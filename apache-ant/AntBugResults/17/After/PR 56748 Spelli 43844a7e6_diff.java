diff --git a/WHATSNEW b/WHATSNEW
index 32932e822..5894c07c7 100644
--- a/WHATSNEW
+++ b/WHATSNEW
@@ -419,4923 +419,4923 @@ Fixed bugs:
  * JUnit4 tests marked @Ignore do not appear in XML output
    Bugzilla Report 43969
 
 Other changes:
 --------------
 
  * merged the ZIP package from Commons Compress, it can now read
    archives using Zip64 extensions (files and archives bigger that 4GB
    and with more that 64k entries).
 
  * a new task <commandlauncher> can be used to configure the
    CommandLauncher used by Ant when forking external programs or new
    Java VMs.
    Bugzilla Report 52706.
 
  * merged the TAR package from Commons Compress, it can now read
    archives using POSIX extension headers and STAR extensions.
 
  * merged the BZIP2 package from Commons Compress, it can now
    optionally read files that contain multiple streams properly.
 
  * <bunzip2> will now properly expand files created by pbzip2 and
    similar tools that create files with multiple bzip2 streams.
 
  * <tar> now supports a new "posix" option for longfile-mode which
    will make it create PAX extension headers for long file names.  PAX
    extension headers are supported by all modern implementations of
    tar including GNU tar.
    This option should now be used in preference to "warn" or "gnu" as
    it is more portable.  For backwards compatibility reasons "warn"
    will still create "gnu" extensions rather than "posix" extensions.
 
  * The ProjectHelper class now exposes a method to be used by third party
    implementations to properly resolve the binding between target extensions
    and extension points.
    Bugzilla Report 53549.
 
  * Make extension point bindable to imported prefixed targets
    Bugzilla Report 53550.
 
  * Add the possibility to register a custom command line argument processor.
    See org.apache.tools.ant.ArgumentProcessor and manual/argumentprocessor.html
 
  * add the possibility to suppress stdout in the sshexec task.
    Bugzilla Report 50270.
 
  * add an encoding attribute to the contains selector.
    This will be useful to use the contains selector if the encoding of the VM is different from the encoding
    of the files being selected.
 
  * support for GNU Classpath.
    Bugzilla report 54760.
 
 Changes from Ant 1.8.3 TO Ant 1.8.4
 ===================================
 
 Fixed bugs:
 -----------
 
  * Ported libbzip2's fallback sort algorithm to CBZip2OutputStream to
    speed up compression in certain edge cases.  Merge from Commons
    Compress.
 
    Using specially crafted inputs this can be used as a denial of
    service attack.
    See http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2098
 
 Changes from Ant 1.8.2 TO Ant 1.8.3
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * The Enumeration returned by AntClassLoader#getResources used to
    return null in nextElement after hasNextElement would return false.
    It has been changed to throw a NoSuchElementException instead so
    that it now adheres to the contract of java.util.Enumeration.
    Bugzilla Report 51579.
 
 Fixed bugs:
 -----------
 
  * Removed buggy duplicate JAR list in RPM mode.
    Bugzilla Report 52556.
 
  * Launcher fixed to pass the right class loader parent.
    Bugzilla Report 48633.
 
  * <junitreport> mishandled ${line.separator}.
    Bugzilla Report 51049.
 
  * <junitreport> did not work in embedded environments on JDK 7.
    Nor did <xslt> when using Xalan redirects.
    Bugzilla Report 51668, 52382.
 
  * Encoding of unicode escape sequences by the property file task
    Bugzilla Report 50515.
 
  * The code that implicitly sets the -source switch if only -target
    has been specified in <javac> was broken for Java 5 and 6.
    Bugzilla Report 50578.
 
  * MailLogger ignore the Maillogger.starttls.enable property.
    Bugzilla Report 50668.
 
  * Delete task example does not work
    Bugzilla Report 50816.
 
  * <splash>'s proxy handling has been delegated to <setproxy>
    internally so the two tasks are consistent.  <splash>'s way of not
    setting a proxy caused problems with other Java libraries.
    Bugzilla Report 50888.
 
  * Include task breaks dependencies or extension-points for multiple
    files.
    Bugzilla Report 50866.
 
  * Read on System.in hangs for forked java task.
    Bugzilla Report 50960.
 
  * FileResource specified using basedir/name attributes was non-functional.
 
  * Resource collection implementation of mapped PropertySet returned
    unusable resources.
 
  * The hasmethod condition failed with a NullPointerException when
    ignoresystemclasses is true and Ant tried to load a "restricted
    class" - i.e. a class that the Java VM will only accept when loaded
    via the bootclassloader (a java.* class).
    It will now fail with a more useful error message.
    Bugzilla Report 51035.
 
  * Exec task may mix the stderr and stdout output while logging it
    Bugzilla Report 50507.
 
  * Missing space between "finished" and timestamp in task/target 
    finish message from ProfileLogger.
    Bugzilla Report 51109.
 
  * Redirecting the output of a java, exec or apply task could print in the
    error output stream some "Pipe broken" errors.
    Bugzilla Report 48789.
 
  * ZipFile failed to clean up some resources which could lead to
    OutOfMemoryException while unzipping large archives.
    A similar problem in ZipArchiveOutputStream has been fixed as well.
    Bugzilla Report 42696.
 
  * quiet attribute added to the copy and move tasks, to be used together
    with failonerror=false, so warnings won't get logged 
    Bugzilla Report 48789.
 
  * System.in was closed and not readable anymore by the DefaultInputHandler 
    when Ant is used via its Java API.
    Bugzilla Report 51161
 
  * <sync> only supported a single non-fileset resource collection even
    though the manual said it could be multiple.
 
  * <sync> didn't work properly when working on resource collections.
    Bugzilla Report 51462.
 
  * <augment> cause a NullPointerException if it was used in a target
    that was invoked by multiple targets from the command line.
    Bugzilla Report 50894.
 
  * The ZipFile class could read past the start of the file if the
    given file is not a ZIP archive and it is smaller than the size of
    a ZIP "end of central directory record".
 
  * <javac> would create the empty package-info.class file in the wrong
    directory if no destdir was specified.  Note it may still pick the
    wrong directory if you specify more than one source directory but
    no destDir.  It is highly recommended that you always explicitly
    specify the destDir attribute.
    Bugzilla Report 51947.
 
  * packagemapper now honors the handleDirSep attribute.
    Bugzilla Report 51086.
 
  * the attributes of macrodef tasks had their values run through
    property expansion twice. Still true by default, but can be disabled.
    Bugzilla Report 42046.
 
  * jvc doesn't like it if source file names in argument files are
    quoted.
    Bugzilla Report 31667.
 
  * ZipFile didn't work properly for archives using unicode extra
    fields rather than UTF-8 filenames and the EFS-Flag.
 
  * Access to DirectoryScanner's default excludes wasn't synchronized.
    Bugzilla Report 52188.
 
  * When a Project instance was created by a custom tasks its
    createTask method didn't work.
    Bugzilla Report 50788.
 
 Other changes:
 --------------
 
  * -f/-file/-buildfile accepts a directory containing build.xml.
 
  * The <javacc>, <jjtree> and <jjdoc> now support a new maxmemory
    attribute.
    Bugzilla Report 50513.
 
  * the documented inputstring attribute of sshexec has been
    implemented and the actually existing attribute inputproperty
    documented.
    Bugzilla Report 50576.
 
  * The concat task now permits the name of its exposed resource
    by means of its 'resourcename' attribute.
 
  * The expandproperties filter now accepts a nested propertyset
    which, if specified, provides the properties for expansion.
    Bugzilla Report 51044.
 
  * <junit filtertrace="true"/> will no longer filter out the very
    first line of the stacktrace containing the original exception
    message even if it matches one of the filter expressions.
 
  * Upgraded to Apache AntUnit 1.2
 
  * Provide read access to Mkdir.dir.  Bugzilla Report 51684.
 
  * <delete> and <move> have a new attribute performGCOnFailedDelete
    that may - when set to true - help resolve some problems with
    deleting empty directories on NFS shares.
    Bugzilla Report 45786.
 
  * <loadfile> and <loadresource> used to log at level INFO to signal a
    property hasn't been set when the resource was empty even if the
    quiet attribute was set to true.  They will now use VERBOSE
    instead.
    Bugzilla Report 52107.
 
  * <javac> has a new attribute createMissingPackageInfoClass that can
    be set to false to prevent Ant from creating empty dummy classes
    used for up-to-date-ness checks.
    Bugzilla Report 52096.
 
  * URLResources#isExists has become less noisy.
    Bugzilla Report 51829.
 
  * The <retry> task has a new optional attribute retryDelay that can
    be used to make the task sleep between retry attempts.
    Bugzilla Report 52076.
 
  * <signjar> has new attributes that control the signature and digest
    algorithms.
    Bugzilla Report 52344.
 
  * Initial support for Java 8.
 
  * <sshexec> can optionally create a pseudo terminal (like ssh -t)
    Bugzilla Report 52554.
 
 Changes from Ant 1.8.1 TO Ant 1.8.2
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Prior to Ant 1.8.0 the <copy> task and several other tasks would
    overwrite read-only destination files.  Starting with 1.8.0 they
    would only do so under special circumstances.  Ant 1.8.2 now
    consistently won't replace a read-only file by default. The same is
    true for a number of other tasks.
    The <copy>, <move> and <echo> tasks now have a new force attribute
    and <concat> has a new forceReadonly attribute that can be used to
    make the task overwrite read-only destinations.
    Bugzilla Report 49261.
 
  * Removed ant-nodeps.jar; it is now merged into ant.jar.
 
  * DOMElementWriter#encode used to employ special code before encoding
    ampersands so that &#123; remained &#123; rather than being turned
    into &amp;#123;.  This is no longer the case, ampersands will now
    be encoded unconditionally.
    Also DOMElementWriter#encodeData will treat CDATA sections containing a
    literal "]]>" sequence different now - it will split the CDATA
    section between the second "]" and ">" and create two sections.
    This affects <echoxml> task as well as the XML logger or JUnit
    formatter where ampersands will now always get encoded.
    In addition DOMElementWriter will now replace the characters \t, \r
    and \n in attribute values by entity references.
    Bugzilla Report 49404.
 
  * The list elements returned by ProjectHelper#getExtensionStack are
    now String arrays of length 3 rather than 2 in order to support the
    onMissingExtensionPoint attribute.
    Bugzilla Report 49473.
 
  * When using <property file="..." prefix="..."/> properties defined
    inside the same file will only get used in expansions if the ${}
    reference uses the same prefix.  This is different from Ant 1.8.1
    but is the same behavior Ant 1.8.0 and earlier exhibited.
    A new attribute prefixValues can be used to re-enable the behavior
    of Ant 1.8.1.
    Bugzilla Report 49373.
 
  * The files and directories used by Git, Mercurial and Bazaar to
    store their information are now excluded by the defaultexcludes.
    Bugzilla Report 49624.
 
  * The <junit> task no longer generates TestListener events - which
    have been introduced in ant 1.7.0 - by default.  The task has a new
    attribute enableTestListenerEvents and a new "magic" property
    ant.junit.enabletestlistenerevents has been added that can be used
    to reinstate the old behavior.
 
 Fixed bugs:
 -----------
 
  * hostinfo now prefers addresses with a hostname over addresses without 
    a hostname, provided the addresses have the same scope.
    For local lookup, no IP address will be put in NAME / DOMAIN anymore.
    For remote lookup, if a host name was provided and only an IP address is 
    found, the IP address will no longer overwrite the host name provided to the
    task.
    Bugzilla Report 49513
 
  * mmap-based file copy problems under JDK 1.4 on Linux.
    Bugzilla Report 49430.
 
  * The Sun JVM tries to mmap the entire file during a copy. 
    For large files this is not feasible. 
    We now explicitly request to copy at most 16 MiB per request.
    Bugzilla Report 49326.
 
  * DemuxInputStream.read() should return unsigned values
    Bugzilla Report 49279.
 
  * The MIME mailer ignored the port parameter when using SSL.
    Bugzilla Report 49267.
 
  * <xslt> ignored the classpath when using the default TraX processor.
    Bugzilla Report 49271.
 
  * <checksum>'s totalproperty only worked reliably if the same file
    name didn't occur inside more than one directory.
    Bugzilla Report 36748.
 
  * <ftp> could fail to download files from remote subdirectories under
    certain circumstances.
    Bugzilla Report 49296.
 
  * <junit> will now produce better diagnostics when it fails to delete
    a temporary file.
    Bugzilla Report 49419.
 
  * Ant would often scan directories even though there were known to
    only hold excluded files when evaluating filesets.  This never
    resulted in wrong results but degraded performance of the scan
    itself.
    Bugzilla Report 49420.
 
  * <javac> failed for long command lines on OS/2.
    Bugzilla Report 49425.
 
  * <junitreport> did not handle encodings well for stdout/stderr.
    Bugzilla Report 49418.
 
  * <junit> could issue a warning about multiple versions of Ant on the
    CLASSPATH if two CLASSPATH entries differed in case on a
    case-insensitive file system.
    Bugzilla Report 49041.
 
  * The <restrict> resource collection was checking every resource even if
    we actually just want the first one, like in the example of use of
    resourcelist in the documentation (getting the first available resource
    from a mirror list).
 
  * A race condition could lead to build failures if multiple <mkdir>
    tasks were trying to create the same directory.
    Bugzilla Report 49572.
 
  * the toString() method of the Resources class - and thus any
    ${toString:} expansion of a reference to a <resources> element -
    didn't iterate over its nested elements if it hadn't done so prior
    to the toString invocation already.
    Bugzilla Report 49588.
 
  * <apply> in parallel mode didn't work together with a nested
    <redirector> if maxparallel was <= 0 (the default) or no source
    files matched.
    Bugzilla Report 49594.
 
  * <jar filesetmanifest="merge"> didn't work for manifests added via
    <zipfileset>s that used the prefix or fullpath attributes.
    Bugzilla Report 49605.
 
  * <tempfile createfile="true"> would cause an error unless the prefix
    attribute has been specified.
    Bugzilla Report 49755.
 
  * If forked, after finished <java> was still reading the input stream
    for a bunch of characters, then stealing them from a following <input>.
    Bugzilla Report 49119.
 
  * Ant could be leaking threads for each forked process (started by
    <exec>, <apply>, <java> or similar tasks) that didn't receive input
    from a resource or string explicitly.
    Bugzilla Report 49587.
 
  * Project#setDefault threw an exception when null was passed in as
    argument, even though the Javadoc says null is a valid value.
    Bugzilla Report 49803.
 
  * runant.py would swallow the first argument if CLASSPATH wasn't set.
    Bugzilla Report 49963.
 
  * <taskdef> failed to load resources from jar files contained in a
    directory that has a "!" in its name.
    Bugzilla Report 50007.
 
  * ant.bat exit strategy improvements and issues
    make the exit codes work in environments where 4NT or MKS are installed
    Bugzilla Report 41039.
 
  * <signjar> would fail if used via its Java API and the File passed
    into the setJar method was not "normalized" (i.e. contained ".."
    segments).
    Bugzilla Report 50081.
 
  * <delete> ignored <fileset>'s errorOnMissingDir attribute
    Bugzilla Report 50124.
 
  * <symlink> failed to close files when reading a list of symbolic
    links from a properties file.
    Bugzilla Report 50136.
 
  * <parallel> could allow tasks to start executing even if a task
    scheduled to run before them timed out.
    Bugzilla Report 49527.
 
  * If a <junit> batch with multiple tests times out Ant logs a message
    about a test named Batch-With-Multiple-Tests since 1.8.0 but the
    logic that determined the Java package of this pseudo-test has been
    wrong.
    Bugzilla Report 45227.
 
  * <propertyfile> didn't preserve the original linefeed style when
    updating a file.
    Bugzilla Report 50049.
 
  * <zip>'s whenEmpty behavior never consulted the non-fileset
    resources so the task could fail even though resources have been
    provided using non-fileset resource collections.
    Bugzilla Issue 50115.
 
 *  ftp chmod could throw a NPE.
    Bugzilla report 50217.
 
 *  The project help (-p option in the command line) will now print
    the dependencies of the targets in debug mode (-d on the command
    line)
 
 Other changes:
 --------------
 
  * <concat>'s force attribute has been deprecated in favor of a new
    overwrite attribute that is consistent with <copy>'s attribute
    names.
 
  * You can now specify a list of methods to run in a JUnit test case.
    Bugzilla Report 34748.
 
  * properties in files read because of the -propertyfile command line
    option will now get resolved against other properties that are
    defined before the project starts executing (those from the same or
    earlier -propertfiles or defined via the -D option).
    Bugzilla Report 18732.
 
  * <pathelement>s can now contain wildcards in order to use wildcard
    CLASSPATH entries introduced with Java6.
    The wildcards are not expanded or even evaluated by Ant and will be
    used literally.  The resulting path may be unusable as a CLASSPATH
    for Java versions prior to Java6 and likely doesn't mean anything
    when used in any other way than a CLASSPATH for a forked Java VM. 
    Bugzilla Report 46842.
 
  * A new attribute allows targets to deal with nonexistent extension
    points, i.e. they can extend an extension-point if it has been
    defined or silently work as plain targets if it hasn't.  This is
    useful for targets that get included/imported in different
    scenarios where a given extension-point may or may not exist.
    Bugzilla Report 49473.
 
  * Ant now logs a warning message if it fails to change the file
    modification time in for example when using <touch> or preserving
    timestamps in various tasks.
    Bugzilla Report 49485.
 
  * ProjectHelpers can now be installed dynamically via the <projecthelper>
    Ant task.
 
  * <import> is now able to switch to the proper ProjectHelper to parse
    the imported resource. This means that several kinds of different build
    files can import each other.
 
  * <copy tofile=""> now also works for non-filesystem resources.
    Bugzilla Report 49756.
 
  * The <linecontainsregexp> filter now supports a casesensitive
    attribute.
 
  * The <containsregexp> selector now supports casesensitive, multiline
    and singleline attributes.
    Bugzilla Report 49764.
 
  * A new <cutdirsmapper> can be used like wget's --cut-dirs option to
    strip leading directories from file names.
 
  * <javah> now supports the GNU project's gcjh compiler.
    Bugzilla Report 50149.
 
  * <checksum> supports additional views of a file's path as elements
    for a custom pattern.
    Bugzilla Report 50114.
 
  * JUnit XMLResultAggregator logs the stack trace of caught IO exceptions
    in verbose runs.
    Bugzilla Report 48836.
 
  * StringUtils.parseHumanSizes() should turn parse failures into
    BuildExceptions.
    Bugzilla Report 48835.
 
  * New task <bindtargets> to make a list of targets bound to some
    specified extension point.
 
  * Initial support for OpenJDK7 has been added.
 
  * Ant now uses java.net.CookieStore rather than
    java.util.ServiceLocator to detect whether the environment is a
    Java 1.6 system.  This means releases of gcj/gij at the time of
    this release of Ant are detected as Java 1.5 and not 1.6.
    Bugzilla Report 50256.
 
  * It is now possible to write a compiler adapter for <javac> that
    compiles sources with extensions other than .java (but that still
    compile to .class files).
    Bugzilla Report 48829.
 
  * The performance of VectorSet#add(Object) has been improved which
    should also benefit any operation that scans directories in Ant.
    Bugzilla Report 50200.
 
 Changes from Ant 1.8.0 TO Ant 1.8.1 
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * ant-trax.jar is no longer produced since TrAX is included in JDK 1.4+.
 
  * Ant no longer ships with Apache Xerces-J or the XML APIs but relies
    on the Java runtime to provide a parser and matching API versions.
 
  * The stylebook ant task and the ant-stylebook.jar are removed.
 
 Fixed bugs:
 -----------
 
  * Tasks that iterate over task or type definitions, references or
    targets now iterate over copies instead of the live maps to avoid
    ConcurrentModificationExceptions if another thread changes the
    maps.
    Bugzilla Report 48310.
 
  * The filesmatch condition threw a NullPointerException when
    comparing text files and the second file contained fewer lines than
    the first one.
    Bugzilla Report 48715.
 
  * Regression: The <ear> task would allow multiple
    META-INF/application.xml files to be added.
    Bugzilla Report 6836.
 
  * VectorSet#remove(Object) would fail if the size of the vector
    equaled its capacity.
 
  * Regression : ant -diagnostics was returning with exit code 1
    Bugzilla Report 48782
 
  * Fix for exec task sometimes inserts extraneous newlines
    Bugzilla Report 48746
 
  * SymlinkTest#testSymbolicLinkUtilsMethods failing on MacOS
    Bugzilla Report 48785.
 
  * If <concat>'s first resourcecollection child is a <resources>,
    any subsequently added child resourcecollection joins the first.
    Bugzilla Report 48816.
 
  * <get> with an invalid URL could trigger an NPE in some JVMs.
    Bugzilla Report 48833
 
  * Broken Pipe issue under Ubuntu Linux
    Bugzilla Report 48789
 
  * Properties wrongly read from file or not update during read
    Bugzilla Report 48768
 
  * AntClassLoader in Ant 1.8.0 has been considerably slower than in
    1.7.1
    Bugzilla Report 48853
 
  * ANT_CMD_LINE_ARGS are rippling through lower level Ant usage 
    Bugzilla Report 48876
 
  * email : IO error sending mail with plain mimetype
    Bugzilla Report 48932
 
  * the complete-ant-cmd.pl script failed to create a proper cache of
    target if "ant -p" failed.
    Bugzilla Report 48980
 
  * <rmic>'s sourcebase attribute was broken.
    Bugzilla Report 48970
 
  * <copy>'s failonerror didn't work as expected when copying a single
    element resource collection to a file.
    Bugzilla Report 49070
 
  * <get> no longer followed redirects if the redirect URL was relative
    and not an absolute URL.
    Bugzilla Report 48972
 
  * fixed a performance degradation in the code that expands property
    references.
    Bugzilla Reports 48961 and 49079
 
  * <jar filesetmanifest="merge"> was broken on Windows.
    Bugzilla Report 49090
 
  * <symlink> delete failed if the link attribute was a relative path
    to a link inside the current directory without a leading ".".
    Bugzilla Report 49137
 
  * <telnet> and <rexec> failed to find the expected strings when
    waiting for responses and thus always failed.
    Bugzilla Report 49173
 
 Other changes:
 --------------
 
  * Project provides new get methods that return copies instead of the
    live maps of task and type definitions, references and targets.
 
  * Ant is now more lenient with ZIP extra fields and will be able to
    read archives that it failed to read in earlier versions.
    Bugzilla Report 48781.
 
  * The <zip> family of tasks has been sped up for bigger archives.
    Bugzilla Report 48755.
 
  * Add removeKeepExtension option to NetRexxC task.
    Bugzilla Report 48788.
 
  * Add prefix attribute to loadproperties task.
 
  * Add resource attribute to length task.
 
  * PropertyResource will effectively proxy another Resource if ${name}
    evaluates to a Resource object.
 
  * Added forcestring attribute to equals condition to force evaluation
    of Object args as strings; previously only API-level usage of the
    equals condition allowed Object args, but Ant 1.8.x+ property
    evaluation may yield values of any type.
 
  * BuildFileTest.assertPropertyUnset() fails with a slightly more 
    meaningful error message
    Bugzilla Report 48834
 
  * <junit> will now throw an exception if a test name is empty.  This
    used to manifest itself in unrelated errors like
    Bugzilla Report 43586.
 
  * A change that made <exec> more reliable on Windows (Bugzilla Report
    5003) strongly impacts the performance for commands that execute
    quickly, like attrib.  Basically no single execution of a command
    could take less than a second on Windows.
    A few timeouts have been tweaked to allow these commands to finish
    more quickly but still they will take longer than they did with Ant
    1.7.1.
    Bugzilla Report 48734.
 
  * Added SimpleBigProjectLogger, intermediate between NoBannerLogger and
    BigProjectLogger.
 
  * <mappedresources> supports new attributes enablemultiplemappings
    and cache.
 
  * Added the augment task to manipulate existing references via Ant's basic
    introspection mechanisms.
 
 Changes from Ant 1.8.0RC1 TO Ant 1.8.0
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * the appendtolines filter has been renamed to suffixlines.
 
 Fixed bugs:
 -----------
 
  * stack traces were not reported at all by <junit/>
    when filtertrace="on", which is the default.
 
  * ant.bat can now also process the -noclasspath switch when it is 
    the first switch on a command line.
    Bugzilla Report 48186.
 
  * <fixcrlf> now tries to delete the created temporary files earlier.
    Bugzilla Report 48506.
 
  * the implementation of <zip> had been changed in a way that broke
    the jarjar links task and protentially other third-party subclasses
    as well.
    Bugzilla Report 48541.
 
  * <scp> task didn't report build file location when a remote operation failed
    Bugzilla Report 48578.
 
  * <propertyfile> would add the same comment and a date line each time
    it updated an existing property file.
    Bugzilla Report 48558.
 
  * <sound> didn't work properly in recent Java VMs.
    Bugzilla Report 48637.
 
 Other changes:
 --------------
 
 Changes from Ant 1.7.1 TO Ant 1.8.0RC1
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * if and unless attributes (on <target> as well as various tasks and other
    elements) have long permitted ${property} interpolation. Now, if the result
    evaluates to "true" or "false" (or "yes", "no", "on", "off"), that boolean
    value will be used; otherwise the traditional behavior of treating the value
    as a property name (defined ~ true, undefined ~ false) is used. Existing
    scripts could be broken if they perversely defined a property named "false"
    and expected if="false" to be true, or used if="true" expecting this to be
    triggered only if a property named "true" were defined.
 
  * Ant now requires Java 1.4 or later.
 
  * Improved handling of InterruptException (lets suppose someone/thing
    is trying to kill the thread when we receive an
    InterruptException), when an InterruptException is received, we do
    not wait anymore in a while loop till the end time has been
    reached.
    Bugzilla Report 42924.
 
  * Refactor PropertyHelper and introspection APIs to make extension
    more granular and support setting task/type attribute values to
    objects decoded by custom PropertyEvaluator delegates. Also add
    <propertyhelper> task for registering delegates and/or replacing
    the registered PropertyHelper instance.
    Bugzilla Report 42736.
 
  * Added a restricted form of typedef called <componentdef>. This
    allows definition of elements that can only be within tasks or
    types. This method is now used to define conditions, selectors,
    comparators and filterreaders. This means that tasks may now have
    nested conditions just by implementing the Condition interface,
    rather than extending ConditionBase. It also means that the use of
    namespaces for some of the selectors introduced in Ant 1.7.0 is no
    longer necessary.  Implementing this means that the DynamicElement
    work-around introduced in Ant 1.7.0 has been removed.
    Bugzilla Report 40511.
 
  * In the <touch> task when a <mapper> is used, the millis and
    datetime attributes now override the time of the source resource if
    provisioned.
    Bugzilla Report 43235.
 
  * Remove fall-back mechanism for references that are not resolved
    during normal runtime execution.
 
  * FileUtils.createTempFile now actually creates the file.
    The TempFile task still does not create the file by default, can be
    instructed to do so however using a new parameter.
    Bugzilla Report 33969.
 
  * A lock in Project ensured that a BuildListener's messageLogged
    method was only ever executed by a single thread at a time, while
    all other methods could be invoked by multiple threads
    simultaniously (while within <parallel>, for example).  This lock
    is no longer in place, messageLogged should be made thread-safe
    now.
 
  * <sql>'s onError="stop" no longer fails the build if an error
    occurs,  this is the main difference between stop and error and
    matches what the documentation implied.
    Bugzilla Report 24668.
 
  * Ant's configuration introspection mechanisms have been modified to prefer
    Resource and FileProvider attributes to plain java.io.File attributes;
    however the configuration-from-String behavior remains equivalent, rendering
    a FileResource.
 
  * CBZip2InputStream will now throw an IOException if
    passed in a null or empty InputStream to read from.
    Bugzilla Reports 32200.
 
  * <unzip> will now fail when trying to extract certain broken
    archives that would have been silently ignored in earlier version.
    Bugzilla Report 35000.
 
  * Ant's <zip> family of tasks tries to preserve the existing Unix
    permissions when updating archives or copying entries from one
    archive to another.
    Since not all archiving tools support storing Unix permissions in
    the same way that is used by Ant, sometimes the permissions read by
    Ant seem to be 0, which means nobody is allowed to do anything to
    the file or directory.
    If Ant now encounters a permission set of 0 it will assume that
    this is not the intended value and instead apply its own default
    values.  Ant used to create entries with 0 permissions itself.
    The <zip> family of tasks has a new attribute preserve0permissions
    that can be set to restore the old behavior.
    Bugzilla Report 42122.
 
  * If a batch containing multiple JUnit tests running inside a forked
    Java VM caused the VM to crash (or caused a timeout), the
    formatters would receive an error message for the last test in the
    batch.
    Ant will now pass in a test with the name "Batch-With-Multiple-Tests"
    instead - this is supposed to show more clearly that the last test
    may not have started at all.
    Bugzilla Report 45227.
 
  * If the number of minutes a build takes is bigger then 1000 Ant will
    no longer print a thousands separator in the "elapsed time"
    message.  It used to be the thousands separator of the current
    locale.
    Bugzilla Report 44659.
 
  * <symlink action="delete"> used to fail if the link was broken (i.e.
    pointing to a file or directory that no longer existed).  It will now
    silently try to remove the link.
    Bugzilla Report 41285.
 
  * <delete file="..."> used to log a warning and not delete broken
    symbolic links.  <delete dir="..."/> didn't even log a warning.
    The task will now try to delete them in both cases.
    Bugzilla Report 41285.
 
  * if the dir attribute of a <fileset> points to a symbolic link and
    followsymlinks is set to false, the fileset will no longer be
    scanned and always seem empty.
    Bugzilla Report 45741.
 
  * the .NET tasks that have been deprecated since Ant 1.7.0 have been
    removed, please use the stand-alone Antlib you can find at
    http://ant.apache.org/antlibs/dotnet/index.html
    instead.
 
  * the logic of closing streams connected to forked processes (read
    the input and output of <exec> and friends) has been changed to
    deal with cases where child processes of the forked processes live
    longer than their parents and keep Ant from exiting.
    It is unlikely but possible that the changed logic breaks stream
    handling on certain Java VMs.
    Bugzilla issue 5003.
 
  * <checksum>'s totalproperty was platform dependent because it relied
    on java.io.File#compareTo.  It has now been made platform
    independent, which means that totalPropery values obtained on
    Windows (and other systems where the sort order of File is not case
    sensitive) can be different from the values obtained with earlier
    versions of Ant.
    Bugzilla Report 36748.
 
  * globmapper didn't work properly if the "to" or "from" patterns
    didn't contain a "*".  In particular it implicitly added a * to the
    end of the pattern(s).  This is no longer the case.  If you relied
    on this behavior you will now need to explicitly specify the
    trailing "*".
    Bugzilla Report 46506.
 
  * <copy> silently ignored missing resources even with
    failOnError="true".  If your build tries to copy non-existent
    resources and you relied on this behavior you must now explicitly
    set failOnError to false.
    Bugzilla Report 47362.
 
  * Ant now prefers the java.runtime.version system property over
    java.vm.version for the Created-By Manifest attribute.
    Bugzilla Report 47632.
 
  * The <image> task now supports a nested mapper.  In order to
    implement this, the Java API of the task had to change so any
    custom subclass overriding the processFile method will need to
    adapt (by overriding the new two-arg processFile method).
    Bugzilla Report 23243.
 
  * A new property syntax can be used to set attributes from
    references: ${ant.ref:some-reference}
 
    In most cases this will yield the exact same result as 
    ${toString:some-reference} - only when an attribute setter method
    accepts an object type other than string and the project's
    reference is an Object of matching type the new syntax will pass in
    that object.
 
    If your build file already contains properties whose name starts
    with "ant.ref:" there is a potential for collision.  If your
    property has been set, normal property expansion will take
    precedence over the new syntax.  If the property has not been set
    and a reference with the postfix of your property name exists
    (i.e. in a very unlikely event) then the new syntax would yield a
    different result (an expanded property) than Ant 1.7.1 did.
 
  * A ProjectHelper implementation can now provide the default build file
    name it is expecting, and can specify if they can support a specific build
    file. So Ant is now capable of supporting several ProjectHelper
    implementations, deciding on which to use depending of the input build file.
 
  * Mapper-aware selectors (depends, different, present) now accept typedef'd
    FileNameMappers.
 
 Fixed bugs:
 -----------
 
  * The default logger was failing to print complete stack traces for
    exceptions other than BuildException when inside <ant> or
    <antcall>, thus omitting often important diagnostic
    information.
    Bugzilla 43398 (continued).
 
  * Better handling of package-info.class.
    Bugzilla Report 43114.
 
  * RPM task needed an inserted space between the define and the value.
    Bugzilla Report 46659.
 
  * Got rid of deadlock between in, out and err in the Redirector. 
    Bugzilla Report 44544.
 
  * Caused by AssertionError no longer filtered.
    Bugzilla Report 45631.
  
  * <zip> would sometimes recreate JARs unnecessarily.
    Bugzilla Report 45902.
 
  * <symlink> task couldn't overwrite existing symlinks that pointed to
    nonexistent files
    Bugzilla Report 38199.
 
  * <symlink> task couldn't overwrite files that were in the way of the symlink.
    Bugzilla Report 43426.
 
  * <symlink> task failonerror="false" does not stop build from failing
    when 'ln' command returns non-zero.
    Bugzilla Report 43624
 
  * <touch> task couldn't differentiate between "no resources
    specified" and "no resources matched."
    Bugzilla Report 43799.
 
  * ManifestClassPath failed when a relative path would traverse the
    file system root.
    Bugzilla Report 44499.
 
  * <globmapper> had an indexoutofbounds when the prefix and postfix
    overlapped.
    Bugzilla Report 44731.
 
  * <typedef> and <taskdef> failed to accept file names with #
    characters in them.
    Bugzilla Report 45190
 
  * A deadlock could occur if a BuildListener tried to access an Ant property
    within messageLogged while a different thread also accessed one.
    Bugzilla Report 45194
 
  * Handle null result of system getProperty() in CommandlineJava.
    Similar to Bugzilla Report 42334.
 
  * Length task did not process nonexistent Resources even though these might
    conceivably still carry file length information.
    Bugzilla Report 45271.
 
  * <javac>'s includeJavaRuntime="false" should work for gcj now.  Note
    that you may need to set includeAntRuntime to false in order to
    have full control.
    Bugzilla Report 34638.
 
- * <sql> would fail if the executed statment didn't return a result
+ * <sql> would fail if the executed statement didn't return a result
    set with some JDBC driver that dissalow Statement.getResultSet to
    be called in such a situation.
    Bugzilla Report 36265 
 
  * if the executed statement in <sql> returned a result set and an
    update count, the count would be lost.
 
  * if an executed statement in <sql> mixes update count and result set
    parts, some result sets wouldn't get printed.
    Bugzilla Report 32168.
 
  * XmlLogger could lose messages if <parallel> is used.
    Bugzilla Report 25734.
 
  * <scp> creates remoteToDir if it doesn't exist.
    Bugzilla Report 42781
 
  * CBZip2OutputStream threw an exception if it was closed prior to
    writing anything.
    Bugzilla Reports 32200, 45836
 
  * The IPlanetDeploymentTool didn't use the configured DTD locations.
    Bugzilla Report 31876.
 
  * The ant shell script printed a warning under Cygwin if JAVA_HOME
    was not set.
    Bugzilla Report 45245.
 
  * <filterset> sometimes incorrectly flagged infinite recursions of
    filter tokens
    Bugzilla Report 44226.
 
  * failures were treated as errors in forked JUnit tests when JUnit 4
    was used.
    Bugzilla Report 43892.
 
  * <jar> and <manifest> disallowed manifest attributes whose name
    contained the character '8'.
    Bugzilla Report 45675.
 
  * BigProjectLogger would set the project's basedir to the current
    working directory.
    Bugzilla Report 45607.
 
  * only <formatter>s that logged to a file were notified if forked VM
    crashed or a timeout occurred in <junit>.
    Bugzilla Report 37312.
 
  * ant -v -version would print the version information twice.
    Bugzilla Report 45695.
 
  * when nested into builds that have been invoked by <ant> tasks
    <subant> might set the wrong basedir on the called projects.
    Bugzilla Report 30569.
 
  * If the message of the failed assertion of a forked JUnit test
    contained line feeds some excess output ended up in Ant's log.
    Bugzilla Report 45411.
 
  * <symlink action="delete"> failed to delete a link that pointed to
    a parent directory.
    Bugzilla Report 45743.
 
  * <symlink action="delete"> failed if ant lacked permission to rename
    the link's target.
    Bugzilla Report 41525.
 
  * when checking whether a jar is signed, <signjar> ignored the
    sigfile attribute.
    Bugzilla Report 44805.
 
  * When using JavaMail all <mail> tasks used the same mail host
    regardless of their configuration.
    Bugzilla Report 37970.
 
  * <signjar> and <issigned> didn't handle aliases with characters other
    than numbers, letters, hyphen or underscore properly.
    Bugzilla Report 45820.
 
  * <filterset> could miss multi-character begin tokens in some cases.
    Bugzilla Report 45094.
 
  * <depend> didn't close JARs that were part of the classpath.
    Bugzilla Report 45955.
 
  * in some cases <depend> would delete class files even if it didn't
    find the corresponding source files.
    Bugzilla Report 45916.
 
  * <javadoc> failed if the nested <bottom> or <head> contained line
    breaks.
    Bugzilla Report 43342.
 
  * encoding="auto" has been broken in <mail> since Ant 1.7.0 and only
    worked if JavaMail was available.
    Bugzilla Report 42389.
 
  * MailLogger could cause a NullPointerException.
    Bugzilla Report 44009.
 
  * <junit> didn't recognize failed assertions as failures if they
    caused subclasses of AssertionError to be thrown (like
    org.junit.ComparisonFailure that is thrown when assertEquals
    fails).
    Bugzilla Report 45028.
 
  * the Unix "ant" wrapper script failed to protect wildcards in
    command line arguments in some cases.
    Bugzilla Report 31601.
 
  * <cvstagdiff> crippled file names and could miss some entries if
    multiple modules have been specified.
    Bugzilla Report 35301.
 
  * Tasks with a "public void add(SomeType)" method failed to work as
    TaskContainers at the same time.
    Bugzilla Report 41647.
 
  * Tasks that implementes DynamicElemen or DynamicElementNS failed to
    work as TaskContainers at the same time.
    Bugzilla Report 41647.
 
  * combining SSL and authentication in <mail> and MailLogger failed in
    some setups.
    Bugzilla Report 46063.
 
  * if an error occurs while logging the buildFinished event, the
    original error is now logged to System.err.
    Bugzilla Report 25086.
 
  * <copy> failed with a NullPointerException when copying a resource
    without a name.  It will now fail with a meaningful error message.
    Bugzilla Report 39960.
 
  * <xslt> now uses the configured classpath to load the factory (when
    using TraX) before falling back to Ant's own classpath.
    Bugzilla Report 46172.
 
  * <dependset> complained about files being modified in the future if
    they had been just very recently (within Ant's assumed granularity
    of the file system).
    Bugzilla Report 43665.
 
  * <sshexec> didn't store the output in outputproperty if the remote
    command failed.
    Bugzilla Report 46340.
 
  * DirectoryScanner's slow-scanning algorithm that is used when you
    ask for excluded or not-included files and/or directories could
    miss some files and directories in the presence of recursive
    exclude patterns.
 
  * <sort> resource collection kept only one of entries deemed equal by
    the chosen Comparator.
    Bugzilla Report 46527.
 
  * the ZipFile class used by <unzip> and others could leave the
    archive open (making it undeletable on Windows as long as the java
    VM was running) for files with an unexpected internal structure.
    Bugzilla Report 46559.
 
  * The zip package now supports the extra fields invented by InfoZIP
    in order to store Unicode file names and comments.
 
  * The zip package detects the encoding bit set by more modern
    archivers when they write UTF-8 filenames and optionally sets it
    when writing zips or jars.
    Bugzilla Report 45548
 
  * <sync> could run into a NullPointerException when faced with broken
    symbolic links.
    Bugzilla Report 46747.
 
  * The ant shell script should now support MSYS/MinGW as well.
    Bugzilla Report 46936.
 
  * <signjar> has a new force attribute that allows re-signing of jars
    that are already signed.
    Bugzilla Report 46891.
 
  * <sshexec> now again honors failonerror in the face of connection
    errors.
    Bugzilla Report 46829.
 
  * The <replacetokens> filter threw an exception if the stream to
    filter ended with a begin token.
    Bugzilla Report 47306.
 
  * <scriptmapper>, <scriptfilter> and <scriptcondition> didn't support
    the setbeans attribute.
    Bugzilla Report 47336.
 
  * <loadproperties>' encoding attribute didn't work.
    Bugzilla Report 47382.
 
  * Ant created tar archives could contain random bytes at the end
    which confused some untar implementations.
    Bugzilla Report 47421.
 
  * various places where unchecked PrintWriters could hide exceptions
    have been revisited to now check the error status or not use a
    PrintWriter at all.
    Bugzilla Report 43537.
 
  * filesetmanifest="mergewithoutmain" in <jar> didn't treat inline
    manifests as expected.
    Bugzilla Report 29731.
 
  * <record> didn't work properly with nested builds.
    Bugzilla Report 41368. 
 
  * <jar> with filesetmanifest different from skip didn't work if the
    update attribute has been set to true.
    Bugzilla Report 30751.
 
  * The default stylesheets for <junitreport> failed to properly escape
    XML content in exception stack traces.
    Bugzilla Report 39492.
 
  * AntClassLoader didn't set the proper CodeSource for loaded classes.
    Bugzilla Report 20174.
 
  * AntClassLoader.getResourceAsStream would return streams to
    resources it didn't return with getResource and to classes it
    failed to load.
    Bugzilla Report 44103.
 
  * Logging exceptions without a message would cause a
    NullPointerException.
    Bugzilla Report 47623.
 
  * WeblogicDeploymentTool could fail on platforms with a file
    separator other than "/".
    Bugzilla Report 35649.
 
  * The update attribute of the modified selector was ignored.
    Bugzilla Report 32597.
 
  * <manifest> and <jar> can now merge Class-Path attributes from
    multiple sources and optionally flatten them into a single
    attribute.
    The default behaviour still is to keep multiple Class-Path
    attributes if they have been specified and to only include the
    attributes of the last merged manifest.
    Bugzilla Report 39655.
 
  * <delete> didn't work correctly with a <modified> selector because
    it was scanning the same filesets more than once.
    Bugzilla Report 43574.
 
  * when using custom filterreaders with the <filterreader classname="">
    syntax Ant could leak memory.
    The problem didn't occur when using <typedef> or <componentdef> to
    define the filterreader which is the recommended approach.
    Bugzilla Report 45439.
 
  * Ant didn't set the proper "magic" value for tar entries containing
    long file names in GNU longfile mode.
    Bugzilla Report 47653.
 
  * The tar task failed to recognize that the archive had to be
    (re-)created in some cases where the sources are filesystem based
    resources but not filesets.
    Bugzilla Report 48035. 
 
  * <sshexec>'s outputproperty was prefixed by the executed command
    when the command attribute has been used, breaking backwards
    compatibility to Ant 1.7.0.
    Bugzilla Report 48040.
 
  * different task instances of the same <scriptdef>ed tasks could
    overwrite each others attributes/nested elements.
    Bugzilla Report 41602.
 
  * The Hashvalue algortihm implementation of the modified task could
    fail to read the file(s) completely.
    Bugzilla Report 48313.
 
 Other changes:
 --------------
 
  * The get task now also follows redirects from http to https
    Bugzilla Report 47433
 
  * A HostInfo task was added performing information on hosts, including info on 
    the host ant is running on. 
    Bugzilla Reports 45861 and 31164.
 
  * There is now a FileProvider interface for resources that act as a source
    of filenames. This should be used by tasks that require resources
    to provide filenames, rather than require that all resources
    are instances or subclasses of FileResource.
    Bugzilla Report 43348
 
  * There is now a URLProvider interface for resources that act as a
    source of URLs. This should be used by tasks that require resources
    to provide URLs, rather than require that all resources are
    instances or subclasses of URLResource.
 
  * Fixcrlf now gives better error messages on bad directory attributes.
    Bugzilla Report 43936
 
  * a new property ant.project.default-target holds the value of the
    current <project>'s default attribute.
 
  * a new property ant.project.invoked-targets holds a comma separated
    list of the targets that have been specified on the command line
    (the IDE, an <ant> task ...) when invoking the current project.
 
  * The <type> resource selector has had an "any" type added for better
    configurability.
 
  * Ant should detect the OS as both a Mac and a Unix system when
    running on OpenJDK.
    Bugzilla Report 44889.
 
  * new protected getConnection and getStatement methods allow
    subclasses of SQLExec more control - or access to the cached
    instances when overriding other methods like runStatements.
    Bugzilla Report 27178.
 
  * <sql> has a new failOnConnectionError attribute that can be used to
    keep a build going even if the task failed to connect to the
    database.
    Bugzilla Report 36712.
 
  * A new attribute strictDelimiterMatching can be used to ignore case
    or whitespace differences when <sql> searches for delimiters.
    This is useful if you execute a SQL script that has contains "GO"
    and "go" as delimiters.
    Bugzilla Report 26459.
 
  * A new showWarnings attribute of <sql> allows warnings to be logged.
    Bugzilla Report 41836.
 
  * A new treatWarningsAsErrors attribute of <sql> can be used to fail
    a build if a warning occurs.
    Bugzilla Report 41836.
 
  * Ant now supports scoped properties (see Local task).
    Bugzilla Report 23942.
 
  * <sql>'s CSV output can be controlled via the new attributes
    csvColumnSeparator and csvQuoteCharacter.
    Bugzilla Report 35627.
 
  * <ftp>'s logging has been improved.
    Bugzilla Reports 30932, 31743.
 
  * It is now possible to disable <ftp>'s remote verification.
    Bugzilla Report 35471.
 
  * <sshexec> now supports input in a way similar to <exec>
    Bugzilla Report 39197.
 
  * <scp> can now preserve the file modification time when downloading
    files.
    Bugzilla Report 33939.
 
  * the new task sshsession can run multiple tasks in the presence of
    an SSH session providing (local and remote) tunnels.
    Bugzilla Report 43083.
 
  * ZipOutputStream has been sped up for certain usage scenarios that
    are not used by Ant's family of zip tasks.
    Bugzilla Report 45396.
 
  * <echo> supports an "output" Resource attribute as an alternative to "file".
 
  * <sql> "output" attribute now supports any Resource in addition to a file.
 
  * <scp> no longer requires a passphrase when using key based
    authentication.
    Bugzilla Report 33718.
 
  * a new failOnEmptyArchive attribute on <unzip> and <untar> can now
    make the task fail the build if it tries to extract an empty
    archive.
 
  * <unzip> and <untar> have a new attribute stripAbsolutePathSpec.
    When set to true, Ant will remove any leading path separator from
    the archived entry's name before extracting it (making the name a
    relative file name).
    Bugzilla Report 28911.
 
  * <unzip> will now detect that it was asked to extract a file that is
    not an archive earlier if the file is big.
    Bugzilla Report 45463.
 
  * New file and resource selectors <readable/> and <writable/> have
    been added that select file which the current process can read or
    write.
    Bugzilla Report 45081.
 
  * The filename file selector has a new attribute regex that allows
    files to be selected by matching their names against a regular
    expression.
    Bugzilla Report 45284
 
  * The name resource selector has a new attribute regex that allows
    resources to be selected by matching their names against a regular
    expression.
    Bugzilla Report 45284
 
  * Enhanced performance of Project.fireMessageLoggedEvent and DirectoryScanner 
    Bugzilla Reports 45651 and 45665
 
  * The package list location for offline links can now be specified as
    an URL.
    Bugzilla Report 28881
 
  * <echoxml> now supports XML namespaces.
    Bugzilla Report 36804.
 
  * A new listener for <junit> has been added that tries to invoke the
    tearDown method of a TestCase if that TestCase was run in a forked
    VM and the VM crashed or a timeout occurred.  See the <junit> task's
    manual page for details.
    Bugzilla Report 37241.
 
  * The Jar task now supports the addition of a jar index file in update mode.
    Previously the absence of the index was not enough to trigger the rebuild;
    some other update was necessary.
    Bugzilla report 45098.
 
  * <ant> has a new attribute "useNativeBasedir" that makes the child
    build use the same basedir it would have used if invoked from the
    command line.  No matter what other attributes/properties have been
    set.
    Bugzilla Report 45711.
 
  * <patch> has a new optional failOnError attribute.
    Bugzilla Report 44772.
 
  * Antlib descriptors will now be parsed by the configured
    ProjectHelper if the implementation overrides the new
    canParseAntlibDescriptor and parseAntlibDescriptor methods.  If the
    configured helper doesn't override the methods, a new instance of
    ProjectHelper2 will be used just like in Ant 1.7.1.
    Bugzilla Report 42208.
 
  * It is now possible to explicitly set the executable used by
    <signjar>.
    Bugzilla Report 39189.
 
  * <compositemapper>'s order of results is now predictable.
    Bugzilla Report 44873
 
  * a new <firstmatchmapper> has been added, which works similar to
    <compositemapper> but only returns the results of the first nested
    mapper that matches.
    Bugzilla Report 44873
 
  * <get> has a new maxtime attribute that terminates downloads that
    are taking too long.
    Bugzilla Report 45181.
 
  * <ftp> now supports selectors for remote directories as well.
    Bugzilla Report 44726.
 
  * In some cases Ant fails to rename files if the source or target
    file has just recently been closed on Windows.  It will now try to
    delete the offending file once again after giving the Java VM time
    to really close the file.
    Bugzilla Report 45960.
 
  * two new properties can be used to set the MIME-Type and charset
    used by MailLogger.
    Bugzilla Report 27211.
 
  * a new attribute of <mail> allows the task to succeed if it can
    reach at least one given recipient.
    Bugzilla Report 36446.
 
  * two new properties allow MailLogger to send a fixed text instead of
    the log file.
    Bugzilla Report 38029.
 
  * <cvsversion> is supposed to support CVSNT now.
    Bugzilla Report 31409.
 
  * <cvs>' port attribute should now work for all clients that use the
    environment variable CVS_PSERVER_PORT instead of the "official"
    CVS_CLIENT_PORT.
    Bugzilla Report 30124.
 
  * <cvsversion> now works for local repositories as well.
 
  * <cvstagdiff> has an option to ignore removed files now.
    Bugzilla Report 26257.
 
  * <cvs> and friends now support modules with spaces in their names
    via nested <module> elements.
 
  * A new attribute "ignoreEmpty" controls how <concat> deals when
    there are no resources to concatenate.  If it is set to false, the
    destination file will be created regardless, which reinstates the
    behavior of Ant 1.7.0.
    Bugzilla Report 46010.
 
  * If the new remote attribute is set to true, <cvschangelog> can now
    work against a remote repository without any working copy.
    Bugzilla Report 27419.
 
  * start and end tags can now be used instead of dates in
    <cvschangelog>.
    Bugzilla Report 27419.
 
  * MailLogger and <mail> can now optionally enable support for
    STARTTLS.
    Bugzilla Report 46063.
 
  * <import> has new attributes "as" and "prefixSeparator" that can be
    used to control the prefix prepended to the imported targets'
    names.
 
  * a new task <include> provides an alternative to <import> that
    should be preferred when you don't want to override any targets.
 
  * delete has a new attribute removeNotFollowedSymlink.  If set to
    true, symbolic links not followed (because followSymlinks was false
    or the number of symlinks was too big) will be removed.
    Bugzilla Report 36658.
 
  * the os and osfamily attributes of <chown>, <chgrp>, <chmod> and
    <attrib> can now be used to run the commands on operating systems
    other than their "native" environment, i.e. non-Unix or non-Windows
    operating systems respectively.
    Bugzilla Report 7624.
 
  * a new resource collection <mappedresources> generalizes the prefix
    and fullpath attributes of <zipfileset> to arbitrary mappers that
    can be applied to arbitrary resource collections.
    Bugzilla Report 4240.
 
  * <tarfileset> and <zipfileset> have a new attribute
    errorOnMissingArchive that allows "optional" filesets that don't
    break the build if the archive doesn't exist.
    Bugzilla Report 46091.
 
  * <javadoc> has new attributes that correspond to the
    -docfilessubdirs and -excludedocfilessubdir command line arguments.
    Bugzilla Report 34455.
 
  * <xslt> now fails early if a specified stylesheet doesn't exist.
    Bugzilla Report 34525.
 
  * <xslt> now has an option to suppress transformer warnings.  This
    option only has an effect for processors that support this feature;
    the "trax" processor included with Ant does support it.
    Bugzilla Report 18897.
 
  * <xslt> has two new attributes failOnError and
    failOnTransformationError that can be used to not make the build
    process proceed if an error occurs.
    Bugzilla Report 36260.
 
  * <xslt> has a new attribute failOnNoResources that can be used to 
    make the build fail/continue if the collection of resources to
    transform is empty.
    Bugzilla Report 46274.
 
  * It is now possible to define system properties that should be set
    during xslt's transformation.  This can be used to enable XInclude
    processing in Xerces, for example.
    Bugzilla Report 36653.
 
  * a new resource collection <archives> can be used to specify
    collections of ZIP and TAR archives as sources.  It extracts them on
    the fly.  This is a generalization of the <zipgroupfileset> found
    as nested element of <zip> and friends.
    Bugzilla Report 46257.
 
  * <dependset> has a new verbose attribute that makes the task list
    all deleted targets and give a hint as to why it deleted them.
    Bugzilla Report 13681.
 
  * <replaceregexp> now supports arbitrary filesystem based resource
    collections.
    Bugzilla Report 46341.
 
  * <replace> now supports arbitrary filesystem based resource
    collections.
    Bugzilla Report 24062.
 
  * token and value of <replace>'s nested <replacefilter> can now also
    be specified as nested elements to allow multiline content more
    easily.
    Bugzilla Report 39568.
 
  * <replace> and <replaceregexp> can now optionally preserve the file
    timestamp even if the file is modified.
    Bugzilla Report 39002.
 
  * The <replace> child-elements <replacetoken> and <replacevalue> have
    a new attribute that controls whether properties in nested text get
    expanded.
    Bugzilla Report 11585.
 
  * <replace> has a new attribute failOnNoReplacements that makes the
    build fail if the task didn't do anything.
    Bugzilla Report 21064.
 
  * <sync>'s <preserveInTarget> has a new attribute that controls
    whether empty directories should be kept.
    Bugzilla Report 43159.
 
  * ant -diagnostics now checks that it can read as much from the
    temporary directory as it has written.  This may help detecting a
    full filesystem.
    Bugzilla Report 32676.
 
  * <pathconvert> has a new preserveduplicates attribute--historically
    these were eliminated in the interest of behaving in the manner
    of a "path."
 
  * <javac>'s source and target attributes are no longer ignored when
    using gcj.
    Bugzilla Issue 46617.
 
  * ant -diagnostics now outputs information about the default XSLT
    processor.
    Bugzilla Issue 46612.
 
  * the ZIP library will now ignore ZIP extra fields that don't specify
    a size.
    Bugzilla Report 42940.
 
  * CBZip2OutputStream now has a finish method separate from close.
    Bugzilla Report 42713.
 
  * the <zip> and <unzip> family of tasks has new options to deal with
    file name and comment encoding.  Please see the zip tasks'
    documentation for details.
 
  * <input ...><handler type="secure" /></input> now uses previously
    undocumented SecureInputHandler shipped with Ant 1.7.1.
 
  * Command line arguments for <exec> and similar tasks can now have
    optional prefix and suffix attributes.
    Bugzilla Report 47365
 
  * <apply>'s srcfile and targetfile child elements can now have
    optional prefix and suffix attributes.
    Bugzilla Report 45625
 
  * <jar> has a new attribute to enable indexing of META-INF
    directories which is disabled for backwards compatibility reasons.
    Bugzilla Report 47457
 
  * <apt>'s executable attribute can be used to specify a different
    executable.
    Bugzilla Report 46230.
 
  * <rmic>'s new executable attribute can be used to specify a
    different executable.
    Bugzilla Report 42132.
 
  * <javac>, <rmic>, <javah> and <native2ascii> now provide a nested
    element to specify a classpath that will be used when loading the
    task's (compiler) adapter class.
    Bugzilla Report 11143.
 
  * <javac>, <rmic>, <javah> and <native2ascii> now provide a nested
    element to specify the task's (compiler) adapter as an instance of
    a class that has been defined via typedef/componentdef.  This
    allows more control over the classpath and allows adapters to be
    defined in Antlibs easily.
 
  * A new subclass org.apache.tools.ant.loader.AntClassLoader5 of
    AntClassLoader has been added which overrides getResources
    which became non-final in ClassLoader with Java5+ so
    this method now behaves as expected.
    The new subclass will be used by Ant internally if it is available
    and Ant is running on Java5 or more recent.
    Bugzilla Report 46752.
 
  * a new attributes can chose a different request method than GET for
    the http condition.
    Bugzilla Report 30244
 
  * <splash> now supports a configurable display text and a regular
    expression based way to determine progress based on logged messages.
    Bugzilla Report 39957.
 
  * the number of retries on error in <get> is now configurable.  <get>
    can be told to not download files that already exist locally.
    Bugzilla Report 40058.
 
  * Ant now builds against commons-net 2.0 as well.
    Bugzilla Report 47669.
 
  * A new nested element connectionProperty of <sql> allows setting of
    arbitrary JDBC connection properties.
    Bugzilla Report 33452.
 
  * A new islastmodified condition can check the last modified date of
    resources.
 
  * <rmic> has a new destDir attribute that allows generated files to
    be written to a different location than the original classes.
    Bugzilla Report 20699.
 
  * <rmic> has a new listfiles attribute similar to the existing one of
    <javac>.
    Bugzilla Report 24359.
 
  * It is now possible to suppress the "FAILED" lines sent to Ant's
    logging system via <junit>'s new logFailedTests attribute.
    Bugzilla Report 35073.
 
  * <propertyfile> now can delete entries.
 
  * The <resources> resource collection can now optionally cache its
    contents.
 
  * A new <resourceexists> condition can check whether resources exists.
 
  * <sql> has two new attributes errorproperty and warningproperty that
    can be set if an error/warning occurs.
    Bugzilla Report 38807.
 
  * <sql> has a new attribute rowcountproperty that can be used to set
    a property to the number of rows affected by a task execution.
    Bugzilla Report 40923.
 
  * when Ant copies files without filtering, it will now use NIO
    channels.
    Bugzilla Report 30094.
 
  * <get> has a new attribute that can be used to disable caching on
    HTTP connections at the HttpUrlConnection level.
    Bugzilla Report 41891.
 
  * <tar> and <zip> (and tasks derived from <zip>) will now create the
    parent directory of the destination archive if it doesn't exist.
    Bugzilla Report 45377.
 
  * A new filterreader <sortfilter> that sorts input lines has been
    added.
    Bugzilla Report 40504.
 
  * A new token filter <uniqfilter> that suppresses tokens that match
    their ancestor token has been added.
 
  * <rootfileset>s nested into <classfileset>s can now use a dir
    attribute different from the <classfileset>.
    Bugzilla Report 37763.
 
  * <path> can now optionally cache its contents.
 
  * <property> can now specify values as nested text.
    Bugzilla Report 32917.
 
  * a new parentFirst attribute on <javaresource> allows resources to
    be loaded from the specified classpath rather than the system
    classloader.
    Bugzilla Report 41369.
 
  * <property location="from" basedir="to" relative="true"/> can now
    calculate relative paths.
 
  * The <name> selector supports a new handleDirSep attribute that
    makes it ignore differences between / and \ separators.
    Bugzilla Report 47858.
 
  * <get> now supports resource collections (as long as the resources
    contained provide URLs) and can get multiple resources in a single
    task.
 
  * <import> can now import non-File resources if they provide an URL
    - as the <url> and <javaresource> resources do.
    Bugzilla Report 29251
 
  * <import> can now import multiple resources specified as resource
    collections.
    Bugzilla Report 22269.
 
  * a new <resourcelist> type is similar to <filelist> but can read the
    list of resources from non-file resources and may return resources
    that are not files.
 
  * a new filterreader appendtolines complements prefixlines.
 
  * a new top level element extension-point allows build files to be
    extended with custom targets more easily.
 
 Changes from Ant 1.7.0 TO Ant 1.7.1
 =============================================
 
 Changes that could break older environments:
 -------------------------------------------
 
 * String resources only have properties single expanded. If you relied on
   <string> resources being expanded more than once, it no longer happens.
   Bugzilla report 42277.
 
 * A String resource's encoding attribute was only taken into account when
   set from the resource's OutputStream; the InputStream provided the String's
   binary content according to the platform's default encoding. Behavior has
   been modified to encode outgoing (InputStream) content as well as encoding
   incoming (OutputStream) content.
 
 * <java> with fork now returns gives -1 instead of 0 as result when failonerror
   is false and some exception (including timeout) occurs. Br 42377. 
 
 * ant-type attribute has been marked as deprecated and a warning has been
   issued if it is encountered in the build file.
 
 Fixed bugs:
 -----------
 
 * The default logger was failing to print complete stack traces for exceptions
   other than BuildException, thus omitting often important diagnostic
   information. Bugzilla 43398.
 
 * Error in FTP task
   Bugzilla report 41724
 
 * Regression: Locator fails with URI encoding problem when spaces in path
   Bugzilla report 42222
 
 * Regression in Locator: running Ant off a network share does not work:
   message "URI has authority component" appears
   Bugzilla report 42275
 
 * Improvements in AntClassLoader Speed.
   Bugzilla report 42259
 
 * Error in handling of some permissions, most notably the AllPermission on
   jdk 1.5
   Bugzilla report 41776
 
 * Replace task summary output incorrect.
   Bugzilla report 41544
 
 * Dependset crashes ant when timestamp on files change during Dependset
   execution.
   Bugzilla report 41284
 
 * Bug in org.apache.tools.ant.types.resources.comparators.Date
   Bugzilla report 41411
 
 * <junit> in Ant 1.7.0 could throw NPE if no <classpath> was defined.
   Bugzilla report 41422.
 
 * In Ant 1.7.0, <fileset> in <javadoc> does not by default include only
   **/*.java as the documentation claims and earlier revisions did.
   Bugzilla report 41264.
 
 * SPI support in jar was broken.
   Bugzilla report 41201.
 
 * jsch-0.1.30 causes SCP task to hang
   Bugzilla report 41090.
 
 * Target from imported file listed twice in projecthelp.
   Bugzilla report 41226.
 
 * <sql> task double-expands properties if expandproperties is true,
   and expands properties if expandproperties is false.
   Bugzilla report 41204.
 
 * Rolling back Bugzilla 32927 (set a default description for a javadoc tag
   if not set) as it caused a BC problem.
   Bugzilla report 41268.
 
 * <apt> forks properly and so memory settings are picked up.
   Bug report 41280.
 
 * Regression: NPE was thrown when using <pathconvert> against a
   (third-party instantiated) fileset with null Project reference.
 
 * Strip out all -J arguments to non forking rmic adapters, specifically
   the Sun and Weblogic compilers.
   Bug report 41349
 
 * Synchonization issues in PropertyHelper.  Bugzilla 41353.
 
 * <concat binary="true" append="true"> did not append.  Bugzilla 41399.
  
 * -autoproxy turns Java1.5+ automatic proxy support on. Bugzilla 41904
 
 * Handle null result of system getProperty(). Bugzilla 42334.
 
 * Regression: concat fixlastline="true" should not have applied to
   nested text, but did in Ant 1.7.0. Bugzilla 42369.
 
 * Regression: ant.version was not passed down in <ant>, <subant>.
   This worked in Ant 1.6.5, but not in 1.7.0.
   ant.core.lib (added in 1.7.0) was also not being propagated.
   Bugzilla bug 42263
 
 * Regression: bzip2 task created corrupted output files for some inputs.
   Bugzilla bug 41596.
 
 * Regression: <available> with <filepath> did not work.
   Bugzilla 42735.
 
 * ant script, cd may output to stdout.
   Bugzilla 42739.
 
 * Modified selector doesn't update the cache if only one file has changed.
   Bugzilla 42802.
 
 * Regression: Path subclasses that overrode list() stopped working in
   resourceCollection contexts in Ant 1.7.0. Bugzilla 42967.
 
 * <property> supports loading from xml based property definition.
   Bugzilla 42946
 
 * <junit> supports collecting and rerunning failed test cases
   (textXXX methods). Bugzilla 42984.
 
 * War task failed with "No WEB-INF/web.xml file was added" when called
   a second time. Bugzilla 43121.
 
 * FilterMapper could throw an NPE.
   Bugzilla 43292.
 
 * Regession nested macrodefs with elements could cause StackOverFlow.
   Bugzilla 43324.
 
 * Some changes to <junit> broke third party tasks that extend it (like
   Apache Cactus' Ant task).  The changes have been modified so that
   subclases should now work again - without any changes to the
   subclass.
 
 Other changes:
 --------------
 
 * Various small optimizations speed up common tasks such as <javac> on large
   filesets, reducing both I/O and CPU usage.
 
 * Profiling logger has been added with basic profiling capabilities.
 
 * <script> now has basic support for JavaFX scripts
 
 * SSH task can now take a command parameter containing the commands to execute.
   This allows you to connect to a server and execute a number of commands
   without constantly reconnecting for each command.
 
 * Upgraded XML API to XML commons version 1.3.04.
 
 * Upgraded to Xerces 2.9.0
 
 * <script> can now work with bsf.jar and js.jar in its <classpath>.
 
 * add errorProperty and updatedProperty to <javac>
   Bugzilla 35637 and 28941.
 
 * add classpathref attribute to <whichresource>
   Bugzilla 41158.
 
 * reduce logging noise of <apply skipemptyfilesets="true">
   Bugzilla 29154
 
 * Show Previous Revision in the tagdiff.xsl stylesheet
   Bugzilla 29143
 
 * Allow <mapper refid> to refer directly to a FileNameMapper instance.
 
 * If you try and use a type in a namespace (or an antlib), and the type is not
   recognized but there are other definitions in that namespace, Ant lists what
   the known definitions are. This helps you find spelling errors.
 
 * Add a <last> resource collection, corresponding to <first>.
 
 * Add new <truncate> task.
 
 * <junitreport> xsl stylesheets allow setting the title used in <title> and <h1> tags by
   using <report><param> element.  Bugzilla 41742.
 
 * Add IgnoreDependenciesExecutor for weird cases when the user wants to run
   only the targets explicitly specified.
 
 * Patternset allows nested inverted patternsets using <invert>.
 
 * <manifest> checks for validity of attribute names.
 
 * JUnitVersionHelper.getTestCaseClassName is now public. Bugzilla 42231
 
 * <string> resource supports nested text. Bugzilla bug 42276
 
 * <scriptdef> now sources scripts from nested resources/resource collections. This lets you
   define scripts in JARs, remote URLs, or any other supported resource. Bugzilla report 41597.
 
 * <concat> is now usable as a single-element ResourceCollection.
 
 * It is now possible to provide the value of a <striplinecomments> filter's
   <comment> nested element as nested text instead of using the 'value'
   attribute.
 
 * A new logger, BigProjectLogger, lists the project name with every target
 
 * Default text added to macrodef. Bugzilla report 42301.
 
 * "rawblobs" attribute added to SQL task.
 
 * Add new retry task container.
 
 * <jar> has a new strict attribute that checks if the jar complies with
   the jar packaging version specification.
 
 * <javac> has a new attribute - includeDestClasses.
   Bugzilla 40776.
 
 * <fileset> has a new attribute - errorOnMissingDir.
   Bugzilla 11270.
 
 * <javac> handles package-info.java files, there were repeatedly compiled.
   Bugzilla 43114.
 
 * SecureInputHandler added to use Java 6 System.console().readPassword()
   when available.
 
 Changes from Ant 1.6.5 to Ant 1.7.0
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
 * Initial support for JDK 6 (JSR 223) scripting.
   <*script*> tasks will now use javax.scripting if BSF is
   not available, or if explicitly requested by using
   a "manager" attribute.
 
 * Removed launcher classes from nodeps jar.
 
 * <classconstants> filter reader uses ISO-8859-1 encoding to read
   the java class file. Bugzilla report 33604.
 
 * Defer reference process. Bugzilla 36955, 34458, 37688.
   This may break build files in which a reference was set in a target which was
   never executed. Historically, Ant would set the reference early on, during parse
   time, so the datatype would be defined. Now it requires the reference to have
   been in a bit of the build file which was actually executed. If you get
   an error about an undefined reference, locate the reference and move it somewhere
   where it is used, or fix the depends attribute of the target in question to
   depend on the target which defines the reference/datatype.
   As a result of testing on real live build scripts, a fall-back mechanism
   was put it place to allow references that are out-of-band to be resolved. If
   this happens a big warning message is logged. This fall-back mechanism will
   be removed in Ant 1.8.0.
 
 * <script> and <scriptdef> now set the current thread context.
 
 * Unrestrict the dbvendor names in the websphere element of the ejbjar task.
   Bugzilla Report 40475.
 
 * <env> nested element in <java>, <exec> and others is now case-insensitive
   for windows OS. Bugzilla Report 28874.
 
 * Removed support for xalan1 completely. Users of Xalan1 for Ant builds will
   have to stay at ant 1.6.5 or upgrade to xalan2.
 
 * Use org.apache.log4j.Logger instead of org.apache.log4j.Category.
   Category has been deprecated for ~2 years and has been removed from
   the log4j code.  Logger was introduced in log4j 1.2 so users of
   log4j 1.1 and log4j 1.0 need to upgrade to a newer version of log4j.
   Bugzilla Report 31951.
 
 * build.sysclasspath now also affects the bootclasspath handling of
   spawned Java VMs.  If you set build.sysclasspath to anything other
   than "ignore" (or leave it unset, since "ignore" is the default when
   it comes to bootclasspath handling), then the bootclasspath of the
   VM running Ant will be added to the bootclasspath you've specified.
 
 * The <java fork="false"> now as per default installs a security manager
   using the default permissions. This is now independent of the
   failonerror attribute.  Bugzilla report 33361.
 
 * <signjar> now notices when the jar and signedjar are equal, and switches
   to the same dependency logic as when signedjar is omitted. This may break
   something that depended upon signing in this situation. However, since
   invoking the JDK jarsigner program with -signedjar set to the source jar
   actually crashes the JVM on our (Java1.5) systems, we don't think any
   build files which actually worked will be affected by the change.
 
 * <signjar> used to ignore a nested fileset when a jar was also provided as an
   attribute, printing a warning message; now it signs files in the fileset.
 
 * An improved method of handling timestamp granularity differences between
   client and server was added to the <ftp> task.  FTP servers typically
   have HH:mm timestamps whereas local filesystems have HH:mm:ss timestamps.
   Previously, this required tweaking with the timediffmillis attribute
   which also was used to handle timezone differences.  Now, there is a new
   timestampgranularity attribute.  The default value for get operations is 0
   since the user has the more powerful preservelastmodified attribute to work
   with.  Since this is not available on put operations the default value
   adds a minute to the server timestamp in order to account for this,
   Scripts which previously used timediffmillis to do this compensation may
   need to be rewritten.  timediffmillis has now been deprecated.
 
 * Support for the XSL:P XML parser has been removed.
   Bugzilla Report 23455.
 
 * Visual Age for Java optional tasks removed as the required library is no
   longer available.
 
 * Testlet (test) optional task removed as the required library is no
   longer available.
 
 * IContract optional task removed as the required library is no
   longer available.
 
 * Metamata (maudit, mmetrics, and mparse tasks) removed as the required 
   library is no longer available.
 
 * Sitraka (jpcoverage, jpcovmerge, jpcovreport) tasks suppressed as the 
   required library is no longer available.
 
 * <fixcrlf> used \r (Mac) line endings on OS X, whose proper line separator
   is \n (Unix).  Bugzilla report 39585.
 
 * <scp> now optionally supports the sftp protocol, you may need a
   newer jsch.jar.  Bugzilla Report 39373.
 
 * Ant launcher program prints errors to stderr, and exits with a 2 exit code
   value if, for any reason, it cannot actually start Ant proper. This will only
   affect programs/scripts that called the launcher and which did not want to
   receive an error if Ant itself would not start
 
 * All .NET tasks are now deprecated in favor of the new .NET Antlib:
   http://ant.apache.org/antlibs/dotnet/index.html
 
 Fixed bugs:
 -----------
 * Directory deletion did not work properly.
   Bugzilla 40972.
 
 * docletpath attribute of javadoc was ignored.
   Bugzilla 40900.
 
 * Fixed incorrect recursion in DOMUtil.listChildNodes().
   Bugzilla 40918.
 
 * CompressedResource.compareTo() did not
   take comparison with another CompressedResource into account.
   Bugzilla 40949.
 
 * Avoid possible NPE in Jar.java.
   Bugzilla 40847.
 
 * regression in attribute prefix (+ others) for refid in zipfileset and tarfileset.
   Bugzilla 41004, 30498.
 
 * dependset failed if the basedir of a target fileset did not exist.
   Bugzilla 40916.
 
 * Recursive filtering encountered NullPointerExceptions under certain
   circumstances.  Bugzilla 41086.
 
 * XmlProperty overrides previously set property value when handling duplicate
   elements. Bugzilla 41080.
 
 * Having many tasks causes OOM.  Bugzilla 41049.
 
 * Regression: <path> was evaluating nested content only once, so that it could
   not e.g. pick up files that didn't exist the first time through.
   Bugzilla 41151.
 
 * OOM caused by IH holding on to classes and thus their classloaders.
   Bugzilla 28283 and 33061.
 
-* <delete> doesnt delete when defaultexcludes="false" and no includes is set
+* <delete> doesn't delete when defaultexcludes="false" and no includes is set
   fixed. Bugzilla 40313.
 
 * Behavior change of DirectoryScanner/AbstractFileset when conditional include
   patterns are used. Bugzilla 40722.
 
 * <javac> fails with NPE when compiling with eclipse ecj 3.1.x.
   Bugzilla 40839.
 
 * JUnitTestRunner had a NPE when unable to create parser, the exception
   containing the error did not get reported. Bugzilla 36733.
 
 * <checksum> with file and todir option failed. Bugzilla report 37386.
 
 * <path location="loc"> was broken (Regression from beta1).
   Bugzilla report 40547.
 
 * Nested fileset in <cab> did not work. Bugzilla report 39439.
 
 * The ant wrapper script should now correctly locate the java
   executable in more recent IBM JDKs for AIX as well.
 
 * URLResource did not close jar files, and also did not disconnect HTTPConnection (s).
 
 * Error calling junitreport. Bugzilla 40595.
 
 * <junittask/> created junitvmwatcher*.properties files but did not close and delete them.
 
 * <xmlproperty> did not create properties for empty leaf elements.
   Bugzilla report 26286.
 
 * UnknownElement.maybeConfigure always configured.
   Bugzilla report 40641.
 
 * No check for refid when prefix attribute is set in zipfileset.
   Bugzilla report 30498.
 
 * Fix for junit4 issue introduced since beta2.
   Bugzilla report 40682.
 
 * Error in duplicate project name with <import> and <antcall>.
   Bugzilla report 39920.
 
 * junit4 did not work with fork=no and junit4 in $ANT_HOME/lib.
   Bugzilla report 40697.
 
 * PathConvert on Windows should process forward and back slashes equivalently.
   Bugzilla report 32884.
 
 * ant.bat now looks in %USERPROFILE% and %HOMEDRIVE%%HOMEPATH% in addition to
   %HOME% for pre/post batch files. Bugzilla report 39298.
 
 * The inheritance hierarchy of the legacy <path> type was changed; code built
   against Ant 1.7 would therefore no longer execute on older versions of Ant.
   Since <path> is historically heavily used this was undesirable, and since it
   is also avoidable, the change to <path>'s taxonomy was reverted.
 
 * <zip filesonly="true"> included empty directories.  Bugzilla report 40258.
 
 * Invalid hash code of Target causes XmlLogger to fail.
   Bugzilla report 40207.
 
 * Macro element did not include top level Text. Bugzilla report 36803.
 
 * AntClassLoader did not isolate resources when isolate was set. Bugzilla report 38747.
 
 * Diagnostics broken when using java 1.4. Bugzilla report 40395.
 
 * Exception reporting in <copy> was broken. Bugzilla report 40300.
 
 * Handling of corrupt tar files, TarInputStream.read() never returns EOF.
   Bugzilla report 39924.
 
 * Some bugs in ReaderInputStream. Bugzilla report 39635.
 
 * <antlr> did not recognise whether the target is up-to-date for html option.
   Bugzilla report 38451.
 
 * Documented minimal version of jsch now 0.1.29.
   Bugzilla report 40333.
 
 * <available> searched parent directories for files.
   Bugzilla report 37148.
 
 * The build could be halted if a file path contained more ".." components than
   the actual depth of the preceding path. Now such paths are left
   alone (meaning they will likely be treated as nonexistent
   files). Bugzilla Report 40281.
 
 * Converting a <dirset> to a string was broken. Bugzilla Report 39683.
 
 * Manifests have improved line length handling, taking care of encoding.
   Bug reports 37548 / 34425.
 
 * <manifest> now closes the inputstream explicitly. Bug report 39628.
 
 * <rpm> now also correctly searches the first element of the path.
   Bug report 39345.
 
 * ant.bat now handles classpath set to "". Bug report 38914.
 
 * <junit> now supports JUnit 4. Bugzilla Report 38811.
 
 * <junit> can now work with junit.jar in its <classpath>. Bugzilla
   Report 38799.
 
 * Some potential NullPointerExceptions, Bugzilla Reports 37765 and 38056.
 
 * Problem when adding multiple filter files, Bugzilla Report 37341.
 
 * Problem referencing jars specified by Class-Path attribute in manifest
   of a ant task jar file, when this ant task jar file is located in
   a directory with space, Bugzilla Report 37085.
 
 * Backward incompatible change in ZipFileSet, Bugzilla Report 35824.
 
 * Wrong replacement of file separator chars prevens junitbatchtest
   from running correctly on files from a zipfileset. Bugzilla Report 35499.
 
 * Calling close twice on ReaderInputStream gave a nullpointer exception.
   Bugzilla Report 35544.
 
 * Memory leak from IntrospectionHelper.getHelper(Class) in embedded
   environments. Bugzilla Report 30162.
 
 * Translate task does not remove tokens when a key is not found.
   It logs a verbose message.  Bugzilla Report 13936.
 
 * Incorrect task name with invalid "javac" task after a "presetdef".
   Bugzilla reports 31389 and 29499.
 
 * <manifest> was not printing warnings about invalid manifest elements.
   Bugzilla report 32190.
 
 * <replace> got out of memory on large files (part of report 32566).
   <replace> can now handle files as long as there is enough disk space
   available.
 
 * Commandline.describeCommand() methods would attempt to describe
   arguments even when none, other than the executable name, were present.
 
 * Create signjar's helper ExecTask instance directly rather than by
   typedef discovery mechanisms. Bugzilla report 33433.
 
 * FileUtils.resolveFile() promised to return absolute files but
   did not always do so.
 
 * <ftp> failed to retrieve a file when the path towards the file contained
   an element starting with . Bugzilla report 33770.
 
 * "<rmic> always compiles on Java1.5" bugzilla report=33862. Fixed default
   stub version to always be "compat", even on Java1.5+.
 
 * The .NET compilation tasks failed if filenames given as references
   contained spaces.  Bugzilla Report 27170.
 
 * SQL task would try access result sets of statements that didn't
   return any, causing problems with Informix IDS 9.2 and IBM DB2 8.1
   FixPak 6 (or later). Bugzilla Reports 27162 and 29954.
 
 * Task.init() was called twice for most tasks.  Bugzilla Report 34411.
 
 * JavaTest testcases sometimes fail on windows. Bugzilla Report 34502.
 
 * Targets with identical name work in imported project. Bugzilla Report 34566.
 
 * DemuxOutputStream now uses a WeakHashMap to store the thread-stream mapping,
   to avoid holding on to thread references after they terminate.
 
 * <xmlvalidate> and <schemavalidate> create a new parser for every file in a
   fileset, and so validate multiple files properly. Bugzilla Report 32791.
 
 * <tar> / <untar> now accepts files upto 8GB, <tar> gives an error if larger
   files are to be included. This is the POSIX size limit.
 
 * <junitreport> removed line-breaks from stack-traces.  Bugzilla
   Report 34963.
 
 * Off-by-one error in environment setup for execution under OpenVMS fixed.
 
 * Bugzilla report 36171: -noclasspath crashes ant if no system
   classpath is set.
 
 * <pvcs> used wrong switch for retrieving revisions by label.
   Bugzilla Report 36359.
 
 * <sshexec> closed System.out, disabling output on second and subsequent
   invocations.  Bugzilla report 36302.
 
 * <cvschangelog> was crashing with CVS versions >= 1.12.x due to change in
   the date format. Bugzilla report 30962.
 
 * The same IntrospectionHelper instance was continuously added as a listener
   to project. Bugzilla report 37184.
 
 * FileUtils.toURI() was not encoding non-ASCII characters to ASCII,
   causing impossibility to process XML entities referenced by XML
   documents in non ASCII paths. Bugzilla report 37348.
 
 * > 1 ssh invocations to a given host would fail. Bugzilla report 36207.
 
 * EmailTask was eating SMTP error messages. Bugzilla report 37547.
 
 * PropertySet API setMapper(...) didn't properly set up the Mapper.
   Bugzilla report 37760.
 
 * Proper return code for ant.bat. Bugzilla report 13655.
 
 * Project not set on ChainReaderHelpers used by the Redirector.
   Bugzilla report 37958.
 
 * Copy task would fail on locked (or otherwise uncopyable) files even if
   failonerror set to false. Bugzilla report 38175.
 
 * <junit> task did not print all the Test names when using forkmode='once'.
   Bugzilla report 37426.
 
 * <available> could leak resources, Bugzilla Report 38260.
 
 * Redirector called Thread.sleep in a synchronized block. Bugzilla
   report 37767.
 
 * CCUnlock's objselect attribute could exhibit unpredictable behavior;
   standardized improperly included objselect and objsel property accessors to
   delegate to the inherited objSelect property accessor. Bugzilla report 37766.
 
 * <unzip> and <untar> now correctly merge multiple nested patternsets.
   Bugzilla Report 38973.
 
 * On case-insensitive filesystems, a <move> to change filename case
   erroneously deleted the "destination" file before attempting to rename
   the source file.  Bugzilla 37701.
 
 * <scp> can now handle uris with @s other than the final one denoting the
   domain.  Bugzilla 38082.
 
 * If the class invoked by the <java> task threw a ClassNotFoundException,
   this was misinterpreted as the specified class itself not being found.
 
 * <echoproperties> setPrefix javadoc claimed null or empty prefix would be
   ignored; instead an error was thrown.  Bugzilla report 39954.
 
 * <get> would fetch files that were up to date, because it used > in a
   remote/local timestamp comparison, not >=. Bugzilla 35607.
 
 * <xslt> passes the current file (name + directory) to the
   stylesheet/transformation.  xsl-parameter name is configurable.
   Bugzilla report 21042.
 
 * The <zip> API allowed creation of directories in file-only archives; a
   habitual offender was the subclassed <jar>, which included META-INF/ in
   the destination file regardless of whether filesonly was set to true.
 
 * <rmic> has a new adapter, xnew, to use the -XNew back end on java1.5+.
   By forking rmic, this works on java1.6+. Bugzilla report 38732.
 
 * Copy of UnknownElement in macroinstance was not recursive.
   Bugzilla report 40238.
 
 * Mixing of add and addConfigured methods in Mapper/ChainedMapper
   causes incorrect chaining. Bugzilla report 40228.
 
 Other changes:
 --------------
 
 * Warn user when a reference in the form "${refid}" cannot be resolved as this
   is a sign they probably meant "refid" (misuse of property expansion syntax).
 
 * Add dtd to javadoc for junit.
   Bugzilla 40754.
 
 * Add quiet attribute to loadfile/resource.
   Bugzilla 38249.
 
 * Make Locator#fromURI also append the drive letter when running under Windows
   with JDK 1.3 or 1.2.
 
 * Do not uppercase the drive letters systematically in FileUtils#normalize.
 
 * Java 5 enumerations may now be used as values in XML attributes in place of
   EnumeratedAttribute. Bugzilla 41058.
 
 * Create a pom file for ant-testutil and add ant-testutil.jar to the ant
   distribution. Bugzilla 40980.
 
 * Roll back automatic proxy enabling on Java 1.5. It broke things like
-  Oracle JDBC drivers, and Ant itself on IBM's JVM on AIX, and didnt
+  Oracle JDBC drivers, and Ant itself on IBM's JVM on AIX, and didn't
   seem to work to well the rest of the time.
   To enable the feature, use the -autoproxy command line option.
 
 * Upgraded XML API and parser to Xerces 2.8.1
 
 * A code review of some threaded logic has tightened up the synchronization
   of Watchdog, ExecuteWatchdog and ExecuteJava, which could reduce the occurrence
   of race conditions here, especially on Java1.5+.
 
 * Allow broken reference build files. The defer reference processing would
   break too many files - so allow them with a warning.
 
 * Removed dependency on sun.misc.UUEncoder for UUMailer.
 
 * Added regex attribute to the echoproperties task.
   Bugzilla 40019.
 
 * <war> task now allows you to omit the web.xml file. as this is optional
   in the servlet 2.5 and Java EE 5 APIs. set needxmlfile="false" to
   avoid a missing web.xml file from halting the build.
 
 * Diagnostics catches and logs security exceptions when accessing system properties.
 
 * <javadoc> useexternalfile now applies to all command line arguments
   of javadoc. Bugzilla report 40852.
 
 * javadoc/tag@description is now set to the name if description is
   not specified. Bugzill report 32927.
 
 * Some performance improvements, including Bugzilla report 25778.
 
 * Add <matches> condition. Bugzilla report 28883.
 
 * Extending JAR-Task for SPI. Bugzilla report 31520.
 
 * Added <tokens> resource collection for convenient creation of string
   resources from other resources' content. Inspired by Bugzilla 40504.
 
 * Added <compare> resource selector to select resources based on the
   results of their comparison to other resources.
 
 * Added outputtoformatters attribute to <junit> to allow suppression
   of noisey tests. Bugzilla report 12817.
 
 * Log level of message 'Overriding previous definition of reference to'
   set to Verbose. Bugzilla report 17240.
 
 * Added setbeans attribute to <script> to allow <script>'s to be
   run without referencing all references.
   Bugzilla report 37688.
 
 * Added classpath attribute and nested element to <script> to allow
   the language jars to be specified in the build script.
   Bugzilla report 29676.
 
 * Trim the driver attribute on the <sql> task. Bugzilla report 21228.
 
 * Allow (jar) files as well as directories to be given to jdepend.
   Bugzilla report 28865.
 
 * Convert SplashTask to use NOT sun internal classes.
   Bugzilla report 35619.
 
 * Made PatternSet#hasPatterns public to allow custom filesets access.
   Bugzilla report 36772.
 
 * Added searchparents attribute to <available>. Bugzilla report 39549.
 
 * Tasks that don't extend Ant's Task class will now get the build file
   location reflected into a method of the signature void setLocation(Location)
   - if such a method exists.
 
 * Remove needless synchronization in DirectoryScanner.
   Bugzilla report 40237.
 
 * Improved recursion detection for lines with multiple matches of same token
   on a single line.  Bugzilla report 38456.
 
 * Task will now log correctly even if no project is set.
   Bugzilla report 38458.
 
 * Use alternative names for the command line arguments in javac. Bugzilla
   Report 37546.
 
 * The Reference class now has a project field that will get
   used (if set) in preference to the passed in project, when
   dereferencing the reference. Bugzilla Report 25777.
 
 * On DOS and Netware, filenames beginning with a drive letter
   and followed by a colon but with no directory separator following
   the colon are no longer (incorrectly) accepted as absolute pathnames
   by FileUtils.normalize() and FileUtils.isAbsolutePath().  Netware
   volumes can still be specified without an intervening separator.
   UNC pathnames on Windows must include a server and share name, i.e.
   "\\a\b" to be considered valid absolute paths.
 
 * A bug in SQLExec would prevent the execution of trailing,
   non-semicolon-delimited statements.  Bugzilla Report 37764.
 
 * InputHandler implementations may now call InputRequest.getDefaultValue()
   if they wish. The default handler uses this also. Bugzilla report 28621.
 
 * Took in bugzilla report 39320, "Simple code cleanups"
 
 * Improve compatibility with GNU Classpath and java versions prior to
   1.5. Bugzilla 39027.
 
 * ${ant.core.lib} may now be used to refer to the library containing the
   Ant classes, for instance useful when compiling tasks.
 
 * Minor performance improvements Bugzilla report 37777
 
 * New task <manifestclasspath> converts a path into a property
   suitable as the value for a manifest's Class-Path attribute.
 
 * Fixed references to obsoleted CVS web site. Bugzilla Report 36854.
 
 * Log fine-grained events at verbose level from JUnit. Bugzilla report 31885.
 
 * <WsdlToDotnet> and <style> are now deprecated in favor of <wsdltodotnet> and
   <xslt>, respectively. Bugzilla report 25832.
 
 * <echoproperties> now (alphanumerically) sorts the property list
   before echoing. Bugzilla report 18976.
 
 * A new base class DispatchTask has been added to facilitate elegant
   creation of tasks with multiple actions.
 
 * Major revision of <wsdltodotnet>. Supports mono wsdl and the microsoft
   wsdl run on mono, as well as most of the .NET WSE2.0 options. Extra
   schemas (files or urls) can be named in the <schema> element.
   Compilers can be selected using the compiler attribute, which defaults
   to "microsoft" on windows, and "mono" on everything else.
 
 * It is now possible to specify the pattern created/parsed by <checksum>.
   Bugzilla Report 16539.
 
 * Added a new "failall" value for the onerror attribute of <typedef>.
   Bugzilla report 31685.
 
 * unzip/unwar/unjar/untar now supports a nested mapper, which lets you unzip
   in useful ways.
 
 * Junit task -- display suite first.
   Bugzilla report 31962.
 
 * Added isSigned condition and signedselector selector
   Bugzilla report 32126.
 
 * Added preserveLastModified attribute to signjar task.
   Bugzilla report 30987.
 
 * Added <scriptcondition> condition, for inline scripted conditions
 
 * Added <xor> condition for exclusive-or combining of nested conditions.
 
 * Added <scriptselector> selector for scripted file selection
 
 * ant -diagnostics lists contents of ${user.home}/.ant/lib , and
   checks that the java.io.tmpdir directory exists and is writeable.
 
 * mail task accepts nested header element.  Bugzilla report 24713.
 
 * zip/jar/war/ear supports level attribute for deflate compression level.
   Bugzilla report 25513.
 
 * Added loginputstring attribute to the redirector type.
 
 * Tighten security by sending storepass and keypass to signjar
   via the input stream of the forked process.
 
 * New task <schemavalidate> extends <xmlvalidate> with extra support
   for XML Schema (XSD) files.
 
 * <fixcrlf> supports a file attribute for easy fixup of a single file.
 
 * New condition <parsersupports> which can look for XML parser feature or
   property support in the parser Ant is using.
 
 * fixcrlf can be used in a filterchain.
 
 * <sync> has a new nested element <preserveInTarget> that can be used
   to protect extra-content in the target directory.  Bugzilla Report
   21832.
 
 * <signjar> now supports:
   -nested filesets at the same time as the jar attribute
   -a destDir attribute with the appropriate dependency logic, which
    can be used with the jar attribute or nested filesets
   -a mapper to permit filename remapping on signing
   -tsaurl and tsacert attributes for timestamped JAR signing
   -nested <sysproperty> elements, which can be used for proxy setup
   and the like
 
 * The linecontains and linecontainsregexp filterreaders now support a
   negate attribute to select lines -not- containing specified text.
   Bugzilla Report 34374.
 
 * <os> condition adds "winnt" as a family which can be tested. This is
   all windows platforms other than the Win9x line or Windows CE.
 
 * <exec> (and hence, <apply> and any other derived classes) have an OsFamily
   attribute, which can restrict execution to a single OS family.
 
 * Added "backtrace" attribute to macrodef. Bugzilla report 27219.
 
 * Ant main provides some diagnostics if it ever sees a -cp or -lib option,
   as this is indicative of a script mismatch. Bugzilla report 34860
 
 * <junitreport> prints a special message if supplied an empty XML File. This
   can be caused by the test JVM exiting during a test, either via a
   System.exit() call or a JVM crash.
 
 * Project name is now used for *all* targets so one can write consistent import
   build files. Bugzilla report 28444.
 
 * New condition <typefound> that can be used to probe for the declaration
   and implementation of a task, type, preset, macro, scriptdef, whatever.
   As it tests for the implementation, it can be used to check for optional
   tasks being available.
 
 * Check for 1.5.* Ant main class. (weblogic.jar in classpath reports)
 
 * New condition <isfailure> that tests the return-code of an executable. This
   contains platform-specific logic and is better than comparing the result with
   "0".
 
 * Added initial support for Resource Collections, including the
   resourcecount task.
 
 * property attribute of pathconvert is now optional. If omitted the
   result will be written to the log.
 
 * New mapper, <scriptmapper>, supports scripted mapping of source files/strings
   to destination strings.
 
 * Add the echoxml task. This will echo nested XML to a file, with
   the normal <?xml ?> processor instruction. UTF-8 encoding only; no-namespace
   support.
 
 * Try to make subprojects of custom Project subclasses instances of the
   same type. Bugzilla report 17901.
 
 * <ssh> and <scp> support keyboard-interactive authentication now.
 
 * <javadoc> now supports -breakiterator for custom doclets if Ant is
   running on JSE 5.0 or higher.  Bugzilla Report: 34580.
 
 * New logger, TimestampedLogger, that prints the wall time that a build
   finished/failed. Use with
   -logger org.apache.tools.ant.listener.TimestampedLogger
 
 * <junitreport> now generates pages alltests-errors.html and
   alltests-fails.html, that list only the errors and failures, respectively.
   Bugzilla Report: 36226
 
 * New task <makeurl> that can turn a file reference into an absolute file://
   url; and nested filesets/paths into a (space, comma, whatever) separated
   list of URLs. Useful for RMI classpath setup, amongst other things.
 
 * <xslt> now accepts nested FileNameMappers e.g. <globmapper>.
   Bugzilla report 37604.
 
 * New task <loadresource> that accompanies <loadfile> for non file resources.
 
 * <echo> now supports an encoding when saving to a file.
 
 * New GreedyInputHandler added.
 
 * Add textfile attribute to the <filesmatch> condition. When true, the text
   contents of the two files are compared, ignoring line ending differences.
 
 * New <resourcesmatch> condition.
 
 * Added the onmissingfiltersfile attribute to filterset. Bugzilla report 19845.
 
 * Added the inline handler element to the input task.
 
 * <sql> supports property expansion if you set the expandProperties
   attribute. By default it does not expand properties, something we
   dare not change for fear of breaking complex SQL operations in
   existing files.
 
 * <javadoc>'s packagenames attribute is now optional and defaults to "*".
 
 * <javac>'s source and target attributes as well as <javadoc>'s source
   attribute will read default values from the properties
   ant.build.javac.source and ant.build.javac.target.
 
 * Handling of ' ', '#' in CLASSPATH and '#' in -lib (cannot use ' '
   in -lib on UNIX at the moment). Bugzilla Report 39295.
 
 * <scp> now optionally supports the sftp protocol.  Bugzilla Report 39373.
 
 * Resources can now be used to indicate the location of the stylesheet to use
   in <xslt>. Bugzilla Report 39407.
 
 * New <antversion> condition. Bugzilla report 32804.
 
 * ReplaceTokens should allow properties files. Bugzilla report 39688.
 
 * FTP Account could not be specified in ant FTP task. Bugzilla report 39720.
 
 * Minor performance updates. Bugzilla report 39565.
 
 * New deleteonexit attribute for the <tempfile> task. Bugzilla report 39842.
   Remember that the exit of the JVM can be a long time coming,
   especially under an IDE. Don't rely on this being called.
 
 * <scriptdef>-created scripts have support for nested text. All text
   passed to a scripted task can be accessed via self.text.
 
 * <fixcrlf> now supports an outputencoding attribute.  Bugzilla report 39697.
 
 * <junitreport> now supports nested XSL parameters. Bugzilla report 39708.
 
 * <javacc> has a jdkversion attribute to pass the desired JDK version
   down to javacc.  Bugzilla report 38715.
 
 * <cvs> prints passfile info at -verbose level instead of -info. Bugzilla
   report 35268
 
 * When <javac> can't find the compiler class, it prints out java.home for
   immediate diagnostics
 
 * Ant launcher now supports a -main attribute so that you can specify
   an extension class to the built in org.apache.tools.ant.Main
   class. This class must implement the interface AntMain
 
 Changes from Ant 1.6.4 to Ant 1.6.5
 ===================================
 
 Changes that could break older environments:
 --------------------------------------------
 
 Fixed bugs:
 -----------
 
 * <move> was unable to replace existing files or write into
   existing directories.  Bugzilla report 34962.
 
 * <macrodef> with redefined default values was incorrect. (Fix for
    31215 had a bug). Bugzilla report 35109.
 
 * <javadoc> will convert backslashes to forwardslashes when generating file
   list by useexternalfile. Bugzilla report 27814.
 
 Changes from Ant 1.6.3 to Ant 1.6.4
 ===================================
 
 Changes that could break older environments:
 --------------------------------------------
 * <ftp> task has had a number of changes.  Uptodate calculation previously
   did not call a file uptodate if the source timestamp and the destination
   timestamp were equal. Bugzilla report 34941.  Any script that attempted
   to compensate for this by using the timediffmillis attribute might need
   to be tweaked.
 
 
 Fixed bugs:
 -----------
 
 * Sun javah failed with java.lang.NoClassDefFoundError.
   Bugzilla report 34681.
 
 * DirectoryScanner.slowScan() was broken. Bugzilla report 34722.
 
 * DirectoryScanner.scan() could throw a NullPointerException on
   case-insensitive filesystems (read Windows or MacOS X).
 
 * Get w/authentication failed with ArrayOutOfBoundsExceptions.
   Bugzilla report 34734.
 
 * Granularity attribute for <sync> task was undocumented.
   Bugzilla report 34871.
 
 * <unzip> and <untar> could leave file handles open on invalid
   archives.  Bugzilla report 34893.
 
 * propertyset threw NPE with nested, mapped propertysets.
 
 Other changes:
 --------------
 
 * AntXMLContext.setCurrentTargets() is now public. Bugzilla report 34680.
 
 Changes from Ant 1.6.2 to Ant 1.6.3
 ===================================
 
 Changes that could break older environments:
 --------------------------------------------
 
 * The subant task used the canonical version of a file path. This
   has been changed to use the absolute path. Bugzilla 30438.
 
 * Tar now writes two EOF blocks rather than one.
   Bugzilla report 28776
 
 * The Reference object now has a project field which it uses in preference
   to the project passed in. This allows composite references to be
   handled to nested projects.
   Bugzilla report 25777
 
 * <junit> with filtertrace="true" will now also swallow lines for the
   sun.reflect package.  If you need to see them in your stack trace,
   you must set filtertrace to false.
   Bugzilla Report 22758
 
 * The jikes compiler adapter now supports -bootclasspath, -extdirs and
   -sourcepath and also uses the same logic for debug flags as javac.
   This means, the jikes compiler adapter now requires Jikes 1.15 or later.
   Bugzilla Reports 25868, 26404 and 32609.
 
 * The gcj compiler adapter used to include the Java runtime classes
   even if includeJavaRuntime was set to false, unless the
   bootclasspath has been specified as well.  It will now always adhere
   to includeJavaRuntime, you may need to set it to true explicitly now
   if you relied on the old behavior.
 
 Other changes:
 --------------
 
 * <javadoc> can now take an attribute 'executable'. Bugzilla report 30606.
 
 * New attribute ignorecontents for <different> selector
 
 * Javadoc fixes for Location, Project, and RuntimeConfigurable
   Bugzilla 30160.
 
 * Enable to choose the regexp implementation without system property.
   Bugzilla Report 15390.
 
 * Expose objects and methods in IntrospectionHelper. Bugzilla Report 30794.
 
 * Allow file attribute of <move> to rename a directory.
   Bugzilla Report 22863.
 
 * Add xmlcatalog nested element to XmlProperty. Bugzilla report 27053.
 
 * New attribute alwayslog for <redirector> type.
 
 * Added <target> nested elements to <ant> and <antcall> to allow
   specification of multiple sub-build targets, which are executed
   with a single dependency analysis.
 
 * Refactored Target invocation into org.apache.tools.ant.Executor
   implementations.  Bugzilla Reports 21421, 29248.
 
 * <rmic> now also supports Kaffe's rmic version shipping with Kaffe
   1.1.2 and above.
 
 * added casesensitive attribute to <globmapper> and <regexpmapper>
   Bugzilla report 16686
 
 * added handledirsep attribute to <globmapper> and <regexpmapper>
   Bugzilla report 32487
 
 * added a new mapper <filtermapper>
 
 * When a BuildListener tried to access System.err or System.out, Ant
   would have thrown an exception - this has been changed.  Ant now
   silently ignores the message.  BuildListeners still should avoid
   accessing either stream.
 
 * Added a comment attribute to the zip task.
   Bugzilla report 22793.
 
 * Overloaded FileUtils.createNewFile with a boolean mkdirs attribute
   to create nonexistent parent directories.
 
 * <apply> has a new "force" attribute that, when true, disables
   checking of target files.
 
 * Made the dest attribute of the apply task optional; mapped target
   filenames will be interpreted as absolute pathnames when dest is omitted.
 
 * Changed default tempdir for <javac> from user.dir to java.io.tmpdir.
 
 * Added searchpath attribute to <exec> for searching path variable(s)
   when resolveexecutable = true.
 
 * Added revision and userid attributes to <pvcs> documentation.
 
 * Added support to the touch task for a mkdirs attribute to create
   nonexistent parent directories before touching new files.
 
 * Added support to the touch task for a pattern attribute to allow
   alternate datetime formats.
 
 * Added support to the touch task to map touched files using a nested
   mapper element.
 
 * Added support to the touch task for a verbose attribute to suppress
   logging of new file creation.
 
 * bad link in docs to the enhancement page in bugzilla.
   Bugzilla report 33252.
 
 * Added length task to get strings' and files' lengths.
 
 * <native2ascii> and <javah> now also support Kaffe's versions.
 
 * Recursive token expansion in a filterset can now be disabled by
   setting its recurse attribute to false.
 
 * Pathconvert no longer requires that one of (targetos|pathsep|dirsep)
   be set; platform defaults are used when this is the case.
 
 * Added preservelastmodified attribute to fixcrlf task. Bugzilla 25770.
 
 * Added isfileselected condition.
 
 * Added verbose="true|false" attribute to <subant>. When verbose is enabled,
   the directory name is logged on entry and exit of the sub-build.
   Bugzilla 33787.
 
 * Added -nouserlib option to allow running ant without automatically loading
   up ${user.home}/.lib/ant. This is useful when compiling ant, and antlibs.
   Modified the build.sh and build.bat to use the option.
 
 * Added -noclasspath option to allow running ant WITHOUT using CLASSPATH env
   variable. Modified ant.bat to do this so that %CLASSPATH% is not looked at.
 
 * Add else attribute to the condition task, which specifies an
   optional alternate value to set the property to if the nested
   condition evaluates to false. Bugzilla report 33074.
 
 * Ant generated jar files should now be detected as jar files by
   Solaris.  Bugzilla Report 32649.
 
 * <rexec> with a single command should now work with unusal login
   dialogs without special read/write pairs.  Bugzilla Report 26632.
 
 * <csc>'s extraoptions can now contain multiple arguments.
   Bugzilla Report 23599.
 
 * <macrodef> with default values set by properties would be
   seen as new definitions when called twice with different properties.
   This was confusing so the definitions are now treated as similar.
   Bugzilla Report 31215.
 
 * <javadoc> has a new attribute "includenosourcepackages" that can be
   used to document packages that don't hold source files but a
   package.html file.  Bugzilla Report 25339.
 
 * <rpm> has new attributes failonerror and quiet.
 
 * Added two tutorials
   - beginner: introduction into Ant
   - task developers: using path, fileset etc
 
 * a number of new attributes that allow the user to handle non-standard
   server listing formats and time zone differences have been added in
   the <ftp> task.
 
 
 Fixed bugs:
 -----------
 
 * Do not pass on ThreadDeath when halting <java fork="false">. Bugzilla
   32941.
 
 * Killing a thread running <java fork="true"> (e.g. from an IDE) would
   not stop the forked process. Bugzilla 31928.
 
 * Programs run with <java fork="true"> can now accept standard input
   from the Ant console.  (Programs run with <java fork="false"> could
   already do so.)  Bugzilla 24918.
 
 * AbstractCvsTask prematurely closed its outputStream and errorStream.
   Bugzilla 30097.
 
 * Impossible to use implicit classpath for <taskdef>
   when Ant core loader != Java application loader and
   Path.systemClassPath taken from ${java.class.path} Bugzilla 30161.
 
 * MacroInstance did not clean up nested elements correctly in the execute
   method, causing multiple use of the same macro instance with nested
   elements to fail.
 
 * checksum fileext property doc wrong. Bugzilla 30787.
 
 * FTP task, getTimeDiff method was returning wrong value. Bugzilla 30595.
 
 * make sure that Zip and its derivatives call the createEmptyZip method when
  there are no resources to zip/jar/...
 
 * Zip task was not zipping when only empty directories were found.
   Bugzilla 30365.
 
 * Jar task was not including manifest files when duplicate="preserve" was
   chosen. Bugzilla 32802.
 
 * ant.bat was missing runAntNoClasspath label for goto.
   Bugzilla 34510.
 
 * Classpath was treated in the same way as -lib options. Bugzilla 28046.
 
 * Manual page for cvsversion contained incorrect attributes and did not
   say since 1.6.1. Bugzilla 31408.
 
 * Typo in definition of <cvsversion> task causing it not to be defined.
   Bugzilla 31403.
 
 * Execution of top level tasks in imported files get delayed by targets.
   Bugzilla report 31487.
 
 * ExecTask executes checkConfiguration() even though os does not match.
   Bugzilla report 31805.
 
 * Concat task instance could not be run twice.
   Bugzilla report 31814.
 
 * NPE using XmlLogger and antlib.
   Bugzilla report 31840.
 
 * Properties.propertyNames() should be used instead of .keys().
   Bugzilla report 27261.
 
 * Target location is not set for default target.
   Bugzilla report 32267.
 
 * Incorrect classloader parent in junittask when using with
   ant-junit.jar and junit.jar not in the project classloader. Bugzilla
   report 28474.
 
 * getResources() on the classloader returned by ClasspathUtils would
   see each resource twice - if the resource is in the project
   classpath and if the classloader is requested with a null path.
 
 * XMLValidate used URL#getFile rather than the ant method FileUtils#fromURI
   Bugzilla report 32508
 
 * fixed Regexp-Mapper docs which gave outdated instructions (optional.jar)
   Bugzilla report 28584
 
 * <scp> using <fileset> didn't work with OpenSSH 3.9 and later.
   Bugzilla report 31939
 
 * <setproxy> failed to set user/password on some JDKs.
   Bugzilla report 32667
 
 * untar would go into infinite loop for some invalid tar files.
   Bugzilla report 29877
 
 * forked <javac> won't pass -source to a JDK 1.1 or 1.2 javac anymore.
   Bugzilla report 32948
 
 * propertyset references did not handle nested propertyset references.
 
 * oata.types.Description.getDescription(Project) would throw a
   NullPointerException when the "ant.targets" reference was unset.
 
 * Wrapper scripts did not detect WINNT value of dynamic OS environment
   variable when logged into workstations using Novell authentication.
   Bugzilla Report 30366.
 
 * DependScanner.getResource() always returned nonexistent resources,
   even when the resource actually existed.  Bugzilla Report 30558.
 
 * <apply> was broken with classfilesets.  Bugzilla Report 30567.
 
 * <available> returned false positives when checking a file
   passed in with the current basedir leading twice:
   e.g. ${basedir}${file.separator}${basedir}${file.separator}foo .
 
 * The first file open that took place when using input files with the
   <exec>, <apply>, or <java> tasks was always logged to System.out
   instead of to the managing Task.
 
 * <telnet> and <rexec> would try to disconnect from servers they never
   connetced to, potentially leading to exceptions in commons-net.
   Bugzilla Report 33618.
 
 * <zip> would drop files matched by defaultexcludes during updates.
   Bugzilla Report 33412.
 
 * <zip> couldn't store files with size between 2GB and 4GB (the
   upper limit set by the ZIP format itself).  Bugzilla Report 33310.
 
 * NPE when when <presetdef> tries to configure a task that
   cannot be instantiated. Bugzilla Report 33689.
 
 * <javac debug="false"> created an invalid command line when running
   the Symantec Java compiler.
 
 * Get with usetimestamp did not work on Java 1.2.
 
 * Get with usetimestamp did not work when local timestamp roughly >= now.
 
 * The framed JUnit report now handles multiple reports for the same
   testcase properly.  Bugzilla Report 32745.
 
 * <cab> didn't work for files with spaces in their names on Windows.
   Bugzilla Report 17182.
 
 * The VAJ tasks could fail if the project name contained characters
   that need to get URL encoded.  Bugzilla Report 23322.
 
 * TarInputStream#read() wasn't implemented correctly.  Bugzilla Report
   34097.
 
 * <xslt> failed to process file-hierarchies of more than one level if
   scanincludeddirectories was true.  Bugzilla Report 24866.
 
 * forkmode="perBatch" or "once" would ignore extension attributes that
   had been specified for <formatter>s.  Bugzilla Report 32973.
 
 * The refid attribute of the I/O redirector was not functional.
 
 Changes from Ant 1.6.1 to Ant 1.6.2
 ===================================
 
 Changes that could break older environments:
 --------------------------------------------
 
 * The import task used the canonical version of a file path. This
   has been changed to use the absolute path. Bugzilla 28505.
 
 * ant-xalan2.jar has been removed since the only class contained in it
   didn't depend on Xalan-J 2 at all.  Its sole dependency has always
   been TraX and so it has been merged into ant-trax.jar.
 
 * All exceptions thrown by tasks are now wrapped in a buildexception
   giving the location in the buildfile of the task.
 
 * Nested elements for namespaced tasks and types may belong to the
   Ant default namespace as well as the task's or type's namespace.
 
 * <junitreport> will very likely no longer work with Xalan-J 1.
 
   Note that Xalan-J 1 has been deprecated for a very long time and we
   highly recommend that you upgrade.
 
   If you really need to continue using Xalan-J 1, please copy the
   junit-frames-xalan1.xsl from the distribution's etc directory as
   junit-frames.xsl into a new directory and use the task's styledir
   attribute to point to.  This is the last version of the XSLT
   stylesheet that is expected to be compatible with Xalan-J 1.
 
 Fixed bugs:
 -----------
 
 * eliminate memory leak in AntClassLoader. Bugzilla Report 8689.
 
 * subant haltonfailure=false did not catch all failures. Bugzilla Report 27007.
 
 * macrodef @@ escaping was broken.  Bugzilla Report 27069.
 
 * MacroDef did not allow attributes named 'description'. Bugzilla Report 27175.
 
 * Throw build exception if name attribute missing from patternset#NameEntry.
   Bugzilla Report 25982.
 
 * Throw build exception if target repeated in build file, but allow targets
   to be repeated in imported files.
 
 * <apply> didn't compare timestamps of source and targetfiles when
   using a nested <filelist>.  Bugzilla Report 26985.
 
 * tagdiff.xml was broken in ant 1.6.1. Bugzilla Report 27057.
 
 * if the basedir contained .. or . dirs, and the build file name contained
   .. or ., the basedir was set incorrectly. Bugzilla Report 26765.
 
 * regression from ant 1.5, exec task outputted two redundant trailing newlines.
   Bugzilla Report 27546.
 
 * NPE when running commons listener. Bugzilla Report 27373.
 
 * <java> swallowed the stack trace of exceptions thrown by the
   executed program if run in the same VM.
 
 * -projecthelp swallowed (configuration) errors silently.
   Bugzilla report 27732.
 
 * filterset used by filtertask doesn't respect loglevel. Bugzilla Report 27568.
 
 * wrong compare used in ProjectComponent for logging. Bugzilla Report 28070.
 
 * failOnAny attribute for <parallel> was broken. Bugzilla Report 28122.
 
 * If <javac> uses gcj and any of the nested <compilerarg>s implies
   compilation to native code (like -o or --main), Ant will not pass
   the -C switch to gcj.  This means you can now compile to native code
   with gcj which has been impossible in Ant < 1.6.2.
 
 * <import optional="false"> and <import optional="true">
   behaved identically.
 
 * <xslt> now sets the context classloader if you've specified a nested
   <classpath>.  Bugzilla Report 24802.
 
 * <zip> and friends would delete the original file when trying to update
   a read-only archive.  Bugzilla Report 28419.
 
 * <junit> and <assertions> are working together. Bugzilla report 27218
 
 * AntClassLoader#getResource could return invalid URLs.  Bugzilla
   Report 28060.
 
 * Ant failed to locate tools.jar if the jre directory name wasn't all
   lowercase.  Bugzilla Report 25798.
 
 * Redirector exhibited inconsistent behavior with regard to split
   output.  When sent to file only, files would be created in all
   cases; when split file-property, files were only created if
   writes were performed.
 
 * fixed case handling of scriptdef attributes and elements.
 
 * UNC pathnames did not work for ANT_HOME or -lib locations on Windows.
   Bugzilla report 27922.
 
 * replacestring tokenfilter only replaced the first occurrence.
 
 * AntLikeTasksAtTopLevelTest failed on cygwin.
 
 * I/O-intensive processes hung when executed via <exec spawn="true">.
   Bugzilla reports 23893/26852.
 
 * JDependTask did not close an output file. Bugzilla Report 28557.
 
 * Using <macrodef> could break XmlLogger. Bugzilla Report 28993.
 
 * <genkey> no longer requires keytool to be in your PATH.  Bugzilla
   Report 29382.
 
 * <symlink> could create cyclic links.  Bugzilla Report 25181.
 
 * <zip whenempty="skip"> didn't work in a common situation.  Bugzilla
   Report 22865.
 
 * <scp> now properly handles remote files and directories with spaces
   in their names.  Bugzilla Report 26097.
 
 * <scp> now has (local|remote)tofile attributes to rename files on the
   fly.  Bugzilla Report 26758.
 
 * <telnet> and <rexec> didn't close the session.  Bugzilla Report 25935.
 
 * <subant> and XmlLogger didn't play nicley together.
 
 Other changes:
 --------------
 * doc fix concerning the dependencies of the ftp task
   Bugzilla Report 29334.
 
 * <xmlvalidate> has now a property nested element,
   allowing to set string properties for the parser
   Bugzilla Report 23395.
 
 * Docs fixes for xmlvalidate.html, javadoc.html, starteam.
   Bugzilla Reports 27092, 27284, 27554.
 
 * <pathconvert> now accepts nested <mapper>s.  Bugzilla Report 26364.
 
 * Shipped XML parser is now Xerces-J 2.6.2.
 
 * Added nested file element to filelist.
 
 * spelling fixes, occurred. Bugzilla Report 27282.
 
 * add uid and gid to tarfileset. Bugzilla Report 19120.
 
 * <scp> has a verbose attribute to get some feedback during the
   transfer and new [local|remote][File|Todir] alternatives to file and
   todir that explicitly state the direction of the transfer.
 
 * The OS/2 wrapper scripts have been adapted to use the new launcher.
   Bugzilla Report 28226.
 
 * <sshexec> now also captures stderr output.  Bugzilla Report 28349.
 
 * <xslt> now supports a nested <mapper>.  Bugzilla Report 11249.
 
 * <touch> has filelist support.
 
 * <nice> task lets you set the priority of the current thread; non-forking
   <java> code will inherit this priority in their main thread.
 
 * New attribute "negate" on <propertyset> to invert selection criteria.
 
 * Target now supports a Location member.  Bugzilla Report 28599.
 
 * New "pattern" attribute for <date> selector.
 
 * <junit> has a new forkmode attribute that controls the number of
   Java VMs that get created when forking tests.  This allows you to
   run all tests in a single forked JVM reducing the overhead of VM
   creation a lot.  Bugzilla Report 24697.
 
 * <jar> can now optionally create an index for jars different than the
   one it currently builds as well.  See the new <indexjars> element
   for details.  Bugzilla Report 14255.
 
 * Permit building under JDK 1.5. Bugzilla Report 28996.
 
 * minor Javadoc changes. Bugzilla Report 28998.
 
 * Misc. corrections in SignJar.java. Bugzilla Report 28999.
 
 * Remove redundant <hr> from javah.html. Bugzilla Report 28995.
 
 * Ignore built distributions. Bugzilla Report 28997.
 
 * A new roundup attribute on <zip> and related task can be used to
   control whether the file modification times inside the archive will
   be rounded up or down (since zips only store modification times with
   a granularity of two seconds).  The default remains to round up.
   Bugzilla Report 17934.
 
 * A binary option has been added to <concat>. Bugzilla Report 26312.
 
 * Added DynamicConfiguratorNS, an namespace aware version of
   DynamicConfigurator. Bugzilla Report 28436.
 
 * Add implicit nested element to <macrodef>. Bugzilla Report 25633.
 
 * Add deleteonexit attribute to <delete>.
 
 * Added Target.getIf/Unless().  Bugzilla Report 29320.
 
 * <fail> has a status attribute that can be used to pass an exit
   status back to the command line.
 
 * <fail> accepts a nested <condition>.
 
 * <loadproperties> supports loading from a resource.
   Bugzilla Report 28340.
 
 * Nested file mappers and a container mapper implementation have been
   introduced.  Additionally, the <mapper> element now accepts "defined"
   nested FileNameMapper implementations directly, allowing a usage
   comparable to those of <condition>, <filter>, and <selector>.
 
 * New <redirector> type introduced to provide extreme I/O flexibility.
   Initial support for <exec>, <apply>, and <java> tasks.
 
 * <apply> has a new ignoremissing attribute (default true for BC)
   which will allow nonexistent files specified via <filelist>s to
   be passed to the executable.  Bugzilla Report 29585.
 
 * <junitreport> now also works with Xalan XSLTC and/or JDK 1.5.
   Bugzilla Report 27541.
 
 * <jspc> doesn't work properly with Tomcat 5.x.  We've implemented a
   work-around but don't intend to support future changes in Tomcat
   5.x.  Please use the jspc task that ships with Tomcat instead of
   Ant's.
 
 Changes from Ant 1.6.0 to Ant 1.6.1
 =============================================
 
 Changes that could break older environments:
 --------------------------------------------
 
 * License is now Apache License 2.0
   see http://www.apache.org/licenses/ for more information
 
 Fixed bugs:
 -----------
 * Remove a recursive template call in the junit xsls that could trigger a stack
   overflow. It now uses Xalan extensions to call a Java class directly.
   Bugzilla Report 19301
 
 * Fix spurious infinite loop detection for filters (introduced in ant 1.6.0).
   Bugzilla Report 23154.
 
 * Fix handling of default ant namespace for nested elements.
 
 * Fix jboss element of ejb task (introduced in ant 1.6.0).
 
 * <whichresource> failed to load classes correctly.
 
 * Ant could fail to start with a NullPointerException if
   ANT_HOME/lib/ant-launcher.jar was part of the system CLASSPATH.
 
 * presetdef'ed types did not work with the ant-type attribute
 
 * fixed case handling of macrodef attributes and elements. Bugzilla
   Reports 25687 and 26225.
 
 * <java> ignored the append attribute, Bugzilla Report 26137.
 
 * The gcj compiler adapter for <javac> failed if the destination
   directory didn't exist.  Bugzilla Report 25856.
 
 * Ant now fails with a more useful message if a new process will be
   forked in a directory and that directory doesn't exist.
 
 * <splash> used to break the build on non-GUI environments.  Bugzilla
   report 11482.
 
 * Ant 1.6.0 cannot run build scripts in directories with non-ASCII names.
   Bugzilla Report 26642.
 
 Other changes:
 --------------
 * Shipped XML parser is now Xerces-J 2.6.1
 
 * Translate task logs a debug message specifying the number of files
   that it processed.  Bugzilla Report 13938.
 
 * <fixcrlf> has a new attribute - fixlast. Bugzilla Report 23262.
 
 * <p4submit> has 2 new attributes, needsresolveproperty and changeproperty.
   Bugzilla Report 25711.
 
 * add description attributes to macrodef attributes and elements.
   Bugzilla Report 24711.
 
 * Extending ClearCase Tasks :
  - Added an extra option to 'failonerr' to each ClearCase task/command.
  - Extended the functionality of cccheckout. It can check (notco) to see if
   the desired element is already checked out to the current view. Thus it
    won't attempt to check it out again.
  - Added three new ClearCase commands: ccmkattr, ccmkdir, ccmkelem
   Bugzilla Report 26253.
 
 * added nested text support to <macrodef>
 
 * added initial support for Java 1.5.  Java 1.5 is now correctly
   detected by Ant and treated just like Java 1.4.  You can now specify
   source="1.5" in the <javac> task.
 
 * created new task <cvsversion>
 
 * added support for branch logging via the tag attribute in <cvschangelog>
   Bugzilla Report 13510.
 
 * added support the groovy language in the script and scriptdef tasks
 
 Changes from Ant 1.5.4 to Ant 1.6.0
 ===================================
 
 Changes that could break older environments:
 --------------------------------------------
 
 * This version of Ant can not be built with JDK 1.1 and requires at
   least Java 1.2 at runtime as well.  Compiling for a 1.1 target is
   still supported.
 
 * Targets cannot have the empty string as their name any longer.
 
 * ant.jar's manifest does no longer include a Class-Path entry, so it
   is no longer possible to run Ant via "java -jar ant.jar" without
   manually altering the CLASSPATH.  Instead of that a file
   ant-bootstrap.jar is included in the etc directory of the binary
   distribution, copy this to the lib directory and use
   "java -jar ant-bootstrap.jar" instead if you want to run Ant without
   the wrapper script (not recommended).
 
 * The <script> task now requires Apache BSF instead of the older IBM
   version.  See <http://jakarta.apache.org/bsf/>
 
 * <xmlproperty> will no longer fail if the file to be loaded doesn't exist.
 
 * XML namespaces are now enabled in the XML parser, meaning XML namespace
   declarations no longer cause errors. However task names containing colons
   will cause errors unless there is a corresponding namespace uri.
 
 * The <ftp> and <telnet> tasks now require Jakarta Commons Net instead
   of the older ORO Netcomponents version.  See
   <http://jakarta.apache.org/commons/net/index.html>.
 
 * <input> will no longer prompt the user and wait for input if the
   addproperty attribute is set to a property that has already been
   defined in the project.  If you rely on the task waiting for input,
   don't use the addproperty attribute.
 
 * The Class-Path attribute in manifests will no longer merge the
   entries of all manifests found, but will be treated like all other
   manifest attributes - the most recent attribute(s) will be used.
 
 * New Launch mechanism implemented. This moves some functionality from
   the batch files / shell scripts into Java. This removes environment
   limitations, for command issues, directory depth issues on Windows. Also
   allows a per-user library location to be used if the main Ant install
   is locked down.
 
 * The Entry nested element of PropertyFile will not any more have its value
   attribute (actually increment) overwritten with the new value of the entry
   after execution.
 
 * Output stored from a <java> or <exec> task is now exactly as generated. No
   conversion to platform end-of-line characters is performed.
 
 * <translate> will now preserve line endings.
 
 * <ftp> followsymlinks="false" in nested fileset definitions is explicitly
   required in order to exclude remote symbolic links (when doing a get, chmod,
   delete, rmdir).
 
 * The values of the Copy#fileCopyMap variable has changed from String to
   String[]. (In java 1.5 terms it was Hashtable<String, String> and
   is now Hashtable<String, String[]>). This will affect third party code
   that extend Copy and override Copy#doFileOperations.
 
 * <loadproperties> didn't expand properties while <property file="..."/>
   does, so they were not equivalent.  This has been fixed, which means
   that propetries may get expanded twice if you use an
   <expandproperties> filterreader.  Bugzilla Report 17782.
 
 * User defined tasks and typedefs are now handled internally in the
   same way as predefined tasks and typedefs. Also tasks and typedefs
   are resolved at a later stage. This causes some
   differences especially for user defined task containers.
 
 * <checksum> log message "Calculating checksum ..." has been degraded
   from INFO to VERBOSE.
 
 Fixed bugs:
 -----------
 * Filter readers were not handling line endings properly.  Bugzilla
   Report 18476.
 
 * Filtersets were also not handling line endings properly.
 
 * Expand tasks did not behave as expected with PatternSets.
 
 * <property environment=... /> now works on OS/400.
 
 * <cab> could hang listcab on large <fileset>s.
 
 * The starteam stcheckout, stcheckin tasks now correctly compute
   status of files against whatever local tree they are run against
   and, optionally, will not process a file if it is current.
   Previously you had to process everything unless you ran against the
   default folder which wasn't the normal use-case for ant-starteam.
   The stlist task now similarly displays that status correctly making
   it a more generally useful tool.
 
 * entity includes would cause exceptions if path names included spaces.
 
 * addConfiguredXXX would not work for TaskAdapter wrapped tasks
 
 * Fix <ilasm> outputfile testing so that the output file does not need
   to exist beforehand.
 
 * Ant will now exit with a return code of 1 if it encounters problems
   with the command line arguments.
 
 * ClassLoader creation changes to use a factory method in Project. A new
   class AntClassLoader2 implemented for 1.2+ specific features including
   Package information and addition of classes specified in the Class-Path
   element of a Jar's manifest.
 
 * It is now possible in <exec> to resolve the executable to a project
   basedir or execution dir relative executable. The resolveExecutable
   must be used to pick up such executables.
 
 * splash screen wouldn't disappear when build was finished.
 
 * <exec> output and error streams can now be redirected independently
   to either a property or a file (or both)
 
 * TarEntry's File-arg constructor would fail with a
   StringIndexOutOfBoundsException on all OSes where os.name is shorter
   than seven characters.  Bugzilla Report 18105.
 
 * <copy> and <move>'s failonerror didn't apply to filesets pointing to
   non-existent directories.  Bugzilla Report 18414.
 
 * The <stripjavacomments> filter sometimes removed parts of string
   constants.  Bugzilla Report 17441.
 
 * <antlr> will now recompile your grammar if the supergrammar has
   changed.  Bugzilla Report 12691.
 
 * <property env> will now work on Unices with /bin/env instead of
   /usr/bin/env.  Bugzilla Report 17642.
 
 * <jar index="on"> could include multiple index lists.  Bugzilla 10262.
 
 * The index created by <jar> didn't conform to the spec as it didn't
   include the top-level entries.  Bugzilla Report 16972.
 
 * <tar> and <zip> didn't honor the defaultexcludes attribute for the
   implicit fileset.  Bugzilla Report 18637.
 
 * The <replacetokens> filter would throw an exception if the token's
   value was an empty string.  Bugzilla Report 18625.
 
 * Perforce tasks relying on output from the server such as <p4change>
   and <p4label> were hanging. Bugzilla Reports 18129 and 18956.
 
 * Improve exception and logging behavior of Perforce tasks.
   Bugzilla report 18154.
 
 * build.sh install had a problem on cygwin (with REALANTHOME).
   Bugzilla Report 17257
 
 * <replaceregexp> didn't work for multi-byte encodings if byline was false.
   Bugzilla Report 19187.
 
 * <replaceregexp> was altering unnecessarily the timestamp of the directories
   containing the files to process
   Bugzilla Report 22541.
 
 * file names that include spaces need to be quoted inside the @argfile
   argument using forked <javac> and (all JDKS).  Bugzilla Report 10499.
   NB : a first correction was only introducing quotes for JDK 1.4
   It has been changed to quote for all external compilers when paths
   contain spaces.
   Also the backslashes need to be converted to forward slashes
   Bugzilla Report 17683.
 
 * Setting filesonly to true in <zip> and related tasks would cause the
   archives to be always recreated.  Bugzilla Report 19449.
 
 * file names that include spaces need to be quoted inside the @argfile
   argument using <javadoc> and JDK 1.4.  Bugzilla Report 16871.
 
 * <junit> didn't work with custom formatters that were only available
   on the user specified classpath when a timeout occurred.  Bugzilla
   Report 19953.
 
 * <different> selector : make ignoreFileTimes effectively default to true
   and fix a bug in the comparison of timestamps. Bugzilla Report 20205.
 
 * <different> selector can now be nested directly under a fileset
   Bugzilla Report 20220.
 
 * <cvstagdiff> had a problem with "dd-MM-yy hh:mm:ss" formats
   Bugzilla Report 15995.
 
 * <cvstagdiff> cvsroot and package attributes added to the root
   element tagdiff of the xml output
   Bugzilla Report 16081.
 
 * <cvstagdiff> had a problem with aliased modules and with requests for
   multiple modules. Bugzilla Reports 21373 and 22877.
 
 * <cvstagdiff> could not parse properly the revision number of new files with
   CVS 1.11.9 or higher. Bugzilla Report 24406.
 
 * <fixcrlf> make fixcrlf create its temporary files in the default directory
   of FileUtils#createTempFile instead of the destination dir of fixcrlf.
   Bugzilla Report 20870.
 
 * <ejbjar> implementation for Borland.
   Prevent the task from being blocked by error messages coming from java2iiop.
   Bugzilla Report 19385.
 
 * <unzip>'s and <untar>'s nested patternsets didn't work as documented
   when the pattern ended in a slash or backslash.  Bugzilla Report 20969.
 
 * <fixcrlf> will now create the parent directories for the destination
   files if necessary.  Bugzilla Report 20840.
 
 * <xmlproperty> now handles CDATA sections. BugZilla Report 17195
 
 * <translate> now translate tokens that are placed close together.
   Bugzilla Report 17297
 
 * Nested websphere element for ejbjar does not support spaces in file name.
   Bugzilla Report 21298
 
 * Don't multiply Class-Path attributes when updating jars.  Bugzilla
   Report 21170.
 
 * Do not overwrite the value (increment) attribute of PropertyFile nested
   Entry element. Bugzilla Report 21505.
 
 * Prevent sysproperties with no key or no value from being added in <junit>.
   Bugzilla Report 21684.
 
 * Allow references to be properly inherited via antcall
   Bugzilla Report 21724.
 
 * ftp chmod failed when the remote system was UNIX and local system Windows
   Bugzilla Report 21865.
 
 * ftp put with chmod failed when the remote system was UNIX and local system
   Windows. Bugzilla Report 23143.
 
 * ftp did not set the ascii mode explicitly, causing problems with ftp servers
   having binary as default
 
 * ftp was not able to download files when they were pointed to by symbolic
   links. Bugzilla Report 14063.
 
 * ftp is able to download also directories pointed to by symbolic links.
 
 * replace would change \r\n into \r\r\n under Windows.
 
 * junitreport with frames did not display a link for classes without a package
   or in the top package.
   Bugzilla Report 21915.
 
 * Project.toBoolean(String) now handles null as argument and does not throw a
   NullPointerException any more.
 
 * The socket condition will now close the socket created to test.
   Bugzilla Report 23040.
 
 * <junit includeantruntime="true" fork="true"> replaced the CLASSPATH instead
   of adding to it.  Bugzilla Report 14971.
 
 * <splash> could fail on JVMs that use null to indicate the system classloader.
   Bugzilla Report 23320.
 
 * <xmlcatalog>s only worked when defined inside of tasks.  Bugzilla
   Report 20965.
 
 * <csc> and siblings (<vbc> <jsharpc>) handle large filesets by
 automatic use of response files.  Bugzilla report #19630
 
 Other changes:
 --------------
 
 * Shipped XML parser is now Xerces 2.6.0
 
 * All tasks can be used outside of <target>s.  Note that some tasks
   will not work at all outside of targets as they would cause infinite
   loops (<antcall> as well as <ant> and <subant> if they invoke the
   current build file).
 
 * Six new Clearcase tasks added.
 
 * A new filter reader namely tokenfilter has been added.  Bugzilla
   Report 18312.
 
 * A new attribute named skip is added to the TailFilter and
   HeadFilter filter readers.
 
 * The filesetmanifest attribute of <jar> has been reenabled.
 
 * The start and end tokens for <translate> may now be longer than a
   single character.
 
 * <setproxy> lets you set the username and password for proxies that
   want authentication
 
 * <loadproperties> has a new encoding attribute.
 
 * <echoproperties> can now create XML output.
 
 * <echoproperties> has a new srcfile attribute that can make it read
   properties files and output them instead of Ant's properties.
 
 * <filterset> will now resolve filters recursively.
 
 * <input> has a new attribute that allows you to specify a default value.
 
 * Added <image> task (requires JAI).
 
 * <image> task has now proportions attribute in the <scale/> nested element
   instead of keepproportions (bringing in more functionality)
 
 * New condition <isreference>
 
 * <ftp> now has a preservelastmodified attribute to preserve the
   timestamp of a downloaded file.
 
 * new rmdir action for <ftp> that removes directories from a fileset.
 
 * <ftp> has attributes timediffauto and timediffmillis to use together
   with the newer attribute to tell ant to take into account a time difference
   between client and remote side.
   Bugzilla Report 19358.
 
 * <ftp> has been optimized to go directly to the include patterns.
   This reduces scanning time under UNIX when followsymlinks="true"
   and casesensitive="true" (the default)
   Bugzilla Report 20103.
 
 * The SOS and VSS tasks will no longer unconditionally prepend a $ to
   vsspath or projectpath.
 
 * OS/400 now gets detected by the os condition.
 
 * <arg> has a new attribute pathref that can be used to reference
   previously defined paths.
 
 * <xmlproperty> has been improved, you can now expand ${properties},
   define ids or paths and use Ant's location magic for filename resolutions
   in the XML file.
 
 * <xmlcatalog> will now support external catalogs according to the
   OASIS "Open Catalog" standard - if resolver.jar (newer than version
   1.0) from Apache's xml-commons is in your CLASSPATH.
 
 * Starteam tasks now have support for revision labels and build labels.
   Checkouts now have the option of using repository timestamps, instead
   of current.
 
 * new task <symlink> that creates and maintains symbolic links.
 
 * new tasks <chown> and <chgrp> which are wrappers of the Unix commands.
 
 * new task <attrib> to change file attributes on Windows systems.
 
 * <style> has a new attribute reloadstylesheet to work around a
   bug in widespread Xalan versions.
 
 * <tarfileset> has a new dirmode attribute to specify the permissions
   for directories.
 
 * <fixcrlf>'s eol attribute now also understands "mac", "unix" and "dos".
 
 * <classfileset> now picks up dependencies of the form MyClass.class. This
   works for the code generated by the Sun java compiler. It may not work for
   all compilers.
 
 * a new attribute "globalopts" can be added to all Perforce tasks.
   You can put in it all the strings described by p4 help usage. Refer to
   the docs for more information.
 
 * new Perforce tasks <p4integrate> , <p4resolve>, and <p4labelsync>
 
 * <p4submit> will change the property p4.change if the Perforce server
   renumbers the change list.
   It will set the property p4.needsresolve if the submit fails,
   and the message says that file(s) need to be resolved.
 
 * <replaceregexp> now has an optional encoding attribute to support
   replacing in files that are in a different encoding than the
   platform's default.
 
 * The <exec> task may now have its input redirected from either a file
   or a string from the build file. The error output can be separated
   to a different file when outut is redirected. standard error may be
   logged to the Ant log when redirecting output to a file
 
 * The <java> task also supports the input redirection and separate
   error streams introduced to the <exec> task. In addition, it is now
   possible to save the output into a property for use within the build
   file as was possible with <exec> in Ant 1.5
 
 * The <javadoc> task <tag> subelement has been enhanced to allow files
   with tag mappings to be used.
 
 * New tasks: <scp> supports file transfers, <sshexec> executes a
   command over SSH.  They require jsch, a BSD licensed SSH library that
   can be found at http://www.jcraft.com/jsch/index.html
 
 * New filterreader <escapeunicode/>.
 
 * Support for HP's NonStop Kernel (Tandem) OS has been added.
 
 * <cab>'s basedir attribute is now optional if you specify nested
   filesets.  Bugzilla Report 18046.
 
 * New task <sync> that synchronizes two directory trees.
 
 * <apply> has new forwardslash attribute that can force filenames to
   use forward slashes (/) as file separators even on platforms with a
   different separator.  This is useful if you want to run certain
   ported Unix tools.
 
 * Copy has a new outputencoding attribute that can be used to change
   the encoding while copying files.  Bugzilla Report 18217.
 
 * The xml formatter for JUnit will now honor test case names set with
   setName.  Bugzilla Report 17040.
 
 * JUnit now has an attribute reloading, which, when set to false,
   makes the task reuse the same class loader for a series of tests.
 
 * <concat> now supports filtering and can check timestamps before
   overriding a file.  Bugzilla Report 18166.
 
 * <junit> has a new attribute tempdir that controls the placement of
   temporary files.  Bugzilla Report 15454.
 
 * <jdepend> now supports a new nested element <classespath> which is
   the same as <sourcespath> but point to compiled classes (the
-  prefered mode of operation for JDepend > 2.5).  Additionally, nested
+  preferred mode of operation for JDepend > 2.5).  Additionally, nested
   <exclude> elements can be used to exclude certain packages from
   being parsed.  Bugzilla Report 17134.
 
 * The JProbe tasks now also work with JProbe 4.x.  Bugzilla Report 14849.
 
 * <javacc> and <jjtree> will now autodetect JavaCC 3.x and can use it.
 
 * <sql> has a new attribute to control escape processing.
 
 * <sql> is able to display properly several resultsets if you are
   running a compound sql statement. Bugzilla Report 21594.
 
 * A new <containsregexp> selector has been added, that selects files
   if their content matches a certain regular expression.
 
 * <antlr>'s debug attribute has been enabled.  Bugzilla Report 19051.
 
 * <mail> has a new attribute charset. Bugzilla Report 15434.
 
 * <mail> has new attributes user and password for SMTP auth.
   maillogger can also use this.
   The implementation only works with JavaMail (encoding="MIME").
   Implementation with plain mail remains to do.
   Bugzilla Report 5969.
 
 * <mail> and mailloger support SMTP over TLS/SSL
   Bugzilla Report 19180.
 
 * <mail> the attributes from, replyto ,tolist, cclist, bcclist
   can now contain email addresses of the form name <address@xyz.com>
   or (name) address@xyz.com
   Bugzilla Report 22474.
 
 * <mail> (version PlainMail)
   prevent blank headers from being sent,
   make the order of the headers of plain mail messages predictable
   Bugzilla Report 22088.
 
 * <zipfileset> can now be defined in the main body of a project
   and referred to with refid="xyz". Bugzilla Report 17007.
 
 * A wrapper script for OS/2 has been added.
 
 * <unzip> will now detect and successfully extract self-extracting
   archives.  Bugzilla Report 16213.
 
 * <stcheckout> has a new attribute "converteol" that can be used to
   control the automatic line-end conversion performed on ASCII files.
   Bugzilla Report 18884.
 
 * Users can now modify the list of default excludes using the new
   defaultexcludes task.  Bugzilla Report 12700.
 
 * There is a new data type <propertyset> that can be used to collect
   properties.  It is supported by <ant>, <antcall>, <subant>, <java>,
   <echoproperties> and <junit>.
 
 * <concat> can now control the encoding of the output as well and optionally
   add new-line characters at the end of files that get concatenated but
   don't end in newlines.  Bugzilla Report 12511.
 
 * <rpm> will detect the rpmbuild executable of RedHat 8.0 and newer
   and use that if it is on your PATH.  Bugzilla Report 14650.
 
 * A new task <rexec> has been added that requires commons-net to work.
   Bugzilla Report 19541.
 
 * <javadoc> now supports a nested <arg> element in addition to the
   additionalparams attribute.
 
 * You can now determine the order of standard tags in <javadoc> via
   <tag> elements - you must not use the description attribute for them.
   Bugzilla Report 18912.
 
 * <javadoc> now supports the -noqualifier switch.  Bugzilla Report 19288.
 
 * <javac>'s executable attribute can now also be used to specify the
   executable for jikes, jvc, sj or gcj.  Bugzilla Report 13814.
 
 * <javac> has a new attribute tempdir that can control the placement
   of temporary files.  Bugzilla Report 19765.
 
 * A new magic property build.compiler.jvc.extensions has been added
   that can be used to turn of Microsoft extensions while using the jvc
   compiler.  Bugzilla Report 19826.
 
 * You can now limit the parallelism of <apply> and <chmod> by using the new
   maxparallel attribute.
 
 * With the new addsourcefile attribute, you can make <apply> ommit the
   source file names from the command line.  Bugzilla Report 13654.
 
 * <apply> and <chmod> now support nested <filelist>s as well as <dirset>s.
   Bugzilla Reports 15929 and 20687.
 
 * <apply> and <chmod> will display a summary if you set the new
   verbose attribute to true.  Bugzilla Report 19883.
 
 * <copy>/<move>'s failonerror attribute can now also be used to
   continue the build if an I/O error caused a problem.  Bugzilla
   Report 12999.
 
 * new selector <type/> allowing to select only files or only directories.
   Bugzilla Report 20222.
 
 * <java> and <junit> now support a nested <bootclasspath> element that
   will be ignored if not forking a new VM.
 
 * <junit>'s nested <formatter> elements now support if/unless clauses.
 
 * <ejbjar>
   cmpversion attribute added
   jboss element will look for jbosscmp-jdbc.xml descriptor
   if ejbjar has cmpversion="2.0" set
   Bugzilla Reports 14707 and 14709.
 
 * <pvcs> config attribute added to set the location of a specific PVCS
   .cfg file
   Bugzilla Report 9752
 
 * <mapper> has an "unpackage" mapper
   Bugzilla Report 18908
 
 * Added <scriptdef> task allowing tasks to be defined using any BSF-supported
   scripting language.
 
 * <touch>'s datetime attribute can now accept time with a granularity
   of seconds as well.  Bugzilla Report 21014.
 
 * <checksum> has two new properties: totalproperty and todir.
 
 * FileUtils#createTempFile will now create temporary files in the
   directory pointed to by the property java.io.tmpdir
 
 * <unzip> and friends now supports an optional encoding attribute to
   enable it to expand archives created with filenames using an encoding
   other than UTF8.  Bugzilla Report 10504.
 
 * <patch> has a new attribute destfile that can be used to create a new
   file instead of patching files in place.
 
 * OpenVMS is detected as a valid OS family.
 
 * DirectoryScanner has been optimized for cases where include patterns do not
   start with wildcards.  Bugzilla Report 20103.
 
 * DirectoryScanner begins to be optimized not to scan excluded directories.
   Bugzilla Report 21941.
 
 * Added keep-going feature. Bugzilla Report 21144
 
 * The archives generated by <zip> and friends will now contain CRC and
   size information in the "local file header", thereby providing this
   information to applications that read the archives using
   java.util.ZipInputStream.  Bugzilla Report 19195.
 
 * <copy> and <move> can now handle mappers that return multiple
   mappings per source path. This behaviour is enabled by using
   an enablemultiplemapping attribute. Bugzilla Report 21320.
 
 * <exec> will now work on OpenVMS (please read the notes in
   <exec>'s manual page).  Bugzilla Report 21877.
 
 * <exec> will now have a new attribute spawn (default false).
   If set to true, the process will be spawned. Bugzilla Report 5907.
 
 * <java> will now have a new attribute spawn (default false).
   If set to true, the process will be spawned. Bugzilla Report 5907.
 
 * <parallel> now supports a timeout which can be used to recover
   from deadlocks, etc in the parallel threads. <parallel> also
   now supports a <daemons> nested element. This can be used to
   run tasks in daemon threads which the parallel task will not
   wait for before completing. A new attribute failonany will cause
   <parallel> to throw an exception if any thread fails without
   waiting for all other threads to complete.
 
 * <zip> and friends will consume far less memory than they used to
   when run with compress="false".  Bugzilla Report 21899.
 
 * <if/> and <unless/> attributes added to <param/> element of <style>
    Bugzilla Report 22044
 
 * <zip> and friends have a new attribute "keepcompression" that can be
   used to incrementally build an archive mixing compressed and uncompressed
   entries.
 
 * <junit>'s XML formatter adds a new classname attribute to the <testcase>
   elements.
 
 * new <permissions> type add permission handling to the code
   this type can be nested in the <java> and <junit> tasks.
   Bugzilla Report 22533.
 
 * additional shortcuts for ant options (-d --> -debug, -e --> -emacs,
   -h --> -help, -p --> -projecthelp, -s --> -find).
 
 * new selector <modified>. "cache" was renamed to "modified".
   Bugzilla Report 20474.
 
 * <stcheckout> and <stlist> have a new asofdate attribute that can be
   used to checkout/list files based on a date instead of a label.
   Bugzilla Report 20578.
 
 * New filter <concatfilter>. Adds the content of file at the beginning
   or end of a file. Discussion started at
   http://marc.theaimsgroup.com/?l=ant-user&m=106366791228585&w=2
 
 * New task <import>
 
 * New task <macrodef>
 
 * New task <presetdef>
 
 * Ant libraries that can make use of namespaces to avoid name
   clashes of custom tasks
 
 * <java> and <junit> now support <assertions>, which let you enable
   and disable Java1.4 assertions on a package or class basis. These
   only work when fork=true, currently.
 
 * .NET tasks expanded with VB support <vbc> and J#, via <jsharp>,
   <importtypelib> and <ilasm>. <csc> supports nested <src> types,
   <defines> for (potentially conditional) definitions, <reference>
   filesets for references. The executable attribute lets you switch to
   mono or other implementations -<csc> has been tested with Mono on
   Linux and OSX.
 
 
 Changes from Ant 1.5.3 to Ant 1.5.4
 ===================================
 
 Changes that could break older environments:
 --------------------------------------------
 
 * If the Visual Age tasks used to work for you, they may stop doing so
   now - and we'd like to know about it.  The current set of tasks is
   supposed to work with any version of VAJ starting with 3.0.
 
 Fixed bugs:
 -----------
 
 * The Visual Age for Java tasks didn't work (at least for versions 3.0
   and higher).  Bugzilla Report 10016.
 
 * URL-encoding in <vaj*port> didn't work properly.
 
 * VAJRemoteUtil called getAbsolutePath instead of getPath
   causing problems when using a Windows VAJ server from a UNIX server.
   Bugzilla Report 20457.
 
 * VAJImport task failed with NullPointerException when using DirectoryScanner.
   Bugzilla Report 22080.
 
 Other changes:
 --------------
 
 * Shipped XML parser is now Xerces 2.5.0
 
 * <javah> will invoke oldjavah on JDK 1.4.2.  Bugzilla Report 18667.
 
 * The VAJ tasks now support a haltonfailure attribute to conditionally
   keep building even if they fail.
 
 * It is now possible to use the latest (versioned or unversioned) edition
   in <vajload> by using special wildcard characters.  Also fixes
   Bugzilla Report 2236.
 
 Changes from Ant 1.5.2 to Ant 1.5.3
 ===================================
 
 Changes that could break older environments:
 --------------------------------------------
 
 * The <zip> task and friends have again changed a method signature
   (sorry, was necessary to fix bug 17780).  The return type of
   getResourcesToAdd has changed.
 
 Fixed bugs:
 -----------
 
 * <zipfileset>'s filemode would get ignored and the dirmode was used
   for the included files as well.  As a side effect, WinZIP was unable
   to extract or display the files, so they seemed to be missing from
   the archive.  Bugzilla Report 17648.
 
 * <ftp> could use the wrong path separator when trying to change the
   remote working directory.  Bugzilla Report 17735.
 
 * <jar update="true"> would loose all original files if you didn't
   specify any nested <(zip)fileset>s and the manifest had changed.
   Bugzilla Report 17780.
 
 * If you used a value starting with \ on Windows for the appxml
   attribute of <ear> or the webxml attribute of <war>, it would be
   ignored.  Bugzilla Report 17871.
 
 * Ant will no longer implicitly add Sun's rt.jar in <javac> when you
   use jvc and don't specify a bootclasspath.  Bugzilla Report 18055.
 
 * The prefix attribute of <zipfileset> would not generate directory
   entries for the prefix itself.  Bugzilla Report 18403.
 
 * starteam checkout can now handle deleted labels.  Bugzilla Report 17646.
 
 * The Unix wrapper script failed if you invoked it as a relative
   symlink and ANT_HOME has not been set.  Bugzilla Report 17721.
 
 Other Changes:
 --------------
 * Added ability to specify manifest encoding for the <jar> and
   <manifest> tasks
 
 Changes from Ant 1.5.1 to Ant 1.5.2
 =============================================
 
 Changes that could break older environments:
 --------------------------------------------
 * ANT_OPTS environment variable is now applied at the start of the
   Java command line, allowing position specific parameters of some
   JVMs, such as -classic to be specified.
 
 * ZipScanner#getIncludedFiles will now return the names of the ZipEntries
   that have been matched instead of the name of the archive.
 
 * The <zip> task and friends have been heavily modified, almost every
   method signature of the Zip class has changed.  If you have subclassed
   Zip (or one of its subclasses), your class will most likely not
   compile against the current code base.  If it still compiles, it will
   probably not work as in Ant 1.5.1.
 
 Fixed bugs:
 -----------
 * <translate> was not ignoring comment lines.
 
 * <manifest> wouldn't update an existing manifest if only an attribute
   of an existing section changed.
 
 * ant.bat now supports the ANT_ARGS and JAVACMD environment variables
   again (like Ant 1.5 did).
 
 * The "plain" <junit> <formatter> could throw a NullPointerException
   if an error occurred in setUp.
 
 * <junit> will now produce output when a test times out as well.
 
 * <replace> would count some internal character replacements when
   reporting the number of replaced tokens.
 
 * <concat> would cause an exception if a <filelist> pointed to files
   that do not exist.
 
 * <javadoc> will now pass -source to custom doclets as well.
 
 * <cvstagdiff> would throw a NullPointException if there had been no
   differences.
 
 * <cvschangelog> could miss today's changes.
 
 * <concat> could append newline characters between concatenated files.
 
 * <xmlvalidate> ignored the specified encoding of the files to
   validate.
 
 * the errorsbeginat attribute of the <http> condition didn't work.
 
 * Ant will try to force loading of certain packages like com.sun.*
   from the system classloader.  The packages are determined by the
   version of the JVM running Ant.
 
 * Ant didn't find the runtime libraries on IBM's JDK 1.4 for Linux.
 
 * random component of temporary files is now always a positive integer.
 
 * Ant could incorrectly try to use the 1.4 regexp implementation even
   if it isn't available if you run the JVM with -Xverify:none.
 
 * Ant would die with an exception if you used nested <reference>
   elements in Ant and the refid attribute didn't point to an existing
   project reference.
 
 * The <get> task can now be compiled (and Ant thus bootstrapped) using
   Kaffee.
 
 * build.sysclasspath will now be honored by more tasks.
 
 * The signjar keystore attribute has been reverted to a String allowing
   it to once again accept URLs. This should not affect current File based usage
   unless you are extending the Signjar task.
 
 * <jar update="true"> would remove the original manifest.
 
 * fix up folder creation in PVCS task
 
 * <tar>'s up-to-date check didn't work for nested <(tar)fileset>s.
 
 * Corrected a problem in XMLLogger where it would not associated
   messages with a taskdef'd task
 
 * <uptodate> now works when using attributes (i.e. not filesets) and pointing
   to the same file
 
 * Java task (and output system) now stores output which doos not end
   with a line feed.
 
 * splash screen wouldn't disappear when build was finished.
 
 * <exec> now supports OS/2.
 
 * <zip> and friends would only update/recreate existing archives if
   the files to add/update have been newer than the archive.
 
 * <javadoc>'s <link> element could fail for offline="true" on some JDKs.
 
 Other changes:
 --------------
 
 * MailLogger now sets the Date header correctly.
 
 * Shipped XML parser is now Xerces 2.3.0
 
 * signjar now accepts a maxmemory attribute to allow the memory allocated to the
   jarsigner tool to be specified. The jarsigner from the JDK's JAVA_HOME bin
   dir is now used rather than the first jarsigner on the path.
 
 * **/.DS_Store has been added to the list of default pattern excludes.
 
 * The Created-By header in the default manifest now contains the JVM
   vendor and version according to the jar specification. A new header,
   Ant-Version provides the Ant version used to create the jar.
 
 * <zip> can now store Unix permissions in a way that can be
   reconstructed by Info-Zip's unzip command.
 
 Changes from Ant 1.5.1Beta1 to 1.5.1
 ====================================
 
 Fixed bugs:
 -----------
 
 * <tstamp>'s prefix attribute failed to apply to nested <format> elements.
 
 * <junitreport> created an empty junit-noframes.html if no format had
   been specified.
 
 * <basename> would remove more than it should if the file name
   contained more than one dot.
 
 * <filterset>s nested into <filterset>s didn't work.
 
 Other changes:
 --------------
 
 * Shipped XML parser is now Xerces 2.2.0
 
 * Filesets now support a 'file' attribute, allowing a single-file
   fileset to be constructed without having to specify its parent
   directory separately.
 
 * <junit> will now return the result of a call to getName instead of
   "unknown" for Test implementations that don't extend TestCase but have
   a public String getName() method.
 
 Changes from Ant 1.5 to 1.5.1Beta1
 ==================================
 
 Fixed bugs:
 -----------
 * Date/time in CvsChangeLog was in local timezone and 12 hour format leading
   to a problem when sorting by time. It is now UTC (GMT) and in 24-hour
   format as per cvs 'specifications'.
 
 * CvsTagDiff now supports ampersand modules or modules that have a different
   root directory than their name.
 
 * EjbJar threw NPEs for the Websphere element. The property 'websphere.home'
   was not documented.
 
 * Mail example in the documentation was not correct.
 
 * Checksum was broken in the following scenario:
   (using verifyproperty OR in a condition) AND using filesets
   with multiple files.
 
 * The ExpandProperties filter threw NPEs when defined using
   the <filterreader> format.
 
 * The sh wrapper script didn't work under Cygwin if ANT_HOME wasn't
   set with a Unix style filename.
 
 * The sh wrapper script could fail if you started Ant from a directory
   with whitespace in its name.
 
 * ant -diagnostics was not working properly when the task dependency
   was missing and was just printing the missing dependency.
 
 * If a task got redefined via <taskdef>, it lost its child elements.
 
 * <property>'s classpathref attribute was broken.
 
 * <arg line="''" /> would result in no command line argument, will now
   be a single empty argument.  Use <arg value="''"/> if you need the
   quotes literally.
 
 * <replaceregexp> could append a newline character at the end of the
   file.
 
 Other changes:
 --------------
 
 * Appendix E of Java Development with Ant (Loughran/Hatcher) was
   contributed to the docs.
 
 * <available> will only print deprecration warnings if it is actually
   used to change the value of a property.
 
 Changes from Ant 1.5beta3 to Ant 1.5
 ====================================
 
 Changes that could break older environments:
 --------------------------------------------
 
 * The filesetmanifest attribute added to <jar> after the 1.4.1
   release has been removed for now.  This change may affect only
   the 1.5Beta/1.6Alpha users.  An attempt will be made to add this
   feature back into Ant 1.6.
 
 Fixed bugs:
 -----------
 
 * <zip> and friends would always update existing archive if you set
   the update attribute to true.
 
 * To support backward compatibility with older versions, <pathconvert>
   will once again set the property, even if the result is the empty
   string, unless the new 'setonempty' attribute is set to false|no|off
   (default is "true").
 
 * The manifest task would crash XmlLogger
 
 Other changes:
 --------------
 
 * added **/.svn and **/.svn/** to the default excludes
 
 Changes from Ant 1.5beta2 to Ant 1.5beta3
 =========================================
 
 Changes that could break older environments:
 --------------------------------------------
 
 * <pvcs> default filenameformat has been different from Ant 1.4.1.
   Now it is different from 1.5beta1 and 1.5beta2.
 
 * <pathconvert> won't set the property if the result is the empty string.
 
 Fixed bugs:
 -----------
 
 * <available> could fail to find files or directories that happen to
   start with the name of the project's basedir but are not children of
   the basedir.
 
 * Nested <property>'s inside <ant> can now be overriden by subsequent
   <ant> and <antcall> tasks.
 
 * <xslt>'s outputtype attribute wouldn't do anything.
 
 * <linecontains> filterreader could swallow lines.
 
 * <sequential> used to configure the tasks (set their attributes)
   before the first task has been executed.  This means that properties
   that have been set by nested task seemed to be unset for the other
   tasks in the same <sequential> element.
 
 * <javac>'s sourcepath setting has been ignored by some compiler
   implementations.
 
 * <javadoc>'s packagelist attribute didn't work.
 
 * the plain mailer would always use port 25 in <mail>.
 
 * Ant's default logger could swallow empty lines.
 
 * ejbjar's iPlanet nested element now can process multiple descriptors.
 
 * IPlanetEjbc was looking in the wrong place for four iiop files.
 
 * <javac> would pass the -source switch to JDK 1.3's javac, even
   though it doesn't support it.
 
 Other changes:
 --------------
 
 * <checksum> now uses a buffer (of configurable size).
 
 * The "Trying to override task definition" warning has been degraded
   to verbose level if the two task definitions only differ in the class
   loader instance that has loaded the definition.
 
 * Add a jvmargs to the ejbjar's weblogic element to allow additional
   arguments to be provided to the VM runnign ejbc. Document the
   jvmdebuglevel attribute which can be used to avoid warnings about
   interface classess being found on the classpath. Document the new
   <sysproperty> element which allows JVM properties to be defined.
   Added an outputdir attribute to allow the destination to be a
   directory into which the exploded jar is written.
 
 * ejbjar now supports Borland Enterprise Server 5 and Jonas 2.5
 
 Changes from Ant 1.5beta1 to Ant 1.5beta2
 =========================================
 
 Changes that could break older environments:
 --------------------------------------------
 
 * Properties will now be expanded in mail message bodies.  This means
   that one $ sign will be stripped if your mail message contains the text $$.
 
 * org.apache.tools.ant.taskdefs.Expand no longer extends MatchingTask.
 
 * Available#setFile now again uses a File argument as it did in 1.4,
   this may break environments that have been adapted to the String
   argument version present in 1.5beta1.
 
 Fixed bugs:
 -----------
 * When <move> attempts a rename, it deletes the destination file, if it
   exists, before renaming the source file.  However, <move> was not
   checking if the destination file was actually a directory before
   trying to delete it.
 
 * Make CVS Tasks to work under Cygwin.
 
 * Fix LineContains to handle huge files elegantly without causing
   Stack Overflows.
 
 * if you ask for the "classic" compiler on Java1.4, you get upgraded to
   "modern" because there is no classic compiler any more.
 
 * the <http> condition was viewing 404 'not found' exceptions as success. Now
   it defaults to viewing any response >=400 as an error, and has an
   errorsBeginAt attribute you can use if you want a higher or lower value.
 
 * <get> throws a build exception on an http authorization error, unless you
   have set ignoreerrors to true.
 
 * <wsdltodotnet> was spelt in Wintel case: <WsdlToDotnet>. It is now lower
   case, though the old spelling is retained for anyone who used it.
 
 * Merging of Manifests in jar now works as documented.
 
 * paths that have been separated by colons would be incorrectly parsed
   on NetWare.
 
 * runant.pl now supports NetWare.
 
 * <tempfile> and <setproxy> tasks were in beta1, but not defined by
   default; They now are. <tempfile> fills a property with the name of a
   temporary file; <setproxy> lets you set the JVM's http, ftp and socks proxy
   settings.
 
 * <available classname="foo" ignoresystemclasses="true"> failed for
   JDK 1.1 and 1.2, even if the class could be found on the
   user-specified classpath.
 
 * <property environment=... /> now works on z/OS.
 
 * forked <javac> failed for the wrong reason on JDK 1.1 - Ant would
   use a temporary file to hold the names of the files to compile under
   some conditons, but 1.1 doesn't support this feature.  Ant will no
   longer try this, but you may run into problems with the length of the
   command line now.
 
 * the refid attribute for <property>s nested into <ant> or <param>s
   nested into <antcall> didn't work.
 
 * <replaceregexp> didn't work for nested <fileset>s.
 
 * <javadoc> dropped sourcepath entries if no "interesting" .java
   source files  could be found below them.  This has been backwards
   incompatible and caused problems with custom doclets like xdoclet.
 
 * Using the doclet, docletpath or docletpathref attributes of
   <javadoc> may have caused NullPointerExceptions.
 
 * nested <filesets> of <javadoc> would include too much.
 
 * <dependset> will no longer choke on <targetfileset>s that point to
   non-existing directories.
 
 * <patch> didn't work at all.
 
 * <replace> and <replaceregexp> now fail if the file they are working
   on is locked.
 
 * <javadoc> would pick up the wrong executable in the combination JDK
   1.2 and AIX.
 
 Other changes:
 --------------
 
 * z/OS now gets detected by the os condition.
 
 * <fileset> and <dirset> now have an optional followsymlink attribute
   that can prevent Ant from following symbolic links on some platforms.
 
 * BeanShell is now supported in the <script> task.
 
 * <ejbjar> under Weblogic attempts to use the ejbc20 compiler for 2.0 beans
   based on the deployment descriptor's DTD reference. Under weblogic 7.00 Beta
   this ejbc class has been deprecated. To avoid the deprecation warning use
   ejbcclass="weblogic.ejbc".
 
 * <ejbjar> will add a manifest to the generated jar based on the naming
   convention in use. This overrides the manifest specified in the
   <ejbjar> attribute
 
 
 Changes from Ant 1.4.1 to 1.5beta1
 ==================================
 
 Changes that could break older environments:
 --------------------------------------------
 
 * Important: Single $ signs are no longer silently stripped!
   Before you panic that we have broken all your build files, we have kept
   the old "$$" -> "$" behaviour. So only build files which accidentally had
   a $ sign in a string that was being silently stripped may break.
   We added this fix to stop newbie confusion; if you want to write a
   build file which works on ant versions 1.4.1 or earlier, stay with
   the double $$ sign rule.
 
 * Project.getBuildListeners now returns a clone of the listener
   list. Changes to the returned list will not affect the listeners
   currently attached to the Project. It also means that it is safe to
   iterate over the returned list if listeners are added or removed
   during the traversal.
 
 * <pvcs> default filenameformat has been different from Ant 1.4.1.
 
 * Some messages that are printed during startup will not be
   written to the logfile specified via -logfile as they might destroy
   the format of the file for special BuildLoggers (like XmlLogger).
 
 * The filesetmanifest attribute added to <jar> after the 1.4.1
   release has been removed for now.  This change may affect only
   the 1.5Beta/1.6Alpha users.  An attempt will be made to add this
   feature back into Ant 1.6.
 * Shipped XML parser is now Xerces 2.0.1 along with the XML Parser APIs.
   XML Parser APIs is a separate jar that contains the necessary
   JAXP/DOM/SAX classes.
 
 * <telnet> was fixed to expand properties inside nested <read> and
   <write> elements; before this only happened when you assigned the text
   to the string attribute. If you had $ signs in the string, they may
   need escaping.
 
 * the RegexpMatcher interface has been extended to support case
   insensitive matches and other options - custom implementations of
   this interface won't work any longer.  We recommend to use the new
   Regexp interface that also supports substitution instead of the
   RegexpMatcher interface in the future.
 
 * <gzip> will throw an exception if your src attribute points to a directory.
 
 * Unjar, Unzip and Unwar will throw an exception if the Src attribute
   represents a directory.  Support for nested filesets is provided
   instead.
 
 * It is no longer possible to overwrite a property using tasks like
   <condition>, <exec>, <pathconvert>, or <tstamp>. In some exceptional
   cases it will generate a warning if you attempt to overwrite an
   existing property.
 
 * Taskwriters please note: Whenever tasks had any overloaded set* methods,
   Ant's introspection mechanism would select the last overloaded method
   provided to it by the Java Runtime.  A modification has now been made such
   that when the Java Runtime provides a method with a String as its argument,
   a check is made to see if there is another overloaded method that takes in
   some other type of argument.  If there is one such method, then the method
   that takes in String as an argument is not selected by the Introspector.
 
 * The pattern definition **/._* has been included into the Default
   Excludes list.
 
 * <propertyfile>'s <entry> element was modified to remove "never" as a value
   as its behavior was undocumented and flakey.
 
 * The -projecthelp flag now only prints out targets that include the
   'description' attribute, unless the -verbose or -debug flag is included
   on the Ant command line.
 
 * Ant's testcases now require JUnit 3.7 or above, as they now use the new
   assertTrue method instead of assert.
 
 * If the 'output' attribute of <ant> is set to a simple filename or a
   relative path, the file is created relative to ${basedir}, not ${user.dir}.
 
 * The default value for build.compiler is now javac1.x with x
   depending on the JDK that is running Ant instead of classic/modern.
 
 Fixed bugs:
 -----------
 
 * <available> could fail to find files or directories that happen to
   start with the name of the project's basedir but are not children of
   the basedir.
 
 * Nested <property>'s inside <ant> can now be overriden by subsequent
   <ant> and <antcall> tasks.
 
 * <xslt>'s outputtype attribute wouldn't do anything.
 
 * <linecontains> filterreader could swallow lines.
 
 * <sequential> used to configure the tasks (set their attributes)
   before the first task has been executed.  This means that properties
   that have been set by nested task seemed to be unset for the other
   tasks in the same <sequential> element.
 
 * <javac>'s sourcepath setting has been ignored by some compiler
   implementations.
 
 * <javadoc>'s packagelist attribute didn't work.
 
 * the plain mailer would always use port 25 in <mail>.
 
 * Ant's default logger could swallow empty lines.
 
 * ejbjar's iPlanet nested element now can process multiple descriptors.
 
 * IPlanetEjbc was looking in the wrong place for four iiop files.
 
 * <javac> would pass the -source switch to JDK 1.3's javac, even
   though it doesn't support it.
 
 * <zip> and friends would always update existing archive if you set
   the update attribute to true.
 
 * To support backward compatibility with older versions, <pathconvert>
   will once again set the property, even if the result is the empty
   string, unless the new 'setonempty' attribute is set to false|no|off
   (default is "true").
 
 * The manifest task would crash XmlLogger
 
 * A bug existed that prevented generated log files from being deleted as
   part of the build process itself.  This has now been fixed.
 
 * Fixed bug where <move> ignored <filterset>s.
 
 * Ant works properly with the combination of Java1.4/WindowsXP.
 
 * Fixed bug where <java> used to sometimes invoke class constructors twice.
 
 * Fixed bug with 4NT shell support.
 
 * Fixed bug where ant would not perform ftp without remotedir being
   specified even though this was not mandatory.
 
 * Fixed bug where ant would not copy system properties into new Project
   in ant/antcall tasks when inheritall="false" is set.
 
 * <propertyfile> would not close the original property file.
 
 * <ant> will no longer override a subbuild's basedir with inheritall="true".
 
 * Fixed problem with the built-in <junit> formatters which assumed
   that only one test could be running at the same time - this is not
   necessarily true, see junit.extensions.ActiveTestSuite.
 
 * <jar>'s whenEmpty attribute is useless as JARs are never empty, they
   contain at least a manifest file, therefore it will now print a
   warning and do nothing.
 
 * <typedef> hasn't been all that useful as it couldn't be used outside
   of targets (it can now) and nested "unknown" elements have always
   been considered to be tasks (changed as well).
 
 * <fixcrlf> would fail for files that contained lines longer than 8kB.
 
 * Some junit formatters incorrectly assumed that all testcases would
   inherit from junit.framework.TestCase.
 
 * <fixcrlf> dropped the first characters from Mac files.
 
 Other changes:
 --------------
 
 * <checksum> now uses a buffer (of configurable size).
 
 * The "Trying to override task definition" warning has been degraded
   to verbose level if the two task definitions only differ in the class
   loader instance that has loaded the definition.
 
 * Add a jvmargs to the ejbjar's weblogic element to allow additional
   arguments to be provided to the VM runnign ejbc. Document the
   jvmdebuglevel attribute which can be used to avoid warnings about
   interface classess being found on the classpath. Document the new
   <sysproperty> element which allows JVM properties to be defined.
   Added an outputdir attribute to allow the destination to be a
   directory into which the exploded jar is written.
 
 * ejbjar now supports Borland Enterprise Server 5 and Jonas 2.5
 
 * added **/.svn and **/.svn/** to the default excludes.
 
 * Selector Elements now provide a way to create filesets based on
   sophisticated selection criteria.
 
 * Gzip and Bzip2 files can now be constructed in the fly when using
   the tar task without having to create the intermediate tar file on
   disk.  The Untar task can also untar GZip and BZip2 files on the fly
   without creating the intermediate tar file.
 
 * New optional type, <classfileset> added.
 
 * <ejbjar> now allows control over which additional classes and interfaces
   are added to the generated EJB jars. A new attribute "dependency" can be
   defined which controls what classes are added. The addition of classes now
   uses the Jakarta-BCEL library rather than reflection, meaning bean classes are
   no longer loaded into Ant's JVM. The default dependency analyzer is known as
   the ancestor analyzer. It provides the same behaviour as the 1.4.1 version of
   <ejbjar>. If the BCEL library is not present, a warning will be issued stating
   the ancestor analyzer is not available. In this case <ejbjar> will continue
   to function but will not add super classes to the jar.
 
 * <available> has a new attribute named ignoreSystemClasses.
 
 * New task <cvschangelog/> generates an XML report of changes that occur
   on CVS repository.
 
 * New filter readers: ClassConstants, ExpandProperties, HeadFilter,
   LineContains, LineContainsRegExp, PrefixLines, ReplaceTokens,
   StripJavaComments, StripLineBreaks, StripLineComments, TabsToSpaces,
   TailFilter.
 
 * <copy>, <loadfile>, <loadproperties>, <move> support FilterChains
   of FilterReaders.
 
 * New task <loadproperties> to load contents of file as Ant properties,
   with nested <filterchain> elements.
 
 * New task <loadfile> to load a whole file into a property.
 
 * New task <echoproperties> to list your current properties to the screen
   or a file.
 
 * New tasks <bzip2> and <bunzip2> to pack and unpack files using the
   BZip2 algorithm.
 
 * New tasks <replaceregexp>, <checksum>, <translate>, <waitfor>,
   <manifest>, <vsscp>, <vssadd>, <vsscreate>, <splash>, <basename>, <dirname>,
   <concat>, <sourceoffsite>, <jarlib-available>, <jarlib-display>,
   <jarlib-manifest>, <jarlib-resolve>.
 
 * A new combined <mail> task, which replaces the old <mail> and
   <mimemail> tasks, has been added.  The <mimemail> task, and
   old SendEmail and MimeMail classes have been deprecated.
 
 * Mail task allows specification of port number.
 
 * Users can control what <zip> and <jar> must do when duplicate files
   are found.  A new element <zipgroupfileset> allows for multiple zip
   files to be merged into the archive.  In addition, <jar> also has
   another new attribute: filesetmanifest.  The existing manifest
   attribute of <jar> now also accepts the name of a jar added through
   a fileset.
 
 * gzip now checks that the zipfile is older than the source file
   before rebuilding the zipfile.
 
 * TarFileset takes in three new attributes - fullpath, prefix
   and preserveLeadingSlashes.
 
 * <move> attempts to rename the directory, if everything inside it is
   included, before performing file-by-file moves.  This attempt will
   be done only if filtering is off and if mappers are not used.  This
   is a performance improvement and there is no change otherwise in
   the functionality of this task.
 
 * Exec task has extra attribute "resultproperty" to get the return code
   into a property.
 
 * Exec task prints a message when a timed-out process is killed.
 
 * Added optional attributes - name, arch and version to the <os> task.
 
 * Unjar, Untar, Unwar and Unzip now support patternsets to
   select files from an archive for extraction.  Filesets may be
   used to select archived files for unarchival.
 
 * Javac task allows debug levels to be specified.  Debug levels
   will have an effect only when the modern compiler or the
   classic compiler (version 1.2 and higher) is used and debugging
   is enabled.
 
 * Added support for specifying CVS_RSH in the <cvs/> task
 
diff --git a/manual/Tasks/ear.html b/manual/Tasks/ear.html
index 5ee8206c9..de4a96260 100644
--- a/manual/Tasks/ear.html
+++ b/manual/Tasks/ear.html
@@ -1,301 +1,301 @@
 <!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 -->
 <html>
 
 <head>
 <meta http-equiv="Content-Language" content="en-us">
 <link rel="stylesheet" type="text/css" href="../stylesheets/style.css">
 <title>EAR Task</title>
 </head>
 
 <body>
 
 <h2><a name="ear">Ear</a></h2>
 <h3>Description</h3>
 <p>An extension of the <a href="jar.html">Jar</a> task with special
 treatment for files that should end up in an Enterprise Application archive.</p>
 <p>(The Ear task is a shortcut for specifying the particular layout of a EAR file. 
 The same thing can be accomplished by using the <i>prefix</i> and <i>fullpath</i>
 attributes of zipfilesets in a Zip or Jar task.)</p>
 <p>The extended zipfileset element from the zip task (with attributes <i>prefix</i>, <i>fullpath</i>, and <i>src</i>) is available in the Ear task.</p>
 
 <p><b>Please note that the zip format allows multiple files of the same
 fully-qualified name to exist within a single archive.  This has been
 documented as causing various problems for unsuspecting users.  If you wish
 to avoid this behavior you must set the <code>duplicate</code> attribute
 to a value other than its default, <code>&quot;add&quot;</code>.</b></p>
 
 <h3>Parameters</h3>
 <table border="1" cellpadding="2" cellspacing="0">
   <tr>
     <td valign="top"><b>Attribute</b></td>
     <td valign="top"><b>Description</b></td>
     <td align="center" valign="top"><b>Required</b></td>
   </tr>
   <tr>
     <td valign="top">destfile</td>
     <td valign="top">the EAR file to create.</td>
     <td valign="top" align="center">Yes</td>
   </tr>
   <tr>
     <td valign="top">appxml</td>
     <td valign="top">The deployment descriptor to use (META-INF/application.xml).</td>
     <td valign="top" align="center">Yes, unless update is set to true</td>
   </tr>
   <tr>
     <td valign="top">basedir</td>
     <td valign="top">the directory from which to jar the files.</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">compress</td>
     <td valign="top">Not only store data but also compress them,
     defaults to true.  Unless you set the <em>keepcompression</em>
     attribute to false, this will apply to the entire archive, not
     only the files you've added while updating.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">keepcompression</td>
     <td valign="top">For entries coming from existing archives (like
     nested <em>zipfileset</em>s or while updating the archive), keep
     the compression as it has been originally instead of using the
     <em>compress</em> attribute.  Defaults false.  <em>Since Apache Ant
     1.6</em></td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">encoding</td>
     <td valign="top">The character encoding to use for filenames
       inside the archive.  Defaults to UTF8. <strong>It is not
       recommended to change this value as the created archive will most
       likely be unreadable for Java otherwise.</strong>
       <br/>See also the <a href="zip.html#encoding">discussion in the
       zip task page</a></td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">filesonly</td>
     <td valign="top">Store only file entries, defaults to false</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">includes</td>
     <td valign="top">comma- or space-separated list of patterns of files that must be
       included. All files are included when omitted.</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">includesfile</td>
     <td valign="top">the name of a file. Each line of this file is
       taken to be an include pattern</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">excludes</td>
     <td valign="top">comma- or space-separated list of patterns of files that must be
       excluded. No files (except default excludes) are excluded when omitted.</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">excludesfile</td>
     <td valign="top">the name of a file. Each line of this file is
       taken to be an exclude pattern</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">defaultexcludes</td>
     <td valign="top">indicates whether default excludes should be used or not
       (&quot;yes&quot;/&quot;no&quot;). Default excludes are used when omitted.</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">manifest</td>
     <td valign="top">the manifest file to use.</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">filesetmanifest</td>
     <td valign="top">behavior when a Manifest is found in a zipfileset or zipgroupfileset file is found.  Valid values are &quot;skip&quot;, &quot;merge&quot;, and &quot;mergewithoutmain&quot;.  &quot;merge&quot; will merge all of the manifests together, and merge this into any other specified manifests.  &quot;mergewithoutmain&quot; merges everything but the Main section of the manifests.  Default value is &quot;skip&quot;.
     </td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">whenmanifestonly</td>
     <td valign="top">behavior when no files match.  Valid values are &quot;fail&quot;, &quot;skip&quot;, and &quot;create&quot;.  Default is &quot;create&quot;.</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">manifestencoding</td>
     <td valign="top">The encoding used to read the JAR manifest, when a manifest file is specified.</td>
     <td valign="top" align="center">No, defaults to the platform encoding.</td>
   </tr>
   <tr>
     <td valign="top">index</td>
     <td valign="top">whether to create an <A
     HREF="http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#JAR_Index">index
     list</A> to speed up classloading.  This is a JDK 1.3+ specific
     feature.  Unless you specify additional jars with nested <a
     href="jar.html#indexjars"><code>indexjars</code></a> elements, only the
     contents of this jar will be included in the index.  Defaults to
     false.</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">indexMetaInf</td>
     <td valign="top">whether to include META-INF and its children in
       the index.  Doesn't have any effect if <em>index</em> is
       false.<br/>
       Oracle's jar implementation used to skip the META-INF directory and
       Ant followed that example.  The behavior has been changed with
       <a href="https://bugs.openjdk.java.net/browse/JDK-4408526">Java
       5</a>.  In order to avoid problems with Ant generated jars on
       Java 1.4 or earlier Ant will not include META-INF unless
       explicitly asked to.<br/>
       <em>Ant 1.8.0</em> - Defaults to false.</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">update</td>
     <td valign="top">indicates whether to update or overwrite
       the destination file if it already exists.  Default is &quot;false&quot;.</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">duplicate</td>
     <td valign="top">behavior when a duplicate file is found.  Valid values are &quot;add&quot;, &quot;preserve&quot;, and &quot;fail&quot;.  The default value is &quot;add&quot;.  </td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">roundup</td>
     <td valign="top">Whether the file modification times will be
     rounded up to the next even number of seconds.<br>
     Zip archives store file modification times with a granularity of
     two seconds, so the times will either be rounded up or down.  If
     you round down, the archive will always seem out-of-date when you
     rerun the task, so the default is to round up.  Rounding up may
     lead to a different type of problems like JSPs inside a web
     archive that seem to be slightly more recent than precompiled
     pages, rendering precompilation useless.<br>
     Defaults to true.  <em>Since Ant 1.6.2</em></td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">level</td>
     <td valign="top">Non-default level at which file compression should be
     performed. Valid values range from 0 (no compression/fastest) to 9
     (maximum compression/slowest). <em>Since Ant 1.7</em></td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">preserve0permissions</td>
     <td valign="top">when updating an archive or adding entries from a
     different archive Ant will assume that a Unix permissions value of
     0 (nobody is allowed to do anything to the file/directory) means
     that the permissions haven't been stored at all rather than real
     permissions and will instead apply its own default values.<br/>
     Set this attribute to true if you really want to preserve the
       original permission field.<em>since Ant 1.8.0</em>
     </td>
     <td valign="top" align="center">No, default is false</td>
   </tr>
   <tr>
     <td valign="top">useLanguageEncodingFlag</td>
     <td valign="top">Whether to set the language encoding flag if the
       encoding is UTF-8.  This setting doesn't have any effect if the
       encoding is not UTF-8.
       <em>Since Ant 1.8.0</em>.
       <br/>See also the <a href="zip.html#encoding">discussion in the
       zip task page</a></td>
     <td valign="top" align="center">No, default is true</td>
   </tr>
   <tr>
     <td valign="top">createUnicodeExtraFields</td>
     <td valign="top">Whether to create unicode extra fields to store
       the file names a second time inside the entry's metadata.
       <br>Possible values are "never", "always" and "not-encodeable"
       which will only add Unicode extra fields if the file name cannot
       be encoded using the specified encoding.
       <em>Since Ant 1.8.0</em>.
       <br/>See also the <a href="zip.html#encoding">discussion in the
       zip task page</a></td>
     <td align="center" valign="top">No, default is "never"</td>
   </tr>
   <tr>
     <td valign="top">fallbacktoUTF8</td>
     <td valign="top">Whether to use UTF-8 and the language encoding
       flag instead of the specified encoding if a file name cannot be
       encoded using the specified encoding.
       <em>Since Ant 1.8.0</em>.
       <br/>See also the <a href="zip.html#encoding">discussion in the
       zip task page</a></td>
     <td align="center" valign="top">No, default is false</td>
   </tr>
   <tr>
     <td valign="top">mergeClassPathAttributes</td>
     <td valign="top">Whether to merge the Class-Path attributes found
       in different manifests (if merging manifests).  If false, only
       the attribute of the last merged manifest will be preserved.
       <em>Since Ant 1.8.0</em>.
       <br/>unless you also set flattenAttributes to true this may
       result in manifests containing multiple Class-Path attributes
       which violates the manifest specification.</td>
     <td align="center" valign="top">No, default is false</td>
   </tr>
   <tr>
     <td valign="top">flattenAttributes</td>
-    <td valign="top">Whether to merge attributes occuring more than
+    <td valign="top">Whether to merge attributes occurring more than
       once in a section (this can only happen for the Class-Path
       attribute) into a single attribute.
       <em>Since Ant 1.8.0</em>.</td>
     <td align="center" valign="top">No, default is false</td>
   </tr>
   <tr>
     <td valign="top">zip64Mode</td>
     <td valign="top">When to use Zip64 extensions for entries.  The
       possible values are "never", "always" and "as-needed".
       <em>Since Ant 1.9.1</em>.
       <br/>See also the <a href="zip.html#zip64">discussion in the
       zip task page</a></td>
     <td align="center" valign="top">No, default is "never"</td>
   </tr>
 </table>
 
 <h3>Nested elements</h3>
 
 <h4>metainf</h4>
 <p>The nested <code>metainf</code> element specifies a <a
 href="../Types/fileset.html">FileSet</a>. All files included in this fileset will
 end up in the <code>META-INF</code> directory of the ear file. If this
 fileset includes a file named <code>MANIFEST.MF</code>, the file is
 ignored and you will get a warning.</p>
 
 <h4>manifest, indexjars, service</h4>
 These are inherited from <a href="jar.html">&lt;jar&gt;</a>
 
 <h2>Example</h2>
 <pre>
     &lt;ear destfile=&quot;${build.dir}/myapp.ear&quot; appxml=&quot;${src.dir}/metadata/application.xml&quot;&gt;
       &lt;fileset dir=&quot;${build.dir}&quot; includes=&quot;*.jar,*.war&quot;/&gt;
     &lt;/ear&gt;
 </pre>
 
 
 </body>
 </html>
 
 
diff --git a/manual/Tasks/javac.html b/manual/Tasks/javac.html
index 2315aca48..6c1d4e651 100644
--- a/manual/Tasks/javac.html
+++ b/manual/Tasks/javac.html
@@ -1,859 +1,859 @@
 <!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 -->
 <html lang="en-us">
 
 <head>
 <meta http-equiv="Content-Language" content="en-us">
 <link rel="stylesheet" type="text/css" href="../stylesheets/style.css">
 <title>Javac Task</title>
 </head>
 
 <body>
 
 <h2><a name="javac">Javac</a></h2>
 <h3>Description</h3>
 <p>Compiles a Java source tree.</p>
 <p>The source and destination directory will be recursively scanned for Java
 source files to compile. Only Java files that have no corresponding
 <code>.class</code> file
 or where the class file is older than the
 <code>.java</code> file will be compiled.</p>
 <p>Note: Apache Ant uses only the names of the source and class files to find
 the classes that need a rebuild. It will not scan the source and therefore
 will have no knowledge about nested classes, classes that are named different
 from the source file, and so on. See the
 <a href="../Tasks/depend.html"><code>&lt;depend&gt;</code></a> task
 for dependency checking based on other than just
 existence/modification times.</p>
 <p>When the source files are part of a package, the directory structure of
 the source tree should follow the package
 hierarchy.</p>
 <p>It is possible to refine the set of files that are being compiled.
 This can be done with the <code>includes</code>, <code>includesfile</code>,
 <code>excludes</code>, and <code>excludesfile</code>
 attributes. With the <code>includes</code> or
 <code>includesfile</code> attribute, you specify the files you want to
 have included.
 The <code>exclude</code> or <code>excludesfile</code> attribute is used
 to specify
 the files you want to have excluded. In both cases, the list of files
 can be specified by either the filename, relative to the directory(s) specified
 in the <code>srcdir</code> attribute or nested <code>&lt;src&gt;</code>
 element(s), or by using wildcard patterns. See the section on
 <a href="../dirtasks.html#directorybasedtasks">directory-based tasks</a>,
 for information on how the
 inclusion/exclusion of files works, and how to write wildcard patterns.</p>
 <p>It is possible to use different compilers. This can be specified by
 either setting the global <code>build.compiler</code> property, which will
 affect all <code>&lt;javac&gt;</code> tasks throughout the build, by
 setting the <code>compiler</code> attribute, specific to the current
 <code>&lt;javac&gt;</code> task or by using a nested element of any
 <a href="typedef.html">typedef</a>fed or
 <a href="componentdef.html">componentdef</a>fed type that implements
 <code>org.apache.tools.ant.taskdefs.compilers.CompilerAdapter</code>.
 <a name="compilervalues">Valid values for either the
 <code>build.compiler</code> property or the <code>compiler</code>
 attribute are:</a></p>
 <ul>
   <li><code>classic</code> (the standard compiler of JDK 1.1/1.2) &ndash;
       <code>javac1.1</code> and
       <code>javac1.2</code> can be used as aliases.</li>
   <li><code>modern</code> (the standard compiler of JDK 1.3/1.4/1.5/1.6/1.7/1.8) &ndash;
       <code>javac1.3</code> and
       <code>javac1.4</code> and
       <code>javac1.5</code> and
       <code>javac1.6</code> and
       <code>javac1.7</code> (<em>since Ant 1.8.2</em>) and
       <code>javac1.8</code> (<em>since Ant 1.8.3</em>) can be used as aliases.</li>
   <li><code>jikes</code> (the <a
     href="http://jikes.sourceforge.net/" target="_top">Jikes</a>
     compiler).</li>
   <li><code>jvc</code> (the Command-Line Compiler from Microsoft's SDK
       for Java / Visual J++) &ndash; <code>microsoft</code> can be used
       as an alias.</li>
   <li><code>kjc</code> (the <a href="http://www.dms.at/kopi/" target="_top">kopi</a>
     compiler).</li>
   <li><code>gcj</code> (the gcj compiler from gcc).</li>
   <li><code>sj</code> (Symantec java compiler) &ndash;
       <code>symantec</code> can be used as an alias.</li>
   <li><code>extJavac</code> (run either modern or classic in a JVM of
       its own).</li>
 </ul>
 <p>The default is <code>javac1.x</code> with <code>x</code> depending
 on the JDK version you use while you are running Ant.
 If you wish to use a different compiler interface than those
 supplied, you can write a class that implements the CompilerAdapter interface
 (<code>package org.apache.tools.ant.taskdefs.compilers</code>). Supply the full
 classname in the <code>build.compiler</code> property or the
 <code>compiler</code> attribute.
 </p>
 <p>The fork attribute overrides the <code>build.compiler</code> property
 or <code>compiler</code> attribute setting and
 expects a JDK1.1 or higher to be set in <code>JAVA_HOME</code>.
 </p>
 <p>You can also use the <code>compiler</code> attribute to tell Ant
 which JDK version it shall assume when it puts together the command
 line switches - even if you set <code>fork=&quot;true&quot;</code>.
 This is useful if you want to run the compiler of JDK 1.1 while you
 current JDK is 1.2+.  If you use
 <code>compiler=&quot;javac1.1&quot;</code> and (for example)
 <code>depend=&quot;true&quot;</code> Ant will use the command line
 switch <code>-depend</code> instead of <code>-Xdepend</code>.</p>
 <p>This task will drop all entries that point to non-existent
 files/directories from the classpath it passes to the compiler.</p>
 <p>The working directory for a forked executable (if any) is the
   project's base directory.</p>
 <p><strong>Windows Note:</strong>When the modern compiler is used
 in unforked mode on Windows, it locks up the files present in the
 classpath of the <code>&lt;javac&gt;</code> task, and does not release them.
 The side effect of this is that you will not be able to delete or move
 those files later on in the build.  The workaround is to fork when
 invoking the compiler.</p>
 <h3>Parameters</h3>
 <table border="1" cellpadding="2" cellspacing="0">
   <tr>
     <td valign="top"><b>Attribute</b></td>
     <td valign="top"><b>Description</b></td>
     <td align="center" valign="top"><b>Required</b></td>
   </tr>
   <tr>
     <td valign="top">srcdir</td>
     <td valign="top">Location of the java files. (See the
      <a href="#srcdirnote">note</a> below.)</td>
     <td align="center" valign="top">Yes, unless nested <code>&lt;src&gt;</code> elements are present.</td>
   </tr>
   <tr>
     <td valign="top">destdir</td>
     <td valign="top">Location to store the class files.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">includes</td>
     <td valign="top">Comma- or space-separated list of files (may be specified using
       wildcard patterns) that must be
       included; all <code>.java</code> files are included when omitted.</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">includesfile</td>
     <td valign="top">The name of a file that contains a list of files to
       include (may be specified using wildcard patterns).</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">excludes</td>
     <td valign="top">Comma- or space-separated list of files (may be specified using
       wildcard patterns) that must be excluded; no files (except default
       excludes) are excluded when omitted.</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">excludesfile</td>
     <td valign="top">The name of a file that contains a list of files to
       exclude (may be specified using wildcard patterns).</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">classpath</td>
     <td valign="top">The classpath to use.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">sourcepath</td>
     <td valign="top">The sourcepath to use; defaults to the value of the srcdir attribute (or nested <code>&lt;src&gt;</code> elements).
         To suppress the sourcepath switch, use <code>sourcepath=&quot;&quot;</code>.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">bootclasspath</td>
     <td valign="top">
       Location of bootstrap class files. (See <a href="#bootstrap">below</a>
       for using the -X and -J-X parameters for specifying
       the bootstrap classpath).
     </td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">classpathref</td>
     <td valign="top">The classpath to use, given as a
       <a href="../using.html#references">reference</a> to a path defined elsewhere.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">sourcepathref</td>
     <td valign="top">The sourcepath to use, given as a
       <a href="../using.html#references">reference</a> to a path defined elsewhere.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">bootclasspathref</td>
     <td valign="top">Location of bootstrap class files, given as a
       <a href="../using.html#references">reference</a> to a path defined elsewhere.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">extdirs</td>
     <td valign="top">Location of installed extensions.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">encoding</td>
     <td valign="top">Encoding of source files. (Note: gcj doesn't support
       this option yet.)</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">nowarn</td>
     <td valign="top">Indicates whether the <code>-nowarn</code> switch
       should be passed to the compiler; defaults to <code>off</code>.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">debug</td>
     <td valign="top">Indicates whether source should be compiled with
     debug information; defaults to <code>off</code>.  If set to
     <code>off</code>, <code>-g:none</code> will be passed on the
     command line for compilers that support it (for other compilers, no
     command line argument will be used).  If set to <code>true</code>,
     the value of the <code>debuglevel</code> attribute determines the
     command line argument.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">debuglevel</td>
     <td valign="top">Keyword list to be appended to the <code>-g</code>
       command-line switch.  This will be ignored by all implementations except
       <code>modern</code>, <code>classic(ver &gt;= 1.2)</code> and <code>jikes</code>.
       Legal values are <code>none</code> or a comma-separated list of the
       following keywords:
       <code>lines</code>, <code>vars</code>, and <code>source</code>.
       If <code>debuglevel</code> is not specified, by default,
       nothing will be
       appended to <code>-g</code>.  If <code>debug</code> is not turned on,
       this attribute will be ignored.
     </td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">optimize</td>
     <td valign="top">
       Indicates whether source should be compiled with
       optimization; defaults to <code>off</code>. <strong>Note</strong>
       that this flag is just ignored by Sun's <code>javac</code> starting
       with JDK 1.3 (since compile-time optimization is unnecessary).
     </td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">deprecation</td>
     <td valign="top">Indicates whether source should be compiled with
       deprecation information; defaults to <code>off</code>.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">target</td>
     <td valign="top">Generate class files for specific VM version
     (e.g., <code>1.1</code> or <code>1.2</code>). <b>Note that the
     default value depends on the JVM that is running Ant.  In
     particular, if you use JDK 1.4+ the generated classes will not be
     usable for a 1.1 Java VM unless you explicitly set this attribute
     to the value 1.1 (which is the default value for JDK 1.1 to
     1.3).  We highly recommend to always specify this
     attribute.</b><br>
     A default value for this attribute can be provided using the magic
     <a
     href="../javacprops.html#target"><code>ant.build.javac.target</code></a>
     property.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">verbose</td>
     <td valign="top">Asks the compiler for verbose output; defaults to
       <code>no</code>.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">depend</td> <td valign="top">Enables dependency-tracking
       for compilers that support this (<code>jikes</code> and
       <code>classic</code>).</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">includeAntRuntime</td>
     <td valign="top">Whether to include the Ant run-time libraries in the
       classpath; defaults to <code>yes</code>, unless
       <a href="../sysclasspath.html"><code>build.sysclasspath</code></a> is set.
       <em>It is usually best to set this to false</em> so the script's behavior is not
       sensitive to the environment in which it is run.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">includeJavaRuntime</td>
     <td valign="top">Whether to include the default run-time
       libraries from the executing VM in the classpath;
       defaults to <code>no</code>.<br/>
       <b>Note:</b> In some setups the run-time libraries may be part
       of the "Ant run-time libraries" so you may need to explicitly
       set includeAntRuntime to false to ensure that the Java
       run-time libraries are not included.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">fork</td>
     <td valign="top">Whether to execute <code>javac</code> using the
       JDK compiler externally; defaults to <code>no</code>.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">executable</td>
     <td valign="top">Complete path to the <code>javac</code>
       executable to use in case of <code>fork=&quot;yes&quot;</code>.
       Defaults to the compiler of the Java version that is currently
       running Ant.  Ignored if <code>fork=&quot;no&quot;</code>.<br>
       Since Ant 1.6 this attribute can also be used to specify the
       path to the executable when using jikes, jvc, gcj or sj.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">memoryInitialSize</td>
     <td valign="top">The initial size of the memory for the underlying VM,
       if <code>javac</code> is run externally; ignored otherwise. Defaults
       to the standard VM memory setting.
       (Examples: <code>83886080</code>, <code>81920k</code>, or
       <code>80m</code>)</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">memoryMaximumSize</td>
     <td valign="top">The maximum size of the memory for the underlying VM,
       if <code>javac</code> is run externally; ignored otherwise. Defaults
       to the standard VM memory setting.
       (Examples: <code>83886080</code>, <code>81920k</code>, or
       <code>80m</code>)</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">failonerror</td>
     <td valign="top">Indicates whether compilation errors
         will fail the build; defaults to <code>true</code>.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">errorProperty</td>
     <td valign="top">
       The property to set (to the value "true") if compilation fails.
       <em>Since Ant 1.7.1</em>.
     </td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">source</td>
 
     <td valign="top">Value of the <code>-source</code> command-line
     switch; will be ignored by all implementations prior to
     <code>javac1.4</code> (or <code>modern</code> when Ant is not
     running in a 1.3 VM), <code>gcj</code> and <code>jikes</code>.<br>
     If you use this attribute together with <code>gcj</code>
     or <code>jikes</code>, you must make sure that your version
     supports the <code>-source</code> (or <code>-fsource</code> for
     gcj)
     switch.  By default, no <code>-source</code> argument will be used
     at all.<br>
     <b>Note that the default value depends on the JVM that is running
     Ant.  We highly recommend to always specify this
     attribute.</b><br>
     A default value for this attribute can be provided using the magic
     <a
     href="../javacprops.html#source"><code>ant.build.javac.source</code></a>
     property.</td>
 
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">compiler</td>
     <td valign="top">The compiler implementation to use.
       If this attribute is not set, the value of the
       <code>build.compiler</code> property, if set, will be used.
       Otherwise, the default compiler for the current VM will be used.
       (See the above <a href="#compilervalues">list</a> of valid
       compilers.)</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">listfiles</td>
     <td valign="top">Indicates whether the source files to be compiled will
       be listed; defaults to <code>no</code>.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">tempdir</td>
     <td valign="top">Where Ant should place temporary files.
       This is only used if the task is forked and the
       command line args length exceeds 4k.
       <em>Since Ant 1.6</em>.</td>
     <td align="center" valign="top">
       No; default is <i>java.io.tmpdir</i>.
     </td>
   </tr>
   <tr>
     <td valign="top">updatedProperty</td>
     <td valign="top">
       The property to set (to the value "true") 
       if compilation has taken place
       and has been successful.
       <em>Since Ant 1.7.1</em>.
     </td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">includeDestClasses</td>
     <td valign="top">
       This attribute controls whether to include the
       destination classes directory in the classpath
       given to the compiler.
       The default value of this is "true" and this
       means that previously compiled classes are on
       the classpath for the compiler. This means that "greedy" compilers
-      will not recompile dependant classes that are already compiled.
+      will not recompile dependent classes that are already compiled.
       In general this is a good thing as it stops the compiler
       for doing unnecessary work. However, for some edge cases,
       involving generics, the javac compiler
-      needs to compile the dependant classes to get the generics
+      needs to compile the dependent classes to get the generics
       information. One example is documented in the bug report:
       <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=40776">
         Bug 40776 - a problem compiling a Java 5 project with generics</a>.
       Setting the attribute to "false" will cause the compiler
       to recompile dependent classes.
       <em>Since Ant 1.7.1</em>.
     </td>
     <td align="center" valign="top">No - default is "true"</td>
   </tr>
   <tr>
     <td valign="top">createMissingPackageInfoClass</td>
     <td valign="top">
       Some package level annotations in <code>package-info.java</code>
       files don't create any <code>package-info.class</code> files so
       Ant would recompile the same file every time.<br/>
       Starting with Ant 1.8 Ant will create an
       empty <code>package-info.class</code> for
       each <code>package-info.java</code> if there isn't one created
       by the compiler.<br/>
       In some setups this additional class causes problems and it can
       be suppressed by setting this attribute to "false".
       <em>Since Ant 1.8.3</em>.
     </td>
     <td align="center" valign="top">No - default is "true"</td>
   </tr>
 </table>
 
 <h3>Parameters specified as nested elements</h3>
 <p>This task forms an implicit <a href="../Types/fileset.html">FileSet</a> and
 supports most attributes of <code>&lt;fileset&gt;</code>
 (<code>dir</code> becomes <code>srcdir</code>) as well as the nested
 <code>&lt;include&gt;</code>, <code>&lt;exclude&gt;</code> and
 <code>&lt;patternset&gt;</code> elements.</p>
 <h4><code>srcdir</code>, <code>classpath</code>, <code>sourcepath</code>,
 <code>bootclasspath</code> and <code>extdirs</code></h4>
 <p><code>&lt;javac&gt;</code>'s <code>srcdir</code>, <code>classpath</code>,
 <code>sourcepath</code>, <code>bootclasspath</code>, and
 <code>extdirs</code> attributes are
 <a href="../using.html#path">path-like structures</a>
 and can also be set via nested
 <code>&lt;src&gt;</code> (note the different name!),
 <code>&lt;classpath&gt;</code>,
 <code>&lt;sourcepath&gt;</code>,
 <code>&lt;bootclasspath&gt;</code> and
 <code>&lt;extdirs&gt;</code> elements, respectively.</p>
 
 <h4>compilerarg</h4>
 
 <p>You can specify additional command line arguments for the compiler
 with nested <code>&lt;compilerarg&gt;</code> elements.  These elements
 are specified like <a href="../using.html#arg">Command-line
 Arguments</a> but have an additional attribute that can be used to
 enable arguments only if a given compiler implementation will be
 used.</p>
 <table border="1" cellpadding="2" cellspacing="0">
 <tr>
   <td width="12%" valign="top"><b>Attribute</b></td>
   <td width="78%" valign="top"><b>Description</b></td>
   <td width="10%" valign="top"><b>Required</b></td>
 </tr>
   <tr>
     <td valign="top">value</td>
     <td align="center" rowspan="4">See
     <a href="../using.html#arg">Command-line Arguments</a>.</td>
     <td align="center" rowspan="4">Exactly one of these.</td>
   </tr>
   <tr>
     <td valign="top">line</td>
   </tr>
   <tr>
     <td valign="top">file</td>
   </tr>
   <tr>
     <td valign="top">path</td>
   </tr>
   <tr>
     <td valign="top">prefix</td>
     <td align="center" rowspan="2">See
     <a href="../using.html#arg">Command-line Arguments</a>.
     <em>Since Ant 1.8.</em></td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">suffix</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">compiler</td>
     <td>Only pass the specified argument if the chosen
       compiler implementation matches the value of this attribute.
       Legal values are the
       same as those in the above <a href="#compilervalues">list</a> of valid
       compilers.)</td>
     <td align="center">No</td>
   </tr>
 </table>
 
 <h4>compilerclasspath <em>since Ant 1.8.0</em></h4>
 
 <p>A <a href="../using.html#path">PATH like structure</a> holding the
   classpath to use when loading the compiler implementation if a
   custom class has been specified.  Doesn't have any effect when
   using one of the built-in compilers.</p>
 
 <h4>Any nested element of a type that implements CompilerAdapter
   <em>since Ant 1.8.0</em></h4>
 
 <p>If a defined type implements the <code>CompilerAdapter</code>
   interface a nested element of that type can be used as an
   alternative to the <code>compiler</code> attribute.</p>
 
 <h3>Examples</h3>
 <pre>  &lt;javac srcdir=&quot;${src}&quot;
          destdir=&quot;${build}&quot;
          classpath=&quot;xyz.jar&quot;
          debug=&quot;on&quot;
          source=&quot;1.4&quot;
   /&gt;</pre>
 <p>compiles all <code>.java</code> files under the <code>${src}</code>
 directory, and stores
 the <code>.class</code> files in the <code>${build}</code> directory.
 The classpath used includes <code>xyz.jar</code>, and compiling with
 debug information is on. The source level is 1.4,
 so you can use <code>assert</code> statements.</p>
 
 <pre>  &lt;javac srcdir=&quot;${src}&quot;
          destdir=&quot;${build}&quot;
          fork=&quot;true&quot;
          source=&quot;1.2&quot;
          target=&quot;1.2&quot;
   /&gt;</pre>
 <p>compiles all <code>.java</code> files under the <code>${src}</code>
 directory, and stores the <code>.class</code> files in the
 <code>${build}</code> directory.  This will fork off the javac
 compiler using the default <code>javac</code> executable.
 The source level is 1.2 (similar to 1.1 or 1.3) and
 the class files should be runnable under JDK 1.2+ as well.</p>
 
 <pre>  &lt;javac srcdir=&quot;${src}&quot;
          destdir=&quot;${build}&quot;
          fork=&quot;java$$javac.exe&quot;
          source=&quot;1.5&quot;
   /&gt;</pre>
 <p>compiles all <code>.java</code> files under the <code>${src}</code>
 directory, and stores the <code>.class</code> files in the
 <code>${build}</code> directory.  This will fork off the javac
 compiler, using the executable named <code>java$javac.exe</code>.  Note
 that the <code>$</code> sign needs to be escaped by a second one.
 The source level is 1.5, so you can use generics.</p>
 
 <pre>  &lt;javac srcdir=&quot;${src}&quot;
          destdir=&quot;${build}&quot;
          includes=&quot;mypackage/p1/**,mypackage/p2/**&quot;
          excludes=&quot;mypackage/p1/testpackage/**&quot;
          classpath=&quot;xyz.jar&quot;
          debug=&quot;on&quot;
   /&gt;</pre>
 <p>compiles <code>.java</code> files under the <code>${src}</code>
 directory, and stores the
 <code>.class</code> files in the <code>${build}</code> directory.
 The classpath used includes <code>xyz.jar</code>, and debug information is on.
 Only files under <code>mypackage/p1</code> and <code>mypackage/p2</code> are
 used. All files in and below the <code>mypackage/p1/testpackage</code>
 directory are excluded from compilation.
 You didn't specify a source or target level,
 so the actual values used will depend on which JDK you ran Ant with.</p>
 
 <pre>  &lt;javac srcdir=&quot;${src}:${src2}&quot;
          destdir=&quot;${build}&quot;
          includes=&quot;mypackage/p1/**,mypackage/p2/**&quot;
          excludes=&quot;mypackage/p1/testpackage/**&quot;
          classpath=&quot;xyz.jar&quot;
          debug=&quot;on&quot;
   /&gt;</pre>
 
 <p>is the same as the previous example, with the addition of a second
 source path, defined by
 the property <code>src2</code>. This can also be represented using nested
 <code>&lt;src&gt;</code> elements as follows:</p>
 
 <pre>  &lt;javac destdir=&quot;${build}&quot;
          classpath=&quot;xyz.jar&quot;
          debug=&quot;on&quot;&gt;
     &lt;src path=&quot;${src}&quot;/&gt;
     &lt;src path=&quot;${src2}&quot;/&gt;
     &lt;include name=&quot;mypackage/p1/**&quot;/&gt;
     &lt;include name=&quot;mypackage/p2/**&quot;/&gt;
     &lt;exclude name=&quot;mypackage/p1/testpackage/**&quot;/&gt;
   &lt;/javac&gt;</pre>
 
 <p>If you want to run the javac compiler of a different JDK, you
 should tell Ant, where to find the compiler and which version of JDK
 you will be using so it can choose the correct command line switches.
 The following example executes a JDK 1.1 javac in a new process and
 uses the correct command line switches even when Ant is running in a
 Java VM of a different version:</p>
 
 <pre>  &lt;javac srcdir=&quot;${src}&quot;
          destdir=&quot;${build}&quot;
          fork=&quot;yes&quot;
          executable=&quot;/opt/java/jdk1.1/bin/javac&quot;
          compiler=&quot;javac1.1&quot;
   /&gt;</pre>
 
 <p><a name="srcdirnote"><b>Note:</b></a>
 If you wish to compile only source files located in certain packages below a
 common root, use the <code>include</code>/<code>exclude</code> attributes
 or <code>&lt;include&gt;</code>/<code>&lt;exclude&gt;</code> nested elements
 to filter for these packages. Do not include part of your package structure
 in the <code>srcdir</code> attribute
 (or nested <code>&lt;src&gt;</code> elements), or Ant will recompile your
 source files every time you run your compile target. See the
 <a href="http://ant.apache.org/faq.html#always-recompiles">Ant FAQ</a>
 for additional information.</p>
 
 <p>
 If you wish to compile only files explicitly specified and disable
 javac's default searching mechanism then you can unset the sourcepath
 attribute:
 <pre>  &lt;javac sourcepath=&quot;&quot; srcdir=&quot;${src}&quot;
          destdir=&quot;${build}&quot; &gt;
     &lt;include name="**/*.java"/&gt;
     &lt;exclude name="**/Example.java"/&gt;
   &lt;/javac&gt;</pre>
 That way the javac will compile all java source files under &quot;${src}&quot;
 directory but skip the examples. The compiler will even produce errors if some of
 the non-example files refers to them.
 </p>
 
 <p>
 If you wish to compile with a special JDK (another than the one Ant is currently using),
 set the <code>executable</code> and <code>fork</code> attribute. Using <code>taskname</code>
 could show in the log, that these settings are fix.
 <pre>  &lt;javac srcdir=&quot;&quot; 
          destdir=&quot;&quot;
          executable=&quot;path-to-java14-home/bin/javac&quot; 
          fork=&quot;true&quot;
          taskname=&quot;javac1.4&quot; /&gt;</pre>
 </p>
 
 
 <p><b>Note:</b> If you are using Ant on Windows and a new DOS window pops up
 for every use of an external compiler, this may be a problem of the JDK you are
 using.  This problem may occur with all JDKs &lt; 1.2.</p>
 
 
 <p>
 If you want to activate other compiler options like <i>lint</i> you could use
 the <tt>&lt;compilerarg&gt;</tt> element:
 <pre>  &lt;javac srcdir="${src.dir}"
          destdir="${classes.dir}"
          classpathref="libraries"&gt;
     &lt;compilerarg value="-Xlint"/&gt;
   &lt;/javac&gt; </pre>
 </p>  
 
 <p>If you want to use a custom
   CompilerAdapter <code>org.example.MyAdapter</code> you can either
   use the compiler attribute:</p>
 <pre>
 &lt;javac srcdir="${src.dir}"
        destdir="${classes.dir}"
        compiler="org.example.MyAdapter"/&gt;
 </pre>
 <p>or a define a type and nest this into the task like in:</p>
 <pre>
 &lt;componentdef classname="org.example.MyAdapter"
               name="myadapter"/&gt;
 &lt;javac srcdir="${src.dir}"
        destdir="${classes.dir}"&gt;
   &lt;myadapter/&gt;
 &lt;/javac&gt;
 </pre>
 <p>in which case your compiler adapter can support attributes and
   nested elements of its own.</p>
 
 <h3>Jikes Notes</h3>
 
 <p>You need Jikes 1.15 or later.</p>
 
 <p>Jikes supports some extra options, which can be set be defining
 the properties shown below prior to invoking the task. The setting
 for each property will be in affect for all <code>&lt;javac&gt;</code>
 tasks throughout the build.
 The Ant developers are aware that
 this is ugly and inflexible &ndash; expect a better solution in the future.
 All the options are boolean, and must be set to <code>true</code> or
 <code>yes</code> to be
 interpreted as anything other than false. By default,
 <code>build.compiler.warnings</code> is <code>true</code>,
 while all others are <code>false</code>.</p>
 
 <table border="1" cellpadding="2" cellspacing="0">
   <tr>
     <td valign="top"><b>Property</b></td>
     <td valign="top"><b>Description</b></td>
     <td align="center" valign="top"><b>Default</b></td>
   </tr>
   <tr>
     <td valign="top">
 	build.compiler.emacs
 	</td>
 	<td valign="top">
 	Enable emacs-compatible error messages.
     </td>
     <td valign="top">
 	<code>false</code>
 	</td>
   </tr>
   <tr>
     <td valign="top">
 	build.compiler.fulldepend
 	</td>
 	<td valign="top">
 	Enable full dependency checking; see<br>
 	the <code>+F</code> switch in the Jikes manual.
     </td>
     <td valign="top">
 	<code>false</code>
 	</td>
   </tr>
   <tr>
     <td valign="top">
 	build.compiler.pedantic
 	</td>
 	<td valign="top">
 	Enable pedantic warnings.
     </td>
     <td valign="top">
 	<code>false</code>
 	</td>
   </tr>
   <tr>
     <td valign="top">
 	build.compiler.warnings<br>
         <strong>Deprecated</strong>. Use
   <code>&lt;javac&gt;</code>'s <code>nowarn</code>
   attribute instead.
 	</td>
 	<td valign="top">
 	Don't disable warning messages.
     </td>
     <td valign="top">
 	<code>true</code>
 	</td>
   </tr>
 </table>
 
 <h3>Jvc Notes</h3>
 
 <p>Jvc will enable Microsoft extensions unless you set the property
 <code>build.compiler.jvc.extensions</code> to false before invoking
 <code>&lt;javac&gt;</code>.</p>
 
 <h3><a name="bootstrap">Bootstrap Options</h3>
 <p>
   The Sun javac compiler has a <em>bootclasspath</em> command
   line option - this corresponds to the "bootclasspath" attribute/element
   of the &lt;javac&gt; task. The Sun compiler also allows more
   control over the boot classpath using the -X and -J-X attributes.
   One can set these by using the &lt;compilerarg&gt;. Since Ant 1.6.0,
   there is a shortcut to convert path references to strings that
   can by used in an OS independent fashion (see
   <a href="../using.html#pathshortcut">pathshortcut</a>). For example:
 </p>
 <pre>
   &lt;path id="lib.path.ref"&gt;
     &lt;fileset dir="lib" includes="*.jar"/&gt;
   &lt;/path&gt;
   &lt;javac srcdir="src" destdir="classes"&gt;
     &lt;compilerarg arg="-Xbootclasspath/p:${toString:lib.path.ref}"/&gt;
   &lt;/javac&gt;
 </pre>
 
   
 </p>
 
 <h3>OpenJDK Notes</h3>
 <p>
   The <a href="https://openjdk.dev.java.net/">openjdk</a>
   project has provided the javac
   <a href="https://openjdk.dev.java.net/compiler/">compiler</a>
   as an opensource project. The output of this project is a
   <code>javac.jar</code> which contains the javac compiler.
   This compiler may be used with the <code>&lt;javac&gt;</code> task with
   the use of a <code>-Xbootclasspath/p</code> java argument. The argument needs
   to be given to the runtime system of the javac executable, so it needs
   to be prepended with a "-J". For example:
 
 <blockquote><pre>
   &lt;property name="patched.javac.jar"
             location="${my.patched.compiler}/dist/lib/javac.jar"/&gt;
 
   &lt;presetdef name="patched.javac"&gt;
     &lt;javac fork="yes"&gt;
       &lt;compilerarg value="-J-Xbootclasspath/p:${patched.javac.jar}"/&gt;
     &lt;/javac&gt;
   &lt;/presetdef&gt;
 
 
   &lt;patched.javac srcdir="src/java" destdir="build/classes"
                  debug="yes"/&gt;
 </pre></blockquote>
 
   <h3>Note on package-info.java</h3>
   <p>
     <code>package-info.java</code> files were introduced in Java5 to
     allow package level annotations. On compilation, if the java file
     does not contain runtime annotations, there will be no .class file
     for the java file. Up to <b>Ant 1.7.1</b>, when the &lt;javac&gt;
     task is run again, the
     task will try to compile the package-info java files again.
   </p>
   <p>With Ant 1.7.1 a different kind of logic was introduced that
     involved the timestamp of the directory that would normally
     contain the .class file.  This logic turned out to lead to Ant not
     recompiling <code>package-info.java</code> in certain setup.</p>
   <p>Starting with Ant 1.8.0 Ant will create
     "empty" <code>package-info.class</code> files if it compiles
     a <code>package-info.java</code> and
     no <code>package-info.class</code> file has been created by the
     compiler itself.</p>
 </body>
 </html>
diff --git a/manual/Tasks/junit.html b/manual/Tasks/junit.html
index 2a328eb22..76df9ced6 100644
--- a/manual/Tasks/junit.html
+++ b/manual/Tasks/junit.html
@@ -1,802 +1,802 @@
 <!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 -->
 <html>
 <head>
 <link rel="stylesheet" type="text/css" href="../stylesheets/style.css">
 <title>JUnit Task</title>
 </head>
 <body>
 
 <h2><a name="junit">JUnit</a></h2>
 <h3>Description</h3>
 
 <p>This task runs tests from the JUnit testing framework. The latest
 version of the framework can be found at
 <a href="http://www.junit.org">http://www.junit.org</a>.
 This task has been tested with JUnit 3.0 up to JUnit 3.8.2; it won't
 work with versions prior to JUnit 3.0. It also works with JUnit 4.0, including
 "pure" JUnit 4 tests using only annotations and no <code>JUnit4TestAdapter</code>.</p>
 <p><strong>Note:</strong> This task depends on external libraries not included
 in the Apache Ant distribution.  See <a href="../install.html#librarydependencies">
 Library Dependencies</a> for more information.
 </p>
 <p>
 <strong>Note</strong>:
 You must have <code>junit.jar</code> available.
 You can do one of:
 </p>
 <ol>
 <li>
 Put both <code>junit.jar</code> and <code>ant-junit.jar</code> in
 <code>ANT_HOME/lib</code>.
 </li>
 <li>
 Do not put either in <code>ANT_HOME/lib</code>, and instead
 include their locations in your <code>CLASSPATH</code> environment variable.
 </li>
 <li>
 Add both JARs to your classpath using <code>-lib</code>.
 </li>
 <li>
 Specify the locations of both JARs using
 a <code>&lt;classpath&gt;</code> element in a <code>&lt;taskdef&gt;</code> in the build file.
 </li>
 <li>
 Leave <code>ant-junit.jar</code> in its default location in <code>ANT_HOME/lib</code>
 but include <code>junit.jar</code> in the <code>&lt;classpath&gt;</code> passed
 to <code>&lt;junit&gt;</code>. <em>(since Ant 1.7)</em>
 </li>
 </ol>
 <p>
 See <a href="http://ant.apache.org/faq.html#delegating-classloader" target="_top">the
 FAQ</a> for details.
 </p>
 
 <p>Tests are defined by nested <code>test</code> or
 <code>batchtest</code> tags (see <a href="#nested">nested
 elements</a>).</p>
 
 <h3>Parameters</h3>
 <table border="1" cellpadding="2" cellspacing="0">
 <tr>
   <td width="12%" valign="top"><b>Attribute</b></td>
   <td width="78%" valign="top"><b>Description</b></td>
   <td width="10%" valign="top"><b>Required</b></td>
 </tr>
   <tr>
     <td valign="top">printsummary</td>
     <td valign="top">Print one-line statistics for each testcase. Can
       take the values <code>on</code>,
       <code>off</code>, and
       <code>withOutAndErr</code>.
       <code>withOutAndErr</code> is the same
       as <code>on</code> but also includes the output of the test
       as written to <code>System.out</code> and <code>System.err</code>.</td>
     <td align="center" valign="top">No; default is <code>off</code>.</td>
   </tr>
   <tr>
     <td valign="top">fork</td>
     <td valign="top">Run the tests in a separate VM.</td>
     <td align="center" valign="top">No; default is <code>off</code>.</td>
   </tr>
   <tr>
     <td valign="top">forkmode</td>
     <td valign="top">Controls how many Java Virtual Machines get
     created if you want to fork some tests.  Possible values are
     &quot;perTest&quot; (the default), &quot;perBatch&quot; and
     &quot;once&quot;.  &quot;once&quot; creates only a single Java VM
     for all tests while &quot;perTest&quot; creates a new VM for each
     TestCase class.  &quot;perBatch&quot; creates a VM for each nested
     <code>&lt;batchtest&gt;</code> and one collecting all nested
     <code>&lt;test&gt;</code>s.  Note that only tests with the same
     settings of <code>filtertrace</code>, <code>haltonerror</code>,
     <code>haltonfailure</code>, <code>errorproperty</code> and
     <code>failureproperty</code> can share a VM, so even if you set
     <code>forkmode</code> to &quot;once&quot;, Ant may have to create
     more than a single Java VM.  This attribute is ignored for tests
     that don't get forked into a new Java VM.  <em>since Ant 1.6.2</em></td>
     <td align="center" valign="top">No; default is <code>perTest</code>.</td>
   </tr>
   <tr>
     <td valign="top">haltonerror</td>
     <td valign="top">Stop the build process if an error occurs during the test
        run.</td>
     <td align="center" valign="top">No; default is <code>off</code>.</td>
   </tr>
 <tr>
     <td valign="top">errorproperty</td>
     <td valign="top">The name of a property to set in the event of an error.</td>
     <td align="center" valign="top">No</td>
 </tr>
   <tr>
     <td valign="top">haltonfailure</td>
     <td valign="top">Stop the build process if a test fails (errors are
       considered failures as well).</td>
     <td align="center" valign="top">No; default is <code>off</code>.</td>
   </tr>
 <tr>
     <td valign="top">failureproperty</td>
     <td valign="top">The name of a property to set in the event of a failure
       (errors are considered failures as well).</td>
     <td align="center" valign="top">No.</td>
 </tr>
   <tr>
     <td valign="top">filtertrace</td>
     <td valign="top">Filter out Junit and Ant stack frames from error and failure stack traces.</td>
     <td align="center" valign="top">No; default is <code>on</code>.</td>
   </tr>
   <tr>
     <td valign="top">timeout</td>
     <td valign="top">Cancel the individual tests if they don't finish
       in the given time (measured in milliseconds).  Ignored if
       <code>fork</code> is disabled.  When running multiple tests
       inside the same Java VM (see forkMode), timeout applies to the
       time that all tests use together, not to an individual
       test.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">maxmemory</td>
     <td valign="top">Maximum amount of memory to allocate to the forked VM.
       Ignored if <code>fork</code> is disabled. <strong>Note</strong>: 
       If you get <code>java.lang.OutOfMemoryError: Java heap space</code>
       in some of your tests then you need to raise the size like
       <code>maxmemory="128m"</code></td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">jvm</td>
     <td valign="top">The command used to invoke the Java Virtual Machine,
       default is 'java'.  The command is resolved by
       <code>java.lang.Runtime.exec()</code>.
       Ignored if <code>fork</code> is disabled.</td>
     <td align="center" valign="top">No; default is <code>java</code>.</td>
   </tr>
   <tr>
     <td valign="top">dir</td>
     <td valign="top">The directory in which to invoke the VM. Ignored if
       <code>fork</code> is disabled.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">newenvironment</td>
     <td valign="top">Do not propagate the old environment when new
       environment variables are specified. Ignored if <code>fork</code> is
       disabled.</td>
     <td align="center" valign="top">No; default is <code>false</code>.</td>
   </tr>
   <tr>
     <td valign="top">includeantruntime</td>
     <td valign="top">Implicitly add the Ant classes required to run
       the tests and JUnit to the classpath in forked mode.
     </td>
     <td align="center" valign="top">No; default is <code>true</code>.</td>
   </tr>
   <tr>
     <td valign="top">showoutput</td>
     <td valign="top">Send any output generated by tests to Ant's
       logging system as well as to the formatters.  By default only the
       formatters receive the output.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">outputtoformatters</td>
     <td valign="top">
       <em>Since Ant 1.7.0.</em><br/>
       Send any output generated by tests to the test formatters.
       This is "true" by default.
     </td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">tempdir</td>
     <td valign="top">Where Ant should place temporary files.
       <em>Since Ant 1.6</em>.</td>
     <td align="center" valign="top">No; default is the project's base
       directory.</td>
   </tr>
   <tr>
     <td valign="top">reloading</td>
     <td valign="top">Whether or not a new classloader should be instantiated for each test case.<br>
     Ignore if <code>fork</code> is set to true.
       <em>Since Ant 1.6</em>.</td>
     <td align="center" valign="top">No; default is <code>true</code>.</td>
   </tr>
   <tr>
     <td valign="top">clonevm</td>
     <td valign="top">If set to true true, then all system properties
       and the bootclasspath of the forked Java Virtual Machine will be
       the same as those of the Java VM running Ant.  Default is
       &quot;false&quot; (ignored if fork is disabled).
       <em>since Ant 1.7</em></td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">logfailedtests</td>
     <td valign="top">When Ant executes multiple tests and doesn't stop
       on errors or failures it will log a "FAILED" message for each
       failing test to its logging system.  If you set this option to
       false, the message will not be logged and you have to rely on the
       formatter output to find the failing tests.
       <em>since Ant 1.8.0</em></td>
     <td align="center" valign="top">No</td>
   </tr>    
   <tr>
     <td valign="top">enableTestListenerEvents</td>
     <td valign="top">Whether Ant should send fine grained information
       about the running tests to Ant's logging system at the verbose
       level.  Such events may be used by custom test listeners to show
       the progress of tests.<br/>
       Defaults to <code>false</code>.<br/>
       Can be overridden by a <a href="#enabletestlistenerevents">magic
         property</a>.<br/>
       <em>since Ant 1.8.2</em> - <strong>Ant 1.7.0 to 1.8.1 behave as
         if this attribute was true by default.</strong></td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">threads</td>
     <td valign="top">a number of threads to run the tests in.<br/>
       When this attribute is specified the tests will be split arbitrarily among the threads.<br/>
       requires that the tests be forked with the <code>perTest</code>
       option to be operative.<br/>
       <em>since Ant 1.9.4</em></td>
     <td align="center" valign="top">No</td>
   </tr>
 </table>
 
 <p>By using the <code>errorproperty</code> and <code>failureproperty</code>
 attributes, it is possible to
 perform setup work (such as starting an external server), execute the test,
 clean up, and still fail the build in the event of a failure.</p>
 
 <p>The <code>filtertrace</code> attribute condenses error and failure
 stack traces before reporting them.
 It works with both the plain and XML formatters.  It filters out any lines
 that begin with the following string patterns:<pre>
    "junit.framework.TestCase"
    "junit.framework.TestResult"
    "junit.framework.TestSuite"
    "junit.framework.Assert."
    "junit.swingui.TestRunner"
    "junit.awtui.TestRunner"
    "junit.textui.TestRunner"
    "java.lang.reflect.Method.invoke("
    "sun.reflect."
    "org.apache.tools.ant."
    "org.junit."
    "junit.framework.JUnit4TestAdapter"
    " more"</pre>
 
 <h3><a name="nested">Nested Elements</a></h3>
 
 <p>The <code>&lt;junit&gt;</code> task
 supports a nested <code>&lt;classpath&gt;</code>
 element that represents a <a href="../using.html#path">PATH like
 structure</a>.</p>
 
 <p>As of Ant 1.7, this classpath may be used to refer to <code>junit.jar</code>
 as well as your tests and the tested code.
 
 <h4>jvmarg</h4>
 
 <p>If <code>fork</code> is enabled, additional parameters may be passed to
 the new VM via nested <code>&lt;jvmarg&gt;</code> elements. For example:</p>
 
 <pre>
 &lt;junit fork=&quot;yes&quot;&gt;
   &lt;jvmarg value=&quot;-Djava.compiler=NONE&quot;/&gt;
   ...
 &lt;/junit&gt;
 </pre>
 
 <p>would run the test in a VM without JIT.</p>
 
 <p><code>&lt;jvmarg&gt;</code> allows all attributes described in <a
 href="../using.html#arg">Command-line Arguments</a>.</p>
 
 <h4>sysproperty</h4>
 
 <p>Use nested <code>&lt;sysproperty&gt;</code> elements to specify system
 properties required by the class. These properties will be made available
 to the VM during the execution of the test (either ANT's VM or the forked VM,
 if <code>fork</code> is enabled).
 The attributes for this element are the same as for <a href="../Tasks/exec.html#env">environment variables</a>.</p>
 
 <pre>
 &lt;junit fork=&quot;no&quot;&gt;
   &lt;sysproperty key=&quot;basedir&quot; value=&quot;${basedir}&quot;/&gt;
   ...
 &lt;/junit&gt;
 </pre>
 
 <p>would run the test in ANT's VM and make the <code>basedir</code> property
 available to the test.</p>
 
 <h4>syspropertyset</h4>
 
 <p>You can specify a set of properties to be used as system properties
 with <a href="../Types/propertyset.html">syspropertyset</a>s.</p>
 
 <p><em>since Ant 1.6</em>.</p>
 
 <h4>env</h4>
 
 <p>It is possible to specify environment variables to pass to the
 forked VM via nested <code>&lt;env&gt;</code> elements. For a description
 of the <code>&lt;env&gt;</code> element's attributes, see the
 description in the <a href="../Tasks/exec.html#env">exec</a> task.</p>
 
 <p>Settings will be ignored if <code>fork</code> is disabled.</p>
 
 <h4>bootclasspath</h4>
 
 <p>The location of bootstrap class files can be specified using this
 <a href="../using.html#path">PATH like structure</a> - will be ignored
 if <i>fork</i> is not <code>true</code> or the target VM doesn't
 support it (i.e. Java 1.1).</p>
 
 <p><em>since Ant 1.6</em>.</p>
 
 <h4>permissions</h4>
 <p>Security permissions can be revoked and granted during the execution of the 
 class via a nested <i>permissions</i> element. For more information please
 see <a href="../Types/permissions.html">permissions</a></p>
 
 <p>Settings will be ignored if fork is enabled.</p>
 
 <p><em>since Ant 1.6</em>.</p>
  
 <h4>assertions</h4>
 
 <p>You can control enablement of Java 1.4 assertions with an
 <a href="../Types/assertions.html"><tt>&lt;assertions&gt;</tt></a>
 subelement.</p>
  
 <p>Assertion statements are currently ignored in non-forked mode.</p>
 
 <p><em>since Ant 1.6.</em></p>
 
 <h4>formatter</h4>
 
 <p>The results of the tests can be printed in different
 formats. Output will always be sent to a file, unless you set the
 <code>usefile</code> attribute to <code>false</code>.
 The name of the file is determined by the
 name of the test and can be set by the <code>outfile</code> attribute
 of <code>&lt;test&gt;</code>.</p>
 
 <p>There are four predefined formatters - one prints the test results
 in XML format, the other emits plain text.  The formatter named
 <code>brief</code> will only print detailed information for testcases
 that failed, while <code>plain</code> gives a little statistics line
 for all test cases.  Custom formatters that need to implement
 <code>org.apache.tools.ant.taskdefs.optional.junit.JUnitResultFormatter</code>
 can be specified.</p>
 
 <p>If you use the XML formatter, it may not include the same output
 that your tests have written as some characters are illegal in XML
 documents and will be dropped.</p>
 
 <p>The fourth formatter named <code>failure</code> (since Ant 1.8.0) 
 collects all failing <code>testXXX()</code>
 methods and creates a new <code>TestCase</code> which delegates only these
 failing methods. The name and the location can be specified via Java System property or Ant property
 <code>ant.junit.failureCollector</code>. The value has to point to the directory and 
 the name of the resulting class (without suffix). It defaults to <i>java-tmp-dir</i>/FailedTests.</p>
 
 <table border="1" cellpadding="2" cellspacing="0">
 <tr>
   <td width="12%" valign="top"><b>Attribute</b></td>
   <td width="78%" valign="top"><b>Description</b></td>
   <td width="10%" valign="top"><b>Required</b></td>
 </tr>
   <tr>
     <td valign="top">type</td>
     <td valign="top">Use a predefined formatter (either
       <code>xml</code>, <code>plain</code>, <code>brief</code> or <code>failure</code>).</td>
     <td align="center" rowspan="2">Exactly one of these.</td>
   </tr>
   <tr>
     <td valign="top">classname</td>
     <td valign="top">Name of a custom formatter class.</td>
   </tr>
   <tr>
     <td valign="top">extension</td>
     <td valign="top">Extension to append to the output filename.</td>
     <td align="center">Yes, if <code>classname</code> has been used.</td>
   </tr>
   <tr>
     <td valign="top">usefile</td>
     <td valign="top">Boolean that determines whether output should be
       sent to a file.</td>
     <td align="center">No; default is <code>true</code>.</td>
   </tr>
   <tr>
     <td valign="top">if</td>
     <td valign="top">Only use formatter <a href="../properties.html#if+unless">if the named property is set</a>.</td>
     <td align="center">No; default is <code>true</code>.</td>
   </tr>
   <tr>
     <td valign="top">unless</td>
     <td valign="top">Only use formatter <a href="../properties.html#if+unless">if the named property is <b>not</b> set</a>.</td>
     <td align="center">No; default is <code>true</code>.</td>
   </tr>  
 </table>
 
 <h4>test</h4>
 
 <p>Defines a single test class.</p>
 
 <table border="1" cellpadding="2" cellspacing="0">
 <tr>
   <td width="12%" valign="top"><b>Attribute</b></td>
   <td width="78%" valign="top"><b>Description</b></td>
   <td width="10%" valign="top"><b>Required</b></td>
 </tr>
   <tr>
     <td valign="top">name</td>
     <td valign="top">Name of the test class.</td>
     <td align="center">Yes</td>
   </tr>
   <tr>
     <td valign="top">methods</td>
     <td valign="top">Comma-separated list of names of test case methods to execute.
       <em>Since 1.8.2</em>
       <p>The <code>methods</code> attribute can be useful in the following scenarios:</p>
       <ul>
         <li>A test method has failed and you want to re-run the test method
             to test a fix or re-run the test under the Java debugger without
             having to wait for the other (possibly long running) test methods
             to complete.</li>
         <li>One or more test methods are running slower than expected and you
             want to re-run them under a Java profiler (without the overhead
             of running the profiler whilst other test methods are being
             executed).</li>
       </ul>
       <p>If the <code>methods</code> attribute is used but no test method
       is specified, then no test method from the suite will be executed.</p>
     </td>
     <td align="center">No; default is to run all test methods in the suite.</td>
   </tr>  
   <tr>
     <td valign="top">fork</td>
     <td valign="top">Run the tests in a separate VM.
       Overrides value set in <code>&lt;junit&gt;</code>.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">haltonerror</td>
     <td valign="top">Stop the build process if an error occurs during the test
        run. Overrides value set in <code>&lt;junit&gt;</code>.</td>
     <td align="center" valign="top">No</td>
   </tr>
 <tr>
     <td valign="top">errorproperty</td>
     <td valign="top">The name of a property to set in the event of an error.
       Overrides value set in <code>&lt;junit&gt;</code>.</td>
     <td align="center" valign="top">No</td>
 </tr>
   <tr>
     <td valign="top">haltonfailure</td>
     <td valign="top">Stop the build process if a test fails (errors are
       considered failures as well).  Overrides value set in
       <code>&lt;junit&gt;</code>.</td>
     <td align="center" valign="top">No</td>
   </tr>
 <tr>
     <td valign="top">failureproperty</td>
     <td valign="top">The name of a property to set in the event of a failure
       (errors are considered failures as well). Overrides value set in
       <code>&lt;junit&gt;</code>.</td>
     <td align="center" valign="top">No</td>
 </tr>
   <tr>
     <td valign="top">filtertrace</td>
     <td valign="top">Filter out Junit and Ant stack frames from error and failure stack
     traces.  Overrides value set in <code>&lt;junit&gt;</code>.</td>
     <td align="center" valign="top">No; default is <code>on</code>.</td>
   </tr>
   <tr>
     <td valign="top">todir</td>
     <td valign="top">Directory to write the reports to.</td>
     <td align="center" valign="top">No; default is the current directory.</td>
   </tr>
   <tr>
     <td valign="top">outfile</td>
     <td valign="top">Base name of the test result. The full filename is
       determined by this attribute and the extension of
       <code>formatter</code>.</td>
     <td align="center" valign="top">No; default is
       <code>TEST-</code><em>name</em>, where <em>name</em> is the name of
       the test specified in the <code>name</code> attribute.</td>
   </tr>
   <tr>
     <td valign="top">if</td>
     <td valign="top">Only run test <a href="../properties.html#if+unless">if the named property is set</a>.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">unless</td>
     <td valign="top">Only run test <a href="../properties.html#if+unless">if the named property is <b>not</b> set</a>.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">skipNonTests</td>
     <td valign="top">Do not pass any classes that do not contain JUnit tests to the test runner.
           This prevents non tests from appearing as test errors in test results.<br />
           Tests are identified by looking for the <code>@Test</code> annotation on any methods in concrete classes
           that don't extend <code>junit.framework.TestCase</code>, or for public/protected methods with
           names starting with 'test' in concrete classes that extend <code>junit.framework.TestCase</code>.
           Classes marked with the JUnit4 <code>org.junit.runner.RunWith</code> or
           <code>org.junit.runner.Suite.SuiteClasses</code> annotations are also passed to JUnit for execution,
           as is any class with a public/protected no-argument <code>suite</code> method.</td>
     <td align="center" valign="top">No. Default is false.</td>
   </tr>
 </table>
 
 <p>Tests can define their own formatters via nested
 <code>&lt;formatter&gt;</code> elements.</p>
 
 <h4>batchtest</h4>
 
 <p>Define a number of tests based on pattern matching.</p>
 
 <p><code>batchtest</code> collects the included <a href="../Types/resources.html">resources</a> from any number
 of nested <a
 href="../Types/resources.html#collection">Resource Collection</a>s. It then
 generates a test class name for each resource that ends in
 <code>.java</code> or <code>.class</code>.</p>
 
 <p>Any type of Resource Collection is supported as a nested element,
 prior to Ant 1.7 only <code>&lt;fileset&gt;</code> has been
 supported.</p>
 
 <table border="1" cellpadding="2" cellspacing="0">
 <tr>
   <td width="12%" valign="top"><b>Attribute</b></td>
   <td width="78%" valign="top"><b>Description</b></td>
   <td width="10%" valign="top"><b>Required</b></td>
 </tr>
   <tr>
     <td valign="top">fork</td>
     <td valign="top">Run the tests in a separate VM.
       Overrides value set in <code>&lt;junit&gt;</code>.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">haltonerror</td>
     <td valign="top">Stop the build process if an error occurs during the test
        run. Overrides value set in <code>&lt;junit&gt;</code>.</td>
     <td align="center" valign="top">No</td>
   </tr>
 <tr>
     <td valign="top">errorproperty</td>
     <td valign="top">The name of a property to set in the event of an error.
       Overrides value set in <code>&lt;junit&gt;</code>.</td>
     <td align="center" valign="top">No</td>
 </tr>
   <tr>
     <td valign="top">haltonfailure</td>
     <td valign="top">Stop the build process if a test fails (errors are
       considered failures as well).  Overrides value set in
       <code>&lt;junit&gt;</code>.</td>
     <td align="center" valign="top">No</td>
   </tr>
 <tr>
     <td valign="top">failureproperty</td>
     <td valign="top">The name of a property to set in the event of a failure
       (errors are considered failures as well). Overrides value set in
       <code>&lt;junit&gt;</code></td>
     <td align="center" valign="top">No</td>
 </tr>
   <tr>
     <td valign="top">filtertrace</td>
     <td valign="top">Filter out Junit and Ant stack frames from error and failure stack
     traces.  Overrides value set in <code>&lt;junit&gt;</code>.</td>
     <td align="center" valign="top">No; default is <code>on</code>.</td>
   </tr>
   <tr>
     <td valign="top">todir</td>
     <td valign="top">Directory to write the reports to.</td>
     <td align="center" valign="top">No; default is the current directory.</td>
   </tr>
   <tr>
     <td valign="top">if</td>
     <td valign="top">Only run tests <a href="../properties.html#if+unless">if the named property is set</a>.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
     <td valign="top">unless</td>
     <td valign="top">Only run tests <a href="../properties.html#if+unless">if the named property is <strong>not</strong> set</a>.</td>
     <td align="center" valign="top">No</td>
   </tr>
   <tr>
       <td valign="top">skipNonTests</td>
       <td valign="top">Do not pass any classes that do not contain JUnit tests to the test runner.
                           This prevents non tests from appearing as test errors in test results.<br />
                           Tests are identified by looking for the <code>@Test</code> annotation on any methods in concrete classes
                           that don't extend <code>junit.framework.TestCase</code>, or for public/protected methods with
                           names starting with 'test' in concrete classes that extend <code>junit.framework.TestCase</code>.
                           Classes marked with the JUnit4 <code>org.junit.runner.RunWith</code> or
                           <code>org.junit.runner.Suite.SuiteClasses</code> annotations are also passed to JUnit for execution,
                           as is any class with a public/protected no-argument <code>suite</code> method.</td>
       <td align="center" valign="top">No. Default is false.</td>
   </tr>
 </table>
 
 <p>Batchtests can define their own formatters via nested
 <code>&lt;formatter&gt;</code> elements.</p>
 
 <h3>Forked tests and <code>tearDown</code></h3>
 
 <p>If a forked test runs into a timeout, Ant will terminate the Java
   VM process it has created, which probably means the
   test's <code>tearDown</code> method will never be called.  The same
   is true if the forked VM crashes for some other reason.</p>
 
 <p>Starting with Ant 1.8.0, a special formatter is distributed with
   Ant that tries to load the testcase that was in the forked VM and
   invoke that class' <code>tearDown</code> method.  This formatter has
   the following limitations:</p>
 
 <ul>
   <li>It runs in the same Java VM as Ant itself, this is a different
     Java VM than the one that was executing the test and it may see a
-    different classloader (and thus may be unable to load the tast
+    different classloader (and thus may be unable to load the test
     class).</li>
   <li>It cannot determine which test was run when the timeout/crash
     occurred if the forked VM was running multiple test.  I.e. the
     formatter cannot work with any <code>forkMode</code> other
     than <code>perTest</code> and it won't do anything if the test
     class contains a <code>suite()</code> method.</li>
 </ul>
 
 <p>If the formatter recognizes an incompatible <code>forkMode</code>
   or a <code>suite</code> method or fails to load the test class it
   will silently do nothing.</p>
 
 <p>The formatter doesn't have any effect on tests that were not
   forked or didn't cause timeouts or VM crashes.</p>
 
 <p>To enable the formatter, add a <code>formatter</code> like</p>
 
 <pre>
 &lt;formatter classname="org.apache.tools.ant.taskdefs.optional.junit.TearDownOnVmCrash"
            usefile="false"/&gt;
 </pre>
 
 <p>to your <code>junit</code> task.</p>
 
 <h3><a name="enabletestlistenerevents"><code>ant.junit.enabletestlistenerevents</code></a>
   magic property</h3>
 
 <p><em>Since Ant 1.8.2</em> the <code>enableTestListenerEvents</code>
   attribute of the task controls whether fine grained logging messages
   will be sent to the task's verbose log.  In addition to this
   attribute Ant will consult the
   property <code>ant.junit.enabletestlistenerevents</code> and the
   value of the property overrides the setting of the attribute.</p>
 
 <p>This property exists so that containers running Ant that depend on
   the additional logging events can ensure they will be generated even
   if the build file disables them.</p>
 
 <h3>Examples</h3>
 
 <pre>
 &lt;junit&gt;
   &lt;test name="my.test.TestCase"/&gt;
 &lt;/junit&gt;
 </pre>
 
 <p>Runs the test defined in <code>my.test.TestCase</code> in the same
 VM. No output will be generated unless the test fails.</p>
 
 <pre>
 &lt;junit printsummary="yes" fork="yes" haltonfailure="yes"&gt;
   &lt;formatter type="plain"/&gt;
   &lt;test name="my.test.TestCase"/&gt;
 &lt;/junit&gt;
 </pre>
 
 <p>Runs the test defined in <code>my.test.TestCase</code> in a
 separate VM.  At the end of the test, a one-line summary will be
 printed. A detailed report of the test can be found in
 <code>TEST-my.test.TestCase.txt</code>. The build process will be
 stopped if the test fails.</p>
 
 <pre>
 &lt;junit printsummary="yes" haltonfailure="yes"&gt;
   &lt;classpath&gt;
     &lt;pathelement location="${build.tests}"/&gt;
     &lt;pathelement path="${java.class.path}"/&gt;
   &lt;/classpath&gt;
 
   &lt;formatter type="plain"/&gt;
 
   &lt;test name="my.test.TestCase" haltonfailure="no" outfile="result"&gt;
     &lt;formatter type="xml"/&gt;
   &lt;/test&gt;
 
   &lt;batchtest fork="yes" todir="${reports.tests}"&gt;
     &lt;fileset dir="${src.tests}"&gt;
       &lt;include name="**/*Test*.java"/&gt;
       &lt;exclude name="**/AllTests.java"/&gt;
     &lt;/fileset&gt;
   &lt;/batchtest&gt;
 &lt;/junit&gt;
 </pre>
 
 <p>Runs <code>my.test.TestCase</code> in the same VM, ignoring the
 given CLASSPATH; only a warning is printed if this test fails. In
 addition to the plain text test results, for this test a XML result
 will be output to <code>result.xml</code>.  
 Then, for each matching file in the directory defined for
 <code>${src.tests}</code> a
 test is run in a separate VM. If a test fails, the build process is
 aborted. Results are collected in files named
 <code>TEST-</code><em>name</em><code>.txt</code> and written to
 <code>${reports.tests}</code>.</p>
 
 <pre>
 &lt;target name=&quot;test&quot;&gt;
     &lt;property name=&quot;collector.dir&quot; value=&quot;${build.dir}/failingTests&quot;/&gt;
     &lt;property name=&quot;collector.class&quot; value=&quot;FailedTests&quot;/&gt;
     &lt;!-- Delete 'old' collector classes --&gt;
     &lt;delete&gt;
         &lt;fileset dir=&quot;${collector.dir}&quot; includes=&quot;${collector.class}*.class&quot;/&gt;
     &lt;/delete&gt;
     &lt;!-- compile the FailedTests class if present --&gt; 
     &lt;javac srcdir=&quot;${collector.dir}&quot; destdir=&quot;${collector.dir}&quot;/&gt;
     &lt;available file=&quot;${collector.dir}/${collector.class}.class&quot; property=&quot;hasFailingTests&quot;/&gt;
     &lt;junit haltonerror=&quot;false&quot; haltonfailure=&quot;false&quot;&gt;
         &lt;sysproperty key=&quot;ant.junit.failureCollector&quot; value=&quot;${collector.dir}/${collector.class}&quot;/&gt;
         &lt;classpath&gt;
             &lt;pathelement location=&quot;${collector.dir}&quot;/&gt;
         &lt;/classpath&gt;
         &lt;batchtest todir=&quot;${collector.dir}&quot; unless=&quot;hasFailingTests&quot;&gt;
             &lt;fileset dir=&quot;${collector.dir}&quot; includes=&quot;**/*.java&quot; excludes=&quot;**/${collector.class}.*&quot;/&gt;
             &lt;!-- for initial creation of the FailingTests.java --&gt;
             &lt;formatter type=&quot;failure&quot;/&gt;
             &lt;!-- I want to see something ... --&gt;
             &lt;formatter type=&quot;plain&quot; usefile=&quot;false&quot;/&gt;
         &lt;/batchtest&gt;
         &lt;test name=&quot;FailedTests&quot; if=&quot;hasFailingTests&quot;&gt;
             &lt;!-- update the FailingTests.java --&gt;
             &lt;formatter type=&quot;failure&quot;/&gt;
             &lt;!-- again, I want to see something --&gt;
             &lt;formatter type=&quot;plain&quot; usefile=&quot;false&quot;/&gt;
         &lt;/test&gt;
     &lt;/junit&gt;
 &lt;/target&gt;
 </pre>
 <p>On the first run all tests are collected via the <code>&lt;batchtest/&gt;</code>
 element. Its <code>plain</code> formatter shows the output on the console. The
 <code>failure</code> formatter creates a java source file in 
 <code>${build.dir}/failingTests/FailedTests.java</code> which extends 
 <code>junit.framework.TestCase</code> and returns from a <code>suite()</code>
 method a test suite for the failing tests. <br/>
 On a second run the collector class exists and instead of the <code>&lt;batchtest/&gt;</code>
 the single <code>&lt;test/&gt;</code> will run. So only the failing test cases are re-run.
 The two nested formatters are for displaying (for the user) and for updating the collector
 class.
 </p>
 
 
 </body>
 </html>
diff --git a/manual/Types/propertyset.html b/manual/Types/propertyset.html
index 94fcf44e8..81d491e0b 100644
--- a/manual/Types/propertyset.html
+++ b/manual/Types/propertyset.html
@@ -1,143 +1,143 @@
 <!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 -->
 <html>
 
 <head>
 <meta http-equiv="Content-Language" content="en-us">
 <link rel="stylesheet" type="text/css" href="../stylesheets/style.css">
 <title>PropertySet Type</title>
 </head>
 
 <body>
 
 <h2><a name="propertyset">PropertySet</a></h2>
 <p><em>Since Apache Ant 1.6</em></p>
 
 <p>Groups a set of properties to be used by reference in a task that
 supports this.</p>
 
 <table border="1" cellpadding="2" cellspacing="0">
   <tr>
     <td valign="top"><b>Attribute</b></td>
     <td valign="top"><b>Description</b></td>
     <td align="center" valign="top"><b>Required</b></td>
   </tr>
   <tr>
     <td valign="top">dynamic</td>
-    <td valign="top">Whether to reevaluate the set everytime the set
+    <td valign="top">Whether to reevaluate the set every time the set
       is used.  Default is &quot;<code>true</code>&quot;.</td>
     <td valign="top" align="center">No</td>
   </tr>
   <tr>
     <td valign="top">negate</td>
     <td valign="top">Whether to negate results. If
       &quot;<code>true</code>&quot;, all properties <i>not</i>
       selected by nested elements will be returned. Default is
       &quot;<code>false</code>&quot;. <em>Since Ant 1.6.2</em>
     </td>
     <td valign="top" align="center">No</td>
   </tr>
 </table>
 <h3>Parameters specified as nested elements</h3>
 
 <h4>propertyref</h4>
 
 <p>Selects properties from the current project to be included in the
 set.</p>
 
 <table border="1" cellpadding="2" cellspacing="0">
   <tr>
     <td valign="top"><b>Attribute</b></td>
     <td valign="top"><b>Description</b></td>
     <td align="center" valign="top"><b>Required</b></td>
   </tr>
   <tr>
     <td valign="top">name</td>
     <td valign="top">Select the property with the given name.</td>
     <td align="center" valign="top" rowspan="4">Exactly one of these.</td>
   </tr>
   <tr>
     <td valign="top">prefix</td>
     <td valign="top">Select the properties whose name starts with the
       given string.</td>
   </tr>
   <tr>
     <td valign="top">regex</td>
     <td valign="top">Select the properties that match the given
       regular expression.  Similar to <a
       href="mapper.html#regexp-mapper">regexp type mappers</a>, this
       requires a supported regular expression library.</td>
   </tr>
   <tr>
     <td valign="top">builtin</td>
     <td valign="top">Selects a builtin set of properties.  Valid
       values for this attribute are <code>all</code> for all Ant
       properties, <code>system</code> for the system properties and
       <code>commandline</code> for all properties specified on the
       command line when invoking Ant (plus a number of special
       internal Ant properties).</td>
   </tr>
 </table>
 
 <h4>propertyset</h4>
 
 <p>A <code>propertyset</code> can be used as the set union of more
 <code>propertyset</code>s.</p>
 
 <p>For example:</p>
 
 <blockquote><pre>
 &lt;propertyset id=&quot;properties-starting-with-foo&quot;&gt;
   &lt;propertyref prefix=&quot;foo&quot;/&gt;
 &lt;/propertyset&gt;
 &lt;propertyset id=&quot;properties-starting-with-bar&quot;&gt;
   &lt;propertyref prefix=&quot;bar&quot;/&gt;
 &lt;/propertyset&gt;
 &lt;propertyset id=&quot;my-set&quot;&gt;
   &lt;propertyset refid=&quot;properties-starting-with-foo&quot;/&gt;
   &lt;propertyset refid=&quot;properties-starting-with-bar&quot;/&gt;
 &lt;/propertyset&gt;
 </pre></blockquote>
 
 <p>collects all properties whose name starts with either
 &quot;foo&quot; or &quot;bar&quot; in the set named
 &quot;my-set&quot;.</p>
 
 <h4>mapper</h4>
 
 <p>A <a href="mapper.html">mapper</a> - at maximum one mapper can be
 specified.  The mapper is used to change the names of the property
 keys, for example:
 
 <blockquote><pre>
 &lt;propertyset id=&quot;properties-starting-with-foo&quot;&gt;
   &lt;propertyref prefix=&quot;foo&quot;/&gt;
   &lt;mapper type=&quot;glob&quot; from=&quot;foo*&quot; to=&quot;bar*&quot;/&gt;
 &lt;/propertyset&gt;
 </pre></blockquote>
 
 <p>collects all properties whose name starts with &quot;foo&quot;, but
 changes the names to start with &quot;bar&quot; instead.</p>
 
 <p>If supplied, the nested mapper will be applied
 subsequent to any negation of matched properties.</p>
 
 
 
 </body>
 </html>
 
diff --git a/manual/Types/selectors.html b/manual/Types/selectors.html
index 0c75d4ac9..560b416c7 100644
--- a/manual/Types/selectors.html
+++ b/manual/Types/selectors.html
@@ -1,1566 +1,1566 @@
 <!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 -->
 <html>
   <head>
     <meta http-equiv="Content-Language" content="en-us">
     <link rel="stylesheet" type="text/css" href="../stylesheets/style.css">
     <title>Selectors in Apache Ant</title>
   </head>
 
   <body>
     <h2>Selectors</h2>
 
     <p>Selectors are a mechanism whereby the files that make up a
     <code>&lt;fileset&gt;</code> can be selected based on criteria
     other than filename as provided by the <code>&lt;include&gt;</code>
     and <code>&lt;exclude&gt;</code> tags.</p>
 
     <h3>How to use a Selector</h3>
 
     <p>A selector is an element of FileSet, and appears within it. It can
     also be defined outside of any target by using the <code>&lt;selector&gt;</code> tag
     and then using it as a reference.
     </p>
 
     <p>Different selectors have different attributes. Some selectors can
     contain other selectors, and these are called
     <a href="#selectcontainers"><code>Selector Containers</code></a>.
     There is also a category of selectors that allow
     user-defined extensions, called
     <a href="#customselect"><code>Custom Selectors</code></a>.
     The ones built in to Apache Ant are called
     <a href="#coreselect"><code>Core Selectors</code></a>.
     </p>
 
     <h3><a name="coreselect">Core Selectors</a></h3>
 
     <p>Core selectors are the ones that come standard
     with Ant. They can be used within a fileset and can be contained
     within Selector Containers.</p>
 
     <p>The core selectors are:</p>
 
     <ul>
       <li><a href="#containsselect"><code>&lt;contains&gt;</code></a> - Select
         files that contain a particular text string</li>
       <li><a href="#dateselect"><code>&lt;date&gt;</code></a> - Select files
         that have been modified either before or after a particular date
         and time</li>
       <li><a href="#dependselect"><code>&lt;depend&gt;</code></a> - Select files
         that have been modified more recently than equivalent files
         elsewhere</li>
       <li><a href="#depthselect"><code>&lt;depth&gt;</code></a> - Select files
         that appear so many directories down in a directory tree</li>
       <li><a href="#differentselect"><code>&lt;different&gt;</code></a> - Select files
         that are different from those elsewhere</li>
       <li><a href="#filenameselect"><code>&lt;filename&gt;</code></a> - Select
         files whose name matches a particular pattern. Equivalent to
         the include and exclude elements of a patternset.</li>
       <li><a href="#presentselect"><code>&lt;present&gt;</code></a> - Select
         files that either do or do not exist in some other location</li>
       <li><a href="#regexpselect"><code>&lt;containsregexp&gt;</code></a> - Select
         files that match a regular expression</li>
       <li><a href="#sizeselect"><code>&lt;size&gt;</code></a> - Select files
         that are larger or smaller than a particular number of bytes.</li>
       <li><a href="#typeselect"><code>&lt;type&gt;</code></a> - Select files
         that are either regular files or directories.</li>
       <li><a href="#modified"><code>&lt;modified&gt;</code></a> - Select files if
         the return value of the configured algorithm is different from that
         stored in a cache.</li>
       <li><a href="#signedselector"><code>&lt;signedselector&gt;</code></a> - Select files if
         they are signed, and optionally if they have a signature of a certain name.
       </li>
       <li><a href="#scriptselector"><code>&lt;scriptselector&gt;</code></a> - 
         Use a BSF or JSR 223 scripting language to create
         your own selector
       </li>
       <li><a href="#readable"><code>&lt;readable&gt;</code></a> -
         Select files if they are readable.</li>
       <li><a href="#writable"><code>&lt;writable&gt;</code></a> -
         Select files if they are writable.</li>
     </ul>
 
     <h4><a name="containsselect">Contains Selector</a></h4>
 
     <p>The <code>&lt;contains&gt;</code> tag in a FileSet limits
     the files defined by that fileset to only those which contain the
     string specified by the <code>text</code> attribute.
     .</p>
     <p>The <code>&lt;contains&gt;</code> selector can be used as a
       ResourceSelector (see the
       <a href="resources.html#restrict">&lt;restrict&gt;</a>
       ResourceCollection).</p>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr>
         <td valign="top"><b>Attribute</b></td>
         <td valign="top"><b>Description</b></td>
         <td align="center" valign="top"><b>Required</b></td>
       </tr>
       <tr>
         <td valign="top">text</td>
         <td valign="top">Specifies the text that every file must contain
         </td>
         <td valign="top" align="center">Yes</td>
       </tr>
       <tr>
         <td valign="top">casesensitive</td>
         <td valign="top">Whether to pay attention to case when looking
           for the string in the <code>text</code> attribute. Default is
           true.
         </td>
         <td valign="top" align="center">No</td>
       </tr>
       <tr>
         <td valign="top">ignorewhitespace</td>
         <td valign="top">Whether to eliminate whitespace before checking
           for the string in the <code>text</code> attribute. Default is
           false.
         </td>
         <td valign="top" align="center">No</td>
       </tr>
         <tr>
             <td valign="top">encoding</td>
             <td valign="top">Encoding of the resources being selected.
                 Required in practice if the encoding of the files being
                 selected is different from the default encoding of the JVM
                 where Ant is running.
                 Since Ant 1.9.0
             </td>
             <td valign="top" align="center">No</td>
         </tr>
     </table>
 
     <p>Here is an example of how to use the Contains Selector:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${doc.path}&quot; includes=&quot;**/*.html&quot;&gt;
     &lt;contains text=&quot;script&quot; casesensitive=&quot;no&quot;/&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Selects all the HTML files that contain the string
     <code>script</code>.</p>
 
 
     <h4><a name="dateselect">Date Selector</a></h4>
 
     <p>The <code>&lt;date&gt;</code> tag in a FileSet will put
     a limit on the files specified by the include tag, so that tags
     whose last modified date does not meet the date limits specified
     by the selector will not end up being selected.</p>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr>
         <td valign="top"><b>Attribute</b></td>
         <td valign="top"><b>Description</b></td>
         <td align="center" valign="top"><b>Required</b></td>
       </tr>
       <tr>
         <td valign="top">datetime</td>
         <td valign="top">Specifies the date and time to test for.
           Should be in the format MM/DD/YYYY HH:MM AM_or_PM, or
           an alternative pattern specified via the <i>pattern</i>
           attribute.
         </td>
         <td valign="top" align="center" rowspan="2">At least one of the two.</td>
       </tr>
       <tr>
         <td valign="top">millis</td>
         <td valign="top">The number of milliseconds since 1970 that should
           be tested for. It is usually much easier to use the datetime
           attribute.
         </td>
       </tr>
       <tr>
         <td valign="top">when</td>
         <td valign="top">Indicates how to interpret the date, whether
           the files to be selected are those whose last modified times should
           be before, after, or equal to the specified value. Acceptable
           values for this attribute are:
           <ul>
             <li>before - select files whose last modified date is before the indicated date
             <li>after - select files whose last modified date is after the indicated date
             <li>equal - select files  whose last modified date is this exact date
           </ul>
           The default is equal.
         <td valign="top" align="center">No</td>
       </tr>
       <tr>
         <td valign="top">granularity</td>
         <td valign="top">The number of milliseconds leeway to use when
           comparing file modification times. This is needed because not every
           file system supports tracking the last modified time to the
           millisecond level. Default is 0 milliseconds, or 2 seconds on DOS systems.
         </td>
         <td valign="top" align="center">No</td>
       </tr>
       <tr>
         <td valign="top">pattern</td>
         <td valign="top">The <CODE>SimpleDateFormat</CODE>-compatible pattern
           to use when interpreting the <i>datetime</i> attribute.
           <i>Since Ant 1.6.2</i>
         </td>
         <td valign="top" align="center">No</td>
       </tr>
       <tr>
         <td valign="top">checkdirs</td>
         <td valign="top">
           Indicates whether or not to check dates on directories.
         </td>
         <td valign="top" align="center">No, defaults to <i>false</i></td>
       </tr>
     </table>
 
     <p>Here is an example of how to use the Date Selector:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${jar.path}&quot; includes=&quot;**/*.jar&quot;&gt;
     &lt;date datetime=&quot;01/01/2001 12:00 AM&quot; when=&quot;before&quot;/&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Selects all JAR files which were last modified before midnight
     January 1, 2001.</p>
 
 
     <h4><a name="dependselect">Depend Selector</a></h4>
 
     <p>The <code>&lt;depend&gt;</code> tag selects files
     whose last modified date is later than another, equivalent file in
     another location.</p>
 
     <p>The <code>&lt;depend&gt;</code> tag supports the use of a
     contained <a href="mapper.html"><code>&lt;mapper&gt;</code></a> element
     to define the location of the file to be compared against. If no
     <code>&lt;mapper&gt;</code> element is specified, the
     <code>identity</code> type mapper is used.</p>
 
     <p>The <code>&lt;depend&gt;</code> selector is case-sensitive.</p>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr>
         <td valign="top"><b>Attribute</b></td>
         <td valign="top"><b>Description</b></td>
         <td align="center" valign="top"><b>Required</b></td>
       </tr>
       <tr>
         <td valign="top">targetdir</td>
         <td valign="top">The base directory to look for the files to compare
           against. The precise location depends on a combination of this
           attribute and the <code>&lt;mapper&gt;</code> element, if any.
         </td>
         <td valign="top" align="center">Yes</td>
       </tr>
       <tr>
         <td valign="top">granularity</td>
         <td valign="top">The number of milliseconds leeway to give before
           deciding a file is out of date. This is needed because not every
           file system supports tracking the last modified time to the
           millisecond level. Default is 0 milliseconds, or 2 seconds on DOS systems.
         </td>
         <td valign="top" align="center">No</td>
       </tr>
     </table>
 
     <p>Here is an example of how to use the Depend Selector:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${ant.1.5}/src/main&quot; includes=&quot;**/*.java&quot;&gt;
     &lt;depend targetdir=&quot;${ant.1.4.1}/src/main&quot;/&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Selects all the Java source files which were modified in the
       1.5 release.
     </p>
 
 
     <h4><a name="depthselect">Depth Selector</a></h4>
 
     <p>The <code>&lt;depth&gt;</code> tag selects files based on
     how many directory levels deep they are in relation to the base
     directory of the fileset.
     </p>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr>
         <td valign="top"><b>Attribute</b></td>
         <td valign="top"><b>Description</b></td>
         <td align="center" valign="top"><b>Required</b></td>
       </tr>
       <tr>
         <td valign="top">min</td>
         <td valign="top">The minimum number of directory levels below
           the base directory that a file must be in order to be selected.
           Default is no limit.
         </td>
         <td valign="top" align="center" rowspan="2">At least one of the two.</td>
       </tr>
       <tr>
         <td valign="top">max</td>
         <td valign="top">The maximum number of directory levels below
           the base directory that a file can be and still be selected.
           Default is no limit.
         </td>
       </tr>
     </table>
 
     <p>Here is an example of how to use the Depth Selector:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${doc.path}&quot; includes=&quot;**/*&quot;&gt;
     &lt;depth max=&quot;1&quot;/&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Selects all files in the base directory and one directory below
     that.</p>
 
     
     <h4><a name="differentselect">Different Selector</a></h4>
 
     <p>The <code>&lt;different&gt;</code> selector will select a file
     if it is deemed to be 'different' from an equivalent file in
     another location. The rules for determining difference between
     the two files are as follows:
     <ol>
     <li>If a file is only present in the resource collection you apply
       the selector to but not in targetdir (or after applying the
       mapper) the file is selected.
     <li>If a file is only present in targetdir (or after applying the
       mapper) it is ignored.
     <li> Files with different lengths are different.
     <li> If <tt>ignoreFileTimes</tt> is turned off, then differing file
     timestamps will cause files to be regarded as different.
     <li> Unless <tt>ignoreContents</tt> is set to true,
          a byte-for-byte check is run against the two files.
     </ol>
 
     This is a useful selector to work with programs and tasks that don't handle
     dependency checking properly; even if a predecessor task always creates its
     output files, followup tasks can be driven off copies made with a different
     selector, so their dependencies are driven on the absolute state of the
     files, not just a timestamp. For example: anything fetched from a web site,
     or the output of some program. To reduce the amount of checking, when using
     this task inside a <code>&lt;copy&gt;</code> task, set
     <tt>preservelastmodified</tt> to <i>true</i> to propagate the timestamp
     from the source file to the destination file.<p>
 
     The <code>&lt;different&gt;</code> selector supports the use of a
     contained <a href="mapper.html"><code>&lt;mapper&gt;</code></a> element
     to define the location of the file to be compared against. If no
     <code>&lt;mapper&gt;</code> element is specified, the
     <code>identity</code> type mapper is used.</p>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr>
         <td valign="top"><b>Attribute</b></td>
         <td valign="top"><b>Description</b></td>
         <td align="center" valign="top"><b>Required</b></td>
       </tr>
       <tr>
         <td valign="top">targetdir</td>
         <td valign="top">The base directory to look for the files to compare
           against. The precise location depends on a combination of this
           attribute and the <code>&lt;mapper&gt;</code> element, if any.
         </td>
         <td valign="top" align="center">Yes</td>
       </tr>
       <tr>
         <td valign="top">ignoreFileTimes</td>
         <td valign="top">Whether to use file times in the comparison or not.
           Default is true (time differences are ignored).
         </td>
         <td valign="top" align="center">No</td>
       </tr>
       <tr>
         <td valign="top">ignoreContents</td>
         <td valign="top">Whether to do a byte per byte compare.
           Default is false (contents are compared).
           Since Ant 1.6.3
         </td>
         <td valign="top" align="center">No</td>
       </tr>
       <tr>
         <td valign="top">granularity</td>
         <td valign="top">The number of milliseconds leeway to give before
           deciding a file is out of date. This is needed because not every
           file system supports tracking the last modified time to the
           millisecond level. Default is 0 milliseconds, or 2 seconds on DOS systems.
         </td>
         <td valign="top" align="center">No</td>
       </tr>
     </table>
 
     <p>Here is an example of how to use the Different Selector:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${ant.1.5}/src/main&quot; includes=&quot;**/*.java&quot;&gt;
     &lt;different targetdir=&quot;${ant.1.4.1}/src/main&quot;
         ignoreFileTimes="true"/&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Compares all the Java source files between the 1.4.1 and the 1.5 release
     and selects those who are different, disregarding file times.
     </p>
 
     <h4><a name="filenameselect">Filename Selector</a></h4>
 
     <p>The <code>&lt;filename&gt;</code> tag acts like the
     <code>&lt;include&gt;</code> and <code>&lt;exclude&gt;</code>
     tags within a fileset. By using a selector instead, however,
     one can combine it with all the other selectors using whatever
     <a href="#selectcontainers">selector container</a> is desired.
     </p>
 
     <p>The <code>&lt;filename&gt;</code> selector is
     case-sensitive.</p>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr>
         <td valign="top"><b>Attribute</b></td>
         <td valign="top"><b>Description</b></td>
         <td align="center" valign="top"><b>Required</b></td>
       </tr>
       <tr>
         <td valign="top">name</td>
         <td valign="top">The name of files to select. The name parameter
           can contain the standard Ant wildcard characters.
         </td>
         <td valign="top" align="center" rowspan="2">Exactly one of
           the two</td>
       </tr>
       <tr>
         <td valign="top">regex</td>
         <td valign="top">The regular expression matching files to select.</td>
       </tr>
       <tr>
         <td valign="top">casesensitive</td>
         <td valign="top">Whether to pay attention to case when looking
           at file names. Default is "true".
         </td>
         <td valign="top" align="center">No</td>
       </tr>
       <tr>
         <td valign="top">negate</td>
         <td valign="top">Whether to reverse the effects of this filename
           selection, therefore emulating an exclude rather than include
           tag. Default is "false".
         </td>
         <td valign="top" align="center">No</td>
       </tr>
     </table>
 
     <p>Here is an example of how to use the Filename Selector:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${doc.path}&quot; includes=&quot;**/*&quot;&gt;
     &lt;filename name=&quot;**/*.css&quot;/&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Selects all the cascading style sheet files.</p>
 
 
     <h4><a name="presentselect">Present Selector</a></h4>
 
     <p>The <code>&lt;present&gt;</code> tag selects files
     that have an equivalent file in another directory tree.</p>
 
     <p>The <code>&lt;present&gt;</code> tag supports the use of a
     contained <a href="mapper.html"><code>&lt;mapper&gt;</code></a> element
     to define the location of the file to be tested against. If no
     <code>&lt;mapper&gt;</code> element is specified, the
     <code>identity</code> type mapper is used.</p>
 
     <p>The <code>&lt;present&gt;</code> selector is case-sensitive.</p>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr>
         <td valign="top"><b>Attribute</b></td>
         <td valign="top"><b>Description</b></td>
         <td align="center" valign="top"><b>Required</b></td>
       </tr>
       <tr>
         <td valign="top">targetdir</td>
         <td valign="top">The base directory to look for the files to compare
           against. The precise location depends on a combination of this
           attribute and the <code>&lt;mapper&gt;</code> element, if any.
         </td>
         <td valign="top" align="center">Yes</td>
       </tr>
       <tr>
         <td valign="top">present</td>
         <td valign="top">Whether we are requiring that a file is present in
           the src directory tree only, or in both the src and the target
           directory tree. Valid values are:
           <ul>
             <li>srconly - select files only if they are in the src
               directory tree but not in the target directory tree
             <li>both - select files only if they are present both in the
               src and target directory trees
           </ul>
           Default is both. Setting this attribute to &quot;srconly&quot;
           is equivalent to wrapping the selector in the <code>&lt;not&gt;</code>
           selector container.
         </td>
         <td valign="top" align="center">No</td>
       </tr>
     </table>
 
     <p>Here is an example of how to use the Present Selector:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${ant.1.5}/src/main&quot; includes=&quot;**/*.java&quot;&gt;
     &lt;present present=&quot;srconly&quot; targetdir=&quot;${ant.1.4.1}/src/main&quot;/&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Selects all the Java source files which are new in the
       1.5 release.
     </p>
 
     <h4><a name="regexpselect">Regular Expression Selector</a></h4>
 
     <p>The <code>&lt;containsregexp&gt;</code> tag in a FileSet limits
     the files defined by that fileset to only those which contents contain a
     match to the regular expression specified by the <code>expression</code> attribute.
     </p>
     <p>The <code>&lt;containsregexp&gt;</code> selector can be used as a
       ResourceSelector (see the
       <a href="resources.html#restrict">&lt;restrict&gt;</a>
       ResourceCollection).</p>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr>
         <td valign="top"><b>Attribute</b></td>
         <td valign="top"><b>Description</b></td>
         <td align="center" valign="top"><b>Required</b></td>
       </tr>
       <tr>
         <td valign="top">expression</td>
         <td valign="top">Specifies the regular expression that must
         match true in every file</td>
         <td valign="top" align="center">Yes</td>
       </tr>
       <tr>
         <td valign="top">casesensitive</td>
         <td valign="top">Perform a case sensitive match.  Default is
           true. <em>since Ant 1.8.2</em></td>
         <td valign="top" align="center">No</td>
       </tr>
       <tr>
         <td valign="top">multiline</td>
         <td valign="top">
           Perform a multi line match.
           Default is false. <em>since Ant 1.8.2</em></td>
         <td valign="top" align="center">No</td>
       </tr>
       <tr>
         <td valign="top">singleline</td>
         <td valign="top">
           This allows '.' to match new lines.
           SingleLine is not to be confused with multiline, SingleLine is a perl
           regex term, it corresponds to dotall in java regex.
           Default is false. <em>since Ant 1.8.2</em></td>
         <td valign="top" align="center">No</td>
       </tr>
     </table>
 
     <p>Here is an example of how to use the regular expression Selector:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${doc.path}&quot; includes=&quot;*.txt&quot;&gt;
     &lt;containsregexp expression=&quot;[4-6]\.[0-9]&quot;/&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Selects all the text files that match the regular expression
     (have a 4,5 or 6 followed by a period and a number from 0 to 9).
 
 
     <h4><a name="sizeselect">Size Selector</a></h4>
 
     <p>The <code>&lt;size&gt;</code> tag in a FileSet will put
     a limit on the files specified by the include tag, so that tags
     which do not meet the size limits specified by the selector will not
     end up being selected.</p>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr>
         <td valign="top"><b>Attribute</b></td>
         <td valign="top"><b>Description</b></td>
         <td align="center" valign="top"><b>Required</b></td>
       </tr>
       <tr>
         <td valign="top">value</td>
         <td valign="top">The size of the file which should be tested for.
         </td>
         <td valign="top" align="center">Yes</td>
       </tr>
       <tr>
         <td valign="top">units</td>
         <td valign="top">The units that the <code>value</code> attribute
           is expressed in. When using the standard single letter SI
           designations, such as &quot;k&quot;,&quot;M&quot;, or
           &quot;G&quot;, multiples of 1000 are used. If you want to use
           power of 2 units, use the IEC standard: &quot;Ki&quot; for 1024,
           &quot;Mi&quot; for 1048576, and so on. The default is no units,
           which means the <code>value</code> attribute expresses the exact
           number of bytes.
         </td>
         <td valign="top" align="center">No</td>
       </tr>
       <tr>
         <td valign="top">when</td>
         <td valign="top">Indicates how to interpret the size, whether
           the files to be selected should be larger, smaller, or equal to
           that value. Acceptable values for this attribute are:
           <ul>
             <li>less - select files less than the indicated size
             <li>more - select files greater than the indicated size
             <li>equal - select files this exact size
           </ul>
           The default is equal.
         <td valign="top" align="center">No</td>
       </tr>
     </table>
 
     <p>Here is an example of how to use the Size Selector:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${jar.path}&quot;&gt;
   &lt;patternset&gt;
     &lt;include name=&quot;**/*.jar&quot;/&gt;
   &lt;/patternset&gt;
   &lt;size value=&quot;4&quot; units=&quot;Ki&quot; when=&quot;more&quot;/&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Selects all JAR files that are larger than 4096 bytes.</p>
 
     <h4><a name="typeselect">Type Selector</a></h4>
 
     <p>The <code>&lt;type&gt;</code> tag selects files of a certain type:
     directory or regular.</p>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr>
         <td valign="top"><b>Attribute</b></td>
         <td valign="top"><b>Description</b></td>
         <td align="center" valign="top"><b>Required</b></td>
       </tr>
       <tr>
         <td valign="top">type</td>
         <td valign="top">The type of file which should be tested for.
             Acceptable values are:
             <ul>
                 <li>file - regular files</li>
                 <li>dir - directories</li>
             </ul>
         </td>
         <td valign="top" align="center">Yes</td>
       </tr>
     </table>
 
     <p>Here is an example of how to use the Type Selector to select only
     directories in <code>${src}</code></p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${src}&quot;&gt;
   &lt;type type="dir"/&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>The Type Selector is often used in conjunction with other selectors.
     For example, to select files that also exist in a <code>template</code>
     directory, but avoid selecting empty directories, use:
 
 <blockquote><pre>
 &lt;fileset dir="${src}"&gt;
     &lt;and&gt;
         &lt;present targetdir="template"/&gt;
         &lt;type type="file"/&gt;
     &lt;/and&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
 
     <h4><a name="modified">Modified Selector</a></h4>
     <p>The <code>&lt;modified&gt;</code> selector computes a value for a file, compares that
     to the value stored in a cache and select the file, if these two values
     differ.</p>
     <p>Because this selector is highly configurable the order in which the selection is done
     is: <ol>
         <li> get the absolute path for the file </li>
         <li> get the cached value from the configured cache (absolute path as key) </li>
         <li> get the new value from the configured algorithm </li>
         <li> compare these two values with the configured comparator </li>
         <li> update the cache if needed and requested </li>
         <li> do the selection according to the comparison result </li>
         </ol>
     <p>The comparison, computing of the hashvalue and the store is done by implementation
     of special interfaces. Therefore they may provide additional parameters.</p>
 
     <p>The <code>&lt;modified&gt;</code> selector can be used as a
       ResourceSelector (see the
       <a href="resources.html#restrict">&lt;restrict&gt;</a>
       ResourceCollection).
     In that case it maps simple file resources to files and does its job. If the
     resource is from another type, the <code>&lt;modified&gt;</code> selector tries
     to (<b>attention!</b>) copy the content into a local file for computing the
     hashvalue.</p>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr>
         <td valign="top"><b>Attribute</b></td>
         <td valign="top"><b>Description</b></td>
         <td align="center" valign="top"><b>Required</b></td>
       </tr>
       <tr>
         <td valign="top"> algorithm </td>
         <td valign="top"> The type of algorithm should be used.
             Acceptable values are (further information see later):
             <ul>
                 <li> hashvalue - HashvalueAlgorithm </li>
                 <li> digest - DigestAlgorithm </li>
                 <li> checksum - ChecksumAlgorithm </li>
             </ul>
         </td>
         <td valign="top" align="center"> No, defaults to <i>digest</i> </td>
       </tr>
       <tr>
         <td valign="top"> cache </td>
         <td valign="top"> The type of cache should be used.
             Acceptable values are (further information see later):
             <ul>
                 <li> propertyfile - PropertyfileCache </li>
             </ul>
         </td>
         <td valign="top" align="center"> No, defaults to <i>propertyfile</i> </td>
       </tr>
       <tr>
         <td valign="top"> comparator </td>
         <td valign="top"> The type of comparator should be used.
             Acceptable values are (further information see later):
             <ul>
                 <li> equal - EqualComparator </li>
                 <li> rule - java.text.RuleBasedCollator
                   <!-- NOTE -->
                   <i>(see <a href="#ModSelNote">note</a> for restrictions)</i>
                 </li>
             </ul>
         </td>
         <td valign="top" align="center"> No, defaults to <i>equal</i> </td>
       </tr>
       <tr>
         <td valign="top"> algorithmclass </td>
         <td valign="top"> Classname of custom algorithm implementation. Lower
           priority than <i>algorithm</i>. </td>
         <td valign="top" align="center"> No </td>
       </tr>
       <tr>
         <td valign="top"> cacheclass </td>
         <td valign="top"> Classname of custom cache implementation. Lower
           priority than <i>cache</i>. </td>
         <td valign="top" align="center"> No </td>
       </tr>
       <tr>
         <td valign="top"> comparatorclass </td>
         <td valign="top"> Classname of custom comparator implementation. Lower
           priority than <i>comparator</i>. </td>
         <td valign="top" align="center"> No </td>
       </tr>
       <tr>
         <td valign="top"> update </td>
         <td valign="top"> Should the cache be updated when values differ? (boolean) </td>
         <td valign="top" align="center"> No, defaults to <i>true</i> </td>
       </tr>
       <tr>
         <td valign="top"> seldirs </td>
         <td valign="top"> Should directories be selected? (boolean) </td>
         <td valign="top" align="center"> No, defaults to <i>true</i> </td>
       </tr>
       <tr>
         <td valign="top"> selres </td>
         <td valign="top"> Should Resources without an InputStream, and
            therefore without checking, be selected?  (boolean) </td>
         <td valign="top" align="center"> No, defaults to <i>true</i>. Only relevant
            when used as ResourceSelector. </td>
       </tr>
       <tr>
         <td valign="top"> delayupdate </td>
         <td valign="top"> If set to <i>true</i>, the storage of the cache will be delayed until the
              next finished BuildEvent; task finished, target finished or build finished,
              whichever comes first.  This is provided for increased performance.  If set
              to <i>false</i>, the storage of the cache will happen with each change.  This
              attribute depends upon the <i>update</i> attribute. (boolean)</td>
         <td valign="top" align="center"> No, defaults to <i>true</i> </td>
       </tr>
     </table>
 
     <p>These attributes can be set with nested <code>&lt;param/&gt;</code> tags. With <code>&lt;param/&gt;</code>
     tags you can set other values too - as long as they are named according to
     the following rules: <ul>
         <li> <b> algorithm </b>: same as attribute algorithm </li>
         <li> <b> cache </b>: same as attribute cache </li>
         <li> <b> comparator </b>: same as attribute comparator </li>
         <li> <b> algorithmclass </b>: same as attribute algorithmclass </li>
         <li> <b> cacheclass </b>: same as attribute cacheclass </li>
         <li> <b> comparatorclass </b>: same as attribute comparatorclass </li>
         <li> <b> update </b>: same as attribute update </li>
         <li> <b> seldirs </b>: same as attribute seldirs </li>
         <li> <b> algorithm.* </b>: Value is transferred to the algorithm via its
                                    <i>set</i>XX-methods </li>
-        <li> <b> cache.* </b>: Value is transfered to the cache via its
+        <li> <b> cache.* </b>: Value is transferred to the cache via its
                                    <i>set</i>XX-methods </li>
-        <li> <b> comparator.* </b>: Value is transfered to the comparator via its
+        <li> <b> comparator.* </b>: Value is transferred to the comparator via its
                                    <i>set</i>XX-methods </li>
     </ul>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr><td colspan="2"><font size="+1"><b> Algorithm options</b></font></td></tr>
       <tr>
         <td valign="top"><b>Name</b></td>
         <td valign="top"><b>Description</b></td>
       </tr>
       <tr>
         <td valign="top"> hashvalue </td>
         <td valign="top"> Reads the content of a file into a java.lang.String
           and use thats hashValue(). No additional configuration required.
         </td>
       </tr>
       <tr>
         <td valign="top"> digest </td>
         <td valign="top"> Uses java.security.MessageDigest. This Algorithm supports
           the following attributes:
           <ul>
             <li><i>algorithm.algorithm</i> (optional): Name of the Digest algorithm
                 (e.g. 'MD5' or 'SHA', default = <i>MD5</i>) </li>
             <li><i>algorithm.provider</i> (optional): Name of the Digest provider
                 (default = <i>null</i>) </li>
           </ul>
         </td>
       </tr>
       <tr>
         <td valign="top"> checksum </td>
         <td valign="top"> Uses java.util.zip.Checksum. This Algorithm supports
           the following attributes:
           <ul>
             <li><i>algorithm.algorithm</i> (optional): Name of the algorithm
                 (e.g. 'CRC' or 'ADLER', default = <i>CRC</i>) </li>
           </ul>
         </td>
       </tr>
       <tr><td colspan="2"><font size="+1"><b> Cache options </b></font></td></tr>
       <tr>
         <td valign="top"> propertyfile </td>
         <td valign="top"> Use the java.util.Properties class and its possibility
           to load and store to file.
           This Cache implementation supports the following attributes:
           <ul>
             <li><i>cache.cachefile</i> (optional): Name of the properties-file
                 (default = <i>cache.properties</i>) </li>
           </ul>
         </td>
       </tr>
       <tr><td colspan="2"><font size="+1"><b> Comparator options</b></font></td></tr>
       <tr>
         <td valign="top"> equal </td>
         <td valign="top"> Very simple object comparison. </td>
       </tr>
       <tr>
         <td valign="top"> rule </td>
         <td valign="top"> Uses <i>java.text.RuleBasedCollator</i> for Object
           comparison.
           <!-- NOTE -->
           <i>(see <a href="#ModSelNote">note</a> for restrictions)</i>
         </td>
       </tr>
     </table>
 
     <p>The <code>&lt;modified&gt;</code> selector supports a nested
     <code>&lt;classpath&gt;</code> element that represents a <a href="../using.html#path">
     PATH like structure</a> for finding custom interface implementations. </p>
 
     <p>Here are some examples of how to use the Modified Selector:</p>
 
     <blockquote><pre>
     &lt;copy todir="dest"&gt;
         &lt;fileset dir="src"&gt;
             &lt;modified/&gt;
         &lt;/fileset&gt;
     &lt;/copy&gt;
     </pre></blockquote>
     <p>This will copy all files from <i>src</i> to <i>dest</i> which content has changed.
     Using an updating PropertyfileCache with cache.properties and
     MD5-DigestAlgorithm.</p>
 
     <blockquote><pre>
     &lt;copy todir="dest"&gt;
         &lt;fileset dir="src"&gt;
             &lt;modified update="true"
                       seldirs="true"
                       cache="propertyfile"
                       algorithm="digest"
                       comparator="equal"&gt;
                 &lt;param name="cache.cachefile"     value="cache.properties"/&gt;
                 &lt;param name="algorithm.algorithm" value="MD5"/&gt;
             &lt;/modified&gt;
         &lt;/fileset&gt;
     &lt;/copy&gt;
     </pre></blockquote>
   <p>This is the same example rewritten as CoreSelector with setting the all the values
   (same as defaults are).</p>
 
     <blockquote><pre>
     &lt;copy todir="dest"&gt;
         &lt;fileset dir="src"&gt;
             &lt;custom class="org.apache.tools.ant.types.selectors.modifiedselector.ModifiedSelector"&gt;
                 &lt;param name="update"     value="true"/&gt;
                 &lt;param name="seldirs"    value="true"/&gt;
                 &lt;param name="cache"      value="propertyfile"/&gt;
                 &lt;param name="algorithm"  value="digest"/&gt;
                 &lt;param name="comparator" value="equal"/&gt;
                 &lt;param name="cache.cachefile"     value="cache.properties"/&gt;
                 &lt;param name="algorithm.algorithm" value="MD5"/&gt;
             &lt;/custom&gt;
         &lt;/fileset&gt;
     &lt;/copy&gt;
     </pre></blockquote>
   <p>And this is the same rewritten as CustomSelector.</p>
 
     <blockquote><pre>
   &lt;target name="generate-and-upload-site"&gt;
       &lt;echo&gt; generate the site using forrest &lt;/echo&gt;
       &lt;antcall target="site"/&gt;
 
       &lt;echo&gt; upload the changed file &lt;/echo&gt;
       &lt;ftp server="${ftp.server}" userid="${ftp.user}" password="${ftp.pwd}"&gt;
           &lt;fileset dir="htdocs/manual"&gt;
               &lt;modified/&gt;
           &lt;/fileset&gt;
       &lt;/ftp&gt;
   &lt;/target&gt;
     </pre></blockquote>
   <p>A useful scenario for this selector inside a build environment
   for homepage generation (e.g. with <a href="http://xml.apache.org/forrest/">
   Apache Forrest</a>). Here all <b>changed</b> files are uploaded to the server. The
   CacheSelector saves therefore much upload time.</p>
 
     <blockquote><pre>
   &lt;modified cacheclassname="com.mycompany.MyCache"&gt;
       &lt;classpath&gt;
           &lt;pathelement location="lib/mycompany-antutil.jar"/&gt;
       &lt;/classpath&gt;
   &lt;/modified&gt;
     </pre></blockquote>
     <p>Uses <tt>com.mycompany.MyCache</tt> from a jar outside of Ants own classpath
     as cache implementation</p>
 
   <h4><a name="ModSelNote">Note on RuleBasedCollator</a></h4>
   <p>The RuleBasedCollator needs a format for its work, but its needed while
   instantiation. There is a problem in the initialization algorithm for this
   case. Therefore you should not use this (or tell me the workaround :-).</p>
 
       <h4><a name="signedselector">Signed Selector</a></h4>
 
       <p>
         The <code>&lt;signedselector&gt;</code> tag selects signed files and optionally
         signed with a certain name.
       </p>
       <p>
         This selector has been added in Apache Ant 1.7.
       </p>
       <table border="1" cellpadding="2" cellspacing="0">
         <tr>
           <td valign="top"><b>Attribute</b></td>
           <td valign="top"><b>Description</b></td>
           <td align="center" valign="top"><b>Required</b></td>
         </tr>
         <tr>
           <td valign="top">name</td>
           <td valign="top"> The signature name to check for.</td>
           <td valign="top" align="center">no</td>
         </tr>
       </table>
 
       <h4><a name="readable">Readable Selector</a></h4>
 
       <p>The <code>&lt;readable&gt;</code> selector selects only files
         that are readable.  Ant only invokes
         <code>java.io.File#canRead</code> so if a file is unreadable
         but the Java VM cannot detect this state, this selector will
         still select the file.</p>
 
       <h4><a name="writable">Writable Selector</a></h4>
 
       <p>The <code>&lt;writable&gt;</code> selector selects only files
         that are writable.  Ant only invokes
         <code>java.io.File#canWrite</code> so if a file is unwritable
         but the Java VM cannot detect this state, this selector will
         still select the file.</p>
 
       <h4><a name="scriptselector">Script Selector</a></h4>
 
       <p>
         The <code>&lt;scriptselector&gt;</code> element enables you
         to write a complex selection algorithm in any
         <a href="http://jakarta.apache.org/bsf" target="_top">Apache BSF</a>
         or
         <a href="https://scripting.dev.java.net">JSR 223</a>
         supported language.
         See the <a href="../Tasks/script.html">Script</a> task for
         an explanation of scripts and dependencies.
       </p>
       <p>
         This selector was added in Apache Ant 1.7.
       </p>
       <table border="1" cellpadding="2" cellspacing="0">
         <tr>
           <td valign="top"><b>Attribute</b></td>
           <td valign="top"><b>Description</b></td>
           <td align="center" valign="top"><b>Required</b></td>
         </tr>
         <tr>
           <td valign="top">language</td>
           <td valign="top">language of the script.</td>
           <td valign="top" align="center">yes</td>
         </tr>
         <tr>
           <td valign="top">manager</td>
           <td valign="top">
             The script engine manager to use.
             See the <a href="../Tasks/script.html">script</a> task
             for using this attribute.
           </td>
           <td valign="top" align="center">No - default is "auto"</td>
         </tr>
         <tr>
           <td valign="top">src</td>
           <td valign="top">filename of the script</td>
           <td valign="top" align="center">no</td>
         </tr>
         <tr>
           <td valign="top">setbeans</td>
           <td valign="top">whether to have all properties, references and targets as
             global variables in the script.</td>
           <td valign="top" align="center">No, default is "true".</td>
         </tr>
         <tr>
           <td valign="top">classpath</td>
           <td valign="top">
             The classpath to pass into the script.
           </td>
           <td align="center" valign="top">No</td>
         </tr>
         <tr>
           <td valign="top">classpathref</td>
           <td valign="top">The classpath to use, given as a
             <a href="../using.html#references">reference</a> to a path defined elsewhere.
             <td align="center" valign="top">No</td>
           </tr>
       </table>
   <p>
     This selector can take a nested &lt;classpath&gt; element.
     See the <a href="../Tasks/script.html">script</a> task
     on how to use this element.
   </p>
       <p>
       If no <code>src</code> attribute is supplied, the script must be nested
       inside the selector declaration.
       </p>
       <p>The embedded script is invoked for every test, with
          the bean <code>self</code>
         is bound to the selector. It has an attribute <code>selected</code>
         must can be set using <code>setSelected(boolean)</code> to select that
         file.
 
       <p>
 
       The following beans are configured for every script, alongside
       the classic set of project, properties, and targets.
 
       <table border="1" cellpadding="2" cellspacing="0">
         <tr>
           <td valign="top"><b>Bean</b></td>
           <td valign="top"><b>Description</b></td>
           <td valign="top"><b>Type</b></td>
         </tr>
         <tr>
           <td valign="top">self</td>
           <td valign="top">selector instance</td>
           <td valign="top">org.apache.tools.ant.types.optional</td>
         </tr>
         <tr>
           <td valign="top">filename</td>
           <td valign="top">filename of the selection</td>
           <td valign="top" >String</td>
         </tr>
         <tr>
           <td valign="top">file</td>
           <td valign="top">file of the selection</td>
           <td valign="top" >java.io.File</td>
         </tr>
         <tr>
           <td valign="top">basedir</td>
           <td valign="top">Fileset base directory</td>
           <td valign="top" >java.io.File</td>
         </tr>
 
       </table>
       <p>
       The <code>self</code> bean maps to the selector, which has the following
       attributes. Only the <code>selected</code> flag is writable, the rest
       are read only via their getter methods.
 
             <table border="1" cellpadding="2" cellspacing="0">
         <tr>
           <td valign="top"><b>Attribute</b></td>
           <td valign="top"><b>Description</b></td>
           <td align="center" valign="top"><b>Type</b></td>
         </tr>
         <tr>
           <td valign="top">selected</td>
           <td valign="top">writeable flag to select this file</td>
           <td valign="top" align="center">boolean</td>
         </tr>
         <tr>
           <td valign="top">filename</td>
           <td valign="top">filename of the selection</td>
           <td valign="top" >String</td>
         </tr>
         <tr>
           <td valign="top">file</td>
           <td valign="top">file of the selection</td>
           <td valign="top" >java.io.File</td>
         </tr>
         <tr>
           <td valign="top">basedir</td>
           <td valign="top">Fileset base directory</td>
           <td valign="top" >java.io.File</td>
         </tr>
       </table>
 
       <p>
       Example
       </p>
 <pre>
     &lt;scriptselector language=&quot;javascript&quot;&gt;
       self.setSelected(true);
     &lt;/scriptselector&gt;
 </pre>
     <p>
     Selects every file.
     </p>
 
 <pre>
     &lt;scriptselector language=&quot;javascript&quot;&gt;
       self.setSelected((filename.length%2)==0);
     &lt;/scriptselector&gt;
 </pre>
 Select files whose filename length is even.
 
     <h3><a name="selectcontainers">Selector Containers</a></h3>
 
     <p>To create more complex selections, a variety of selectors that
     contain other selectors are available for your use. They combine the
     selections of their child selectors in various ways.</p>
 
     <p>The selector containers are:</p>
 
     <ul>
       <li><a href="#andselect"><code>&lt;and&gt;</code></a> - select a file only if all
         the contained selectors select it.
       <li><a href="#majorityselect"><code>&lt;majority&gt;</code></a> - select a file
         if a majority of its selectors select it.
       <li><a href="#noneselect"><code>&lt;none&gt;</code></a> - select a file only if
         none of the contained selectors select it.
       <li><a href="#notselect"><code>&lt;not&gt;</code></a> - can contain only one
         selector, and reverses what it selects and doesn't select.
       <li><a href="#orselect"><code>&lt;or&gt;</code></a> - selects a file if any one
         of the contained selectors selects it.
       <li><a href="#selectorselect"><code>&lt;selector&gt;</code></a> - contains only one
         selector and forwards all requests to it without alteration, provided
         that any <code>&quot;if&quot;</code> or
         <code>&quot;unless&quot;</code> conditions are met. This
         is the selector to use if you want to define a reference. It is
         usable as an element of <code>&lt;project&gt;</code>. It is also
         the one to use if you want selection of files to be dependent on
         Ant property settings.
     </ul>
 
     <p>All selector containers can contain any other selector, including
     other containers, as an element. Using containers, the selector tags
     can be arbitrarily deep. Here is a complete list of allowable
     selector elements within a container:</p>
 
     <ul>
       <li><code>&lt;and&gt;</code></li>
       <li><code>&lt;contains&gt;</code></li>
       <li><code>&lt;custom&gt;</code></li>
       <li><code>&lt;date&gt;</code></li>
       <li><code>&lt;depend&gt;</code></li>
       <li><code>&lt;depth&gt;</code></li>
       <li><code>&lt;filename&gt;</code></li>
       <li><code>&lt;majority&gt;</code></li>
       <li><code>&lt;none&gt;</code></li>
       <li><code>&lt;not&gt;</code></li>
       <li><code>&lt;or&gt;</code></li>
       <li><code>&lt;present&gt;</code></li>
       <li><code>&lt;selector&gt;</code></li>
       <li><code>&lt;size&gt;</code></li>
     </ul>
 
     <h4><a name="andselect">And Selector</a></h4>
 
     <p>The <code>&lt;and&gt;</code> tag selects files that are
     selected by all of the elements it contains. It returns as
     soon as it finds a selector that does not select the file,
     so it is not guaranteed to check every selector.
     </p>
 
     <p>Here is an example of how to use the And Selector:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${dist}&quot; includes=&quot;**/*.jar&quot;&gt;
     &lt;and&gt;
         &lt;size value=&quot;4&quot; units=&quot;Ki&quot; when=&quot;more&quot;/&gt;
         &lt;date datetime=&quot;01/01/2001 12:00 AM&quot; when=&quot;before&quot;/&gt;
     &lt;/and&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Selects all the JAR file larger than 4096 bytes which haven't been update
-      since the last millenium.
+      since the last millennium.
     </p>
 
 
     <h4><a name="majorityselect">Majority Selector</a></h4>
 
     <p>The <code>&lt;majority&gt;</code> tag selects files provided
     that a majority of the contained elements also select it. Ties are
     dealt with as specified by the <code>allowtie</code> attribute.
     </p>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr>
         <td valign="top"><b>Attribute</b></td>
         <td valign="top"><b>Description</b></td>
         <td align="center" valign="top"><b>Required</b></td>
       </tr>
       <tr>
         <td valign="top">allowtie</td>
         <td valign="top">Whether files should be selected if there
           are an even number of selectors selecting them as are
           not selecting them. Default is true.
         </td>
         <td valign="top" align="center">No</td>
       </tr>
     </table>
 
 
     <p>Here is an example of how to use the Majority Selector:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${docs}&quot; includes=&quot;**/*.html&quot;&gt;
     &lt;majority&gt;
         &lt;contains text=&quot;project&quot; casesensitive="false"/&gt;
         &lt;contains text=&quot;taskdef&quot; casesensitive="false"/&gt;
         &lt;contains text=&quot;IntrospectionHelper&quot; casesensitive="true"/&gt;
     &lt;/majority&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Selects all the HTML files which contain at least two of the three
     phrases "project", "taskdef", and "IntrospectionHelper" (this last phrase must
     match case exactly).
     </p>
 
 
     <h4><a name="noneselect">None Selector</a></h4>
 
     <p>The <code>&lt;none&gt;</code> tag selects files that are
     not selected by any of the elements it contains. It returns as
     soon as it finds a selector that selects the file,
     so it is not guaranteed to check every selector.
     </p>
 
     <p>Here is an example of how to use the None Selector:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${src}&quot; includes=&quot;**/*.java&quot;&gt;
     &lt;none&gt;
         &lt;present targetdir=&quot;${dest}&quot;/&gt;
         &lt;present targetdir=&quot;${dest}&quot;&gt;
             &lt;mapper type=&quot;glob&quot; from=&quot;*.java&quot; to=&quot;*.class&quot;/&gt;
         &lt;/present&gt;
     &lt;/none&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Selects only Java files which do not have equivalent java or
     class files in the dest directory.
     </p>
 
 
     <h4><a name="notselect">Not Selector</a></h4>
 
     <p>The <code>&lt;not&gt;</code> tag reverses the meaning of the
     single selector it contains.
     </p>
 
     <p>Here is an example of how to use the Not Selector:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${src}&quot; includes=&quot;**/*.java&quot;&gt;
     &lt;not&gt;
         &lt;contains text=&quot;test&quot;/&gt;
     &lt;/not&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Selects all the files in the src directory that do not contain the
     string "test".
     </p>
 
 
     <h4><a name="orselect">Or Selector</a></h4>
 
     <p>The <code>&lt;or&gt;</code> tag selects files that are
     selected by any one of the elements it contains. It returns as
     soon as it finds a selector that selects the file,
     so it is not guaranteed to check every selector.
     </p>
 
     <p>Here is an example of how to use the Or Selector:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${basedir}&quot;&gt;
     &lt;or&gt;
         &lt;depth max=&quot;0&quot;/&gt;
         &lt;filename name="*.png"/&gt;
         &lt;filename name="*.gif"/&gt;
         &lt;filename name="*.jpg"/&gt;
     &lt;/or&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Selects all the files in the top directory along with all the
     image files below it.
     </p>
 
 
     <h4><a name="selectorselect">Selector Reference</a></h4>
 
     <p>The <code>&lt;selector&gt;</code> tag is used to create selectors
     that can be reused through references. It is the only selector which can
     be used outside of
     any target, as an element of the <code>&lt;project&gt;</code> tag. It
     can contain only one other selector, but of course that selector can
     be a container.
     </p>
 
     <p>The <code>&lt;selector&gt;</code> tag can also be used to select
     files conditionally based on whether an Ant property exists or not.
     This functionality is realized using the <code>&quot;if&quot;</code> and
     <code>&quot;unless&quot;</code> attributes in exactly the same way they
     are used on targets or on the <code>&lt;include&gt;</code> and
     <code>&lt;exclude&gt;</code> tags within a
     <code>&lt;patternset&gt;</code>.</p>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr>
         <td valign="top"><b>Attribute</b></td>
         <td valign="top"><b>Description</b></td>
         <td align="center" valign="top"><b>Required</b></td>
       </tr>
       <tr>
         <td valign="top">if</td>
         <td valign="top">Allow files to be selected only <a href="../properties.html#if+unless">if the named
           property is set</a>.
         </td>
         <td valign="top" align="center">No</td>
       </tr>
       <tr>
         <td valign="top">unless</td>
         <td valign="top">Allow files to be selected only <a href="../properties.html#if+unless">if the named
           property is <b>not</b> set</a>.
         </td>
         <td valign="top" align="center">No</td>
       </tr>
     </table>
 
     <p>Here is an example of how to use the Selector Reference:</p>
 
     <blockquote><pre>
 &lt;project default=&quot;all&quot; basedir=&quot;./ant&quot;&gt;
 
     &lt;selector id=&quot;completed&quot;&gt;
         &lt;none&gt;
             &lt;depend targetdir=&quot;build/classes&quot;&gt;
                 &lt;mapper type=&quot;glob&quot; from=&quot;*.java&quot; to=&quot;*.class&quot;/&gt;
             &lt;/depend&gt;
             &lt;depend targetdir=&quot;docs/manual/api&quot;&gt;
                 &lt;mapper type=&quot;glob&quot; from=&quot;*.java&quot; to=&quot;*.html&quot;/&gt;
             &lt;/depend&gt;
         &lt;/none&gt;
     &lt;/selector&gt;
 
     &lt;target&gt;
         &lt;zip&gt;
             &lt;fileset dir=&quot;src/main&quot; includes=&quot;**/*.java&quot;&gt;
                 &lt;selector refid=&quot;completed&quot;/&gt;
             &lt;/fileset&gt;
         &lt;/zip&gt;
     &lt;/target&gt;
 
 &lt;/project&gt;
 </pre></blockquote>
 
     <p>Zips up all the Java files which have an up-to-date equivalent
     class file and javadoc file associated with them.
     </p>
 
     <p>And an example of selecting files conditionally, based on whether
     properties are set:</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${working.copy}&quot;&gt;
     &lt;or&gt;
         &lt;selector if=&quot;include.tests&quot;&gt;
             &lt;filename name=&quot;**/*Test.class&quot;&gt;
         &lt;/selector&gt;
         &lt;selector if=&quot;include.source&quot;&gt;
             &lt;and&gt;
                 &lt;filename name=&quot;**/*.java&quot;&gt;
                 &lt;not&gt;
                     &lt;selector unless=&quot;include.tests&quot;&gt;
                         &lt;filename name=&quot;**/*Test.java&quot;&gt;
                     &lt;/selector&gt;
                 &lt;/not&gt;
             &lt;/and&gt;
         &lt;/selector&gt;
     &lt;/or&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>A fileset that conditionally contains Java source files and Test
     source and class files.</p>
 
     <h3><a name="customselect">Custom Selectors</a></h3>
 
     <p>You can write your own selectors and use them within the selector
     containers by specifying them within the <code>&lt;custom&gt;</code> tag.</p>
 
     <p>First, you have to write your selector class in Java. The only
     requirement it must meet in order to be a selector is that it implements
     the <code>org.apache.tools.ant.types.selectors.FileSelector</code>
     interface, which contains a single method. See
     <a href="selectors-program.html">Programming Selectors in Ant</a> for
     more information.</p>
 
     <p>Once that is written, you include it in your build file by using
     the <code>&lt;custom&gt;</code> tag.
     </p>
 
     <table border="1" cellpadding="2" cellspacing="0">
       <tr>
         <td valign="top"><b>Attribute</b></td>
         <td valign="top"><b>Description</b></td>
         <td align="center" valign="top"><b>Required</b></td>
       </tr>
       <tr>
         <td valign="top">classname</td>
         <td valign="top">The name of your class that implements
           <code>org.apache.tools.ant.types.selectors.FileSelector</code>.
         </td>
         <td valign="top" align="center">Yes</td>
       </tr>
       <tr>
         <td valign="top">classpath</td>
         <td valign="top">The classpath to use in order to load the
           custom selector class. If neither this classpath nor the
           classpathref are specified, the class will be
           loaded from the classpath that Ant uses.
         </td>
         <td valign="top" align="center">No</td>
       </tr>
       <tr>
         <td valign="top">classpathref</td>
         <td valign="top">A reference to a classpath previously
           defined. If neither this reference nor the
           classpath above are specified, the class will be
           loaded from the classpath that Ant uses.
         </td>
         <td valign="top" align="center">No</td>
       </tr>
     </table>
 
     <p>Here is how you use <code>&lt;custom&gt;</code> to
     use your class as a selector:
     </p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${mydir}&quot; includes=&quot;**/*&quot;&gt;
     &lt;custom classname=&quot;com.mydomain.MySelector&quot;&gt;
         &lt;param name=&quot;myattribute&quot; value=&quot;myvalue&quot;/&gt;
     &lt;/custom&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>A number of core selectors can also be used as custom selectors
     by specifying their attributes using <code>&lt;param&gt;</code> elements. These
     are</p>
 
     <ul>
       <li><a href="#containsselect">Contains Selector</a> with
         classname <code>org.apache.tools.ant.types.selectors.ContainsSelector</code>
       <li><a href="#dateselect">Date Selector</a> with
         classname <code>org.apache.tools.ant.types.selectors.DateSelector</code>
       <li><a href="#depthselect">Depth Selector</a> with
         classname <code>org.apache.tools.ant.types.selectors.DepthSelector</code>
       <li><a href="#filenameselect">Filename Selector</a> with
         classname <code>org.apache.tools.ant.types.selectors.FilenameSelector</code>
       <li><a href="#sizeselect">Size Selector</a> with
         classname <code>org.apache.tools.ant.types.selectors.SizeSelector</code>
     </ul>
 
     <p>Here is the example from the Depth Selector section rewritten
     to use the selector through <code>&lt;custom&gt;</code>.</p>
 
     <blockquote><pre>
 &lt;fileset dir=&quot;${doc.path}&quot; includes=&quot;**/*&quot;&gt;
     &lt;custom classname=&quot;org.apache.tools.ant.types.selectors.DepthSelector&quot;&gt;
         &lt;param name=&quot;max&quot; value=&quot;1&quot;/&gt;
     &lt;/custom&gt;
 &lt;/fileset&gt;
 </pre></blockquote>
 
     <p>Selects all files in the base directory and one directory below
     that.</p>
 
     <p>For more details concerning writing your own selectors, consult
     <a href="selectors-program.html">Programming Selectors in Ant</a>.</p>
 
     
 
   </body>
 
 </html>
diff --git a/manual/argumentprocessor.html b/manual/argumentprocessor.html
index 22160ccb5..2cd5202f0 100644
--- a/manual/argumentprocessor.html
+++ b/manual/argumentprocessor.html
@@ -1,76 +1,76 @@
 <!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 -->
 <html>
 
 <head>
 <meta http-equiv="Content-Language" content="en-us">
 <link rel="stylesheet" type="text/css" href="stylesheets/style.css">
 <title>The Command Line Processor Plugin: ArgumentProcessor</title>
 </head>
 
 <body>
 <h1>The Command Line Processor Plugin: ArgumentProcessor</h1>
 
 <h2><a name="definition">What is an ArgumentProcessor?</a></h2>
 
 <p>
 An <code>ArgumentProcessor</code> is a parser of command line argument which is
 then call before and after the build file is being parsed. Third party
 libraries may then be able to have custom argument line argument which modify
 Ant behaviour.
 </p>
 
 <p>
 An <code>ArgumentProcessor</code> is called each time Ant parse an unknown
 argument, an <code>ArgumentProcessor</code> doesn't take precedence over Ant to
-parse already suported options. It is then recommended to thrid party
+parse already suported options. It is then recommended to third party
 <code>ArgumentProcessor</code> implementation to chose specific 'enough'
 argument name, avoiding for instance one letter arguments.
 </p>
 
 <p>
 It is also called at the different phases so different behaviour can be
 implemented. It is called just after every arguments are parsed, just
 before the project is being configured (the build file being parsed),
 and just after. Some of the methods to be implemented return a boolean:
-if <code>true</code> is returned, Ant will terminate immediatly, without
+if <code>true</code> is returned, Ant will terminate immediately, without
 error.
 </p>
 
 <p>
 Being called during all these phases, an <code>ArgumentProcessor</code>
 can just print some specific system properties and quit (like
 <code>-diagnose</code>), or print some specific properties of a project after
 being parsed and quit (like <code>-projectHelp</code>), or just set some
 custom properties on the project and let it run.
 </p>
 
 <h2><a name="repository">How to register it's own ArgumentProcessor</a></h2>
 
 <p>First, the <code>ArgumentProcessor</code> must be an implementation of
 <code>org.apache.tools.ant.ArgumentProcessor</code>.
 </p>
 
 <p>Then to decare it: create a file
 <code>META-INF/services/org.apache.tools.ant.ArgumentProcessor</code> which
 contains only one line the fully qualified name of the class of the
 implementation. This file together with the implementation class need then to
 be found in Ant's classpath.
 </p>
 </body>
 </html>
 
diff --git a/src/main/org/apache/tools/ant/DemuxOutputStream.java b/src/main/org/apache/tools/ant/DemuxOutputStream.java
index cd5a7e9d6..bd3991321 100644
--- a/src/main/org/apache/tools/ant/DemuxOutputStream.java
+++ b/src/main/org/apache/tools/ant/DemuxOutputStream.java
@@ -1,249 +1,249 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.WeakHashMap;
 
 
 /**
  * Logs content written by a thread and forwards the buffers onto the
  * project object which will forward the content to the appropriate
  * task.
  *
  * @since 1.4
  */
 public class DemuxOutputStream extends OutputStream {
 
     /**
      * A data class to store information about a buffer. Such information
      * is stored on a per-thread basis.
      */
     private static class BufferInfo {
         /**
          * The per-thread output stream.
          */
         private ByteArrayOutputStream buffer;
 
         /**
          * Indicates we have just seen a carriage return. It may be part of
          * a crlf pair or a single cr invoking processBuffer twice.
          */
          private boolean crSeen = false;
     }
 
     /** Maximum buffer size. */
     private static final int MAX_SIZE = 1024;
 
     /** Initial buffer size. */
-    private static final int INTIAL_SIZE = 132;
+    private static final int INITIAL_SIZE = 132;
 
     /** Carriage return */
     private static final int CR = 0x0d;
 
     /** Linefeed */
     private static final int LF = 0x0a;
 
     /** Mapping from thread to buffer (Thread to BufferInfo). */
     private WeakHashMap<Thread, BufferInfo> buffers = new WeakHashMap<Thread, BufferInfo>();
 
     /**
      * The project to send output to.
      */
     private Project project;
 
     /**
      * Whether or not this stream represents an error stream.
      */
     private boolean isErrorStream;
 
     /**
      * Creates a new instance of this class.
      *
      * @param project The project instance for which output is being
      *                demultiplexed. Must not be <code>null</code>.
      * @param isErrorStream <code>true</code> if this is the error string,
      *                      otherwise a normal output stream. This is
      *                      passed to the project so it knows
      *                      which stream it is receiving.
      */
     public DemuxOutputStream(Project project, boolean isErrorStream) {
         this.project = project;
         this.isErrorStream = isErrorStream;
     }
 
     /**
      * Returns the buffer associated with the current thread.
      *
      * @return a BufferInfo for the current thread to write data to
      */
     private BufferInfo getBufferInfo() {
         Thread current = Thread.currentThread();
         BufferInfo bufferInfo = (BufferInfo) buffers.get(current);
         if (bufferInfo == null) {
             bufferInfo = new BufferInfo();
-            bufferInfo.buffer = new ByteArrayOutputStream(INTIAL_SIZE);
+            bufferInfo.buffer = new ByteArrayOutputStream(INITIAL_SIZE);
             bufferInfo.crSeen = false;
             buffers.put(current, bufferInfo);
         }
         return bufferInfo;
     }
 
     /**
      * Resets the buffer for the current thread.
      */
     private void resetBufferInfo() {
         Thread current = Thread.currentThread();
         BufferInfo bufferInfo = (BufferInfo) buffers.get(current);
         try {
             bufferInfo.buffer.close();
         } catch (IOException e) {
             // Shouldn't happen
         }
         bufferInfo.buffer = new ByteArrayOutputStream();
         bufferInfo.crSeen = false;
     }
 
     /**
      * Removes the buffer for the current thread.
      */
     private void removeBuffer() {
         Thread current = Thread.currentThread();
         buffers.remove (current);
     }
 
     /**
      * Writes the data to the buffer and flushes the buffer if a line
      * separator is detected or if the buffer has reached its maximum size.
      *
      * @param cc data to log (byte).
      * @exception IOException if the data cannot be written to the stream
      */
     public void write(int cc) throws IOException {
         final byte c = (byte) cc;
 
         BufferInfo bufferInfo = getBufferInfo();
 
         if (c == '\n') {
             // LF is always end of line (i.e. CRLF or single LF)
             bufferInfo.buffer.write(cc);
             processBuffer(bufferInfo.buffer);
         } else {
             if (bufferInfo.crSeen) {
                 // CR without LF - send buffer then add char
                 processBuffer(bufferInfo.buffer);
             }
             // add into buffer
             bufferInfo.buffer.write(cc);
         }
         bufferInfo.crSeen = (c == '\r');
         if (!bufferInfo.crSeen && bufferInfo.buffer.size() > MAX_SIZE) {
             processBuffer(bufferInfo.buffer);
         }
     }
 
     /**
      * Converts the buffer to a string and sends it to the project.
      *
      * @param buffer the ByteArrayOutputStream used to collect the output
      * until a line separator is seen.
      *
      * @see Project#demuxOutput(String,boolean)
      */
     protected void processBuffer(ByteArrayOutputStream buffer) {
         String output = buffer.toString();
         project.demuxOutput(output, isErrorStream);
         resetBufferInfo();
     }
 
     /**
      * Converts the buffer to a string and sends it to the project.
      *
      * @param buffer the ByteArrayOutputStream used to collect the output
      * until a line separator is seen.
      *
      * @see Project#demuxOutput(String,boolean)
      */
     protected void processFlush(ByteArrayOutputStream buffer) {
         String output = buffer.toString();
         project.demuxFlush(output, isErrorStream);
         resetBufferInfo();
     }
 
     /**
      * Equivalent to flushing the stream.
      *
      * @exception IOException if there is a problem closing the stream.
      *
      * @see #flush
      */
     public void close() throws IOException {
         flush();
         removeBuffer();
     }
 
     /**
      * Writes all remaining data in the buffer associated
      * with the current thread to the project.
      *
      * @exception IOException if there is a problem flushing the stream.
      */
     public void flush() throws IOException {
         BufferInfo bufferInfo = getBufferInfo();
         if (bufferInfo.buffer.size() > 0) {
             processFlush(bufferInfo.buffer);
         }
     }
 
     /**
      * Write a block of characters to the output stream
      *
      * @param b the array containing the data
      * @param off the offset into the array where data starts
      * @param len the length of block
      *
      * @throws IOException if the data cannot be written into the stream.
      */
     public void write(byte[] b, int off, int len) throws IOException {
         // find the line breaks and pass other chars through in blocks
         int offset = off;
         int blockStartOffset = offset;
         int remaining = len;
         BufferInfo bufferInfo = getBufferInfo();
         while (remaining > 0) {
             while (remaining > 0 && b[offset] != LF && b[offset] != CR) {
                 offset++;
                 remaining--;
             }
             // either end of buffer or a line separator char
             int blockLength = offset - blockStartOffset;
             if (blockLength > 0) {
                 bufferInfo.buffer.write(b, blockStartOffset, blockLength);
             }
             while (remaining > 0 && (b[offset] == LF || b[offset] == CR)) {
                 write(b[offset]);
                 offset++;
                 remaining--;
             }
             blockStartOffset = offset;
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/filters/FixCrLfFilter.java b/src/main/org/apache/tools/ant/filters/FixCrLfFilter.java
index 055720072..8a37924c7 100644
--- a/src/main/org/apache/tools/ant/filters/FixCrLfFilter.java
+++ b/src/main/org/apache/tools/ant/filters/FixCrLfFilter.java
@@ -1,1004 +1,1004 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.filters;
 
 import java.io.IOException;
 import java.io.Reader;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.taskdefs.condition.Os;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 
 /**
  * Converts text to local OS formatting conventions, as well as repair text
  * damaged by misconfigured or misguided editors or file transfer programs.
  * <p>
  * This filter can take the following arguments:
  * <ul>
  * <li>eof
  * <li>eol
  * <li>fixlast
  * <li>javafiles
  * <li>tab
  * <li>tablength
  * </ul>
  * None of which are required.
  * <p>
  * This version generalises the handling of EOL characters, and allows for
  * CR-only line endings (the standard on Mac systems prior to OS X). Tab
  * handling has also been generalised to accommodate any tabwidth from 2 to 80,
  * inclusive. Importantly, it can leave untouched any literal TAB characters
  * embedded within Java string or character constants.
  * <p>
  * <em>Caution:</em> run with care on carefully formatted files. This may
  * sound obvious, but if you don't specify asis, presume that your files are
  * going to be modified. If "tabs" is "add" or "remove", whitespace characters
  * may be added or removed as necessary. Similarly, for EOLs, eol="asis"
  * actually means convert to your native O/S EOL convention while eol="crlf" or
  * cr="add" can result in CR characters being removed in one special case
  * accommodated, i.e., CRCRLF is regarded as a single EOL to handle cases where
  * other programs have converted CRLF into CRCRLF.
  *
  * <P>
  * Example:
  *
  * <pre>
  * &lt;&lt;fixcrlf tab=&quot;add&quot; eol=&quot;crlf&quot; eof=&quot;asis&quot;/&gt;
  * </pre>
  *
  * Or:
  *
  * <pre>
  * &lt;filterreader classname=&quot;org.apache.tools.ant.filters.FixCrLfFilter&quot;&gt;
  *   &lt;param eol=&quot;crlf&quot; tab=&quot;asis&quot;/&gt;
  *  &lt;/filterreader&gt;
  * </pre>
  *
  */
 public final class FixCrLfFilter extends BaseParamFilterReader implements ChainableReader {
     private static final int DEFAULT_TAB_LENGTH = 8;
     private static final int MIN_TAB_LENGTH = 2;
     private static final int MAX_TAB_LENGTH = 80;
     private static final char CTRLZ = '\u001A';
 
     private int tabLength = DEFAULT_TAB_LENGTH;
 
     private CrLf eol;
 
     private AddAsisRemove ctrlz;
 
     private AddAsisRemove tabs;
 
     private boolean javafiles = false;
 
     private boolean fixlast = true;
 
     private boolean initialized = false;
 
     /**
      * Constructor for "dummy" instances.
      *
      * @see BaseFilterReader#BaseFilterReader()
      */
     public FixCrLfFilter() {
         super();
     }
 
     /**
      * Create a new filtered reader.
      *
      * @param in
      *            A Reader object providing the underlying stream. Must not be
      *            <code>null</code>.
      * @throws IOException on error.
      */
     public FixCrLfFilter(final Reader in) throws IOException {
         super(in);
     }
 
     // Instance initializer: Executes just after the super() call in this
     // class's constructor.
     {
         tabs = AddAsisRemove.ASIS;
         if (Os.isFamily("mac") && !Os.isFamily("unix")) {
             ctrlz = AddAsisRemove.REMOVE;
             setEol(CrLf.MAC);
         } else if (Os.isFamily("dos")) {
             ctrlz = AddAsisRemove.ASIS;
             setEol(CrLf.DOS);
         } else {
             ctrlz = AddAsisRemove.REMOVE;
             setEol(CrLf.UNIX);
         }
     }
 
     /**
      * Create a new FixCrLfFilter using the passed in Reader for instantiation.
      *
      * @param rdr
      *            A Reader object providing the underlying stream. Must not be
      *            <code>null</code>.
      *
      * @return a new filter based on this configuration, but filtering the
      *         specified reader.
      */
     public Reader chain(final Reader rdr) {
         try {
             FixCrLfFilter newFilter = new FixCrLfFilter(rdr);
 
             newFilter.setJavafiles(getJavafiles());
             newFilter.setEol(getEol());
             newFilter.setTab(getTab());
             newFilter.setTablength(getTablength());
             newFilter.setEof(getEof());
             newFilter.setFixlast(getFixlast());
             newFilter.initInternalFilters();
 
             return newFilter;
         } catch (IOException e) {
             throw new BuildException(e);
         }
     }
 
     /**
      * Get how DOS EOF (control-z) characters are being handled.
      *
      * @return values:
      *         <ul>
      *         <li>add: ensure that there is an eof at the end of the file
      *         <li>asis: leave eof characters alone
      *         <li>remove: remove any eof character found at the end
      *         </ul>
      */
     public AddAsisRemove getEof() {
         // Return copy so that the call must call setEof() to change the state
         // of fixCRLF
         return ctrlz.newInstance();
     }
 
     /**
      * Get how EndOfLine characters are being handled.
      *
      * @return values:
      *         <ul>
      *         <li>asis: convert line endings to your O/S convention
      *         <li>cr: convert line endings to CR
      *         <li>lf: convert line endings to LF
      *         <li>crlf: convert line endings to CRLF
      *         </ul>
      */
     public CrLf getEol() {
         // Return copy so that the call must call setEol() to change the state
         // of fixCRLF
         return eol.newInstance();
     }
 
     /**
      * Get whether a missing EOL be added to the final line of the stream.
      *
      * @return true if a filtered file will always end with an EOL
      */
     public boolean getFixlast() {
         return fixlast;
     }
 
     /**
      * Get whether the stream is to be treated as though it contains Java
      * source.
      * <P>
      * This attribute is only used in association with the &quot;<i><b>tab</b></i>&quot;
      * attribute. Tabs found in Java literals are protected from changes by this
      * filter.
      *
      * @return true if whitespace in Java character and string literals is
      *         ignored.
      */
     public boolean getJavafiles() {
         return javafiles;
     }
 
     /**
      * Return how tab characters are being handled.
      *
      * @return values:
      *         <ul>
      *         <li>add: convert sequences of spaces which span a tab stop to
      *         tabs
      *         <li>asis: leave tab and space characters alone
      *         <li>remove: convert tabs to spaces
      *         </ul>
      */
     public AddAsisRemove getTab() {
         // Return copy so that the caller must call setTab() to change the state
         // of fixCRLF.
         return tabs.newInstance();
     }
 
     /**
      * Get the tab length to use.
      *
      * @return the length of tab in spaces
      */
     public int getTablength() {
         return tabLength;
     }
 
     private static String calculateEolString(CrLf eol) {
         // Calculate the EOL string per the current config
         if (eol == CrLf.CR || eol == CrLf.MAC) {
             return "\r";
         }
         if (eol == CrLf.CRLF || eol == CrLf.DOS) {
             return "\r\n";
         }
         // assume (eol == CrLf.LF || eol == CrLf.UNIX)
         return "\n";
     }
 
     /**
      * Wrap the input stream with the internal filters necessary to perform the
      * configuration settings.
      */
     private void initInternalFilters() {
 
         // If I'm removing an EOF character, do so first so that the other
         // filters don't see that character.
         in = (ctrlz == AddAsisRemove.REMOVE) ? new RemoveEofFilter(in) : in;
 
         // Change all EOL characters to match the calculated EOL string. If
         // configured to do so, append a trailing EOL so that the file ends on
         // a EOL.
         if (eol != CrLf.ASIS) {
             in = new NormalizeEolFilter(in, calculateEolString(eol), getFixlast());
         }
 
         if (tabs != AddAsisRemove.ASIS) {
             // If filtering Java source, prevent changes to whitespace in
             // character and string literals.
             if (getJavafiles()) {
                 in = new MaskJavaTabLiteralsFilter(in);
             }
             // Add/Remove tabs
             in = (tabs == AddAsisRemove.ADD) ? (Reader) new AddTabFilter(in, getTablength())
                     : (Reader) new RemoveTabFilter(in, getTablength());
         }
         // Add missing EOF character
         in = (ctrlz == AddAsisRemove.ADD) ? new AddEofFilter(in) : in;
         initialized = true;
     }
 
     /**
      * Return the next character in the filtered stream.
      *
      * @return the next character in the resulting stream, or -1 if the end of
      *         the resulting stream has been reached.
      *
      * @exception IOException
      *                if the underlying stream throws an IOException during
      *                reading.
      */
     public synchronized int read() throws IOException {
         if (!initialized) {
             initInternalFilters();
         }
         return in.read();
     }
 
     /**
      * Specify how DOS EOF (control-z) characters are to be handled.
      *
      * @param attr
      *            valid values:
      *            <ul>
      *            <li>add: ensure that there is an eof at the end of the file
      *            <li>asis: leave eof characters alone
      *            <li>remove: remove any eof character found at the end
      *            </ul>
      */
     public void setEof(AddAsisRemove attr) {
         ctrlz = attr.resolve();
     }
 
     /**
      * Specify how end of line (EOL) characters are to be handled.
      *
      * @param attr
      *            valid values:
      *            <ul>
      *            <li>asis: convert line endings to your O/S convention
      *            <li>cr: convert line endings to CR
      *            <li>lf: convert line endings to LF
      *            <li>crlf: convert line endings to CRLF
      *            </ul>
      */
     public void setEol(CrLf attr) {
         eol = attr.resolve();
     }
 
     /**
      * Specify whether a missing EOL will be added to the final line of input.
      *
      * @param fixlast
      *            if true a missing EOL will be appended.
      */
     public void setFixlast(boolean fixlast) {
         this.fixlast = fixlast;
     }
 
     /**
      * Indicate whether this stream contains Java source.
      *
-     * This attribute is only used in assocation with the &quot;<i><b>tab</b></i>&quot;
+     * This attribute is only used in association with the &quot;<i><b>tab</b></i>&quot;
      * attribute.
      *
      * @param javafiles
      *            set to true to prevent this filter from changing tabs found in
      *            Java literals.
      */
     public void setJavafiles(boolean javafiles) {
         this.javafiles = javafiles;
     }
 
     /**
      * Specify how tab characters are to be handled.
      *
      * @param attr
      *            valid values:
      *            <ul>
      *            <li>add: convert sequences of spaces which span a tab stop to
      *            tabs
      *            <li>asis: leave tab and space characters alone
      *            <li>remove: convert tabs to spaces
      *            </ul>
      */
     public void setTab(AddAsisRemove attr) {
         tabs = attr.resolve();
     }
 
     /**
      * Specify tab length in characters.
      *
      * @param tabLength
      *            specify the length of tab in spaces. Valid values are between
      *            2 and 80 inclusive. The default for this parameter is 8.
      * @throws IOException on error.
      */
     public void setTablength(int tabLength) throws IOException {
         if (tabLength < MIN_TAB_LENGTH
             || tabLength > MAX_TAB_LENGTH) {
             throw new IOException(
                 "tablength must be between " + MIN_TAB_LENGTH
                 + " and " + MAX_TAB_LENGTH);
         }
         this.tabLength = tabLength;
     }
 
     /**
      * This filter reader redirects all read I/O methods through its own read()
      * method.
      *
      * <P>
      * The input stream is already buffered by the copy task so this doesn't
      * significantly impact performance while it makes writing the individual
      * fix filters much easier.
      * </P>
      */
     private static class SimpleFilterReader extends Reader {
         private static final int PREEMPT_BUFFER_LENGTH = 16;
         private Reader in;
 
         private int[] preempt = new int[PREEMPT_BUFFER_LENGTH];
 
         private int preemptIndex = 0;
 
         public SimpleFilterReader(Reader in) {
             this.in = in;
         }
 
         public void push(char c) {
             push((int) c);
         }
 
         public void push(int c) {
             try {
                 preempt[preemptIndex++] = c;
             } catch (ArrayIndexOutOfBoundsException e) {
                 int[] p2 = new int[preempt.length * 2];
                 System.arraycopy(preempt, 0, p2, 0, preempt.length);
                 preempt = p2;
                 push(c);
             }
         }
 
         public void push(char[] cs, int start, int length) {
             for (int i = start + length - 1; i >= start;) {
                 push(cs[i--]);
             }
         }
 
         public void push(char[] cs) {
             push(cs, 0, cs.length);
         }
 
         /**
          * Does this filter want to block edits on the last character returned
          * by read()?
          */
         public boolean editsBlocked() {
             return in instanceof SimpleFilterReader && ((SimpleFilterReader) in).editsBlocked();
         }
 
         public int read() throws java.io.IOException {
             return preemptIndex > 0 ? preempt[--preemptIndex] : in.read();
         }
 
         public void close() throws java.io.IOException {
             in.close();
         }
 
         public void reset() throws IOException {
             in.reset();
         }
 
         public boolean markSupported() {
             return in.markSupported();
         }
 
         public boolean ready() throws java.io.IOException {
             return in.ready();
         }
 
         public void mark(int i) throws java.io.IOException {
             in.mark(i);
         }
 
         public long skip(long i) throws java.io.IOException {
             return in.skip(i);
         }
 
         public int read(char[] buf) throws java.io.IOException {
             return read(buf, 0, buf.length);
         }
 
         public int read(char[] buf, int start, int length) throws java.io.IOException {
             int count = 0;
             int c = 0;
 
             // CheckStyle:InnerAssignment OFF - leave alone
             while (length-- > 0 && (c = this.read()) != -1) {
                 buf[start++] = (char) c;
                 count++;
             }
             // if at EOF with no characters in the buffer, return EOF
             return (count == 0 && c == -1) ? -1 : count;
         }
     }
 
     private static class MaskJavaTabLiteralsFilter extends SimpleFilterReader {
         private boolean editsBlocked = false;
 
         private static final int JAVA = 1;
 
         private static final int IN_CHAR_CONST = 2;
 
         private static final int IN_STR_CONST = 3;
 
         private static final int IN_SINGLE_COMMENT = 4;
 
         private static final int IN_MULTI_COMMENT = 5;
 
         private static final int TRANS_TO_COMMENT = 6;
 
         private static final int TRANS_FROM_MULTI = 8;
 
         private int state;
 
         public MaskJavaTabLiteralsFilter(Reader in) {
             super(in);
             state = JAVA;
         }
 
         public boolean editsBlocked() {
             return editsBlocked || super.editsBlocked();
         }
 
         public int read() throws IOException {
             int thisChar = super.read();
             // Mask, block from being edited, all characters in constants.
             editsBlocked = (state == IN_CHAR_CONST || state == IN_STR_CONST);
 
             switch (state) {
             case JAVA:
                 // The current character is always emitted.
                 switch (thisChar) {
                 case '\'':
                     state = IN_CHAR_CONST;
                     break;
                 case '"':
                     state = IN_STR_CONST;
                     break;
                 case '/':
                     state = TRANS_TO_COMMENT;
                     break;
                 default:
                     // Fall tru
                 }
                 break;
             case IN_CHAR_CONST:
                 switch (thisChar) {
                 case '\'':
                     state = JAVA;
                     break;
                 default:
                     // Fall tru
                 }
                 break;
             case IN_STR_CONST:
                 switch (thisChar) {
                 case '"':
                     state = JAVA;
                     break;
                 default:
                     // Fall tru
                 }
                 break;
             case IN_SINGLE_COMMENT:
                 // The current character is always emitted.
                 switch (thisChar) {
                 case '\n':
                 case '\r': // EOL
                     state = JAVA;
                     break;
                 default:
                     // Fall tru
                 }
                 break;
             case IN_MULTI_COMMENT:
                 // The current character is always emitted.
                 switch (thisChar) {
                 case '*':
                     state = TRANS_FROM_MULTI;
                     break;
                 default:
                     // Fall tru
                 }
                 break;
             case TRANS_TO_COMMENT:
                 // The current character is always emitted.
                 switch (thisChar) {
                 case '*':
                     state = IN_MULTI_COMMENT;
                     break;
                 case '/':
                     state = IN_SINGLE_COMMENT;
                     break;
                 case '\'':
                     state = IN_CHAR_CONST;
                     break;
                 case '"':
                     state = IN_STR_CONST;
                     break;
                 default:
                     state = JAVA;
                 }
                 break;
             case TRANS_FROM_MULTI:
                 // The current character is always emitted.
                 switch (thisChar) {
                 case '/':
                     state = JAVA;
                     break;
                 default:
                     // Fall tru
                 }
                 break;
             default:
                 // Fall tru
             }
             return thisChar;
         }
     }
 
     private static class NormalizeEolFilter extends SimpleFilterReader {
         private boolean previousWasEOL;
 
         private boolean fixLast;
 
         private int normalizedEOL = 0;
 
         private char[] eol = null;
 
         public NormalizeEolFilter(Reader in, String eolString, boolean fixLast) {
             super(in);
             eol = eolString.toCharArray();
             this.fixLast = fixLast;
         }
 
         public int read() throws IOException {
             int thisChar = super.read();
 
             if (normalizedEOL == 0) {
                 int numEOL = 0;
                 boolean atEnd = false;
                 switch (thisChar) {
                 case CTRLZ:
                     int c = super.read();
                     if (c == -1) {
                         atEnd = true;
                         if (fixLast && !previousWasEOL) {
                             numEOL = 1;
                             push(thisChar);
                         }
                     } else {
                         push(c);
                     }
                     break;
                 case -1:
                     atEnd = true;
                     if (fixLast && !previousWasEOL) {
                         numEOL = 1;
                     }
                     break;
                 case '\n':
                     // EOL was "\n"
                     numEOL = 1;
                     break;
                 case '\r':
                     numEOL = 1;
                     int c1 = super.read();
                     int c2 = super.read();
 
                     if (c1 == '\r' && c2 == '\n') {
                         // EOL was "\r\r\n"
                     } else if (c1 == '\r') {
                         // EOL was "\r\r" - handle as two consecutive "\r" and
                         // "\r"
                         numEOL = 2;
                         push(c2);
                     } else if (c1 == '\n') {
                         // EOL was "\r\n"
                         push(c2);
                     } else {
                         // EOL was "\r"
                         push(c2);
                         push(c1);
                     }
                 default:
                     // Fall tru
                 }
                 if (numEOL > 0) {
                     while (numEOL-- > 0) {
                         push(eol);
                         normalizedEOL += eol.length;
                     }
                     previousWasEOL = true;
                     thisChar = read();
                 } else if (!atEnd) {
                     previousWasEOL = false;
                 }
             } else {
                 normalizedEOL--;
             }
             return thisChar;
         }
     }
 
     private static class AddEofFilter extends SimpleFilterReader {
         private int lastChar = -1;
 
         public AddEofFilter(Reader in) {
             super(in);
         }
 
         public int read() throws IOException {
             int thisChar = super.read();
 
             // if source is EOF but last character was NOT ctrl-z, return ctrl-z
             if (thisChar == -1) {
                 if (lastChar != CTRLZ) {
                     lastChar = CTRLZ;
                     return lastChar;
                 }
             } else {
                 lastChar = thisChar;
             }
             return thisChar;
         }
     }
 
     private static class RemoveEofFilter extends SimpleFilterReader {
         private int lookAhead = -1;
 
         public RemoveEofFilter(Reader in) {
             super(in);
 
             try {
                 lookAhead = in.read();
             } catch (IOException e) {
                 lookAhead = -1;
             }
         }
 
         public int read() throws IOException {
             int lookAhead2 = super.read();
 
             // If source at EOF and lookAhead is ctrl-z, return EOF (NOT ctrl-z)
             if (lookAhead2 == -1 && lookAhead == CTRLZ) {
                 return -1;
             }
             // Return current look-ahead
             int i = lookAhead;
             lookAhead = lookAhead2;
             return i;
         }
     }
 
     private static class AddTabFilter extends SimpleFilterReader {
         private int columnNumber = 0;
 
         private int tabLength = 0;
 
         public AddTabFilter(Reader in, int tabLength) {
             super(in);
             this.tabLength = tabLength;
         }
 
         public int read() throws IOException {
             int c = super.read();
 
             switch (c) {
             case '\r':
             case '\n':
                 columnNumber = 0;
                 break;
             case ' ':
                 columnNumber++;
                 if (!editsBlocked()) {
                     int colNextTab = ((columnNumber + tabLength - 1) / tabLength) * tabLength;
                     int countSpaces = 1;
                     int numTabs = 0;
 
                     scanWhitespace: while ((c = super.read()) != -1) {
                         switch (c) {
                         case ' ':
                             if (++columnNumber == colNextTab) {
                                 numTabs++;
                                 countSpaces = 0;
                                 colNextTab += tabLength;
                             } else {
                                 countSpaces++;
                             }
                             break;
                         case '\t':
                             columnNumber = colNextTab;
                             numTabs++;
                             countSpaces = 0;
                             colNextTab += tabLength;
                             break;
                         default:
                             push(c);
                             break scanWhitespace;
                         }
                     }
                     while (countSpaces-- > 0) {
                         push(' ');
                         columnNumber--;
                     }
                     while (numTabs-- > 0) {
                         push('\t');
                         columnNumber -= tabLength;
                     }
                     c = super.read();
                     switch (c) {
                     case ' ':
                         columnNumber++;
                         break;
                     case '\t':
                         columnNumber += tabLength;
                         break;
                     default:
                         // Fall tru
                     }
                 }
                 break;
             case '\t':
                 columnNumber = ((columnNumber + tabLength - 1) / tabLength) * tabLength;
                 break;
             default:
                 columnNumber++;
             }
             return c;
         }
     }
 
     private static class RemoveTabFilter extends SimpleFilterReader {
         private int columnNumber = 0;
 
         private int tabLength = 0;
 
         public RemoveTabFilter(Reader in, int tabLength) {
             super(in);
 
             this.tabLength = tabLength;
         }
 
         public int read() throws IOException {
             int c = super.read();
 
             switch (c) {
             case '\r':
             case '\n':
                 columnNumber = 0;
                 break;
             case '\t':
                 int width = tabLength - columnNumber % tabLength;
 
                 if (!editsBlocked()) {
                     for (; width > 1; width--) {
                         push(' ');
                     }
                     c = ' ';
                 }
                 columnNumber += width;
                 break;
             default:
                 columnNumber++;
             }
             return c;
         }
     }
 
     /**
      * Enumerated attribute with the values "asis", "add" and "remove".
      */
     public static class AddAsisRemove extends EnumeratedAttribute {
         private static final AddAsisRemove ASIS = newInstance("asis");
 
         private static final AddAsisRemove ADD = newInstance("add");
 
         private static final AddAsisRemove REMOVE = newInstance("remove");
 
         /** {@inheritDoc}. */
         public String[] getValues() {
             return new String[] {"add", "asis", "remove"};
         }
 
         /**
          * Equality depending in the index.
          * @param other the object to test equality against.
          * @return true if the object has the same index as this.
          */
         public boolean equals(Object other) {
             return other instanceof AddAsisRemove
                     && getIndex() == ((AddAsisRemove) other).getIndex();
         }
 
         /**
          * Hashcode depending on the index.
          * @return the index as the hashcode.
          */
         public int hashCode() {
             return getIndex();
         }
 
         AddAsisRemove resolve() throws IllegalStateException {
             if (this.equals(ASIS)) {
                 return ASIS;
             }
             if (this.equals(ADD)) {
                 return ADD;
             }
             if (this.equals(REMOVE)) {
                 return REMOVE;
             }
             throw new IllegalStateException("No replacement for " + this);
         }
 
         // Works like clone() but doesn't show up in the Javadocs
         private AddAsisRemove newInstance() {
             return newInstance(getValue());
         }
 
         /**
          * Create an instance of this enumerated value based on the string value.
          * @param value the value to use.
          * @return an enumerated instance.
          */
         public static AddAsisRemove newInstance(String value) {
             AddAsisRemove a = new AddAsisRemove();
             a.setValue(value);
             return a;
         }
     }
 
     /**
      * Enumerated attribute with the values "asis", "cr", "lf" and "crlf".
      */
     public static class CrLf extends EnumeratedAttribute {
         private static final CrLf ASIS = newInstance("asis");
 
         private static final CrLf CR = newInstance("cr");
 
         private static final CrLf CRLF = newInstance("crlf");
 
         private static final CrLf DOS = newInstance("dos");
 
         private static final CrLf LF = newInstance("lf");
 
         private static final CrLf MAC = newInstance("mac");
 
         private static final CrLf UNIX = newInstance("unix");
 
         /**
          * @see EnumeratedAttribute#getValues
          */
         /** {@inheritDoc}. */
         public String[] getValues() {
             return new String[] {"asis", "cr", "lf", "crlf", "mac", "unix", "dos"};
         }
 
         /**
          * Equality depending in the index.
          * @param other the object to test equality against.
          * @return true if the object has the same index as this.
          */
         public boolean equals(Object other) {
             return other instanceof CrLf && getIndex() == ((CrLf) other).getIndex();
         }
 
         /**
          * Hashcode depending on the index.
          * @return the index as the hashcode.
          */
         public int hashCode() {
             return getIndex();
         }
 
         CrLf resolve() {
             if (this.equals(ASIS)) {
                 return ASIS;
             }
             if (this.equals(CR) || this.equals(MAC)) {
                 return CR;
             }
             if (this.equals(CRLF) || this.equals(DOS)) {
                 return CRLF;
             }
             if (this.equals(LF) || this.equals(UNIX)) {
                 return LF;
             }
             throw new IllegalStateException("No replacement for " + this);
         }
 
         // Works like clone() but doesn't show up in the Javadocs
         private CrLf newInstance() {
             return newInstance(getValue());
         }
 
         /**
          * Create an instance of this enumerated value based on the string value.
          * @param value the value to use.
          * @return an enumerated instance.
          */
         public static CrLf newInstance(String value) {
             CrLf c = new CrLf();
             c.setValue(value);
             return c;
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/filters/SortFilter.java b/src/main/org/apache/tools/ant/filters/SortFilter.java
index 62bf3c6c8..471660c3b 100644
--- a/src/main/org/apache/tools/ant/filters/SortFilter.java
+++ b/src/main/org/apache/tools/ant/filters/SortFilter.java
@@ -1,375 +1,375 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.filters;
 
 import java.io.IOException;
 import java.io.Reader;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.types.Parameter;
 
 /**
  * <p>
  * Sort a file before and/or after the file.
  * </p>
  *
  * <p>
  * Examples:
  * </p>
  *
  * <pre>
  *   &lt;copy todir=&quot;build&quot;&gt;
  *       &lt;fileset dir=&quot;input&quot; includes=&quot;*.txt&quot;/&gt;
  *       &lt;filterchain&gt;
  *           &lt;sortfilter/&gt;
  *       &lt;/filterchain&gt;
  *   &lt;/copy&gt;
  * </pre>
  *
  * <p>
  * Sort all files <code>*.txt</code> from <i>src</i> location and copy
  * them into <i>build</i> location. The lines of each file are sorted
  * in ascendant order comparing the lines via the
  * <code>String.compareTo(Object o)</code> method.
  * </p>
  *
  * <pre>
  *   &lt;copy todir=&quot;build&quot;&gt;
  *       &lt;fileset dir=&quot;input&quot; includes=&quot;*.txt&quot;/&gt;
  *       &lt;filterchain&gt;
  *           &lt;sortfilter reverse=&quot;true&quot;/&gt;
  *       &lt;/filterchain&gt;
  *   &lt;/copy&gt;
  * </pre>
  *
  * <p>
  * Sort all files <code>*.txt</code> from <i>src</i> location into reverse
  * order and copy them into <i>build</i> location. If reverse parameter has
  * value <code>true</code> (default value), then the output line of the files
  * will be in ascendant order.
  * </p>
  *
  * <pre>
  *   &lt;copy todir=&quot;build&quot;&gt;
  *       &lt;fileset dir=&quot;input&quot; includes=&quot;*.txt&quot;/&gt;
  *       &lt;filterchain&gt;
  *           &lt;filterreader classname=&quot;org.apache.tools.ant.filters.SortFilter&quot;&gt;
  *             &lt;param name=&quot;comparator&quot; value=&quot;org.apache.tools.ant.filters.EvenFirstCmp&quot;/&gt;
  *           &lt;/filterreader&gt;
  *       &lt;/filterchain&gt;
  *   &lt;/copy&gt;
  * </pre>
  *
  * <p>
  * Sort all files <code>*.txt</code> from <i>src</i> location using as
  * sorting criterium <code>EvenFirstCmp</code> class, that sorts the file
  * lines putting even lines first then odd lines for example. The modified files
  * are copied into <i>build</i> location. The <code>EvenFirstCmp</code>,
  * has to an instanciable class via <code>Class.newInstance()</code>,
  * therefore in case of inner class has to be <em>static</em>. It also has to
  * implement <code>java.util.Comparator</code> interface, for example:
  * </p>
  *
  * <pre>
  *         package org.apache.tools.ant.filters;
  *         ...(omitted)
  *           public final class EvenFirstCmp implements &lt;b&gt;Comparator&lt;/b&gt; {
  *             public int compare(Object o1, Object o2) {
  *             ...(omitted)
  *             }
  *           }
  * </pre>
  *
  * <p>The example above is equivalent to:</p>
  *
  * <blockquote><pre>
  *   &lt;componentdef name="evenfirst"
  *                 classname="org.apache.tools.ant.filters.EvenFirstCmp&quot;/&gt;
  *   &lt;copy todir=&quot;build&quot;&gt;
  *       &lt;fileset dir=&quot;input&quot; includes=&quot;*.txt&quot;/&gt;
  *       &lt;filterchain&gt;
  *           &lt;sortfilter&gt;
  *               &lt;evenfirst/&gt;
  *           &lt;/sortfilter&gt;
  *       &lt;/filterchain&gt;
  *   &lt;/copy&gt;
  * </pre></blockquote>
  *
  * <p> If parameter <code>comparator</code> is present, then
  * <code>reverse</code> parameter will not be taken into account.  </p>
  *
  * @since Ant 1.8.0
  */
 public final class SortFilter extends BaseParamFilterReader
     implements ChainableReader {
 
     /** Parameter name for reverse order. */
     private static final String REVERSE_KEY = "reverse";
 
     /**
      * Parameter name for specifying the comparator criteria via class that
      * implement <code>java.util.Comparator</code> interface.
      */
     private static final String COMPARATOR_KEY = "comparator";
 
     /**
      * Instance of comparator class to be used for sorting.
      */
     private Comparator<? super String> comparator = null;
 
     /**
      * Controls if the sorting process will be in ascendant/descendant order. If
      * If has value <code>true</code>, then the line of the file will be
      * sorted on descendant order. Default value: <code>false</code>. It will
      * be considered only if <code>comparator</code> is <code>null</code>.
      */
     private boolean reverse;
 
     /**
      * Stores the lines to be sorted.
      */
     private List<String> lines;
 
     /**
      * Remaining line to be read from this filter, or <code>null</code> if the
      * next call to <code>read()</code> should read the original stream to
      * find the next matching line.
      */
     private String line = null;
 
     private Iterator<String> iterator = null;
 
     /**
      * Constructor for "dummy" instances.
      *
      * @see BaseFilterReader#BaseFilterReader()
      */
     public SortFilter() {
         super();
     }
 
     /**
      * Creates a new filtered reader.
      *
      * @param in
      *            A Reader object providing the underlying stream. Must not be
      *            <code>null</code>.
      */
     public SortFilter(final Reader in) {
         super(in);
     }
 
     /**
      * Returns the next character in the filtered stream. If the desired number
      * of lines have already been read, the resulting stream is effectively at
      * an end. Otherwise, the next character from the underlying stream is read
      * and returned.
      *
      * @return the next character in the resulting stream, or -1 if the end of
      *         the resulting stream has been reached
      *
      * @exception IOException
      *                if the underlying stream throws an IOException during
      *                reading
      */
     public int read() throws IOException {
         if (!getInitialized()) {
             initialize();
             setInitialized(true);
         }
 
         int ch = -1;
         if (line != null) {
             /*
              * We are on the state: "reading the current line", lines are
              * already sorted
              */
             ch = line.charAt(0);
             if (line.length() == 1) {
                 line = null;
             } else {
                 line = line.substring(1);
             }
         } else {
             if (lines == null) {
                 // We read all lines and sort them
                 lines = new ArrayList<String>();
                 for (line = readLine(); line != null; line = readLine()) {
                     lines.add(line);
                 }
                 sort();
                 iterator = lines.iterator();
             }
 
             if (iterator.hasNext()) {
                 line = (String) iterator.next();
             } else {
                 line = null;
                 lines = null;
                 iterator = null;
             }
             if (line != null) {
                 return read();
             }
         }
         return ch;
     }
 
     /**
      * Creates a new SortReader using the passed in Reader for instantiation.
      *
      * @param rdr
      *            A Reader object providing the underlying stream. Must not be
      *            <code>null</code>.
      *
      * @return a new filter based on this configuration, but filtering the
      *         specified reader
      */
     public Reader chain(final Reader rdr) {
         SortFilter newFilter = new SortFilter(rdr);
         newFilter.setReverse(isReverse());
         newFilter.setComparator(getComparator());
         newFilter.setInitialized(true);
         return newFilter;
     }
 
     /**
      * Returns <code>true</code> if the sorting process will be in reverse
      * order, otherwise the sorting process will be in ascendant order.
      *
      * @return <code>true</code> if the sorting process will be in reverse
      *         order, otherwise the sorting process will be in ascendant order.
      */
     public boolean isReverse() {
         return reverse;
     }
 
     /**
      * Sets the sorting process will be in ascendant (<code>reverse=false</code>)
      * or to descendant (<code>reverse=true</code>).
      *
      * @param reverse
      *            Boolean representing reverse ordering process.
      */
     public void setReverse(boolean reverse) {
         this.reverse = reverse;
     }
 
     /**
      * Returns the comparator to be used for sorting.
      *
      * @return the comparator
      */
     public Comparator<? super String> getComparator() {
         return comparator;
     }
 
     /**
      * Set the comparator to be used as sorting criterium.
      *
      * @param comparator
      *            the comparator to set
      */
     public void setComparator(Comparator<? super String> comparator) {
         this.comparator = comparator;
     }
 
     /**
      * Set the comparator to be used as sorting criterion as nested element.
      *
      * @param comparator
      *            the comparator to set
      */
     public void add(Comparator<? super String> comparator) {
         if (this.comparator != null && comparator != null) {
             throw new BuildException("can't have more than one comparator");
         }
         setComparator(comparator);
     }
 
     /**
      * Scans the parameters list
      */
     private void initialize() throws IOException {
         // get parameters
         Parameter[] params = getParameters();
         if (params != null) {
             for (int i = 0; i < params.length; i++) {
                 final String paramName = params[i].getName();
                 if (REVERSE_KEY.equals(paramName)) {
                     setReverse(Boolean.valueOf(params[i].getValue())
                                .booleanValue());
                     continue;
                 }
                 if (COMPARATOR_KEY.equals(paramName)) {
                     try {
                         String className = (String) params[i].getValue();
                         @SuppressWarnings("unchecked")
                         final Comparator<? super String> comparatorInstance = (Comparator<? super String>) (Class
                                 .forName(className).newInstance());
                         setComparator(comparatorInstance);
                         continue;
                     } catch (InstantiationException e) {
                         throw new BuildException(e);
                     } catch (IllegalAccessException e) {
                         /*
                          * Probably a inner non-static class, this this case is
                          * not considered
                          */
                         throw new BuildException(e);
                     } catch (ClassNotFoundException e) {
                         throw new BuildException(e);
                     } catch (ClassCastException e) {
                         throw new BuildException("Value of comparator attribute"
                                                  + " should implement"
                                                  + " java.util.Comparator"
                                                  + " interface");
                     } catch (Exception e) {
                         throw new BuildException(e);
                     }
                 }
             }
         }
     }
 
     /**
-     * Sorts the read lines (<code>lines</code>)acording to the sorting
+     * Sorts the read lines (<code>lines</code>) according to the sorting
      * criteria defined by the user.
      *
      */
     private void sort() {
         if (comparator == null) {
             if (reverse) {
                 Collections.sort(lines, new Comparator<String>() {
                         public int compare(String s1, String s2) {
                             return (-s1.compareTo(s2));
                         }
                     });
             } else {
                 Collections.sort(lines);
             }
         } else {
             Collections.sort(lines, comparator);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Execute.java b/src/main/org/apache/tools/ant/taskdefs/Execute.java
index 15fca4081..06596fa3b 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Execute.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Execute.java
@@ -1,734 +1,734 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.BufferedReader;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.StringReader;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Vector;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.taskdefs.condition.Os;
 import org.apache.tools.ant.taskdefs.launcher.CommandLauncher;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.StringUtils;
 
 /**
  * Runs an external program.
  *
  * @since Ant 1.2
  */
 public class Execute {
 
     private static final int ONE_SECOND = 1000;
 
     /**
      * Invalid exit code. set to {@link Integer#MAX_VALUE}
      */
     public static final int INVALID = Integer.MAX_VALUE;
 
     private String[] cmdl = null;
     private String[] env = null;
     private int exitValue = INVALID;
     private ExecuteStreamHandler streamHandler;
     private final ExecuteWatchdog watchdog;
     private File workingDirectory = null;
     private Project project = null;
     private boolean newEnvironment = false;
 
     /** Controls whether the VM is used to launch commands, where possible. */
     private boolean useVMLauncher = true;
 
     private static String antWorkingDirectory = System.getProperty("user.dir");
     private static Map<String, String> procEnvironment = null;
 
     /** Used to destroy processes when the VM exits. */
     private static ProcessDestroyer processDestroyer = new ProcessDestroyer();
 
     /** Used for replacing env variables */
     private static boolean environmentCaseInSensitive = false;
 
     static {
         if (Os.isFamily("windows")) {
             environmentCaseInSensitive = true;
         }
     }
 
     /**
      * Set whether or not you want the process to be spawned.
      * Default is not spawned.
      *
      * @param spawn if true you do not want Ant
      *              to wait for the end of the process.
      *              Has no influence in here, the calling task contains
      *              and acts accordingly
      *
      * @since Ant 1.6
      * @deprecated
      */
     @Deprecated
     public void setSpawn(boolean spawn) {
         // Method did not do anything to begin with
     }
 
     /**
      * Find the list of environment variables for this process.
      *
      * @return a map containing the environment variables.
      * @since Ant 1.8.2
      */
     public static synchronized Map<String,String> getEnvironmentVariables() {
         if (procEnvironment != null) {
             return procEnvironment;
         }
         if (!Os.isFamily("openvms")) {
             try {
                 procEnvironment = System.getenv();
                 return procEnvironment;
             } catch (Exception x) {
                 x.printStackTrace();
             }
         }
 
         procEnvironment = new LinkedHashMap<String, String>();
         try {
             ByteArrayOutputStream out = new ByteArrayOutputStream();
             Execute exe = new Execute(new PumpStreamHandler(out));
             exe.setCommandline(getProcEnvCommand());
             // Make sure we do not recurse forever
             exe.setNewenvironment(true);
             int retval = exe.execute();
             if (retval != 0) {
                 // Just try to use what we got
             }
             BufferedReader in =
                 new BufferedReader(new StringReader(toString(out)));
 
             if (Os.isFamily("openvms")) {
                 procEnvironment = getVMSLogicals(in);
                 return procEnvironment;
             }
             String var = null;
             String line, lineSep = StringUtils.LINE_SEP;
             while ((line = in.readLine()) != null) {
                 if (line.indexOf('=') == -1) {
                     // Chunk part of previous env var (UNIX env vars can
                     // contain embedded new lines).
                     if (var == null) {
                         var = lineSep + line;
                     } else {
                         var += lineSep + line;
                     }
                 } else {
                     // New env var...append the previous one if we have it.
                     if (var != null) {
                         int eq = var.indexOf("=");
                         procEnvironment.put(var.substring(0, eq),
                                             var.substring(eq + 1));
                     }
                     var = line;
                 }
             }
             // Since we "look ahead" before adding, there's one last env var.
             if (var != null) {
                 int eq = var.indexOf("=");
                 procEnvironment.put(var.substring(0, eq), var.substring(eq + 1));
             }
         } catch (java.io.IOException exc) {
             exc.printStackTrace();
             // Just try to see how much we got
         }
         return procEnvironment;
     }
 
     /**
      * Find the list of environment variables for this process.
      *
      * @return a vector containing the environment variables.
      * The vector elements are strings formatted like variable = value.
      * @deprecated use #getEnvironmentVariables instead
      */
     @Deprecated
     public static synchronized Vector<String> getProcEnvironment() {
         Vector<String> v = new Vector<String>();
         for (Entry<String, String> entry : getEnvironmentVariables().entrySet()) {
             v.add(entry.getKey() + "=" + entry.getValue());
         }
         return v;
     }
 
     /**
      * This is the operation to get our environment.
      * It is a notorious troublespot pre-Java1.5, and should be approached
      * with extreme caution.
      *
      * @return
      */
     private static String[] getProcEnvCommand() {
         if (Os.isFamily("os/2")) {
             // OS/2 - use same mechanism as Windows 2000
             return new String[] {"cmd", "/c", "set"};
         } else if (Os.isFamily("windows")) {
             // Determine if we're running under XP/2000/NT or 98/95
             if (Os.isFamily("win9x")) {
                 // Windows 98/95
                 return new String[] {"command.com", "/c", "set"};
             } else {
                 // Windows XP/2000/NT/2003
                 return new String[] {"cmd", "/c", "set"};
             }
         } else if (Os.isFamily("z/os") || Os.isFamily("unix")) {
             // On most systems one could use: /bin/sh -c env
 
             // Some systems have /bin/env, others /usr/bin/env, just try
             String[] cmd = new String[1];
             if (new File("/bin/env").canRead()) {
                 cmd[0] = "/bin/env";
             } else if (new File("/usr/bin/env").canRead()) {
                 cmd[0] = "/usr/bin/env";
             } else {
                 // rely on PATH
                 cmd[0] = "env";
             }
             return cmd;
         } else if (Os.isFamily("netware") || Os.isFamily("os/400")) {
             // rely on PATH
             return new String[] {"env"};
         } else if (Os.isFamily("openvms")) {
             return new String[] {"show", "logical"};
         } else {
             // MAC OS 9 and previous
             // TODO: I have no idea how to get it, someone must fix it
             return null;
         }
     }
 
     /**
      * ByteArrayOutputStream#toString doesn't seem to work reliably on
      * OS/390, at least not the way we use it in the execution
      * context.
      *
      * @param bos the output stream that one wants to read.
      * @return the output stream as a string, read with
      * special encodings in the case of z/os and os/400.
      * @since Ant 1.5
      */
     public static String toString(ByteArrayOutputStream bos) {
         if (Os.isFamily("z/os")) {
             try {
                 return bos.toString("Cp1047");
             } catch (java.io.UnsupportedEncodingException e) {
                 // noop default encoding used
             }
         } else if (Os.isFamily("os/400")) {
             try {
                 return bos.toString("Cp500");
             } catch (java.io.UnsupportedEncodingException e) {
                 // noop default encoding used
             }
         }
         return bos.toString();
     }
 
     /**
      * Creates a new execute object using <code>PumpStreamHandler</code> for
      * stream handling.
      */
     public Execute() {
         this(new PumpStreamHandler(), null);
     }
 
     /**
      * Creates a new execute object.
      *
      * @param streamHandler the stream handler used to handle the input and
      *        output streams of the subprocess.
      */
     public Execute(ExecuteStreamHandler streamHandler) {
         this(streamHandler, null);
     }
 
     /**
      * Creates a new execute object.
      *
      * @param streamHandler the stream handler used to handle the input and
      *        output streams of the subprocess.
      * @param watchdog a watchdog for the subprocess or <code>null</code>
      *        to disable a timeout for the subprocess.
      */
     public Execute(ExecuteStreamHandler streamHandler,
                    ExecuteWatchdog watchdog) {
         setStreamHandler(streamHandler);
         this.watchdog = watchdog;
         // By default, use the shell launcher for VMS
         //
         if (Os.isFamily("openvms")) {
             useVMLauncher = false;
         }
     }
 
     /**
      * Set the stream handler to use.
      *
      * @param streamHandler ExecuteStreamHandler.
      * @since Ant 1.6
      */
     public void setStreamHandler(ExecuteStreamHandler streamHandler) {
         this.streamHandler = streamHandler;
     }
 
     /**
      * Returns the commandline used to create a subprocess.
      *
      * @return the commandline used to create a subprocess.
      */
     public String[] getCommandline() {
         return cmdl;
     }
 
     /**
      * Sets the commandline of the subprocess to launch.
      *
      * @param commandline the commandline of the subprocess to launch.
      */
     public void setCommandline(String[] commandline) {
         cmdl = commandline;
     }
 
     /**
      * Set whether to propagate the default environment or not.
      *
      * @param newenv whether to propagate the process environment.
      */
     public void setNewenvironment(boolean newenv) {
         newEnvironment = newenv;
     }
 
     /**
      * Returns the environment used to create a subprocess.
      *
      * @return the environment used to create a subprocess.
      */
     public String[] getEnvironment() {
         return (env == null || newEnvironment)
             ? env : patchEnvironment();
     }
 
     /**
      * Sets the environment variables for the subprocess to launch.
      *
      * @param env array of Strings, each element of which has
      * an environment variable settings in format <em>key=value</em>.
      */
     public void setEnvironment(String[] env) {
         this.env = env;
     }
 
     /**
      * Sets the working directory of the process to execute.
      *
      * <p>This is emulated using the antRun scripts unless the OS is
      * Windows NT in which case a cmd.exe is spawned,
      * or MRJ and setting user.dir works, or JDK 1.3 and there is
      * official support in java.lang.Runtime.
      *
      * @param wd the working directory of the process.
      */
     public void setWorkingDirectory(File wd) {
         workingDirectory =
             (wd == null || wd.getAbsolutePath().equals(antWorkingDirectory))
             ? null : wd;
     }
 
     /**
      * Return the working directory.
      *
      * @return the directory as a File.
      * @since Ant 1.7
      */
     public File getWorkingDirectory() {
         return workingDirectory == null ? new File(antWorkingDirectory)
                                         : workingDirectory;
     }
 
     /**
      * Set the name of the antRun script using the project's value.
      *
      * @param project the current project.
      * @throws BuildException not clear when it is going to throw an exception, but
      * it is the method's signature.
      */
     public void setAntRun(Project project) throws BuildException {
         this.project = project;
     }
 
     /**
      * Launch this execution through the VM, where possible, rather than through
      * the OS's shell. In some cases and operating systems using the shell will
      * allow the shell to perform additional processing such as associating an
      * executable with a script, etc.
      *
      * @param useVMLauncher true if exec should launch through the VM,
      *                   false if the shell should be used to launch the
      *                   command.
      */
     public void setVMLauncher(boolean useVMLauncher) {
         this.useVMLauncher = useVMLauncher;
     }
 
     /**
      * Creates a process that runs a command.
      *
      * @param project the Project, only used for logging purposes, may be null.
      * @param command the command to run.
      * @param env the environment for the command.
      * @param dir the working directory for the command.
      * @param useVM use the built-in exec command for JDK 1.3 if available.
      * @return the process started.
      * @throws IOException forwarded from the particular launcher used.
      * @since Ant 1.5
      */
     public static Process launch(Project project, String[] command,
                                  String[] env, File dir, boolean useVM)
         throws IOException {
         if (dir != null && !dir.exists()) {
             throw new BuildException(dir + " doesn't exist.");
         }
 
         CommandLauncher vmLauncher = CommandLauncher.getVMLauncher(project);
         CommandLauncher launcher = (useVM && vmLauncher != null)
             ? vmLauncher : CommandLauncher.getShellLauncher(project);
         return launcher.exec(project, command, env, dir);
     }
 
     /**
      * Runs a process defined by the command line and returns its exit status.
      *
      * @return the exit status of the subprocess or <code>INVALID</code>.
      * @exception java.io.IOException The exception is thrown, if launching
      *            of the subprocess failed.
      */
     public int execute() throws IOException {
         if (workingDirectory != null && !workingDirectory.exists()) {
             throw new BuildException(workingDirectory + " doesn't exist.");
         }
         final Process process = launch(project, getCommandline(),
                                        getEnvironment(), workingDirectory,
                                        useVMLauncher);
         try {
             streamHandler.setProcessInputStream(process.getOutputStream());
             streamHandler.setProcessOutputStream(process.getInputStream());
             streamHandler.setProcessErrorStream(process.getErrorStream());
         } catch (IOException e) {
             process.destroy();
             throw e;
         }
         streamHandler.start();
 
         try {
             // add the process to the list of those to destroy if the VM exits
             //
             processDestroyer.add(process);
 
             if (watchdog != null) {
                 watchdog.start(process);
             }
             waitFor(process);
 
             if (watchdog != null) {
                 watchdog.stop();
             }
             streamHandler.stop();
             closeStreams(process);
 
             if (watchdog != null) {
                 watchdog.checkException();
             }
             return getExitValue();
         } catch (ThreadDeath t) {
             // #31928: forcibly kill it before continuing.
             process.destroy();
             throw t;
         } finally {
             // remove the process to the list of those to destroy if
             // the VM exits
             //
             processDestroyer.remove(process);
         }
     }
 
     /**
      * Starts a process defined by the command line.
      * Ant will not wait for this process, nor log its output.
      *
      * @throws java.io.IOException The exception is thrown, if launching
      *            of the subprocess failed.
      * @since Ant 1.6
      */
     public void spawn() throws IOException {
         if (workingDirectory != null && !workingDirectory.exists()) {
             throw new BuildException(workingDirectory + " doesn't exist.");
         }
         final Process process = launch(project, getCommandline(),
                                        getEnvironment(), workingDirectory,
                                        useVMLauncher);
         if (Os.isFamily("windows")) {
             try {
                 Thread.sleep(ONE_SECOND);
             } catch (InterruptedException e) {
                 project.log("interruption in the sleep after having spawned a"
                             + " process", Project.MSG_VERBOSE);
             }
         }
         OutputStream dummyOut = new OutputStream() {
             @Override
             public void write(int b) throws IOException {
                 // Method intended to swallow whatever comes at it
             }
         };
 
         ExecuteStreamHandler handler = new PumpStreamHandler(dummyOut);
         handler.setProcessErrorStream(process.getErrorStream());
         handler.setProcessOutputStream(process.getInputStream());
         handler.start();
         process.getOutputStream().close();
 
         project.log("spawned process " + process.toString(),
                     Project.MSG_VERBOSE);
     }
 
     /**
      * Wait for a given process.
      *
      * @param process the process one wants to wait for.
      */
     protected void waitFor(Process process) {
         try {
             process.waitFor();
             setExitValue(process.exitValue());
         } catch (InterruptedException e) {
             process.destroy();
         }
     }
 
     /**
      * Set the exit value.
      *
      * @param value exit value of the process.
      */
     protected void setExitValue(int value) {
         exitValue = value;
     }
 
     /**
      * Query the exit value of the process.
      *
      * @return the exit value or Execute.INVALID if no exit value has
      * been received.
      */
     public int getExitValue() {
         return exitValue;
     }
 
     /**
      * Checks whether <code>exitValue</code> signals a failure on the current
      * system (OS specific).
      *
      * <p><b>Note</b> that this method relies on the conventions of
      * the OS, it will return false results if the application you are
      * running doesn't follow these conventions. One notable
      * exception is the Java VM provided by HP for OpenVMS - it will
      * return 0 if successful (like on any other platform), but this
      * signals a failure on OpenVMS. So if you execute a new Java VM
      * on OpenVMS, you cannot trust this method.</p>
      *
      * @param exitValue the exit value (return code) to be checked.
      * @return <code>true</code> if <code>exitValue</code> signals a failure.
      */
     public static boolean isFailure(int exitValue) {
         // on openvms even exit value signals failure;
         // for other platforms nonzero exit value signals failure
         return Os.isFamily("openvms")
             ? (exitValue % 2 == 0) : (exitValue != 0);
     }
 
     /**
      * Did this execute return in a failure.
      *
      * @see #isFailure(int)
      * @return true if and only if the exit code is interpreted as a failure
      * @since Ant1.7
      */
     public boolean isFailure() {
         return isFailure(getExitValue());
     }
 
     /**
      * Test for an untimely death of the process.
      *
      * @return true if a watchdog had to kill the process.
      * @since Ant 1.5
      */
     public boolean killedProcess() {
         return watchdog != null && watchdog.killedProcess();
     }
 
     /**
      * Patch the current environment with the new values from the user.
      *
      * @return the patched environment.
      */
     private String[] patchEnvironment() {
         // On OpenVMS Runtime#exec() doesn't support the environment array,
         // so we only return the new values which then will be set in
         // the generated DCL script, inheriting the parent process environment
         if (Os.isFamily("openvms")) {
             return env;
         }
         Map<String, String> osEnv =
             new LinkedHashMap<String, String>(getEnvironmentVariables());
         for (int i = 0; i < env.length; i++) {
             String keyValue = env[i];
             String key = keyValue.substring(0, keyValue.indexOf('='));
-            // Find the key in the current enviroment copy
+            // Find the key in the current environment copy
             // and remove it.
 
             // Try without changing case first
             if (osEnv.remove(key) == null && environmentCaseInSensitive) {
                 // not found, maybe perform a case insensitive search
 
                 for (String osEnvItem : osEnv.keySet()) {
                     // Nb: using default locale as key is a env name
                     if (osEnvItem.toLowerCase().equals(key.toLowerCase())) {
                         // Use the original casiness of the key
                         key = osEnvItem;
                         break;
                     }
                 }
             }
 
             // Add the key to the enviromnent copy
             osEnv.put(key, keyValue.substring(key.length() + 1));
         }
 
         ArrayList<String> l = new ArrayList<String>();
         for (Entry<String, String> entry : osEnv.entrySet()) {
             l.add(entry.getKey() + "=" + entry.getValue());
         }
         return l.toArray(new String[osEnv.size()]);
     }
 
     /**
      * A utility method that runs an external command. Writes the output and
      * error streams of the command to the project log.
      *
      * @param task The task that the command is part of. Used for logging
      * @param cmdline The command to execute.
      * @throws BuildException if the command does not exit successfully.
      */
     public static void runCommand(Task task, String[] cmdline)
         throws BuildException {
         try {
             task.log(Commandline.describeCommand(cmdline),
                      Project.MSG_VERBOSE);
             Execute exe = new Execute(
                 new LogStreamHandler(task, Project.MSG_INFO, Project.MSG_ERR));
             exe.setAntRun(task.getProject());
             exe.setCommandline(cmdline);
             int retval = exe.execute();
             if (isFailure(retval)) {
                 throw new BuildException(cmdline[0]
                     + " failed with return code " + retval, task.getLocation());
             }
         } catch (java.io.IOException exc) {
             throw new BuildException("Could not launch " + cmdline[0] + ": "
                 + exc, task.getLocation());
         }
     }
 
     /**
      * Close the streams belonging to the given Process.
      *
      * @param process the <code>Process</code>.
      */
     public static void closeStreams(Process process) {
         FileUtils.close(process.getInputStream());
         FileUtils.close(process.getOutputStream());
         FileUtils.close(process.getErrorStream());
     }
 
     /**
      * This method is VMS specific and used by getEnvironmentVariables().
      *
      * Parses VMS logicals from <code>in</code> and returns them as a Map.
      * <code>in</code> is expected to be the
      * output of "SHOW LOGICAL". The method takes care of parsing the output
      * correctly as well as making sure that a logical defined in multiple
      * tables only gets added from the highest order table. Logicals with
      * multiple equivalence names are mapped to a variable with multiple
      * values separated by a comma (,).
      */
     private static Map<String, String> getVMSLogicals(BufferedReader in)
         throws IOException {
         HashMap<String, String> logicals = new HashMap<String, String>();
         String logName = null, logValue = null, newLogName;
         String line = null;
         // CheckStyle:MagicNumber OFF
         while ((line = in.readLine()) != null) {
             // parse the VMS logicals into required format ("VAR=VAL[,VAL2]")
             if (line.startsWith("\t=")) {
                 // further equivalence name of previous logical
                 if (logName != null) {
                     logValue += "," + line.substring(4, line.length() - 1);
                 }
             } else if (line.startsWith("  \"")) {
                 // new logical?
                 if (logName != null) {
                     logicals.put(logName, logValue);
                 }
                 int eqIndex = line.indexOf('=');
                 newLogName = line.substring(3, eqIndex - 2);
                 if (logicals.containsKey(newLogName)) {
                     // already got this logical from a higher order table
                     logName = null;
                 } else {
                     logName = newLogName;
                     logValue = line.substring(eqIndex + 3, line.length() - 1);
                 }
             }
         }
         // CheckStyle:MagicNumber ON
         // Since we "look ahead" before adding, there's one last env var.
         if (logName != null) {
             logicals.put(logName, logValue);
         }
         return logicals;
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/MacroDef.java b/src/main/org/apache/tools/ant/taskdefs/MacroDef.java
index b38e1c690..63f68c5a8 100644
--- a/src/main/org/apache/tools/ant/taskdefs/MacroDef.java
+++ b/src/main/org/apache/tools/ant/taskdefs/MacroDef.java
@@ -1,851 +1,851 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 
 import org.apache.tools.ant.AntTypeDefinition;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.ComponentHelper;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.ProjectHelper;
 import org.apache.tools.ant.RuntimeConfigurable;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.TaskContainer;
 import org.apache.tools.ant.UnknownElement;
 
 /**
  * Describe class <code>MacroDef</code> here.
  *
  * @since Ant 1.6
  */
 public class MacroDef extends AntlibDefinition  {
 
     private NestedSequential nestedSequential;
     private String     name;
     private boolean    backTrace = true;
     private List<Attribute>       attributes = new ArrayList<Attribute>();
     private Map<String, TemplateElement>        elements   = new HashMap<String, TemplateElement>();
     private String     textName   = null;
     private Text       text       = null;
     private boolean    hasImplicitElement = false;
 
     /**
      * Name of the definition
      * @param name the name of the definition
      */
      public void setName(String name) {
         this.name = name;
     }
 
     /**
      * Add the text element.
      * @param text the nested text element to add
      * @since ant 1.6.1
      */
     public void addConfiguredText(Text text) {
         if (this.text != null) {
             throw new BuildException(
                 "Only one nested text element allowed");
         }
         if (text.getName() == null) {
             throw new BuildException(
                 "the text nested element needed a \"name\" attribute");
         }
         // Check if used by attributes
         for (Attribute attribute : attributes) {
             if (text.getName().equals(attribute.getName())) {
                 throw new BuildException(
                     "the name \"" + text.getName()
                     + "\" is already used as an attribute");
             }
         }
         this.text = text;
         this.textName = text.getName();
     }
 
     /**
      * @return the nested text element
      * @since ant 1.6.1
      */
     public Text getText() {
         return text;
     }
 
     /**
      * Set the backTrace attribute.
      *
      * @param backTrace if true and the macro instance generates
      *                  an error, a backtrace of the location within
      *                  the macro and call to the macro will be output.
      *                  if false, only the location of the call to the
      *                  macro will be shown. Default is true.
      * @since ant 1.7
      */
     public void setBackTrace(boolean backTrace) {
         this.backTrace = backTrace;
     }
 
     /**
      * @return the backTrace attribute.
      * @since ant 1.7
      */
     public boolean getBackTrace() {
         return backTrace;
     }
 
     /**
      * This is the sequential nested element of the macrodef.
      *
      * @return a sequential element to be configured.
      */
     public NestedSequential createSequential() {
         if (this.nestedSequential != null) {
             throw new BuildException("Only one sequential allowed");
         }
         this.nestedSequential = new NestedSequential();
         return this.nestedSequential;
     }
 
     /**
      * The class corresponding to the sequential nested element.
      * This is a simple task container.
      */
     public static class NestedSequential implements TaskContainer {
         private List<Task> nested = new ArrayList<Task>();
 
         /**
          * Add a task or type to the container.
          *
          * @param task an unknown element.
          */
         public void addTask(Task task) {
             nested.add(task);
         }
 
         /**
          * @return the list of unknown elements
          */
         public List<Task> getNested() {
             return nested;
         }
 
         /**
          * A compare function to compare this with another
          * NestedSequential.
          * It calls similar on the nested unknown elements.
          *
          * @param other the nested sequential to compare with.
          * @return true if they are similar, false otherwise
          */
         public boolean similar(NestedSequential other) {
             final int size = nested.size();
             if (size != other.nested.size()) {
                 return false;
             }
             for (int i = 0; i < size; ++i) {
                 UnknownElement me = (UnknownElement) nested.get(i);
                 UnknownElement o = (UnknownElement) other.nested.get(i);
                 if (!me.similar(o)) {
                     return false;
                 }
             }
             return true;
         }
     }
 
     /**
      * Convert the nested sequential to an unknown element
      * @return the nested sequential as an unknown element.
      */
     public UnknownElement getNestedTask() {
         UnknownElement ret = new UnknownElement("sequential");
         ret.setTaskName("sequential");
         ret.setNamespace("");
         ret.setQName("sequential");
         new RuntimeConfigurable(ret, "sequential");
         final int size = nestedSequential.getNested().size();
         for (int i = 0; i < size; ++i) {
             UnknownElement e =
                 (UnknownElement) nestedSequential.getNested().get(i);
             ret.addChild(e);
             ret.getWrapper().addChild(e.getWrapper());
         }
         return ret;
     }
 
     /**
      * Gets this macro's attribute (and define?) list.
      *
      * @return the nested Attributes
      */
     public List<Attribute> getAttributes() {
         return attributes;
     }
 
     /**
      * Gets this macro's elements.
      *
      * @return the map nested elements, keyed by element name, with
      *         {@link TemplateElement} values.
      */
     public Map<String, TemplateElement> getElements() {
         return elements;
     }
 
     /**
      * Check if a character is a valid character for an element or
      * attribute name.
      *
      * @param c the character to check
      * @return true if the character is a letter or digit or '.' or '-'
      *         attribute name
      */
     public static boolean isValidNameCharacter(char c) {
         // ? is there an xml api for this ?
         return Character.isLetterOrDigit(c) || c == '.' || c == '-';
     }
 
     /**
      * Check if a string is a valid name for an element or attribute.
      *
      * @param name the string to check
      * @return true if the name consists of valid name characters
      */
     private static boolean isValidName(String name) {
         if (name.length() == 0) {
             return false;
         }
         for (int i = 0; i < name.length(); ++i) {
             if (!isValidNameCharacter(name.charAt(i))) {
                 return false;
             }
         }
         return true;
     }
 
     /**
      * Add an attribute element.
      *
      * @param attribute an attribute nested element.
      */
     public void addConfiguredAttribute(Attribute attribute) {
         if (attribute.getName() == null) {
             throw new BuildException(
                 "the attribute nested element needed a \"name\" attribute");
         }
         if (attribute.getName().equals(textName)) {
             throw new BuildException(
                 "the name \"" + attribute.getName()
                 + "\" has already been used by the text element");
         }
         final int size = attributes.size();
         for (int i = 0; i < size; ++i) {
             Attribute att = (Attribute) attributes.get(i);
             if (att.getName().equals(attribute.getName())) {
                 throw new BuildException(
                     "the name \"" + attribute.getName()
                         + "\" has already been used in "
                         + "another attribute element");
             }
         }
         attributes.add(attribute);
     }
 
     /**
      * Add an element element.
      *
      * @param element an element nested element.
      */
     public void addConfiguredElement(TemplateElement element) {
         if (element.getName() == null) {
             throw new BuildException(
                 "the element nested element needed a \"name\" attribute");
         }
         if (elements.get(element.getName()) != null) {
             throw new BuildException(
                 "the element " + element.getName()
                 + " has already been specified");
         }
         if (hasImplicitElement
             || (element.isImplicit() && elements.size() != 0)) {
             throw new BuildException(
                 "Only one element allowed when using implicit elements");
         }
         hasImplicitElement = element.isImplicit();
         elements.put(element.getName(), element);
     }
 
     /**
      * Create a new ant type based on the embedded tasks and types.
      */
     public void execute() {
         if (nestedSequential == null) {
             throw new BuildException("Missing sequential element");
         }
         if (name == null) {
             throw new BuildException("Name not specified");
         }
 
         name = ProjectHelper.genComponentName(getURI(), name);
 
         MyAntTypeDefinition def = new MyAntTypeDefinition(this);
         def.setName(name);
         def.setClass(MacroInstance.class);
 
         ComponentHelper helper = ComponentHelper.getComponentHelper(
             getProject());
 
         helper.addDataTypeDefinition(def);
         log("creating macro  " + name, Project.MSG_VERBOSE);
     }
 
 
     /**
      * An attribute for the MacroDef task.
      *
      */
     public static class Attribute {
         private String name;
         private String defaultValue;
         private String description;
         private boolean doubleExpanding = true;
 
         /**
          * The name of the attribute.
          *
          * @param name the name of the attribute
          */
         public void setName(String name) {
             if (!isValidName(name)) {
                 throw new BuildException(
                     "Illegal name [" + name + "] for attribute");
             }
             this.name = name.toLowerCase(Locale.ENGLISH);
         }
 
         /**
          * @return the name of the attribute
          */
         public String getName() {
             return name;
         }
 
         /**
          * The default value to use if the parameter is not
          * used in the templated instance.
          *
          * @param defaultValue the default value
          */
         public void setDefault(String defaultValue) {
             this.defaultValue = defaultValue;
         }
 
         /**
          * @return the default value, null if not set
          */
         public String getDefault() {
             return defaultValue;
         }
 
         /**
          * @param desc Description of the element.
          * @since ant 1.6.1
          */
         public void setDescription(String desc) {
             description = desc;
         }
 
         /**
          * @return the description of the element, or <code>null</code> if
          *         no description is available.
          * @since ant 1.6.1
          */
         public String getDescription() {
             return description;
         }
 
         /**
          * See {@link #isDoubleExpanding} for explanation.
          * @param doubleExpanding true to expand twice, false for just once
          * @since Ant 1.8.3
          */
         public void setDoubleExpanding(boolean doubleExpanding) {
             this.doubleExpanding = doubleExpanding;
         }
 
         /**
          * Determines whether {@link RuntimeConfigurable#maybeConfigure(Project, boolean)} will reevaluate this property.
          * For compatibility reasons (#52621) it will, though for most applications (#42046) it should not.
          * @return true if expanding twice (the default), false for just once
          * @since Ant 1.8.3
          */
         public boolean isDoubleExpanding() {
             return doubleExpanding;
         }
 
         /**
          * equality method
          *
          * @param obj an <code>Object</code> value
          * @return a <code>boolean</code> value
          */
         public boolean equals(Object obj) {
             if (obj == null) {
                 return false;
             }
             if (obj.getClass() != getClass()) {
                 return false;
             }
             Attribute other = (Attribute) obj;
             if (name == null) {
                 if (other.name != null) {
                     return false;
                 }
             } else if (!name.equals(other.name)) {
                 return false;
             }
             if (defaultValue == null) {
                 if (other.defaultValue != null) {
                     return false;
                 }
             } else if (!defaultValue.equals(other.defaultValue)) {
                 return false;
             }
             return true;
         }
 
         /**
          * @return a hash code value for this object.
          */
         public int hashCode() {
             return objectHashCode(defaultValue) + objectHashCode(name);
         }
     }
 
     /**
      * A nested text element for the MacroDef task.
      * @since ant 1.6.1
      */
     public static class Text {
         private String  name;
         private boolean optional;
         private boolean trim;
         private String  description;
         private String  defaultString;
 
         /**
          * The name of the attribute.
          *
          * @param name the name of the attribute
          */
         public void setName(String name) {
             if (!isValidName(name)) {
                 throw new BuildException(
                     "Illegal name [" + name + "] for attribute");
             }
             this.name = name.toLowerCase(Locale.ENGLISH);
         }
 
         /**
          * @return the name of the attribute
          */
         public String getName() {
             return name;
         }
 
         /**
          * The optional attribute of the text element.
          *
          * @param optional if true this is optional
          */
         public void setOptional(boolean optional) {
             this.optional = optional;
         }
 
         /**
          * @return true if the text is optional
          */
         public boolean getOptional() {
             return optional;
         }
 
         /**
          * The trim attribute of the text element.
          *
          * @param trim if true this String.trim() is called on
          *             the contents of the text element.
          */
         public void setTrim(boolean trim) {
             this.trim = trim;
         }
 
         /**
          * @return true if the text is trim
          */
         public boolean getTrim() {
             return trim;
         }
 
         /**
          * @param desc Description of the text.
          */
         public void setDescription(String desc) {
             description = desc;
         }
 
         /**
          * @return the description of the text, or <code>null</code> if
          *         no description is available.
          */
         public String getDescription() {
             return description;
         }
 
         /**
          * @param defaultString default text for the string.
          */
         public void setDefault(String defaultString) {
             this.defaultString = defaultString;
         }
 
         /**
          * @return the default text if set, null otherwise.
          */
         public String getDefault() {
             return defaultString;
         }
 
         /**
          * equality method
          *
          * @param obj an <code>Object</code> value
          * @return a <code>boolean</code> value
          */
         public boolean equals(Object obj) {
             if (obj == null) {
                 return false;
             }
             if (obj.getClass() != getClass()) {
                 return false;
             }
             Text other = (Text) obj;
             return safeCompare(name, other.name)
                 && optional == other.optional
                 && trim == other.trim
                 && safeCompare(defaultString, other.defaultString);
         }
 
         /**
          * @return a hash code value for this object.
          */
         public int hashCode() {
             return objectHashCode(name);
         }
     }
 
     private static boolean safeCompare(Object a, Object b) {
         return a == null ? b == null : a.equals(b);
     }
 
     /**
      * A nested element for the MacroDef task.
      */
     public static class TemplateElement {
 
         private String name;
         private String description;
         private boolean optional = false;
         private boolean implicit = false;
 
         /**
          * Sets the name of this element.
          *
          * @param name the name of the element
          */
         public void setName(String name) {
             if (!isValidName(name)) {
                 throw new BuildException(
                     "Illegal name [" + name + "] for macro element");
             }
             this.name = name.toLowerCase(Locale.ENGLISH);
         }
 
         /**
          * Gets the name of this element.
          *
          * @return the name of the element.
          */
         public String getName() {
             return name;
         }
 
         /**
          * Sets a textual description of this element,
          * for build documentation purposes only.
          *
          * @param desc Description of the element.
          * @since ant 1.6.1
          */
         public void setDescription(String desc) {
             description = desc;
         }
 
         /**
          * Gets the description of this element.
          *
          * @return the description of the element, or <code>null</code> if
          *         no description is available.
          * @since ant 1.6.1
          */
         public String getDescription() {
             return description;
         }
 
         /**
          * Sets whether this element is optional.
          *
          * @param optional if true this element may be left out, default
          *                 is false.
          */
         public void setOptional(boolean optional) {
             this.optional = optional;
         }
 
         /**
          * Gets whether this element is optional.
          *
          * @return the optional attribute
          */
         public boolean isOptional() {
             return optional;
         }
 
         /**
          * Sets whether this element is implicit.
          *
          * @param implicit if true this element may be left out, default
          *                 is false.
          */
         public void setImplicit(boolean implicit) {
             this.implicit = implicit;
         }
 
         /**
          * Gets whether this element is implicit.
          *
          * @return the implicit attribute
          */
         public boolean isImplicit() {
             return implicit;
         }
 
         /**
          * equality method.
          *
          * @param obj an <code>Object</code> value
          * @return a <code>boolean</code> value
          */
         public boolean equals(Object obj) {
             if (obj == this) {
               return true;
             }
             if (obj == null || !obj.getClass().equals(getClass())) {
                 return false;
             }
             TemplateElement t = (TemplateElement) obj;
             return
                 (name == null ? t.name == null : name.equals(t.name))
                 && optional == t.optional
                 && implicit == t.implicit;
         }
 
         /**
          * @return a hash code value for this object.
          */
         public int hashCode() {
             return objectHashCode(name)
                 + (optional ? 1 : 0) + (implicit ? 1 : 0);
         }
 
     } // END static class TemplateElement
 
     /**
      * same or similar equality method for macrodef, ignores project and
      * runtime info.
      *
      * @param obj an <code>Object</code> value
-     * @param same if true test for sameness, otherwise just similiar
+     * @param same if true test for sameness, otherwise just similar
      * @return a <code>boolean</code> value
      */
     private boolean sameOrSimilar(Object obj, boolean same) {
         if (obj == this) {
             return true;
         }
 
         if (obj == null) {
             return false;
         }
         if (!obj.getClass().equals(getClass())) {
             return false;
         }
         MacroDef other = (MacroDef) obj;
         if (name == null) {
             return other.name == null;
         }
         if (!name.equals(other.name)) {
             return false;
         }
         // Allow two macro definitions with the same location
         // to be treated as similar - bugzilla 31215
         if (other.getLocation() != null
             && other.getLocation().equals(getLocation())
             && !same) {
             return true;
         }
         if (text == null) {
             if (other.text != null) {
                 return false;
             }
         } else {
             if (!text.equals(other.text)) {
                 return false;
             }
         }
         if (getURI() == null || getURI().equals("")
             || getURI().equals(ProjectHelper.ANT_CORE_URI)) {
             if (!(other.getURI() == null || other.getURI().equals("")
                   || other.getURI().equals(ProjectHelper.ANT_CORE_URI))) {
                 return false;
             }
         } else {
             if (!getURI().equals(other.getURI())) {
                 return false;
             }
         }
 
         if (!nestedSequential.similar(other.nestedSequential)) {
             return false;
         }
         if (!attributes.equals(other.attributes)) {
             return false;
         }
         if (!elements.equals(other.elements)) {
             return false;
         }
         return true;
     }
 
     /**
      * Similar method for this definition
      *
      * @param obj another definition
      * @return true if the definitions are similar
      */
     public boolean similar(Object obj) {
         return sameOrSimilar(obj, false);
     }
 
     /**
      * Equality method for this definition
      *
      * @param obj another definition
      * @return true if the definitions are the same
      */
     public boolean sameDefinition(Object obj) {
         return sameOrSimilar(obj, true);
     }
 
     /**
      * extends AntTypeDefinition, on create
      * of the object, the template macro definition
      * is given.
      */
     private static class MyAntTypeDefinition extends AntTypeDefinition {
         private MacroDef macroDef;
 
         /**
          * Creates a new <code>MyAntTypeDefinition</code> instance.
          *
          * @param macroDef a <code>MacroDef</code> value
          */
         public MyAntTypeDefinition(MacroDef macroDef) {
             this.macroDef = macroDef;
         }
 
         /**
          * Create an instance of the definition.
          * The instance may be wrapped in a proxy class.
          * @param project the current project
          * @return the created object
          */
         public Object create(Project project) {
             Object o = super.create(project);
             if (o == null) {
                 return null;
             }
             ((MacroInstance) o).setMacroDef(macroDef);
             return o;
         }
 
         /**
          * Equality method for this definition
          *
          * @param other another definition
          * @param project the current project
          * @return true if the definitions are the same
          */
         public boolean sameDefinition(AntTypeDefinition other, Project project) {
             if (!super.sameDefinition(other, project)) {
                 return false;
             }
             MyAntTypeDefinition otherDef = (MyAntTypeDefinition) other;
             return macroDef.sameDefinition(otherDef.macroDef);
         }
 
         /**
          * Similar method for this definition
          *
          * @param other another definition
          * @param project the current project
          * @return true if the definitions are the same
          */
         public boolean similarDefinition(
             AntTypeDefinition other, Project project) {
             if (!super.similarDefinition(other, project)) {
                 return false;
             }
             MyAntTypeDefinition otherDef = (MyAntTypeDefinition) other;
             return macroDef.similar(otherDef.macroDef);
         }
     }
 
     private static int objectHashCode(Object o) {
         if (o == null) {
             return 0;
         } else {
             return o.hashCode();
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/ManifestTask.java b/src/main/org/apache/tools/ant/taskdefs/ManifestTask.java
index 2d5958091..9b600db55 100644
--- a/src/main/org/apache/tools/ant/taskdefs/ManifestTask.java
+++ b/src/main/org/apache/tools/ant/taskdefs/ManifestTask.java
@@ -1,293 +1,293 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.util.Enumeration;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.taskdefs.Manifest.Attribute;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * Creates a manifest file for inclusion in a JAR, Ant task wrapper
  * around {@link Manifest Manifest}.  This task can be used to write a
  * Manifest file, optionally replacing or updating an existing file.
  *
  * @since Ant 1.5
  *
  * @ant.task category="java"
  */
 public class ManifestTask extends Task {
 
     /**
      * Specifies the valid characters which can be used in attribute names.
      * {@value}
      */
     public static final String VALID_ATTRIBUTE_CHARS =
         "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_";
 
     /**
      * Holds the real data.
      */
     private Manifest nestedManifest = new Manifest();
 
     /**
      * The file to which the manifest should be written when used as a task
      */
     private File manifestFile;
 
     /**
      * The mode with which the manifest file is written
      */
     private Mode mode;
 
     /**
      * The encoding of the manifest file
      */
     private String encoding;
 
     /**
      * whether to merge Class-Path attributes.
      */
     private boolean mergeClassPaths = false;
 
     /**
      * whether to flatten Class-Path attributes into a single one.
      */
     private boolean flattenClassPaths = false;
 
     /**
      * Helper class for Manifest's mode attribute.
      */
     public static class Mode extends EnumeratedAttribute {
         /**
          * Get Allowed values for the mode attribute.
          *
          * @return a String array of the allowed values.
          */
         public String[] getValues() {
             return new String[] {"update", "replace"};
         }
     }
 
     /**
      * Default constructor
      */
     public ManifestTask() {
         mode = new Mode();
         mode.setValue("replace");
     }
 
     /**
      * Add a section to the manifest
      *
      * @param section the manifest section to be added
      *
      * @exception ManifestException if the section is not valid.
      */
     public void addConfiguredSection(Manifest.Section section)
          throws ManifestException {
         Enumeration<String> attributeKeys = section.getAttributeKeys();
         while (attributeKeys.hasMoreElements()) {
             Attribute attribute = section.getAttribute(
                 attributeKeys.nextElement());
             checkAttribute(attribute);
         }
         nestedManifest.addConfiguredSection(section);
     }
 
     /**
      * Add an attribute to the manifest - it is added to the main section.
      *
      * @param attribute the attribute to be added.
      *
      * @exception ManifestException if the attribute is not valid.
      */
     public void addConfiguredAttribute(Manifest.Attribute attribute)
          throws ManifestException {
         checkAttribute(attribute);
         nestedManifest.addConfiguredAttribute(attribute);
     }
 
     /**
-     * Checks the attribute agains the Jar-specification.
+     * Checks the attribute against the Jar-specification.
      *
      * Jar-Specification <i>"Name-Value pairs and Sections"</i>: <pre>
      *   name:       alphanum *headerchar
      *   alphanum:   {A-Z} | {a-z} | {0-9}
      *   headerchar: alphanum | - | _
      * </pre>
      * So the resulting regexp would be <tt>[A-Za-z0-9][A-Za-z0-9-_]*</tt>.
      *
      * Because of JDK 1.2 compliance and the possible absence of a
      * regexp matcher we can not use regexps here. Instead we have to
      * check each character.
      *
      * @param attribute The attribute to check
      * @throws BuildException if the check fails
      */
     private void checkAttribute(Manifest.Attribute attribute) throws BuildException {
         String name = attribute.getName();
         char ch = name.charAt(0);
 
         if (ch == '-' || ch == '_') {
             throw new BuildException("Manifest attribute names must not start with '" + ch + "'.");
         }
 
         for (int i = 0; i < name.length(); i++) {
             ch = name.charAt(i);
             if (VALID_ATTRIBUTE_CHARS.indexOf(ch) < 0) {
                 throw new BuildException("Manifest attribute names must not contain '" + ch + "'");
             }
         }
     }
 
     /**
      * The name of the manifest file to create/update.
      * Required if used as a task.
      * @param f the Manifest file to be written
      */
     public void setFile(File f) {
         manifestFile = f;
     }
 
     /**
      * The encoding to use for reading in an existing manifest file
      * @param encoding the manifest file encoding.
      */
     public void setEncoding(String encoding) {
         this.encoding = encoding;
     }
 
     /**
      * Update policy: either "update" or "replace"; default is "replace".
      * @param m the mode value - update or replace.
      */
     public void setMode(Mode m) {
         mode = m;
     }
 
     /**
      * Whether to merge Class-Path attributes.
      *
      * @since Ant 1.8.0
      */
     public void setMergeClassPathAttributes(boolean b) {
         mergeClassPaths = b;
     }
 
     /**
      * Whether to flatten multi-valued attributes (i.e. Class-Path)
      * into a single one.
      *
      * @since Ant 1.8.0
      */
     public void setFlattenAttributes(boolean b) {
         flattenClassPaths = b;
     }
 
     /**
      * Create or update the Manifest when used as a task.
      *
      * @throws BuildException if the manifest cannot be written.
      */
     public void execute() throws BuildException {
         if (manifestFile == null) {
             throw new BuildException("the file attribute is required");
         }
 
         Manifest toWrite = Manifest.getDefaultManifest();
         Manifest current = null;
         BuildException error = null;
 
         if (manifestFile.exists()) {
             FileInputStream fis = null;
             InputStreamReader isr = null;
             try {
                 fis = new FileInputStream(manifestFile);
                 if (encoding == null) {
                     isr = new InputStreamReader(fis, "UTF-8");
                 } else {
                     isr = new InputStreamReader(fis, encoding);
                 }
                 current = new Manifest(isr);
             } catch (ManifestException m) {
                 error = new BuildException("Existing manifest " + manifestFile
                                            + " is invalid", m, getLocation());
             } catch (IOException e) {
                 error = new BuildException("Failed to read " + manifestFile,
                                            e, getLocation());
             } finally {
                 FileUtils.close(isr);
             }
         }
 
         //look for and print warnings
         for (Enumeration<String> e = nestedManifest.getWarnings();
                 e.hasMoreElements();) {
             log("Manifest warning: " + e.nextElement(),
                     Project.MSG_WARN);
         }
         try {
             if (mode.getValue().equals("update") && manifestFile.exists()) {
                 if (current != null) {
                     toWrite.merge(current, false, mergeClassPaths);
                 } else if (error != null) {
                     throw error;
                 }
             }
 
             toWrite.merge(nestedManifest, false, mergeClassPaths);
         } catch (ManifestException m) {
             throw new BuildException("Manifest is invalid", m, getLocation());
         }
 
         if (toWrite.equals(current)) {
             log("Manifest has not changed, do not recreate",
                 Project.MSG_VERBOSE);
             return;
         }
 
         PrintWriter w = null;
         try {
             FileOutputStream fos = new FileOutputStream(manifestFile);
             OutputStreamWriter osw = new OutputStreamWriter(fos, Manifest.JAR_ENCODING);
             w = new PrintWriter(osw);
             toWrite.write(w, flattenClassPaths);
             if (w.checkError()) {
                 throw new IOException("Encountered an error writing manifest");
             }
         } catch (IOException e) {
             throw new BuildException("Failed to write " + manifestFile,
                                      e, getLocation());
         } finally {
             FileUtils.close(w);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Replace.java b/src/main/org/apache/tools/ant/taskdefs/Replace.java
index 981663ef7..9aa9fe8e6 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Replace.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Replace.java
@@ -1,955 +1,955 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.Reader;
 import java.io.Writer;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Properties;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.StringUtils;
 
 /**
  * Replaces all occurrences of one or more string tokens with given
  * values in the indicated files. Each value can be either a string
  * or the value of a property available in a designated property file.
  * If you want to replace a text that crosses line boundaries, you
  * must use a nested <code>&lt;replacetoken&gt;</code> element.
  *
  * @since Ant 1.1
  *
  * @ant.task category="filesystem"
  */
 public class Replace extends MatchingTask {
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     private File sourceFile = null;
     private NestedString token = null;
     private NestedString value = new NestedString();
 
     private Resource propertyResource = null;
     private Resource replaceFilterResource = null;
     private Properties properties = null;
     private ArrayList replacefilters = new ArrayList();
 
     private File dir = null;
 
     private int fileCount;
     private int replaceCount;
     private boolean summary = false;
 
     /** The encoding used to read and write files - if null, uses default */
     private String encoding = null;
 
     private Union resources;
 
     private boolean preserveLastModified = false;
     private boolean failOnNoReplacements = false;
 
     /**
      * An inline string to use as the replacement text.
      */
     public class NestedString {
 
         private boolean expandProperties = false;
         private StringBuffer buf = new StringBuffer();
 
         /**
          * Whether properties should be expanded in nested test.
          *
          * <p>If you use this class via its Java interface the text
          * you add via {@link #addText addText} has most likely been
          * expanded already so you do <b>not</b> want to set this to
          * true.</p>
          *
          * @since Ant 1.8.0
          */
         public void setExpandProperties(boolean b) {
             expandProperties = b;
         }
 
         /**
          * The text of the element.
          *
          * @param val the string to add
          */
         public void addText(String val) {
             buf.append(val);
         }
 
         /**
          * @return the text
          */
         public String getText() {
             String s = buf.toString();
             return expandProperties ? getProject().replaceProperties(s) : s;
         }
     }
 
     /**
      * A filter to apply.
      */
     public class Replacefilter {
         private NestedString token;
         private NestedString value;
         private String replaceValue;
         private String property;
 
         private StringBuffer inputBuffer;
         private StringBuffer outputBuffer = new StringBuffer();
 
         /**
          * Validate the filter's configuration.
          * @throws BuildException if any part is invalid.
          */
         public void validate() throws BuildException {
             //Validate mandatory attributes
             if (token == null) {
                 String message = "token is a mandatory for replacefilter.";
                 throw new BuildException(message);
             }
 
             if ("".equals(token.getText())) {
                 String message = "The token must not be an empty "
                     + "string.";
                 throw new BuildException(message);
             }
 
             //value and property are mutually exclusive attributes
             if ((value != null) && (property != null)) {
                 String message = "Either value or property "
                     + "can be specified, but a replacefilter "
                     + "element cannot have both.";
                 throw new BuildException(message);
             }
 
             if ((property != null)) {
                 //the property attribute must have access to a property file
                 if (propertyResource == null) {
                     String message = "The replacefilter's property attribute "
                         + "can only be used with the replacetask's "
                         + "propertyFile/Resource attribute.";
                     throw new BuildException(message);
                 }
 
                 //Make sure property exists in property file
                 if (properties == null
                     || properties.getProperty(property) == null) {
                     String message = "property \"" + property
                         + "\" was not found in " + propertyResource.getName();
                     throw new BuildException(message);
                 }
             }
 
             replaceValue = getReplaceValue();
         }
 
         /**
          * Get the replacement value for this filter token.
          * @return the replacement value
          */
         public String getReplaceValue() {
             if (property != null) {
                 return properties.getProperty(property);
             } else if (value != null) {
                 return value.getText();
             } else if (Replace.this.value != null) {
                 return Replace.this.value.getText();
             } else {
                 //Default is empty string
                 return "";
             }
         }
 
         /**
          * Set the token to replace.
          * @param t <code>String</code> token.
          */
         public void setToken(String t) {
             createReplaceToken().addText(t);
         }
 
         /**
          * Get the string to search for.
          * @return current <code>String</code> token.
          */
         public String getToken() {
             return token.getText();
         }
 
         /**
          * The replacement string; required if <code>property</code>
          * is not set.
          * @param value <code>String</code> value to replace.
          */
         public void setValue(String value) {
             createReplaceValue().addText(value);
         }
 
         /**
          * Get replacement <code>String</code>.
          * @return replacement or null.
          */
         public String getValue() {
             return value.getText();
         }
 
         /**
          * Set the name of the property whose value is to serve as
          * the replacement value; required if <code>value</code> is not set.
          * @param property property name.
          */
         public void setProperty(String property) {
             this.property = property;
         }
 
         /**
          * Get the name of the property whose value is to serve as
          * the replacement value.
          * @return property or null.
          */
         public String getProperty() {
             return property;
         }
 
         /**
          * Create a token to filter as the text of a nested element.
          * @return nested token <code>NestedString</code> to configure.
          * @since Ant 1.8.0
          */
         public NestedString createReplaceToken() {
             if (token == null) {
                 token = new NestedString();
             }
             return token;
         }
 
         /**
          * Create a string to replace the token as the text of a nested element.
          * @return replacement value <code>NestedString</code> to configure.
          * @since Ant 1.8.0
          */
         public NestedString createReplaceValue() {
             if (value == null) {
                 value = new NestedString();
             }
             return value;
         }
 
         /**
          * Retrieves the output buffer of this filter. The filter guarantees
          * that data is only appended to the end of this StringBuffer.
          * @return The StringBuffer containing the output of this filter.
          */
         StringBuffer getOutputBuffer() {
             return outputBuffer;
         }
 
         /**
          * Sets the input buffer for this filter.
          * The filter expects from the component providing the input that data
          * is only added by that component to the end of this StringBuffer.
          * This StringBuffer will be modified by this filter, and expects that
          * another component will only apped to this StringBuffer.
          * @param input The input for this filter.
          */
         void setInputBuffer(StringBuffer input) {
             inputBuffer = input;
         }
 
         /**
          * Processes the buffer as far as possible. Takes into account that
          * appended data may make it possible to replace the end of the already
          * received data, when the token is split over the "old" and the "new"
          * part.
          * @return true if some data has been made available in the
          *         output buffer.
          */
         boolean process() {
             String t = getToken();
             if (inputBuffer.length() > t.length()) {
                 int pos = replace();
                 pos = Math.max((inputBuffer.length() - t.length()), pos);
                 outputBuffer.append(inputBuffer.substring(0, pos));
                 inputBuffer.delete(0, pos);
                 return true;
             }
             return false;
         }
 
         /**
          * Processes the buffer to the end. Does not take into account that
          * appended data may make it possible to replace the end of the already
          * received data.
          */
         void flush() {
             replace();
             outputBuffer.append(inputBuffer);
             inputBuffer.delete(0, inputBuffer.length());
         }
 
         /**
          * Performs the replace operation.
          * @return The position of the last character that was inserted as
          *         replacement.
          */
         private int replace() {
             String t = getToken();
             int found = inputBuffer.indexOf(t);
             int pos = -1;
             final int tokenLength = t.length();
             final int replaceValueLength = replaceValue.length();
             while (found >= 0) {
                 inputBuffer.replace(found, found + tokenLength, replaceValue);
                 pos = found + replaceValueLength;
                 found = inputBuffer.indexOf(t, pos);
                 ++replaceCount;
             }
             return pos;
         }
     }
 
     /**
      * Class reading a file in small chunks, and presenting these chunks in
      * a StringBuffer. Compatible with the Replacefilter.
      * @since 1.7
      */
     private class FileInput /* JDK 5: implements Closeable */ {
         private StringBuffer outputBuffer;
         private final InputStream is;
         private Reader reader;
         private char[] buffer;
         private static final int BUFF_SIZE = 4096;
 
         /**
          * Constructs the input component. Opens the file for reading.
          * @param source The file to read from.
          * @throws IOException When the file cannot be read from.
          */
         FileInput(File source) throws IOException {
             outputBuffer = new StringBuffer();
             buffer = new char[BUFF_SIZE];
             is = new FileInputStream(source);
             try {
                 reader = new BufferedReader(encoding != null ? new InputStreamReader(is, encoding) : new InputStreamReader(is));
             } finally {
                 if (reader == null) {
                     is.close();
                 }
             }
         }
 
         /**
          * Retrieves the output buffer of this filter. The component guarantees
          * that data is only appended to the end of this StringBuffer.
          * @return The StringBuffer containing the output of this filter.
          */
         StringBuffer getOutputBuffer() {
             return outputBuffer;
         }
 
         /**
          * Reads some data from the file.
          * @return true when the end of the file has not been reached.
          * @throws IOException When the file cannot be read from.
          */
         boolean readChunk() throws IOException {
             int bufferLength = 0;
             bufferLength = reader.read(buffer);
             if (bufferLength < 0) {
                 return false;
             }
             outputBuffer.append(new String(buffer, 0, bufferLength));
             return true;
         }
 
         /**
          * Closes the file.
          * @throws IOException When the file cannot be closed.
          */
         public void close() throws IOException {
             is.close();
         }
 
     }
 
     /**
      * Component writing a file in chunks, taking the chunks from the
      * Replacefilter.
      * @since 1.7
      */
     private class FileOutput /* JDK 5: implements Closeable */ {
         private StringBuffer inputBuffer;
         private final OutputStream os;
         private Writer writer;
 
         /**
          * Constructs the output component. Opens the file for writing.
          * @param out The file to read to.
          * @throws IOException When the file cannot be read from.
          */
         FileOutput(File out) throws IOException {
             os = new FileOutputStream(out);
             try {
                 writer = new BufferedWriter(encoding != null ? new OutputStreamWriter(os, encoding) : new OutputStreamWriter(os));
             } finally {
                 if (writer == null) {
                     os.close();
                 }
             }
         }
 
         /**
          * Sets the input buffer for this component.
          * The filter expects from the component providing the input that data
          * is only added by that component to the end of this StringBuffer.
          * This StringBuffer will be modified by this filter, and expects that
          * another component will only append to this StringBuffer.
          * @param input The input for this filter.
          */
         void setInputBuffer(StringBuffer input) {
             inputBuffer = input;
         }
 
         /**
          * Writes the buffer as far as possible.
          * @return false to be inline with the Replacefilter.
          * (Yes defining an interface crossed my mind, but would publish the
          * internal behavior.)
          * @throws IOException when the output cannot be written.
          */
         boolean process() throws IOException {
             writer.write(inputBuffer.toString());
             inputBuffer.delete(0, inputBuffer.length());
             return false;
         }
 
         /**
          * Processes the buffer to the end.
          * @throws IOException when the output cannot be flushed.
          */
         void flush() throws IOException {
             process();
             writer.flush();
         }
 
         /**
          * Closes the file.
          * @throws IOException When the file cannot be closed.
          */
         public void close() throws IOException {
             os.close();
         }
 
     }
 
     /**
      * Do the execution.
-     * @throws BuildException if we cant build
+     * @throws BuildException if we can't build
      */
     public void execute() throws BuildException {
 
         ArrayList savedFilters = (ArrayList) replacefilters.clone();
         Properties savedProperties =
             properties == null ? null : (Properties) properties.clone();
 
         if (token != null) {
             // line separators in values and tokens are "\n"
             // in order to compare with the file contents, replace them
             // as needed
             StringBuffer val = new StringBuffer(value.getText());
             stringReplace(val, "\r\n", "\n");
             stringReplace(val, "\n", StringUtils.LINE_SEP);
             StringBuffer tok = new StringBuffer(token.getText());
             stringReplace(tok, "\r\n", "\n");
             stringReplace(tok, "\n", StringUtils.LINE_SEP);
             Replacefilter firstFilter = createPrimaryfilter();
             firstFilter.setToken(tok.toString());
             firstFilter.setValue(val.toString());
         }
 
         try {
             if (replaceFilterResource != null) {
                 Properties props = getProperties(replaceFilterResource);
                 Iterator e = props.keySet().iterator();
                 while (e.hasNext()) {
                     String tok =  e.next().toString();
                     Replacefilter replaceFilter = createReplacefilter();
                     replaceFilter.setToken(tok);
                     replaceFilter.setValue(props.getProperty(tok));
                 }
             }
 
             validateAttributes();
 
             if (propertyResource != null) {
                 properties = getProperties(propertyResource);
             }
 
             validateReplacefilters();
             fileCount = 0;
             replaceCount = 0;
 
             if (sourceFile != null) {
                 processFile(sourceFile);
             }
 
             if (dir != null) {
                 DirectoryScanner ds = super.getDirectoryScanner(dir);
                 String[] srcs = ds.getIncludedFiles();
 
                 for (int i = 0; i < srcs.length; i++) {
                     File file = new File(dir, srcs[i]);
                     processFile(file);
                 }
             }
 
             if (resources != null) {
                 for (Resource r : resources) {
                     FileProvider fp =
                     r.as(FileProvider.class);
                     processFile(fp.getFile());
                 }
             }
 
             if (summary) {
                 log("Replaced " + replaceCount + " occurrences in "
                     + fileCount + " files.", Project.MSG_INFO);
             }
             if (failOnNoReplacements && replaceCount == 0) {
                 throw new BuildException("didn't replace anything");
             }
         } finally {
             replacefilters = savedFilters;
             properties = savedProperties;
         } // end of finally
 
     }
 
     /**
      * Validate attributes provided for this task in .xml build file.
      *
      * @exception BuildException if any supplied attribute is invalid or any
      * mandatory attribute is missing.
      */
     public void validateAttributes() throws BuildException {
         if (sourceFile == null && dir == null && resources == null) {
             String message = "Either the file or the dir attribute "
                 + "or nested resources must be specified";
             throw new BuildException(message, getLocation());
         }
         if (propertyResource != null && !propertyResource.isExists()) {
             String message = "Property file " + propertyResource.getName()
                 + " does not exist.";
             throw new BuildException(message, getLocation());
         }
         if (token == null && replacefilters.size() == 0) {
             String message = "Either token or a nested replacefilter "
                 + "must be specified";
             throw new BuildException(message, getLocation());
         }
         if (token != null && "".equals(token.getText())) {
             String message = "The token attribute must not be an empty string.";
             throw new BuildException(message, getLocation());
         }
     }
 
     /**
      * Validate nested elements.
      *
      * @exception BuildException if any supplied attribute is invalid or any
      * mandatory attribute is missing.
      */
     public void validateReplacefilters()
             throws BuildException {
         final int size = replacefilters.size();
         for (int i = 0; i < size; i++) {
             Replacefilter element =
                 (Replacefilter) replacefilters.get(i);
             element.validate();
         }
     }
 
     /**
      * Load a properties file.
      * @param propertyFile the file to load the properties from.
      * @return loaded <code>Properties</code> object.
      * @throws BuildException if the file could not be found or read.
      */
     public Properties getProperties(File propertyFile) throws BuildException {
         return getProperties(new FileResource(getProject(), propertyFile));
     }
 
     /**
      * Load a properties resource.
      * @param propertyResource the resource to load the properties from.
      * @return loaded <code>Properties</code> object.
      * @throws BuildException if the resource could not be found or read.
      * @since Ant 1.8.0
      */
     public Properties getProperties(Resource propertyResource)
         throws BuildException {
         Properties props = new Properties();
 
         InputStream in = null;
         try {
             in = propertyResource.getInputStream();
             props.load(in);
         } catch (IOException e) {
             String message = "Property resource (" + propertyResource.getName()
                 + ") cannot be loaded.";
             throw new BuildException(message);
         } finally {
             FileUtils.close(in);
         }
 
         return props;
     }
 
     /**
      * Perform the replacement on the given file.
      *
      * The replacement is performed on a temporary file which then
      * replaces the original file.
      *
      * @param src the source <code>File</code>.
      */
     private void processFile(File src) throws BuildException {
         if (!src.exists()) {
             throw new BuildException("Replace: source file " + src.getPath()
                                      + " doesn't exist", getLocation());
         }
 
         int repCountStart = replaceCount;
         logFilterChain(src.getPath());
 
         try {
             File temp = FILE_UTILS.createTempFile("rep", ".tmp",
                     src.getParentFile(), false, true);
             try {
                 FileInput in = new FileInput(src);
                 try {
                     FileOutput out = new FileOutput(temp);
                     try {
                         out.setInputBuffer(buildFilterChain(in.getOutputBuffer()));
 
                         while (in.readChunk()) {
                             if (processFilterChain()) {
                                 out.process();
                             }
                         }
 
                         flushFilterChain();
 
                         out.flush();
                     } finally {
                         out.close();
                     }
                 } finally {
                     in.close();
                 }
                 boolean changes = (replaceCount != repCountStart);
                 if (changes) {
                     fileCount++;
                     long origLastModified = src.lastModified();
                     FILE_UTILS.rename(temp, src);
                     if (preserveLastModified) {
                         FILE_UTILS.setFileLastModified(src, origLastModified);
                     }
                 }
             } finally {
                 if (temp.isFile() && !temp.delete()) {
                     temp.deleteOnExit();
                 }
             }
         } catch (IOException ioe) {
             throw new BuildException("IOException in " + src + " - "
                     + ioe.getClass().getName() + ":"
                     + ioe.getMessage(), ioe, getLocation());
         }
     }
 
     /**
      * Flushes all filters.
      */
     private void flushFilterChain() {
         final int size = replacefilters.size();
         for (int i = 0; i < size; i++) {
             Replacefilter filter = (Replacefilter) replacefilters.get(i);
             filter.flush();
         }
     }
 
     /**
      * Performs the normal processing of the filters.
      * @return true if the filter chain produced new output.
      */
     private boolean processFilterChain() {
         final int size = replacefilters.size();
         for (int i = 0; i < size; i++) {
             Replacefilter filter = (Replacefilter) replacefilters.get(i);
             if (!filter.process()) {
                 return false;
             }
         }
         return true;
     }
 
     /**
      * Creates the chain of filters to operate.
      * @param inputBuffer <code>StringBuffer</code> containing the input for the
      *                    first filter.
      * @return <code>StringBuffer</code> containing the output of the last filter.
      */
     private StringBuffer buildFilterChain(StringBuffer inputBuffer) {
         StringBuffer buf = inputBuffer;
         final int size = replacefilters.size();
         for (int i = 0; i < size; i++) {
             Replacefilter filter = (Replacefilter) replacefilters.get(i);
             filter.setInputBuffer(buf);
             buf = filter.getOutputBuffer();
         }
         return buf;
     }
 
     /**
      * Logs the chain of filters to operate on the file.
      * @param filename <code>String</code>.
      */
     private void logFilterChain(String filename) {
         final int size = replacefilters.size();
         for (int i = 0; i < size; i++) {
             Replacefilter filter = (Replacefilter) replacefilters.get(i);
             log("Replacing in " + filename + ": " + filter.getToken()
                     + " --> " + filter.getReplaceValue(), Project.MSG_VERBOSE);
         }
     }
     /**
      * Set the source file; required unless <code>dir</code> is set.
      * @param file source <code>File</code>.
      */
     public void setFile(File file) {
         this.sourceFile = file;
     }
 
     /**
      * Indicates whether a summary of the replace operation should be
      * produced, detailing how many token occurrences and files were
      * processed; optional, default=<code>false</code>.
      *
      * @param summary <code>boolean</code> whether a summary of the
      *                replace operation should be logged.
      */
     public void setSummary(boolean summary) {
         this.summary = summary;
     }
 
 
     /**
      * Sets the name of a property file containing filters; optional.
      * Each property will be treated as a replacefilter where token is the name
      * of the property and value is the value of the property.
      * @param replaceFilterFile <code>File</code> to load.
      */
     public void setReplaceFilterFile(File replaceFilterFile) {
         setReplaceFilterResource(new FileResource(getProject(),
                                                   replaceFilterFile));
     }
 
     /**
      * Sets the name of a resource containing filters; optional.
      * Each property will be treated as a replacefilter where token is the name
      * of the property and value is the value of the property.
      * @param replaceFilter <code>Resource</code> to load.
      * @since Ant 1.8.0
      */
     public void setReplaceFilterResource(Resource replaceFilter) {
         this.replaceFilterResource = replaceFilter;
     }
 
     /**
      * The base directory to use when replacing a token in multiple files;
      * required if <code>file</code> is not defined.
      * @param dir <code>File</code> representing the base directory.
      */
     public void setDir(File dir) {
         this.dir = dir;
     }
 
     /**
      * Set the string token to replace; required unless a nested
      * <code>replacetoken</code> element or the
      * <code>replacefilterresource</code> attribute is used.
      * @param token token <code>String</code>.
      */
     public void setToken(String token) {
         createReplaceToken().addText(token);
     }
 
     /**
      * Set the string value to use as token replacement;
      * optional, default is the empty string "".
      * @param value replacement value.
      */
     public void setValue(String value) {
         createReplaceValue().addText(value);
     }
 
     /**
      * Set the file encoding to use on the files read and written by the task;
      * optional, defaults to default JVM encoding.
      *
      * @param encoding the encoding to use on the files.
      */
     public void setEncoding(String encoding) {
         this.encoding = encoding;
     }
 
     /**
      * Create a token to filter as the text of a nested element.
      * @return nested token <code>NestedString</code> to configure.
      */
     public NestedString createReplaceToken() {
         if (token == null) {
             token = new NestedString();
         }
         return token;
     }
 
     /**
      * Create a string to replace the token as the text of a nested element.
      * @return replacement value <code>NestedString</code> to configure.
      */
     public NestedString createReplaceValue() {
         return value;
     }
 
     /**
      * The name of a property file from which properties specified using nested
      * <code>&lt;replacefilter&gt;</code> elements are drawn; required only if
      * the <i>property</i> attribute of <code>&lt;replacefilter&gt;</code> is used.
      * @param propertyFile <code>File</code> to load.
      */
     public void setPropertyFile(File propertyFile) {
         setPropertyResource(new FileResource(propertyFile));
     }
 
     /**
      * A resource from which properties specified using nested
      * <code>&lt;replacefilter&gt;</code> elements are drawn; required
      * only if the <i>property</i> attribute of
      * <code>&lt;replacefilter&gt;</code> is used.
      * @param propertyResource <code>Resource</code> to load.
      *
      * @since Ant 1.8.0
      */
     public void setPropertyResource(Resource propertyResource) {
         this.propertyResource = propertyResource;
     }
 
     /**
      * Add a nested &lt;replacefilter&gt; element.
      * @return a nested <code>Replacefilter</code> object to be configured.
      */
     public Replacefilter createReplacefilter() {
         Replacefilter filter = new Replacefilter();
         replacefilters.add(filter);
         return filter;
     }
 
     /**
      * Support arbitrary file system based resource collections.
      *
      * @since Ant 1.8.0
      */
     public void addConfigured(ResourceCollection rc) {
         if (!rc.isFilesystemOnly()) {
             throw new BuildException("only filesystem resources are supported");
         }
         if (resources == null) {
             resources = new Union();
         }
         resources.add(rc);
     }
 
     /**
      * Whether the file timestamp shall be preserved even if the file
      * is modified.
      *
      * @since Ant 1.8.0
      */
     public void setPreserveLastModified(boolean b) {
         preserveLastModified = b;
     }
 
     /**
      * Whether the build should fail if nothing has been replaced.
      *
      * @since Ant 1.8.0
      */
     public void setFailOnNoReplacements(boolean b) {
         failOnNoReplacements = b;
     }
 
     /**
      * Adds the token and value as first &lt;replacefilter&gt; element.
      * The token and value are always processed first.
      * @return a nested <code>Replacefilter</code> object to be configured.
      */
     private Replacefilter createPrimaryfilter() {
         Replacefilter filter = new Replacefilter();
         replacefilters.add(0, filter);
         return filter;
     }
 
     /**
      * Replace occurrences of str1 in StringBuffer str with str2.
      */
     private void stringReplace(StringBuffer str, String str1, String str2) {
         int found = str.indexOf(str1);
         final int str1Length = str1.length();
         final int str2Length = str2.length();
         while (found >= 0) {
             str.replace(found, found + str1Length, str2);
             found = str.indexOf(str1, found + str2Length);
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/SignJar.java b/src/main/org/apache/tools/ant/taskdefs/SignJar.java
index f971001fa..fc31b1d3d 100644
--- a/src/main/org/apache/tools/ant/taskdefs/SignJar.java
+++ b/src/main/org/apache/tools/ant/taskdefs/SignJar.java
@@ -1,645 +1,645 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.IOException;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.condition.IsSigned;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.IdentityMapper;
 import org.apache.tools.ant.util.ResourceUtils;
 
 /**
  * Signs JAR or ZIP files with the javasign command line tool. The tool detailed
  * dependency checking: files are only signed if they are not signed. The
  * <tt>signjar</tt> attribute can point to the file to generate; if this file
  * exists then its modification date is used as a cue as to whether to resign
  * any JAR file.
  *
  * Timestamp driven signing is based on the unstable and inadequately documented
  * information in the Java1.5 docs
  * @see <a href="http://java.sun.com/j2se/1.5.0/docs/guide/security/time-of-signing-beta1.html">
  * beta documentation</a>
  * @ant.task category="java"
  * @since Ant 1.1
  */
 public class SignJar extends AbstractJarSignerTask {
     // CheckStyle:VisibilityModifier OFF - bc
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * name to a signature file
      */
     protected String sigfile;
 
     /**
      * name of a single jar
      */
     protected File signedjar;
 
     /**
      * flag for internal sf signing
      */
     protected boolean internalsf;
 
     /**
      * sign sections only?
      */
     protected boolean sectionsonly;
 
     /**
      * flag to preserve timestamp on modified files
      */
     private boolean preserveLastModified;
 
     /**
      * Whether to assume a jar which has an appropriate .SF file in is already
      * signed.
      */
     protected boolean lazy;
 
     /**
      * the output directory when using paths.
      */
     protected File destDir;
 
     /**
      * mapper for todir work
      */
     private FileNameMapper mapper;
 
     /**
      * URL for a tsa; null implies no tsa support
      */
     protected String tsaurl;
 
     /**
      * Proxy host to be used when connecting to TSA server
      */
     protected String tsaproxyhost;
 
     /**
      * Proxy port to be used when connecting to TSA server
      */
     protected String tsaproxyport;
 
     /**
      * alias for the TSA in the keystore
      */
     protected String tsacert;
 
     /**
      * force signing even if the jar is already signed.
      */
     private boolean force = false;
 
     /**
      * signature algorithm
      */
     private String sigAlg;
 
     /**
      * digest algorithm
      */
     private String digestAlg;
 
     /**
      * error string for unit test verification: {@value}
      */
     public static final String ERROR_TODIR_AND_SIGNEDJAR
             = "'destdir' and 'signedjar' cannot both be set";
     /**
      * error string for unit test verification: {@value}
      */
     public static final String ERROR_TOO_MANY_MAPPERS = "Too many mappers";
     /**
      * error string for unit test verification {@value}
      */
     public static final String ERROR_SIGNEDJAR_AND_PATHS
         = "You cannot specify the signed JAR when using paths or filesets";
     /**
      * error string for unit test verification: {@value}
      */
     public static final String ERROR_BAD_MAP = "Cannot map source file to anything sensible: ";
     /**
      * error string for unit test verification: {@value}
      */
     public static final String ERROR_MAPPER_WITHOUT_DEST
         = "The destDir attribute is required if a mapper is set";
     /**
      * error string for unit test verification: {@value}
      */
     public static final String ERROR_NO_ALIAS = "alias attribute must be set";
     /**
      * error string for unit test verification: {@value}
      */
     public static final String ERROR_NO_STOREPASS = "storepass attribute must be set";
     // CheckStyle:VisibilityModifier ON
 
     /**
      * name of .SF/.DSA file; optional
      *
      * @param sigfile the name of the .SF/.DSA file
      */
     public void setSigfile(final String sigfile) {
         this.sigfile = sigfile;
     }
 
     /**
      * name of signed JAR file; optional
      *
      * @param signedjar the name of the signed jar file
      */
     public void setSignedjar(final File signedjar) {
         this.signedjar = signedjar;
     }
 
     /**
      * Flag to include the .SF file inside the signature; optional; default
      * false
      *
      * @param internalsf if true include the .SF file inside the signature
      */
     public void setInternalsf(final boolean internalsf) {
         this.internalsf = internalsf;
     }
 
     /**
      * flag to compute hash of entire manifest; optional, default false
      *
      * @param sectionsonly flag to compute hash of entire manifest
      */
     public void setSectionsonly(final boolean sectionsonly) {
         this.sectionsonly = sectionsonly;
     }
 
     /**
      * flag to control whether the presence of a signature file means a JAR is
      * signed; optional, default false
      *
      * @param lazy flag to control whether the presence of a signature
      */
     public void setLazy(final boolean lazy) {
         this.lazy = lazy;
     }
 
     /**
      * Optionally sets the output directory to be used.
      *
      * @param destDir the directory in which to place signed jars
      * @since Ant 1.7
      */
     public void setDestDir(File destDir) {
         this.destDir = destDir;
     }
 
 
     /**
      * add a mapper to determine file naming policy. Only used with toDir
      * processing.
      *
      * @param newMapper the mapper to add.
      * @since Ant 1.7
      */
     public void add(FileNameMapper newMapper) {
         if (mapper != null) {
             throw new BuildException(ERROR_TOO_MANY_MAPPERS);
         }
         mapper = newMapper;
     }
 
     /**
      * get the active mapper; may be null
      * @return mapper or null
      * @since Ant 1.7
      */
     public FileNameMapper getMapper() {
         return mapper;
     }
 
     /**
      * get the -tsaurl url
      * @return url or null
      * @since Ant 1.7
      */
     public String getTsaurl() {
         return tsaurl;
     }
 
     /**
      *
      * @param tsaurl the tsa url.
      * @since Ant 1.7
      */
     public void setTsaurl(String tsaurl) {
         this.tsaurl = tsaurl;
     }
 
     /**
      * Get the proxy host to be used when connecting to the TSA url
      * @return url or null
      * @since Ant 1.9.5
      */
     public String getTsaproxyhost() {
         return tsaproxyhost;
     }
 
     /**
      *
      * @param tsaproxyhost the proxy host to be used when connecting to the TSA.
      * @since Ant 1.9.5
      */
     public void setTsaproxyhost(String tsaproxyhost) {
         this.tsaproxyhost = tsaproxyhost;
     }
 
     /**
      * Get the proxy host to be used when connecting to the TSA url
      * @return url or null
      * @since Ant 1.9.5
      */
     public String getTsaproxyport() {
         return tsaproxyport;
     }
 
     /**
      *
      * @param tsaproxyport the proxy port to be used when connecting to the TSA.
      * @since Ant 1.9.5
      */
     public void setTsaproxyport(String tsaproxyport) {
         this.tsaproxyport = tsaproxyport;
     }
 
     /**
      * get the -tsacert option
      * @since Ant 1.7
      * @return a certificate alias or null
      */
     public String getTsacert() {
         return tsacert;
     }
 
     /**
      * set the alias in the keystore of the TSA to use;
      * @param tsacert the cert alias.
      */
     public void setTsacert(String tsacert) {
         this.tsacert = tsacert;
     }
 
     /**
      * Whether to force signing of a jar even it is already signed.
      * @since Ant 1.8.0
      */
     public void setForce(boolean b) {
         force = b;
     }
 
     /**
      * Should the task force signing of a jar even it is already
      * signed?
      * @since Ant 1.8.0
      */
     public boolean isForce() {
         return force;
     }
 
     /**
      * Signature Algorithm; optional
      *
      * @param sigAlg the signature algorithm
      */
     public void setSigAlg(String sigAlg) {
         this.sigAlg = sigAlg;
     }
 
     /**
      * Signature Algorithm; optional
      */
     public String getSigAlg() {
         return sigAlg;
     }
 
     /**
      * Digest Algorithm; optional
      *
      * @param digestAlg the digest algorithm
      */
     public void setDigestAlg(String digestAlg) {
         this.digestAlg = digestAlg;
     }
 
     /**
      * Digest Algorithm; optional
      */
     public String getDigestAlg() {
         return digestAlg;
     }
 
     /**
      * sign the jar(s)
      *
      * @throws BuildException on errors
      */
     @Override
     public void execute() throws BuildException {
         //validation logic
         final boolean hasJar = jar != null;
         final boolean hasSignedJar = signedjar != null;
         final boolean hasDestDir = destDir != null;
         final boolean hasMapper = mapper != null;
 
         if (!hasJar && !hasResources()) {
             throw new BuildException(ERROR_NO_SOURCE);
         }
         if (null == alias) {
             throw new BuildException(ERROR_NO_ALIAS);
         }
 
         if (null == storepass) {
             throw new BuildException(ERROR_NO_STOREPASS);
         }
 
         if (hasDestDir && hasSignedJar) {
             throw new BuildException(ERROR_TODIR_AND_SIGNEDJAR);
         }
 
 
         if (hasResources() && hasSignedJar) {
             throw new BuildException(ERROR_SIGNEDJAR_AND_PATHS);
         }
 
-        //this isnt strictly needed, but by being fussy now,
+        //this isn't strictly needed, but by being fussy now,
         //we can change implementation details later
         if (!hasDestDir && hasMapper) {
             throw new BuildException(ERROR_MAPPER_WITHOUT_DEST);
         }
 
         beginExecution();
 
 
         try {
             //special case single jar handling with signedjar attribute set
             if (hasJar && hasSignedJar) {
                 // single jar processing
                 signOneJar(jar, signedjar);
                 //return here.
                 return;
             }
 
             //the rest of the method treats single jar like
             //a nested path with one file
 
             Path sources = createUnifiedSourcePath();
             //set up our mapping policy
             FileNameMapper destMapper;
             if (hasMapper) {
                 destMapper = mapper;
             } else {
                 //no mapper? use the identity policy
                 destMapper = new IdentityMapper();
             }
 
 
             //at this point the paths are set up with lists of files,
             //and the mapper is ready to map from source dirs to dest files
             //now we iterate through every JAR giving source and dest names
             // deal with the paths
             for (Resource r : sources) {
                 FileResource fr = ResourceUtils
                     .asFileResource(r.as(FileProvider.class));
 
                 //calculate our destination directory; it is either the destDir
                 //attribute, or the base dir of the fileset (for in situ updates)
                 File toDir = hasDestDir ? destDir : fr.getBaseDir();
 
                 //determine the destination filename via the mapper
                 String[] destFilenames = destMapper.mapFileName(fr.getName());
                 if (destFilenames == null || destFilenames.length != 1) {
                     //we only like simple mappers.
                     throw new BuildException(ERROR_BAD_MAP + fr.getFile());
                 }
                 File destFile = new File(toDir, destFilenames[0]);
                 signOneJar(fr.getFile(), destFile);
             }
         } finally {
             endExecution();
         }
     }
 
     /**
      * Sign one jar.
      * <p/>
      * The signing only takes place if {@link #isUpToDate(File, File)} indicates
      * that it is needed.
      *
      * @param jarSource source to sign
      * @param jarTarget target; may be null
      * @throws BuildException
      */
     private void signOneJar(File jarSource, File jarTarget)
         throws BuildException {
 
 
         File targetFile = jarTarget;
         if (targetFile == null) {
             targetFile = jarSource;
         }
         if (isUpToDate(jarSource, targetFile)) {
             return;
         }
 
         long lastModified = jarSource.lastModified();
         final ExecTask cmd = createJarSigner();
 
         setCommonOptions(cmd);
 
         bindToKeystore(cmd);
         if (null != sigfile) {
             addValue(cmd, "-sigfile");
             String value = this.sigfile;
             addValue(cmd, value);
         }
 
         try {
             //DO NOT SET THE -signedjar OPTION if source==dest
             //unless you like fielding hotspot crash reports
             if (!FILE_UTILS.areSame(jarSource, targetFile)) {
                 addValue(cmd, "-signedjar");
                 addValue(cmd, targetFile.getPath());
             }
         } catch (IOException ioex) {
             throw new BuildException(ioex);
         }
 
         if (internalsf) {
             addValue(cmd, "-internalsf");
         }
 
         if (sectionsonly) {
             addValue(cmd, "-sectionsonly");
         }
 
         if (sigAlg != null) {
             addValue(cmd, "-sigalg");
             addValue(cmd, sigAlg);
         }
 
         if (digestAlg != null) {
             addValue(cmd, "-digestalg");
             addValue(cmd, digestAlg);
         }
 
         //add -tsa operations if declared
         addTimestampAuthorityCommands(cmd);
 
         //JAR source is required
         addValue(cmd, jarSource.getPath());
 
         //alias is required for signing
         addValue(cmd, alias);
 
         log("Signing JAR: "
             + jarSource.getAbsolutePath()
             + " to "
             + targetFile.getAbsolutePath()
             + " as " + alias);
 
         cmd.execute();
 
         // restore the lastModified attribute
         if (preserveLastModified) {
             FILE_UTILS.setFileLastModified(targetFile, lastModified);
         }
     }
 
     /**
      * If the tsa parameters are set, this passes them to the command.
      * There is no validation of java version, as third party JDKs
      * may implement this on earlier/later jarsigner implementations.
      * @param cmd the exec task.
      */
     private void addTimestampAuthorityCommands(final ExecTask cmd) {
         if (tsaurl != null) {
             addValue(cmd, "-tsa");
             addValue(cmd, tsaurl);
         }
 
         if (tsacert != null) {
             addValue(cmd, "-tsacert");
             addValue(cmd, tsacert);
         }
 
         if (tsaproxyhost != null) {
             if (tsaurl == null || tsaurl.startsWith("https")) {
                 addProxyFor(cmd, "https");
             }
             if (tsaurl == null || !tsaurl.startsWith("https")) {
                 addProxyFor(cmd, "http");
             }
         }
     }
 
     /**
      * <p>Compare a jar file with its corresponding signed jar. The logic for this
      * is complex, and best explained in the source itself. Essentially if
-     * either file doesnt exist, or the destfile has an out of date timestamp,
+     * either file doesn't exist, or the destfile has an out of date timestamp,
      * then the return value is false.</p>
      *
      * <p>If we are signing ourself, the check {@link #isSigned(File)} is used to
      * trigger the process.</p>
      *
      * @param jarFile       the unsigned jar file
      * @param signedjarFile the result signed jar file
      * @return true if the signedjarFile is considered up to date
      */
     protected boolean isUpToDate(File jarFile, File signedjarFile) {
         if (isForce() || null == jarFile || !jarFile.exists()) {
             //these are pathological cases, but retained in case somebody
             //subclassed us.
             return false;
         }
 
         //we normally compare destination with source
         File destFile = signedjarFile;
         if (destFile == null) {
             //but if no dest is specified, compare source to source
             destFile = jarFile;
         }
 
         //if, by any means, the destfile and source match,
         if (jarFile.equals(destFile)) {
             if (lazy) {
                 //we check the presence of signatures on lazy signing
                 return isSigned(jarFile);
             }
             //unsigned or non-lazy self signings are always false
             return false;
         }
 
         //if they are different, the timestamps are used
         return FILE_UTILS.isUpToDate(jarFile, destFile);
     }
 
     /**
      * test for a file being signed, by looking for a signature in the META-INF
      * directory with our alias/sigfile.
      *
      * @param file the file to be checked
      * @return true if the file is signed
      * @see IsSigned#isSigned(File, String)
      */
     protected boolean isSigned(File file) {
         try {
             return IsSigned.isSigned(file, sigfile == null ? alias : sigfile);
         } catch (IOException e) {
             //just log this
             log(e.toString(), Project.MSG_VERBOSE);
             return false;
         }
     }
 
     /**
      * true to indicate that the signed jar modification date remains the same
      * as the original. Defaults to false
      *
      * @param preserveLastModified if true preserve the last modified time
      */
     public void setPreserveLastModified(boolean preserveLastModified) {
         this.preserveLastModified = preserveLastModified;
     }
 
     private void addProxyFor(final ExecTask cmd, final String scheme) {
         addValue(cmd, "-J-D" + scheme + ".proxyHost=" + tsaproxyhost);
 
         if (tsaproxyport != null) {
             addValue(cmd, "-J-D" + scheme + ".proxyPort=" + tsaproxyport);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java b/src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java
index 9d10f2c0c..4fe31260b 100644
--- a/src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java
+++ b/src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java
@@ -134,1556 +134,1556 @@ public class XSLTProcess extends MatchingTask implements XSLTLogger {
     /**
      * factory element for TraX processors only
      * @since Ant 1.6
      */
     private Factory factory = null;
 
     /**
      * whether to reuse Transformer if transforming multiple files.
      * @since 1.5.2
      */
     private boolean reuseLoadedStylesheet = true;
 
     /**
      * AntClassLoader for the nested &lt;classpath&gt; - if set.
      *
      * <p>We keep this here in order to reset the context classloader
      * in execute.  We can't use liaison.getClass().getClassLoader()
      * since the actual liaison class may have been loaded by a loader
      * higher up (system classloader, for example).</p>
      *
      * @since Ant 1.6.2
      */
     private AntClassLoader loader = null;
 
     /**
      * Mapper to use when a set of files gets processed.
      *
      * @since Ant 1.6.2
      */
     private Mapper mapperElement = null;
 
     /**
      * Additional resource collections to process.
      *
      * @since Ant 1.7
      */
     private final Union resources = new Union();
 
     /**
      * Whether to use the implicit fileset.
      *
      * @since Ant 1.7
      */
     private boolean useImplicitFileset = true;
 
     /**
      * The default processor is trax
      * @since Ant 1.7
      */
     public static final String PROCESSOR_TRAX = "trax";
 
     /**
      * whether to suppress warnings.
      *
      * @since Ant 1.8.0
      */
     private boolean suppressWarnings = false;
 
     /**
      * whether to fail the build if an error occurs during transformation.
      *
      * @since Ant 1.8.0
      */
     private boolean failOnTransformationError = true;
 
     /**
      * whether to fail the build if an error occurs.
      *
      * @since Ant 1.8.0
      */
     private boolean failOnError = true;
 
     /**
      * Whether the build should fail if the nested resource collection
      * is empty.
      *
      * @since Ant 1.8.0
      */
     private boolean failOnNoResources = true;
 
     /**
      * For evaluating template params
      *
      * @since Ant 1.9.3
      */
     private XPathFactory xpathFactory;
     /**
      * For evaluating template params
      *
      * @since Ant 1.9.3
      */
     private XPath xpath;
 
     /**
      * System properties to set during transformation.
      *
      * @since Ant 1.8.0
      */
     private final CommandlineJava.SysProperties sysProperties =
         new CommandlineJava.SysProperties();
 
     /**
      * Trace configuration for Xalan2.
      *
      * @since Ant 1.8.0
      */
     private TraceConfiguration traceConfiguration;
 
     /**
      * Creates a new XSLTProcess Task.
      */
     public XSLTProcess() {
     } //-- XSLTProcess
 
     /**
      * Whether to style all files in the included directories as well;
      * optional, default is true.
      *
      * @param b true if files in included directories are processed.
      * @since Ant 1.5
      */
     public void setScanIncludedDirectories(final boolean b) {
         performDirectoryScan = b;
     }
 
     /**
      * Controls whether the stylesheet is reloaded for every transform.
      *
      * <p>Setting this to true may get around a bug in certain
      * Xalan-J versions, default is false.</p>
      * @param b a <code>boolean</code> value
      * @since Ant 1.5.2
      */
     public void setReloadStylesheet(final boolean b) {
         reuseLoadedStylesheet = !b;
     }
 
     /**
      * Defines the mapper to map source to destination files.
      * @param mapper the mapper to use
      * @exception BuildException if more than one mapper is defined
      * @since Ant 1.6.2
      */
     public void addMapper(final Mapper mapper) {
         if (mapperElement != null) {
             handleError("Cannot define more than one mapper");
         } else {
             mapperElement = mapper;
         }
     }
 
     /**
      * Adds a collection of resources to style in addition to the
      * given file or the implicit fileset.
      *
      * @param rc the collection of resources to style
      * @since Ant 1.7
      */
     public void add(final ResourceCollection rc) {
         resources.add(rc);
     }
 
     /**
      * Add a nested &lt;style&gt; element.
      * @param rc the configured Resources object represented as &lt;style&gt;.
      * @since Ant 1.7
      */
     public void addConfiguredStyle(final Resources rc) {
         if (rc.size() != 1) {
             handleError("The style element must be specified with exactly one"
                         + " nested resource.");
         } else {
             setXslResource(rc.iterator().next());
         }
     }
 
     /**
      * API method to set the XSL Resource.
      * @param xslResource Resource to set as the stylesheet.
      * @since Ant 1.7
      */
     public void setXslResource(final Resource xslResource) {
         this.xslResource = xslResource;
     }
 
     /**
      * Adds a nested filenamemapper.
      * @param fileNameMapper the mapper to add
      * @exception BuildException if more than one mapper is defined
      * @since Ant 1.7.0
      */
     public void add(final FileNameMapper fileNameMapper) throws BuildException {
        final Mapper mapper = new Mapper(getProject());
        mapper.add(fileNameMapper);
        addMapper(mapper);
     }
 
     /**
      * Executes the task.
      *
      * @exception BuildException if there is an execution problem.
      * @todo validate that if either in or out is defined, then both are
      */
     @Override
     public void execute() throws BuildException {
         if ("style".equals(getTaskType())) {
             log("Warning: the task name <style> is deprecated. Use <xslt> instead.",
                     Project.MSG_WARN);
         }
         final File savedBaseDir = baseDir;
 
         DirectoryScanner scanner;
         String[]         list;
         String[]         dirs;
 
         final String baseMessage =
             "specify the stylesheet either as a filename in style attribute "
             + "or as a nested resource";
 
         if (xslResource == null && xslFile == null) {
             handleError(baseMessage);
             return;
         }
         if (xslResource != null && xslFile != null) {
             handleError(baseMessage + " but not as both");
             return;
         }
         if (inFile != null && !inFile.exists()) {
             handleError("input file " + inFile + " does not exist");
             return;
         }
         try {
             setupLoader();
 
             if (sysProperties.size() > 0) {
                 sysProperties.setSystem();
             }
 
             Resource styleResource;
             if (baseDir == null) {
                 baseDir = getProject().getBaseDir();
             }
             liaison = getLiaison();
 
             // check if liaison wants to log errors using us as logger
             if (liaison instanceof XSLTLoggerAware) {
                 ((XSLTLoggerAware) liaison).setLogger(this);
             }
             log("Using " + liaison.getClass().toString(), Project.MSG_VERBOSE);
 
             if (xslFile != null) {
                 // If we enter here, it means that the stylesheet is supplied
                 // via style attribute
                 File stylesheet = getProject().resolveFile(xslFile);
                 if (!stylesheet.exists()) {
                     final File alternative = FILE_UTILS.resolveFile(baseDir, xslFile);
                     /*
                      * shouldn't throw out deprecation warnings before we know,
                      * the wrong version has been used.
                      */
                     if (alternative.exists()) {
                         log("DEPRECATED - the 'style' attribute should be "
                             + "relative to the project's");
                         log("             basedir, not the tasks's basedir.");
                         stylesheet = alternative;
                     }
                 }
                 final FileResource fr = new FileResource();
                 fr.setProject(getProject());
                 fr.setFile(stylesheet);
                 styleResource = fr;
             } else {
                 styleResource = xslResource;
             }
 
             if (!styleResource.isExists()) {
                 handleError("stylesheet " + styleResource + " doesn't exist.");
                 return;
             }
 
             // if we have an in file and out then process them
             if (inFile != null && outFile != null) {
                 process(inFile, outFile, styleResource);
                 return;
             }
             /*
              * if we get here, in and out have not been specified, we are
              * in batch processing mode.
              */
 
             //-- make sure destination directory exists...
             checkDest();
 
             if (useImplicitFileset) {
                 scanner = getDirectoryScanner(baseDir);
                 log("Transforming into " + destDir, Project.MSG_INFO);
 
                 // Process all the files marked for styling
                 list = scanner.getIncludedFiles();
                 for (int i = 0; i < list.length; ++i) {
                     process(baseDir, list[i], destDir, styleResource);
                 }
                 if (performDirectoryScan) {
                     // Process all the directories marked for styling
                     dirs = scanner.getIncludedDirectories();
                     for (int j = 0; j < dirs.length; ++j) {
                         list = new File(baseDir, dirs[j]).list();
                         for (int i = 0; i < list.length; ++i) {
                             process(baseDir, dirs[j] + File.separator + list[i], destDir,
                                     styleResource);
                         }
                     }
                 }
             } else { // only resource collections, there better be some
                 if (resources.size() == 0) {
                     if (failOnNoResources) {
                         handleError("no resources specified");
                     }
                     return;
                 }
             }
             processResources(styleResource);
         } finally {
             if (loader != null) {
                 loader.resetThreadContextLoader();
                 loader.cleanup();
                 loader = null;
             }
             if (sysProperties.size() > 0) {
                 sysProperties.restoreSystem();
             }
             liaison = null;
             stylesheetLoaded = false;
             baseDir = savedBaseDir;
         }
     }
 
     /**
      * Set whether to check dependencies, or always generate;
      * optional, default is false.
      *
      * @param force true if always generate.
      */
     public void setForce(final boolean force) {
         this.force = force;
     }
 
     /**
      * Set the base directory;
      * optional, default is the project's basedir.
      *
      * @param dir the base directory
      **/
     public void setBasedir(final File dir) {
         baseDir = dir;
     }
 
     /**
      * Set the destination directory into which the XSL result
      * files should be copied to;
      * required, unless <tt>in</tt> and <tt>out</tt> are
      * specified.
      * @param dir the name of the destination directory
      **/
     public void setDestdir(final File dir) {
         destDir = dir;
     }
 
     /**
      * Set the desired file extension to be used for the target;
      * optional, default is html.
      * @param name the extension to use
      **/
     public void setExtension(final String name) {
         targetExtension = name;
     }
 
     /**
      * Name of the stylesheet to use - given either relative
      * to the project's basedir or as an absolute path; required.
      *
      * @param xslFile the stylesheet to use
      */
     public void setStyle(final String xslFile) {
         this.xslFile = xslFile;
     }
 
     /**
      * Set the optional classpath to the XSL processor
      *
      * @param classpath the classpath to use when loading the XSL processor
      */
     public void setClasspath(final Path classpath) {
         createClasspath().append(classpath);
     }
 
     /**
      * Set the optional classpath to the XSL processor
      *
      * @return a path instance to be configured by the Ant core.
      */
     public Path createClasspath() {
         if (classpath == null) {
             classpath = new Path(getProject());
         }
         return classpath.createPath();
     }
 
     /**
      * Set the reference to an optional classpath to the XSL processor
      *
      * @param r the id of the Ant path instance to act as the classpath
      *          for loading the XSL processor
      */
     public void setClasspathRef(final Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * Set the name of the XSL processor to use; optional, default trax.
      *
      * @param processor the name of the XSL processor
      */
     public void setProcessor(final String processor) {
         this.processor = processor;
     }
 
     /**
      * Whether to use the implicit fileset.
      *
      * <p>Set this to false if you want explicit control with nested
      * resource collections.</p>
      * @param useimplicitfileset set to true if you want to use implicit fileset
      * @since Ant 1.7
      */
     public void setUseImplicitFileset(final boolean useimplicitfileset) {
         useImplicitFileset = useimplicitfileset;
     }
 
     /**
      * Add the catalog to our internal catalog
      *
      * @param xmlCatalog the XMLCatalog instance to use to look up DTDs
      */
     public void addConfiguredXMLCatalog(final XMLCatalog xmlCatalog) {
         this.xmlCatalog.addConfiguredXMLCatalog(xmlCatalog);
     }
 
     /**
      * Pass the filename of the current processed file as a xsl parameter
      * to the transformation. This value sets the name of that xsl parameter.
      *
      * @param fileNameParameter name of the xsl parameter retrieving the
      *                          current file name
      */
     public void setFileNameParameter(final String fileNameParameter) {
         this.fileNameParameter = fileNameParameter;
     }
 
     /**
      * Pass the directory name of the current processed file as a xsl parameter
      * to the transformation. This value sets the name of that xsl parameter.
      *
      * @param fileDirParameter name of the xsl parameter retrieving the
      *                         current file directory
      */
     public void setFileDirParameter(final String fileDirParameter) {
         this.fileDirParameter = fileDirParameter;
     }
 
     /**
      * Whether to suppress warning messages of the processor.
      *
      * @since Ant 1.8.0
      */
     public void setSuppressWarnings(final boolean b) {
         suppressWarnings = b;
     }
 
     /**
      * Whether to suppress warning messages of the processor.
      *
      * @since Ant 1.8.0
      */
     public boolean getSuppressWarnings() {
         return suppressWarnings;
     }
 
     /**
      * Whether transformation errors should make the build fail.
      *
      * @since Ant 1.8.0
      */
     public void setFailOnTransformationError(final boolean b) {
         failOnTransformationError = b;
     }
 
     /**
      * Whether any errors should make the build fail.
      *
      * @since Ant 1.8.0
      */
     public void setFailOnError(final boolean b) {
         failOnError = b;
     }
 
     /**
      * Whether the build should fail if the nested resource collection is empty.
      *
      * @since Ant 1.8.0
      */
     public void setFailOnNoResources(final boolean b) {
         failOnNoResources = b;
     }
 
     /**
      * A system property to set during transformation.
      *
      * @since Ant 1.8.0
      */
     public void addSysproperty(final Environment.Variable sysp) {
         sysProperties.addVariable(sysp);
     }
 
     /**
      * A set of system properties to set during transformation.
      *
      * @since Ant 1.8.0
      */
     public void addSyspropertyset(final PropertySet sysp) {
         sysProperties.addSyspropertyset(sysp);
     }
 
     /**
      * Enables Xalan2 traces and uses the given configuration.
      *
      * <p>Note that this element doesn't have any effect with a
      * processor other than trax or if the Transformer is not Xalan2's
      * transformer implementation.</p>
      *
      * @since Ant 1.8.0
      */
     public TraceConfiguration createTrace() {
         if (traceConfiguration != null) {
             throw new BuildException("can't have more than one trace"
                                      + " configuration");
         }
         traceConfiguration = new TraceConfiguration();
         return traceConfiguration;
     }
 
     /**
      * Configuration for Xalan2 traces.
      *
      * @since Ant 1.8.0
      */
     public TraceConfiguration getTraceConfiguration() {
         return traceConfiguration;
     }
 
     /**
      * Load processor here instead of in setProcessor - this will be
      * called from within execute, so we have access to the latest
      * classpath.
      *
      * @param proc the name of the processor to load.
      * @exception Exception if the processor cannot be loaded.
      */
     private void resolveProcessor(final String proc) throws Exception {
         if (proc.equals(PROCESSOR_TRAX)) {
             liaison = new org.apache.tools.ant.taskdefs.optional.TraXLiaison();
         } else {
             //anything else is a classname
             final Class clazz = loadClass(proc);
             liaison = (XSLTLiaison) clazz.newInstance();
         }
     }
 
     /**
      * Load named class either via the system classloader or a given
      * custom classloader.
      *
      * As a side effect, the loader is set as the thread context classloader
      * @param classname the name of the class to load.
      * @return the requested class.
      * @exception Exception if the class could not be loaded.
      */
     private Class loadClass(final String classname) throws Exception {
         setupLoader();
         if (loader == null) {
             return Class.forName(classname);
         }
         return Class.forName(classname, true, loader);
     }
 
     /**
      * If a custom classpath has been defined but no loader created
      * yet, create the classloader and set it as the context
      * classloader.
      */
     private void setupLoader() {
         if (classpath != null && loader == null) {
             loader = getProject().createClassLoader(classpath);
             loader.setThreadContextLoader();
         }
     }
 
     /**
      * Specifies the output name for the styled result from the
      * <tt>in</tt> attribute; required if <tt>in</tt> is set
      *
      * @param outFile the output File instance.
      */
     public void setOut(final File outFile) {
         this.outFile = outFile;
     }
 
     /**
      * specifies a single XML document to be styled. Should be used
      * with the <tt>out</tt> attribute; ; required if <tt>out</tt> is set
      *
      * @param inFile the input file
      */
     public void setIn(final File inFile) {
         this.inFile = inFile;
     }
 
     /**
      * Throws a BuildException if the destination directory hasn't
      * been specified.
      * @since Ant 1.7
      */
     private void checkDest() {
         if (destDir == null) {
             handleError("destdir attributes must be set!");
         }
     }
 
     /**
      * Styles all existing resources.
      *
      * @param stylesheet style sheet to use
      * @since Ant 1.7
      */
     private void processResources(final Resource stylesheet) {
         for (final Resource r : resources) {
             if (!r.isExists()) {
                 continue;
             }
             File base = baseDir;
             String name = r.getName();
             final FileProvider fp = r.as(FileProvider.class);
             if (fp != null) {
                 final FileResource f = ResourceUtils.asFileResource(fp);
                 base = f.getBaseDir();
                 if (base == null) {
                     name = f.getFile().getAbsolutePath();
                 }
             }
             process(base, name, destDir, stylesheet);
         }
     }
 
     /**
      * Processes the given input XML file and stores the result
      * in the given resultFile.
      *
      * @param baseDir the base directory for resolving files.
      * @param xmlFile the input file
      * @param destDir the destination directory
      * @param stylesheet the stylesheet to use.
      * @exception BuildException if the processing fails.
      */
     private void process(final File baseDir, final String xmlFile, final File destDir, final Resource stylesheet)
             throws BuildException {
 
         File   outF = null;
         File   inF = null;
 
         try {
             final long styleSheetLastModified = stylesheet.getLastModified();
             inF = new File(baseDir, xmlFile);
 
             if (inF.isDirectory()) {
                 log("Skipping " + inF + " it is a directory.", Project.MSG_VERBOSE);
                 return;
             }
             FileNameMapper mapper = null;
             if (mapperElement != null) {
                 mapper = mapperElement.getImplementation();
             } else {
                 mapper = new StyleMapper();
             }
 
             final String[] outFileName = mapper.mapFileName(xmlFile);
             if (outFileName == null || outFileName.length == 0) {
                 log("Skipping " + inFile + " it cannot get mapped to output.", Project.MSG_VERBOSE);
                 return;
             } else if (outFileName == null || outFileName.length > 1) {
                 log("Skipping " + inFile + " its mapping is ambiguos.", Project.MSG_VERBOSE);
                 return;
             }
             outF = new File(destDir, outFileName[0]);
 
             if (force || inF.lastModified() > outF.lastModified()
                     || styleSheetLastModified > outF.lastModified()) {
                 ensureDirectoryFor(outF);
                 log("Processing " + inF + " to " + outF);
                 configureLiaison(stylesheet);
                 setLiaisonDynamicFileParameters(liaison, inF);
                 liaison.transform(inF, outF);
             }
         } catch (final Exception ex) {
             // If failed to process document, must delete target document,
             // or it will not attempt to process it the second time
             log("Failed to process " + inFile, Project.MSG_INFO);
             if (outF != null) {
                 outF.delete();
             }
             handleTransformationError(ex);
         }
 
     } //-- processXML
 
     /**
      * Process the input file to the output file with the given stylesheet.
      *
      * @param inFile the input file to process.
      * @param outFile the destination file.
      * @param stylesheet the stylesheet to use.
      * @exception BuildException if the processing fails.
      */
     private void process(final File inFile, final File outFile, final Resource stylesheet) throws BuildException {
         try {
             final long styleSheetLastModified = stylesheet.getLastModified();
             log("In file " + inFile + " time: " + inFile.lastModified(), Project.MSG_DEBUG);
             log("Out file " + outFile + " time: " + outFile.lastModified(), Project.MSG_DEBUG);
             log("Style file " + xslFile + " time: " + styleSheetLastModified, Project.MSG_DEBUG);
             if (force || inFile.lastModified() >= outFile.lastModified()
                     || styleSheetLastModified >= outFile.lastModified()) {
                 ensureDirectoryFor(outFile);
                 log("Processing " + inFile + " to " + outFile, Project.MSG_INFO);
                 configureLiaison(stylesheet);
                 setLiaisonDynamicFileParameters(liaison, inFile);
                 liaison.transform(inFile, outFile);
             } else {
                 log("Skipping input file " + inFile + " because it is older than output file "
                         + outFile + " and so is the stylesheet " + stylesheet, Project.MSG_DEBUG);
             }
         } catch (final Exception ex) {
             log("Failed to process " + inFile, Project.MSG_INFO);
             if (outFile != null) {
                 outFile.delete();
             }
             handleTransformationError(ex);
         }
     }
 
     /**
      * Ensure the directory exists for a given file
      *
      * @param targetFile the file for which the directories are required.
      * @exception BuildException if the directories cannot be created.
      */
     private void ensureDirectoryFor(final File targetFile) throws BuildException {
         final File directory = targetFile.getParentFile();
         if (!directory.exists()) {
             if (!(directory.mkdirs() || directory.isDirectory())) {
                 handleError("Unable to create directory: "
                             + directory.getAbsolutePath());
             }
         }
     }
 
     /**
      * Get the factory instance configured for this processor
      *
      * @return the factory instance in use
      */
     public Factory getFactory() {
         return factory;
     }
 
     /**
      * Get the XML catalog containing entity definitions
      *
      * @return the XML catalog for the task.
      */
     public XMLCatalog getXMLCatalog() {
         xmlCatalog.setProject(getProject());
         return xmlCatalog;
     }
 
     /**
      * Get an enumeration on the outputproperties.
      * @return the outputproperties
      */
     public Enumeration getOutputProperties() {
         return outputProperties.elements();
     }
 
     /**
      * Get the Liaison implementation to use in processing.
      *
      * @return an instance of the XSLTLiaison interface.
      */
     protected XSLTLiaison getLiaison() {
         // if processor wasn't specified, use TraX.
         if (liaison == null) {
             if (processor != null) {
                 try {
                     resolveProcessor(processor);
                 } catch (final Exception e) {
                     handleError(e);
                 }
             } else {
                 try {
                     resolveProcessor(PROCESSOR_TRAX);
                 } catch (final Throwable e1) {
                     e1.printStackTrace();
                     handleError(e1);
                 }
             }
         }
         return liaison;
     }
 
     /**
      * Create an instance of an XSL parameter for configuration by Ant.
      *
      * @return an instance of the Param class to be configured.
      */
     public Param createParam() {
         final Param p = new Param();
         params.add(p);
         return p;
     }
 
     /**
      * The Param inner class used to store XSL parameters
      */
     public static class Param {
         /** The parameter name */
         private String name = null;
 
         /** The parameter's value */
         private String expression = null;
 
         /**
          * Type of the expression.
          * @see ParamType
          */
         private String type;
 
         private Object ifCond;
         private Object unlessCond;
         private Project project;
 
         /**
          * Set the current project
          *
          * @param project the current project
          */
         public void setProject(final Project project) {
             this.project = project;
         }
 
         /**
          * Set the parameter name.
          *
          * @param name the name of the parameter.
          */
         public void setName(final String name) {
             this.name = name;
         }
 
         /**
          * The parameter value -
          * can be a primitive type value or an XPath expression.
          * @param expression the parameter's value/expression.
          * @see #setType(java.lang.String)
          */
         public void setExpression(final String expression) {
             this.expression = expression;
         }
 
         /**
          * @see ParamType
          * @since Ant 1.9.3
          */
         public void setType(final String type) {
             this.type = type;
         }
 
         /**
          * Get the parameter name
          *
          * @return the parameter name
          * @exception BuildException if the name is not set.
          */
         public String getName() throws BuildException {
             if (name == null) {
                 throw new BuildException("Name attribute is missing.");
             }
             return name;
         }
 
         /**
          * Get the parameter's value
          *
          * @return the parameter value
          * @exception BuildException if the value is not set.
          * @see #getType()
          */
         public String getExpression() throws BuildException {
             if (expression == null) {
                 throw new BuildException("Expression attribute is missing.");
             }
             return expression;
         }
 
         /**
          * @see ParamType
          * @since Ant 1.9.3
          */
         public String getType() {
             return type;
         }
 
         /**
          * Set whether this param should be used.  It will be used if
          * the expression evaluates to true or the name of a property
          * which has been set, otherwise it won't.
          * @param ifCond evaluated expression
          * @since Ant 1.8.0
          */
         public void setIf(final Object ifCond) {
             this.ifCond = ifCond;
         }
 
         /**
          * Set whether this param should be used.  It will be used if
          * the expression evaluates to true or the name of a property
          * which has been set, otherwise it won't.
          * @param ifProperty evaluated expression
          */
         public void setIf(final String ifProperty) {
             setIf((Object) ifProperty);
         }
 
         /**
          * Set whether this param should NOT be used. It will not be
          * used if the expression evaluates to true or the name of a
          * property which has been set, otherwise it will be used.
          * @param unlessCond evaluated expression
          * @since Ant 1.8.0
          */
         public void setUnless(final Object unlessCond) {
             this.unlessCond = unlessCond;
         }
 
         /**
          * Set whether this param should NOT be used. It will not be
          * used if the expression evaluates to true or the name of a
          * property which has been set, otherwise it will be used.
          * @param unlessProperty evaluated expression
          */
         public void setUnless(final String unlessProperty) {
             setUnless((Object) unlessProperty);
         }
 
         /**
          * Ensures that the param passes the conditions placed
          * on it with <code>if</code> and <code>unless</code> properties.
          * @return true if the task passes the "if" and "unless" parameters
          */
         public boolean shouldUse() {
             final PropertyHelper ph = PropertyHelper.getPropertyHelper(project);
             return ph.testIfCondition(ifCond)
                 && ph.testUnlessCondition(unlessCond);
         }
     } // Param
 
     /**
      * Enum for types of the parameter expression.
      *
      * <p>The expression can be:</p>
      * <ul>
      * <li>primitive type that will be parsed from the string value e.g.
      * {@linkplain Integer#parseInt(java.lang.String)}</li>
      * <li>XPath expression that will be evaluated (outside of the transformed
      * document - on empty one) and casted to given type. Inside XPath
      * expressions the Ant variables (properties) can be used (as XPath
      * variables - e.g. $variable123). n.b. placeholders in form of
      * ${variable123} will be substituted with their values before evaluating the
      * XPath expression (so it can be used for dynamic XPath function names and
      * other hacks).</li>
      * </ul>
      * <p>The parameter will be then passed to the XSLT template.</p>
      *
-     * <p>Default type (if omited) is primitive String. So if the expression is e.g
+     * <p>Default type (if omitted) is primitive String. So if the expression is e.g
      * "true" with no type, in XSLT it will be only a text string, not true
      * boolean.</p>
      *
      * @see Param#setType(java.lang.String)
      * @see Param#setExpression(java.lang.String)
      * @since Ant 1.9.3
      */
     public enum ParamType {
 
         STRING,
         BOOLEAN,
         INT,
         LONG,
         DOUBLE,
         XPATH_STRING,
         XPATH_BOOLEAN,
         XPATH_NUMBER,
         XPATH_NODE,
         XPATH_NODESET;
 
         public static final Map<ParamType, QName> XPATH_TYPES;
 
         static {
             final Map<ParamType, QName> m = new EnumMap<ParamType, QName>(ParamType.class);
             m.put(XPATH_STRING, XPathConstants.STRING);
             m.put(XPATH_BOOLEAN, XPathConstants.BOOLEAN);
             m.put(XPATH_NUMBER, XPathConstants.NUMBER);
             m.put(XPATH_NODE, XPathConstants.NODE);
             m.put(XPATH_NODESET, XPathConstants.NODESET);
             XPATH_TYPES = Collections.unmodifiableMap(m);
         }
     }
 
     /**
      * Create an instance of an output property to be configured.
      * @return the newly created output property.
      * @since Ant 1.5
      */
     public OutputProperty createOutputProperty() {
         final OutputProperty p = new OutputProperty();
         outputProperties.addElement(p);
         return p;
     }
 
     /**
      * Specify how the result tree should be output as specified
      * in the <a href="http://www.w3.org/TR/xslt#output">
      * specification</a>.
      * @since Ant 1.5
      */
     public static class OutputProperty {
         /** output property name */
         private String name;
 
         /** output property value */
         private String value;
 
         /**
          * @return the output property name.
          */
         public String getName() {
             return name;
         }
 
         /**
          * set the name for this property
          * @param name A non-null String that specifies an
          * output property name, which may be namespace qualified.
          */
         public void setName(final String name) {
             this.name = name;
         }
 
         /**
          * @return the output property value.
          */
         public String getValue() {
             return value;
         }
 
         /**
          * set the value for this property
          * @param value The non-null string value of the output property.
          */
         public void setValue(final String value) {
             this.value = value;
         }
     }
 
     /**
      * Initialize internal instance of XMLCatalog.
      * Initialize XPath for parameter evaluation.
      * @throws BuildException on error
      */
     @Override
     public void init() throws BuildException {
         super.init();
         xmlCatalog.setProject(getProject());
 
         xpathFactory = XPathFactory.newInstance();
         xpath = xpathFactory.newXPath();
         xpath.setXPathVariableResolver(new XPathVariableResolver() {
             public Object resolveVariable(final QName variableName) {
                 return getProject().getProperty(variableName.toString());
             }
         });
     }
 
     /**
      * Loads the stylesheet and set xsl:param parameters.
      *
      * @param stylesheet the file from which to load the stylesheet.
      * @exception BuildException if the stylesheet cannot be loaded.
      * @deprecated since Ant 1.7
      */
     @Deprecated
     protected void configureLiaison(final File stylesheet) throws BuildException {
         final FileResource fr = new FileResource();
         fr.setProject(getProject());
         fr.setFile(stylesheet);
         configureLiaison(fr);
     }
 
     /**
      * Loads the stylesheet and set xsl:param parameters.
      *
      * @param stylesheet the resource from which to load the stylesheet.
      * @exception BuildException if the stylesheet cannot be loaded.
      * @since Ant 1.7
      */
     protected void configureLiaison(final Resource stylesheet) throws BuildException {
         if (stylesheetLoaded && reuseLoadedStylesheet) {
             return;
         }
         stylesheetLoaded = true;
 
         try {
             log("Loading stylesheet " + stylesheet, Project.MSG_INFO);
             // We call liaison.configure() and then liaison.setStylesheet()
             // so that the internal variables of liaison can be set up
             if (liaison instanceof XSLTLiaison2) {
                 ((XSLTLiaison2) liaison).configure(this);
             }
             if (liaison instanceof XSLTLiaison3) {
                 // If we are here we can set the stylesheet as a
                 // resource
                 ((XSLTLiaison3) liaison).setStylesheet(stylesheet);
             } else {
                 // If we are here we cannot set the stylesheet as
                 // a resource, but we can set it as a file. So,
                 // we make an attempt to get it as a file
                 final FileProvider fp =
                     stylesheet.as(FileProvider.class);
                 if (fp != null) {
                     liaison.setStylesheet(fp.getFile());
                 } else {
                     handleError(liaison.getClass().toString()
                                 + " accepts the stylesheet only as a file");
                     return;
                 }
             }
             for (final Param p : params) {
                 if (p.shouldUse()) {
                     final Object evaluatedParam = evaluateParam(p);
                     if (liaison instanceof XSLTLiaison4) {
                         ((XSLTLiaison4)liaison).addParam(p.getName(), evaluatedParam);
                     } else {
                         if (evaluatedParam == null || evaluatedParam instanceof String) {
                             liaison.addParam(p.getName(), (String)evaluatedParam);
                         } else {
                             log("XSLTLiaison '" + liaison.getClass().getName()
                                     + "' supports only String parameters. Converting parameter '" + p.getName()
                                     + "' to its String value '" + evaluatedParam, Project.MSG_WARN);
                             liaison.addParam(p.getName(), String.valueOf(evaluatedParam));
                         }
                     }
                 }
             }
         } catch (final Exception ex) {
             log("Failed to transform using stylesheet " + stylesheet, Project.MSG_INFO);
             handleTransformationError(ex);
         }
     }
 
     /**
      * Evaluates parameter expression according to its type.
      *
      * @param param parameter from Ant build file
      * @return value to be passed to XSLT as parameter
      * @throws IllegalArgumentException if param type is unsupported
      * @throws NumberFormatException if expression of numeric type is not
      * desired numeric type
      * @throws XPathExpressionException if XPath expression can not be compiled
      * @since Ant 1.9.3
      */
     private Object evaluateParam(final Param param) throws XPathExpressionException {
         final String typeName = param.getType();
         final String expression = param.getExpression();
 
         ParamType type;
 
         if (typeName == null || "".equals(typeName)) {
             type = ParamType.STRING; // String is default
         } else {
             try {
                 type = ParamType.valueOf(typeName);
             } catch (final IllegalArgumentException e) {
                 throw new IllegalArgumentException("Invalid XSLT parameter type: " + typeName, e);
             }
         }
 
         switch (type) {
             case STRING:
                 return expression;
             case BOOLEAN:
                 return Boolean.parseBoolean(expression);
             case DOUBLE:
                 return Double.parseDouble(expression);
             case INT:
                 return Integer.parseInt(expression);
             case LONG:
                 return Long.parseLong(expression);
             default: // XPath expression
                 final QName xpathType = ParamType.XPATH_TYPES.get(type);
                 if (xpathType == null) {
                     throw new IllegalArgumentException("Invalid XSLT parameter type: " + typeName);
                 } else {
                     final XPathExpression xpe = xpath.compile(expression);
                     // null = evaluate XPath on empty XML document
                     return xpe.evaluate((Object) null, xpathType);
                 }
         }
     }
 
     /**
      * Sets file parameter(s) for directory and filename if the attribute
      * 'filenameparameter' or 'filedirparameter' are set in the task.
      *
      * @param  liaison    to change parameters for
      * @param  inFile     to get the additional file information from
      * @throws Exception  if an exception occurs on filename lookup
      *
      * @since Ant 1.7
      */
     private void setLiaisonDynamicFileParameters(
         final XSLTLiaison liaison, final File inFile) throws Exception {
         if (fileNameParameter != null) {
             liaison.addParam(fileNameParameter, inFile.getName());
         }
         if (fileDirParameter != null) {
             final String fileName = FileUtils.getRelativePath(baseDir, inFile);
             final File file = new File(fileName);
             // Give always a slash as file separator, so the stylesheet could be sure about that
             // Use '.' so a dir+"/"+name would not result in an absolute path
             liaison.addParam(fileDirParameter, file.getParent() != null ? file.getParent().replace(
                     '\\', '/') : ".");
         }
     }
 
     /**
      * Create the factory element to configure a trax liaison.
      * @return the newly created factory element.
      * @throws BuildException if the element is created more than one time.
      */
     public Factory createFactory() throws BuildException {
         if (factory != null) {
             handleError("'factory' element must be unique");
         } else {
             factory = new Factory();
         }
         return factory;
     }
 
     /**
      * Throws an exception with the given message if failOnError is
      * true, otherwise logs the message using the WARN level.
      *
      * @since Ant 1.8.0
      */
     protected void handleError(final String msg) {
         if (failOnError) {
             throw new BuildException(msg, getLocation());
         }
         log(msg, Project.MSG_WARN);
     }
 
 
     /**
      * Throws an exception with the given nested exception if
      * failOnError is true, otherwise logs the message using the WARN
      * level.
      *
      * @since Ant 1.8.0
      */
     protected void handleError(final Throwable ex) {
         if (failOnError) {
             throw new BuildException(ex);
         } else {
             log("Caught an exception: " + ex, Project.MSG_WARN);
         }
     }
 
     /**
      * Throws an exception with the given nested exception if
      * failOnError and failOnTransformationError are true, otherwise
      * logs the message using the WARN level.
      *
      * @since Ant 1.8.0
      */
     protected void handleTransformationError(final Exception ex) {
         if (failOnError && failOnTransformationError) {
             throw new BuildException(ex);
         } else {
             log("Caught an error during transformation: " + ex,
                 Project.MSG_WARN);
         }
     }
 
     /**
      * The factory element to configure a transformer factory
      * @since Ant 1.6
      */
     public static class Factory {
 
         /** the factory class name to use for TraXLiaison */
         private String name;
 
         /**
          * the list of factory attributes to use for TraXLiaison
          */
         private final Vector attributes = new Vector();
 
         /**
          * @return the name of the factory.
          */
         public String getName() {
             return name;
         }
 
         /**
          * Set the name of the factory
          * @param name the name of the factory.
          */
         public void setName(final String name) {
             this.name = name;
         }
 
         /**
          * Create an instance of a factory attribute.
          * @param attr the newly created factory attribute
          */
         public void addAttribute(final Attribute attr) {
             attributes.addElement(attr);
         }
 
         /**
          * return the attribute elements.
          * @return the enumeration of attributes
          */
         public Enumeration getAttributes() {
             return attributes.elements();
         }
 
         /**
          * A JAXP factory attribute. This is mostly processor specific, for
          * example for Xalan 2.3+, the following attributes could be set:
          * <ul>
          *  <li>http://xml.apache.org/xalan/features/optimize (true|false) </li>
          *  <li>http://xml.apache.org/xalan/features/incremental (true|false) </li>
          * </ul>
          */
         public static class Attribute implements DynamicConfigurator {
 
             /** attribute name, mostly processor specific */
             private String name;
 
             /** attribute value, often a boolean string */
             private Object value;
 
             /**
              * @return the attribute name.
              */
             public String getName() {
                 return name;
             }
 
             /**
              * @return the output property value.
              */
             public Object getValue() {
                 return value;
             }
 
             /**
              * Not used.
              * @param name not used
              * @return null
              * @throws BuildException never
              */
             public Object createDynamicElement(final String name) throws BuildException {
                 return null;
             }
 
             /**
              * Set an attribute.
              * Only "name" and "value" are supported as names.
              * @param name the name of the attribute
              * @param value the value of the attribute
              * @throws BuildException on error
              */
             public void setDynamicAttribute(final String name, final String value) throws BuildException {
                 // only 'name' and 'value' exist.
                 if ("name".equalsIgnoreCase(name)) {
                     this.name = value;
                 } else if ("value".equalsIgnoreCase(name)) {
                     // a value must be of a given type
                     // say boolean|integer|string that are mostly used.
                     if ("true".equalsIgnoreCase(value)) {
                         this.value = Boolean.TRUE;
                     } else if ("false".equalsIgnoreCase(value)) {
                         this.value = Boolean.FALSE;
                     } else {
                         try {
                             this.value = new Integer(value);
                         } catch (final NumberFormatException e) {
                             this.value = value;
                         }
                     }
                 } else {
                     throw new BuildException("Unsupported attribute: " + name);
                 }
             }
         } // -- class Attribute
     } // -- class Factory
 
     /**
      * Mapper implementation of the "traditional" way &lt;xslt&gt;
      * mapped filenames.
      *
      * <p>If the file has an extension, chop it off.  Append whatever
      * the user has specified as extension or ".html".</p>
      *
      * @since Ant 1.6.2
      */
     private class StyleMapper implements FileNameMapper {
         public void setFrom(final String from) {
         }
         public void setTo(final String to) {
         }
         public String[] mapFileName(String xmlFile) {
             final int dotPos = xmlFile.lastIndexOf('.');
             if (dotPos > 0) {
                 xmlFile = xmlFile.substring(0, dotPos);
             }
             return new String[] {xmlFile + targetExtension};
         }
     }
 
     /**
      * Configuration for Xalan2 traces.
      *
      * @since Ant 1.8.0
      */
     public final class TraceConfiguration {
         private boolean elements, extension, generation, selection, templates;
 
         /**
          * Set to true if the listener is to print events that occur
          * as each node is 'executed' in the stylesheet.
          */
         public void setElements(final boolean b) {
             elements = b;
         }
 
         /**
          * True if the listener is to print events that occur as each
          * node is 'executed' in the stylesheet.
          */
         public boolean getElements() {
             return elements;
         }
 
         /**
          * Set to true if the listener is to print information after
          * each extension event.
          */
         public void setExtension(final boolean b) {
             extension = b;
         }
 
         /**
          * True if the listener is to print information after each
          * extension event.
          */
         public boolean getExtension() {
             return extension;
         }
 
         /**
          * Set to true if the listener is to print information after
          * each result-tree generation event.
          */
         public void setGeneration(final boolean b) {
             generation = b;
         }
 
         /**
          * True if the listener is to print information after each
          * result-tree generation event.
          */
         public boolean getGeneration() {
             return generation;
         }
 
         /**
          * Set to true if the listener is to print information after
          * each selection event.
          */
         public void setSelection(final boolean b) {
             selection = b;
         }
 
         /**
          * True if the listener is to print information after each
          * selection event.
          */
         public boolean getSelection() {
             return selection;
         }
 
         /**
          * Set to true if the listener is to print an event whenever a
          * template is invoked.
          */
         public void setTemplates(final boolean b) {
             templates = b;
         }
 
         /**
          * True if the listener is to print an event whenever a
          * template is invoked.
          */
         public boolean getTemplates() {
             return templates;
         }
 
         /**
          * The stream to write traces to.
          */
         public java.io.OutputStream getOutputStream() {
             return new LogOutputStream(XSLTProcess.this);
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/condition/Os.java b/src/main/org/apache/tools/ant/taskdefs/condition/Os.java
index b1f9fca6f..974c396fb 100644
--- a/src/main/org/apache/tools/ant/taskdefs/condition/Os.java
+++ b/src/main/org/apache/tools/ant/taskdefs/condition/Os.java
@@ -1,321 +1,321 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.condition;
 
 import java.util.Locale;
 
 import org.apache.tools.ant.BuildException;
 
 /**
  * Condition that tests the OS type.
  *
  * @since Ant 1.4
  */
 public class Os implements Condition {
     private static final String OS_NAME =
         System.getProperty("os.name").toLowerCase(Locale.ENGLISH);
     private static final String OS_ARCH =
         System.getProperty("os.arch").toLowerCase(Locale.ENGLISH);
     private static final String OS_VERSION =
         System.getProperty("os.version").toLowerCase(Locale.ENGLISH);
     private static final String PATH_SEP =
         System.getProperty("path.separator");
 
     /**
      * OS family to look for
      */
     private String family;
     /**
      * Name of OS
      */
     private String name;
     /**
      * version of OS
      */
     private String version;
     /**
      * OS architecture
      */
     private String arch;
     /**
      * OS family that can be tested for. {@value}
      */
     public static final String FAMILY_WINDOWS = "windows";
     /**
      * OS family that can be tested for. {@value}
      */
     public static final String FAMILY_9X = "win9x";
     /**
      * OS family that can be tested for. {@value}
      */
     public static final String FAMILY_NT = "winnt";
     /**
      * OS family that can be tested for. {@value}
      */
     public static final String FAMILY_OS2 = "os/2";
     /**
      * OS family that can be tested for. {@value}
      */
     public static final String FAMILY_NETWARE = "netware";
     /**
      * OS family that can be tested for. {@value}
      */
     public static final String FAMILY_DOS = "dos";
     /**
      * OS family that can be tested for. {@value}
      */
     public static final String FAMILY_MAC = "mac";
     /**
      * OS family that can be tested for. {@value}
      */
     public static final String FAMILY_TANDEM = "tandem";
     /**
      * OS family that can be tested for. {@value}
      */
     public static final String FAMILY_UNIX = "unix";
     /**
      * OS family that can be tested for. {@value}
      */
     public static final String FAMILY_VMS = "openvms";
     /**
      * OS family that can be tested for. {@value}
      */
     public static final String FAMILY_ZOS = "z/os";
     /** OS family that can be tested for. {@value} */
     public static final String FAMILY_OS400 = "os/400";
 
     /**
      * OpenJDK is reported to call MacOS X "Darwin"
      * @see https://issues.apache.org/bugzilla/show_bug.cgi?id=44889
      * @see https://issues.apache.org/jira/browse/HADOOP-3318
      */
     private static final String DARWIN = "darwin";
 
     /**
      * Default constructor
      *
      */
     public Os() {
         //default
     }
 
     /**
      * Constructor that sets the family attribute
      * @param family a String value
      */
     public Os(String family) {
         setFamily(family);
     }
 
     /**
      * Sets the desired OS family type
      *
      * @param f      The OS family type desired<br>
      *               Possible values:<br>
      *               <ul>
      *               <li>dos</li>
      *               <li>mac</li>
      *               <li>netware</li>
      *               <li>os/2</li>
      *               <li>tandem</li>
      *               <li>unix</li>
      *               <li>windows</li>
      *               <li>win9x</li>
      *               <li>z/os</li>
      *               <li>os/400</li>
      *               </ul>
      */
     public void setFamily(String f) {
         family = f.toLowerCase(Locale.ENGLISH);
     }
 
     /**
      * Sets the desired OS name
      *
      * @param name   The OS name
      */
     public void setName(String name) {
         this.name = name.toLowerCase(Locale.ENGLISH);
     }
 
     /**
      * Sets the desired OS architecture
      *
      * @param arch   The OS architecture
      */
     public void setArch(String arch) {
         this.arch = arch.toLowerCase(Locale.ENGLISH);
     }
 
     /**
      * Sets the desired OS version
      *
      * @param version   The OS version
      */
     public void setVersion(String version) {
         this.version = version.toLowerCase(Locale.ENGLISH);
     }
 
     /**
      * Determines if the OS on which Ant is executing matches the type of
      * that set in setFamily.
      * @return true if the os matches.
      * @throws BuildException if there is an error.
      * @see Os#setFamily(String)
      */
     public boolean eval() throws BuildException {
         return isOs(family, name, arch, version);
     }
 
     /**
      * Determines if the OS on which Ant is executing matches the
      * given OS family.
      * @param family the family to check for
      * @return true if the OS matches
      * @since 1.5
      */
     public static boolean isFamily(String family) {
         return isOs(family, null, null, null);
     }
 
     /**
      * Determines if the OS on which Ant is executing matches the
      * given OS name.
      *
      * @param name the OS name to check for
      * @return true if the OS matches
      * @since 1.7
      */
     public static boolean isName(String name) {
         return isOs(null, name, null, null);
     }
 
     /**
      * Determines if the OS on which Ant is executing matches the
      * given OS architecture.
      *
      * @param arch the OS architecture to check for
      * @return true if the OS matches
      * @since 1.7
      */
     public static boolean isArch(String arch) {
         return isOs(null, null, arch, null);
     }
 
     /**
      * Determines if the OS on which Ant is executing matches the
      * given OS version.
      *
      * @param version the OS version to check for
      * @return true if the OS matches
      * @since 1.7
      */
     public static boolean isVersion(String version) {
         return isOs(null, null, null, version);
     }
 
     /**
      * Determines if the OS on which Ant is executing matches the
      * given OS family, name, architecture and version
      *
      * @param family   The OS family
      * @param name   The OS name
      * @param arch   The OS architecture
      * @param version   The OS version
      * @return true if the OS matches
      * @since 1.7
      */
     public static boolean isOs(String family, String name, String arch,
                                String version) {
         boolean retValue = false;
 
         if (family != null || name != null || arch != null
             || version != null) {
 
             boolean isFamily = true;
             boolean isName = true;
             boolean isArch = true;
             boolean isVersion = true;
 
             if (family != null) {
 
                 //windows probing logic relies on the word 'windows' in
                 //the OS
                 boolean isWindows = OS_NAME.indexOf(FAMILY_WINDOWS) > -1;
                 boolean is9x = false;
                 boolean isNT = false;
                 if (isWindows) {
                     //there are only four 9x platforms that we look for
                     is9x = (OS_NAME.indexOf("95") >= 0
                             || OS_NAME.indexOf("98") >= 0
                             || OS_NAME.indexOf("me") >= 0
                             //wince isn't really 9x, but crippled enough to
-                            //be a muchness. Ant doesnt run on CE, anyway.
+                            //be a muchness. Ant doesn't run on CE, anyway.
                             || OS_NAME.indexOf("ce") >= 0);
                     isNT = !is9x;
                 }
                 if (family.equals(FAMILY_WINDOWS)) {
                     isFamily = isWindows;
                 } else if (family.equals(FAMILY_9X)) {
                     isFamily = isWindows && is9x;
                 } else if (family.equals(FAMILY_NT)) {
                     isFamily = isWindows && isNT;
                 } else if (family.equals(FAMILY_OS2)) {
                     isFamily = OS_NAME.indexOf(FAMILY_OS2) > -1;
                 } else if (family.equals(FAMILY_NETWARE)) {
                     isFamily = OS_NAME.indexOf(FAMILY_NETWARE) > -1;
                 } else if (family.equals(FAMILY_DOS)) {
                     isFamily = PATH_SEP.equals(";") && !isFamily(FAMILY_NETWARE);
                 } else if (family.equals(FAMILY_MAC)) {
                     isFamily = OS_NAME.indexOf(FAMILY_MAC) > -1
                         || OS_NAME.indexOf(DARWIN) > -1;
                 } else if (family.equals(FAMILY_TANDEM)) {
                     isFamily = OS_NAME.indexOf("nonstop_kernel") > -1;
                 } else if (family.equals(FAMILY_UNIX)) {
                     isFamily = PATH_SEP.equals(":")
                         && !isFamily(FAMILY_VMS)
                         && (!isFamily(FAMILY_MAC) || OS_NAME.endsWith("x")
                             || OS_NAME.indexOf(DARWIN) > -1);
                 } else if (family.equals(FAMILY_ZOS)) {
                     isFamily = OS_NAME.indexOf(FAMILY_ZOS) > -1
                         || OS_NAME.indexOf("os/390") > -1;
                 } else if (family.equals(FAMILY_OS400)) {
                     isFamily = OS_NAME.indexOf(FAMILY_OS400) > -1;
                 } else if (family.equals(FAMILY_VMS)) {
                     isFamily = OS_NAME.indexOf(FAMILY_VMS) > -1;
                 } else {
                     throw new BuildException(
                         "Don\'t know how to detect os family \""
                         + family + "\"");
                 }
             }
             if (name != null) {
                 isName = name.equals(OS_NAME);
             }
             if (arch != null) {
                 isArch = arch.equals(OS_ARCH);
             }
             if (version != null) {
                 isVersion = version.equals(OS_VERSION);
             }
             retValue = isFamily && isName && isArch && isVersion;
         }
         return retValue;
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/PropertyFile.java b/src/main/org/apache/tools/ant/taskdefs/optional/PropertyFile.java
index 838f122a0..162cab1a4 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/PropertyFile.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/PropertyFile.java
@@ -1,726 +1,726 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional;
 
 import java.io.BufferedInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.text.DateFormat;
 import java.text.DecimalFormat;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Vector;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.LayoutPreservingProperties;
 
 /**
  * Modifies settings in a property file.
  *
  * <p>The following is an example of its usage:</p>
  * <pre>
  *    &lt;target name="setState"&gt;
  *      &lt;property
  *        name="header"
  *        value="##Generated file - do not modify!"/&gt;
  *      &lt;propertyfile file="apropfile.properties" comment="${header}"&gt;
  *        &lt;entry key="product.version.major" type="int"  value="5"/&gt;
  *        &lt;entry key="product.version.minor" type="int"  value="0"/&gt;
  *        &lt;entry key="product.build.major"   type="int"  value="0" /&gt;
  *        &lt;entry key="product.build.minor"   type="int"  operation="+" /&gt;
  *        &lt;entry key="product.build.date"    type="date" value="now" /&gt;
  *        &lt;entry key="intSet" type="int" operation="=" value="681"/&gt;
  *        &lt;entry key="intDec" type="int" operation="-"/&gt;
  *        &lt;entry key="StringEquals" type="string" value="testValue"/&gt;
  *     &lt;/propertyfile&gt;
  *   &lt;/target&gt;
  * </pre>
  *
  * The &lt;propertyfile&gt; task must have:
  * <ul>
  *   <li>file</li>
  * </ul>
  * Other parameters are:
  * <ul>
  *   <li>comment</li>
  *   <li>key</li>
  *   <li>operation</li>
  *   <li>type</li>
  *   <li>value (the final four being eliminated shortly)</li>
  * </ul>
  *
  * The &lt;entry&gt; task must have:
  * <ul>
  *   <li>key</li>
  * </ul>
  * Other parameters are:
  * <ul>
  *   <li>operation</li>
  *   <li>type</li>
  *   <li>value</li>
  *   <li>default</li>
  *   <li>unit</li>
  * </ul>
  *
  * If type is unspecified, it defaults to string.
  *
  * Parameter values:
  * <ul>
  *   <li>operation:</li>
  *   <ul>
  *     <li>"=" (set -- default)</li>
  *     <li>"-" (dec)</li>
  *     <li>"+" (inc)</li>
  *   </ul>
  *   <li>type:</li>
  *   <ul>
  *     <li>"int"</li>
  *     <li>"date"</li>
  *     <li>"string"</li>
  *   </ul>
  *   <li>value:</li>
  *   <ul>
  *     <li>holds the default value, if the property
  *              was not found in property file</li>
  *     <li>"now" In case of type "date", the
  *              value "now" will be replaced by the current
  *              date/time and used even if a valid date was
  *              found in the property file.</li>
  *   </ul>
  * </ul>
  *
  * <p>String property types can only use the "=" operation.
  * Int property types can only use the "=", "-" or "+" operations.<p>
  *
  * The message property is used for the property file header, with "\\" being
  * a newline delimiter character.
  *
  */
 public class PropertyFile extends Task {
 
     /* ========================================================================
      *
      * Instance variables.
      */
 
     // Use this to prepend a message to the properties file
     private String              comment;
 
     private Properties          properties;
     private File                propertyfile;
     private boolean             useJDKProperties;
 
     private Vector entries = new Vector();
 
     /* ========================================================================
      *
      * Constructors
      */
 
     /* ========================================================================
      *
      * Methods
      */
 
     /**
      * Execute the task.
      * @throws BuildException on error.
      */
     @Override
     public void execute() throws BuildException {
         checkParameters();
         readFile();
         executeOperation();
         writeFile();
     }
 
     /**
      * The entry nested element.
      * @return an entry nested element to be configured.
      */
     public Entry createEntry() {
         Entry e = new Entry();
         entries.addElement(e);
         return e;
     }
 
     private void executeOperation() throws BuildException {
         for (Enumeration e = entries.elements(); e.hasMoreElements();) {
             Entry entry = (Entry) e.nextElement();
             entry.executeOn(properties);
         }
     }
 
     private void readFile() throws BuildException {
         if (useJDKProperties) {
             // user chose to use standard Java properties, which loose
             // comments and layout
             properties = new Properties();
         } else {
             properties = new LayoutPreservingProperties();
         }
         try {
             if (propertyfile.exists()) {
                 log("Updating property file: "
                     + propertyfile.getAbsolutePath());
                 FileInputStream fis = null;
                 try {
                     fis = new FileInputStream(propertyfile);
                     BufferedInputStream bis = new BufferedInputStream(fis);
                     properties.load(bis);
                 } finally {
                     if (fis != null) {
                         fis.close();
                     }
                 }
             } else {
                 log("Creating new property file: "
                     + propertyfile.getAbsolutePath());
                 FileOutputStream out = null;
                 try {
                     out = new FileOutputStream(propertyfile.getAbsolutePath());
                     out.flush();
                 } finally {
                     if (out != null) {
                         out.close();
                     }
                 }
             }
         } catch (IOException ioe) {
             throw new BuildException(ioe.toString());
         }
     }
 
     private void checkParameters() throws BuildException {
         if (!checkParam(propertyfile)) {
             throw new BuildException("file token must not be null.",
                                      getLocation());
         }
     }
 
     /**
      * Location of the property file to be edited; required.
      * @param file the property file.
      */
     public void setFile(File file) {
         propertyfile = file;
     }
 
     /**
      * optional header comment for the file
      * @param hdr the string to use for the comment.
      */
     public void setComment(String hdr) {
         comment = hdr;
     }
 
     /**
      * optional flag to use original Java properties (as opposed to
      * layout preserving properties)
      */
     public void setJDKProperties(boolean val) {
         useJDKProperties = val;
     }
 
     private void writeFile() throws BuildException {
         // Write to RAM first, as an OOME could otherwise produce a truncated file:
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         try {
             properties.store(baos, comment);
         } catch (IOException x) { // should not happen
             throw new BuildException(x, getLocation());
         }
         try {
             OutputStream os = new FileOutputStream(propertyfile);
             try {
                 try {
                     os.write(baos.toByteArray());
                 } finally {
                     os.close();
                 }
             } catch (IOException x) { // possibly corrupt
                 FileUtils.getFileUtils().tryHardToDelete(propertyfile);
                 throw x;
             }
         } catch (IOException x) { // opening, writing, or closing
             throw new BuildException(x, getLocation());
         }
     }
 
     private boolean checkParam(File param) {
         return !(param == null);
     }
 
     /**
      * Instance of this class represents nested elements of
      * a task propertyfile.
      */
     public static class Entry {
         private static final int DEFAULT_INT_VALUE = 0;
         private static final String DEFAULT_DATE_VALUE = "now";
         private static final String DEFAULT_STRING_VALUE = "";
 
         private String              key = null;
         private int                 type = Type.STRING_TYPE;
         private int                 operation = Operation.EQUALS_OPER;
         private String              value = null;
         private String              defaultValue = null;
         private String              newValue = null;
         private String              pattern = null;
         private int                 field = Calendar.DATE;
 
         /**
          * Name of the property name/value pair
          * @param value the key.
          */
         public void setKey(String value) {
             this.key = value;
         }
 
         /**
          * Value to set (=), to add (+) or subtract (-)
          * @param value the value.
          */
         public void setValue(String value) {
             this.value = value;
         }
 
         /**
          * operation to apply.
          * &quot;+&quot; or &quot;=&quot;
          *(default) for all datatypes; &quot;-&quot; for date and int only)\.
          * @param value the operation enumerated value.
          */
         public void setOperation(Operation value) {
             this.operation = Operation.toOperation(value.getValue());
         }
 
         /**
          * Regard the value as : int, date or string (default)
          * @param value the type enumerated value.
          */
         public void setType(Type value) {
             this.type = Type.toType(value.getValue());
         }
 
         /**
          * Initial value to set for a property if it is not
          * already defined in the property file.
          * For type date, an additional keyword is allowed: &quot;now&quot;
          * @param value the default value.
          */
         public void setDefault(String value) {
             this.defaultValue = value;
         }
 
         /**
          * For int and date type only. If present, Values will
          * be parsed and formatted accordingly.
          * @param value the pattern to use.
          */
         public void setPattern(String value) {
             this.pattern = value;
         }
 
         /**
          * The unit of the value to be applied to date +/- operations.
          *            Valid Values are:
          *            <ul>
          *               <li>millisecond</li>
          *               <li>second</li>
          *               <li>minute</li>
          *               <li>hour</li>
          *               <li>day (default)</li>
          *               <li>week</li>
          *               <li>month</li>
          *               <li>year</li>
          *            </ul>
          *            This only applies to date types using a +/- operation.
          * @param unit the unit enumerated value.
          * @since Ant 1.5
          */
         public void setUnit(PropertyFile.Unit unit) {
             field = unit.getCalendarField();
         }
 
         /**
          * Apply the nested element to the properties.
          * @param props the properties to apply the entry on.
          * @throws BuildException if there is an error.
          */
         protected void executeOn(Properties props) throws BuildException {
             checkParameters();
 
             if (operation == Operation.DELETE_OPER) {
                 props.remove(key);
                 return;
             }
 
             // type may be null because it wasn't set
             String oldValue = (String) props.get(key);
             try {
                 if (type == Type.INTEGER_TYPE) {
                     executeInteger(oldValue);
                 } else if (type == Type.DATE_TYPE) {
                     executeDate(oldValue);
                 } else if (type == Type.STRING_TYPE) {
                     executeString(oldValue);
                 } else {
                     throw new BuildException("Unknown operation type: "
                                              + type);
                 }
             } catch (NullPointerException npe) {
                 // Default to string type
                 // which means do nothing
                 npe.printStackTrace();
             }
 
             if (newValue == null) {
                 newValue = "";
             }
 
             // Insert as a string by default
             props.put(key, newValue);
         }
 
         /**
          * Handle operations for type <code>date</code>.
          *
          * @param oldValue the current value read from the property file or
          *                 <code>null</code> if the <code>key</code> was
          *                 not contained in the property file.
          */
         private void executeDate(String oldValue) throws BuildException {
             Calendar currentValue = Calendar.getInstance();
 
             if (pattern == null) {
                 pattern = "yyyy/MM/dd HH:mm";
             }
             DateFormat fmt = new SimpleDateFormat(pattern);
 
             String currentStringValue = getCurrentValue(oldValue);
             if (currentStringValue == null) {
                 currentStringValue = DEFAULT_DATE_VALUE;
             }
 
             if ("now".equals(currentStringValue)) {
                 currentValue.setTime(new Date());
             } else {
                 try {
                     currentValue.setTime(fmt.parse(currentStringValue));
                 } catch (ParseException pe)  {
                     // swallow
                 }
             }
 
             if (operation != Operation.EQUALS_OPER) {
                 int offset = 0;
                 try {
                     offset = Integer.parseInt(value);
                     if (operation == Operation.DECREMENT_OPER) {
                         offset = -1 * offset;
                     }
                 } catch (NumberFormatException e) {
                     throw new BuildException("Value not an integer on " + key);
                 }
                 currentValue.add(field, offset);
             }
 
             newValue = fmt.format(currentValue.getTime());
         }
 
 
         /**
          * Handle operations for type <code>int</code>.
          *
          * @param oldValue the current value read from the property file or
          *                 <code>null</code> if the <code>key</code> was
          *                 not contained in the property file.
          */
         private void executeInteger(String oldValue) throws BuildException {
             int currentValue = DEFAULT_INT_VALUE;
             int newV  = DEFAULT_INT_VALUE;
 
 
             DecimalFormat fmt = (pattern != null) ? new DecimalFormat(pattern)
                 : new DecimalFormat();
             try {
                 String curval = getCurrentValue(oldValue);
                 if (curval != null) {
                     currentValue = fmt.parse(curval).intValue();
                 } else {
                     currentValue = 0;
                 }
             } catch (NumberFormatException nfe) {
                 // swallow
             } catch (ParseException pe)  {
                 // swallow
             }
 
             if (operation == Operation.EQUALS_OPER) {
                 newV = currentValue;
             } else {
                 int operationValue = 1;
                 if (value != null) {
                     try {
                         operationValue = fmt.parse(value).intValue();
                     } catch (NumberFormatException nfe) {
                         // swallow
                     } catch (ParseException pe)  {
                         // swallow
                     }
                 }
 
                 if (operation == Operation.INCREMENT_OPER) {
                     newV = currentValue + operationValue;
                 } else if (operation == Operation.DECREMENT_OPER) {
                     newV = currentValue - operationValue;
                 }
             }
 
             this.newValue = fmt.format(newV);
         }
 
         /**
          * Handle operations for type <code>string</code>.
          *
          * @param oldValue the current value read from the property file or
          *                 <code>null</code> if the <code>key</code> was
          *                 not contained in the property file.
          */
         private void executeString(String oldValue) throws BuildException {
             String newV  = DEFAULT_STRING_VALUE;
 
             String currentValue = getCurrentValue(oldValue);
 
             if (currentValue == null) {
                 currentValue = DEFAULT_STRING_VALUE;
             }
 
             if (operation == Operation.EQUALS_OPER) {
                 newV = currentValue;
             } else if (operation == Operation.INCREMENT_OPER) {
                 newV = currentValue + value;
             }
             this.newValue = newV;
         }
 
         /**
          * Check if parameter combinations can be supported
          * @todo make sure the 'unit' attribute is only specified on date
          *      fields
          */
         private void checkParameters() throws BuildException {
             if (type == Type.STRING_TYPE
                 && operation == Operation.DECREMENT_OPER) {
                 throw new BuildException("- is not supported for string "
                                          + "properties (key:" + key + ")");
             }
             if (value == null && defaultValue == null  && operation != Operation.DELETE_OPER) {
                 throw new BuildException("\"value\" and/or \"default\" "
                                          + "attribute must be specified (key:" + key + ")");
             }
             if (key == null) {
                 throw new BuildException("key is mandatory");
             }
             if (type == Type.STRING_TYPE && pattern != null) {
                 throw new BuildException("pattern is not supported for string "
                                          + "properties (key:" + key + ")");
             }
         }
 
         private String getCurrentValue(String oldValue) {
             String ret = null;
             if (operation == Operation.EQUALS_OPER) {
                 // If only value is specified, the property is set to it
                 // regardless of its previous value.
                 if (value != null && defaultValue == null) {
                     ret = value;
                 }
 
                 // If only default is specified and the property previously
                 // existed in the property file, it is unchanged.
                 if (value == null && defaultValue != null && oldValue != null) {
                     ret = oldValue;
                 }
 
                 // If only default is specified and the property did not
                 // exist in the property file, the property is set to default.
                 if (value == null && defaultValue != null && oldValue == null) {
                     ret = defaultValue;
                 }
 
                 // If value and default are both specified and the property
                 // previously existed in the property file, the property
                 // is set to value.
                 if (value != null && defaultValue != null && oldValue != null) {
                     ret = value;
                 }
 
                 // If value and default are both specified and the property
                 // did not exist in the property file, the property is set
                 // to default.
                 if (value != null && defaultValue != null && oldValue == null) {
                     ret = defaultValue;
                 }
             } else {
                 ret = (oldValue == null) ? defaultValue : oldValue;
             }
 
             return ret;
         }
 
         /**
          * Enumerated attribute with the values "+", "-", "="
          */
         public static class Operation extends EnumeratedAttribute {
 
             // Property type operations
             /** + */
             public static final int INCREMENT_OPER =   0;
             /** - */
             public static final int DECREMENT_OPER =   1;
             /** = */
             public static final int EQUALS_OPER =      2;
             /** del */
             public static final int DELETE_OPER =      3;
 
             /** {@inheritDoc}. */
             @Override
             public String[] getValues() {
                 return new String[] {"+", "-", "=", "del"};
             }
 
             /**
              * Convert string to index.
              * @param oper the string to convert.
              * @return the index.
              */
             public static int toOperation(String oper) {
                 if ("+".equals(oper)) {
                     return INCREMENT_OPER;
                 } else if ("-".equals(oper)) {
                     return DECREMENT_OPER;
                 } else if ("del".equals(oper)) {
                     return DELETE_OPER;
                 }
                 return EQUALS_OPER;
             }
         }
 
         /**
          * Enumerated attribute with the values "int", "date" and "string".
          */
         public static class Type extends EnumeratedAttribute {
 
             // Property types
             /** int */
             public static final int INTEGER_TYPE =     0;
             /** date */
             public static final int DATE_TYPE =        1;
             /** string */
             public static final int STRING_TYPE =      2;
 
             /** {@inheritDoc} */
             @Override
             public String[] getValues() {
                 return new String[] {"int", "date", "string"};
             }
 
             /**
              * Convert string to index.
              * @param type the string to convert.
              * @return the index.
              */
             public static int toType(String type) {
                 if ("int".equals(type)) {
                     return INTEGER_TYPE;
                 } else if ("date".equals(type)) {
                     return DATE_TYPE;
                 }
                 return STRING_TYPE;
             }
         }
     }
 
     /**
      * Borrowed from Tstamp
      * @todo share all this time stuff across many tasks as a datetime datatype
      * @since Ant 1.5
      */
     public static class Unit extends EnumeratedAttribute {
 
         private static final String MILLISECOND = "millisecond";
         private static final String SECOND = "second";
         private static final String MINUTE = "minute";
         private static final String HOUR = "hour";
         private static final String DAY = "day";
         private static final String WEEK = "week";
         private static final String MONTH = "month";
         private static final String YEAR = "year";
 
         private static final String[] UNITS
             = {MILLISECOND, SECOND, MINUTE, HOUR,
                DAY, WEEK, MONTH, YEAR };
 
         private Map calendarFields = new HashMap();
 
         /** no arg constructor */
         public Unit() {
             calendarFields.put(MILLISECOND,
                                new Integer(Calendar.MILLISECOND));
             calendarFields.put(SECOND, new Integer(Calendar.SECOND));
             calendarFields.put(MINUTE, new Integer(Calendar.MINUTE));
             calendarFields.put(HOUR, new Integer(Calendar.HOUR_OF_DAY));
             calendarFields.put(DAY, new Integer(Calendar.DATE));
             calendarFields.put(WEEK, new Integer(Calendar.WEEK_OF_YEAR));
             calendarFields.put(MONTH, new Integer(Calendar.MONTH));
             calendarFields.put(YEAR, new Integer(Calendar.YEAR));
         }
 
         /**
          * Convert the value to a Calendar field index.
-         * @return the calander value.
+         * @return the calendar value.
          */
         public int getCalendarField() {
             String key = getValue().toLowerCase();
             Integer i = (Integer) calendarFields.get(key);
             return i.intValue();
         }
 
         /** {@inheritDoc}. */
         @Override
         public String[] getValues() {
             return UNITS;
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/TraXLiaison.java b/src/main/org/apache/tools/ant/taskdefs/optional/TraXLiaison.java
index cf66e913e..8d9a44a65 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/TraXLiaison.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/TraXLiaison.java
@@ -1,650 +1,650 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.reflect.Field;
 import java.net.URL;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Vector;
 
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.parsers.SAXParserFactory;
 import javax.xml.transform.ErrorListener;
 import javax.xml.transform.Source;
 import javax.xml.transform.SourceLocator;
 import javax.xml.transform.Templates;
 import javax.xml.transform.Transformer;
 import javax.xml.transform.TransformerConfigurationException;
 import javax.xml.transform.TransformerException;
 import javax.xml.transform.TransformerFactory;
 import javax.xml.transform.URIResolver;
 import javax.xml.transform.sax.SAXSource;
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.transform.stream.StreamSource;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.XSLTLiaison4;
 import org.apache.tools.ant.taskdefs.XSLTLogger;
 import org.apache.tools.ant.taskdefs.XSLTLoggerAware;
 import org.apache.tools.ant.taskdefs.XSLTProcess;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.XMLCatalog;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.URLProvider;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.JAXPUtils;
 import org.xml.sax.EntityResolver;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 import org.xml.sax.XMLReader;
 
 /**
  * Concrete liaison for XSLT processor implementing TraX. (ie JAXP 1.1)
  *
  * @since Ant 1.3
  */
 public class TraXLiaison implements XSLTLiaison4, ErrorListener, XSLTLoggerAware {
 
     /**
      * Helper for transforming filenames to URIs.
      *
      * @since Ant 1.7
      */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * The current <code>Project</code>
      */
     private Project project;
 
     /**
      * the name of the factory implementation class to use
      * or null for default JAXP lookup.
      */
     private String factoryName = null;
 
     /** The trax TransformerFactory */
     private TransformerFactory tfactory = null;
 
     /** stylesheet to use for transformation */
     private Resource stylesheet;
 
     private XSLTLogger logger;
 
     /** possible resolver for publicIds */
     private EntityResolver entityResolver;
 
     /** transformer to use for processing files */
     private Transformer transformer;
 
     /** The In memory version of the stylesheet */
     private Templates templates;
 
     /**
      * The modification time of the stylesheet from which the templates
      * are read
      */
     private long templatesModTime;
 
     /** possible resolver for URIs */
     private URIResolver uriResolver;
 
     /** transformer output properties */
     private final Vector outputProperties = new Vector();
 
     /** stylesheet parameters */
     private final Hashtable<String, Object> params = new Hashtable<String, Object>();
 
     /** factory attributes */
     private final Vector attributes = new Vector();
 
     /** whether to suppress warnings */
     private boolean suppressWarnings = false;
 
     /** optional trace configuration. */
     private XSLTProcess.TraceConfiguration traceConfiguration = null;
 
     /**
      * Constructor for TraXLiaison.
      * @throws Exception never
      */
     public TraXLiaison() throws Exception {
     }
 
     /**
      * Set the stylesheet file.
      * @param stylesheet a <code>File</code> value
      * @throws Exception on error
      */
     public void setStylesheet(final File stylesheet) throws Exception {
         final FileResource fr = new FileResource();
         fr.setProject(project);
         fr.setFile(stylesheet);
         setStylesheet(fr);
     }
 
     /**
      * Set the stylesheet file.
      * @param stylesheet a {@link org.apache.tools.ant.types.Resource} value
      * @throws Exception on error
      */
     public void setStylesheet(final Resource stylesheet) throws Exception {
         if (this.stylesheet != null) {
             // resetting the stylesheet - reset transformer
             transformer = null;
 
             // do we need to reset templates as well
             if (!this.stylesheet.equals(stylesheet)
                 || (stylesheet.getLastModified() != templatesModTime)) {
                 templates = null;
             }
         }
         this.stylesheet = stylesheet;
     }
 
     /**
      * Transform an input file.
      * @param infile the file to transform
      * @param outfile the result file
      * @throws Exception on error
      */
     public void transform(final File infile, final File outfile) throws Exception {
         if (transformer == null) {
             createTransformer();
         }
 
         InputStream fis = null;
         OutputStream fos = null;
         try {
             fis = new BufferedInputStream(new FileInputStream(infile));
             fos = new BufferedOutputStream(new FileOutputStream(outfile));
             final StreamResult res = new StreamResult(fos);
             // not sure what could be the need of this...
             res.setSystemId(JAXPUtils.getSystemId(outfile));
             final Source src = getSource(fis, infile);
 
             // set parameters on each transformation, maybe something has changed
             //(e.g. value of file name parameter)
             setTransformationParameters();
 
             transformer.transform(src, res);
         } finally {
             // make sure to close all handles, otherwise the garbage
             // collector will close them...whenever possible and
             // Windows may complain about not being able to delete files.
             FileUtils.close(fis);
             FileUtils.close(fos);
         }
     }
 
     /**
      * Get the source instance from the stream and id of the file.
      * @param is the stream containing the stylesheet data.
      * @param infile the file that will be used for the systemid.
      * @return the configured source instance matching the stylesheet.
      * @throws ParserConfigurationException if a parser cannot be created which
      * satisfies the requested configuration.
      * @throws SAXException in case of problem detected by the SAX parser.
      */
     private Source getSource(final InputStream is, final File infile)
         throws ParserConfigurationException, SAXException {
         // todo: is this comment still relevant ??
         // FIXME: need to use a SAXSource as the source for the transform
         // so we can plug in our own entity resolver
         Source src = null;
         if (entityResolver != null) {
             if (getFactory().getFeature(SAXSource.FEATURE)) {
                 final SAXParserFactory spFactory = SAXParserFactory.newInstance();
                 spFactory.setNamespaceAware(true);
                 final XMLReader reader = spFactory.newSAXParser().getXMLReader();
                 reader.setEntityResolver(entityResolver);
                 src = new SAXSource(reader, new InputSource(is));
             } else {
                 throw new IllegalStateException("xcatalog specified, but "
                     + "parser doesn't support SAX");
             }
         } else {
             // WARN: Don't use the StreamSource(File) ctor. It won't work with
             // xalan prior to 2.2 because of systemid bugs.
             src = new StreamSource(is);
         }
         src.setSystemId(JAXPUtils.getSystemId(infile));
         return src;
     }
 
     private Source getSource(final InputStream is, final Resource resource)
         throws ParserConfigurationException, SAXException {
         // todo: is this comment still relevant ??
         // FIXME: need to use a SAXSource as the source for the transform
         // so we can plug in our own entity resolver
         Source src = null;
         if (entityResolver != null) {
             if (getFactory().getFeature(SAXSource.FEATURE)) {
                 final SAXParserFactory spFactory = SAXParserFactory.newInstance();
                 spFactory.setNamespaceAware(true);
                 final XMLReader reader = spFactory.newSAXParser().getXMLReader();
                 reader.setEntityResolver(entityResolver);
                 src = new SAXSource(reader, new InputSource(is));
             } else {
                 throw new IllegalStateException("xcatalog specified, but "
                     + "parser doesn't support SAX");
             }
         } else {
             // WARN: Don't use the StreamSource(File) ctor. It won't work with
             // xalan prior to 2.2 because of systemid bugs.
             src = new StreamSource(is);
         }
         // The line below is a hack: the system id must an URI, but it is not
         // cleat to get the URI of an resource, so just set the name of the
         // resource as a system id
         src.setSystemId(resourceToURI(resource));
         return src;
     }
 
     private String resourceToURI(final Resource resource) {
         final FileProvider fp = resource.as(FileProvider.class);
         if (fp != null) {
             return FILE_UTILS.toURI(fp.getFile().getAbsolutePath());
         }
         final URLProvider up = resource.as(URLProvider.class);
         if (up != null) {
             final URL u = up.getURL();
             return String.valueOf(u);
         } else {
             return resource.getName();
         }
     }
 
     /**
      * Read in templates from the stylesheet
      */
     private void readTemplates()
         throws IOException, TransformerConfigurationException,
                ParserConfigurationException, SAXException {
 
         // Use a stream so that you can close it yourself quickly
         // and avoid keeping the handle until the object is garbaged.
         // (always keep control), otherwise you won't be able to delete
         // the file quickly on windows.
         InputStream xslStream = null;
         try {
             xslStream
                 = new BufferedInputStream(stylesheet.getInputStream());
             templatesModTime = stylesheet.getLastModified();
             final Source src = getSource(xslStream, stylesheet);
             templates = getFactory().newTemplates(src);
         } finally {
             if (xslStream != null) {
                 xslStream.close();
             }
         }
     }
 
     /**
      * Create a new transformer based on the liaison settings
      * @throws Exception thrown if there is an error during creation.
      * @see #setStylesheet(java.io.File)
      * @see #addParam(java.lang.String, java.lang.String)
      * @see #setOutputProperty(java.lang.String, java.lang.String)
      */
     private void createTransformer() throws Exception {
         if (templates == null) {
             readTemplates();
         }
 
         transformer = templates.newTransformer();
 
         // configure the transformer...
         transformer.setErrorListener(this);
         if (uriResolver != null) {
             transformer.setURIResolver(uriResolver);
         }
         final int size = outputProperties.size();
         for (int i = 0; i < size; i++) {
             final String[] pair = (String[]) outputProperties.elementAt(i);
             transformer.setOutputProperty(pair[0], pair[1]);
         }
 
         if (traceConfiguration != null) {
             if ("org.apache.xalan.transformer.TransformerImpl"
                 .equals(transformer.getClass().getName())) {
                 try {
                     final Class traceSupport =
                         Class.forName("org.apache.tools.ant.taskdefs.optional."
                                       + "Xalan2TraceSupport", true,
                                       Thread.currentThread()
                                       .getContextClassLoader());
                     final XSLTTraceSupport ts =
                         (XSLTTraceSupport) traceSupport.newInstance();
                     ts.configureTrace(transformer, traceConfiguration);
                 } catch (final Exception e) {
                     final String msg = "Failed to enable tracing because of " + e;
                     if (project != null) {
                         project.log(msg, Project.MSG_WARN);
                     } else {
                         System.err.println(msg);
                     }
                 }
             } else {
                 final String msg = "Not enabling trace support for transformer"
                     + " implementation" + transformer.getClass().getName();
                 if (project != null) {
                     project.log(msg, Project.MSG_WARN);
                 } else {
                     System.err.println(msg);
                 }
             }
         }
     }
 
     /**
      * Sets the parameters for the transformer.
      */
     private void setTransformationParameters() {
         for (final Enumeration enumeration = params.keys();
              enumeration.hasMoreElements();) {
             final String name = (String) enumeration.nextElement();
             final Object value = params.get(name);
             transformer.setParameter(name, value);
         }
     }
 
     /**
      * return the Transformer factory associated to this liaison.
      * @return the Transformer factory associated to this liaison.
      * @throws BuildException thrown if there is a problem creating
      * the factory.
      * @see #setFactory(String)
      * @since Ant 1.5.2
      */
     private TransformerFactory getFactory() throws BuildException {
         if (tfactory != null) {
             return tfactory;
         }
         // not initialized yet, so create the factory
         if (factoryName == null) {
             tfactory = TransformerFactory.newInstance();
         } else {
             try {
                 Class clazz = null;
                 try {
                     clazz =
                         Class.forName(factoryName, true,
                                       Thread.currentThread()
                                       .getContextClassLoader());
                 } catch (final ClassNotFoundException cnfe) {
                     final String msg = "Failed to load " + factoryName
                         + " via the configured classpath, will try"
                         + " Ant's classpath instead.";
                     if (logger != null) {
                         logger.log(msg);
                     } else if (project != null) {
                         project.log(msg, Project.MSG_WARN);
                     } else {
                         System.err.println(msg);
                     }
                 }
 
                 if (clazz == null) {
                     clazz = Class.forName(factoryName);
                 }
                 tfactory = (TransformerFactory) clazz.newInstance();
             } catch (final Exception e) {
                 throw new BuildException(e);
             }
         }
 
         try { // #51668, #52382
             final Field _isNotSecureProcessing = tfactory.getClass().getDeclaredField("_isNotSecureProcessing");
             _isNotSecureProcessing.setAccessible(true);
             _isNotSecureProcessing.set(tfactory, Boolean.TRUE);
         } catch (final Exception x) {
             if (project != null) {
                 project.log(x.toString(), Project.MSG_DEBUG);
             }
         }
 
         tfactory.setErrorListener(this);
 
         // specific attributes for the transformer
         final int size = attributes.size();
         for (int i = 0; i < size; i++) {
             final Object[] pair = (Object[]) attributes.elementAt(i);
             tfactory.setAttribute((String) pair[0], pair[1]);
         }
 
         if (uriResolver != null) {
             tfactory.setURIResolver(uriResolver);
         }
         return tfactory;
     }
 
 
     /**
      * Set the factory name to use instead of JAXP default lookup.
      * @param name the fully qualified class name of the factory to use
      * or null for the default JAXP look up mechanism.
      * @since Ant 1.6
      */
     public void setFactory(final String name) {
         factoryName = name;
     }
 
     /**
      * Set a custom attribute for the JAXP factory implementation.
      * @param name the attribute name.
      * @param value the value of the attribute, usually a boolean
      * string or object.
      * @since Ant 1.6
      */
     public void setAttribute(final String name, final Object value) {
         final Object[] pair = new Object[]{name, value};
         attributes.addElement(pair);
     }
 
     /**
      * Set the output property for the current transformer.
      * Note that the stylesheet must be set prior to calling
      * this method.
      * @param name the output property name.
      * @param value the output property value.
      * @since Ant 1.5
      * @since Ant 1.5
      */
     public void setOutputProperty(final String name, final String value) {
         final String[] pair = new String[]{name, value};
         outputProperties.addElement(pair);
     }
 
     /**
      * Set the class to resolve entities during the transformation.
      * @param aResolver the resolver class.
      */
     public void setEntityResolver(final EntityResolver aResolver) {
         entityResolver = aResolver;
     }
 
     /**
      * Set the class to resolve URIs during the transformation
      * @param aResolver a <code>EntityResolver</code> value
      */
     public void setURIResolver(final URIResolver aResolver) {
         uriResolver = aResolver;
     }
 
     /**
      * Add a parameter.
      * @param name the name of the parameter
      * @param value the value of the parameter
      */
     public void addParam(final String name, final String value) {
         params.put(name, value);
     }
 
     /**
      * Add a parameter.
      * @param name the name of the parameter
      * @param value the value of the parameter
      * @since Ant 1.9.3
      */
     public void addParam(final String name, final Object value) {
         params.put(name, value);
     }
 
     /**
      * Set a logger.
      * @param l a logger.
      */
     public void setLogger(final XSLTLogger l) {
         logger = l;
     }
 
     /**
      * Log an error.
      * @param e the exception to log.
      */
     public void error(final TransformerException e) {
         logError(e, "Error");
     }
 
     /**
      * Log a fatal error.
      * @param e the exception to log.
      */
     public void fatalError(final TransformerException e) {
         logError(e, "Fatal Error");
         throw new BuildException("Fatal error during transformation using " + stylesheet + ": " + e.getMessageAndLocation(), e);
     }
 
     /**
      * Log a warning.
      * @param e the exception to log.
      */
     public void warning(final TransformerException e) {
         if (!suppressWarnings) {
             logError(e, "Warning");
         }
     }
 
     private void logError(final TransformerException e, final String type) {
         if (logger == null) {
             return;
         }
 
         final StringBuffer msg = new StringBuffer();
         final SourceLocator locator = e.getLocator();
         if (locator != null) {
             final String systemid = locator.getSystemId();
             if (systemid != null) {
                 String url = systemid;
                 if (url.startsWith("file:")) {
                     url = FileUtils.getFileUtils().fromURI(url);
                 }
                 msg.append(url);
             } else {
                 msg.append("Unknown file");
             }
             final int line = locator.getLineNumber();
             if (line != -1) {
                 msg.append(":");
                 msg.append(line);
                 final int column = locator.getColumnNumber();
                 if (column != -1) {
                     msg.append(":");
                     msg.append(column);
                 }
             }
         }
         msg.append(": ");
         msg.append(type);
         msg.append("! ");
         msg.append(e.getMessage());
         if (e.getCause() != null) {
             msg.append(" Cause: ");
             msg.append(e.getCause());
         }
 
         logger.log(msg.toString());
     }
 
     // kept for backwards compatibility
     /**
      * @param file the filename to use for the systemid
      * @return the systemid
      * @deprecated since 1.5.x.
      *             Use org.apache.tools.ant.util.JAXPUtils#getSystemId instead.
      */
     @Deprecated
     protected String getSystemId(final File file) {
         return JAXPUtils.getSystemId(file);
     }
 
 
     /**
      * Specific configuration for the TRaX liaison.
-     * @param xsltTask the XSLTProcess task instance from which this liasion
+     * @param xsltTask the XSLTProcess task instance from which this liaison
      *        is to be configured.
      */
     public void configure(final XSLTProcess xsltTask) {
         project = xsltTask.getProject();
         final XSLTProcess.Factory factory = xsltTask.getFactory();
         if (factory != null) {
             setFactory(factory.getName());
 
             // configure factory attributes
             for (final Enumeration attrs = factory.getAttributes();
                     attrs.hasMoreElements();) {
                 final XSLTProcess.Factory.Attribute attr =
                         (XSLTProcess.Factory.Attribute) attrs.nextElement();
                 setAttribute(attr.getName(), attr.getValue());
             }
         }
 
         final XMLCatalog xmlCatalog = xsltTask.getXMLCatalog();
         // use XMLCatalog as the entity resolver and URI resolver
         if (xmlCatalog != null) {
             setEntityResolver(xmlCatalog);
             setURIResolver(xmlCatalog);
         }
 
 
         // configure output properties
         for (final Enumeration props = xsltTask.getOutputProperties();
                 props.hasMoreElements();) {
             final XSLTProcess.OutputProperty prop
                 = (XSLTProcess.OutputProperty) props.nextElement();
             setOutputProperty(prop.getName(), prop.getValue());
         }
 
         suppressWarnings = xsltTask.getSuppressWarnings();
 
         traceConfiguration = xsltTask.getTraceConfiguration();
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/XMLValidateTask.java b/src/main/org/apache/tools/ant/taskdefs/optional/XMLValidateTask.java
index 28b6b5a2d..e9fed0dfd 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/XMLValidateTask.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/XMLValidateTask.java
@@ -1,764 +1,764 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.util.Vector;
 
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.DTDLocation;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.types.XMLCatalog;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.JAXPUtils;
 import org.apache.tools.ant.util.XmlConstants;
 import org.xml.sax.EntityResolver;
 import org.xml.sax.ErrorHandler;
 import org.xml.sax.InputSource;
 import org.xml.sax.Parser;
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXNotRecognizedException;
 import org.xml.sax.SAXNotSupportedException;
 import org.xml.sax.SAXParseException;
 import org.xml.sax.XMLReader;
 import org.xml.sax.helpers.ParserAdapter;
 
 /**
  * Checks XML files are valid (or only well formed). The
  * task uses the SAX2 parser implementation provided by JAXP by default
  * (probably the one that is used by Ant itself), but one can specify any
  * SAX1/2 parser if needed.
  *
  */
 public class XMLValidateTask extends Task {
 
     /**
      * helper for path -> URI and URI -> path conversions.
      */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     protected static final String INIT_FAILED_MSG =
         "Could not start xml validation: ";
 
     // ant task properties
     // defaults
     // CheckStyle:VisibilityModifier OFF - bc
     protected boolean failOnError = true;
     protected boolean warn = true;
     protected boolean lenient = false;
     protected String readerClassName = null;
 
     /** file to be validated */
     protected File file = null;
     /** sets of file to be validated */
     protected Vector filesets = new Vector();
     protected Path classpath;
 
     /**
      * the parser is viewed as a SAX2 XMLReader. If a SAX1 parser is specified,
      * it's wrapped in an adapter that make it behave as a XMLReader.
      * a more 'standard' way of doing this would be to use the JAXP1.1 SAXParser
      * interface.
      */
     protected XMLReader xmlReader = null;
     // XMLReader used to validation process
     protected ValidatorErrorHandler errorHandler = new ValidatorErrorHandler();
     // to report sax parsing errors
     // CheckStyle:VisibilityModifier ON
 
     /** The vector to store all attributes (features) to be set on the parser. **/
     private Vector attributeList = new Vector();
 
     /**
      * List of properties.
      */
     private final Vector propertyList = new Vector();
 
     private XMLCatalog xmlCatalog = new XMLCatalog();
-    /** Message for successfull validation */
+    /** Message for successful validation */
     public static final String MESSAGE_FILES_VALIDATED
         = " file(s) have been successfully validated.";
 
     private AntClassLoader readerLoader = null;
 
     /**
      * Specify how parser error are to be handled.
      * Optional, default is <code>true</code>.
      * <p>
      * If set to <code>true</code> (default), throw a buildException if the
      * parser yields an error.
      * @param fail if set to <code>false</code> do not fail on error
      */
     public void setFailOnError(boolean fail) {
         failOnError = fail;
     }
 
     /**
      * Specify how parser error are to be handled.
      * <p>
      * If set to <code>true</code> (default), log a warn message for each SAX warn event.
      * @param bool if set to <code>false</code> do not send warnings
      */
     public void setWarn(boolean bool) {
         warn = bool;
     }
 
     /**
      * Specify whether the parser should be validating. Default
      * is <code>true</code>.
      * <p>
      * If set to false, the validation will fail only if the parsed document
      * is not well formed XML.
      * <p>
      * this option is ignored if the specified class
      * with {@link #setClassName(String)} is not a SAX2 XMLReader.
      * @param bool if set to <code>false</code> only fail on malformed XML
      */
     public void setLenient(boolean bool) {
         lenient = bool;
     }
 
     /**
      * Specify the class name of the SAX parser to be used. (optional)
      * @param className should be an implementation of SAX2
      * <code>org.xml.sax.XMLReader</code> or SAX2 <code>org.xml.sax.Parser</code>.
      * <p> if className is an implementation of
      * <code>org.xml.sax.Parser</code>, {@link #setLenient(boolean)},
      * will be ignored.
      * <p> if not set, the default will be used.
      * @see org.xml.sax.XMLReader
      * @see org.xml.sax.Parser
      */
     public void setClassName(String className) {
         readerClassName = className;
     }
 
     /**
      * Specify the classpath to be searched to load the parser (optional)
      * @param classpath the classpath to load the parser
      */
     public void setClasspath(Path classpath) {
         if (this.classpath == null) {
             this.classpath = classpath;
         } else {
             this.classpath.append(classpath);
         }
     }
 
     /**
      * @see #setClasspath
      * @return the classpath created
      */
     public Path createClasspath() {
         if (this.classpath == null) {
             this.classpath = new Path(getProject());
         }
         return this.classpath.createPath();
     }
 
     /**
      * Where to find the parser class; optional.
      * @see #setClasspath
      * @param r reference to a classpath defined elsewhere
      */
     public void setClasspathRef(Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * specify the file to be checked; optional.
      * @param file the file to be checked
      */
     public void setFile(File file) {
         this.file = file;
     }
 
     /**
      * add an XMLCatalog as a nested element; optional.
      * @param catalog XMLCatalog to use
      */
     public void addConfiguredXMLCatalog(XMLCatalog catalog) {
         xmlCatalog.addConfiguredXMLCatalog(catalog);
     }
 
     /**
      * specify a set of file to be checked
      * @param set the fileset to check
      */
     public void addFileset(FileSet set) {
         filesets.addElement(set);
     }
 
     /**
      * Add an attribute nested element. This is used for setting arbitrary
      * features of the SAX parser.
      * Valid attributes
      * <a href=
      * "http://www.saxproject.org/apidoc/org/xml/sax/package-summary.html#package_description"
      * >include</a>
      * @return attribute created
      * @since ant1.6
      */
     public Attribute createAttribute() {
         final Attribute feature = new Attribute();
         attributeList.addElement(feature);
         return feature;
     }
 
     /**
      * Creates a property.
      *
      * @return a property.
      * @since ant 1.6.2
      */
     public Property createProperty() {
         final Property prop = new Property();
         propertyList.addElement(prop);
         return prop;
     }
 
     /**
      * Called by the project to let the task initialize properly.
      *
      * @exception BuildException if something goes wrong with the build
      */
     public void init() throws BuildException {
         super.init();
         xmlCatalog.setProject(getProject());
     }
 
     /**
      * Create a DTD location record; optional.
      * This stores the location of a DTD. The DTD is identified
      * by its public Id.
      * @return created DTD location
      */
     public DTDLocation createDTD() {
         DTDLocation dtdLocation = new DTDLocation();
         xmlCatalog.addDTD(dtdLocation);
         return dtdLocation;
     }
     /**
      * accessor to the xmlCatalog used in the task
      * @return xmlCatalog reference
      */
     protected EntityResolver getEntityResolver() {
         return xmlCatalog;
     }
 
     /**
      * get the XML reader. Non-null only after {@link #initValidator()}.
      * If the reader is an instance of  {@link ParserAdapter} then
      * the parser is a SAX1 parser, and you cannot call
      * {@link #setFeature(String, boolean)} or {@link #setProperty(String, String)}
      * on it.
      * @return the XML reader or null.
      */
     protected XMLReader getXmlReader() {
         return xmlReader;
     }
 
     /**
      * execute the task
      * @throws BuildException if <code>failonerror</code> is true and an error happens
      */
     public void execute() throws BuildException {
         try {
         int fileProcessed = 0;
         if (file == null && (filesets.size() == 0)) {
             throw new BuildException(
                 "Specify at least one source - " + "a file or a fileset.");
         }
 
 
 
         if (file != null) {
             if (file.exists() && file.canRead() && file.isFile()) {
                 doValidate(file);
                 fileProcessed++;
             } else {
                 String errorMsg = "File " + file + " cannot be read";
                 if (failOnError) {
                     throw new BuildException(errorMsg);
                 } else {
                     log(errorMsg, Project.MSG_ERR);
                 }
             }
         }
 
         final int size = filesets.size();
         for (int i = 0; i < size; i++) {
 
             FileSet fs = (FileSet) filesets.elementAt(i);
             DirectoryScanner ds = fs.getDirectoryScanner(getProject());
             String[] files = ds.getIncludedFiles();
 
             for (int j = 0; j < files.length; j++) {
                 File srcFile = new File(fs.getDir(getProject()), files[j]);
                 doValidate(srcFile);
                 fileProcessed++;
             }
         }
         onSuccessfulValidation(fileProcessed);
         } finally {
             cleanup();
         }
     }
 
     /**
      * handler called on successful file validation.
      * @param fileProcessed number of files processed.
      */
     protected void onSuccessfulValidation(int fileProcessed) {
         log(fileProcessed + MESSAGE_FILES_VALIDATED);
     }
 
     /**
      * init the parser :
      * load the parser class, and set features if necessary
      * It is only after this that the reader is valid
      * @throws BuildException if something went wrong
      */
     protected void initValidator() {
 
         xmlReader = createXmlReader();
 
         xmlReader.setEntityResolver(getEntityResolver());
         xmlReader.setErrorHandler(errorHandler);
 
         if (!isSax1Parser()) {
             // turn validation on
             if (!lenient) {
                 setFeature(XmlConstants.FEATURE_VALIDATION, true);
             }
             // set the feature from the attribute list
             final int attSize = attributeList.size();
             for (int i = 0; i < attSize; i++) {
                 Attribute feature = (Attribute) attributeList.elementAt(i);
                 setFeature(feature.getName(), feature.getValue());
 
             }
             // Sets properties
             final int propSize = propertyList.size();
             for (int i = 0; i < propSize; i++) {
                 final Property prop = (Property) propertyList.elementAt(i);
                 setProperty(prop.getName(), prop.getValue());
             }
         }
     }
 
     /**
      * test that returns true if we are using a SAX1 parser.
      * @return true when a SAX1 parser is in use
      */
     protected boolean isSax1Parser() {
         return (xmlReader instanceof ParserAdapter);
     }
 
     /**
      * create the XML reader.
      * This is one by instantiating anything specified by {@link #readerClassName},
      * falling back to a default reader if not.
      * If the returned reader is an instance of {@link ParserAdapter} then
      * we have created and wrapped a SAX1 parser.
      * @return the new XMLReader.
      */
     protected XMLReader createXmlReader() {
         Object reader = null;
         if (readerClassName == null) {
             reader = createDefaultReaderOrParser();
         } else {
 
             Class readerClass = null;
             try {
                 // load the parser class
                 if (classpath != null) {
                     readerLoader = getProject().createClassLoader(classpath);
                     readerClass = Class.forName(readerClassName, true,
                                                 readerLoader);
                 } else {
                     readerClass = Class.forName(readerClassName);
                 }
 
                 reader = readerClass.newInstance();
             } catch (ClassNotFoundException e) {
                 throw new BuildException(INIT_FAILED_MSG + readerClassName, e);
             } catch (InstantiationException e) {
                 throw new BuildException(INIT_FAILED_MSG + readerClassName, e);
             } catch (IllegalAccessException e) {
                 throw new BuildException(INIT_FAILED_MSG + readerClassName, e);
             }
         }
 
         // then check it implements XMLReader
         XMLReader newReader;
         if (reader instanceof XMLReader) {
             newReader = (XMLReader) reader;
             log(
                 "Using SAX2 reader " + reader.getClass().getName(),
                 Project.MSG_VERBOSE);
         } else {
 
             // see if it is a SAX1 Parser
             if (reader instanceof Parser) {
                 newReader = new ParserAdapter((Parser) reader);
                 log(
                     "Using SAX1 parser " + reader.getClass().getName(),
                     Project.MSG_VERBOSE);
             } else {
                 throw new BuildException(
                     INIT_FAILED_MSG
                         + reader.getClass().getName()
                         + " implements nor SAX1 Parser nor SAX2 XMLReader.");
             }
         }
         return newReader;
     }
 
     /**
      * Cleans up resources.
      *
      * @since Ant 1.8.0
      */
     protected void cleanup() {
         if (readerLoader != null) {
             readerLoader.cleanup();
             readerLoader = null;
         }
     }
 
     /**
      *
      * @return
      */
     private Object createDefaultReaderOrParser() {
         Object reader;
         try {
             reader = createDefaultReader();
         } catch (BuildException exc) {
             reader = JAXPUtils.getParser();
         }
         return reader;
     }
 
     /**
      * create a reader if the use of the class did not specify another one.
      * If a BuildException is thrown, the caller may revert to an alternate
      * reader.
      * @return a new reader.
      * @throws BuildException if something went wrong
      */
     protected XMLReader createDefaultReader() {
         return JAXPUtils.getXMLReader();
     }
 
     /**
      * Set a feature on the parser.
      * @param feature the name of the feature to set
      * @param value the value of the feature
      * @throws BuildException if the feature was not supported
      */
     protected void setFeature(String feature, boolean value)
         throws BuildException {
         log("Setting feature " + feature + "=" + value, Project.MSG_DEBUG);
         try {
             xmlReader.setFeature(feature, value);
         } catch (SAXNotRecognizedException e) {
             throw new BuildException(
                 "Parser "
                     + xmlReader.getClass().getName()
                     + " doesn't recognize feature "
                     + feature,
                 e,
                 getLocation());
         } catch (SAXNotSupportedException e) {
             throw new BuildException(
                 "Parser "
                     + xmlReader.getClass().getName()
                     + " doesn't support feature "
                     + feature,
                 e,
                 getLocation());
         }
     }
 
     /**
      * Sets a property.
      *
      * @param name a property name
      * @param value a property value.
      * @throws BuildException if an error occurs.
      * @throws BuildException if the property was not supported
      */
     protected void setProperty(String name, String value) throws BuildException {
         // Validates property
         if (name == null || value == null) {
             throw new BuildException("Property name and value must be specified.");
         }
 
         try {
             xmlReader.setProperty(name, value);
         } catch (SAXNotRecognizedException e) {
             throw new BuildException(
                 "Parser "
                     + xmlReader.getClass().getName()
                     + " doesn't recognize property "
                     + name,
                 e,
                 getLocation());
         } catch (SAXNotSupportedException e) {
             throw new BuildException(
                 "Parser "
                     + xmlReader.getClass().getName()
                     + " doesn't support property "
                     + name,
                 e,
                 getLocation());
         }
     }
 
     /**
      * parse the file
      * @param afile the file to validate.
      * @return true if the file validates.
      */
     protected boolean doValidate(File afile) {
         //for every file, we have a new instance of the validator
         initValidator();
         boolean result = true;
         try {
             log("Validating " + afile.getName() + "... ", Project.MSG_VERBOSE);
             errorHandler.init(afile);
             InputSource is = new InputSource(new FileInputStream(afile));
             String uri = FILE_UTILS.toURI(afile.getAbsolutePath());
             is.setSystemId(uri);
             xmlReader.parse(is);
         } catch (SAXException ex) {
             log("Caught when validating: " + ex.toString(), Project.MSG_DEBUG);
             if (failOnError) {
                 throw new BuildException(
                     "Could not validate document " + afile);
             }
             log("Could not validate document " + afile + ": " + ex.toString());
             result = false;
         } catch (IOException ex) {
             throw new BuildException(
                 "Could not validate document " + afile,
                 ex);
         }
         if (errorHandler.getFailure()) {
             if (failOnError) {
                 throw new BuildException(
                     afile + " is not a valid XML document.");
             }
             result = false;
             log(afile + " is not a valid XML document", Project.MSG_ERR);
         }
         return result;
     }
 
     /**
      * ValidatorErrorHandler role :
      * <ul>
      * <li> log SAX parse exceptions,
      * <li> remember if an error occurred
      * </ul>
      */
     protected class ValidatorErrorHandler implements ErrorHandler {
 
         // CheckStyle:VisibilityModifier OFF - bc
         protected File currentFile = null;
         protected String lastErrorMessage = null;
         protected boolean failed = false;
         // CheckStyle:VisibilityModifier ON
         /**
          * initialises the class
          * @param file file used
          */
         public void init(File file) {
             currentFile = file;
             failed = false;
         }
         /**
          * did an error happen during last parsing ?
          * @return did an error happen during last parsing ?
          */
         public boolean getFailure() {
             return failed;
         }
 
         /**
          * record a fatal error
          * @param exception the fatal error
          */
         public void fatalError(SAXParseException exception) {
             failed = true;
             doLog(exception, Project.MSG_ERR);
         }
         /**
          * receive notification of a recoverable error
          * @param exception the error
          */
         public void error(SAXParseException exception) {
             failed = true;
             doLog(exception, Project.MSG_ERR);
         }
         /**
          * receive notification of a warning
          * @param exception the warning
          */
         public void warning(SAXParseException exception) {
             // depending on implementation, XMLReader can yield hips of warning,
             // only output then if user explicitly asked for it
             if (warn) {
                 doLog(exception, Project.MSG_WARN);
             }
         }
 
         private void doLog(SAXParseException e, int logLevel) {
 
             log(getMessage(e), logLevel);
         }
 
         private String getMessage(SAXParseException e) {
             String sysID = e.getSystemId();
             if (sysID != null) {
                 String name = sysID;
                 if (sysID.startsWith("file:")) {
                     try {
                         name = FILE_UTILS.fromURI(sysID);
                     } catch (Exception ex) {
                         // if this is not a valid file: just use the uri
                     }
                 }
                 int line = e.getLineNumber();
                 int col = e.getColumnNumber();
                 return  name
                     + (line == -1
                        ? ""
                        : (":" + line + (col == -1 ? "" : (":" + col))))
                     + ": "
                     + e.getMessage();
             }
             return e.getMessage();
         }
     }
 
     /**
      * The class to create to set a feature of the parser.
      * @since ant1.6
      */
     public static class Attribute {
         /** The name of the attribute to set.
          *
          * Valid attributes <a href=
          * "http://www.saxproject.org/apidoc/org/xml/sax/package-summary.html#package_description"
          * >include.</a>
          */
         private String attributeName = null;
 
         /**
          * The value of the feature.
          **/
         private boolean attributeValue;
 
         /**
          * Set the feature name.
          * @param name the name to set
          */
         public void setName(String name) {
             attributeName = name;
         }
         /**
          * Set the feature value to true or false.
          * @param value feature value
          */
         public void setValue(boolean value) {
             attributeValue = value;
         }
 
         /**
          * Gets the attribute name.
          * @return the feature name
          */
         public String getName() {
             return attributeName;
         }
 
         /**
          * Gets the attribute value.
          * @return the feature value
          */
         public boolean getValue() {
             return attributeValue;
         }
     }
 
     /**
      * A Parser property.
      * See <a href="http://xml.apache.org/xerces-j/properties.html">
      * XML parser properties</a> for usable properties
      * @since ant 1.6.2
      */
     public static final class Property {
 
         private String name;
         private String value;
         /**
          * accessor to the name of the property
          * @return name of the property
          */
         public String getName() {
             return name;
         }
         /**
          * setter for the name of the property
          * @param name name of the property
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * getter for the value of the property
          * @return value of the property
          */
         public String getValue() {
             return value;
         }
         /**
          * sets the value of the property
          * @param value value of the property
          */
         public void setValue(String value) {
             this.value = value;
         }
 
     } // Property
 
 
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java b/src/main/org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java
index 62dd64005..550f59ce0 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/ejb/WeblogicDeploymentTool.java
@@ -1,932 +1,932 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.ejb;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Vector;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.JarOutputStream;
 
 import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.SAXParserFactory;
 
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.Java;
 import org.apache.tools.ant.types.Environment;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.util.FileUtils;
 import org.xml.sax.InputSource;
 
 /**
     The weblogic element is used to control the weblogic.ejbc compiler for
     generating weblogic EJB jars. Prior to Ant 1.3, the method of locating CMP
     descriptors was to use the ejbjar naming convention. So if your ejb-jar was
     called, Customer-ejb-jar.xml, your weblogic descriptor was called Customer-
     weblogic-ejb-jar.xml and your CMP descriptor had to be Customer-weblogic-cmp-
     rdbms-jar.xml. In addition, the &lt;type-storage&gt; element in the weblogic
     descriptor had to be set to the standard name META-INF/weblogic-cmp-rdbms-
     jar.xml, as that is where the CMP descriptor was mapped to in the generated
     jar.
 */
 public class WeblogicDeploymentTool extends GenericDeploymentTool {
     /** EJB11 id */
     public static final String PUBLICID_EJB11
          = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN";
     /** EJB20 id */
     public static final String PUBLICID_EJB20
          = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN";
     /** Weblogic 5.1.0 id */
     public static final String PUBLICID_WEBLOGIC_EJB510
          = "-//BEA Systems, Inc.//DTD WebLogic 5.1.0 EJB//EN";
     /** Weblogic 6.0.0 id */
     public static final String PUBLICID_WEBLOGIC_EJB600
          = "-//BEA Systems, Inc.//DTD WebLogic 6.0.0 EJB//EN";
     /** Weblogic 7.0.0 id */
     public static final String PUBLICID_WEBLOGIC_EJB700
          = "-//BEA Systems, Inc.//DTD WebLogic 7.0.0 EJB//EN";
 
     /** Weblogic 5.1 dtd location */
     protected static final String DEFAULT_WL51_EJB11_DTD_LOCATION
          = "/weblogic/ejb/deployment/xml/ejb-jar.dtd";
     /** Weblogic 6.0 ejb 1.1 dtd location */
     protected static final String DEFAULT_WL60_EJB11_DTD_LOCATION
          = "/weblogic/ejb20/dd/xml/ejb11-jar.dtd";
     /** Weblogic 6.0 ejb 2.0 dtd location */
     protected static final String DEFAULT_WL60_EJB20_DTD_LOCATION
          = "/weblogic/ejb20/dd/xml/ejb20-jar.dtd";
 
     protected static final String DEFAULT_WL51_DTD_LOCATION
          = "/weblogic/ejb/deployment/xml/weblogic-ejb-jar.dtd";
     protected static final String DEFAULT_WL60_51_DTD_LOCATION
          = "/weblogic/ejb20/dd/xml/weblogic510-ejb-jar.dtd";
     protected static final String DEFAULT_WL60_DTD_LOCATION
          = "/weblogic/ejb20/dd/xml/weblogic600-ejb-jar.dtd";
     protected static final String DEFAULT_WL70_DTD_LOCATION
          = "/weblogic/ejb20/dd/xml/weblogic700-ejb-jar.dtd";
 
     protected static final String DEFAULT_COMPILER = "default";
 
     protected static final String WL_DD = "weblogic-ejb-jar.xml";
     protected static final String WL_CMP_DD = "weblogic-cmp-rdbms-jar.xml";
 
     protected static final String COMPILER_EJB11 = "weblogic.ejbc";
     protected static final String COMPILER_EJB20 = "weblogic.ejbc20";
 
     /** File utilities instance for copying jars */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /** Instance variable that stores the suffix for the weblogic jarfile. */
     private String jarSuffix = ".jar";
 
     /** Instance variable that stores the location of the weblogic DTD file. */
     private String weblogicDTD;
 
     /** Instance variable that stores the location of the ejb 1.1 DTD file. */
     private String ejb11DTD;
 
     /** Instance variable that determines whether generic ejb jars are kept. */
     private boolean keepgenerated = false;
 
     /**
      * Instance variable that stores the fully qualified classname of the
      * weblogic EJBC compiler
      */
     private String ejbcClass = null;
 
     private String additionalArgs = "";
 
     /**
      * additional args to pass to the spawned jvm
      */
     private String additionalJvmArgs = "";
 
     private boolean keepGeneric = false;
 
     private String compiler = null;
 
     private boolean alwaysRebuild = true;
 
     /** controls whether ejbc is run on the generated jar */
     private boolean noEJBC = false;
 
     /** Indicates if the old CMP location convention is to be used.  */
     private boolean newCMP = false;
 
     /** The classpath to the weblogic classes. */
     private Path wlClasspath = null;
 
     /** System properties for the JVM. */
     private Vector sysprops = new Vector();
 
     /**
      * The weblogic.StdoutSeverityLevel to use when running the JVM that
      * executes ejbc. Set to 16 to avoid the warnings about EJB Home and
      * Remotes being in the classpath
      */
     private Integer jvmDebugLevel = null;
 
     private File outputDir;
 
     /**
      * Add a nested sysproperty element.
      * @param sysp the element to add.
      */
     public void addSysproperty(Environment.Variable sysp) {
         sysprops.add(sysp);
     }
 
 
     /**
      * Get the classpath to the weblogic classpaths.
      * @return the classpath to configure.
      */
     public Path createWLClasspath() {
         if (wlClasspath == null) {
             wlClasspath = new Path(getTask().getProject());
         }
         return wlClasspath.createPath();
     }
 
     /**
      * If set ejbc will use this directory as the output
      * destination rather than a jar file. This allows for the
      * generation of &quot;exploded&quot; jars.
      * @param outputDir the directory to be used.
      */
     public void setOutputDir(File outputDir) {
         this.outputDir = outputDir;
     }
 
 
     /**
      * Optional classpath to WL6.0.
      * Weblogic 6.0 will give a warning if the home and remote interfaces
      * of a bean are on the system classpath used to run weblogic.ejbc.
      * In that case, the standard weblogic classes should be set with
      * this attribute (or equivalent nested element) and the
      * home and remote interfaces located with the standard classpath
      * attribute.
      * @param wlClasspath the path to be used.
      */
     public void setWLClasspath(Path wlClasspath) {
         this.wlClasspath = wlClasspath;
     }
 
 
     /**
      * The compiler (switch <code>-compiler</code>) to use; optional.
      * This allows for the selection of a different compiler
      * to be used for the compilation of the generated Java
      * files. This could be set, for example, to Jikes to
      * compile with the Jikes compiler. If this is not set
      * and the <code>build.compiler</code> property is set
      * to jikes, the Jikes compiler will be used. If this
      * is not desired, the value &quot;<code>default</code>&quot;
      * may be given to use the default compiler.
      * @param compiler the compiler to be used.
      */
     public void setCompiler(String compiler) {
         this.compiler = compiler;
     }
 
 
     /**
      * Set the rebuild flag to false to only update changes in the jar rather
      * than rerunning ejbc; optional, default true.
      * This flag controls whether weblogic.ejbc is always
      * invoked to build the jar file. In certain circumstances,
      * such as when only a bean class has been changed, the jar
      * can be generated by merely replacing the changed classes
      * and not rerunning ejbc. Setting this to false will reduce
      * the time to run ejbjar.
      * @param rebuild a <code>boolean</code> value.
      */
     public void setRebuild(boolean rebuild) {
         this.alwaysRebuild = rebuild;
     }
 
 
     /**
      * Sets the weblogic.StdoutSeverityLevel to use when running the JVM that
      * executes ejbc; optional. Set to 16 to avoid the warnings about EJB Home and
      * Remotes being in the classpath
      * @param jvmDebugLevel the value to use.
      */
     public void setJvmDebugLevel(Integer jvmDebugLevel) {
         this.jvmDebugLevel = jvmDebugLevel;
     }
 
 
     /**
      * Get the debug level.
      * @return the jvm debug level (may be null).
      */
     public Integer getJvmDebugLevel() {
         return jvmDebugLevel;
     }
 
 
 
     /**
      * Setter used to store the suffix for the generated weblogic jar file.
      *
      * @param inString the string to use as the suffix.
      */
     public void setSuffix(String inString) {
         this.jarSuffix = inString;
     }
 
 
     /**
      * controls whether the generic file used as input to
      * ejbc is retained; defaults to false
      *
      * @param inValue true for keep generic
      */
     public void setKeepgeneric(boolean inValue) {
         this.keepGeneric = inValue;
     }
 
 
     /**
      * Controls whether weblogic will keep the generated Java
      * files used to build the class files added to the
      * jar. This can be useful when debugging; default is false.
      *
      * @param inValue either 'true' or 'false'
      */
     public void setKeepgenerated(String inValue) {
         this.keepgenerated = Boolean.valueOf(inValue).booleanValue();
     }
 
 
     /**
      * Any optional extra arguments pass to the weblogic.ejbc
      * tool.
      * @param args extra arguments to pass to the ejbc tool.
      */
     public void setArgs(String args) {
         this.additionalArgs = args;
     }
 
 
     /**
      * Set any additional arguments to pass to the weblogic JVM; optional.
      * @param args the arguments to be passed to the JVM
      */
     public void setJvmargs(String args) {
         this.additionalJvmArgs = args;
     }
 
     /**
      * Set the classname of the ejbc compiler;  optional
      * Normally ejbjar determines
      * the appropriate class based on the DTD used for the EJB. The EJB 2.0 compiler
      * featured in weblogic 6 has, however, been deprecated in version 7. When
      * using with version 7 this attribute should be set to
      * &quot;weblogic.ejbc&quot; to avoid the deprecation warning.
      * @param ejbcClass the name of the class to use.
      */
     public void setEjbcClass(String ejbcClass) {
         this.ejbcClass = ejbcClass;
     }
 
 
     /**
      * Get the ejbc compiler class.
      * @return the name of the ejbc compiler class.
      */
     public String getEjbcClass() {
         return ejbcClass;
     }
 
 
     /**
      * <b>Deprecated</b>. Defines the location of the ejb-jar DTD in
      *  the weblogic class hierarchy. Should not be needed, and the
      * nested &lt;dtd&gt; element is recommended when it is.
      *
      * @param inString the string to use as the DTD location.
      */
     public void setWeblogicdtd(String inString) {
         setEJBdtd(inString);
     }
 
 
     /**
      * <b>Deprecated</b>. Defines the location of weblogic DTD in
      *  the weblogic class hierarchy. Should not be needed, and the
      * nested &lt;dtd&gt; element is recommended when it is.
      *
      * @param inString the string to use as the DTD location.
      */
     public void setWLdtd(String inString) {
         this.weblogicDTD = inString;
     }
 
 
     /**
      * <b>Deprecated</b>. Defines the location of Sun's EJB DTD in
      *  the weblogic class hierarchy. Should not be needed, and the
      * nested &lt;dtd&gt; element is recommended when it is.
      *
      * @param inString the string to use as the DTD location.
      */
     public void setEJBdtd(String inString) {
         this.ejb11DTD = inString;
     }
 
 
     /**
      * Set the value of the oldCMP scheme. This is an antonym for newCMP
      * @ant.attribute ignore="true'
      * @param oldCMP a <code>boolean</code> value.
      */
     public void setOldCMP(boolean oldCMP) {
         this.newCMP = !oldCMP;
     }
 
 
     /**
      * If this is set to true, the new method for locating
      * CMP descriptors will be used; optional, default false.
      * <P>
      * The old CMP scheme locates the
      * weblogic CMP descriptor based on the naming convention where the
      * weblogic CMP file is expected to be named with the bean name as the
      * prefix. Under this scheme the name of the CMP descriptor does not match
      * the name actually used in the main weblogic EJB descriptor. Also,
      * descriptors which contain multiple CMP references could not be used.
      * @param newCMP a <code>boolean</code> value.
      */
     public void setNewCMP(boolean newCMP) {
         this.newCMP = newCMP;
     }
 
 
     /**
      * Do not EJBC the jar after it has been put together;
      * optional, default false
      * @param noEJBC a <code>boolean</code> value.
      */
     public void setNoEJBC(boolean noEJBC) {
         this.noEJBC = noEJBC;
     }
 
 
     /**
      * Register the DTDs.
      * @param handler the handler to use.
      */
     protected void registerKnownDTDs(DescriptorHandler handler) {
         // register all the known DTDs
         handler.registerDTD(PUBLICID_EJB11, DEFAULT_WL51_EJB11_DTD_LOCATION);
         handler.registerDTD(PUBLICID_EJB11, DEFAULT_WL60_EJB11_DTD_LOCATION);
         handler.registerDTD(PUBLICID_EJB11, ejb11DTD);
         handler.registerDTD(PUBLICID_EJB20, DEFAULT_WL60_EJB20_DTD_LOCATION);
     }
 
 
     /**
      * Get the weblogic descriptor handler.
      * @param srcDir the source directory.
      * @return the descriptor.
      */
     protected DescriptorHandler getWeblogicDescriptorHandler(final File srcDir) {
         DescriptorHandler handler =
             new DescriptorHandler(getTask(), srcDir) {
                 protected void processElement() {
                     if (currentElement.equals("type-storage")) {
                         // Get the filename of vendor specific descriptor
                         String fileNameWithMETA = currentText;
                         //trim the META_INF\ off of the file name
                         String fileName
                              = fileNameWithMETA.substring(META_DIR.length(),
                             fileNameWithMETA.length());
                         File descriptorFile = new File(srcDir, fileName);
 
                         ejbFiles.put(fileNameWithMETA, descriptorFile);
                     }
                 }
             };
 
         handler.registerDTD(PUBLICID_WEBLOGIC_EJB510, DEFAULT_WL51_DTD_LOCATION);
         handler.registerDTD(PUBLICID_WEBLOGIC_EJB510, DEFAULT_WL60_51_DTD_LOCATION);
         handler.registerDTD(PUBLICID_WEBLOGIC_EJB600, DEFAULT_WL60_DTD_LOCATION);
         handler.registerDTD(PUBLICID_WEBLOGIC_EJB700, DEFAULT_WL70_DTD_LOCATION);
         handler.registerDTD(PUBLICID_WEBLOGIC_EJB510, weblogicDTD);
         handler.registerDTD(PUBLICID_WEBLOGIC_EJB600, weblogicDTD);
 
         for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {
             EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();
 
             handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
         }
         return handler;
     }
 
 
     /**
      * Add any vendor specific files which should be included in the EJB Jar.
      * @param ejbFiles the hash table to be populated.
      * @param ddPrefix the prefix to use.
      */
     protected void addVendorFiles(Hashtable ejbFiles, String ddPrefix) {
         File weblogicDD = new File(getConfig().descriptorDir, ddPrefix + WL_DD);
 
         if (weblogicDD.exists()) {
             ejbFiles.put(META_DIR + WL_DD,
                 weblogicDD);
         } else {
             log("Unable to locate weblogic deployment descriptor. "
                 + "It was expected to be in "
                 + weblogicDD.getPath(), Project.MSG_WARN);
             return;
         }
 
         if (!newCMP) {
             log("The old method for locating CMP files has been DEPRECATED.", Project.MSG_VERBOSE);
             log("Please adjust your weblogic descriptor and set "
                 + "newCMP=\"true\" to use the new CMP descriptor "
                 + "inclusion mechanism. ", Project.MSG_VERBOSE);
             // The the weblogic cmp deployment descriptor
             File weblogicCMPDD = new File(getConfig().descriptorDir, ddPrefix + WL_CMP_DD);
 
             if (weblogicCMPDD.exists()) {
                 ejbFiles.put(META_DIR + WL_CMP_DD,
                     weblogicCMPDD);
             }
         } else {
             // now that we have the weblogic descriptor, we parse the file
             // to find other descriptors needed to deploy the bean.
             // this could be the weblogic-cmp-rdbms.xml or any other O/R
             // mapping tool descriptors.
             try {
                 File ejbDescriptor = (File) ejbFiles.get(META_DIR + EJB_DD);
                 SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
 
                 saxParserFactory.setValidating(true);
 
                 SAXParser saxParser = saxParserFactory.newSAXParser();
                 DescriptorHandler handler
                     = getWeblogicDescriptorHandler(ejbDescriptor.getParentFile());
 
                 saxParser.parse(new InputSource
                     (new FileInputStream(weblogicDD)),
                         handler);
 
                 Hashtable ht = handler.getFiles();
                 Enumeration e = ht.keys();
 
                 while (e.hasMoreElements()) {
                     String key = (String) e.nextElement();
 
                     ejbFiles.put(key, ht.get(key));
                 }
             } catch (Exception e) {
                 String msg = "Exception while adding Vendor specific files: " + e.toString();
 
                 throw new BuildException(msg, e);
             }
         }
     }
 
 
     /**
      * Get the vendor specific name of the Jar that will be output. The
      * modification date of this jar will be checked against the dependent
      * bean classes.
      */
     File getVendorOutputJarFile(String baseName) {
         return new File(getDestDir(), baseName + jarSuffix);
     }
 
 
     /**
      * Helper method invoked by execute() for each WebLogic jar to be built.
      * Encapsulates the logic of constructing a java task for calling
      * weblogic.ejbc and executing it.
      *
      * @param sourceJar java.io.File representing the source (EJB1.1) jarfile.
      * @param destJar java.io.File representing the destination, WebLogic
      *      jarfile.
      */
     private void buildWeblogicJar(File sourceJar, File destJar, String publicId) {
         Java javaTask = null;
 
         if (noEJBC) {
             try {
                 FILE_UTILS.copyFile(sourceJar, destJar);
                 if (!keepgenerated) {
                     sourceJar.delete();
                 }
                 return;
             } catch (IOException e) {
                 throw new BuildException("Unable to write EJB jar", e);
             }
         }
 
         String ejbcClassName = ejbcClass;
 
         try {
             javaTask = new Java(getTask());
             javaTask.setTaskName("ejbc");
 
             javaTask.createJvmarg().setLine(additionalJvmArgs);
             if (!(sysprops.isEmpty())) {
                 for (Enumeration en = sysprops.elements(); en.hasMoreElements();) {
                     Environment.Variable entry
                         = (Environment.Variable) en.nextElement();
                     javaTask.addSysproperty(entry);
                 }
             }
 
             if (getJvmDebugLevel() != null) {
                 javaTask.createJvmarg().setLine(" -Dweblogic.StdoutSeverityLevel=" + jvmDebugLevel);
             }
 
             if (ejbcClassName == null) {
                 // try to determine it from publicId
                 if (PUBLICID_EJB11.equals(publicId)) {
                     ejbcClassName = COMPILER_EJB11;
                 } else if (PUBLICID_EJB20.equals(publicId)) {
                     ejbcClassName = COMPILER_EJB20;
                 } else {
                     log("Unrecognized publicId " + publicId
                         + " - using EJB 1.1 compiler", Project.MSG_WARN);
                     ejbcClassName = COMPILER_EJB11;
                 }
             }
 
             javaTask.setClassname(ejbcClassName);
             javaTask.createArg().setLine(additionalArgs);
             if (keepgenerated) {
                 javaTask.createArg().setValue("-keepgenerated");
             }
             if (compiler == null) {
                 // try to use the compiler specified by build.compiler.
                 // Right now we are just going to allow Jikes
                 String buildCompiler
                     = getTask().getProject().getProperty("build.compiler");
 
                 if (buildCompiler != null && buildCompiler.equals("jikes")) {
                     javaTask.createArg().setValue("-compiler");
                     javaTask.createArg().setValue("jikes");
                 }
             } else {
                 if (!compiler.equals(DEFAULT_COMPILER)) {
                     javaTask.createArg().setValue("-compiler");
                     javaTask.createArg().setLine(compiler);
                 }
             }
 
             Path combinedClasspath = getCombinedClasspath();
             if (wlClasspath != null && combinedClasspath != null
                  && combinedClasspath.toString().trim().length() > 0) {
                 javaTask.createArg().setValue("-classpath");
                 javaTask.createArg().setPath(combinedClasspath);
             }
 
             javaTask.createArg().setValue(sourceJar.getPath());
             if (outputDir == null) {
                 javaTask.createArg().setValue(destJar.getPath());
             } else {
                 javaTask.createArg().setValue(outputDir.getPath());
             }
 
             Path classpath = wlClasspath;
 
             if (classpath == null) {
                 classpath = getCombinedClasspath();
             }
 
             javaTask.setFork(true);
             if (classpath != null) {
                 javaTask.setClasspath(classpath);
             }
 
             log("Calling " + ejbcClassName + " for " + sourceJar.toString(),
                 Project.MSG_VERBOSE);
 
             if (javaTask.executeJava() != 0) {
                 throw new BuildException("Ejbc reported an error");
             }
         } catch (Exception e) {
             // Have to catch this because of the semantics of calling main()
             String msg = "Exception while calling " + ejbcClassName
                 + ". Details: " + e.toString();
 
             throw new BuildException(msg, e);
         }
     }
 
 
     /**
      * Method used to encapsulate the writing of the JAR file. Iterates over
      * the filenames/java.io.Files in the Hashtable stored on the instance
      * variable ejbFiles.
      * @param baseName the base name.
      * @param jarFile the jar file to populate.
      * @param files   the hash table of files to write.
      * @param publicId the id to use.
      * @throws BuildException if there is a problem.
      */
     protected void writeJar(String baseName, File jarFile, Hashtable files,
                             String publicId) throws BuildException {
         // need to create a generic jar first.
         File genericJarFile = super.getVendorOutputJarFile(baseName);
 
         super.writeJar(baseName, genericJarFile, files, publicId);
 
         if (alwaysRebuild || isRebuildRequired(genericJarFile, jarFile)) {
             buildWeblogicJar(genericJarFile, jarFile, publicId);
         }
         if (!keepGeneric) {
             log("deleting generic jar " + genericJarFile.toString(),
                 Project.MSG_VERBOSE);
             genericJarFile.delete();
         }
     }
 
 
     /**
      * Called to validate that the tool parameters have been configured.
      * @throws BuildException if there is an error.
      */
     public void validateConfigured() throws BuildException {
         super.validateConfigured();
     }
 
 
     /**
      * Helper method to check to see if a weblogic EBJ1.1 jar needs to be
      * rebuilt using ejbc. Called from writeJar it sees if the "Bean" classes
      * are the only thing that needs to be updated and either updates the Jar
      * with the Bean classfile or returns true, saying that the whole weblogic
      * jar needs to be regened with ejbc. This allows faster build times for
      * working developers. <p>
      *
      * The way weblogic ejbc works is it creates wrappers for the publicly
      * defined methods as they are exposed in the remote interface. If the
      * actual bean changes without changing the the method signatures then
      * only the bean classfile needs to be updated and the rest of the
      * weblogic jar file can remain the same. If the Interfaces, ie. the
      * method signatures change or if the xml deployment descriptors changed,
      * the whole jar needs to be rebuilt with ejbc. This is not strictly true
-     * for the xml files. If the JNDI name changes then the jar doesnt have to
+     * for the xml files. If the JNDI name changes then the jar doesn't have to
      * be rebuild, but if the resources references change then it does. At
      * this point the weblogic jar gets rebuilt if the xml files change at
      * all.
      *
      * @param genericJarFile java.io.File The generic jar file.
      * @param weblogicJarFile java.io.File The weblogic jar file to check to
      *      see if it needs to be rebuilt.
      * @return true if the jar needs to be rebuilt.
      */
     // CheckStyle:MethodLength OFF - this will no be fixed
     protected boolean isRebuildRequired(File genericJarFile, File weblogicJarFile) {
         boolean rebuild = false;
 
         JarFile genericJar = null;
         JarFile wlJar = null;
         File newWLJarFile = null;
         JarOutputStream newJarStream = null;
         ClassLoader genericLoader = null;
 
         try {
             log("Checking if weblogic Jar needs to be rebuilt for jar " + weblogicJarFile.getName(),
                 Project.MSG_VERBOSE);
             // Only go forward if the generic and the weblogic file both exist
             if (genericJarFile.exists() && genericJarFile.isFile()
                  && weblogicJarFile.exists() && weblogicJarFile.isFile()) {
                 //open jar files
                 genericJar = new JarFile(genericJarFile);
                 wlJar = new JarFile(weblogicJarFile);
 
                 Hashtable genericEntries = new Hashtable();
                 Hashtable wlEntries = new Hashtable();
                 Hashtable replaceEntries = new Hashtable();
 
                 //get the list of generic jar entries
                 for (Enumeration e = genericJar.entries(); e.hasMoreElements();) {
                     JarEntry je = (JarEntry) e.nextElement();
 
                     genericEntries.put(je.getName().replace('\\', '/'), je);
                 }
                 //get the list of weblogic jar entries
                 for (Enumeration e = wlJar.entries(); e.hasMoreElements();) {
                     JarEntry je = (JarEntry) e.nextElement();
 
                     wlEntries.put(je.getName(), je);
                 }
 
                 //Cycle Through generic and make sure its in weblogic
                 genericLoader = getClassLoaderFromJar(genericJarFile);
 
                 for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) {
                     String filepath = (String) e.nextElement();
 
                     if (wlEntries.containsKey(filepath)) {
                         // File name/path match
 
                         // Check files see if same
                         JarEntry genericEntry = (JarEntry) genericEntries.get(filepath);
                         JarEntry wlEntry = (JarEntry) wlEntries.get(filepath);
 
                         if ((genericEntry.getCrc() != wlEntry.getCrc())
                             || (genericEntry.getSize() != wlEntry.getSize())) {
 
                             if (genericEntry.getName().endsWith(".class")) {
                                 //File are different see if its an object or an interface
                                 String classname
                                     = genericEntry.getName()
                                     .replace(File.separatorChar, '.')
                                     .replace('/', '.');
 
                                 classname = classname.substring(0, classname.lastIndexOf(".class"));
 
                                 Class genclass = genericLoader.loadClass(classname);
 
                                 if (genclass.isInterface()) {
                                     //Interface changed   rebuild jar.
                                     log("Interface " + genclass.getName()
                                         + " has changed", Project.MSG_VERBOSE);
                                     rebuild = true;
                                     break;
                                 } else {
                                     //Object class Changed   update it.
                                     replaceEntries.put(filepath, genericEntry);
                                 }
                             } else {
                                 // is it the manifest. If so ignore it
                                 if (!genericEntry.getName().equals("META-INF/MANIFEST.MF")) {
                                     //File other then class changed   rebuild
                                     log("Non class file " + genericEntry.getName()
                                         + " has changed", Project.MSG_VERBOSE);
                                     rebuild = true;
                                     break;
                                 }
                             }
                         }
                     } else {
-                        // a file doesnt exist rebuild
+                        // a file doesn't exist rebuild
 
                         log("File " + filepath + " not present in weblogic jar",
                             Project.MSG_VERBOSE);
                         rebuild = true;
                         break;
                     }
                 }
 
                 if (!rebuild) {
                     log("No rebuild needed - updating jar", Project.MSG_VERBOSE);
                     newWLJarFile = new File(weblogicJarFile.getAbsolutePath() + ".temp");
                     if (newWLJarFile.exists()) {
                         newWLJarFile.delete();
                     }
 
                     newJarStream = new JarOutputStream(new FileOutputStream(newWLJarFile));
                     newJarStream.setLevel(0);
 
                     //Copy files from old weblogic jar
                     for (Enumeration e = wlEntries.elements(); e.hasMoreElements();) {
                         byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
                         int bytesRead;
                         InputStream is;
                         JarEntry je = (JarEntry) e.nextElement();
 
                         if (je.getCompressedSize() == -1
                             || je.getCompressedSize() == je.getSize()) {
                             newJarStream.setLevel(0);
                         } else {
                             newJarStream.setLevel(JAR_COMPRESS_LEVEL);
                         }
 
                         // Update with changed Bean class
                         if (replaceEntries.containsKey(je.getName())) {
                             log("Updating Bean class from generic Jar "
                                 + je.getName(), Project.MSG_VERBOSE);
                             // Use the entry from the generic jar
                             je = (JarEntry) replaceEntries.get(je.getName());
                             is = genericJar.getInputStream(je);
                         } else {
                             //use fle from original weblogic jar
 
                             is = wlJar.getInputStream(je);
                         }
                         newJarStream.putNextEntry(new JarEntry(je.getName()));
 
                         while ((bytesRead = is.read(buffer)) != -1) {
                             newJarStream.write(buffer, 0, bytesRead);
                         }
                         is.close();
                     }
                 } else {
                     log("Weblogic Jar rebuild needed due to changed "
                          + "interface or XML", Project.MSG_VERBOSE);
                 }
             } else {
                 rebuild = true;
             }
         } catch (ClassNotFoundException cnfe) {
             String cnfmsg = "ClassNotFoundException while processing ejb-jar file"
                  + ". Details: "
                  + cnfe.getMessage();
 
             throw new BuildException(cnfmsg, cnfe);
         } catch (IOException ioe) {
             String msg = "IOException while processing ejb-jar file "
                  + ". Details: "
                  + ioe.getMessage();
 
             throw new BuildException(msg, ioe);
         } finally {
             // need to close files and perhaps rename output
             if (genericJar != null) {
                 try {
                     genericJar.close();
                 } catch (IOException closeException) {
                     // empty
                 }
             }
 
             if (wlJar != null) {
                 try {
                     wlJar.close();
                 } catch (IOException closeException) {
                     // empty
                 }
             }
 
             if (newJarStream != null) {
                 try {
                     newJarStream.close();
                 } catch (IOException closeException) {
                     // empty
                 }
 
                 try {
                     FILE_UTILS.rename(newWLJarFile, weblogicJarFile);
                 } catch (IOException renameException) {
                     log(renameException.getMessage(), Project.MSG_WARN);
                     rebuild = true;
                 }
             }
             if (genericLoader != null
                 && genericLoader instanceof AntClassLoader) {
                 AntClassLoader loader = (AntClassLoader) genericLoader;
                 loader.cleanup();
             }
         }
 
         return rebuild;
     }
 
 
     /**
      * Helper method invoked by isRebuildRequired to get a ClassLoader for a
      * Jar File passed to it.
      *
      * @param classjar java.io.File representing jar file to get classes from.
      * @return the classloader for the jarfile.
      * @throws IOException if there is a problem.
      */
     protected ClassLoader getClassLoaderFromJar(File classjar) throws IOException {
         Path lookupPath = new Path(getTask().getProject());
 
         lookupPath.setLocation(classjar);
 
         Path classpath = getCombinedClasspath();
 
         if (classpath != null) {
             lookupPath.append(classpath);
         }
 
         return getTask().getProject().createClassLoader(lookupPath);
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/ejb/WebsphereDeploymentTool.java b/src/main/org/apache/tools/ant/taskdefs/optional/ejb/WebsphereDeploymentTool.java
index 232a1fb23..d15f9f523 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/ejb/WebsphereDeploymentTool.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/ejb/WebsphereDeploymentTool.java
@@ -1,897 +1,897 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.ejb;
 
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.JarOutputStream;
 
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.Java;
 import org.apache.tools.ant.types.Environment;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * Websphere deployment tool that augments the ejbjar task.
  * Searches for the websphere specific deployment descriptors and
  * adds them to the final ejb jar file. Websphere has two specific descriptors for session
  * beans:
  * <ul>
  *    <li>ibm-ejb-jar-bnd.xmi</li>
  *    <li>ibm-ejb-jar-ext.xmi</li>
  * </ul>
  * and another two for container managed entity beans:
  * <ul>
  *    <li>Map.mapxmi</li>
  *    <li>Schema.dbxmi</li>
  * </ul>
  * In terms of WebSphere, the generation of container code and stubs is
  * called <code>deployment</code>. This step can be performed by the websphere
  * element as part of the jar generation process. If the switch
  * <code>ejbdeploy</code> is on, the ejbdeploy tool from the websphere toolset
  * is called for every ejb-jar. Unfortunately, this step only works, if you
  * use the ibm jdk. Otherwise, the rmic (called by ejbdeploy) throws a
  * ClassFormatError. Be sure to switch ejbdeploy off, if run ant with
  * sun jdk.
  *
  */
 public class WebsphereDeploymentTool extends GenericDeploymentTool {
 
     /** ID for ejb 1.1 */
     public static final String PUBLICID_EJB11
          = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN";
     /** ID for ejb 2.0 */
     public static final String PUBLICID_EJB20
          = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN";
     /** Schema directory */
     protected static final String SCHEMA_DIR = "Schema/";
 
     protected static final String WAS_EXT = "ibm-ejb-jar-ext.xmi";
     protected static final String WAS_BND = "ibm-ejb-jar-bnd.xmi";
     protected static final String WAS_CMP_MAP = "Map.mapxmi";
     protected static final String WAS_CMP_SCHEMA = "Schema.dbxmi";
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /** Instance variable that stores the suffix for the websphere jarfile. */
     private String jarSuffix = ".jar";
 
     /** Instance variable that stores the location of the ejb 1.1 DTD file. */
     private String ejb11DTD;
 
     /** Instance variable that determines whether generic ejb jars are kept. */
 
     private boolean keepGeneric = false;
 
     private boolean alwaysRebuild = true;
 
     private boolean ejbdeploy = true;
 
     /** Indicates if the old CMP location convention is to be used. */
     private boolean newCMP = false;
 
     /** The classpath to the websphere classes. */
     private Path wasClasspath = null;
 
     /** The DB Vendor name, the EJB is persisted against */
     private String dbVendor;
 
     /** The name of the database to create. (For top-down mapping only) */
     private String dbName;
 
     /** The name of the schema to create. (For top-down mappings only) */
     private String dbSchema;
 
     /** true - Only generate the deployment code, do not run RMIC or Javac */
     private boolean codegen;
 
     /** true - Only output error messages, suppress informational messages */
     private boolean quiet = true;
 
     /** true - Disable the validation steps */
     private boolean novalidate;
 
     /** true - Disable warning and informational messages */
     private boolean nowarn;
 
     /** true - Disable informational messages */
     private boolean noinform;
 
     /** true - Enable internal tracing */
     private boolean trace;
 
     /** Additional options for RMIC */
     private String rmicOptions;
 
     /** true- Use the WebSphere 3.5 compatible mapping rules */
     private boolean use35MappingRules;
 
     /** the scratchdir for the ejbdeploy operation */
     private String tempdir = "_ejbdeploy_temp";
 
     /** the home directory for websphere */
     private File websphereHome;
 
     /**
      * Get the classpath to the websphere classpaths.
      * @return the websphere classpath.
      */
     public Path createWASClasspath() {
         if (wasClasspath == null) {
             wasClasspath = new Path(getTask().getProject());
         }
         return wasClasspath.createPath();
     }
 
 
     /**
      * Set the websphere classpath.
      * @param wasClasspath the websphere classpath.
      */
     public void setWASClasspath(Path wasClasspath) {
         this.wasClasspath = wasClasspath;
     }
 
 
     /** Sets the DB Vendor for the Entity Bean mapping ; optional.
      * <p>
      * Valid options can be obtained by running the following command:
      * <code>
      * &lt;WAS_HOME&gt;/bin/EJBDeploy.[sh/bat] -help
      * </code>
      * </p>
      * <p>
      * This is also used to determine the name of the Map.mapxmi and
      * Schema.dbxmi files, for example Account-DB2UDB_V81-Map.mapxmi
      * and Account-DB2UDB_V81-Schema.dbxmi.
      * </p>
      *
      * @param dbvendor database vendor type
      */
     public void setDbvendor(String dbvendor) {
         this.dbVendor = dbvendor;
     }
 
 
     /**
      * Sets the name of the Database to create; optional.
      *
      * @param dbName name of the database
      */
     public void setDbname(String dbName) {
         this.dbName = dbName;
     }
 
 
     /**
      * Sets the name of the schema to create; optional.
      *
      * @param dbSchema name of the schema
      */
     public void setDbschema(String dbSchema) {
         this.dbSchema = dbSchema;
     }
 
 
     /**
      * Flag, default false, to only generate the deployment
      * code, do not run RMIC or Javac
      *
      * @param codegen option
      */
     public void setCodegen(boolean codegen) {
         this.codegen = codegen;
     }
 
 
     /**
      * Flag, default true, to only output error messages.
      *
      * @param quiet option
      */
     public void setQuiet(boolean quiet) {
         this.quiet = quiet;
     }
 
 
     /**
      * Flag to disable the validation steps; optional, default false.
      *
      * @param novalidate option
      */
     public void setNovalidate(boolean novalidate) {
         this.novalidate = novalidate;
     }
 
 
     /**
      * Flag to disable warning and informational messages; optional, default false.
      *
      * @param nowarn option
      */
     public void setNowarn(boolean nowarn) {
         this.nowarn = nowarn;
     }
 
 
     /**
      * Flag to disable informational messages; optional, default false.
      *
      * @param noinform if true disables informational messages
      */
     public void setNoinform(boolean noinform) {
         this.noinform = noinform;
     }
 
 
     /**
      * Flag to enable internal tracing when set, optional, default false.
      *
      * @param trace a <code>boolean</code> value.
      */
     public void setTrace(boolean trace) {
         this.trace = trace;
     }
 
     /**
      * Set the rmic options.
      *
      * @param options the options to use.
      */
     public void setRmicoptions(String options) {
         this.rmicOptions = options;
     }
 
     /**
      * Flag to use the WebSphere 3.5 compatible mapping rules ; optional, default false.
      *
      * @param attr a <code>boolean</code> value.
      */
     public void setUse35(boolean attr) {
         use35MappingRules = attr;
     }
 
 
     /**
      * Set the rebuild flag to false to only update changes in the jar rather
      * than rerunning ejbdeploy; optional, default true.
      * @param rebuild a <code>boolean</code> value.
      */
     public void setRebuild(boolean rebuild) {
         this.alwaysRebuild = rebuild;
     }
 
 
     /**
      * String value appended to the basename of the deployment
      * descriptor to create the filename of the WebLogic EJB
      * jar file. Optional, default '.jar'.
      * @param inString the string to use as the suffix.
      */
     public void setSuffix(String inString) {
         this.jarSuffix = inString;
     }
 
 
     /**
      * This controls whether the generic file used as input to
      * ejbdeploy is retained; optional, default false.
      * @param inValue either 'true' or 'false'.
      */
     public void setKeepgeneric(boolean inValue) {
         this.keepGeneric = inValue;
     }
 
 
     /**
      * Decide, whether ejbdeploy should be called or not;
      * optional, default true.
      *
      * @param ejbdeploy a <code>boolean</code> value.
      */
     public void setEjbdeploy(boolean ejbdeploy) {
         this.ejbdeploy = ejbdeploy;
     }
 
 
     /**
      * Setter used to store the location of the Sun's Generic EJB DTD. This
      * can be a file on the system or a resource on the classpath.
      *
      * @param inString the string to use as the DTD location.
      */
     public void setEJBdtd(String inString) {
         this.ejb11DTD = inString;
     }
 
 
     /**
      * Set the value of the oldCMP scheme. This is an antonym for newCMP
      * @ant.attribute ignore="true"
      * @param oldCMP a <code>boolean</code> value.
      */
     public void setOldCMP(boolean oldCMP) {
         this.newCMP = !oldCMP;
     }
 
 
     /**
      * Set the value of the newCMP scheme. The old CMP scheme locates the
      * websphere CMP descriptor based on the naming convention where the
      * websphere CMP file is expected to be named with the bean name as the
      * prefix. Under this scheme the name of the CMP descriptor does not match
      * the name actually used in the main websphere EJB descriptor. Also,
      * descriptors which contain multiple CMP references could not be used.
      * @param newCMP a <code>boolean</code> value.
      */
     public void setNewCMP(boolean newCMP) {
         this.newCMP = newCMP;
     }
 
 
     /**
      * The directory, where ejbdeploy will write temporary files;
      * optional, defaults to '_ejbdeploy_temp'.
      * @param tempdir the directory name to use.
      */
     public void setTempdir(String tempdir) {
         this.tempdir = tempdir;
     }
 
 
     /** {@inheritDoc}. */
     protected DescriptorHandler getDescriptorHandler(File srcDir) {
         DescriptorHandler handler = new DescriptorHandler(getTask(), srcDir);
         // register all the DTDs, both the ones that are known and
         // any supplied by the user
         handler.registerDTD(PUBLICID_EJB11, ejb11DTD);
 
         for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {
             EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();
 
             handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
         }
 
         return handler;
     }
 
 
     /**
      * Get a description handler.
      * @param srcDir the source directory.
      * @return the handler.
      */
     protected DescriptorHandler getWebsphereDescriptorHandler(final File srcDir) {
         DescriptorHandler handler =
             new DescriptorHandler(getTask(), srcDir) {
                 protected void processElement() {
                 }
             };
 
         for (Iterator i = getConfig().dtdLocations.iterator(); i.hasNext();) {
             EjbJar.DTDLocation dtdLocation = (EjbJar.DTDLocation) i.next();
 
             handler.registerDTD(dtdLocation.getPublicId(), dtdLocation.getLocation());
         }
         return handler;
     }
 
 
     /**
      * Add any vendor specific files which should be included in the EJB Jar.
      * @param ejbFiles a hashtable entryname -> file.
      * @param baseName a prefix to use.
      */
     protected void addVendorFiles(Hashtable ejbFiles, String baseName) {
 
         String ddPrefix = (usingBaseJarName() ? "" : baseName);
         String dbPrefix = (dbVendor == null) ? "" : dbVendor + "-";
 
         // Get the Extensions document
         File websphereEXT = new File(getConfig().descriptorDir, ddPrefix + WAS_EXT);
 
         if (websphereEXT.exists()) {
             ejbFiles.put(META_DIR + WAS_EXT,
                 websphereEXT);
         } else {
             log("Unable to locate websphere extensions. "
                 + "It was expected to be in "
                 + websphereEXT.getPath(), Project.MSG_VERBOSE);
         }
 
         File websphereBND = new File(getConfig().descriptorDir, ddPrefix + WAS_BND);
 
         if (websphereBND.exists()) {
             ejbFiles.put(META_DIR + WAS_BND,
                 websphereBND);
         } else {
             log("Unable to locate websphere bindings. "
                 + "It was expected to be in "
                 + websphereBND.getPath(), Project.MSG_VERBOSE);
         }
 
         if (!newCMP) {
             log("The old method for locating CMP files has been DEPRECATED.",
                 Project.MSG_VERBOSE);
             log("Please adjust your websphere descriptor and set "
                 + "newCMP=\"true\" to use the new CMP descriptor "
                 + "inclusion mechanism. ", Project.MSG_VERBOSE);
         } else {
             // We attempt to put in the MAP and Schema files of CMP beans
             try {
                 // Add the Map file
                 File websphereMAP = new File(getConfig().descriptorDir,
                     ddPrefix + dbPrefix + WAS_CMP_MAP);
 
                 if (websphereMAP.exists()) {
                     ejbFiles.put(META_DIR + WAS_CMP_MAP,
                         websphereMAP);
                 } else {
                     log("Unable to locate the websphere Map: "
                         + websphereMAP.getPath(), Project.MSG_VERBOSE);
                 }
 
                 File websphereSchema = new File(getConfig().descriptorDir,
                     ddPrefix + dbPrefix + WAS_CMP_SCHEMA);
 
                 if (websphereSchema.exists()) {
                     ejbFiles.put(META_DIR + SCHEMA_DIR + WAS_CMP_SCHEMA,
                         websphereSchema);
                 } else {
                     log("Unable to locate the websphere Schema: "
                         + websphereSchema.getPath(), Project.MSG_VERBOSE);
                 }
                 // Theres nothing else to see here...keep moving sonny
             } catch (Exception e) {
                 String msg = "Exception while adding Vendor specific files: "
                     + e.toString();
 
                 throw new BuildException(msg, e);
             }
         }
     }
 
 
     /**
      * Get the vendor specific name of the Jar that will be output. The
      * modification date of this jar will be checked against the dependent
      * bean classes.
      */
     File getVendorOutputJarFile(String baseName) {
         return new File(getDestDir(), baseName + jarSuffix);
     }
 
 
     /**
      * Gets the options for the EJB Deploy operation
      *
      * @return String
      */
     protected String getOptions() {
         // Set the options
         StringBuffer options = new StringBuffer();
 
         if (dbVendor != null) {
             options.append(" -dbvendor ").append(dbVendor);
         }
         if (dbName != null) {
             options.append(" -dbname \"").append(dbName).append("\"");
         }
 
         if (dbSchema != null) {
             options.append(" -dbschema \"").append(dbSchema).append("\"");
         }
 
         if (codegen) {
             options.append(" -codegen");
         }
 
         if (quiet) {
             options.append(" -quiet");
         }
 
         if (novalidate) {
             options.append(" -novalidate");
         }
 
         if (nowarn) {
             options.append(" -nowarn");
         }
 
         if (noinform) {
             options.append(" -noinform");
         }
 
         if (trace) {
             options.append(" -trace");
         }
 
         if (use35MappingRules) {
             options.append(" -35");
         }
 
         if (rmicOptions != null) {
             options.append(" -rmic \"").append(rmicOptions).append("\"");
         }
 
         return options.toString();
     }
 
 
     /**
      * Helper method invoked by execute() for each websphere jar to be built.
      * Encapsulates the logic of constructing a java task for calling
      * websphere.ejbdeploy and executing it.
      *
      * @param sourceJar java.io.File representing the source (EJB1.1) jarfile.
      * @param destJar java.io.File representing the destination, websphere
      *      jarfile.
      */
     private void buildWebsphereJar(File sourceJar, File destJar) {
         try {
             if (ejbdeploy) {
                 Java javaTask = new Java(getTask());
                 // Set the JvmArgs
                 javaTask.createJvmarg().setValue("-Xms64m");
                 javaTask.createJvmarg().setValue("-Xmx128m");
 
                 // Set the Environment variable
                 Environment.Variable var = new Environment.Variable();
 
                 var.setKey("websphere.lib.dir");
                 File libdir = new File(websphereHome, "lib");
                 var.setValue(libdir.getAbsolutePath());
                 javaTask.addSysproperty(var);
 
                 // Set the working directory
                 javaTask.setDir(websphereHome);
 
                 // Set the Java class name
                 javaTask.setTaskName("ejbdeploy");
                 javaTask.setClassname("com.ibm.etools.ejbdeploy.EJBDeploy");
 
                 javaTask.createArg().setValue(sourceJar.getPath());
                 javaTask.createArg().setValue(tempdir);
                 javaTask.createArg().setValue(destJar.getPath());
                 javaTask.createArg().setLine(getOptions());
                 if (getCombinedClasspath() != null
                     && getCombinedClasspath().toString().length() > 0) {
                     javaTask.createArg().setValue("-cp");
                     javaTask.createArg().setValue(getCombinedClasspath().toString());
                 }
 
                 Path classpath = wasClasspath;
 
                 if (classpath == null) {
                     classpath = getCombinedClasspath();
                 }
 
                 javaTask.setFork(true);
                 if (classpath != null) {
                     javaTask.setClasspath(classpath);
                 }
 
                 log("Calling websphere.ejbdeploy for " + sourceJar.toString(),
                     Project.MSG_VERBOSE);
 
                 javaTask.execute();
             }
         } catch (Exception e) {
             // Have to catch this because of the semantics of calling main()
             String msg = "Exception while calling ejbdeploy. Details: " + e.toString();
 
             throw new BuildException(msg, e);
         }
     }
 
     /** {@inheritDoc}. */
     protected void writeJar(String baseName, File jarFile, Hashtable files, String publicId)
          throws BuildException {
         if (ejbdeploy) {
             // create the -generic.jar, if required
             File genericJarFile = super.getVendorOutputJarFile(baseName);
 
             super.writeJar(baseName, genericJarFile, files, publicId);
 
             // create the output .jar, if required
             if (alwaysRebuild || isRebuildRequired(genericJarFile, jarFile)) {
                 buildWebsphereJar(genericJarFile, jarFile);
             }
             if (!keepGeneric) {
                 log("deleting generic jar " + genericJarFile.toString(),
                     Project.MSG_VERBOSE);
                 genericJarFile.delete();
             }
         } else {
             // create the "undeployed" output .jar, if required
             super.writeJar(baseName, jarFile, files, publicId);
         }
     }
 
 
     /**
      * Called to validate that the tool parameters have been configured.
      * @throws BuildException if there is an error.
      */
     public void validateConfigured() throws BuildException {
         super.validateConfigured();
         if (ejbdeploy) {
             String home = getTask().getProject().getProperty("websphere.home");
             if (home == null) {
                 throw new BuildException("The 'websphere.home' property must "
                     + "be set when 'ejbdeploy=true'");
             }
             websphereHome = getTask().getProject().resolveFile(home);
         }
     }
 
 
     /**
      * Helper method to check to see if a websphere EBJ1.1 jar needs to be
      * rebuilt using ejbdeploy. Called from writeJar it sees if the "Bean"
      * classes are the only thing that needs to be updated and either updates
      * the Jar with the Bean classfile or returns true, saying that the whole
      * websphere jar needs to be regened with ejbdeploy. This allows faster
      * build times for working developers. <p>
      *
      * The way websphere ejbdeploy works is it creates wrappers for the
      * publicly defined methods as they are exposed in the remote interface.
      * If the actual bean changes without changing the the method signatures
      * then only the bean classfile needs to be updated and the rest of the
      * websphere jar file can remain the same. If the Interfaces, ie. the
      * method signatures change or if the xml deployment descriptors changed,
      * the whole jar needs to be rebuilt with ejbdeploy. This is not strictly
-     * true for the xml files. If the JNDI name changes then the jar doesnt
+     * true for the xml files. If the JNDI name changes then the jar doesn't
      * have to be rebuild, but if the resources references change then it
      * does. At this point the websphere jar gets rebuilt if the xml files
      * change at all.
      *
      * @param genericJarFile java.io.File The generic jar file.
      * @param websphereJarFile java.io.File The websphere jar file to check to
      *      see if it needs to be rebuilt.
      * @return true if a rebuild is required.
      */
     // CheckStyle:MethodLength OFF - this will no be fixed
     protected boolean isRebuildRequired(File genericJarFile, File websphereJarFile) {
         boolean rebuild = false;
 
         JarFile genericJar = null;
         JarFile wasJar = null;
         File newwasJarFile = null;
         JarOutputStream newJarStream = null;
         ClassLoader genericLoader = null;
 
         try {
             log("Checking if websphere Jar needs to be rebuilt for jar "
                 + websphereJarFile.getName(), Project.MSG_VERBOSE);
             // Only go forward if the generic and the websphere file both exist
             if (genericJarFile.exists() && genericJarFile.isFile()
                  && websphereJarFile.exists() && websphereJarFile.isFile()) {
                 //open jar files
                 genericJar = new JarFile(genericJarFile);
                 wasJar = new JarFile(websphereJarFile);
 
                 Hashtable genericEntries = new Hashtable();
                 Hashtable wasEntries = new Hashtable();
                 Hashtable replaceEntries = new Hashtable();
 
                 //get the list of generic jar entries
                 for (Enumeration e = genericJar.entries(); e.hasMoreElements();) {
                     JarEntry je = (JarEntry) e.nextElement();
 
                     genericEntries.put(je.getName().replace('\\', '/'), je);
                 }
                 //get the list of websphere jar entries
                 for (Enumeration e = wasJar.entries(); e.hasMoreElements();) {
                     JarEntry je = (JarEntry) e.nextElement();
 
                     wasEntries.put(je.getName(), je);
                 }
 
                 //Cycle Through generic and make sure its in websphere
                 genericLoader = getClassLoaderFromJar(genericJarFile);
 
                 for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) {
                     String filepath = (String) e.nextElement();
 
                     if (wasEntries.containsKey(filepath)) {
                         // File name/path match
                         // Check files see if same
                         JarEntry genericEntry = (JarEntry) genericEntries.get(filepath);
                         JarEntry wasEntry = (JarEntry) wasEntries.get(filepath);
 
                         if ((genericEntry.getCrc() != wasEntry.getCrc())
                             || (genericEntry.getSize() != wasEntry.getSize())) {
 
                             if (genericEntry.getName().endsWith(".class")) {
                                 //File are different see if its an object or an interface
                                 String classname
                                     = genericEntry.getName().replace(File.separatorChar, '.');
 
                                 classname = classname.substring(0, classname.lastIndexOf(".class"));
 
                                 Class genclass = genericLoader.loadClass(classname);
 
                                 if (genclass.isInterface()) {
                                     //Interface changed   rebuild jar.
                                     log("Interface " + genclass.getName()
                                         + " has changed", Project.MSG_VERBOSE);
                                     rebuild = true;
                                     break;
                                 } else {
                                     //Object class Changed   update it.
                                     replaceEntries.put(filepath, genericEntry);
                                 }
                             } else {
                                 // is it the manifest. If so ignore it
                                 if (!genericEntry.getName().equals("META-INF/MANIFEST.MF")) {
                                     //File other then class changed   rebuild
                                     log("Non class file " + genericEntry.getName()
                                         + " has changed", Project.MSG_VERBOSE);
                                     rebuild = true;
                                 }
                                 break;
                             }
                         }
                     } else {
                         // a file doesn't exist rebuild
 
                         log("File " + filepath + " not present in websphere jar",
                             Project.MSG_VERBOSE);
                         rebuild = true;
                         break;
                     }
                 }
 
                 if (!rebuild) {
                     log("No rebuild needed - updating jar", Project.MSG_VERBOSE);
                     newwasJarFile = new File(websphereJarFile.getAbsolutePath() + ".temp");
                     if (newwasJarFile.exists()) {
                         newwasJarFile.delete();
                     }
 
                     newJarStream = new JarOutputStream(new FileOutputStream(newwasJarFile));
                     newJarStream.setLevel(0);
 
                     //Copy files from old websphere jar
                     for (Enumeration e = wasEntries.elements(); e.hasMoreElements();) {
                         byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
                         int bytesRead;
                         InputStream is;
                         JarEntry je = (JarEntry) e.nextElement();
 
                         if (je.getCompressedSize() == -1
                             || je.getCompressedSize() == je.getSize()) {
                             newJarStream.setLevel(0);
                         } else {
                             newJarStream.setLevel(JAR_COMPRESS_LEVEL);
                         }
 
                         // Update with changed Bean class
                         if (replaceEntries.containsKey(je.getName())) {
                             log("Updating Bean class from generic Jar " + je.getName(),
                                 Project.MSG_VERBOSE);
                             // Use the entry from the generic jar
                             je = (JarEntry) replaceEntries.get(je.getName());
                             is = genericJar.getInputStream(je);
                         } else {
                             //use fle from original websphere jar
 
                             is = wasJar.getInputStream(je);
                         }
                         newJarStream.putNextEntry(new JarEntry(je.getName()));
 
                         while ((bytesRead = is.read(buffer)) != -1) {
                             newJarStream.write(buffer, 0, bytesRead);
                         }
                         is.close();
                     }
                 } else {
                     log("websphere Jar rebuild needed due to changed "
                         + "interface or XML", Project.MSG_VERBOSE);
                 }
             } else {
                 rebuild = true;
             }
         } catch (ClassNotFoundException cnfe) {
             String cnfmsg = "ClassNotFoundException while processing ejb-jar file"
                  + ". Details: "
                  + cnfe.getMessage();
 
             throw new BuildException(cnfmsg, cnfe);
         } catch (IOException ioe) {
             String msg = "IOException while processing ejb-jar file "
                  + ". Details: "
                  + ioe.getMessage();
 
             throw new BuildException(msg, ioe);
         } finally {
             // need to close files and perhaps rename output
             if (genericJar != null) {
                 try {
                     genericJar.close();
                 } catch (IOException closeException) {
                     // Ignore
                 }
             }
 
             if (wasJar != null) {
                 try {
                     wasJar.close();
                 } catch (IOException closeException) {
                     // Ignore
                 }
             }
 
             if (newJarStream != null) {
                 try {
                     newJarStream.close();
                 } catch (IOException closeException) {
                     // Ignore
                 }
 
                 try {
                     FILE_UTILS.rename(newwasJarFile, websphereJarFile);
                 } catch (IOException renameException) {
                     log(renameException.getMessage(), Project.MSG_WARN);
                     rebuild = true;
                 }
             }
             if (genericLoader != null
                 && genericLoader instanceof AntClassLoader) {
                 AntClassLoader loader = (AntClassLoader) genericLoader;
                 loader.cleanup();
             }
         }
 
         return rebuild;
     }
 
 
     /**
      * Helper method invoked by isRebuildRequired to get a ClassLoader for a
      * Jar File passed to it.
      *
      * @param classjar java.io.File representing jar file to get classes from.
      * @return a classloader for the jar file.
      * @throws IOException if there is an error.
      */
     protected ClassLoader getClassLoaderFromJar(File classjar) throws IOException {
         Path lookupPath = new Path(getTask().getProject());
 
         lookupPath.setLocation(classjar);
 
         Path classpath = getCombinedClasspath();
 
         if (classpath != null) {
             lookupPath.append(classpath);
         }
 
         return getTask().getProject().createClassLoader(lookupPath);
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/extension/JarLibResolveTask.java b/src/main/org/apache/tools/ant/taskdefs/optional/extension/JarLibResolveTask.java
index 40cc50b92..c13194fa9 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/extension/JarLibResolveTask.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/extension/JarLibResolveTask.java
@@ -1,268 +1,268 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.extension;
 
 import java.io.File;
 import java.util.ArrayList;
 import java.util.jar.Manifest;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.taskdefs.optional.extension.resolvers.AntResolver;
 import org.apache.tools.ant.taskdefs.optional.extension.resolvers.LocationResolver;
 import org.apache.tools.ant.taskdefs.optional.extension.resolvers.URLResolver;
 
 /**
  * Tries to locate a JAR to satisfy an extension and place
  * location of JAR into property.
  *
  * @ant.task name="jarlib-resolve"
  */
 public class JarLibResolveTask extends Task {
     /**
      * The name of the property in which the location of
      * library is stored.
      */
     private String propertyName;
 
     /**
      * The extension that is required.
      */
     private Extension requiredExtension;
 
     /**
      * The set of resolvers to use to attempt to locate library.
      */
     private final ArrayList resolvers = new ArrayList();
 
     /**
      * Flag to indicate that you should check that
      * the librarys resolved actually contain
      * extension and if they don't then raise
      * an exception.
      */
     private boolean checkExtension = true;
 
     /**
      * Flag indicating whether or not you should
      * throw a BuildException if you cannot resolve
      * library.
      */
     private boolean failOnError = true;
 
     /**
      * The name of the property in which the location of
      * library is stored.
      *
      * @param property The name of the property in which the location of
      *                 library is stored.
      */
     public void setProperty(final String property) {
         this.propertyName = property;
     }
 
     /**
      * Check nested libraries for extensions
      *
      * @param checkExtension if true, libraries returned by nested
      * resolvers should be checked to see if they supply extension.
      */
     public void setCheckExtension(final boolean checkExtension) {
         this.checkExtension = checkExtension;
     }
 
     /**
      * Set whether to fail if error.
      *
      * @param failOnError if true, failure to locate library should fail build.
      */
     public void setFailOnError(final boolean failOnError) {
         this.failOnError = failOnError;
     }
 
     /**
      * Adds location resolver to look for a library in a location
      * relative to project directory.
      *
      * @param loc the resolver location to search.
      */
     public void addConfiguredLocation(final LocationResolver loc) {
         resolvers.add(loc);
     }
 
     /**
      * Adds a URL resolver to download a library from a URL
      * to a local file.
      *
      * @param url the URL resolver from which to download the library
      */
     public void addConfiguredUrl(final URLResolver url) {
         resolvers.add(url);
     }
 
     /**
      * Adds Ant resolver to run an Ant build file to generate a library.
      *
      * @param ant the AntResolver to generate the library.
      */
     public void addConfiguredAnt(final AntResolver ant) {
         resolvers.add(ant);
     }
 
     /**
      * Set the Extension looking for.
      *
      * @param extension Set the Extension looking for.
      */
     public void addConfiguredExtension(final ExtensionAdapter extension) {
         if (null != requiredExtension) {
             final String message = "Can not specify extension to "
                 + "resolve multiple times.";
             throw new BuildException(message);
         }
         requiredExtension = extension.toExtension();
     }
 
     /**
      * Execute the task.
      *
      * @throws BuildException if the task fails.
      */
     public void execute() throws BuildException {
         validate();
 
         getProject().log("Resolving extension: " + requiredExtension, Project.MSG_VERBOSE);
 
         String candidate = getProject().getProperty(propertyName);
 
         if (null != candidate) {
             final String message = "Property Already set to: " + candidate;
             if (failOnError) {
                 throw new BuildException(message);
             }
             getProject().log(message, Project.MSG_ERR);
             return;
         }
 
         final int size = resolvers.size();
         for (int i = 0; i < size; i++) {
             final ExtensionResolver resolver =
                 (ExtensionResolver) resolvers.get(i);
 
             getProject().log("Searching for extension using Resolver:" + resolver,
                     Project.MSG_VERBOSE);
 
             try {
                 final File file = resolver.resolve(requiredExtension, getProject());
                 try {
                     checkExtension(file);
                     return;
                 } catch (final BuildException be) {
                     final String message = "File " + file + " returned by "
                             + "resolver failed to satisfy extension due to: " + be.getMessage();
                     getProject().log(message, Project.MSG_WARN);
                 }
             } catch (final BuildException be) {
                 final String message = "Failed to resolve extension to file " + "using resolver "
                         + resolver + " due to: " + be;
                 getProject().log(message, Project.MSG_WARN);
             }
         }
         missingExtension();
     }
 
     /**
      * Utility method that will throw a {@link BuildException}
      * if {@link #failOnError} is true else it just displays
      * a warning.
      */
     private void missingExtension() {
         final String message = "Unable to resolve extension to a file";
         if (failOnError) {
             throw new BuildException(message);
         }
         getProject().log(message, Project.MSG_ERR);
     }
 
     /**
      * Check if specified file satisfies extension.
-     * If it does then set the relevent property
+     * If it does then set the relevant property
      * else throw a BuildException.
      *
      * @param file the candidate library
      * @throws BuildException if library does not satisfy extension
      */
     private void checkExtension(final File file) {
         if (!file.exists()) {
             throw new BuildException("File " + file + " does not exist");
         }
         if (!file.isFile()) {
             throw new BuildException("File " + file + " is not a file");
         }
         if (!checkExtension) {
             getProject().log("Setting property to " + file
                     + " without verifying library satisfies extension", Project.MSG_VERBOSE);
             setLibraryProperty(file);
         } else {
             getProject().log("Checking file " + file + " to see if it satisfies extension",
                     Project.MSG_VERBOSE);
             final Manifest manifest = ExtensionUtil.getManifest(file);
             final Extension[] extensions = Extension.getAvailable(manifest);
             for (int i = 0; i < extensions.length; i++) {
                 final Extension extension = extensions[ i ];
                 if (extension.isCompatibleWith(requiredExtension)) {
                     setLibraryProperty(file);
                     return;
                 }
             }
             final String message = "File " + file + " skipped as it "
                 + "does not satisfy extension";
             getProject().log(message, Project.MSG_VERBOSE);
             throw new BuildException(message);
         }
     }
 
     /**
      * Utility method to set the appropriate property
      * to indicate that specified file satisfies library
      * requirements.
      *
      * @param file the library
      */
     private void setLibraryProperty(final File file) {
         getProject().setNewProperty(propertyName, file.getAbsolutePath());
     }
 
     /**
      * Validate the tasks parameters.
      *
      * @throws BuildException if invalid parameters found
      */
     private void validate() throws BuildException {
         if (null == propertyName) {
             final String message = "Property attribute must be specified.";
             throw new BuildException(message);
         }
 
         if (null == requiredExtension) {
             final String message = "Extension element must be specified.";
             throw new BuildException(message);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/extension/LibFileSet.java b/src/main/org/apache/tools/ant/taskdefs/optional/extension/LibFileSet.java
index 591fda7d0..b21719e58 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/extension/LibFileSet.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/extension/LibFileSet.java
@@ -1,117 +1,117 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.extension;
 
 import org.apache.tools.ant.types.FileSet;
 
 /**
  * LibFileSet represents a fileset containing libraries.
- * Asociated with the libraries is data pertaining to
+ * Associated with the libraries is data pertaining to
  * how they are to be handled when building manifests.
  *
  */
 public class LibFileSet
     extends FileSet {
     /**
      * Flag indicating whether should include the
      * "Implementation-URL" attribute in manifest.
      * Defaults to false.
      */
     private boolean includeURL;
 
     /**
      * Flag indicating whether should include the
      * "Implementation-*" attributes in manifest.
      * Defaults to false.
      */
     private boolean includeImpl;
 
     /**
      * String that is the base URL for the librarys
      * when constructing the "Implementation-URL"
      * attribute. For instance setting the base to
      * "http://jakarta.apache.org/avalon/libs/" and then
      * including the library "excalibur-cli-1.0.jar" in the
      * fileset will result in the "Implementation-URL" attribute
      * being set to "http://jakarta.apache.org/avalon/libs/excalibur-cli-1.0.jar"
      *
      * Note this is only used if the library does not define
      * "Implementation-URL" itself.
      *
      * Note that this also implies includeURL=true
      */
     private String urlBase;
 
     /**
      * Flag indicating whether should include the
      * "Implementation-URL" attribute in manifest.
      * Defaults to false.
      *
      * @param includeURL the flag
      */
     public void setIncludeUrl(boolean includeURL) {
         this.includeURL = includeURL;
     }
 
     /**
      * Flag indicating whether should include the
      * "Implementation-*" attributes in manifest.
      * Defaults to false.
      *
      * @param includeImpl the flag
      */
     public void setIncludeImpl(boolean includeImpl) {
         this.includeImpl = includeImpl;
     }
 
     /**
      * Set the url base for fileset.
      *
      * @param urlBase the base url
      */
     public void setUrlBase(String urlBase) {
         this.urlBase = urlBase;
     }
 
     /**
      * Get the includeURL flag.
      *
      * @return the includeURL flag.
      */
     boolean isIncludeURL() {
         return includeURL;
     }
 
     /**
      * Get the includeImpl flag.
      *
      * @return the includeImpl flag.
      */
     boolean isIncludeImpl() {
         return includeImpl;
     }
 
     /**
      * Get the urlbase.
      *
      * @return the urlbase.
      */
     String getUrlBase() {
         return urlBase;
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/i18n/Translate.java b/src/main/org/apache/tools/ant/taskdefs/optional/i18n/Translate.java
index 5cca45c00..82731fe9e 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/i18n/Translate.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/i18n/Translate.java
@@ -1,632 +1,632 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.i18n;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.util.Hashtable;
 import java.util.Locale;
 import java.util.Vector;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.LineTokenizer;
 
 /**
  * Translates text embedded in files using Resource Bundle files.
  * Since ant 1.6 preserves line endings
  *
  */
 public class Translate extends MatchingTask {
     /**
      * search a bundle matching the specified language, the country and the variant
      */
     private static final int BUNDLE_SPECIFIED_LANGUAGE_COUNTRY_VARIANT = 0;
     /**
      * search a bundle matching the specified language, and the country
      */
     private static final int BUNDLE_SPECIFIED_LANGUAGE_COUNTRY = 1;
     /**
      * search a bundle matching the specified language only
      */
     private static final int BUNDLE_SPECIFIED_LANGUAGE = 2;
     /**
      * search a bundle matching nothing special
      */
     private static final int BUNDLE_NOMATCH = 3;
     /**
      * search a bundle matching the language, the country and the variant
      * of the current locale of the computer
      */
     private static final int BUNDLE_DEFAULT_LANGUAGE_COUNTRY_VARIANT = 4;
     /**
      * search a bundle matching the language, and the country
      * of the current locale of the computer
      */
     private static final int BUNDLE_DEFAULT_LANGUAGE_COUNTRY = 5;
     /**
      * search a bundle matching the language only
      * of the current locale of the computer
      */
     private static final int BUNDLE_DEFAULT_LANGUAGE = 6;
     /**
      * number of possibilities for the search
      */
      private static final int BUNDLE_MAX_ALTERNATIVES = BUNDLE_DEFAULT_LANGUAGE + 1;
     /**
      * Family name of resource bundle
      */
     private String bundle;
 
     /**
      * Locale specific language of the resource bundle
      */
     private String bundleLanguage;
 
     /**
      * Locale specific country of the resource bundle
      */
     private String bundleCountry;
 
     /**
      * Locale specific variant of the resource bundle
      */
     private String bundleVariant;
 
     /**
      * Destination directory
      */
     private File toDir;
 
     /**
      * Source file encoding scheme
      */
     private String srcEncoding;
 
     /**
      * Destination file encoding scheme
      */
     private String destEncoding;
 
     /**
      * Resource Bundle file encoding scheme, defaults to srcEncoding
      */
     private String bundleEncoding;
 
     /**
      * Starting token to identify keys
      */
     private String startToken;
 
     /**
      * Ending token to identify keys
      */
     private String endToken;
 
     /**
      * Whether or not to create a new destination file.
      * Defaults to <code>false</code>.
      */
     private boolean forceOverwrite;
 
     /**
      * Vector to hold source file sets.
      */
     private Vector filesets = new Vector();
 
     /**
      * Holds key value pairs loaded from resource bundle file
      */
     private Hashtable resourceMap = new Hashtable();
     /**
 
      * Used to resolve file names.
      */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * Last Modified Timestamp of resource bundle file being used.
      */
     private long[] bundleLastModified = new long[BUNDLE_MAX_ALTERNATIVES];
 
     /**
      * Last Modified Timestamp of source file being used.
      */
     private long srcLastModified;
 
     /**
      * Last Modified Timestamp of destination file being used.
      */
     private long destLastModified;
 
     /**
      * Has at least one file from the bundle been loaded?
      */
     private boolean loaded = false;
 
     /**
      * Sets Family name of resource bundle; required.
      * @param bundle family name of resource bundle
      */
     public void setBundle(String bundle) {
         this.bundle = bundle;
     }
 
     /**
      * Sets locale specific language of resource bundle; optional.
      * @param bundleLanguage language of the bundle
      */
     public void setBundleLanguage(String bundleLanguage) {
         this.bundleLanguage = bundleLanguage;
     }
 
     /**
      * Sets locale specific country of resource bundle; optional.
      * @param bundleCountry country of the bundle
      */
     public void setBundleCountry(String bundleCountry) {
         this.bundleCountry = bundleCountry;
     }
 
     /**
      * Sets locale specific variant of resource bundle; optional.
      * @param bundleVariant locale variant of resource bundle
      */
     public void setBundleVariant(String bundleVariant) {
         this.bundleVariant = bundleVariant;
     }
 
     /**
      * Sets Destination directory; required.
      * @param toDir destination directory
      */
     public void setToDir(File toDir) {
         this.toDir = toDir;
     }
 
     /**
      * Sets starting token to identify keys; required.
      * @param startToken starting token to identify keys
      */
     public void setStartToken(String startToken) {
         this.startToken = startToken;
     }
 
     /**
      * Sets ending token to identify keys; required.
      * @param endToken ending token to identify keys
      */
     public void setEndToken(String endToken) {
         this.endToken = endToken;
     }
 
     /**
      * Sets source file encoding scheme; optional,
      * defaults to encoding of local system.
      * @param srcEncoding source file encoding
      */
     public void setSrcEncoding(String srcEncoding) {
         this.srcEncoding = srcEncoding;
     }
 
     /**
      * Sets destination file encoding scheme; optional.  Defaults to source file
      * encoding
      * @param destEncoding destination file encoding scheme
      */
     public void setDestEncoding(String destEncoding) {
         this.destEncoding = destEncoding;
     }
 
     /**
      * Sets Resource Bundle file encoding scheme; optional.  Defaults to source file
      * encoding
      * @param bundleEncoding bundle file encoding scheme
      */
     public void setBundleEncoding(String bundleEncoding) {
         this.bundleEncoding = bundleEncoding;
     }
 
     /**
      * Whether or not to overwrite existing file irrespective of
      * whether it is newer than the source file as well as the
      * resource bundle file.
      * Defaults to false.
      * @param forceOverwrite whether or not to overwrite existing files
      */
     public void setForceOverwrite(boolean forceOverwrite) {
         this.forceOverwrite = forceOverwrite;
     }
 
     /**
      * Adds a set of files to translate as a nested fileset element.
      * @param set the fileset to be added
      */
     public void addFileset(FileSet set) {
         filesets.addElement(set);
     }
 
     /**
      * Check attributes values, load resource map and translate
      * @throws BuildException if the required attributes are not set
      * Required : <ul>
      *       <li>bundle</li>
      *       <li>starttoken</li>
      *       <li>endtoken</li>
      *            </ul>
      */
     public void execute() throws BuildException {
         if (bundle == null) {
             throw new BuildException("The bundle attribute must be set.",
                                      getLocation());
         }
 
         if (startToken == null) {
             throw new BuildException("The starttoken attribute must be set.",
                                      getLocation());
         }
 
         if (endToken == null) {
             throw new BuildException("The endtoken attribute must be set.",
                                      getLocation());
         }
 
         if (bundleLanguage == null) {
             Locale l = Locale.getDefault();
             bundleLanguage  = l.getLanguage();
         }
 
         if (bundleCountry == null) {
             bundleCountry = Locale.getDefault().getCountry();
         }
 
         if (bundleVariant == null) {
             Locale l = new Locale(bundleLanguage, bundleCountry);
             bundleVariant = l.getVariant();
         }
 
         if (toDir == null) {
             throw new BuildException("The todir attribute must be set.",
                                      getLocation());
         }
 
         if (!toDir.exists()) {
             toDir.mkdirs();
         } else if (toDir.isFile()) {
             throw new BuildException(toDir + " is not a directory");
         }
 
         if (srcEncoding == null) {
             srcEncoding = System.getProperty("file.encoding");
         }
 
         if (destEncoding == null) {
             destEncoding = srcEncoding;
         }
 
         if (bundleEncoding == null) {
             bundleEncoding = srcEncoding;
         }
 
         loadResourceMaps();
 
         translate();
     }
 
     /**
      * Load resource maps based on resource bundle encoding scheme.
      * The resource bundle lookup searches for resource files with various
      * suffixes on the basis of (1) the desired locale and (2) the default
      * locale (basebundlename), in the following order from lower-level
      * (more specific) to parent-level (less specific):
      *
      * basebundlename + "_" + language1 + "_" + country1 + "_" + variant1
      * basebundlename + "_" + language1 + "_" + country1
      * basebundlename + "_" + language1
      * basebundlename
      * basebundlename + "_" + language2 + "_" + country2 + "_" + variant2
      * basebundlename + "_" + language2 + "_" + country2
      * basebundlename + "_" + language2
      *
      * To the generated name, a ".properties" string is appeneded and
      * once this file is located, it is treated just like a properties file
      * but with bundle encoding also considered while loading.
      */
     private void loadResourceMaps() throws BuildException {
         Locale locale = new Locale(bundleLanguage,
                                    bundleCountry,
                                    bundleVariant);
         String language = locale.getLanguage().length() > 0
             ? "_" + locale.getLanguage() : "";
         String country = locale.getCountry().length() > 0
             ? "_" + locale.getCountry() : "";
         String variant = locale.getVariant().length() > 0
             ? "_" + locale.getVariant() : "";
         String bundleFile = bundle + language + country + variant;
         processBundle(bundleFile, BUNDLE_SPECIFIED_LANGUAGE_COUNTRY_VARIANT, false);
 
         bundleFile = bundle + language + country;
         processBundle(bundleFile, BUNDLE_SPECIFIED_LANGUAGE_COUNTRY, false);
 
         bundleFile = bundle + language;
         processBundle(bundleFile, BUNDLE_SPECIFIED_LANGUAGE, false);
 
         bundleFile = bundle;
         processBundle(bundleFile, BUNDLE_NOMATCH, false);
 
         //Load default locale bundle files
         //using default file encoding scheme.
         locale = Locale.getDefault();
 
         language = locale.getLanguage().length() > 0
             ? "_" + locale.getLanguage() : "";
         country = locale.getCountry().length() > 0
             ? "_" + locale.getCountry() : "";
         variant = locale.getVariant().length() > 0
             ? "_" + locale.getVariant() : "";
         bundleEncoding = System.getProperty("file.encoding");
 
         bundleFile = bundle + language + country + variant;
         processBundle(bundleFile, BUNDLE_DEFAULT_LANGUAGE_COUNTRY_VARIANT, false);
 
         bundleFile = bundle + language + country;
         processBundle(bundleFile, BUNDLE_DEFAULT_LANGUAGE_COUNTRY, false);
 
         bundleFile = bundle + language;
         processBundle(bundleFile, BUNDLE_DEFAULT_LANGUAGE, true);
     }
 
     /**
      * Process each file that makes up this bundle.
      */
     private void processBundle(final String bundleFile, final int i,
                                final boolean checkLoaded) throws BuildException {
         final File propsFile = getProject().resolveFile(bundleFile + ".properties");
         FileInputStream ins = null;
         try {
             ins = new FileInputStream(propsFile);
             loaded = true;
             bundleLastModified[i] = propsFile.lastModified();
             log("Using " + propsFile, Project.MSG_DEBUG);
             loadResourceMap(ins);
         } catch (IOException ioe) {
             log(propsFile + " not found.", Project.MSG_DEBUG);
             //if all resource files associated with this bundle
             //have been scanned for and still not able to
             //find a single resrouce file, throw exception
             if (!loaded && checkLoaded) {
                 throw new BuildException(ioe.getMessage(), getLocation());
             }
         }
     }
 
     /**
      * Load resourceMap with key value pairs.  Values of existing keys
      * are not overwritten.  Bundle's encoding scheme is used.
      */
     private void loadResourceMap(FileInputStream ins) throws BuildException {
         try {
             BufferedReader in = null;
             InputStreamReader isr = new InputStreamReader(ins, bundleEncoding);
             in = new BufferedReader(isr);
             String line = null;
             while ((line = in.readLine()) != null) {
                 //So long as the line isn't empty and isn't a comment...
                 if (line.trim().length() > 1 && '#' != line.charAt(0) && '!' != line.charAt(0)) {
                     //Legal Key-Value separators are :, = and white space.
                     int sepIndex = line.indexOf('=');
                     if (-1 == sepIndex) {
                         sepIndex = line.indexOf(':');
                     }
                     if (-1 == sepIndex) {
                         for (int k = 0; k < line.length(); k++) {
                             if (Character.isSpaceChar(line.charAt(k))) {
                                 sepIndex = k;
                                 break;
                             }
                         }
                     }
                     //Only if we do have a key is there going to be a value
                     if (-1 != sepIndex) {
                         String key = line.substring(0, sepIndex).trim();
                         String value = line.substring(sepIndex + 1).trim();
                         //Handle line continuations, if any
                         while (value.endsWith("\\")) {
                             value = value.substring(0, value.length() - 1);
                             line = in.readLine();
                             if (line != null) {
                                 value = value + line.trim();
                             } else {
                                 break;
                             }
                         }
                         if (key.length() > 0) {
                             //Has key already been loaded into resourceMap?
                             if (resourceMap.get(key) == null) {
                                 resourceMap.put(key, value);
                             }
                         }
                     }
                 }
             }
             if (in != null) {
                 in.close();
             }
         } catch (IOException ioe) {
             throw new BuildException(ioe.getMessage(), getLocation());
         }
     }
 
     /**
      * Reads source file line by line using the source encoding and
      * searches for keys that are sandwiched between the startToken
      * and endToken.  The values for these keys are looked up from
      * the hashtable and substituted.  If the hashtable doesn't
      * contain the key, they key itself is used as the value.
      * Detination files and directories are created as needed.
      * The destination file is overwritten only if
      * the forceoverwritten attribute is set to true if
      * the source file or any associated bundle resource file is
      * newer than the destination file.
      */
     private void translate() throws BuildException {
         int filesProcessed = 0;
         final int size = filesets.size();
         for (int i = 0; i < size; i++) {
             FileSet fs = (FileSet) filesets.elementAt(i);
             DirectoryScanner ds = fs.getDirectoryScanner(getProject());
             String[] srcFiles = ds.getIncludedFiles();
             for (int j = 0; j < srcFiles.length; j++) {
                 try {
                     File dest = FILE_UTILS.resolveFile(toDir, srcFiles[j]);
                     //Make sure parent dirs exist, else, create them.
                     try {
                         File destDir = new File(dest.getParent());
                         if (!destDir.exists()) {
                             destDir.mkdirs();
                         }
                     } catch (Exception e) {
                         log("Exception occurred while trying to check/create "
                             + " parent directory.  " + e.getMessage(),
                             Project.MSG_DEBUG);
                     }
                     destLastModified = dest.lastModified();
                     File src = FILE_UTILS.resolveFile(ds.getBasedir(), srcFiles[j]);
                     srcLastModified = src.lastModified();
                     //Check to see if dest file has to be recreated
                     boolean needsWork = forceOverwrite
                         || destLastModified < srcLastModified;
                     if (!needsWork) {
                         for (int icounter = 0; icounter < BUNDLE_MAX_ALTERNATIVES; icounter++) {
                             needsWork = (destLastModified < bundleLastModified[icounter]);
                             if (needsWork) {
                                 break;
                             }
                         }
                     }
                     if (needsWork) {
                         log("Processing " + srcFiles[j],
                             Project.MSG_DEBUG);
                         translateOneFile(src, dest);
                         ++filesProcessed;
                     } else {
                         log("Skipping " + srcFiles[j]
                             + " as destination file is up to date",
                             Project.MSG_VERBOSE);
                     }
                 } catch (IOException ioe) {
                     throw new BuildException(ioe.getMessage(), getLocation());
                 }
             }
         }
         log("Translation performed on " + filesProcessed + " file(s).", Project.MSG_DEBUG);
     }
 
     private void translateOneFile(File src, File dest) throws IOException {
         BufferedWriter out = null;
         BufferedReader in = null;
         try {
             FileOutputStream fos = new FileOutputStream(dest);
             out = new BufferedWriter(new OutputStreamWriter(fos, destEncoding));
             FileInputStream fis = new FileInputStream(src);
             in = new BufferedReader(new InputStreamReader(fis, srcEncoding));
             String line;
             LineTokenizer lineTokenizer = new LineTokenizer();
             lineTokenizer.setIncludeDelims(true);
             line = lineTokenizer.getToken(in);
             while ((line) != null) {
                 // 2003-02-21 new replace algorithm by tbee (tbee@tbee.org)
                 // because it wasn't able to replace something like "@aaa;@bbb;"
 
                 // is there a startToken
                 // and there is still stuff following the startToken
                 int startIndex = line.indexOf(startToken);
                 while (startIndex >= 0
                        && (startIndex + startToken.length()) <= line.length()) {
                     // the new value, this needs to be here
                     // because it is required to calculate the next position to
                     // search from at the end of the loop
                     String replace = null;
 
                     // we found a starttoken, is there an endtoken following?
                     // start at token+tokenlength because start and end
-                    // token may be indentical
+                    // token may be identical
                     int endIndex = line.indexOf(endToken, startIndex
                                                 + startToken.length());
                     if (endIndex < 0) {
                         startIndex += 1;
                     } else {
                         // grab the token
                         String token = line.substring(startIndex
                                                       + startToken.length(),
                                                       endIndex);
 
                         // If there is a white space or = or :, then
                         // it isn't to be treated as a valid key.
                         boolean validToken = true;
                         for (int k = 0; k < token.length() && validToken; k++) {
                             char c = token.charAt(k);
                             if (c == ':' || c == '='
                                 || Character.isSpaceChar(c)) {
                                 validToken = false;
                             }
                         }
                         if (!validToken) {
                             startIndex += 1;
                         } else {
                             // find the replace string
                             if (resourceMap.containsKey(token)) {
                                 replace = (String) resourceMap.get(token);
                             } else {
                                 log("Replacement string missing for: " + token,
                                     Project.MSG_VERBOSE);
                                 replace = startToken + token + endToken;
                             }
 
 
                             // generate the new line
                             line = line.substring(0, startIndex) + replace
                                 + line.substring(endIndex + endToken.length());
 
                             // set start position for next search
                             startIndex += replace.length();
                         }
                     }
 
                     // find next starttoken
                     startIndex = line.indexOf(startToken, startIndex);
                 }
                 out.write(line);
                 line = lineTokenizer.getToken(in);
             }
         } finally {
             FileUtils.close(in);
             FileUtils.close(out);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/jsp/JspNameMangler.java b/src/main/org/apache/tools/ant/taskdefs/optional/jsp/JspNameMangler.java
index 6aaae5c25..6e08e7d5e 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/jsp/JspNameMangler.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/jsp/JspNameMangler.java
@@ -1,155 +1,155 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.jsp;
 import java.io.File;
 
 import org.apache.tools.ant.util.StringUtils;
 
 /**
  * This is a class derived from the Jasper code
  * (org.apache.jasper.compiler.CommandLineCompiler) to map from a JSP filename
  * to a valid Java classname.
  *
  */
 public class JspNameMangler implements JspMangler {
 
     // CheckStyle:ConstantNameCheck OFF - bc
 
     /**
      * this is the list of keywords which can not be used as classnames
      */
     public static final String[] keywords = {
             "assert",
             "abstract", "boolean", "break", "byte",
             "case", "catch", "char", "class",
             "const", "continue", "default", "do",
             "double", "else", "extends", "final",
             "finally", "float", "for", "goto",
             "if", "implements", "import",
             "instanceof", "int", "interface",
             "long", "native", "new", "package",
             "private", "protected", "public",
             "return", "short", "static", "super",
             "switch", "synchronized", "this",
             "throw", "throws", "transient",
             "try", "void", "volatile", "while"
             };
 
     // CheckStyle:ConstantNameCheck ON
 
     /**
      * map from a jsp file to a java filename; does not do packages
      *
      * @param jspFile file
      * @return java filename
      */
     public String mapJspToJavaName(File jspFile) {
         return mapJspToBaseName(jspFile) + ".java";
     }
 
 
     /**
      * map from a jsp file to a base name; does not deal with extensions
      *
      * @param jspFile jspFile file
      * @return exensionless potentially remapped name
      */
     private String mapJspToBaseName(File jspFile) {
         String className;
         className = stripExtension(jspFile);
 
         // since we don't mangle extensions like the servlet does,
         // we need to check for keywords as class names
         for (int i = 0; i < keywords.length; ++i) {
             if (className.equals(keywords[i])) {
                 className += "%";
                 break;
             }
         }
 
         // Fix for invalid characters. If you think of more add to the list.
         StringBuffer modifiedClassName = new StringBuffer(className.length());
         // first char is more restrictive than the rest
         char firstChar = className.charAt(0);
         if (Character.isJavaIdentifierStart(firstChar)) {
             modifiedClassName.append(firstChar);
         } else {
             modifiedClassName.append(mangleChar(firstChar));
         }
         // this is the rest
         for (int i = 1; i < className.length(); i++) {
             char subChar = className.charAt(i);
             if (Character.isJavaIdentifierPart(subChar)) {
                 modifiedClassName.append(subChar);
             } else {
                 modifiedClassName.append(mangleChar(subChar));
             }
         }
         return modifiedClassName.toString();
     }
 
 
     /**
      * get short filename from file
      *
      * @param jspFile file in
      * @return file without any jsp extension
      */
     private String stripExtension(File jspFile) {
         return StringUtils.removeSuffix(jspFile.getName(), ".jsp");
     }
 
 
     /**
      * definition of the char escaping algorithm
      *
      * @param ch char to mangle
      * @return mangled string; 5 digit hex value
      */
     private static String mangleChar(char ch) {
         // CheckStyle:MagicNumber OFF
         if (ch == File.separatorChar) {
             ch = '/';
         }
         String s = Integer.toHexString(ch);
         int nzeros = 5 - s.length();
         char[] result = new char[6];
         result[0] = '_';
         for (int i = 1; i <= nzeros; ++i) {
             result[i] = '0';
         }
         int resultIndex = 0;
         for (int i = nzeros + 1; i < 6; ++i) {
             result[i] = s.charAt(resultIndex++);
         }
         return new String(result);
         // CheckStyle:MagicNumber ON
     }
 
     /**
      * taking in the substring representing the path relative to the source dir
      * return a new string representing the destination path
-     * not supported, as jasper in tomcat4.0 doesnt either
+     * not supported, as jasper in tomcat4.0 doesn't either
      * @param path not used
      * @return null always.
      */
     public String mapPath(String path) {
         return null;
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/jsp/compilers/JspCompilerAdapter.java b/src/main/org/apache/tools/ant/taskdefs/optional/jsp/compilers/JspCompilerAdapter.java
index 34897d5bf..16b67f9d6 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/jsp/compilers/JspCompilerAdapter.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/jsp/compilers/JspCompilerAdapter.java
@@ -1,64 +1,64 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.jsp.compilers;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.taskdefs.optional.jsp.JspC;
 import org.apache.tools.ant.taskdefs.optional.jsp.JspMangler;
 
 /**
  * The interface that all jsp compiler adapters must adher to.
  *
  * <p>A compiler adapter is an adapter that interprets the jspc's
- * parameters in preperation to be passed off to the compiler this
+ * parameters in preparation to be passed off to the compiler this
  * adapter represents.  As all the necessary values are stored in the
  * Jspc task itself, the only thing all adapters need is the jsp
  * task, the execute command and a parameterless constructor (for
  * reflection).</p>
  *
  */
 
 public interface JspCompilerAdapter {
 
     /**
      * Sets the compiler attributes, which are stored in the Jspc task.
      * @param attributes the jsp compiler attributes
      */
     void setJspc(JspC attributes);
 
     /**
      * Executes the task.
      *
      * @return has the compilation been successful
      * @throws BuildException on error
      */
     boolean execute() throws BuildException;
 
     /**
      * @return an instance of the mangler this compiler uses
      */
 
     JspMangler createMangler();
 
     /**
      * ask if compiler can sort out its own dependencies
      * @return true if the compiler wants to do its own
      * depends
      */
     boolean implementsOwnDependencyChecking();
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/junit/FailureRecorder.java b/src/main/org/apache/tools/ant/taskdefs/optional/junit/FailureRecorder.java
index 63451e7e2..3046b75aa 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/junit/FailureRecorder.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/junit/FailureRecorder.java
@@ -1,448 +1,448 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.junit;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.SortedSet;
 import java.util.TreeSet;
 import java.util.Vector;
 
 import junit.framework.AssertionFailedError;
 import junit.framework.Test;
 
 import org.apache.tools.ant.BuildEvent;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.BuildListener;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.ProjectComponent;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * <p>Collects all failing test <i>cases</i> and creates a new JUnit test class containing
  * a suite() method which calls these failed tests.</p>
  * <p>Having classes <i>A</i> ... <i>D</i> with each several testcases you could earn a new
  * test class like
  * <pre>
  * // generated on: 2007.08.06 09:42:34,555
  * import junit.framework.*;
  * public class FailedTests extends TestCase {
  *     public FailedTests(String testname) {
  *         super(testname);
  *     }
  *     public static Test suite() {
  *         TestSuite suite = new TestSuite();
  *         suite.addTest( new B("test04") );
  *         suite.addTest( new org.D("test10") );
  *         return suite;
  *     }
  * }
  * </pre>
  *
  * Because each running test case gets its own formatter, we collect
  * the failing test cases in a static list. Because we dont have a finalizer
  * method in the formatters "lifecycle", we register this formatter as
  * BuildListener and generate the new java source on taskFinished event.
  *
  * @since Ant 1.8.0
  */
 public class FailureRecorder extends ProjectComponent implements JUnitResultFormatter, BuildListener {
 
     /**
      * This is the name of a magic System property ({@value}). The value of this
      * <b>System</b> property should point to the location where to store the
      * generated class (without suffix).
      * Default location and name is defined in DEFAULT_CLASS_LOCATION.
      * @see #DEFAULT_CLASS_LOCATION
      */
     public static final String MAGIC_PROPERTY_CLASS_LOCATION
         = "ant.junit.failureCollector";
 
     /** Default location and name for the generated JUnit class file,
      *  in the temp directory + FailedTests */
     public static final String DEFAULT_CLASS_LOCATION
         = System.getProperty("java.io.tmpdir") + "FailedTests";
 
     /** Prefix for logging. {@value} */
     private static final String LOG_PREFIX = "    [junit]";
 
     /** Class names of failed tests without duplicates. */
     private static SortedSet/*<TestInfos>*/ failedTests = new TreeSet();
 
     /** A writer for writing the generated source to. */
     private BufferedWriter writer;
 
     /**
      * Location and name of the generated JUnit class.
      * Lazy instantiated via getLocationName().
      */
     private static String locationName;
 
     /**
      * Returns the (lazy evaluated) location for the collector class.
      * Order for evaluation: System property > Ant property > default value
      * @return location for the collector class
      * @see #MAGIC_PROPERTY_CLASS_LOCATION
      * @see #DEFAULT_CLASS_LOCATION
      */
     private String getLocationName() {
         if (locationName == null) {
             String syspropValue = System.getProperty(MAGIC_PROPERTY_CLASS_LOCATION);
             String antpropValue = getProject().getProperty(MAGIC_PROPERTY_CLASS_LOCATION);
 
             if (syspropValue != null) {
                 locationName = syspropValue;
                 verbose("System property '" + MAGIC_PROPERTY_CLASS_LOCATION + "' set, so use "
                         + "its value '" + syspropValue + "' as location for collector class.");
             } else if (antpropValue != null) {
                 locationName = antpropValue;
                 verbose("Ant property '" + MAGIC_PROPERTY_CLASS_LOCATION + "' set, so use "
                         + "its value '" + antpropValue + "' as location for collector class.");
             } else {
                 locationName = DEFAULT_CLASS_LOCATION;
                 verbose("System property '" + MAGIC_PROPERTY_CLASS_LOCATION + "' not set, so use "
                         + "value as location for collector class: '"
                         + DEFAULT_CLASS_LOCATION + "'");
             }
 
             File locationFile = new File(locationName);
             if (!locationFile.isAbsolute()) {
                 File f = new File(getProject().getBaseDir(), locationName);
                 locationName = f.getAbsolutePath();
                 verbose("Location file is relative (" + locationFile + ")"
                         + " use absolute path instead (" + locationName + ")");
             }
         }
 
         return locationName;
     }
 
     /**
      * This method is called by the Ant runtime by reflection. We use the project reference for
      * registration of this class as BuildListener.
      *
      * @param project
      *            project reference
      */
     public void setProject(Project project) {
         // store project reference for logging
         super.setProject(project);
         // check if already registered
         boolean alreadyRegistered = false;
         Vector allListeners = project.getBuildListeners();
         final int size = allListeners.size();
         for (int i = 0; i < size; i++) {
             Object listener = allListeners.get(i);
             if (listener instanceof FailureRecorder) {
                 alreadyRegistered = true;
                 break;
             }
         }
         // register if needed
         if (!alreadyRegistered) {
             verbose("Register FailureRecorder (@" + this.hashCode() + ") as BuildListener");
             project.addBuildListener(this);
         }
     }
 
     // ===== JUnitResultFormatter =====
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void endTestSuite(JUnitTest suite) throws BuildException {
     }
 
     /**
      * Add the failed test to the list.
      * @param test the test that errored.
      * @param throwable the reason it errored.
      * @see junit.framework.TestListener#addError(junit.framework.Test, java.lang.Throwable)
      */
     public void addError(Test test, Throwable throwable) {
         failedTests.add(new TestInfos(test));
     }
 
     // CheckStyle:LineLengthCheck OFF - @see is long
     /**
      * Add the failed test to the list.
      * @param test the test that failed.
      * @param error the assertion that failed.
      * @see junit.framework.TestListener#addFailure(junit.framework.Test, junit.framework.AssertionFailedError)
      */
     // CheckStyle:LineLengthCheck ON
     public void addFailure(Test test, AssertionFailedError error) {
         failedTests.add(new TestInfos(test));
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void setOutput(OutputStream out) {
         // unused, close output file so it can be deleted before the VM exits
         if (out != System.out) {
             FileUtils.close(out);
         }
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void setSystemError(String err) {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void setSystemOutput(String out) {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void startTestSuite(JUnitTest suite) throws BuildException {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void endTest(Test test) {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void startTest(Test test) {
     }
 
     // ===== "Templates" for generating the JUnit class =====
 
     private void writeJavaClass() {
         try {
             File sourceFile = new File((getLocationName() + ".java"));
             verbose("Write collector class to '" + sourceFile.getAbsolutePath() + "'");
 
             if (sourceFile.exists() && !sourceFile.delete()) {
                 throw new IOException("could not delete " + sourceFile);
             }
             writer = new BufferedWriter(new FileWriter(sourceFile));
 
             createClassHeader();
             createSuiteMethod();
             createClassFooter();
 
         } catch (IOException e) {
             e.printStackTrace();
         } finally {
             FileUtils.close(writer);
         }
     }
 
     private void createClassHeader() throws IOException {
         String className = getLocationName().replace('\\', '/');
         if (className.indexOf('/') > -1) {
             className = className.substring(className.lastIndexOf('/') + 1);
         }
         SimpleDateFormat sdf = new SimpleDateFormat("yyyy.MM.dd HH:mm:ss,SSS");
         writer.write("// generated on: ");
         writer.write(sdf.format(new Date()));
         writer.newLine();
         writer.write("import junit.framework.*;");
         writer.newLine();
         writer.write("public class ");
         writer.write(className);
-        // If this class does not extend TC, Ant doesnt run these
+        // If this class does not extend TC, Ant doesn't run these
         writer.write(" extends TestCase {");
         writer.newLine();
         // standard String-constructor
         writer.write("    public ");
         writer.write(className);
         writer.write("(String testname) {");
         writer.newLine();
         writer.write("        super(testname);");
         writer.newLine();
         writer.write("    }");
         writer.newLine();
     }
 
     private void createSuiteMethod() throws IOException {
         writer.write("    public static Test suite() {");
         writer.newLine();
         writer.write("        TestSuite suite = new TestSuite();");
         writer.newLine();
         for (Iterator iter = failedTests.iterator(); iter.hasNext();) {
             TestInfos testInfos = (TestInfos) iter.next();
             writer.write("        suite.addTest(");
             writer.write(String.valueOf(testInfos));
             writer.write(");");
             writer.newLine();
         }
         writer.write("        return suite;");
         writer.newLine();
         writer.write("    }");
         writer.newLine();
     }
 
     private void createClassFooter() throws IOException {
         writer.write("}");
         writer.newLine();
     }
 
     // ===== Helper classes and methods =====
 
     /**
      * Logging facade in INFO-mode.
      * @param message Log-message
      */
     public void log(String message) {
         getProject().log(LOG_PREFIX + " " + message, Project.MSG_INFO);
     }
 
     /**
      * Logging facade in VERBOSE-mode.
      * @param message Log-message
      */
     public void verbose(String message) {
         getProject().log(LOG_PREFIX + " " + message, Project.MSG_VERBOSE);
     }
 
     /**
      * TestInfos holds information about a given test for later use.
      */
     public static class TestInfos implements Comparable {
 
         /** The class name of the test. */
         private final String className;
 
         /** The method name of the testcase. */
         private final String methodName;
 
         /**
          * This constructor extracts the needed information from the given test.
          * @param test Test to analyze
          */
         public TestInfos(Test test) {
             className = test.getClass().getName();
             String _methodName = test.toString();
             methodName = _methodName.substring(0, _methodName.indexOf('('));
         }
 
         /**
          * This String-Representation can directly be used for instantiation of
          * the JUnit testcase.
          * @return the string representation.
          * @see java.lang.Object#toString()
          * @see FailureRecorder#createSuiteMethod()
          */
         public String toString() {
             return "new " + className + "(\"" + methodName + "\")";
         }
 
         /**
          * The SortedMap needs comparable elements.
          * @param other the object to compare to.
          * @return the result of the comparison.
          * @see java.lang.Comparable#compareTo
          * @see SortedSet#comparator()
          */
         public int compareTo(Object other) {
             if (other instanceof TestInfos) {
                 TestInfos otherInfos = (TestInfos) other;
                 return toString().compareTo(otherInfos.toString());
             } else {
                 return -1;
             }
         }
         public boolean equals(Object obj) {
             return obj instanceof TestInfos && toString().equals(obj.toString());
         }
         public int hashCode() {
             return toString().hashCode();
         }
     }
 
     // ===== BuildListener =====
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void buildFinished(BuildEvent event) {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void buildStarted(BuildEvent event) {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void messageLogged(BuildEvent event) {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void targetFinished(BuildEvent event) {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void targetStarted(BuildEvent event) {
     }
 
     /**
      * The task outside of this JUnitResultFormatter is the <junit> task. So all tests passed
      * and we could create the new java class.
      * @param event  not used
      * @see org.apache.tools.ant.BuildListener#taskFinished(org.apache.tools.ant.BuildEvent)
      */
     public void taskFinished(BuildEvent event) {
         if (!failedTests.isEmpty()) {
             writeJavaClass();
         }
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void taskStarted(BuildEvent event) {
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/net/FTP.java b/src/main/org/apache/tools/ant/taskdefs/optional/net/FTP.java
index 44f50b0d4..cef9dda0f 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/net/FTP.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/net/FTP.java
@@ -1,2725 +1,2725 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.net;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.text.SimpleDateFormat;
 import java.util.Collection;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.Vector;
 
 import org.apache.commons.net.ftp.FTPClient;
 import org.apache.commons.net.ftp.FTPClientConfig;
 import org.apache.commons.net.ftp.FTPFile;
 import org.apache.commons.net.ftp.FTPReply;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.taskdefs.Delete;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.selectors.SelectorUtils;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.RetryHandler;
 import org.apache.tools.ant.util.Retryable;
 import org.apache.tools.ant.util.VectorSet;
 
 /**
  * Basic FTP client. Performs the following actions:
  * <ul>
  *   <li> <strong>send</strong> - send files to a remote server. This is the
  *   default action.</li>
  *   <li> <strong>get</strong> - retrieve files from a remote server.</li>
  *   <li> <strong>del</strong> - delete files from a remote server.</li>
  *   <li> <strong>list</strong> - create a file listing.</li>
  *   <li> <strong>chmod</strong> - change unix file permissions.</li>
  *   <li> <strong>rmdir</strong> - remove directories, if empty, from a
  *   remote server.</li>
  * </ul>
  * <strong>Note:</strong> Some FTP servers - notably the Solaris server - seem
  * to hold data ports open after a "retr" operation, allowing them to timeout
  * instead of shutting them down cleanly. This happens in active or passive
  * mode, and the ports will remain open even after ending the FTP session. FTP
  * "send" operations seem to close ports immediately. This behavior may cause
  * problems on some systems when downloading large sets of files.
  *
  * @since Ant 1.3
  */
 public class FTP extends Task implements FTPTaskConfig {
     protected static final int SEND_FILES = 0;
     protected static final int GET_FILES = 1;
     protected static final int DEL_FILES = 2;
     protected static final int LIST_FILES = 3;
     protected static final int MK_DIR = 4;
     protected static final int CHMOD = 5;
     protected static final int RM_DIR = 6;
     protected static final int SITE_CMD = 7;
     /** return code of ftp */
     private static final int CODE_521 = 521;
     private static final int CODE_550 = 550;
     private static final int CODE_553 = 553;
 
     /** adjust uptodate calculations where server timestamps are HH:mm and client's
      * are HH:mm:ss */
     private static final long GRANULARITY_MINUTE = 60000L;
 
     /** Date formatter used in logging, note not thread safe! */
     private static final SimpleDateFormat TIMESTAMP_LOGGING_SDF =
         new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
 
     /** Default port for FTP */
     public static final int DEFAULT_FTP_PORT = 21;
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     private String remotedir;
     private String server;
     private String userid;
     private String password;
     private String account;
     private File listing;
     private boolean binary = true;
     private boolean passive = false;
     private boolean verbose = false;
     private boolean newerOnly = false;
     private long timeDiffMillis = 0;
     private long granularityMillis = 0L;
     private boolean timeDiffAuto = false;
     private int action = SEND_FILES;
     private Vector filesets = new Vector();
     private Set dirCache = new HashSet();
     private int transferred = 0;
     private String remoteFileSep = "/";
     private int port = DEFAULT_FTP_PORT;
     private boolean skipFailedTransfers = false;
     private int skipped = 0;
     private boolean ignoreNoncriticalErrors = false;
     private boolean preserveLastModified = false;
     private String chmod = null;
     private String umask = null;
     private FTPSystemType systemTypeKey = FTPSystemType.getDefault();
     private String defaultDateFormatConfig = null;
     private String recentDateFormatConfig = null;
     private LanguageCode serverLanguageCodeConfig = LanguageCode.getDefault();
     private String serverTimeZoneConfig = null;
     private String shortMonthNamesConfig = null;
     private Granularity timestampGranularity = Granularity.getDefault();
     private boolean isConfigurationSet = false;
     private int retriesAllowed = 0;
     private String siteCommand = null;
     private String initialSiteCommand = null;
     private boolean enableRemoteVerification = true;
 
     protected static final String[] ACTION_STRS = {
         "sending",
         "getting",
         "deleting",
         "listing",
         "making directory",
         "chmod",
         "removing",
         "site"
     };
 
     protected static final String[] COMPLETED_ACTION_STRS = {
         "sent",
         "retrieved",
         "deleted",
         "listed",
         "created directory",
         "mode changed",
         "removed",
         "site command executed"
     };
 
     protected static final String[] ACTION_TARGET_STRS = {
         "files",
         "files",
         "files",
         "files",
         "directory",
         "files",
         "directories",
         "site command"
     };
 
     /**
      * internal class providing a File-like interface to some of the information
      * available from the FTP server
      *
      */
     protected static class FTPFileProxy extends File {
 
         private final FTPFile file;
         private final String[] parts;
         private final String name;
 
         /**
          * creates a proxy to a FTP file
          * @param file
          */
         public FTPFileProxy(FTPFile file) {
             super(file.getName());
             name = file.getName();
             this.file = file;
             parts = FileUtils.getPathStack(name);
         }
 
         /**
          * creates a proxy to a FTP directory
          * @param completePath the remote directory.
          */
         public FTPFileProxy(String completePath) {
             super(completePath);
             file = null;
             name = completePath;
             parts = FileUtils.getPathStack(completePath);
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#exists()
          */
         public boolean exists() {
             return true;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getAbsolutePath()
          */
         public String getAbsolutePath() {
             return name;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getName()
          */
         public String getName() {
             return parts.length > 0 ? parts[parts.length - 1] : name;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getParent()
          */
         public String getParent() {
             String result = "";
             for(int i = 0; i < parts.length - 1; i++){
                 result += File.separatorChar + parts[i];
             }
             return result;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getPath()
          */
         public String getPath() {
             return name;
         }
 
 
         /**
          * FTP files are stored as absolute paths
          * @return true
          */
         public boolean isAbsolute() {
             return true;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#isDirectory()
          */
         public boolean isDirectory() {
             return file == null;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#isFile()
          */
         public boolean isFile() {
             return file != null;
         }
 
 
         /**
          * FTP files cannot be hidden
          *
          * @return  false
          */
         public boolean isHidden() {
             return false;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#lastModified()
          */
         public long lastModified() {
             if (file != null) {
                 return file.getTimestamp().getTimeInMillis();
             }
             return 0;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#length()
          */
         public long length() {
             if (file != null) {
                 return file.getSize();
             }
             return 0;
         }
     }
 
     /**
      * internal class allowing to read the contents of a remote file system
      * using the FTP protocol
      * used in particular for ftp get operations
      * differences with DirectoryScanner
      * "" (the root of the fileset) is never included in the included directories
      * followSymlinks defaults to false
      */
     protected class FTPDirectoryScanner extends DirectoryScanner {
         // CheckStyle:VisibilityModifier OFF - bc
         protected FTPClient ftp = null;
         // CheckStyle:VisibilityModifier ON
 
         private String rootPath = null;
 
         /**
          * since ant 1.6
          * this flag should be set to true on UNIX and can save scanning time
          */
         private boolean remoteSystemCaseSensitive = false;
         private boolean remoteSensitivityChecked = false;
 
         /**
          * constructor
          * @param ftp  ftpclient object
          */
         public FTPDirectoryScanner(FTPClient ftp) {
             super();
             this.ftp = ftp;
             this.setFollowSymlinks(false);
         }
 
 
         /**
          * scans the remote directory,
          * storing internally the included files, directories, ...
          */
         public void scan() {
             if (includes == null) {
                 // No includes supplied, so set it to 'matches all'
                 includes = new String[1];
                 includes[0] = "**";
             }
             if (excludes == null) {
                 excludes = new String[0];
             }
 
             filesIncluded = new VectorSet();
             filesNotIncluded = new Vector();
             filesExcluded = new VectorSet();
             dirsIncluded = new VectorSet();
             dirsNotIncluded = new Vector();
             dirsExcluded = new VectorSet();
 
             try {
                 String cwd = ftp.printWorkingDirectory();
                 // always start from the current ftp working dir
                 forceRemoteSensitivityCheck();
 
                 checkIncludePatterns();
                 clearCaches();
                 ftp.changeWorkingDirectory(cwd);
             } catch (IOException e) {
                 throw new BuildException("Unable to scan FTP server: ", e);
             }
         }
 
 
         /**
          * this routine is actually checking all the include patterns in
          * order to avoid scanning everything under base dir
          * @since ant1.6
          */
         private void checkIncludePatterns() {
 
             Hashtable newroots = new Hashtable();
             // put in the newroots vector the include patterns without
             // wildcard tokens
             for (int icounter = 0; icounter < includes.length; icounter++) {
                 String newpattern =
                     SelectorUtils.rtrimWildcardTokens(includes[icounter]);
                 newroots.put(newpattern, includes[icounter]);
             }
             if (remotedir == null) {
                 try {
                     remotedir = ftp.printWorkingDirectory();
                 } catch (IOException e) {
                     throw new BuildException("could not read current ftp directory",
                                              getLocation());
                 }
             }
             AntFTPFile baseFTPFile = new AntFTPRootFile(ftp, remotedir);
             rootPath = baseFTPFile.getAbsolutePath();
             // construct it
             if (newroots.containsKey("")) {
                 // we are going to scan everything anyway
                 scandir(rootPath, "", true);
             } else {
                 // only scan directories that can include matched files or
                 // directories
                 Enumeration enum2 = newroots.keys();
 
                 while (enum2.hasMoreElements()) {
                     String currentelement = (String) enum2.nextElement();
                     String originalpattern = (String) newroots.get(currentelement);
                     AntFTPFile myfile = new AntFTPFile(baseFTPFile, currentelement);
                     boolean isOK = true;
                     boolean traversesSymlinks = false;
                     String path = null;
 
                     if (myfile.exists()) {
                         forceRemoteSensitivityCheck();
                         if (remoteSensitivityChecked
                             && remoteSystemCaseSensitive && isFollowSymlinks()) {
                             // cool case,
                             //we do not need to scan all the subdirs in the relative path
                             path = myfile.getFastRelativePath();
                         } else {
                             // may be on a case insensitive file system.  We want
                             // the results to show what's really on the disk, so
                             // we need to double check.
                             try {
                                 path = myfile.getRelativePath();
                                 traversesSymlinks = myfile.isTraverseSymlinks();
                             }  catch (IOException be) {
                                 throw new BuildException(be, getLocation());
                             } catch (BuildException be) {
                                 isOK = false;
                             }
                         }
                     } else {
                         isOK = false;
                     }
                     if (isOK) {
                         currentelement = path.replace(remoteFileSep.charAt(0), File.separatorChar);
                         if (!isFollowSymlinks()
                             && traversesSymlinks) {
                             continue;
                         }
 
                         if (myfile.isDirectory()) {
                             if (isIncluded(currentelement)
                                 && currentelement.length() > 0) {
                                 accountForIncludedDir(currentelement, myfile, true);
                             }  else {
                                 if (currentelement.length() > 0) {
                                     if (currentelement.charAt(currentelement
                                                               .length() - 1)
                                         != File.separatorChar) {
                                         currentelement =
                                             currentelement + File.separatorChar;
                                     }
                                 }
                                 scandir(myfile.getAbsolutePath(), currentelement, true);
                             }
                         } else {
                             if (isCaseSensitive
                                 && originalpattern.equals(currentelement)) {
                                 accountForIncludedFile(currentelement);
                             } else if (!isCaseSensitive
                                        && originalpattern
                                        .equalsIgnoreCase(currentelement)) {
                                 accountForIncludedFile(currentelement);
                             }
                         }
                     }
                 }
             }
         }
         /**
          * scans a particular directory. populates the scannedDirs cache.
          *
          * @param dir directory to scan
          * @param vpath  relative path to the base directory of the remote fileset
          * always ended with a File.separator
          * @param fast seems to be always true in practice
          */
         protected void scandir(String dir, String vpath, boolean fast) {
             // avoid double scanning of directories, can only happen in fast mode
             if (fast && hasBeenScanned(vpath)) {
                 return;
             }
             try {
                 if (!ftp.changeWorkingDirectory(dir)) {
                     return;
                 }
                 String completePath = null;
                 if (!vpath.equals("")) {
                     completePath = rootPath + remoteFileSep
                         + vpath.replace(File.separatorChar, remoteFileSep.charAt(0));
                 } else {
                     completePath = rootPath;
                 }
                 FTPFile[] newfiles = listFiles(completePath, false);
 
                 if (newfiles == null) {
                     ftp.changeToParentDirectory();
                     return;
                 }
                 for (int i = 0; i < newfiles.length; i++) {
                     FTPFile file = newfiles[i];
                     if (file != null
                         && !file.getName().equals(".")
                         && !file.getName().equals("..")) {
                         String name = vpath + file.getName();
                         scannedDirs.put(name, new FTPFileProxy(file));
                         if (isFunctioningAsDirectory(ftp, dir, file)) {
                             boolean slowScanAllowed = true;
                             if (!isFollowSymlinks() && file.isSymbolicLink()) {
                                 dirsExcluded.addElement(name);
                                 slowScanAllowed = false;
                             } else if (isIncluded(name)) {
                                 accountForIncludedDir(name,
                                                       new AntFTPFile(ftp, file, completePath) , fast);
                             } else {
                                 dirsNotIncluded.addElement(name);
                                 if (fast && couldHoldIncluded(name)) {
                                     scandir(file.getName(),
                                             name + File.separator, fast);
                                 }
                             }
                             if (!fast && slowScanAllowed) {
                                 scandir(file.getName(),
                                         name + File.separator, fast);
                             }
                         } else {
                             if (!isFollowSymlinks() && file.isSymbolicLink()) {
                                 filesExcluded.addElement(name);
                             } else if (isFunctioningAsFile(ftp, dir, file)) {
                                 accountForIncludedFile(name);
                             }
                         }
                     }
                 }
                 ftp.changeToParentDirectory();
             } catch (IOException e) {
                 throw new BuildException("Error while communicating with FTP "
                                          + "server: ", e);
             }
         }
         /**
          * process included file
          * @param name  path of the file relative to the directory of the fileset
          */
         private void accountForIncludedFile(String name) {
             if (!filesIncluded.contains(name)
                 && !filesExcluded.contains(name)) {
 
                 if (isIncluded(name)) {
                     if (!isExcluded(name)
                         && isSelected(name, (File) scannedDirs.get(name))) {
                         filesIncluded.addElement(name);
                     } else {
                         filesExcluded.addElement(name);
                     }
                 } else {
                     filesNotIncluded.addElement(name);
                 }
             }
         }
 
         /**
          *
          * @param name path of the directory relative to the directory of
          * the fileset
          * @param file directory as file
          * @param fast
          */
         private void accountForIncludedDir(String name, AntFTPFile file, boolean fast) {
             if (!dirsIncluded.contains(name)
                 && !dirsExcluded.contains(name)) {
 
                 if (!isExcluded(name)) {
                     if (fast) {
                         if (file.isSymbolicLink()) {
                             try {
                                 file.getClient().changeWorkingDirectory(file.curpwd);
                             } catch (IOException ioe) {
                                 throw new BuildException("could not change directory to curpwd");
                             }
                             scandir(file.getLink(),
                                     name + File.separator, fast);
                         } else {
                             try {
                                 file.getClient().changeWorkingDirectory(file.curpwd);
                             } catch (IOException ioe) {
                                 throw new BuildException("could not change directory to curpwd");
                             }
                             scandir(file.getName(),
                                     name + File.separator, fast);
                         }
                     }
                     dirsIncluded.addElement(name);
                 } else {
                     dirsExcluded.addElement(name);
                     if (fast && couldHoldIncluded(name)) {
                         try {
                             file.getClient().changeWorkingDirectory(file.curpwd);
                         } catch (IOException ioe) {
                             throw new BuildException("could not change directory to curpwd");
                         }
                         scandir(file.getName(),
                                 name + File.separator, fast);
                     }
                 }
             }
         }
         /**
          * temporary table to speed up the various scanning methods below
          *
          * @since Ant 1.6
          */
         private Map fileListMap = new HashMap();
         /**
          * List of all scanned directories.
          *
          * @since Ant 1.6
          */
 
         private Map scannedDirs = new HashMap();
 
         /**
          * Has the directory with the given path relative to the base
          * directory already been scanned?
          *
          * @since Ant 1.6
          */
         private boolean hasBeenScanned(String vpath) {
             return scannedDirs.containsKey(vpath);
         }
 
         /**
          * Clear internal caches.
          *
          * @since Ant 1.6
          */
         private void clearCaches() {
             fileListMap.clear();
             scannedDirs.clear();
         }
         /**
          * list the files present in one directory.
          * @param directory full path on the remote side
          * @param changedir if true change to directory directory before listing
          * @return array of FTPFile
          */
         public FTPFile[] listFiles(String directory, boolean changedir) {
             //getProject().log("listing files in directory " + directory, Project.MSG_DEBUG);
             String currentPath = directory;
             if (changedir) {
                 try {
                     boolean result = ftp.changeWorkingDirectory(directory);
                     if (!result) {
                         return null;
                     }
                     currentPath = ftp.printWorkingDirectory();
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, getLocation());
                 }
             }
             if (fileListMap.containsKey(currentPath)) {
                 getProject().log("filelist map used in listing files", Project.MSG_DEBUG);
                 return ((FTPFile[]) fileListMap.get(currentPath));
             }
             FTPFile[] result = null;
             try {
                 result = ftp.listFiles();
             } catch (IOException ioe) {
                 throw new BuildException(ioe, getLocation());
             }
             fileListMap.put(currentPath, result);
             if (!remoteSensitivityChecked) {
                 checkRemoteSensitivity(result, directory);
             }
             return result;
         }
 
         private void forceRemoteSensitivityCheck() {
             if (!remoteSensitivityChecked) {
                 try {
                     checkRemoteSensitivity(ftp.listFiles(), ftp.printWorkingDirectory());
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, getLocation());
                 }
             }
         }
         /**
          * cd into one directory and
          * list the files present in one directory.
          * @param directory full path on the remote side
          * @return array of FTPFile
          */
         public FTPFile[] listFiles(String directory) {
             return listFiles(directory, true);
         }
         private void checkRemoteSensitivity(FTPFile[] array, String directory) {
             if (array == null) {
                 return;
             }
             boolean candidateFound = false;
             String target = null;
             for (int icounter = 0; icounter < array.length; icounter++) {
                 if (array[icounter] != null && array[icounter].isDirectory()) {
                     if (!array[icounter].getName().equals(".")
                         && !array[icounter].getName().equals("..")) {
                         candidateFound = true;
                         target = fiddleName(array[icounter].getName());
                         getProject().log("will try to cd to "
                                          + target + " where a directory called " + array[icounter].getName()
                                          + " exists", Project.MSG_DEBUG);
                         for (int pcounter = 0; pcounter < array.length; pcounter++) {
                             if (array[pcounter] != null
                                 && pcounter != icounter
                                 && target.equals(array[pcounter].getName())) {
                                 candidateFound = false;
                                 break;
                             }
                         }
                         if (candidateFound) {
                             break;
                         }
                     }
                 }
             }
             if (candidateFound) {
                 try {
                     getProject().log("testing case sensitivity, attempting to cd to "
                                      + target, Project.MSG_DEBUG);
                     remoteSystemCaseSensitive  = !ftp.changeWorkingDirectory(target);
                 } catch (IOException ioe) {
                     remoteSystemCaseSensitive = true;
                 } finally {
                     try {
                         ftp.changeWorkingDirectory(directory);
                     } catch (IOException ioe) {
                         throw new BuildException(ioe, getLocation());
                     }
                 }
                 getProject().log("remote system is case sensitive : " + remoteSystemCaseSensitive,
                                  Project.MSG_VERBOSE);
                 remoteSensitivityChecked = true;
             }
         }
         private String fiddleName(String origin) {
             StringBuffer result = new StringBuffer();
             for (int icounter = 0; icounter < origin.length(); icounter++) {
                 if (Character.isLowerCase(origin.charAt(icounter))) {
                     result.append(Character.toUpperCase(origin.charAt(icounter)));
                 } else if (Character.isUpperCase(origin.charAt(icounter))) {
                     result.append(Character.toLowerCase(origin.charAt(icounter)));
                 } else {
                     result.append(origin.charAt(icounter));
                 }
             }
             return result.toString();
         }
         /**
          * an AntFTPFile is a representation of a remote file
          * @since Ant 1.6
          */
         protected class AntFTPFile {
             /**
              * ftp client
              */
             private FTPClient client;
             /**
              * parent directory of the file
              */
             private String curpwd;
             /**
              * the file itself
              */
             private FTPFile ftpFile;
             /**
              *
              */
             private AntFTPFile parent = null;
             private boolean relativePathCalculated = false;
             private boolean traversesSymlinks = false;
             private String relativePath = "";
             /**
              * constructor
              * @param client ftp client variable
              * @param ftpFile the file
              * @param curpwd absolute remote path where the file is found
              */
             public AntFTPFile(FTPClient client, FTPFile ftpFile, String curpwd) {
                 this.client = client;
                 this.ftpFile = ftpFile;
                 this.curpwd = curpwd;
             }
             /**
              * other constructor
              * @param parent the parent file
              * @param path  a relative path to the parent file
              */
             public AntFTPFile(AntFTPFile parent, String path) {
                 this.parent = parent;
                 this.client = parent.client;
                 Vector pathElements = SelectorUtils.tokenizePath(path);
                 try {
                     boolean result = this.client.changeWorkingDirectory(parent.getAbsolutePath());
                     //this should not happen, except if parent has been deleted by another process
                     if (!result) {
                         return;
                     }
                     this.curpwd = parent.getAbsolutePath();
                 } catch (IOException ioe) {
                     throw new BuildException("could not change working dir to "
                                              + parent.curpwd);
                 }
                 final int size = pathElements.size();
                 for (int fcount = 0; fcount < size - 1; fcount++) {
                     String currentPathElement = (String) pathElements.elementAt(fcount);
                     try {
                         boolean result = this.client.changeWorkingDirectory(currentPathElement);
                         if (!result && !isCaseSensitive()
                             && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) {
                             currentPathElement = findPathElementCaseUnsensitive(this.curpwd,
                                                                                 currentPathElement);
                             if (currentPathElement == null) {
                                 return;
                             }
                         } else if (!result) {
                             return;
                         }
                         this.curpwd = getCurpwdPlusFileSep()
                             + currentPathElement;
                     } catch (IOException ioe) {
                         throw new BuildException("could not change working dir to "
                                                  + (String) pathElements.elementAt(fcount)
                                                  + " from " + this.curpwd);
                     }
 
                 }
                 String lastpathelement = (String) pathElements.elementAt(size - 1);
                 FTPFile [] theFiles = listFiles(this.curpwd);
                 this.ftpFile = getFile(theFiles, lastpathelement);
             }
             /**
              * find a file in a directory in case unsensitive way
              * @param parentPath        where we are
              * @param soughtPathElement what is being sought
              * @return                  the first file found or null if not found
              */
             private String findPathElementCaseUnsensitive(String parentPath,
                                                           String soughtPathElement) {
                 // we are already in the right path, so the second parameter
                 // is false
                 FTPFile[] theFiles = listFiles(parentPath, false);
                 if (theFiles == null) {
                     return null;
                 }
                 for (int icounter = 0; icounter < theFiles.length; icounter++) {
                     if (theFiles[icounter] != null
                         && theFiles[icounter].getName().equalsIgnoreCase(soughtPathElement)) {
                         return theFiles[icounter].getName();
                     }
                 }
                 return null;
             }
             /**
              * find out if the file exists
              * @return  true if the file exists
              */
             public boolean exists() {
                 return (ftpFile != null);
             }
             /**
              * if the file is a symbolic link, find out to what it is pointing
              * @return the target of the symbolic link
              */
             public String getLink() {
                 return ftpFile.getLink();
             }
             /**
              * get the name of the file
              * @return the name of the file
              */
             public String getName() {
                 return ftpFile.getName();
             }
             /**
              * find out the absolute path of the file
              * @return absolute path as string
              */
             public String getAbsolutePath() {
                 return getCurpwdPlusFileSep() + ftpFile.getName();
             }
             /**
              * find out the relative path assuming that the path used to construct
              * this AntFTPFile was spelled properly with regards to case.
              * This is OK on a case sensitive system such as UNIX
              * @return relative path
              */
             public String getFastRelativePath() {
                 String absPath = getAbsolutePath();
                 if (absPath.startsWith(rootPath + remoteFileSep)) {
                     return absPath.substring(rootPath.length() + remoteFileSep.length());
                 }
                 return null;
             }
             /**
              * find out the relative path to the rootPath of the enclosing scanner.
              * this relative path is spelled exactly like on disk,
              * for instance if the AntFTPFile has been instantiated as ALPHA,
              * but the file is really called alpha, this method will return alpha.
              * If a symbolic link is encountered, it is followed, but the name of the link
              * rather than the name of the target is returned.
              * (ie does not behave like File.getCanonicalPath())
              * @return                relative path, separated by remoteFileSep
              * @throws IOException    if a change directory fails, ...
              * @throws BuildException if one of the components of the relative path cannot
              * be found.
              */
             public String getRelativePath() throws IOException, BuildException {
                 if (!relativePathCalculated) {
                     if (parent != null) {
                         traversesSymlinks = parent.isTraverseSymlinks();
                         relativePath = getRelativePath(parent.getAbsolutePath(),
                                                        parent.getRelativePath());
                     } else {
                         relativePath = getRelativePath(rootPath, "");
                         relativePathCalculated = true;
                     }
                 }
                 return relativePath;
             }
             /**
-             * get thge relative path of this file
+             * get the relative path of this file
              * @param currentPath          base path
              * @param currentRelativePath  relative path of the base path with regards to remote dir
              * @return relative path
              */
             private String getRelativePath(String currentPath, String currentRelativePath) {
                 Vector pathElements = SelectorUtils.tokenizePath(getAbsolutePath(), remoteFileSep);
                 Vector pathElements2 = SelectorUtils.tokenizePath(currentPath, remoteFileSep);
                 String relPath = currentRelativePath;
                 final int size = pathElements.size();
                 for (int pcount = pathElements2.size(); pcount < size; pcount++) {
                     String currentElement = (String) pathElements.elementAt(pcount);
                     FTPFile[] theFiles = listFiles(currentPath);
                     FTPFile theFile = null;
                     if (theFiles != null) {
                         theFile = getFile(theFiles, currentElement);
                     }
                     if (!relPath.equals("")) {
                         relPath = relPath + remoteFileSep;
                     }
                     if (theFile == null) {
                         // hit a hidden file assume not a symlink
                         relPath = relPath + currentElement;
                         currentPath = currentPath + remoteFileSep + currentElement;
                         log("Hidden file " + relPath
                             + " assumed to not be a symlink.",
                             Project.MSG_VERBOSE);
                     } else {
                         traversesSymlinks = traversesSymlinks || theFile.isSymbolicLink();
                         relPath = relPath + theFile.getName();
                         currentPath = currentPath + remoteFileSep + theFile.getName();
                     }
                 }
                 return relPath;
             }
             /**
              * find a file matching a string in an array of FTPFile.
              * This method will find "alpha" when requested for "ALPHA"
              * if and only if the caseSensitive attribute is set to false.
              * When caseSensitive is set to true, only the exact match is returned.
              * @param theFiles  array of files
              * @param lastpathelement  the file name being sought
              * @return null if the file cannot be found, otherwise return the matching file.
              */
             public FTPFile getFile(FTPFile[] theFiles, String lastpathelement) {
                 if (theFiles == null) {
                     return null;
                 }
                 for (int fcount = 0; fcount < theFiles.length; fcount++) {
                     if (theFiles[fcount] != null) {
                         if (theFiles[fcount].getName().equals(lastpathelement)) {
                             return theFiles[fcount];
                         } else if (!isCaseSensitive()
                                    && theFiles[fcount].getName().equalsIgnoreCase(
                                                                                   lastpathelement)) {
                             return theFiles[fcount];
                         }
                     }
                 }
                 return null;
             }
             /**
              * tell if a file is a directory.
              * note that it will return false for symbolic links pointing to directories.
              * @return <code>true</code> for directories
              */
             public boolean isDirectory() {
                 return ftpFile.isDirectory();
             }
             /**
              * tell if a file is a symbolic link
              * @return <code>true</code> for symbolic links
              */
             public boolean isSymbolicLink() {
                 return ftpFile.isSymbolicLink();
             }
             /**
              * return the attached FTP client object.
              * Warning : this instance is really shared with the enclosing class.
              * @return  FTP client
              */
             protected FTPClient getClient() {
                 return client;
             }
 
             /**
              * sets the current path of an AntFTPFile
              * @param curpwd the current path one wants to set
              */
             protected void setCurpwd(String curpwd) {
                 this.curpwd = curpwd;
             }
             /**
              * returns the path of the directory containing the AntFTPFile.
              * of the full path of the file itself in case of AntFTPRootFile
              * @return parent directory of the AntFTPFile
              */
             public String getCurpwd() {
                 return curpwd;
             }
             /**
              * returns the path of the directory containing the AntFTPFile.
              * of the full path of the file itself in case of AntFTPRootFile
              * and appends the remote file separator if necessary.
              * @return parent directory of the AntFTPFile
              * @since Ant 1.8.2
              */
             public String getCurpwdPlusFileSep() {
                 return curpwd.endsWith(remoteFileSep) ? curpwd
                     : curpwd + remoteFileSep;
             }
             /**
              * find out if a symbolic link is encountered in the relative path of this file
              * from rootPath.
              * @return <code>true</code> if a symbolic link is encountered in the relative path.
              * @throws IOException if one of the change directory or directory listing operations
              * fails
              * @throws BuildException if a path component in the relative path cannot be found.
              */
             public boolean isTraverseSymlinks() throws IOException, BuildException {
                 if (!relativePathCalculated) {
                     // getRelativePath also finds about symlinks
                     getRelativePath();
                 }
                 return traversesSymlinks;
             }
 
             /**
              * Get a string rep of this object.
              * @return a string containing the pwd and the file.
              */
             public String toString() {
                 return "AntFtpFile: " + curpwd + "%" + ftpFile;
             }
         }
         /**
          * special class to represent the remote directory itself
          * @since Ant 1.6
          */
         protected class AntFTPRootFile extends AntFTPFile {
             private String remotedir;
             /**
              * constructor
              * @param aclient FTP client
              * @param remotedir remote directory
              */
             public AntFTPRootFile(FTPClient aclient, String remotedir) {
                 super(aclient, null, remotedir);
                 this.remotedir = remotedir;
                 try {
                     this.getClient().changeWorkingDirectory(this.remotedir);
                     this.setCurpwd(this.getClient().printWorkingDirectory());
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, getLocation());
                 }
             }
             /**
              * find the absolute path
              * @return absolute path
              */
             public String getAbsolutePath() {
                 return this.getCurpwd();
             }
             /**
              * find out the relative path to root
              * @return empty string
              * @throws BuildException actually never
              * @throws IOException  actually never
              */
             public String getRelativePath() throws BuildException, IOException {
                 return "";
             }
         }
     }
     /**
      * check FTPFiles to check whether they function as directories too
      * the FTPFile API seem to make directory and symbolic links incompatible
      * we want to find out if we can cd to a symbolic link
      * @param dir  the parent directory of the file to test
      * @param file the file to test
      * @return true if it is possible to cd to this directory
      * @since ant 1.6
      */
     private boolean isFunctioningAsDirectory(FTPClient ftp, String dir, FTPFile file) {
         boolean result = false;
         String currentWorkingDir = null;
         if (file.isDirectory()) {
             return true;
         } else if (file.isFile()) {
             return false;
         }
         try {
             currentWorkingDir = ftp.printWorkingDirectory();
         } catch (IOException ioe) {
             getProject().log("could not find current working directory " + dir
                              + " while checking a symlink",
                              Project.MSG_DEBUG);
         }
         if (currentWorkingDir != null) {
             try {
                 result = ftp.changeWorkingDirectory(file.getLink());
             } catch (IOException ioe) {
                 getProject().log("could not cd to " + file.getLink() + " while checking a symlink",
                                  Project.MSG_DEBUG);
             }
             if (result) {
                 boolean comeback = false;
                 try {
                     comeback = ftp.changeWorkingDirectory(currentWorkingDir);
                 } catch (IOException ioe) {
                     getProject().log("could not cd back to " + dir + " while checking a symlink",
                                      Project.MSG_ERR);
                 } finally {
                     if (!comeback) {
                         throw new BuildException("could not cd back to " + dir
                                                  + " while checking a symlink");
                     }
                 }
             }
         }
         return result;
     }
     /**
      * check FTPFiles to check whether they function as directories too
      * the FTPFile API seem to make directory and symbolic links incompatible
      * we want to find out if we can cd to a symbolic link
      * @param dir  the parent directory of the file to test
      * @param file the file to test
      * @return true if it is possible to cd to this directory
      * @since ant 1.6
      */
     private boolean isFunctioningAsFile(FTPClient ftp, String dir, FTPFile file) {
         if (file.isDirectory()) {
             return false;
         } else if (file.isFile()) {
             return true;
         }
         return !isFunctioningAsDirectory(ftp, dir, file);
     }
     /**
      * Sets the remote directory where files will be placed. This may be a
      * relative or absolute path, and must be in the path syntax expected by
      * the remote server. No correction of path syntax will be performed.
      *
      * @param dir the remote directory name.
      */
     public void setRemotedir(String dir) {
         this.remotedir = dir;
     }
 
 
     /**
      * Sets the FTP server to send files to.
      *
      * @param server the remote server name.
      */
     public void setServer(String server) {
         this.server = server;
     }
 
 
     /**
      * Sets the FTP port used by the remote server.
      *
      * @param port the port on which the remote server is listening.
      */
     public void setPort(int port) {
         this.port = port;
     }
 
 
     /**
      * Sets the login user id to use on the specified server.
      *
      * @param userid remote system userid.
      */
     public void setUserid(String userid) {
         this.userid = userid;
     }
 
 
     /**
      * Sets the login password for the given user id.
      *
      * @param password the password on the remote system.
      */
     public void setPassword(String password) {
         this.password = password;
     }
 
     /**
      * Sets the login account to use on the specified server.
      *
      * @param pAccount the account name on remote system
      * @since Ant 1.7
      */
     public void setAccount(String pAccount) {
         this.account = pAccount;
     }
 
 
     /**
      * If true, uses binary mode, otherwise text mode (default is binary).
      *
      * @param binary if true use binary mode in transfers.
      */
     public void setBinary(boolean binary) {
         this.binary = binary;
     }
 
 
     /**
      * Specifies whether to use passive mode. Set to true if you are behind a
      * firewall and cannot connect without it. Passive mode is disabled by
      * default.
      *
      * @param passive true is passive mode should be used.
      */
     public void setPassive(boolean passive) {
         this.passive = passive;
     }
 
 
     /**
      * Set to true to receive notification about each file as it is
      * transferred.
      *
      * @param verbose true if verbose notifications are required.
      */
     public void setVerbose(boolean verbose) {
         this.verbose = verbose;
     }
 
 
     /**
      * A synonym for <tt>depends</tt>. Set to true to transmit only new
      * or changed files.
      *
      * See the related attributes timediffmillis and timediffauto.
      *
      * @param newer if true only transfer newer files.
      */
     public void setNewer(boolean newer) {
         this.newerOnly = newer;
     }
 
     /**
      * number of milliseconds to add to the time on the remote machine
      * to get the time on the local machine.
      *
      * use in conjunction with <code>newer</code>
      *
      * @param timeDiffMillis number of milliseconds
      *
      * @since ant 1.6
      */
     public void setTimeDiffMillis(long timeDiffMillis) {
         this.timeDiffMillis = timeDiffMillis;
     }
 
     /**
      * &quot;true&quot; to find out automatically the time difference
      * between local and remote machine.
      *
      * This requires right to create
      * and delete a temporary file in the remote directory.
      *
      * @param timeDiffAuto true = find automatically the time diff
      *
      * @since ant 1.6
      */
     public void setTimeDiffAuto(boolean timeDiffAuto) {
         this.timeDiffAuto = timeDiffAuto;
     }
 
     /**
      * Set to true to preserve modification times for "gotten" files.
      *
      * @param preserveLastModified if true preserver modification times.
      */
     public void setPreserveLastModified(boolean preserveLastModified) {
         this.preserveLastModified = preserveLastModified;
     }
 
 
     /**
      * Set to true to transmit only files that are new or changed from their
      * remote counterparts. The default is to transmit all files.
      *
      * @param depends if true only transfer newer files.
      */
     public void setDepends(boolean depends) {
         this.newerOnly = depends;
     }
 
 
     /**
      * Sets the remote file separator character. This normally defaults to the
      * Unix standard forward slash, but can be manually overridden using this
      * call if the remote server requires some other separator. Only the first
      * character of the string is used.
      *
      * @param separator the file separator on the remote system.
      */
     public void setSeparator(String separator) {
         remoteFileSep = separator;
     }
 
 
     /**
      * Sets the file permission mode (Unix only) for files sent to the
      * server.
      *
      * @param theMode unix style file mode for the files sent to the remote
      *        system.
      */
     public void setChmod(String theMode) {
         this.chmod = theMode;
     }
 
 
     /**
      * Sets the default mask for file creation on a unix server.
      *
      * @param theUmask unix style umask for files created on the remote server.
      */
     public void setUmask(String theUmask) {
         this.umask = theUmask;
     }
 
 
     /**
      *  A set of files to upload or download
      *
      * @param set the set of files to be added to the list of files to be
      *        transferred.
      */
     public void addFileset(FileSet set) {
         filesets.addElement(set);
     }
 
 
     /**
      * Sets the FTP action to be taken. Currently accepts "put", "get", "del",
      * "mkdir", "chmod", "list", and "site".
      *
      * @deprecated since 1.5.x.
      *             setAction(String) is deprecated and is replaced with
      *      setAction(FTP.Action) to make Ant's Introspection mechanism do the
      *      work and also to encapsulate operations on the type in its own
      *      class.
      * @ant.attribute ignore="true"
      *
      * @param action the FTP action to be performed.
      *
      * @throws BuildException if the action is not a valid action.
      */
     public void setAction(String action) throws BuildException {
         log("DEPRECATED - The setAction(String) method has been deprecated."
             + " Use setAction(FTP.Action) instead.");
 
         Action a = new Action();
 
         a.setValue(action);
         this.action = a.getAction();
     }
 
 
     /**
      * Sets the FTP action to be taken. Currently accepts "put", "get", "del",
      * "mkdir", "chmod", "list", and "site".
      *
      * @param action the FTP action to be performed.
      *
      * @throws BuildException if the action is not a valid action.
      */
     public void setAction(Action action) throws BuildException {
         this.action = action.getAction();
     }
 
 
     /**
      * The output file for the "list" action. This attribute is ignored for
      * any other actions.
      *
      * @param listing file in which to store the listing.
      */
     public void setListing(File listing) {
         this.listing = listing;
     }
 
 
     /**
      * If true, enables unsuccessful file put, delete and get
      * operations to be skipped with a warning and the remainder
      * of the files still transferred.
      *
      * @param skipFailedTransfers true if failures in transfers are ignored.
      */
     public void setSkipFailedTransfers(boolean skipFailedTransfers) {
         this.skipFailedTransfers = skipFailedTransfers;
     }
 
 
     /**
      * set the flag to skip errors on directory creation.
      * (and maybe later other server specific errors)
      *
      * @param ignoreNoncriticalErrors true if non-critical errors should not
      *        cause a failure.
      */
     public void setIgnoreNoncriticalErrors(boolean ignoreNoncriticalErrors) {
         this.ignoreNoncriticalErrors = ignoreNoncriticalErrors;
     }
 
     private void configurationHasBeenSet() {
         this.isConfigurationSet = true;
     }
 
     /**
      * Sets the systemTypeKey attribute.
      * Method for setting <code>FTPClientConfig</code> remote system key.
      *
      * @param systemKey the key to be set - BUT if blank
      * the default value of null (which signifies "autodetect") will be kept.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setSystemTypeKey(FTPSystemType systemKey) {
         if (systemKey != null && !systemKey.getValue().equals("")) {
             this.systemTypeKey = systemKey;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the defaultDateFormatConfig attribute.
      * @param defaultDateFormat configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setDefaultDateFormatConfig(String defaultDateFormat) {
         if (defaultDateFormat != null && !defaultDateFormat.equals("")) {
             this.defaultDateFormatConfig = defaultDateFormat;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the recentDateFormatConfig attribute.
      * @param recentDateFormat configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setRecentDateFormatConfig(String recentDateFormat) {
         if (recentDateFormat != null && !recentDateFormat.equals("")) {
             this.recentDateFormatConfig = recentDateFormat;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the serverLanguageCode attribute.
      * @param serverLanguageCode configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setServerLanguageCodeConfig(LanguageCode serverLanguageCode) {
         if (serverLanguageCode != null && !"".equals(serverLanguageCode.getValue())) {
             this.serverLanguageCodeConfig = serverLanguageCode;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the serverTimeZoneConfig attribute.
      * @param serverTimeZoneId configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setServerTimeZoneConfig(String serverTimeZoneId) {
         if (serverTimeZoneId != null && !serverTimeZoneId.equals("")) {
             this.serverTimeZoneConfig = serverTimeZoneId;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the shortMonthNamesConfig attribute
      *
      * @param shortMonthNames configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setShortMonthNamesConfig(String shortMonthNames) {
         if (shortMonthNames != null && !shortMonthNames.equals("")) {
             this.shortMonthNamesConfig = shortMonthNames;
             configurationHasBeenSet();
         }
     }
 
 
 
     /**
      * Defines how many times to retry executing FTP command before giving up.
      * Default is 0 - try once and if failure then give up.
      *
      * @param retriesAllowed number of retries to allow.  -1 means
      * keep trying forever. "forever" may also be specified as a
      * synonym for -1.
      */
     public void setRetriesAllowed(String retriesAllowed) {
         if ("FOREVER".equalsIgnoreCase(retriesAllowed)) {
             this.retriesAllowed = Retryable.RETRY_FOREVER;
         } else {
             try {
                 int retries = Integer.parseInt(retriesAllowed);
                 if (retries < Retryable.RETRY_FOREVER) {
                     throw new BuildException(
                                              "Invalid value for retriesAllowed attribute: "
                                              + retriesAllowed);
 
                 }
                 this.retriesAllowed = retries;
             } catch (NumberFormatException px) {
                 throw new BuildException(
                                          "Invalid value for retriesAllowed attribute: "
                                          + retriesAllowed);
 
             }
 
         }
     }
     /**
      * @return Returns the systemTypeKey.
      */
     public String getSystemTypeKey() {
         return systemTypeKey.getValue();
     }
     /**
      * @return Returns the defaultDateFormatConfig.
      */
     public String getDefaultDateFormatConfig() {
         return defaultDateFormatConfig;
     }
     /**
      * @return Returns the recentDateFormatConfig.
      */
     public String getRecentDateFormatConfig() {
         return recentDateFormatConfig;
     }
     /**
      * @return Returns the serverLanguageCodeConfig.
      */
     public String getServerLanguageCodeConfig() {
         return serverLanguageCodeConfig.getValue();
     }
     /**
      * @return Returns the serverTimeZoneConfig.
      */
     public String getServerTimeZoneConfig() {
         return serverTimeZoneConfig;
     }
     /**
      * @return Returns the shortMonthNamesConfig.
      */
     public String getShortMonthNamesConfig() {
         return shortMonthNamesConfig;
     }
     /**
      * @return Returns the timestampGranularity.
      */
     Granularity getTimestampGranularity() {
         return timestampGranularity;
     }
     /**
      * Sets the timestampGranularity attribute
      * @param timestampGranularity The timestampGranularity to set.
      */
     public void setTimestampGranularity(Granularity timestampGranularity) {
         if (null == timestampGranularity || "".equals(timestampGranularity.getValue())) {
             return;
         }
         this.timestampGranularity = timestampGranularity;
     }
     /**
      * Sets the siteCommand attribute.  This attribute
      * names the command that will be executed if the action
      * is "site".
      * @param siteCommand The siteCommand to set.
      */
     public void setSiteCommand(String siteCommand) {
         this.siteCommand = siteCommand;
     }
     /**
      * Sets the initialSiteCommand attribute.  This attribute
      * names a site command that will be executed immediately
      * after connection.
      * @param initialCommand The initialSiteCommand to set.
      */
     public void setInitialSiteCommand(String initialCommand) {
         this.initialSiteCommand = initialCommand;
     }
 
     /**
      * Whether to verify that data and control connections are
      * connected to the same remote host.
      *
      * @since Ant 1.8.0
      */
     public void setEnableRemoteVerification(boolean b) {
         enableRemoteVerification = b;
     }
 
     /**
      * Checks to see that all required parameters are set.
      *
      * @throws BuildException if the configuration is not valid.
      */
     protected void checkAttributes() throws BuildException {
         if (server == null) {
             throw new BuildException("server attribute must be set!");
         }
         if (userid == null) {
             throw new BuildException("userid attribute must be set!");
         }
         if (password == null) {
             throw new BuildException("password attribute must be set!");
         }
 
         if ((action == LIST_FILES) && (listing == null)) {
             throw new BuildException("listing attribute must be set for list "
                                      + "action!");
         }
 
         if (action == MK_DIR && remotedir == null) {
             throw new BuildException("remotedir attribute must be set for "
                                      + "mkdir action!");
         }
 
         if (action == CHMOD && chmod == null) {
             throw new BuildException("chmod attribute must be set for chmod "
                                      + "action!");
         }
         if (action == SITE_CMD && siteCommand == null) {
             throw new BuildException("sitecommand attribute must be set for site "
                                      + "action!");
         }
 
 
         if (this.isConfigurationSet) {
             try {
                 Class.forName("org.apache.commons.net.ftp.FTPClientConfig");
             } catch (ClassNotFoundException e) {
                 throw new BuildException(
                                          "commons-net.jar >= 1.4.0 is required for at least one"
                                          + " of the attributes specified.");
             }
         }
     }
 
     /**
      * Executable a retryable object.
      * @param h the retry handler.
      * @param r the object that should be retried until it succeeds
      *          or the number of retrys is reached.
      * @param descr a description of the command that is being run.
      * @throws IOException if there is a problem.
      */
     protected void executeRetryable(RetryHandler h, Retryable r, String descr)
         throws IOException {
         h.execute(r, descr);
     }
 
 
     /**
      * For each file in the fileset, do the appropriate action: send, get,
      * delete, or list.
      *
      * @param ftp the FTPClient instance used to perform FTP actions
      * @param fs the fileset on which the actions are performed.
      *
      * @return the number of files to be transferred.
      *
      * @throws IOException if there is a problem reading a file
      * @throws BuildException if there is a problem in the configuration.
      */
     protected int transferFiles(final FTPClient ftp, FileSet fs)
         throws IOException, BuildException {
         DirectoryScanner ds;
         if (action == SEND_FILES) {
             ds = fs.getDirectoryScanner(getProject());
         } else {
             ds = new FTPDirectoryScanner(ftp);
             fs.setupDirectoryScanner(ds, getProject());
             ds.setFollowSymlinks(fs.isFollowSymlinks());
             ds.scan();
         }
 
         String[] dsfiles = null;
         if (action == RM_DIR) {
             dsfiles = ds.getIncludedDirectories();
         } else {
             dsfiles = ds.getIncludedFiles();
         }
         String dir = null;
 
         if ((ds.getBasedir() == null)
             && ((action == SEND_FILES) || (action == GET_FILES))) {
             throw new BuildException("the dir attribute must be set for send "
                                      + "and get actions");
         } else {
             if ((action == SEND_FILES) || (action == GET_FILES)) {
                 dir = ds.getBasedir().getAbsolutePath();
             }
         }
 
         // If we are doing a listing, we need the output stream created now.
         BufferedWriter bw = null;
 
         try {
             if (action == LIST_FILES) {
                 File pd = listing.getParentFile();
 
                 if (!pd.exists()) {
                     pd.mkdirs();
                 }
                 bw = new BufferedWriter(new FileWriter(listing));
             }
             RetryHandler h = new RetryHandler(this.retriesAllowed, this);
             if (action == RM_DIR) {
                 // to remove directories, start by the end of the list
                 // the trunk does not let itself be removed before the leaves
                 for (int i = dsfiles.length - 1; i >= 0; i--) {
                     final String dsfile = dsfiles[i];
                     executeRetryable(h, new Retryable() {
                             public void execute() throws IOException {
                                 rmDir(ftp, dsfile);
                             }
                         }, dsfile);
                 }
             } else {
                 final BufferedWriter fbw = bw;
                 final String fdir = dir;
                 if (this.newerOnly) {
                     this.granularityMillis =
                         this.timestampGranularity.getMilliseconds(action);
                 }
                 for (int i = 0; i < dsfiles.length; i++) {
                     final String dsfile = dsfiles[i];
                     executeRetryable(h, new Retryable() {
                             public void execute() throws IOException {
                                 switch (action) {
                                 case SEND_FILES:
                                     sendFile(ftp, fdir, dsfile);
                                     break;
                                 case GET_FILES:
                                     getFile(ftp, fdir, dsfile);
                                     break;
                                 case DEL_FILES:
                                     delFile(ftp, dsfile);
                                     break;
                                 case LIST_FILES:
                                     listFile(ftp, fbw, dsfile);
                                     break;
                                 case CHMOD:
                                     doSiteCommand(ftp, "chmod " + chmod
                                                   + " " + resolveFile(dsfile));
                                     transferred++;
                                     break;
                                 default:
                                     throw new BuildException("unknown ftp action " + action);
                                 }
                             }
                         }, dsfile);
                 }
             }
         } finally {
             FileUtils.close(bw);
         }
 
         return dsfiles.length;
     }
 
 
     /**
      * Sends all files specified by the configured filesets to the remote
      * server.
      *
      * @param ftp the FTPClient instance used to perform FTP actions
      *
      * @throws IOException if there is a problem reading a file
      * @throws BuildException if there is a problem in the configuration.
      */
     protected void transferFiles(FTPClient ftp)
         throws IOException, BuildException {
         transferred = 0;
         skipped = 0;
 
         if (filesets.size() == 0) {
             throw new BuildException("at least one fileset must be specified.");
         } else {
             // get files from filesets
             final int size = filesets.size();
             for (int i = 0; i < size; i++) {
                 FileSet fs = (FileSet) filesets.elementAt(i);
 
                 if (fs != null) {
                     transferFiles(ftp, fs);
                 }
             }
         }
 
         log(transferred + " " + ACTION_TARGET_STRS[action] + " "
             + COMPLETED_ACTION_STRS[action]);
         if (skipped != 0) {
             log(skipped + " " + ACTION_TARGET_STRS[action]
                 + " were not successfully " + COMPLETED_ACTION_STRS[action]);
         }
     }
 
 
     /**
      * Correct a file path to correspond to the remote host requirements. This
      * implementation currently assumes that the remote end can handle
      * Unix-style paths with forward-slash separators. This can be overridden
      * with the <code>separator</code> task parameter. No attempt is made to
      * determine what syntax is appropriate for the remote host.
      *
      * @param file the remote file name to be resolved
      *
      * @return the filename as it will appear on the server.
      */
     protected String resolveFile(String file) {
         return file.replace(System.getProperty("file.separator").charAt(0),
                             remoteFileSep.charAt(0));
     }
 
 
     /**
      * Creates all parent directories specified in a complete relative
      * pathname. Attempts to create existing directories will not cause
      * errors.
      *
      * @param ftp the FTP client instance to use to execute FTP actions on
      *        the remote server.
      * @param filename the name of the file whose parents should be created.
      * @throws IOException under non documented circumstances
      * @throws BuildException if it is impossible to cd to a remote directory
      *
      */
     protected void createParents(FTPClient ftp, String filename)
         throws IOException, BuildException {
 
         File dir = new File(filename);
         if (dirCache.contains(dir)) {
             return;
         }
 
         Vector parents = new Vector();
         String dirname;
 
         while ((dirname = dir.getParent()) != null) {
             File checkDir = new File(dirname);
             if (dirCache.contains(checkDir)) {
                 break;
             }
             dir = checkDir;
             parents.addElement(dir);
         }
 
         // find first non cached dir
         int i = parents.size() - 1;
 
         if (i >= 0) {
             String cwd = ftp.printWorkingDirectory();
             String parent = dir.getParent();
             if (parent != null) {
                 if (!ftp.changeWorkingDirectory(resolveFile(parent))) {
                     throw new BuildException("could not change to "
                                              + "directory: " + ftp.getReplyString());
                 }
             }
 
             while (i >= 0) {
                 dir = (File) parents.elementAt(i--);
                 // check if dir exists by trying to change into it.
                 if (!ftp.changeWorkingDirectory(dir.getName())) {
                     // could not change to it - try to create it
                     log("creating remote directory "
                         + resolveFile(dir.getPath()), Project.MSG_VERBOSE);
                     if (!ftp.makeDirectory(dir.getName())) {
                         handleMkDirFailure(ftp);
                     }
                     if (!ftp.changeWorkingDirectory(dir.getName())) {
                         throw new BuildException("could not change to "
                                                  + "directory: " + ftp.getReplyString());
                     }
                 }
                 dirCache.add(dir);
             }
             ftp.changeWorkingDirectory(cwd);
         }
     }
     /**
      * auto find the time difference between local and remote
      * @param ftp handle to ftp client
      * @return number of millis to add to remote time to make it comparable to local time
      * @since ant 1.6
      */
     private long getTimeDiff(FTPClient ftp) {
         long returnValue = 0;
         File tempFile = findFileName(ftp);
         try {
             // create a local temporary file
             FILE_UTILS.createNewFile(tempFile);
             long localTimeStamp = tempFile.lastModified();
             BufferedInputStream instream = new BufferedInputStream(new FileInputStream(tempFile));
             ftp.storeFile(tempFile.getName(), instream);
             instream.close();
             boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
             if (success) {
                 FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName());
                 if (ftpFiles.length == 1) {
                     long remoteTimeStamp = ftpFiles[0].getTimestamp().getTime().getTime();
                     returnValue = localTimeStamp - remoteTimeStamp;
                 }
                 ftp.deleteFile(ftpFiles[0].getName());
             }
             // delegate the deletion of the local temp file to the delete task
-            // because of race conditions occuring on Windows
+            // because of race conditions occurring on Windows
             Delete mydelete = new Delete();
             mydelete.bindToOwner(this);
             mydelete.setFile(tempFile.getCanonicalFile());
             mydelete.execute();
         } catch (Exception e) {
             throw new BuildException(e, getLocation());
         }
         return returnValue;
     }
     /**
      *  find a suitable name for local and remote temporary file
      */
     private File findFileName(FTPClient ftp) {
         FTPFile [] theFiles = null;
         final int maxIterations = 1000;
         for (int counter = 1; counter < maxIterations; counter++) {
             File localFile = FILE_UTILS.createTempFile(
                                                        "ant" + Integer.toString(counter), ".tmp",
                                                        null, false, false);
             String fileName = localFile.getName();
             boolean found = false;
             try {
                 if (theFiles == null) {
                     theFiles = ftp.listFiles();
                 }
                 for (int counter2 = 0; counter2 < theFiles.length; counter2++) {
                     if (theFiles[counter2] != null
                         && theFiles[counter2].getName().equals(fileName)) {
                         found = true;
                         break;
                     }
                 }
             } catch (IOException ioe) {
                 throw new BuildException(ioe, getLocation());
             }
             if (!found) {
                 localFile.deleteOnExit();
                 return localFile;
             }
         }
         return null;
     }
 
     /**
      * Checks to see if the remote file is current as compared with the local
      * file. Returns true if the target file is up to date.
      * @param ftp ftpclient
      * @param localFile local file
      * @param remoteFile remote file
      * @return true if the target file is up to date
      * @throws IOException  in unknown circumstances
      * @throws BuildException if the date of the remote files cannot be found and the action is
      * GET_FILES
      */
     protected boolean isUpToDate(FTPClient ftp, File localFile,
                                  String remoteFile)
         throws IOException, BuildException {
         log("checking date for " + remoteFile, Project.MSG_VERBOSE);
 
         FTPFile[] files = ftp.listFiles(remoteFile);
 
         // For Microsoft's Ftp-Service an Array with length 0 is
         // returned if configured to return listings in "MS-DOS"-Format
         if (files == null || files.length == 0) {
             // If we are sending files, then assume out of date.
             // If we are getting files, then throw an error
 
             if (action == SEND_FILES) {
                 log("Could not date test remote file: " + remoteFile
                     + "assuming out of date.", Project.MSG_VERBOSE);
                 return false;
             } else {
                 throw new BuildException("could not date test remote file: "
                                          + ftp.getReplyString());
             }
         }
 
         long remoteTimestamp = files[0].getTimestamp().getTime().getTime();
         long localTimestamp = localFile.lastModified();
         long adjustedRemoteTimestamp =
             remoteTimestamp + this.timeDiffMillis + this.granularityMillis;
 
         StringBuffer msg;
         synchronized(TIMESTAMP_LOGGING_SDF) {
             msg = new StringBuffer("   [")
                 .append(TIMESTAMP_LOGGING_SDF.format(new Date(localTimestamp)))
                 .append("] local");
         }
         log(msg.toString(), Project.MSG_VERBOSE);
 
         synchronized(TIMESTAMP_LOGGING_SDF) {
             msg = new StringBuffer("   [")
                 .append(TIMESTAMP_LOGGING_SDF.format(new Date(adjustedRemoteTimestamp)))
                 .append("] remote");
         }
         if (remoteTimestamp != adjustedRemoteTimestamp) {
             synchronized(TIMESTAMP_LOGGING_SDF) {
                 msg.append(" - (raw: ")
                     .append(TIMESTAMP_LOGGING_SDF.format(new Date(remoteTimestamp)))
                     .append(")");
             }
         }
         log(msg.toString(), Project.MSG_VERBOSE);
 
 
 
         if (this.action == SEND_FILES) {
             return adjustedRemoteTimestamp >= localTimestamp;
         } else {
             return localTimestamp >= adjustedRemoteTimestamp;
         }
     }
 
 
     /**
      * Sends a site command to the ftp server
      * @param ftp ftp client
      * @param theCMD command to execute
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void doSiteCommand(FTPClient ftp, String theCMD)
         throws IOException, BuildException {
         boolean rc;
         String[] myReply = null;
 
         log("Doing Site Command: " + theCMD, Project.MSG_VERBOSE);
 
         rc = ftp.sendSiteCommand(theCMD);
 
         if (!rc) {
             log("Failed to issue Site Command: " + theCMD, Project.MSG_WARN);
         } else {
 
             myReply = ftp.getReplyStrings();
 
             for (int x = 0; x < myReply.length; x++) {
                 if (myReply[x] != null && myReply[x].indexOf("200") == -1) {
                     log(myReply[x], Project.MSG_WARN);
                 }
             }
         }
     }
 
 
     /**
      * Sends a single file to the remote host. <code>filename</code> may
      * contain a relative path specification. When this is the case, <code>sendFile</code>
      * will attempt to create any necessary parent directories before sending
      * the file. The file will then be sent using the entire relative path
      * spec - no attempt is made to change directories. It is anticipated that
      * this may eventually cause problems with some FTP servers, but it
      * simplifies the coding.
      * @param ftp ftp client
      * @param dir base directory of the file to be sent (local)
      * @param filename relative path of the file to be send
      *        locally relative to dir
      *        remotely relative to the remotedir attribute
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void sendFile(FTPClient ftp, String dir, String filename)
         throws IOException, BuildException {
         InputStream instream = null;
 
         try {
             // TODO - why not simply new File(dir, filename)?
             File file = getProject().resolveFile(new File(dir, filename).getPath());
 
             if (newerOnly && isUpToDate(ftp, file, resolveFile(filename))) {
                 return;
             }
 
             if (verbose) {
                 log("transferring " + file.getAbsolutePath());
             }
 
             instream = new BufferedInputStream(new FileInputStream(file));
 
             createParents(ftp, filename);
 
             ftp.storeFile(resolveFile(filename), instream);
 
             boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
 
             if (!success) {
                 String s = "could not put file: " + ftp.getReplyString();
 
                 if (skipFailedTransfers) {
                     log(s, Project.MSG_WARN);
                     skipped++;
                 } else {
                     throw new BuildException(s);
                 }
 
             } else {
                 // see if we should issue a chmod command
                 if (chmod != null) {
                     doSiteCommand(ftp, "chmod " + chmod + " " + resolveFile(filename));
                 }
                 log("File " + file.getAbsolutePath() + " copied to " + server,
                     Project.MSG_VERBOSE);
                 transferred++;
             }
         } finally {
             FileUtils.close(instream);
         }
     }
 
 
     /**
      * Delete a file from the remote host.
      * @param ftp ftp client
      * @param filename file to delete
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is set to false
      * and the deletion could not be done
      */
     protected void delFile(FTPClient ftp, String filename)
         throws IOException, BuildException {
         if (verbose) {
             log("deleting " + filename);
         }
 
         if (!ftp.deleteFile(resolveFile(filename))) {
             String s = "could not delete file: " + ftp.getReplyString();
 
             if (skipFailedTransfers) {
                 log(s, Project.MSG_WARN);
                 skipped++;
             } else {
                 throw new BuildException(s);
             }
         } else {
             log("File " + filename + " deleted from " + server,
                 Project.MSG_VERBOSE);
             transferred++;
         }
     }
 
     /**
      * Delete a directory, if empty, from the remote host.
      * @param ftp ftp client
      * @param dirname directory to delete
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is set to false
      * and the deletion could not be done
      */
     protected void rmDir(FTPClient ftp, String dirname)
         throws IOException, BuildException {
         if (verbose) {
             log("removing " + dirname);
         }
 
         if (!ftp.removeDirectory(resolveFile(dirname))) {
             String s = "could not remove directory: " + ftp.getReplyString();
 
             if (skipFailedTransfers) {
                 log(s, Project.MSG_WARN);
                 skipped++;
             } else {
                 throw new BuildException(s);
             }
         } else {
             log("Directory " + dirname + " removed from " + server,
                 Project.MSG_VERBOSE);
             transferred++;
         }
     }
 
 
     /**
      * Retrieve a single file from the remote host. <code>filename</code> may
      * contain a relative path specification. <p>
      *
      * The file will then be retrieved using the entire relative path spec -
      * no attempt is made to change directories. It is anticipated that this
      * may eventually cause problems with some FTP servers, but it simplifies
      * the coding.</p>
      * @param ftp the ftp client
      * @param dir local base directory to which the file should go back
      * @param filename relative path of the file based upon the ftp remote directory
      *        and/or the local base directory (dir)
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is false
      * and the file cannot be retrieved.
      */
     protected void getFile(FTPClient ftp, String dir, String filename)
         throws IOException, BuildException {
         OutputStream outstream = null;
         try {
             File file = getProject().resolveFile(new File(dir, filename).getPath());
 
             if (newerOnly && isUpToDate(ftp, file, resolveFile(filename))) {
                 return;
             }
 
             if (verbose) {
                 log("transferring " + filename + " to "
                     + file.getAbsolutePath());
             }
 
             File pdir = file.getParentFile();
 
             if (!pdir.exists()) {
                 pdir.mkdirs();
             }
             outstream = new BufferedOutputStream(new FileOutputStream(file));
             ftp.retrieveFile(resolveFile(filename), outstream);
 
             if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                 String s = "could not get file: " + ftp.getReplyString();
 
                 if (skipFailedTransfers) {
                     log(s, Project.MSG_WARN);
                     skipped++;
                 } else {
                     throw new BuildException(s);
                 }
 
             } else {
                 log("File " + file.getAbsolutePath() + " copied from "
                     + server, Project.MSG_VERBOSE);
                 transferred++;
                 if (preserveLastModified) {
                     outstream.close();
                     outstream = null;
                     FTPFile[] remote = ftp.listFiles(resolveFile(filename));
                     if (remote.length > 0) {
                         FILE_UTILS.setFileLastModified(file,
                                                        remote[0].getTimestamp()
                                                        .getTime().getTime());
                     }
                 }
             }
         } finally {
             FileUtils.close(outstream);
         }
     }
 
 
     /**
      * List information about a single file from the remote host. <code>filename</code>
      * may contain a relative path specification. <p>
      *
      * The file listing will then be retrieved using the entire relative path
      * spec - no attempt is made to change directories. It is anticipated that
      * this may eventually cause problems with some FTP servers, but it
      * simplifies the coding.</p>
      * @param ftp ftp client
      * @param bw buffered writer
      * @param filename the directory one wants to list
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void listFile(FTPClient ftp, BufferedWriter bw, String filename)
         throws IOException, BuildException {
         if (verbose) {
             log("listing " + filename);
         }
         FTPFile[] ftpfiles = ftp.listFiles(resolveFile(filename));
 
         if (ftpfiles != null && ftpfiles.length > 0) {
             bw.write(ftpfiles[0].toString());
             bw.newLine();
             transferred++;
         }
     }
 
 
     /**
      * Create the specified directory on the remote host.
      *
      * @param ftp The FTP client connection
      * @param dir The directory to create (format must be correct for host
      *      type)
      * @throws IOException  in unknown circumstances
      * @throws BuildException if ignoreNoncriticalErrors has not been set to true
      *         and a directory could not be created, for instance because it was
      *         already existing. Precisely, the codes 521, 550 and 553 will trigger
      *         a BuildException
      */
     protected void makeRemoteDir(FTPClient ftp, String dir)
         throws IOException, BuildException {
         String workingDirectory = ftp.printWorkingDirectory();
         if (verbose) {
             if (dir.startsWith("/") || workingDirectory == null) {
                 log("Creating directory: " + dir + " in /");
             } else {
                 log("Creating directory: " + dir + " in " + workingDirectory);
             }
         }
         if (dir.startsWith("/")) {
             ftp.changeWorkingDirectory("/");
         }
         String subdir = "";
         StringTokenizer st = new StringTokenizer(dir, "/");
         while (st.hasMoreTokens()) {
             subdir = st.nextToken();
             log("Checking " + subdir, Project.MSG_DEBUG);
             if (!ftp.changeWorkingDirectory(subdir)) {
                 if (!ftp.makeDirectory(subdir)) {
                     // codes 521, 550 and 553 can be produced by FTP Servers
                     //  to indicate that an attempt to create a directory has
                     //  failed because the directory already exists.
                     int rc = ftp.getReplyCode();
                     if (!(ignoreNoncriticalErrors
                           && (rc == CODE_550 || rc == CODE_553
                               || rc == CODE_521))) {
                         throw new BuildException("could not create directory: "
                                                  + ftp.getReplyString());
                     }
                     if (verbose) {
                         log("Directory already exists");
                     }
                 } else {
                     if (verbose) {
                         log("Directory created OK");
                     }
                     ftp.changeWorkingDirectory(subdir);
                 }
             }
         }
         if (workingDirectory != null) {
             ftp.changeWorkingDirectory(workingDirectory);
         }
     }
 
     /**
      * look at the response for a failed mkdir action, decide whether
      * it matters or not. If it does, we throw an exception
      * @param ftp current ftp connection
      * @throws BuildException if this is an error to signal
      */
     private void handleMkDirFailure(FTPClient ftp)
         throws BuildException {
         int rc = ftp.getReplyCode();
         if (!(ignoreNoncriticalErrors
               && (rc == CODE_550 || rc == CODE_553 || rc == CODE_521))) {
             throw new BuildException("could not create directory: "
                                      + ftp.getReplyString());
         }
     }
 
     /**
      * Runs the task.
      *
      * @throws BuildException if the task fails or is not configured
      *         correctly.
      */
     public void execute() throws BuildException {
         checkAttributes();
 
         FTPClient ftp = null;
 
         try {
             log("Opening FTP connection to " + server, Project.MSG_VERBOSE);
 
             ftp = new FTPClient();
             if (this.isConfigurationSet) {
                 ftp = FTPConfigurator.configure(ftp, this);
             }
 
             ftp.setRemoteVerificationEnabled(enableRemoteVerification);
             ftp.connect(server, port);
             if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                 throw new BuildException("FTP connection failed: "
                                          + ftp.getReplyString());
             }
 
             log("connected", Project.MSG_VERBOSE);
             log("logging in to FTP server", Project.MSG_VERBOSE);
 
             if ((this.account != null && !ftp.login(userid, password, account))
                 || (this.account == null && !ftp.login(userid, password))) {
                 throw new BuildException("Could not login to FTP server");
             }
 
             log("login succeeded", Project.MSG_VERBOSE);
 
             if (binary) {
                 ftp.setFileType(org.apache.commons.net.ftp.FTP.BINARY_FILE_TYPE);
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not set transfer type: "
                                              + ftp.getReplyString());
                 }
             } else {
                 ftp.setFileType(org.apache.commons.net.ftp.FTP.ASCII_FILE_TYPE);
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not set transfer type: "
                                              + ftp.getReplyString());
                 }
             }
 
             if (passive) {
                 log("entering passive mode", Project.MSG_VERBOSE);
                 ftp.enterLocalPassiveMode();
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not enter into passive "
                                              + "mode: " + ftp.getReplyString());
                 }
             }
 
             // If an initial command was configured then send it.
             // Some FTP servers offer different modes of operation,
             // E.G. switching between a UNIX file system mode and
             // a legacy file system.
             if (this.initialSiteCommand != null) {
                 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, FTP.this.initialSiteCommand);
                         }
                     }, "initial site command: " + this.initialSiteCommand);
             }
 
 
             // For a unix ftp server you can set the default mask for all files
             // created.
 
             if (umask != null) {
                 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, "umask " + umask);
                         }
                     }, "umask " + umask);
             }
 
             // If the action is MK_DIR, then the specified remote
             // directory is the directory to create.
 
             if (action == MK_DIR) {
                 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             makeRemoteDir(lftp, remotedir);
                         }
                     }, remotedir);
             } else if (action == SITE_CMD) {
                 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, FTP.this.siteCommand);
                         }
                     }, "Site Command: " + this.siteCommand);
             } else {
                 if (remotedir != null) {
                     log("changing the remote directory to " + remotedir,
                         Project.MSG_VERBOSE);
                     ftp.changeWorkingDirectory(remotedir);
                     if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                         throw new BuildException("could not change remote "
                                                  + "directory: " + ftp.getReplyString());
                     }
                 }
                 if (newerOnly && timeDiffAuto) {
                     // in this case we want to find how much time span there is between local
                     // and remote
                     timeDiffMillis = getTimeDiff(ftp);
                 }
                 log(ACTION_STRS[action] + " " + ACTION_TARGET_STRS[action]);
                 transferFiles(ftp);
             }
 
         } catch (IOException ex) {
             throw new BuildException("error during FTP transfer: " + ex, ex);
         } finally {
             if (ftp != null && ftp.isConnected()) {
                 try {
                     log("disconnecting", Project.MSG_VERBOSE);
                     ftp.logout();
                     ftp.disconnect();
                 } catch (IOException ex) {
                     // ignore it
                 }
             }
         }
     }
 
 
     /**
      * an action to perform, one of
      * "send", "put", "recv", "get", "del", "delete", "list", "mkdir", "chmod",
      * "rmdir"
      */
     public static class Action extends EnumeratedAttribute {
 
         private static final String[] VALID_ACTIONS = {
             "send", "put", "recv", "get", "del", "delete", "list", "mkdir",
             "chmod", "rmdir", "site"
         };
 
 
         /**
          * Get the valid values
          *
          * @return an array of the valid FTP actions.
          */
         public String[] getValues() {
             return VALID_ACTIONS;
         }
 
 
         /**
          * Get the symbolic equivalent of the action value.
          *
          * @return the SYMBOL representing the given action.
          */
         public int getAction() {
             String actionL = getValue().toLowerCase(Locale.ENGLISH);
             if (actionL.equals("send") || actionL.equals("put")) {
                 return SEND_FILES;
             } else if (actionL.equals("recv") || actionL.equals("get")) {
                 return GET_FILES;
             } else if (actionL.equals("del") || actionL.equals("delete")) {
                 return DEL_FILES;
             } else if (actionL.equals("list")) {
                 return LIST_FILES;
             } else if (actionL.equals("chmod")) {
                 return CHMOD;
             } else if (actionL.equals("mkdir")) {
                 return MK_DIR;
             } else if (actionL.equals("rmdir")) {
                 return RM_DIR;
             } else if (actionL.equals("site")) {
                 return SITE_CMD;
             }
             return SEND_FILES;
         }
     }
     /**
      * represents one of the valid timestamp adjustment values
      * recognized by the <code>timestampGranularity</code> attribute.<p>
 
      * A timestamp adjustment may be used in file transfers for checking
      * uptodateness. MINUTE means to add one minute to the server
      * timestamp.  This is done because FTP servers typically list
      * timestamps HH:mm and client FileSystems typically use HH:mm:ss.
      *
      * The default is to use MINUTE for PUT actions and NONE for GET
      * actions, since GETs have the <code>preserveLastModified</code>
      * option, which takes care of the problem in most use cases where
      * this level of granularity is an issue.
      *
      */
     public static class Granularity extends EnumeratedAttribute {
 
         private static final String[] VALID_GRANULARITIES = {
             "", "MINUTE", "NONE"
         };
 
         /**
          * Get the valid values.
          * @return the list of valid Granularity values
          */
         public String[] getValues() {
             return VALID_GRANULARITIES;
         }
         /**
          * returns the number of milliseconds associated with
          * the attribute, which can vary in some cases depending
          * on the value of the action parameter.
          * @param action SEND_FILES or GET_FILES
          * @return the number of milliseconds associated with
          * the attribute, in the context of the supplied action
          */
         public long getMilliseconds(int action) {
             String granularityU = getValue().toUpperCase(Locale.ENGLISH);
             if ("".equals(granularityU)) {
                 if (action == SEND_FILES) {
                     return GRANULARITY_MINUTE;
                 }
             } else if ("MINUTE".equals(granularityU)) {
                 return GRANULARITY_MINUTE;
             }
             return 0L;
         }
         static final Granularity getDefault() {
             Granularity g = new Granularity();
             g.setValue("");
             return g;
         }
 
     }
     /**
      * one of the valid system type keys recognized by the systemTypeKey
      * attribute.
      */
     public static class FTPSystemType extends EnumeratedAttribute {
 
         private static final String[] VALID_SYSTEM_TYPES = {
             "", "UNIX", "VMS", "WINDOWS", "OS/2", "OS/400",
             "MVS"
         };
 
 
         /**
          * Get the valid values.
          * @return the list of valid system types.
          */
         public String[] getValues() {
             return VALID_SYSTEM_TYPES;
         }
 
         static final FTPSystemType getDefault() {
             FTPSystemType ftpst = new FTPSystemType();
             ftpst.setValue("");
             return ftpst;
         }
     }
     /**
      * Enumerated class for languages.
      */
     public static class LanguageCode extends EnumeratedAttribute {
 
 
         private static final String[] VALID_LANGUAGE_CODES =
             getValidLanguageCodes();
 
         private static String[] getValidLanguageCodes() {
             Collection c = FTPClientConfig.getSupportedLanguageCodes();
             String[] ret = new String[c.size() + 1];
             int i = 0;
             ret[i++] = "";
             for (Iterator it = c.iterator(); it.hasNext(); i++) {
                 ret[i] = (String) it.next();
             }
             return ret;
         }
 
 
         /**
          * Return the value values.
          * @return the list of valid language types.
          */
         public String[] getValues() {
             return VALID_LANGUAGE_CODES;
         }
 
         static final LanguageCode getDefault() {
             LanguageCode lc = new LanguageCode();
             lc.setValue("");
             return lc;
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/net/FTPTaskMirrorImpl.java b/src/main/org/apache/tools/ant/taskdefs/optional/net/FTPTaskMirrorImpl.java
index 1115f67ef..a4f241301 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/net/FTPTaskMirrorImpl.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/net/FTPTaskMirrorImpl.java
@@ -1,1951 +1,1951 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.net;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Hashtable;
 import java.util.Map;
 import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.Vector;
 
 import org.apache.commons.net.ftp.FTPClient;
 import org.apache.commons.net.ftp.FTPFile;
 import org.apache.commons.net.ftp.FTPReply;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.Delete;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.selectors.SelectorUtils;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.RetryHandler;
 import org.apache.tools.ant.util.Retryable;
 import org.apache.tools.ant.util.VectorSet;
 
 public class FTPTaskMirrorImpl implements FTPTaskMirror {
 
     /** return code of ftp */
     private static final int CODE_521 = 521;
     private static final int CODE_550 = 550;
     private static final int CODE_553 = 553;
 
     /** Date formatter used in logging, note not thread safe! */
     private static final SimpleDateFormat TIMESTAMP_LOGGING_SDF =
         new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     private final FTPTask task;
     private Set dirCache = new HashSet();
     private int transferred = 0;
     private int skipped = 0;
 
     /**
      * Constructor.
      * @param task the FTPTask that uses this mirror.
      */
     public FTPTaskMirrorImpl(FTPTask task) {
         this.task = task;
     }
 
     /**
      * internal class providing a File-like interface to some of the information
      * available from the FTP server
      *
      */
     protected static class FTPFileProxy extends File {
 
         private final FTPFile file;
         private final String[] parts;
         private final String name;
 
         /**
          * creates a proxy to a FTP file
          * @param file
          */
         public FTPFileProxy(FTPFile file) {
             super(file.getName());
             name = file.getName();
             this.file = file;
             parts = FileUtils.getPathStack(name);
         }
 
         /**
          * creates a proxy to a FTP directory
          * @param completePath the remote directory.
          */
         public FTPFileProxy(String completePath) {
             super(completePath);
             file = null;
             name = completePath;
             parts = FileUtils.getPathStack(completePath);
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#exists()
          */
         public boolean exists() {
             return true;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getAbsolutePath()
          */
         public String getAbsolutePath() {
             return name;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getName()
          */
         public String getName() {
             return parts.length > 0 ? parts[parts.length - 1] : name;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getParent()
          */
         public String getParent() {
             String result = "";
             for(int i = 0; i < parts.length - 1; i++){
                 result += File.separatorChar + parts[i];
             }
             return result;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getPath()
          */
         public String getPath() {
             return name;
         }
 
 
         /**
          * FTP files are stored as absolute paths
          * @return true
          */
         public boolean isAbsolute() {
             return true;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#isDirectory()
          */
         public boolean isDirectory() {
             return file == null;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#isFile()
          */
         public boolean isFile() {
             return file != null;
         }
 
 
         /**
          * FTP files cannot be hidden
          *
          * @return  false
          */
         public boolean isHidden() {
             return false;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#lastModified()
          */
         public long lastModified() {
             if (file != null) {
                 return file.getTimestamp().getTimeInMillis();
             }
             return 0;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#length()
          */
         public long length() {
             if (file != null) {
                 return file.getSize();
             }
             return 0;
         }
     }
 
     /**
      * internal class allowing to read the contents of a remote file system
      * using the FTP protocol
      * used in particular for ftp get operations
      * differences with DirectoryScanner
      * "" (the root of the fileset) is never included in the included directories
      * followSymlinks defaults to false
      */
     protected class FTPDirectoryScanner extends DirectoryScanner {
         // CheckStyle:VisibilityModifier OFF - bc
         protected FTPClient ftp = null;
         // CheckStyle:VisibilityModifier ON
 
         private String rootPath = null;
 
         /**
          * since ant 1.6
          * this flag should be set to true on UNIX and can save scanning time
          */
         private boolean remoteSystemCaseSensitive = false;
         private boolean remoteSensitivityChecked = false;
 
         /**
          * constructor
          * @param ftp  ftpclient object
          */
         public FTPDirectoryScanner(FTPClient ftp) {
             super();
             this.ftp = ftp;
             this.setFollowSymlinks(false);
         }
 
 
         /**
          * scans the remote directory,
          * storing internally the included files, directories, ...
          */
         public void scan() {
             if (includes == null) {
                 // No includes supplied, so set it to 'matches all'
                 includes = new String[1];
                 includes[0] = "**";
             }
             if (excludes == null) {
                 excludes = new String[0];
             }
 
             filesIncluded = new VectorSet();
             filesNotIncluded = new Vector();
             filesExcluded = new VectorSet();
             dirsIncluded = new VectorSet();
             dirsNotIncluded = new Vector();
             dirsExcluded = new VectorSet();
 
             try {
                 String cwd = ftp.printWorkingDirectory();
                 // always start from the current ftp working dir
                 forceRemoteSensitivityCheck();
 
                 checkIncludePatterns();
                 clearCaches();
                 ftp.changeWorkingDirectory(cwd);
             } catch (IOException e) {
                 throw new BuildException("Unable to scan FTP server: ", e);
             }
         }
 
 
         /**
          * this routine is actually checking all the include patterns in
          * order to avoid scanning everything under base dir
          * @since ant1.6
          */
         private void checkIncludePatterns() {
 
             Hashtable newroots = new Hashtable();
             // put in the newroots vector the include patterns without
             // wildcard tokens
             for (int icounter = 0; icounter < includes.length; icounter++) {
                 String newpattern =
                     SelectorUtils.rtrimWildcardTokens(includes[icounter]);
                 newroots.put(newpattern, includes[icounter]);
             }
             if (task.getRemotedir() == null) {
                 try {
                     task.setRemotedir(ftp.printWorkingDirectory());
                 } catch (IOException e) {
                     throw new BuildException("could not read current ftp directory",
                                              task.getLocation());
                 }
             }
             AntFTPFile baseFTPFile = new AntFTPRootFile(ftp, task.getRemotedir());
             rootPath = baseFTPFile.getAbsolutePath();
             // construct it
             if (newroots.containsKey("")) {
                 // we are going to scan everything anyway
                 scandir(rootPath, "", true);
             } else {
                 // only scan directories that can include matched files or
                 // directories
                 Enumeration enum2 = newroots.keys();
 
                 while (enum2.hasMoreElements()) {
                     String currentelement = (String) enum2.nextElement();
                     String originalpattern = (String) newroots.get(currentelement);
                     AntFTPFile myfile = new AntFTPFile(baseFTPFile, currentelement);
                     boolean isOK = true;
                     boolean traversesSymlinks = false;
                     String path = null;
 
                     if (myfile.exists()) {
                         forceRemoteSensitivityCheck();
                         if (remoteSensitivityChecked
                             && remoteSystemCaseSensitive && isFollowSymlinks()) {
                             // cool case,
                             //we do not need to scan all the subdirs in the relative path
                             path = myfile.getFastRelativePath();
                         } else {
                             // may be on a case insensitive file system.  We want
                             // the results to show what's really on the disk, so
                             // we need to double check.
                             try {
                                 path = myfile.getRelativePath();
                                 traversesSymlinks = myfile.isTraverseSymlinks();
                             }  catch (IOException be) {
                                 throw new BuildException(be, task.getLocation());
                             } catch (BuildException be) {
                                 isOK = false;
                             }
                         }
                     } else {
                         isOK = false;
                     }
                     if (isOK) {
                         currentelement = path.replace(task.getSeparator().charAt(0), File.separatorChar);
                         if (!isFollowSymlinks()
                             && traversesSymlinks) {
                             continue;
                         }
 
                         if (myfile.isDirectory()) {
                             if (isIncluded(currentelement)
                                 && currentelement.length() > 0) {
                                 accountForIncludedDir(currentelement, myfile, true);
                             }  else {
                                 if (currentelement.length() > 0) {
                                     if (currentelement.charAt(currentelement
                                                               .length() - 1)
                                         != File.separatorChar) {
                                         currentelement =
                                             currentelement + File.separatorChar;
                                     }
                                 }
                                 scandir(myfile.getAbsolutePath(), currentelement, true);
                             }
                         } else {
                             if (isCaseSensitive
                                 && originalpattern.equals(currentelement)) {
                                 accountForIncludedFile(currentelement);
                             } else if (!isCaseSensitive
                                        && originalpattern
                                        .equalsIgnoreCase(currentelement)) {
                                 accountForIncludedFile(currentelement);
                             }
                         }
                     }
                 }
             }
         }
         /**
          * scans a particular directory. populates the scannedDirs cache.
          *
          * @param dir directory to scan
          * @param vpath  relative path to the base directory of the remote fileset
          * always ended with a File.separator
          * @param fast seems to be always true in practice
          */
         protected void scandir(String dir, String vpath, boolean fast) {
             // avoid double scanning of directories, can only happen in fast mode
             if (fast && hasBeenScanned(vpath)) {
                 return;
             }
             try {
                 if (!ftp.changeWorkingDirectory(dir)) {
                     return;
                 }
                 String completePath = null;
                 if (!vpath.equals("")) {
                     completePath = rootPath + task.getSeparator()
                         + vpath.replace(File.separatorChar, task.getSeparator().charAt(0));
                 } else {
                     completePath = rootPath;
                 }
                 FTPFile[] newfiles = listFiles(completePath, false);
 
                 if (newfiles == null) {
                     ftp.changeToParentDirectory();
                     return;
                 }
                 for (int i = 0; i < newfiles.length; i++) {
                     FTPFile file = newfiles[i];
                     if (file != null
                         && !file.getName().equals(".")
                         && !file.getName().equals("..")) {
                         String name = vpath + file.getName();
                         scannedDirs.put(name, new FTPFileProxy(file));
                         if (isFunctioningAsDirectory(ftp, dir, file)) {
                             boolean slowScanAllowed = true;
                             if (!isFollowSymlinks() && file.isSymbolicLink()) {
                                 dirsExcluded.addElement(name);
                                 slowScanAllowed = false;
                             } else if (isIncluded(name)) {
                                 accountForIncludedDir(name,
                                                       new AntFTPFile(ftp, file, completePath) , fast);
                             } else {
                                 dirsNotIncluded.addElement(name);
                                 if (fast && couldHoldIncluded(name)) {
                                     scandir(file.getName(),
                                             name + File.separator, fast);
                                 }
                             }
                             if (!fast && slowScanAllowed) {
                                 scandir(file.getName(),
                                         name + File.separator, fast);
                             }
                         } else {
                             if (!isFollowSymlinks() && file.isSymbolicLink()) {
                                 filesExcluded.addElement(name);
                             } else if (isFunctioningAsFile(ftp, dir, file)) {
                                 accountForIncludedFile(name);
                             }
                         }
                     }
                 }
                 ftp.changeToParentDirectory();
             } catch (IOException e) {
                 throw new BuildException("Error while communicating with FTP "
                                          + "server: ", e);
             }
         }
         /**
          * process included file
          * @param name  path of the file relative to the directory of the fileset
          */
         private void accountForIncludedFile(String name) {
             if (!filesIncluded.contains(name)
                 && !filesExcluded.contains(name)) {
 
                 if (isIncluded(name)) {
                     if (!isExcluded(name)
                         && isSelected(name, (File) scannedDirs.get(name))) {
                         filesIncluded.addElement(name);
                     } else {
                         filesExcluded.addElement(name);
                     }
                 } else {
                     filesNotIncluded.addElement(name);
                 }
             }
         }
 
         /**
          *
          * @param name path of the directory relative to the directory of
          * the fileset
          * @param file directory as file
          * @param fast
          */
         private void accountForIncludedDir(String name, AntFTPFile file, boolean fast) {
             if (!dirsIncluded.contains(name)
                 && !dirsExcluded.contains(name)) {
 
                 if (!isExcluded(name)) {
                     if (fast) {
                         if (file.isSymbolicLink()) {
                             try {
                                 file.getClient().changeWorkingDirectory(file.curpwd);
                             } catch (IOException ioe) {
                                 throw new BuildException("could not change directory to curpwd");
                             }
                             scandir(file.getLink(),
                                     name + File.separator, fast);
                         } else {
                             try {
                                 file.getClient().changeWorkingDirectory(file.curpwd);
                             } catch (IOException ioe) {
                                 throw new BuildException("could not change directory to curpwd");
                             }
                             scandir(file.getName(),
                                     name + File.separator, fast);
                         }
                     }
                     dirsIncluded.addElement(name);
                 } else {
                     dirsExcluded.addElement(name);
                     if (fast && couldHoldIncluded(name)) {
                         try {
                             file.getClient().changeWorkingDirectory(file.curpwd);
                         } catch (IOException ioe) {
                             throw new BuildException("could not change directory to curpwd");
                         }
                         scandir(file.getName(),
                                 name + File.separator, fast);
                     }
                 }
             }
         }
         /**
          * temporary table to speed up the various scanning methods below
          *
          * @since Ant 1.6
          */
         private Map fileListMap = new HashMap();
         /**
          * List of all scanned directories.
          *
          * @since Ant 1.6
          */
 
         private Map scannedDirs = new HashMap();
 
         /**
          * Has the directory with the given path relative to the base
          * directory already been scanned?
          *
          * @since Ant 1.6
          */
         private boolean hasBeenScanned(String vpath) {
             return scannedDirs.containsKey(vpath);
         }
 
         /**
          * Clear internal caches.
          *
          * @since Ant 1.6
          */
         private void clearCaches() {
             fileListMap.clear();
             scannedDirs.clear();
         }
         /**
          * list the files present in one directory.
          * @param directory full path on the remote side
          * @param changedir if true change to directory directory before listing
          * @return array of FTPFile
          */
         public FTPFile[] listFiles(String directory, boolean changedir) {
             //task.log("listing files in directory " + directory, Project.MSG_DEBUG);
             String currentPath = directory;
             if (changedir) {
                 try {
                     boolean result = ftp.changeWorkingDirectory(directory);
                     if (!result) {
                         return null;
                     }
                     currentPath = ftp.printWorkingDirectory();
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, task.getLocation());
                 }
             }
             if (fileListMap.containsKey(currentPath)) {
                 task.log("filelist map used in listing files", Project.MSG_DEBUG);
                 return ((FTPFile[]) fileListMap.get(currentPath));
             }
             FTPFile[] result = null;
             try {
                 result = ftp.listFiles();
             } catch (IOException ioe) {
                 throw new BuildException(ioe, task.getLocation());
             }
             fileListMap.put(currentPath, result);
             if (!remoteSensitivityChecked) {
                 checkRemoteSensitivity(result, directory);
             }
             return result;
         }
 
         private void forceRemoteSensitivityCheck() {
             if (!remoteSensitivityChecked) {
                 try {
                     checkRemoteSensitivity(ftp.listFiles(), ftp.printWorkingDirectory());
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, task.getLocation());
                 }
             }
         }
         /**
          * cd into one directory and
          * list the files present in one directory.
          * @param directory full path on the remote side
          * @return array of FTPFile
          */
         public FTPFile[] listFiles(String directory) {
             return listFiles(directory, true);
         }
         private void checkRemoteSensitivity(FTPFile[] array, String directory) {
             if (array == null) {
                 return;
             }
             boolean candidateFound = false;
             String target = null;
             for (int icounter = 0; icounter < array.length; icounter++) {
                 if (array[icounter] != null && array[icounter].isDirectory()) {
                     if (!array[icounter].getName().equals(".")
                         && !array[icounter].getName().equals("..")) {
                         candidateFound = true;
                         target = fiddleName(array[icounter].getName());
                         task.log("will try to cd to "
                                          + target + " where a directory called " + array[icounter].getName()
                                          + " exists", Project.MSG_DEBUG);
                         for (int pcounter = 0; pcounter < array.length; pcounter++) {
                             if (array[pcounter] != null
                                 && pcounter != icounter
                                 && target.equals(array[pcounter].getName())) {
                                 candidateFound = false;
                                 break;
                             }
                         }
                         if (candidateFound) {
                             break;
                         }
                     }
                 }
             }
             if (candidateFound) {
                 try {
                     task.log("testing case sensitivity, attempting to cd to "
                                      + target, Project.MSG_DEBUG);
                     remoteSystemCaseSensitive  = !ftp.changeWorkingDirectory(target);
                 } catch (IOException ioe) {
                     remoteSystemCaseSensitive = true;
                 } finally {
                     try {
                         ftp.changeWorkingDirectory(directory);
                     } catch (IOException ioe) {
                         throw new BuildException(ioe, task.getLocation());
                     }
                 }
                 task.log("remote system is case sensitive : "
                                       + remoteSystemCaseSensitive,
                                       Project.MSG_VERBOSE);
                 remoteSensitivityChecked = true;
             }
         }
         private String fiddleName(String origin) {
             StringBuffer result = new StringBuffer();
             for (int icounter = 0; icounter < origin.length(); icounter++) {
                 if (Character.isLowerCase(origin.charAt(icounter))) {
                     result.append(Character.toUpperCase(origin.charAt(icounter)));
                 } else if (Character.isUpperCase(origin.charAt(icounter))) {
                     result.append(Character.toLowerCase(origin.charAt(icounter)));
                 } else {
                     result.append(origin.charAt(icounter));
                 }
             }
             return result.toString();
         }
         /**
          * an AntFTPFile is a representation of a remote file
          * @since Ant 1.6
          */
         protected class AntFTPFile {
             /**
              * ftp client
              */
             private FTPClient client;
             /**
              * parent directory of the file
              */
             private String curpwd;
             /**
              * the file itself
              */
             private FTPFile ftpFile;
             /**
              *
              */
             private AntFTPFile parent = null;
             private boolean relativePathCalculated = false;
             private boolean traversesSymlinks = false;
             private String relativePath = "";
             /**
              * constructor
              * @param client ftp client variable
              * @param ftpFile the file
              * @param curpwd absolute remote path where the file is found
              */
             public AntFTPFile(FTPClient client, FTPFile ftpFile, String curpwd) {
                 this.client = client;
                 this.ftpFile = ftpFile;
                 this.curpwd = curpwd;
             }
             /**
              * other constructor
              * @param parent the parent file
              * @param path  a relative path to the parent file
              */
             public AntFTPFile(AntFTPFile parent, String path) {
                 this.parent = parent;
                 this.client = parent.client;
                 Vector pathElements = SelectorUtils.tokenizePath(path);
                 try {
                     boolean result = this.client.changeWorkingDirectory(parent.getAbsolutePath());
                     //this should not happen, except if parent has been deleted by another process
                     if (!result) {
                         return;
                     }
                     this.curpwd = parent.getAbsolutePath();
                 } catch (IOException ioe) {
                     throw new BuildException("could not change working dir to "
                                              + parent.curpwd);
                 }
                 final int size = pathElements.size();
                 for (int fcount = 0; fcount < size - 1; fcount++) {
                     String currentPathElement = (String) pathElements.elementAt(fcount);
                     try {
                         boolean result = this.client.changeWorkingDirectory(currentPathElement);
                         if (!result && !isCaseSensitive()
                             && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) {
                             currentPathElement = findPathElementCaseUnsensitive(this.curpwd,
                                                                                 currentPathElement);
                             if (currentPathElement == null) {
                                 return;
                             }
                         } else if (!result) {
                             return;
                         }
                         this.curpwd = getCurpwdPlusFileSep()
                             + currentPathElement;
                     } catch (IOException ioe) {
                         throw new BuildException("could not change working dir to "
                                                  + (String) pathElements.elementAt(fcount)
                                                  + " from " + this.curpwd);
                     }
 
                 }
                 String lastpathelement = (String) pathElements.elementAt(size - 1);
                 FTPFile [] theFiles = listFiles(this.curpwd);
                 this.ftpFile = getFile(theFiles, lastpathelement);
             }
             /**
              * find a file in a directory in case unsensitive way
              * @param parentPath        where we are
              * @param soughtPathElement what is being sought
              * @return                  the first file found or null if not found
              */
             private String findPathElementCaseUnsensitive(String parentPath,
                                                           String soughtPathElement) {
                 // we are already in the right path, so the second parameter
                 // is false
                 FTPFile[] theFiles = listFiles(parentPath, false);
                 if (theFiles == null) {
                     return null;
                 }
                 for (int icounter = 0; icounter < theFiles.length; icounter++) {
                     if (theFiles[icounter] != null
                         && theFiles[icounter].getName().equalsIgnoreCase(soughtPathElement)) {
                         return theFiles[icounter].getName();
                     }
                 }
                 return null;
             }
             /**
              * find out if the file exists
              * @return  true if the file exists
              */
             public boolean exists() {
                 return (ftpFile != null);
             }
             /**
              * if the file is a symbolic link, find out to what it is pointing
              * @return the target of the symbolic link
              */
             public String getLink() {
                 return ftpFile.getLink();
             }
             /**
              * get the name of the file
              * @return the name of the file
              */
             public String getName() {
                 return ftpFile.getName();
             }
             /**
              * find out the absolute path of the file
              * @return absolute path as string
              */
             public String getAbsolutePath() {
                 return getCurpwdPlusFileSep() + ftpFile.getName();
             }
             /**
              * find out the relative path assuming that the path used to construct
              * this AntFTPFile was spelled properly with regards to case.
              * This is OK on a case sensitive system such as UNIX
              * @return relative path
              */
             public String getFastRelativePath() {
                 String absPath = getAbsolutePath();
                 if (absPath.startsWith(rootPath + task.getSeparator())) {
                     return absPath.substring(rootPath.length()
                                              + task.getSeparator().length());
                 }
                 return null;
             }
             /**
              * find out the relative path to the rootPath of the enclosing scanner.
              * this relative path is spelled exactly like on disk,
              * for instance if the AntFTPFile has been instantiated as ALPHA,
              * but the file is really called alpha, this method will return alpha.
              * If a symbolic link is encountered, it is followed, but the name of the link
              * rather than the name of the target is returned.
              * (ie does not behave like File.getCanonicalPath())
              * @return                relative path, separated by remoteFileSep
              * @throws IOException    if a change directory fails, ...
              * @throws BuildException if one of the components of the relative path cannot
              * be found.
              */
             public String getRelativePath() throws IOException, BuildException {
                 if (!relativePathCalculated) {
                     if (parent != null) {
                         traversesSymlinks = parent.isTraverseSymlinks();
                         relativePath = getRelativePath(parent.getAbsolutePath(),
                                                        parent.getRelativePath());
                     } else {
                         relativePath = getRelativePath(rootPath, "");
                         relativePathCalculated = true;
                     }
                 }
                 return relativePath;
             }
             /**
-             * get thge relative path of this file
+             * get the relative path of this file
              * @param currentPath          base path
              * @param currentRelativePath  relative path of the base path with regards to remote dir
              * @return relative path
              */
             private String getRelativePath(String currentPath, String currentRelativePath) {
                 Vector pathElements = SelectorUtils.tokenizePath(getAbsolutePath(), task.getSeparator());
                 Vector pathElements2 = SelectorUtils.tokenizePath(currentPath,
                                                                   task.getSeparator());
                 String relPath = currentRelativePath;
                 final int size = pathElements.size();
                 for (int pcount = pathElements2.size(); pcount < size; pcount++) {
                     String currentElement = (String) pathElements.elementAt(pcount);
                     FTPFile[] theFiles = listFiles(currentPath);
                     FTPFile theFile = null;
                     if (theFiles != null) {
                         theFile = getFile(theFiles, currentElement);
                     }
                     if (!relPath.equals("")) {
                         relPath = relPath + task.getSeparator();
                     }
                     if (theFile == null) {
                         // hit a hidden file assume not a symlink
                         relPath = relPath + currentElement;
                         currentPath = currentPath + task.getSeparator()
                             + currentElement;
                         task.log("Hidden file " + relPath
                                  + " assumed to not be a symlink.",
                                  Project.MSG_VERBOSE);
                     } else {
                         traversesSymlinks = traversesSymlinks || theFile.isSymbolicLink();
                         relPath = relPath + theFile.getName();
                         currentPath = currentPath + task.getSeparator()
                             + theFile.getName();
                     }
                 }
                 return relPath;
             }
             /**
              * find a file matching a string in an array of FTPFile.
              * This method will find "alpha" when requested for "ALPHA"
              * if and only if the caseSensitive attribute is set to false.
              * When caseSensitive is set to true, only the exact match is returned.
              * @param theFiles  array of files
              * @param lastpathelement  the file name being sought
              * @return null if the file cannot be found, otherwise return the matching file.
              */
             public FTPFile getFile(FTPFile[] theFiles, String lastpathelement) {
                 if (theFiles == null) {
                     return null;
                 }
                 for (int fcount = 0; fcount < theFiles.length; fcount++) {
                     if (theFiles[fcount] != null) {
                         if (theFiles[fcount].getName().equals(lastpathelement)) {
                             return theFiles[fcount];
                         } else if (!isCaseSensitive()
                                    && theFiles[fcount].getName().equalsIgnoreCase(
                                                                                   lastpathelement)) {
                             return theFiles[fcount];
                         }
                     }
                 }
                 return null;
             }
             /**
              * tell if a file is a directory.
              * note that it will return false for symbolic links pointing to directories.
              * @return <code>true</code> for directories
              */
             public boolean isDirectory() {
                 return ftpFile.isDirectory();
             }
             /**
              * tell if a file is a symbolic link
              * @return <code>true</code> for symbolic links
              */
             public boolean isSymbolicLink() {
                 return ftpFile.isSymbolicLink();
             }
             /**
              * return the attached FTP client object.
              * Warning : this instance is really shared with the enclosing class.
              * @return  FTP client
              */
             protected FTPClient getClient() {
                 return client;
             }
 
             /**
              * sets the current path of an AntFTPFile
              * @param curpwd the current path one wants to set
              */
             protected void setCurpwd(String curpwd) {
                 this.curpwd = curpwd;
             }
             /**
              * returns the path of the directory containing the AntFTPFile.
              * of the full path of the file itself in case of AntFTPRootFile
              * @return parent directory of the AntFTPFile
              */
             public String getCurpwd() {
                 return curpwd;
             }
             /**
              * returns the path of the directory containing the AntFTPFile.
              * of the full path of the file itself in case of AntFTPRootFile
              * and appends the remote file separator if necessary.
              * @return parent directory of the AntFTPFile
              * @since Ant 1.8.2
              */
             public String getCurpwdPlusFileSep() {
                 String sep = task.getSeparator();
                 return curpwd.endsWith(sep) ? curpwd : curpwd + sep;
             }
             /**
              * find out if a symbolic link is encountered in the relative path of this file
              * from rootPath.
              * @return <code>true</code> if a symbolic link is encountered in the relative path.
              * @throws IOException if one of the change directory or directory listing operations
              * fails
              * @throws BuildException if a path component in the relative path cannot be found.
              */
             public boolean isTraverseSymlinks() throws IOException, BuildException {
                 if (!relativePathCalculated) {
                     // getRelativePath also finds about symlinks
                     getRelativePath();
                 }
                 return traversesSymlinks;
             }
 
             /**
              * Get a string rep of this object.
              * @return a string containing the pwd and the file.
              */
             public String toString() {
                 return "AntFtpFile: " + curpwd + "%" + ftpFile;
             }
         }
         /**
          * special class to represent the remote directory itself
          * @since Ant 1.6
          */
         protected class AntFTPRootFile extends AntFTPFile {
             private String remotedir;
             /**
              * constructor
              * @param aclient FTP client
              * @param remotedir remote directory
              */
             public AntFTPRootFile(FTPClient aclient, String remotedir) {
                 super(aclient, null, remotedir);
                 this.remotedir = remotedir;
                 try {
                     this.getClient().changeWorkingDirectory(this.remotedir);
                     this.setCurpwd(this.getClient().printWorkingDirectory());
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, task.getLocation());
                 }
             }
             /**
              * find the absolute path
              * @return absolute path
              */
             public String getAbsolutePath() {
                 return this.getCurpwd();
             }
             /**
              * find out the relative path to root
              * @return empty string
              * @throws BuildException actually never
              * @throws IOException  actually never
              */
             public String getRelativePath() throws BuildException, IOException {
                 return "";
             }
         }
     }
     /**
      * check FTPFiles to check whether they function as directories too
      * the FTPFile API seem to make directory and symbolic links incompatible
      * we want to find out if we can cd to a symbolic link
      * @param dir  the parent directory of the file to test
      * @param file the file to test
      * @return true if it is possible to cd to this directory
      * @since ant 1.6
      */
     private boolean isFunctioningAsDirectory(FTPClient ftp, String dir, FTPFile file) {
         boolean result = false;
         String currentWorkingDir = null;
         if (file.isDirectory()) {
             return true;
         } else if (file.isFile()) {
             return false;
         }
         try {
             currentWorkingDir = ftp.printWorkingDirectory();
         } catch (IOException ioe) {
             task.log("could not find current working directory " + dir
                                   + " while checking a symlink", Project.MSG_DEBUG);
         }
         if (currentWorkingDir != null) {
             try {
                 result = ftp.changeWorkingDirectory(file.getLink());
             } catch (IOException ioe) {
                 task.log("could not cd to " + file.getLink()
                                       + " while checking a symlink",
                                       Project.MSG_DEBUG);
             }
             if (result) {
                 boolean comeback = false;
                 try {
                     comeback = ftp.changeWorkingDirectory(currentWorkingDir);
                 } catch (IOException ioe) {
                     task.log("could not cd back to " + dir + " while checking a symlink",
                                           Project.MSG_ERR);
                 } finally {
                     if (!comeback) {
                         throw new BuildException("could not cd back to " + dir
                                                  + " while checking a symlink");
                     }
                 }
             }
         }
         return result;
     }
     /**
      * check FTPFiles to check whether they function as directories too
      * the FTPFile API seem to make directory and symbolic links incompatible
      * we want to find out if we can cd to a symbolic link
      * @param dir  the parent directory of the file to test
      * @param file the file to test
      * @return true if it is possible to cd to this directory
      * @since ant 1.6
      */
     private boolean isFunctioningAsFile(FTPClient ftp, String dir, FTPFile file) {
         if (file.isDirectory()) {
             return false;
         } else if (file.isFile()) {
             return true;
         }
         return !isFunctioningAsDirectory(ftp, dir, file);
     }
 
     /**
      * Executable a retryable object.
      * @param h the retry handler.
      * @param r the object that should be retried until it succeeds
      *          or the number of retrys is reached.
      * @param descr a description of the command that is being run.
      * @throws IOException if there is a problem.
      */
     protected void executeRetryable(RetryHandler h, Retryable r, String descr)
         throws IOException {
         h.execute(r, descr);
     }
 
 
     /**
      * For each file in the fileset, do the appropriate action: send, get,
      * delete, or list.
      *
      * @param ftp the FTPClient instance used to perform FTP actions
      * @param fs the fileset on which the actions are performed.
      *
      * @return the number of files to be transferred.
      *
      * @throws IOException if there is a problem reading a file
      * @throws BuildException if there is a problem in the configuration.
      */
     protected int transferFiles(final FTPClient ftp, FileSet fs)
         throws IOException, BuildException {
         DirectoryScanner ds;
         if (task.getAction() == FTPTask.SEND_FILES) {
             ds = fs.getDirectoryScanner(task.getProject());
         } else {
             ds = new FTPDirectoryScanner(ftp);
             fs.setupDirectoryScanner(ds, task.getProject());
             ds.setFollowSymlinks(fs.isFollowSymlinks());
             ds.scan();
         }
 
         String[] dsfiles = null;
         if (task.getAction() == FTPTask.RM_DIR) {
             dsfiles = ds.getIncludedDirectories();
         } else {
             dsfiles = ds.getIncludedFiles();
         }
         String dir = null;
 
         if ((ds.getBasedir() == null)
             && ((task.getAction() == FTPTask.SEND_FILES) || (task.getAction() == FTPTask.GET_FILES))) {
             throw new BuildException("the dir attribute must be set for send "
                                      + "and get actions");
         } else {
             if ((task.getAction() == FTPTask.SEND_FILES) || (task.getAction() == FTPTask.GET_FILES)) {
                 dir = ds.getBasedir().getAbsolutePath();
             }
         }
 
         // If we are doing a listing, we need the output stream created now.
         BufferedWriter bw = null;
 
         try {
             if (task.getAction() == FTPTask.LIST_FILES) {
                 File pd = task.getListing().getParentFile();
 
                 if (!pd.exists()) {
                     pd.mkdirs();
                 }
                 bw = new BufferedWriter(new FileWriter(task.getListing()));
             }
             RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
             if (task.getAction() == FTPTask.RM_DIR) {
                 // to remove directories, start by the end of the list
                 // the trunk does not let itself be removed before the leaves
                 for (int i = dsfiles.length - 1; i >= 0; i--) {
                     final String dsfile = dsfiles[i];
                     executeRetryable(h, new Retryable() {
                             public void execute() throws IOException {
                                 rmDir(ftp, dsfile);
                             }
                         }, dsfile);
                 }
             } else {
                 final BufferedWriter fbw = bw;
                 final String fdir = dir;
                 if (task.isNewer()) {
                     task.setGranularityMillis(task.getTimestampGranularity()
                                               .getMilliseconds(task.getAction()));
                 }
                 for (int i = 0; i < dsfiles.length; i++) {
                     final String dsfile = dsfiles[i];
                     executeRetryable(h, new Retryable() {
                             public void execute() throws IOException {
                                 switch (task.getAction()) {
                                 case FTPTask.SEND_FILES:
                                     sendFile(ftp, fdir, dsfile);
                                     break;
                                 case FTPTask.GET_FILES:
                                     getFile(ftp, fdir, dsfile);
                                     break;
                                 case FTPTask.DEL_FILES:
                                     delFile(ftp, dsfile);
                                     break;
                                 case FTPTask.LIST_FILES:
                                     listFile(ftp, fbw, dsfile);
                                     break;
                                 case FTPTask.CHMOD:
                                     doSiteCommand(ftp, "chmod " + task.getChmod() + " "
                                                   + resolveFile(dsfile));
                                     transferred++;
                                     break;
                                 default:
                                     throw new BuildException("unknown ftp action "
                                                              + task.getAction());
                                 }
                             }
                         }, dsfile);
                 }
             }
         } finally {
             if (bw != null) {
                 bw.close();
             }
         }
 
         return dsfiles.length;
     }
 
 
     /**
      * Sends all files specified by the configured filesets to the remote
      * server.
      *
      * @param ftp the FTPClient instance used to perform FTP actions
      *
      * @throws IOException if there is a problem reading a file
      * @throws BuildException if there is a problem in the configuration.
      */
     protected void transferFiles(FTPClient ftp)
         throws IOException, BuildException {
         transferred = 0;
         skipped = 0;
 
         if (task.getFilesets().size() == 0) {
             throw new BuildException("at least one fileset must be specified.");
         } else {
             // get files from filesets
             final int size = task.getFilesets().size();
             for (int i = 0; i < size; i++) {
                 FileSet fs = (FileSet) task.getFilesets().elementAt(i);
 
                 if (fs != null) {
                     transferFiles(ftp, fs);
                 }
             }
         }
 
         task.log(transferred + " " + FTPTask.ACTION_TARGET_STRS[task.getAction()] + " "
                  + FTPTask.COMPLETED_ACTION_STRS[task.getAction()]);
         if (skipped != 0) {
             task.log(skipped + " " + FTPTask.ACTION_TARGET_STRS[task.getAction()]
                      + " were not successfully " + FTPTask.COMPLETED_ACTION_STRS[task.getAction()]);
         }
     }
 
 
     /**
      * Correct a file path to correspond to the remote host requirements. This
      * implementation currently assumes that the remote end can handle
      * Unix-style paths with forward-slash separators. This can be overridden
      * with the <code>separator</code> task parameter. No attempt is made to
      * determine what syntax is appropriate for the remote host.
      *
      * @param file the remote file name to be resolved
      *
      * @return the filename as it will appear on the server.
      */
     protected String resolveFile(String file) {
         return file.replace(System.getProperty("file.separator").charAt(0),
                             task.getSeparator().charAt(0));
     }
 
 
     /**
      * Creates all parent directories specified in a complete relative
      * pathname. Attempts to create existing directories will not cause
      * errors.
      *
      * @param ftp the FTP client instance to use to execute FTP actions on
      *        the remote server.
      * @param filename the name of the file whose parents should be created.
      * @throws IOException under non documented circumstances
      * @throws BuildException if it is impossible to cd to a remote directory
      *
      */
     protected void createParents(FTPClient ftp, String filename)
         throws IOException, BuildException {
 
         File dir = new File(filename);
         if (dirCache.contains(dir)) {
             return;
         }
 
         Vector parents = new Vector();
         String dirname;
 
         while ((dirname = dir.getParent()) != null) {
             File checkDir = new File(dirname);
             if (dirCache.contains(checkDir)) {
                 break;
             }
             dir = checkDir;
             parents.addElement(dir);
         }
 
         // find first non cached dir
         int i = parents.size() - 1;
 
         if (i >= 0) {
             String cwd = ftp.printWorkingDirectory();
             String parent = dir.getParent();
             if (parent != null) {
                 if (!ftp.changeWorkingDirectory(resolveFile(parent))) {
                     throw new BuildException("could not change to "
                                              + "directory: " + ftp.getReplyString());
                 }
             }
 
             while (i >= 0) {
                 dir = (File) parents.elementAt(i--);
                 // check if dir exists by trying to change into it.
                 if (!ftp.changeWorkingDirectory(dir.getName())) {
                     // could not change to it - try to create it
                     task.log("creating remote directory "
                              + resolveFile(dir.getPath()), Project.MSG_VERBOSE);
                     if (!ftp.makeDirectory(dir.getName())) {
                         handleMkDirFailure(ftp);
                     }
                     if (!ftp.changeWorkingDirectory(dir.getName())) {
                         throw new BuildException("could not change to "
                                                  + "directory: " + ftp.getReplyString());
                     }
                 }
                 dirCache.add(dir);
             }
             ftp.changeWorkingDirectory(cwd);
         }
     }
     /**
      * auto find the time difference between local and remote
      * @param ftp handle to ftp client
      * @return number of millis to add to remote time to make it comparable to local time
      * @since ant 1.6
      */
     private long getTimeDiff(FTPClient ftp) {
         long returnValue = 0;
         File tempFile = findFileName(ftp);
         try {
             // create a local temporary file
             FILE_UTILS.createNewFile(tempFile);
             long localTimeStamp = tempFile.lastModified();
             BufferedInputStream instream = new BufferedInputStream(new FileInputStream(tempFile));
             ftp.storeFile(tempFile.getName(), instream);
             instream.close();
             boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
             if (success) {
                 FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName());
                 if (ftpFiles.length == 1) {
                     long remoteTimeStamp = ftpFiles[0].getTimestamp().getTime().getTime();
                     returnValue = localTimeStamp - remoteTimeStamp;
                 }
                 ftp.deleteFile(ftpFiles[0].getName());
             }
             // delegate the deletion of the local temp file to the delete task
-            // because of race conditions occuring on Windows
+            // because of race conditions occurring on Windows
             Delete mydelete = new Delete();
             mydelete.bindToOwner(task);
             mydelete.setFile(tempFile.getCanonicalFile());
             mydelete.execute();
         } catch (Exception e) {
             throw new BuildException(e, task.getLocation());
         }
         return returnValue;
     }
     /**
      *  find a suitable name for local and remote temporary file
      */
     private File findFileName(FTPClient ftp) {
         FTPFile [] theFiles = null;
         final int maxIterations = 1000;
         for (int counter = 1; counter < maxIterations; counter++) {
             File localFile = FILE_UTILS.createTempFile(
                                                        "ant" + Integer.toString(counter), ".tmp",
                                                        null, false, false);
             String fileName = localFile.getName();
             boolean found = false;
             try {
                 if (theFiles == null) {
                     theFiles = ftp.listFiles();
                 }
                 for (int counter2 = 0; counter2 < theFiles.length; counter2++) {
                     if (theFiles[counter2] != null
                         && theFiles[counter2].getName().equals(fileName)) {
                         found = true;
                         break;
                     }
                 }
             } catch (IOException ioe) {
                 throw new BuildException(ioe, task.getLocation());
             }
             if (!found) {
                 localFile.deleteOnExit();
                 return localFile;
             }
         }
         return null;
     }
 
     /**
      * Checks to see if the remote file is current as compared with the local
      * file. Returns true if the target file is up to date.
      * @param ftp ftpclient
      * @param localFile local file
      * @param remoteFile remote file
      * @return true if the target file is up to date
      * @throws IOException  in unknown circumstances
      * @throws BuildException if the date of the remote files cannot be found and the action is
      * GET_FILES
      */
     protected boolean isUpToDate(FTPClient ftp, File localFile,
                                  String remoteFile)
         throws IOException, BuildException {
         task.log("checking date for " + remoteFile, Project.MSG_VERBOSE);
 
         FTPFile[] files = ftp.listFiles(remoteFile);
 
         // For Microsoft's Ftp-Service an Array with length 0 is
         // returned if configured to return listings in "MS-DOS"-Format
         if (files == null || files.length == 0) {
             // If we are sending files, then assume out of date.
             // If we are getting files, then throw an error
 
             if (task.getAction() == FTPTask.SEND_FILES) {
                 task.log("Could not date test remote file: " + remoteFile
                          + "assuming out of date.", Project.MSG_VERBOSE);
                 return false;
             } else {
                 throw new BuildException("could not date test remote file: "
                                          + ftp.getReplyString());
             }
         }
 
         long remoteTimestamp = files[0].getTimestamp().getTime().getTime();
         long localTimestamp = localFile.lastModified();
         long adjustedRemoteTimestamp = remoteTimestamp + task.getTimeDiffMillis()
             + task.getGranularityMillis();
 
         StringBuffer msg;
         synchronized(TIMESTAMP_LOGGING_SDF) {
             msg = new StringBuffer("   [")
                 .append(TIMESTAMP_LOGGING_SDF.format(new Date(localTimestamp)))
                 .append("] local");
         }
         task.log(msg.toString(), Project.MSG_VERBOSE);
 
         synchronized(TIMESTAMP_LOGGING_SDF) {
             msg = new StringBuffer("   [")
                 .append(TIMESTAMP_LOGGING_SDF.format(new Date(adjustedRemoteTimestamp)))
                 .append("] remote");
         }
         if (remoteTimestamp != adjustedRemoteTimestamp) {
             synchronized(TIMESTAMP_LOGGING_SDF) {
                 msg.append(" - (raw: ")
                     .append(TIMESTAMP_LOGGING_SDF.format(new Date(remoteTimestamp)))
                     .append(")");
             }
         }
         task.log(msg.toString(), Project.MSG_VERBOSE);
 
         if (task.getAction() == FTPTask.SEND_FILES) {
             return adjustedRemoteTimestamp >= localTimestamp;
         } else {
             return localTimestamp >= adjustedRemoteTimestamp;
         }
     }
 
 
     /**
      * Sends a site command to the ftp server
      * @param ftp ftp client
      * @param theCMD command to execute
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void doSiteCommand(FTPClient ftp, String theCMD)
         throws IOException, BuildException {
         boolean rc;
         String[] myReply = null;
 
         task.log("Doing Site Command: " + theCMD, Project.MSG_VERBOSE);
 
         rc = ftp.sendSiteCommand(theCMD);
 
         if (!rc) {
             task.log("Failed to issue Site Command: " + theCMD, Project.MSG_WARN);
         } else {
 
             myReply = ftp.getReplyStrings();
 
             for (int x = 0; x < myReply.length; x++) {
                 if (myReply[x].indexOf("200") == -1) {
                     task.log(myReply[x], Project.MSG_WARN);
                 }
             }
         }
     }
 
 
     /**
      * Sends a single file to the remote host. <code>filename</code> may
      * contain a relative path specification. When this is the case, <code>sendFile</code>
      * will attempt to create any necessary parent directories before sending
      * the file. The file will then be sent using the entire relative path
      * spec - no attempt is made to change directories. It is anticipated that
      * this may eventually cause problems with some FTP servers, but it
      * simplifies the coding.
      * @param ftp ftp client
      * @param dir base directory of the file to be sent (local)
      * @param filename relative path of the file to be send
      *        locally relative to dir
      *        remotely relative to the remotedir attribute
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void sendFile(FTPClient ftp, String dir, String filename)
         throws IOException, BuildException {
         InputStream instream = null;
 
         try {
             // TODO - why not simply new File(dir, filename)?
             File file = task.getProject().resolveFile(new File(dir, filename).getPath());
 
             if (task.isNewer() && isUpToDate(ftp, file, resolveFile(filename))) {
                 return;
             }
 
             if (task.isVerbose()) {
                 task.log("transferring " + file.getAbsolutePath());
             }
 
             instream = new BufferedInputStream(new FileInputStream(file));
 
             createParents(ftp, filename);
 
             ftp.storeFile(resolveFile(filename), instream);
 
             boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
 
             if (!success) {
                 String s = "could not put file: " + ftp.getReplyString();
 
                 if (task.isSkipFailedTransfers()) {
                     task.log(s, Project.MSG_WARN);
                     skipped++;
                 } else {
                     throw new BuildException(s);
                 }
 
             } else {
                 // see if we should issue a chmod command
                 if (task.getChmod() != null) {
                     doSiteCommand(ftp, "chmod " + task.getChmod() + " "
                                   + resolveFile(filename));
                 }
                 task.log("File " + file.getAbsolutePath() + " copied to " + task.getServer(),
                          Project.MSG_VERBOSE);
                 transferred++;
             }
         } finally {
             if (instream != null) {
                 try {
                     instream.close();
                 } catch (IOException ex) {
                     // ignore it
                 }
             }
         }
     }
 
 
     /**
      * Delete a file from the remote host.
      * @param ftp ftp client
      * @param filename file to delete
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is set to false
      * and the deletion could not be done
      */
     protected void delFile(FTPClient ftp, String filename)
         throws IOException, BuildException {
         if (task.isVerbose()) {
             task.log("deleting " + filename);
         }
 
         if (!ftp.deleteFile(resolveFile(filename))) {
             String s = "could not delete file: " + ftp.getReplyString();
 
             if (task.isSkipFailedTransfers()) {
                 task.log(s, Project.MSG_WARN);
                 skipped++;
             } else {
                 throw new BuildException(s);
             }
         } else {
             task.log("File " + filename + " deleted from " + task.getServer(),
                      Project.MSG_VERBOSE);
             transferred++;
         }
     }
 
     /**
      * Delete a directory, if empty, from the remote host.
      * @param ftp ftp client
      * @param dirname directory to delete
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is set to false
      * and the deletion could not be done
      */
     protected void rmDir(FTPClient ftp, String dirname)
         throws IOException, BuildException {
         if (task.isVerbose()) {
             task.log("removing " + dirname);
         }
 
         if (!ftp.removeDirectory(resolveFile(dirname))) {
             String s = "could not remove directory: " + ftp.getReplyString();
 
             if (task.isSkipFailedTransfers()) {
                 task.log(s, Project.MSG_WARN);
                 skipped++;
             } else {
                 throw new BuildException(s);
             }
         } else {
             task.log("Directory " + dirname + " removed from " + task.getServer(),
                      Project.MSG_VERBOSE);
             transferred++;
         }
     }
 
 
     /**
      * Retrieve a single file from the remote host. <code>filename</code> may
      * contain a relative path specification. <p>
      *
      * The file will then be retreived using the entire relative path spec -
      * no attempt is made to change directories. It is anticipated that this
      * may eventually cause problems with some FTP servers, but it simplifies
      * the coding.</p>
      * @param ftp the ftp client
      * @param dir local base directory to which the file should go back
      * @param filename relative path of the file based upon the ftp remote directory
      *        and/or the local base directory (dir)
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is false
      * and the file cannot be retrieved.
      */
     protected void getFile(FTPClient ftp, String dir, String filename)
         throws IOException, BuildException {
         OutputStream outstream = null;
         try {
             File file = task.getProject().resolveFile(new File(dir, filename).getPath());
 
             if (task.isNewer() && isUpToDate(ftp, file, resolveFile(filename))) {
                 return;
             }
 
             if (task.isVerbose()) {
                 task.log("transferring " + filename + " to "
                          + file.getAbsolutePath());
             }
 
             File pdir = file.getParentFile();
 
             if (!pdir.exists()) {
                 pdir.mkdirs();
             }
             outstream = new BufferedOutputStream(new FileOutputStream(file));
             ftp.retrieveFile(resolveFile(filename), outstream);
 
             if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                 String s = "could not get file: " + ftp.getReplyString();
 
                 if (task.isSkipFailedTransfers()) {
                     task.log(s, Project.MSG_WARN);
                     skipped++;
                 } else {
                     throw new BuildException(s);
                 }
 
             } else {
                 task.log(
                          "File " + file.getAbsolutePath() + " copied from "
                          + task.getServer(), Project.MSG_VERBOSE);
                 transferred++;
                 if (task.isPreserveLastModified()) {
                     outstream.close();
                     outstream = null;
                     FTPFile[] remote = ftp.listFiles(resolveFile(filename));
                     if (remote.length > 0) {
                         FILE_UTILS.setFileLastModified(file,
                                                        remote[0].getTimestamp()
                                                        .getTime().getTime());
                     }
                 }
             }
         } finally {
             if (outstream != null) {
                 try {
                     outstream.close();
                 } catch (IOException ex) {
                     // ignore it
                 }
             }
         }
     }
 
 
     /**
      * List information about a single file from the remote host. <code>filename</code>
      * may contain a relative path specification. <p>
      *
      * The file listing will then be retrieved using the entire relative path
      * spec - no attempt is made to change directories. It is anticipated that
      * this may eventually cause problems with some FTP servers, but it
      * simplifies the coding.</p>
      * @param ftp ftp client
      * @param bw buffered writer
      * @param filename the directory one wants to list
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void listFile(FTPClient ftp, BufferedWriter bw, String filename)
         throws IOException, BuildException {
         if (task.isVerbose()) {
             task.log("listing " + filename);
         }
         FTPFile[] ftpfiles = ftp.listFiles(resolveFile(filename));
 
         if (ftpfiles != null && ftpfiles.length > 0) {
             bw.write(ftpfiles[0].toString());
             bw.newLine();
             transferred++;
         }
     }
 
 
     /**
      * Create the specified directory on the remote host.
      *
      * @param ftp The FTP client connection
      * @param dir The directory to create (format must be correct for host
      *      type)
      * @throws IOException  in unknown circumstances
      * @throws BuildException if ignoreNoncriticalErrors has not been set to true
      *         and a directory could not be created, for instance because it was
      *         already existing. Precisely, the codes 521, 550 and 553 will trigger
      *         a BuildException
      */
     protected void makeRemoteDir(FTPClient ftp, String dir)
         throws IOException, BuildException {
         String workingDirectory = ftp.printWorkingDirectory();
         if (task.isVerbose()) {
             if (dir.startsWith("/") || workingDirectory == null) {
                 task.log("Creating directory: " + dir + " in /");
             } else {
                 task.log("Creating directory: " + dir + " in " + workingDirectory);
             }
         }
         if (dir.startsWith("/")) {
             ftp.changeWorkingDirectory("/");
         }
         String subdir = "";
         StringTokenizer st = new StringTokenizer(dir, "/");
         while (st.hasMoreTokens()) {
             subdir = st.nextToken();
             task.log("Checking " + subdir, Project.MSG_DEBUG);
             if (!ftp.changeWorkingDirectory(subdir)) {
                 if (!ftp.makeDirectory(subdir)) {
                     // codes 521, 550 and 553 can be produced by FTP Servers
                     //  to indicate that an attempt to create a directory has
                     //  failed because the directory already exists.
                     int rc = ftp.getReplyCode();
                     if (!(task.isIgnoreNoncriticalErrors() && (rc == CODE_550
                                                                || rc == CODE_553
                                                                || rc == CODE_521))) {
                         throw new BuildException("could not create directory: "
                                                  + ftp.getReplyString());
                     }
                     if (task.isVerbose()) {
                         task.log("Directory already exists");
                     }
                 } else {
                     if (task.isVerbose()) {
                         task.log("Directory created OK");
                     }
                     ftp.changeWorkingDirectory(subdir);
                 }
             }
         }
         if (workingDirectory != null) {
             ftp.changeWorkingDirectory(workingDirectory);
         }
     }
 
     /**
      * look at the response for a failed mkdir action, decide whether
      * it matters or not. If it does, we throw an exception
      * @param ftp current ftp connection
      * @throws BuildException if this is an error to signal
      */
     private void handleMkDirFailure(FTPClient ftp)
         throws BuildException {
         int rc = ftp.getReplyCode();
         if (!(task.isIgnoreNoncriticalErrors() && (rc == CODE_550
                                                    || rc == CODE_553
                                                    || rc == CODE_521))) {
             throw new BuildException("could not create directory: "
                                      + ftp.getReplyString());
         }
     }
 
     public void doFTP() throws BuildException {
         FTPClient ftp = null;
 
         try {
             task.log("Opening FTP connection to " + task.getServer(), Project.MSG_VERBOSE);
 
             ftp = new FTPClient();
             if (task.isConfigurationSet()) {
                 ftp = FTPConfigurator.configure(ftp, task);
             }
 
             ftp.setRemoteVerificationEnabled(task.getEnableRemoteVerification());
             ftp.connect(task.getServer(), task.getPort());
             if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                 throw new BuildException("FTP connection failed: "
                                          + ftp.getReplyString());
             }
 
             task.log("connected", Project.MSG_VERBOSE);
             task.log("logging in to FTP server", Project.MSG_VERBOSE);
 
             if ((task.getAccount() != null && !ftp.login(task.getUserid(), task.getPassword(), task.getAccount()))
                 || (task.getAccount() == null && !ftp.login(task.getUserid(), task.getPassword()))) {
                 throw new BuildException("Could not login to FTP server");
             }
 
             task.log("login succeeded", Project.MSG_VERBOSE);
 
             if (task.isBinary()) {
                 ftp.setFileType(org.apache.commons.net.ftp.FTP.BINARY_FILE_TYPE);
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not set transfer type: "
                                              + ftp.getReplyString());
                 }
             } else {
                 ftp.setFileType(org.apache.commons.net.ftp.FTP.ASCII_FILE_TYPE);
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not set transfer type: "
                                              + ftp.getReplyString());
                 }
             }
 
             if (task.isPassive()) {
                 task.log("entering passive mode", Project.MSG_VERBOSE);
                 ftp.enterLocalPassiveMode();
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not enter into passive "
                                              + "mode: " + ftp.getReplyString());
                 }
             }
 
             // If an initial command was configured then send it.
             // Some FTP servers offer different modes of operation,
             // E.G. switching between a UNIX file system mode and
             // a legacy file system.
             if (task.getInitialSiteCommand() != null) {
                 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, task.getInitialSiteCommand());
                         }
                     }, "initial site command: " + task.getInitialSiteCommand());
             }
 
 
             // For a unix ftp server you can set the default mask for all files
             // created.
 
             if (task.getUmask() != null) {
                 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, "umask " + task.getUmask());
                         }
                     }, "umask " + task.getUmask());
             }
 
             // If the action is MK_DIR, then the specified remote
             // directory is the directory to create.
 
             if (task.getAction() == FTPTask.MK_DIR) {
                 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             makeRemoteDir(lftp, task.getRemotedir());
                         }
                     }, task.getRemotedir());
             } else if (task.getAction() == FTPTask.SITE_CMD) {
                 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, task.getSiteCommand());
                         }
                     }, "Site Command: " + task.getSiteCommand());
             } else {
                 if (task.getRemotedir() != null) {
                     task.log("changing the remote directory", Project.MSG_VERBOSE);
                     ftp.changeWorkingDirectory(task.getRemotedir());
                     if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                         throw new BuildException("could not change remote "
                                                  + "directory: " + ftp.getReplyString());
                     }
                 }
                 if (task.isNewer() && task.isTimeDiffAuto()) {
                     // in this case we want to find how much time span there is between local
                     // and remote
                     task.setTimeDiffMillis(getTimeDiff(ftp));
                 }
                 task.log(FTPTask.ACTION_STRS[task.getAction()] + " " + FTPTask.ACTION_TARGET_STRS[task.getAction()]);
                 transferFiles(ftp);
             }
 
         } catch (IOException ex) {
             throw new BuildException("error during FTP transfer: " + ex, ex);
         } finally {
             if (ftp != null && ftp.isConnected()) {
                 try {
                     task.log("disconnecting", Project.MSG_VERBOSE);
                     ftp.logout();
                     ftp.disconnect();
                 } catch (IOException ex) {
                     // ignore it
                 }
             }
         }
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java b/src/main/org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java
index 9bdae6a3f..dd6016a8c 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java
@@ -1,675 +1,675 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.pvcs;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.text.MessageFormat;
 import java.text.ParseException;
 import java.util.Enumeration;
 import java.util.Random;
 import java.util.Vector;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.Execute;
 import org.apache.tools.ant.taskdefs.ExecuteStreamHandler;
 import org.apache.tools.ant.taskdefs.LogOutputStream;
 import org.apache.tools.ant.taskdefs.LogStreamHandler;
 import org.apache.tools.ant.taskdefs.PumpStreamHandler;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  *
  * Extracts the latest edition of the source code from a PVCS repository.
  * PVCS is a version control system
  * developed by <a href="http://www.merant.com/products/pvcs">Merant</a>.
  * <br>
  * Before using this tag, the user running ant must have access to the commands
  * of PVCS (get and pcli) and must have access to the repository. Note that the way to specify
  * the repository is platform dependent so use property to specify location of repository.
  * <br>
- * This version has been tested agains PVCS version 6.5 and 6.6 under Windows and Solaris.
+ * This version has been tested against PVCS version 6.5 and 6.6 under Windows and Solaris.
 
  *
  * <b>19-04-2001</b> <p>The task now has a more robust
  * parser. It allows for platform independent file paths
  * and supports file names with <i>()</i>. Thanks to Erik Husby for
  * bringing the bug to my attention.
  *
  * <b>27-04-2001</b> <p>UNC paths are now handled properly.
  * Fix provided by Don Jeffery. He also added an <i>UpdateOnly</i> flag
  * that, when true, conditions the PVCS get using the -U option to only
  * update those files that have a modification time (in PVCS) that is newer
  * than the existing workfile.
  *
  * <b>25-10-2002</b> <p>Added a revision attribute that currently is a
  * synonym for label, but in a future release the behavior of the label
  * attribute will change to use the -v option of GET.  See bug #13847 for
  * discussion.
  *
  */
 public class Pvcs extends org.apache.tools.ant.Task {
     // CheckStyle - magic numbers
     // checking for "X:\ 0=dquote,1=letter,2=:,3=\
     private static final int POS_1 = 1;
     private static final int POS_2 = 2;
     private static final int POS_3 = 3;
 
     private String pvcsbin;
     private String repository;
     private String pvcsProject;
     private Vector pvcsProjects;
     private String workspace;
     private String force;
     private String promotiongroup;
     private String label;
     private String revision;
     private boolean ignorerc;
     private boolean updateOnly;
     private String filenameFormat;
     private String lineStart;
     private String userId;
     private String config;
     /**
      * Constant for the thing to execute
      */
     private static final String PCLI_EXE = "pcli";
 
     /*
      * Constant for the PCLI listversionedfiles recursive i a format "get" understands
      */
     // private static final String PCLI_LVF_ARGS = "lvf -z -aw";
 
     /**
      * Constant for the thing to execute
      */
     private static final String GET_EXE = "get";
 
 
     /**
      * Run the command.
      * @param cmd the command line to use.
      * @param out the output stream handler to use.
      * @return the exit code of the command.
      */
     protected int runCmd(Commandline cmd, ExecuteStreamHandler out) {
         try {
             Project aProj = getProject();
             Execute exe = new Execute(out);
             exe.setAntRun(aProj);
             exe.setWorkingDirectory(aProj.getBaseDir());
             exe.setCommandline(cmd.getCommandline());
             return exe.execute();
         } catch (java.io.IOException e) {
             String msg = "Failed executing: " + cmd.toString()
                 + ". Exception: " + e.getMessage();
             throw new BuildException(msg, getLocation());
         }
     }
 
     private String getExecutable(String exe) {
         StringBuffer correctedExe = new StringBuffer();
         if (getPvcsbin() != null) {
             if (pvcsbin.endsWith(File.separator)) {
                 correctedExe.append(pvcsbin);
             } else {
                 correctedExe.append(pvcsbin).append(File.separator);
             }
         }
         return correctedExe.append(exe).toString();
     }
 
     /**
      * @exception org.apache.tools.ant.BuildException Something is stopping the build...
      */
     public void execute() throws org.apache.tools.ant.BuildException {
         int result = 0;
 
         if (repository == null || repository.trim().equals("")) {
             throw new BuildException("Required argument repository not specified");
         }
 
         // Check workspace exists
         // Launch PCLI listversionedfiles -z -aw
         // Capture output
         // build the command line from what we got the format is
         Commandline commandLine = new Commandline();
         commandLine.setExecutable(getExecutable(PCLI_EXE));
 
         commandLine.createArgument().setValue("lvf");
         commandLine.createArgument().setValue("-z");
         commandLine.createArgument().setValue("-aw");
         if (getWorkspace() != null) {
             commandLine.createArgument().setValue("-sp" + getWorkspace());
         }
         commandLine.createArgument().setValue("-pr" + getRepository());
 
         String uid = getUserId();
 
         if (uid != null) {
             commandLine.createArgument().setValue("-id" + uid);
         }
 
         // default pvcs project is "/"
         if (getPvcsproject() == null && getPvcsprojects().isEmpty()) {
             pvcsProject = "/";
         }
 
         if (getPvcsproject() != null) {
             commandLine.createArgument().setValue(getPvcsproject());
         }
         if (!getPvcsprojects().isEmpty()) {
             Enumeration e = getPvcsprojects().elements();
             while (e.hasMoreElements()) {
                 String projectName = ((PvcsProject) e.nextElement()).getName();
                 if (projectName == null || (projectName.trim()).equals("")) {
                     throw new BuildException("name is a required attribute "
                         + "of pvcsproject");
                 }
                 commandLine.createArgument().setValue(projectName);
             }
         }
 
         File tmp = null;
         File tmp2 = null;
         try {
             Random rand = new Random(System.currentTimeMillis());
             tmp = new File("pvcs_ant_" + rand.nextLong() + ".log");
             FileOutputStream fos = new FileOutputStream(tmp);
             tmp2 = new File("pvcs_ant_" + rand.nextLong() + ".log");
             log(commandLine.describeCommand(), Project.MSG_VERBOSE);
             try {
                 result = runCmd(commandLine,
                                 new PumpStreamHandler(fos,
                                     new LogOutputStream(this,
                                                         Project.MSG_WARN)));
             } finally {
                 FileUtils.close(fos);
             }
 
             if (Execute.isFailure(result) && !ignorerc) {
                 String msg = "Failed executing: " + commandLine.toString();
                 throw new BuildException(msg, getLocation());
             }
 
             if (!tmp.exists()) {
                 throw new BuildException("Communication between ant and pvcs "
                     + "failed. No output generated from executing PVCS "
                     + "commandline interface \"pcli\" and \"get\"");
             }
 
             // Create folders in workspace
             log("Creating folders", Project.MSG_INFO);
             createFolders(tmp);
 
             // Massage PCLI lvf output transforming '\' to '/' so get command works appropriately
             massagePCLI(tmp, tmp2);
 
             // Launch get on output captured from PCLI lvf
             commandLine.clearArgs();
             commandLine.setExecutable(getExecutable(GET_EXE));
 
             if (getConfig() != null && getConfig().length() > 0) {
                 commandLine.createArgument().setValue("-c" + getConfig());
             }
 
             if (getForce() != null && getForce().equals("yes")) {
                 commandLine.createArgument().setValue("-Y");
             } else {
                 commandLine.createArgument().setValue("-N");
             }
 
             if (getPromotiongroup() != null) {
                 commandLine.createArgument().setValue("-G"
                     + getPromotiongroup());
             } else {
                 if (getLabel() != null) {
                     commandLine.createArgument().setValue("-v" + getLabel());
                 } else {
                     if (getRevision() != null) {
                         commandLine.createArgument().setValue("-r"
                             + getRevision());
                     }
                 }
             }
 
             if (updateOnly) {
                 commandLine.createArgument().setValue("-U");
             }
 
             commandLine.createArgument().setValue("@" + tmp2.getAbsolutePath());
             log("Getting files", Project.MSG_INFO);
             log("Executing " + commandLine.toString(), Project.MSG_VERBOSE);
             result = runCmd(commandLine,
                 new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_WARN));
             if (result != 0 && !ignorerc) {
                 String msg = "Failed executing: " + commandLine.toString()
                     + ". Return code was " + result;
                 throw new BuildException(msg, getLocation());
             }
 
         } catch (FileNotFoundException e) {
             String msg = "Failed executing: " + commandLine.toString()
                 + ". Exception: " + e.getMessage();
             throw new BuildException(msg, getLocation());
         } catch (IOException e) {
             String msg = "Failed executing: " + commandLine.toString()
                 + ". Exception: " + e.getMessage();
             throw new BuildException(msg, getLocation());
         } catch (ParseException e) {
             String msg = "Failed executing: " + commandLine.toString()
                 + ". Exception: " + e.getMessage();
             throw new BuildException(msg, getLocation());
         } finally {
             if (tmp != null) {
                 tmp.delete();
             }
             if (tmp2 != null) {
                 tmp2.delete();
             }
         }
     }
 
     /**
      * Parses the file and creates the folders specified in the output section
      */
     private void createFolders(File file) throws IOException, ParseException {
         BufferedReader in = null;
         try {
             in = new BufferedReader(new FileReader(file));
             MessageFormat mf = new MessageFormat(getFilenameFormat());
             String line = in.readLine();
             while (line != null) {
                 log("Considering \"" + line + "\"", Project.MSG_VERBOSE);
                 if (line.startsWith("\"\\")    // Checking for "\
                     || line.startsWith("\"/")  // or           "/
                                                // or           "X:\...
                    || (line.length() > POS_3 && line.startsWith("\"")
                         && Character.isLetter(line.charAt(POS_1))
                         && String.valueOf(line.charAt(POS_2)).equals(":")
                         && String.valueOf(line.charAt(POS_3)).equals("\\"))) {
                     Object[] objs = mf.parse(line);
                     String f = (String) objs[1];
                     // Extract the name of the directory from the filename
                     int index = f.lastIndexOf(File.separator);
                     if (index > -1) {
                         File dir = new File(f.substring(0, index));
                         if (!dir.exists()) {
                             log("Creating " + dir.getAbsolutePath(),
                                 Project.MSG_VERBOSE);
                             if (dir.mkdirs() || dir.isDirectory()) {
                                 log("Created " + dir.getAbsolutePath(),
                                     Project.MSG_INFO);
                             } else {
                                 log("Failed to create "
                                     + dir.getAbsolutePath(),
                                     Project.MSG_INFO);
                             }
                         } else {
                             log(dir.getAbsolutePath() + " exists. Skipping",
                                 Project.MSG_VERBOSE);
                         }
                     } else {
                         log("File separator problem with " + line,
                             Project.MSG_WARN);
                     }
                 } else {
                     log("Skipped \"" + line + "\"", Project.MSG_VERBOSE);
                 }
                 line = in.readLine();
             }
         } finally {
             FileUtils.close(in);
         }
     }
 
 
     /**
      * Simple hack to handle the PVCS command-line tools botch when
      * handling UNC notation.
      * @throws IOException if there is an error.
      */
     private void massagePCLI(File in, File out)
         throws IOException {
         BufferedReader inReader = null;
         BufferedWriter outWriter = null;
         try {
             inReader = new BufferedReader(new FileReader(in));
             outWriter = new BufferedWriter(new FileWriter(out));
             String s = null;
             while ((s = inReader.readLine()) != null) {
                 String sNormal = s.replace('\\', '/');
                 outWriter.write(sNormal);
                 outWriter.newLine();
             }
         } finally {
             FileUtils.close(inReader);
             FileUtils.close(outWriter);
         }
     }
 
     /**
      * Get network name of the PVCS repository
      * @return String
      */
     public String getRepository() {
         return repository;
     }
 
     /**
      *  The filenameFormat attribute defines a MessageFormat string used
      *  to parse the output of the pcli command.  It defaults to
      *  <code>{0}-arc({1})</code>.  Repositories where the archive
      *   extension is not  -arc should set this.
      * @return the filename format attribute.
      */
     public String getFilenameFormat() {
         return filenameFormat;
     }
 
     /**
      * The format of the folder names; optional.
      * This must be in a format suitable for
      * <code>java.text.MessageFormat</code>.
      *  Index 1 of the format will be used as the file name.
      *  Defaults to <code>{0}-arc({1})</code>
      * @param f the format to use.
      */
     public void setFilenameFormat(String f) {
         filenameFormat = f;
     }
 
     /**
 
      * The lineStart attribute is used to parse the output of the pcli
      * command. It defaults to <code>&quot;P:</code>.  The parser already
      * knows about / and \\, this property is useful in cases where the
      * repository is accessed on a Windows platform via a drive letter
      * mapping.
      * @return the lineStart attribute.
      */
     public String getLineStart() {
         return lineStart;
     }
 
     /**
      * What a valid return value from PVCS looks like
      *  when it describes a file.  Defaults to <code>&quot;P:</code>.
      * If you are not using an UNC name for your repository and the
      * drive letter <code>P</code> is incorrect for your setup, you may
      * need to change this value, UNC names will always be
      * accepted.
      * @param l the value to use.
      */
     public void setLineStart(String l) {
         lineStart = l;
     }
 
     /**
      * The network name of the PVCS repository; required.
      * @param repo String
      */
     public void setRepository(String repo) {
         repository = repo;
     }
 
     /**
      * Get name of the project in the PVCS repository
      * @return String
      */
     public String getPvcsproject() {
         return pvcsProject;
     }
 
     /**
      * The project within the PVCS repository to extract files from;
      * optional, default &quot;/&quot;
      * @param prj String
      */
     public void setPvcsproject(String prj) {
         pvcsProject = prj;
     }
 
     /**
      * Get name of the project in the PVCS repository
      * @return Vector
      */
     public Vector getPvcsprojects() {
         return pvcsProjects;
     }
 
     /**
      * Get name of the workspace to store the retrieved files
      * @return String
      */
     public String getWorkspace() {
         return workspace;
     }
 
     /**
      * Workspace to use; optional.
      * By specifying a workspace, the files are extracted to that location.
      * A PVCS workspace is a name for a location of the workfiles and
      * isn't as such the location itself.
      * You define the location for a workspace using the PVCS GUI clients.
      * If this isn't specified the default workspace for the current user is used.
      * @param ws String
      */
     public void setWorkspace(String ws) {
         workspace = ws;
     }
 
     /**
      * Get name of the PVCS bin directory
      * @return String
      */
     public String getPvcsbin() {
         return pvcsbin;
     }
 
     /**
      * Specifies the location of the PVCS bin directory; optional if on the PATH.
      * On some systems the PVCS executables <i>pcli</i>
      * and <i>get</i> are not found in the PATH. In such cases this attribute
      * should be set to the bin directory of the PVCS installation containing
      * the executables mentioned before. If this attribute isn't specified the
      * tag expects the executables to be found using the PATH environment variable.
      * @param bin PVCS bin directory
      * @todo use a File setter and resolve paths.
      */
     public void setPvcsbin(String bin) {
         pvcsbin = bin;
     }
 
     /**
      * Get value of force
      * @return String
      */
     public String getForce() {
         return force;
     }
 
     /**
      * Specifies the value of the force argument; optional.
      * If set to <i>yes</i> all files that exists and are
      * writable are overwritten. Default <i>no</i> causes the files
      * that are writable to be ignored. This stops the PVCS command
      * <i>get</i> to stop asking questions!
      * @todo make a boolean setter
      * @param f String (yes/no)
      */
     public void setForce(String f) {
         if (f != null && f.equalsIgnoreCase("yes")) {
             force = "yes";
         } else {
             force = "no";
         }
     }
 
     /**
      * Get value of promotiongroup
      * @return String
      */
     public String getPromotiongroup() {
         return promotiongroup;
     }
 
     /**
      * Specifies the name of the promotiongroup argument
      * @param w String
      */
     public void setPromotiongroup(String w) {
         promotiongroup = w;
     }
 
     /**
      * Get value of label
      * @return String
      */
     public String getLabel() {
         return label;
     }
 
     /**
      * Only files marked with this label are extracted; optional.
      * @param l String
      */
     public void setLabel(String l) {
         label = l;
     }
 
     /**
      * Get value of revision
      * @return String
      */
     public String getRevision() {
         return revision;
     }
 
     /**
      * Only files with this revision are extract; optional.
      * @param r String
      */
     public void setRevision(String r) {
         revision = r;
     }
 
     /**
      * Get value of ignorereturncode
      * @return String
      */
     public boolean getIgnoreReturnCode() {
         return ignorerc;
     }
 
     /**
      * If set to true the return value from executing the pvcs
      * commands are ignored; optional, default false.
      * @param b a <code>boolean</code> value.
      */
     public void setIgnoreReturnCode(boolean b) {
         ignorerc = b;
     }
 
     /**
      * Specify a project within the PVCS repository to extract files from.
      * @param p the pvcs project to use.
      */
     public void addPvcsproject(PvcsProject p) {
         pvcsProjects.addElement(p);
     }
 
     /**
      * get the updateOnly attribute.
      * @return the updateOnly attribute.
      */
     public boolean getUpdateOnly() {
         return updateOnly;
     }
 
     /**
      * If set to <i>true</i> files are fetched only if
      * newer than existing local files; optional, default false.
      * @param l a <code>boolean</code> value.
      */
     public void setUpdateOnly(boolean l) {
         updateOnly = l;
     }
 
     /**
      * returns the path of the configuration file to be used
      * @return the path of the config file
      */
     public String getConfig() {
         return config;
     }
 
     /**
      * Sets a configuration file other than the default to be used.
      * These files have a .cfg extension and are often found in archive or pvcsprop folders.
      * @param f config file - can be given absolute or relative to ant basedir
      */
     public void setConfig(File f) {
         config = f.toString();
     }
 
 
     /**
      * Get the userid.
      * @return the userid.
      */
     public String getUserId() {
         return userId;
     }
 
     /**
      * User ID
      * @param u the value to use.
      */
     public void setUserId(String u) {
         userId = u;
     }
 
     /**
      * Creates a Pvcs object
      */
     public Pvcs() {
         super();
         pvcsProject = null;
         pvcsProjects = new Vector();
         workspace = null;
         repository = null;
         pvcsbin = null;
         force = null;
         promotiongroup = null;
         label = null;
         ignorerc = false;
         updateOnly = false;
         lineStart = "\"P:";
         filenameFormat = "{0}-arc({1})";
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/sound/AntSoundPlayer.java b/src/main/org/apache/tools/ant/taskdefs/optional/sound/AntSoundPlayer.java
index 3f090644c..7988bc60b 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/sound/AntSoundPlayer.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/sound/AntSoundPlayer.java
@@ -1,251 +1,251 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.sound;
 
 // ant includes
 import java.io.File;
 import java.io.IOException;
 
 import javax.sound.sampled.AudioFormat;
 import javax.sound.sampled.AudioInputStream;
 import javax.sound.sampled.AudioSystem;
 import javax.sound.sampled.Clip;
 import javax.sound.sampled.DataLine;
 import javax.sound.sampled.Line;
 import javax.sound.sampled.LineEvent;
 import javax.sound.sampled.LineListener;
 import javax.sound.sampled.LineUnavailableException;
 import javax.sound.sampled.UnsupportedAudioFileException;
 
 import org.apache.tools.ant.BuildEvent;
 import org.apache.tools.ant.BuildListener;
 import org.apache.tools.ant.Project;
 
 
 
 /**
  * This class is designed to be used by any AntTask that requires audio output.
  *
  * It implements the BuildListener interface to listen for BuildEvents
  * and could be easily extended to provide audio output upon any
  * specific build events occurring.
  *
  * I have only tested this with .WAV and .AIFF sound file formats. Both seem to work fine.
  *
  */
 
 public class AntSoundPlayer implements LineListener, BuildListener {
 
     private File fileSuccess = null;
     private int loopsSuccess = 0;
     private Long durationSuccess = null;
 
     private File fileFail = null;
     private int loopsFail = 0;
     private Long durationFail = null;
 
     /** Constructor for AntSoundPlayer. */
     public AntSoundPlayer() {
     }
 
     /**
      * @param file the location of the audio file to be played when the
      *        build is successful
      * @param loops the number of times the file should be played when
      *        the build is successful
      * @param duration the number of milliseconds the file should be
      *        played when the build is successful
      */
     public void addBuildSuccessfulSound(File file, int loops, Long duration) {
         this.fileSuccess = file;
         this.loopsSuccess = loops;
         this.durationSuccess = duration;
     }
 
 
     /**
      * @param fileFail the location of the audio file to be played
      *        when the build fails
      * @param loopsFail the number of times the file should be played
      *        when the build is fails
      * @param durationFail the number of milliseconds the file should be
      *        played when the build fails
      */
     public void addBuildFailedSound(File fileFail, int loopsFail, Long durationFail) {
         this.fileFail = fileFail;
         this.loopsFail = loopsFail;
         this.durationFail = durationFail;
     }
 
     /**
      * Plays the file for duration milliseconds or loops.
      */
     private void play(Project project, File file, int loops, Long duration) {
 
         Clip audioClip = null;
 
         AudioInputStream audioInputStream = null;
 
 
         try {
             audioInputStream = AudioSystem.getAudioInputStream(file);
         } catch (UnsupportedAudioFileException uafe) {
             project.log("Audio format is not yet supported: "
                 + uafe.getMessage());
         } catch (IOException ioe) {
             ioe.printStackTrace();
         }
 
         if (audioInputStream != null) {
             AudioFormat format = audioInputStream.getFormat();
             DataLine.Info   info = new DataLine.Info(Clip.class, format,
                                              AudioSystem.NOT_SPECIFIED);
             try {
                 audioClip = (Clip) AudioSystem.getLine(info);
                 audioClip.addLineListener(this);
                 audioClip.open(audioInputStream);
             } catch (LineUnavailableException e) {
                 project.log("The sound device is currently unavailable");
                 return;
             } catch (IOException e) {
                 e.printStackTrace();
             }
 
             if (duration != null) {
                 playClip(audioClip, duration.longValue());
             } else {
                 playClip(audioClip, loops);
             }
             audioClip.drain();
             audioClip.close();
         } else {
             project.log("Can't get data from file " + file.getName());
         }
     }
 
     private void playClip(Clip clip, int loops) {
 
         clip.loop(loops);
         do {
             try {
                 long timeLeft =
                     (clip.getMicrosecondLength() - clip.getMicrosecondPosition())
                     / 1000;
                 if (timeLeft > 0) {
                     Thread.sleep(timeLeft);
                 }
             } catch (InterruptedException e) {
                 break;
             }
         } while (clip.isRunning());
 
         if (clip.isRunning()) {
             clip.stop();
         }
     }
 
     private void playClip(Clip clip, long duration) {
         clip.loop(Clip.LOOP_CONTINUOUSLY);
         try {
             Thread.sleep(duration);
         } catch (InterruptedException e) {
             // Ignore Exception
         }
         clip.stop();
     }
 
     /**
      * This is implemented to listen for any line events and closes the
      * clip if required.
      * @param event the line event to follow
      */
     public void update(LineEvent event) {
         if (event.getType().equals(LineEvent.Type.STOP)) {
             Line line = event.getLine();
             line.close();
         }
     }
 
 
     /**
      *  Fired before any targets are started.
      * @param event ignored
      */
     public void buildStarted(BuildEvent event) {
     }
 
     /**
      *  Fired after the last target has finished. This event
      *  will still be thrown if an error occurred during the build.
      * @param event the build finished event.
      *  @see BuildEvent#getException()
      */
     public void buildFinished(BuildEvent event) {
         if (event.getException() == null && fileSuccess != null) {
-            // build successfull!
+            // build successful!
             play(event.getProject(), fileSuccess, loopsSuccess, durationSuccess);
         } else if (event.getException() != null && fileFail != null) {
             play(event.getProject(), fileFail, loopsFail, durationFail);
         }
     }
 
     /**
      *  Fired when a target is started.
      * @param event ignored.
      *  @see BuildEvent#getTarget()
      */
     public void targetStarted(BuildEvent event) {
     }
 
     /**
      *  Fired when a target has finished. This event will
      *  still be thrown if an error occurred during the build.
      * @param event ignored.
      *  @see BuildEvent#getException()
      */
     public void targetFinished(BuildEvent event) {
     }
 
     /**
      *  Fired when a task is started.
      * @param event ignored.
      *  @see BuildEvent#getTask()
      */
     public void taskStarted(BuildEvent event) {
     }
 
     /**
      *  Fired when a task has finished. This event will still
      *  be throw if an error occurred during the build.
      * @param event ignored.
      *  @see BuildEvent#getException()
      */
     public void taskFinished(BuildEvent event) {
     }
 
     /**
      *  Fired whenever a message is logged.
      *  @param event the build event
      *  @see BuildEvent#getMessage()
      *  @see BuildEvent#getPriority()
      */
     public void messageLogged(BuildEvent event) {
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/ssh/Scp.java b/src/main/org/apache/tools/ant/taskdefs/optional/ssh/Scp.java
index 66c9b811c..7a09f68ac 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/ssh/Scp.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/ssh/Scp.java
@@ -1,457 +1,457 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.ssh;
 
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.FileSet;
 
 import com.jcraft.jsch.JSchException;
 import com.jcraft.jsch.Session;
 
 /**
  * Ant task for sending files to remote machine over ssh/scp.
  *
  * @since Ant 1.6
  */
 public class Scp extends SSHBase {
 
     private static final String[] FROM_ATTRS = {
         "file", "localfile", "remotefile" };
 
     private static final String[] TO_ATTRS = {
         "todir", "localtodir", "remotetodir", "localtofile", "remotetofile" };
 
     private String fromUri;
     private String toUri;
     private boolean preserveLastModified = false;
     private List fileSets = null;
     private boolean isFromRemote, isToRemote;
     private boolean isSftp = false;
 
     /**
      * Sets the file to be transferred.  This can either be a remote
      * file or a local file.  Remote files take the form:<br>
      * <i>user:password@host:/directory/path/file.example</i><br>
      * Files to transfer can also include a wildcard to include all
      * files in a remote directory.  For example:<br>
      * <i>user:password@host:/directory/path/*</i><br>
      * @param aFromUri a string representing the file to transfer.
      */
     public void setFile(final String aFromUri) {
         setFromUri(aFromUri);
         this.isFromRemote = isRemoteUri(this.fromUri);
     }
 
     /**
      * Sets the location where files will be transferred to.
      * This can either be a remote directory or a local directory.
      * Remote directories take the form of:<br>
      * <i>user:password@host:/directory/path/</i><br>
      * This parameter is required.
 
      * @param aToUri a string representing the target of the copy.
      */
     public void setTodir(final String aToUri) {
         setToUri(aToUri);
         this.isToRemote = isRemoteUri(this.toUri);
     }
 
     /**
-     * Similiar to {@link #setFile setFile} but explicitly states that
+     * Similar to {@link #setFile setFile} but explicitly states that
      * the file is a local file.  This is the only way to specify a
      * local file with a @ character.
      * @param aFromUri a string representing the source of the copy.
      * @since Ant 1.6.2
      */
     public void setLocalFile(final String aFromUri) {
         setFromUri(aFromUri);
         this.isFromRemote = false;
     }
 
     /**
-     * Similiar to {@link #setFile setFile} but explicitly states that
+     * Similar to {@link #setFile setFile} but explicitly states that
      * the file is a remote file.
      * @param aFromUri a string representing the source of the copy.
      * @since Ant 1.6.2
      */
     public void setRemoteFile(final String aFromUri) {
         validateRemoteUri("remoteFile", aFromUri);
         setFromUri(aFromUri);
         this.isFromRemote = true;
      }
 
     /**
-     * Similiar to {@link #setTodir setTodir} but explicitly states
+     * Similar to {@link #setTodir setTodir} but explicitly states
      * that the directory is a local.  This is the only way to specify
      * a local directory with a @ character.
      * @param aToUri a string representing the target of the copy.
      * @since Ant 1.6.2
      */
     public void setLocalTodir(final String aToUri) {
         setToUri(aToUri);
         this.isToRemote = false;
     }
 
     /**
      * Sets flag to determine if file timestamp from
      * remote system is to be preserved during copy.
      * @since Ant 1.8.0
      */
     public void setPreservelastmodified(final boolean yesOrNo) {
         this.preserveLastModified = yesOrNo;
     }
 
     /**
-     * Similiar to {@link #setTodir setTodir} but explicitly states
+     * Similar to {@link #setTodir setTodir} but explicitly states
      * that the directory is a remote.
      * @param aToUri a string representing the target of the copy.
      * @since Ant 1.6.2
      */
     public void setRemoteTodir(final String aToUri) {
         validateRemoteUri("remoteToDir", aToUri);
         setToUri(aToUri);
         this.isToRemote = true;
     }
 
     private static void validateRemoteUri(final String type, final String aToUri) {
         if (!isRemoteUri(aToUri)) {
             throw new BuildException(type + " '" + aToUri + "' is invalid. "
                                      + "The 'remoteToDir' attribute must "
                                      + "have syntax like the "
                                      + "following: user:password@host:/path"
                                      + " - the :password part is optional");
         }
     }
 
     /**
      * Changes the file name to the given name while receiving it,
      * only useful if receiving a single file.
      * @param aToUri a string representing the target of the copy.
      * @since Ant 1.6.2
      */
     public void setLocalTofile(final String aToUri) {
         setToUri(aToUri);
         this.isToRemote = false;
     }
 
     /**
      * Changes the file name to the given name while sending it,
      * only useful if sending a single file.
      * @param aToUri a string representing the target of the copy.
      * @since Ant 1.6.2
      */
     public void setRemoteTofile(final String aToUri) {
         validateRemoteUri("remoteToFile", aToUri);
         setToUri(aToUri);
         this.isToRemote = true;
     }
 
     /**
      * Setting this to true to use sftp protocol.
      *
      * @param yesOrNo if true sftp protocol will be used.
      */
     public void setSftp(final boolean yesOrNo) {
         isSftp = yesOrNo;
     }
 
     /**
      * Adds a FileSet transfer to remote host.  NOTE: Either
      * addFileSet() or setFile() are required.  But, not both.
      *
      * @param set FileSet to send to remote host.
      */
     public void addFileset(final FileSet set) {
         if (fileSets == null) {
             fileSets = new LinkedList();
         }
         fileSets.add(set);
     }
 
     /**
      * Initialize this task.
      * @throws BuildException on error
      */
     @Override
     public void init() throws BuildException {
         super.init();
         this.toUri = null;
         this.fromUri = null;
         this.fileSets = null;
     }
 
     /**
      * Execute this task.
      * @throws BuildException on error
      */
     @Override
     public void execute() throws BuildException {
         if (toUri == null) {
             throw exactlyOne(TO_ATTRS);
         }
         if (fromUri == null && fileSets == null) {
             throw exactlyOne(FROM_ATTRS, "one or more nested filesets");
         }
         try {
             if (isFromRemote && !isToRemote) {
                 download(fromUri, toUri);
             } else if (!isFromRemote && isToRemote) {
                 if (fileSets != null) {
                     upload(fileSets, toUri);
                 } else {
                     upload(fromUri, toUri);
                 }
             } else if (isFromRemote && isToRemote) {
                 throw new BuildException(
                     "Copying from a remote server to a remote server is not supported.");
             } else {
                 throw new BuildException("'todir' and 'file' attributes "
                     + "must have syntax like the following: "
                     + "user:password@host:/path");
             }
         } catch (final Exception e) {
             if (getFailonerror()) {
                 if(e instanceof BuildException) {
                     final BuildException be = (BuildException) e;
                     if(be.getLocation() == null) {
                         be.setLocation(getLocation());
                     }
                     throw be;
                 } else {
                     throw new BuildException(e);
                 }
             } else {
                 log("Caught exception: " + e.getMessage(), Project.MSG_ERR);
             }
         }
     }
 
     private void download(final String fromSshUri, final String toPath)
         throws JSchException, IOException {
         final String file = parseUri(fromSshUri);
 
         Session session = null;
         try {
             session = openSession();
             ScpFromMessage message = null;
             if (!isSftp) {
                 message =
                     new ScpFromMessage(getVerbose(), session, file,
                                        getProject().resolveFile(toPath),
                                        fromSshUri.endsWith("*"),
                                        preserveLastModified);
             } else {
                 message =
                     new ScpFromMessageBySftp(getVerbose(), session, file,
                                              getProject().resolveFile(toPath),
                                              fromSshUri.endsWith("*"),
                                              preserveLastModified);
             }
             log("Receiving file: " + file);
             message.setLogListener(this);
             message.execute();
         } finally {
             if (session != null) {
                 session.disconnect();
             }
         }
     }
 
     private void upload(final List fileSet, final String toSshUri)
         throws IOException, JSchException {
         final String file = parseUri(toSshUri);
 
         Session session = null;
         try {
             final List list = new ArrayList(fileSet.size());
             for (final Iterator i = fileSet.iterator(); i.hasNext();) {
                 final FileSet set = (FileSet) i.next();
                 final Directory d = createDirectory(set);
                 if (d != null) {
                     list.add(d);
                 }
             }
             if (!list.isEmpty()) {
                 session = openSession();
                 ScpToMessage message = null;
                 if (!isSftp) {
                     message = new ScpToMessage(getVerbose(), session,
                                                list, file);
                 } else {
                     message = new ScpToMessageBySftp(getVerbose(), session,
                                                      list, file);
                 }
                 message.setLogListener(this);
                 message.execute();
             }
         } finally {
             if (session != null) {
                 session.disconnect();
             }
         }
     }
 
     private void upload(final String fromPath, final String toSshUri)
         throws IOException, JSchException {
         final String file = parseUri(toSshUri);
 
         Session session = null;
         try {
             session = openSession();
             ScpToMessage message = null;
             if (!isSftp) {
                 message =
                     new ScpToMessage(getVerbose(), session,
                                      getProject().resolveFile(fromPath), file);
             } else {
                 message =
                     new ScpToMessageBySftp(getVerbose(), session,
                                            getProject().resolveFile(fromPath),
                                            file);
             }
             message.setLogListener(this);
             message.execute();
         } finally {
             if (session != null) {
                 session.disconnect();
             }
         }
     }
 
     private String parseUri(final String uri) {
 
         int indexOfAt = uri.indexOf('@');
         final int indexOfColon = uri.indexOf(':');
 
         if (indexOfColon > -1 && indexOfColon < indexOfAt) {
             // user:password@host:/path notation
             // everything upto the last @ before the last : is considered
             // password. (so if the path contains an @ and a : it will not work)
             int indexOfCurrentAt = indexOfAt;
             final int indexOfLastColon = uri.lastIndexOf(':');
             while (indexOfCurrentAt > -1 && indexOfCurrentAt < indexOfLastColon)
             {
                 indexOfAt = indexOfCurrentAt;
                 indexOfCurrentAt = uri.indexOf('@', indexOfCurrentAt + 1);
             }
             setUsername(uri.substring(0, indexOfColon));
             setPassword(uri.substring(indexOfColon + 1, indexOfAt));
         } else if (indexOfAt > -1) {
             // no password, will require keyfile
             setUsername(uri.substring(0, indexOfAt));
         } else {
             throw new BuildException("no username was given.  Can't authenticate.");
         }
 
         if (getUserInfo().getPassword() == null
             && getUserInfo().getKeyfile() == null) {
             throw new BuildException("neither password nor keyfile for user "
                                      + getUserInfo().getName() + " has been "
                                      + "given.  Can't authenticate.");
         }
 
         final int indexOfPath = uri.indexOf(':', indexOfAt + 1);
         if (indexOfPath == -1) {
             throw new BuildException("no remote path in " + uri);
         }
 
         setHost(uri.substring(indexOfAt + 1, indexOfPath));
         String remotePath = uri.substring(indexOfPath + 1);
         if (remotePath.equals("")) {
             remotePath = ".";
         }
         return remotePath;
     }
 
     private static boolean isRemoteUri(final String uri) {
         boolean isRemote = true;
         final int indexOfAt = uri.indexOf('@');
         if (indexOfAt < 0) {
             isRemote = false;
         }
         return isRemote;
     }
 
     private Directory createDirectory(final FileSet set) {
         final DirectoryScanner scanner = set.getDirectoryScanner(getProject());
         Directory root = new Directory(scanner.getBasedir());
         final String[] files = scanner.getIncludedFiles();
         if (files.length != 0) {
             for (int j = 0; j < files.length; j++) {
                 final String[] path = Directory.getPath(files[j]);
                 Directory current = root;
                 File currentParent = scanner.getBasedir();
                 for (int i = 0; i < path.length; i++) {
                     final File file = new File(currentParent, path[i]);
                     if (file.isDirectory()) {
                         current.addDirectory(new Directory(file));
                         current = current.getChild(file);
                         currentParent = current.getDirectory();
                     } else if (file.isFile()) {
                         current.addFile(file);
                     }
                 }
             }
         } else {
             // skip
             root = null;
         }
         return root;
     }
 
     private void setFromUri(final String fromUri) {
         if (this.fromUri != null) {
             throw exactlyOne(FROM_ATTRS);
         }
         this.fromUri = fromUri;
     }
 
     private void setToUri(final String toUri) {
         if (this.toUri != null) {
             throw exactlyOne(TO_ATTRS);
         }
         this.toUri = toUri;
     }
 
     private BuildException exactlyOne(final String[] attrs) {
         return exactlyOne(attrs, null);
     }
 
     private BuildException exactlyOne(final String[] attrs, final String alt) {
         final StringBuffer buf = new StringBuffer("Exactly one of ").append(
                 '[').append(attrs[0]);
         for (int i = 1; i < attrs.length; i++) {
             buf.append('|').append(attrs[i]);
         }
         buf.append(']');
         if (alt != null) {
             buf.append(" or ").append(alt);
         }
         return new BuildException(buf.append(" is required.").toString());
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/rmic/RmicAdapter.java b/src/main/org/apache/tools/ant/taskdefs/rmic/RmicAdapter.java
index 851f3d5a5..2cabe2faa 100644
--- a/src/main/org/apache/tools/ant/taskdefs/rmic/RmicAdapter.java
+++ b/src/main/org/apache/tools/ant/taskdefs/rmic/RmicAdapter.java
@@ -1,67 +1,67 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.rmic;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.taskdefs.Rmic;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.util.FileNameMapper;
 
 /**
  * The interface that all rmic adapters must adhere to.
  *
  * <p>A rmic adapter is an adapter that interprets the rmic's
- * parameters in preperation to be passed off to the compiler this
+ * parameters in preparation to be passed off to the compiler this
  * adapter represents.  As all the necessary values are stored in the
  * Rmic task itself, the only thing all adapters need is the rmic
  * task, the execute command and a parameterless constructor (for
  * reflection).</p>
  *
  * @since Ant 1.4
  */
 
 public interface RmicAdapter {
 
     /**
      * Sets the rmic attributes, which are stored in the Rmic task.
      * @param attributes the rmic attributes to use
      */
     void setRmic(Rmic attributes);
 
     /**
      * Call the rmic compiler.
      *
      * @return true if has the compilation been successful
      * @throws BuildException on error
      */
     boolean execute() throws BuildException;
 
     /**
      * Maps source class files to the files generated by this rmic
      * implementation.
      * @return the filename mapper used by this implementation
      */
     FileNameMapper getMapper();
 
     /**
      * The CLASSPATH this rmic process will use.
      * @return the classpath this rmic process will use
      */
     Path getClasspath();
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/rmic/XNewRmic.java b/src/main/org/apache/tools/ant/taskdefs/rmic/XNewRmic.java
index a5b9ad61b..559c76985 100644
--- a/src/main/org/apache/tools/ant/taskdefs/rmic/XNewRmic.java
+++ b/src/main/org/apache/tools/ant/taskdefs/rmic/XNewRmic.java
@@ -1,52 +1,52 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.rmic;
 
 import org.apache.tools.ant.types.Commandline;
 
 /**
  * Run rmic in a new process with -Xnew set.
- * This switches rmic to use a new compiler, one that doesnt work in-process
+ * This switches rmic to use a new compiler, one that doesn't work in-process
  * on ant on java1.6.
  * see: <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=38732">
  * http://issues.apache.org/bugzilla/show_bug.cgi?id=38732</a>
  */
 public class XNewRmic extends ForkingSunRmic {
 
     /**
      * the name of this adapter for users to select
      */
     public static final String COMPILER_NAME = "xnew";
 
     /** No-arg constructor. */
     public XNewRmic() {
     }
 
     /**
      * Create a normal command line, then with -Xnew at the front
      * @return a command line that hands off to thw
      */
     protected Commandline setupRmicCommand() {
         String[] options = new String[] {
                 "-Xnew"
         };
         Commandline commandline = super.setupRmicCommand(options);
         return commandline;
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/types/PropertySet.java b/src/main/org/apache/tools/ant/types/PropertySet.java
index b37602c9d..f59920445 100644
--- a/src/main/org/apache/tools/ant/types/PropertySet.java
+++ b/src/main/org/apache/tools/ant/types/PropertySet.java
@@ -1,577 +1,577 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types;
 
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Properties;
 import java.util.Set;
 import java.util.Stack;
 import java.util.TreeMap;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.resources.MappedResource;
 import org.apache.tools.ant.types.resources.PropertyResource;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.regexp.RegexpMatcher;
 import org.apache.tools.ant.util.regexp.RegexpMatcherFactory;
 
 /**
  * A set of properties.
  *
  * @since Ant 1.6
  */
 public class PropertySet extends DataType implements ResourceCollection {
 
     private boolean dynamic = true;
     private boolean negate = false;
     private Set<String> cachedNames;
     private List<PropertyRef> ptyRefs = new ArrayList<PropertyRef>();
     private List<PropertySet> setRefs = new ArrayList<PropertySet>();
     private Mapper mapper;
 
     /**
      * This is a nested class containing a reference to some properties
      * and optionally a source of properties.
      */
     public static class PropertyRef {
 
         private int count;
         private String name;
         private String regex;
         private String prefix;
         private String builtin;
 
         /**
          * Set the name.
          * @param name a <code>String</code> value.
          */
         public void setName(String name) {
             assertValid("name", name);
             this.name = name;
         }
 
         /**
          * Set the regular expression to use to filter the properties.
          * @param regex a regular expression.
          */
         public void setRegex(String regex) {
             assertValid("regex", regex);
             this.regex = regex;
         }
 
         /**
          * Set the prefix to use.
          * @param prefix a <code>String</code> value.
          */
         public void setPrefix(String prefix) {
             assertValid("prefix", prefix);
             this.prefix = prefix;
         }
 
         /**
          * Builtin property names - all, system or commandline.
          * @param b an enumerated <code>BuildinPropertySetName</code> value.
          */
         public void setBuiltin(BuiltinPropertySetName b) {
             String pBuiltIn = b.getValue();
             assertValid("builtin", pBuiltIn);
             this.builtin = pBuiltIn;
         }
 
         private void assertValid(String attr, String value) {
             if (value == null || value.length() < 1) {
                 throw new BuildException("Invalid attribute: " + attr);
             }
 
             if (++count != 1) {
                 throw new BuildException("Attributes name, regex, and "
                     + "prefix are mutually exclusive");
             }
         }
 
         /**
          * A debug toString().
          * @return a string version of this object.
          */
         public String toString() {
             return "name=" + name + ", regex=" + regex + ", prefix=" + prefix
                 + ", builtin=" + builtin;
         }
 
     } //end nested class
 
     /**
      * Allow properties of a particular name in the set.
      * @param name the property name to allow.
      */
     public void appendName(String name) {
         PropertyRef r = new PropertyRef();
         r.setName(name);
         addPropertyref(r);
     }
 
     /**
      * Allow properties whose names match a regex in the set.
      * @param regex the regular expression to use.
      */
     public void appendRegex(String regex) {
         PropertyRef r = new PropertyRef();
         r.setRegex(regex);
         addPropertyref(r);
     }
 
     /**
      * Allow properties whose names start with a prefix in the set.
      * @param prefix the prefix to use.
      */
     public void appendPrefix(String prefix) {
         PropertyRef r = new PropertyRef();
         r.setPrefix(prefix);
         addPropertyref(r);
     }
 
     /**
      * Allow builtin (all, system or commandline) properties in the set.
      * @param b the type of builtin properties.
      */
     public void appendBuiltin(BuiltinPropertySetName b) {
         PropertyRef r = new PropertyRef();
         r.setBuiltin(b);
         addPropertyref(r);
     }
 
     /**
      * Set a mapper to change property names.
      * @param type mapper type.
      * @param from source pattern.
      * @param to output pattern.
      */
     public void setMapper(String type, String from, String to) {
         Mapper m = createMapper();
         Mapper.MapperType mapperType = new Mapper.MapperType();
         mapperType.setValue(type);
         m.setType(mapperType);
         m.setFrom(from);
         m.setTo(to);
     }
 
     /**
      * Add a property reference (nested element) to the references to be used.
      * @param ref a property reference.
      */
     public void addPropertyref(PropertyRef ref) {
         assertNotReference();
         setChecked(false);
         ptyRefs.add(ref);
     }
 
     /**
      * Add another property set to this set.
      * @param ref another property set.
      */
     public void addPropertyset(PropertySet ref) {
         assertNotReference();
         setChecked(false);
         setRefs.add(ref);
     }
 
     /**
      * Create a mapper to map the property names.
      * @return a mapper to be configured.
      */
     public Mapper createMapper() {
         assertNotReference();
         if (mapper != null) {
             throw new BuildException("Too many <mapper>s!");
         }
         mapper = new Mapper(getProject());
         setChecked(false);
         return mapper;
     }
 
     /**
      * Add a nested FileNameMapper.
      * @param fileNameMapper the mapper to add.
      * @since Ant 1.6.3
      */
     public void add(FileNameMapper fileNameMapper) {
         createMapper().add(fileNameMapper);
     }
 
     /**
-     * Set whether to reevaluate the set everytime the set is used.
+     * Set whether to reevaluate the set every time the set is used.
      * Default is true.
      *
      * @param dynamic if true, reevaluate the property set each time
      *                the set is used. if false cache the property set
      *                the first time and use the cached set on subsequent
      *                occasions.
      */
     public void setDynamic(boolean dynamic) {
         assertNotReference();
         this.dynamic = dynamic;
     }
 
     /**
      * Set whether to negate results.
      * If "true", all properties not selected by nested elements will be returned.
      *  Default is "false".
      * @param negate if true, negate the selection criteria.
      */
     public void setNegate(boolean negate) {
         assertNotReference();
         this.negate = negate;
     }
 
     /**
      * Get the dynamic attribute.
      * @return true if the property set is to be evaluated each time it is used.
      */
     public boolean getDynamic() {
         if (isReference()) {
             return getRef().dynamic;
         }
         dieOnCircularReference();
         return dynamic;
     }
 
     /**
      * Get the mapper attribute.
      * @return the mapper attribute.
      */
     public Mapper getMapper() {
         if (isReference()) {
             return getRef().mapper;
         }
         dieOnCircularReference();
         return mapper;
     }
 
     /**
      * Convert the system properties to a hashtable.
      * Use propertynames to get the list of properties (including
      * default ones).
      */
     private Hashtable<String, Object> getAllSystemProperties() {
         Hashtable<String, Object>  ret = new Hashtable<String, Object>();
         for (Enumeration<?> e = System.getProperties().propertyNames();
              e.hasMoreElements();) {
             String name = (String) e.nextElement();
             ret.put(name, System.getProperties().getProperty(name));
         }
         return ret;
     }
 
     /**
      * This is the operation to get the existing or recalculated properties.
      * @return the properties for this propertyset.
      */
     public Properties getProperties() {
         final Properties result = new Properties();
         result.putAll(getPropertyMap());
         return result;
     }
 
     /**
      *
      * @return Map
      * @since 1.9.0
      */
     private Map<String, Object> getPropertyMap() {
         if (isReference()) {
             return getRef().getPropertyMap();
         }
         dieOnCircularReference();
         final Mapper myMapper = getMapper();
         final FileNameMapper m = myMapper == null ? null : myMapper.getImplementation();
 
         final Map<String, Object> effectiveProperties = getEffectiveProperties();
         final Set<String> propertyNames = getPropertyNames(effectiveProperties);
         final Map<String, Object> result = new HashMap<String, Object>();
 
         //iterate through the names, get the matching values
         for (String name : propertyNames) {
             Object value = effectiveProperties.get(name);
             // TODO should we include null properties?
             // TODO should we query the PropertyHelper for property value to grab potentially shadowed values?
             if (value != null) {
                 // may be null if a system property has been added
                 // after the project instance has been initialized
                 if (m != null) {
                     //map the names
                     String[] newname = m.mapFileName(name);
                     if (newname != null) {
                         name = newname[0];
                     }
                 }
                 result.put(name, value);
             }
         }
         return result;
 
     }
 
     private Map<String, Object> getEffectiveProperties() {
         final Project prj = getProject();
         final Map<String, Object> result = prj == null ? getAllSystemProperties() : prj.getProperties();
         //quick & dirty, to make nested mapped p-sets work:
         for (PropertySet set : setRefs) {
             result.putAll(set.getPropertyMap());
         }
         return result;
     }
 
     private Set<String> getPropertyNames(Map<String, Object> props) {
         Set<String> names;
         if (getDynamic() || cachedNames == null) {
             names = new HashSet<String>();
             addPropertyNames(names, props);
             // Add this PropertySet's nested PropertySets' property names.
             for (PropertySet set : setRefs) {
                 names.addAll(set.getPropertyMap().keySet());
             }
             if (negate) {
                 //make a copy...
                 HashSet<String> complement = new HashSet<String>(props.keySet());
                 complement.removeAll(names);
                 names = complement;
             }
             if (!getDynamic()) {
                 cachedNames = names;
             }
         } else {
             names = cachedNames;
         }
         return names;
     }
 
     /**
      * @param  names the output Set to fill with the property names
      *         matching this PropertySet selection criteria.
      * @param  props the current Project properties, passed in to
      *         avoid needless duplication of the Hashtable during recursion.
      */
     private void addPropertyNames(Set<String> names, Map<String, Object> props) {
         if (isReference()) {
             getRef().addPropertyNames(names, props);
         }
         dieOnCircularReference();
         // Add this PropertySet's property names.
         for (PropertyRef r : ptyRefs) {
             if (r.name != null) {
                 if (props.get(r.name) != null) {
                     names.add(r.name);
                 }
             } else if (r.prefix != null) {
                 for (String name : props.keySet()) {
                     if (name.startsWith(r.prefix)) {
                         names.add(name);
                     }
                 }
             } else if (r.regex != null) {
                 RegexpMatcherFactory matchMaker = new RegexpMatcherFactory();
                 RegexpMatcher matcher = matchMaker.newRegexpMatcher();
                 matcher.setPattern(r.regex);
                 for (String name : props.keySet()) {
                     if (matcher.matches(name)) {
                         names.add(name);
                     }
                 }
             } else if (r.builtin != null) {
 
                 if (r.builtin.equals(BuiltinPropertySetName.ALL)) {
                     names.addAll(props.keySet());
                 } else if (r.builtin.equals(BuiltinPropertySetName.SYSTEM)) {
                     names.addAll(getAllSystemProperties().keySet());
                 } else if (r.builtin.equals(BuiltinPropertySetName
                                               .COMMANDLINE)) {
                     names.addAll(getProject().getUserProperties().keySet());
                 } else {
                     throw new BuildException("Impossible: Invalid builtin "
                                              + "attribute!");
                 }
             } else {
                 throw new BuildException("Impossible: Invalid PropertyRef!");
             }
         }
     }
 
     /**
      * Performs the check for circular references and returns the
      * referenced PropertySet.
      * @return the referenced PropertySet.
      */
     protected PropertySet getRef() {
         return (PropertySet) getCheckedRef(PropertySet.class, "propertyset");
     }
 
     /**
      * Sets the value of the refid attribute.
      *
      * @param  r the reference this datatype should point to.
      * @throws BuildException if another attribute was set, since
      *         refid and all other attributes are mutually exclusive.
      */
     public final void setRefid(Reference r) {
         if (!noAttributeSet) {
             throw tooManyAttributes();
         }
         super.setRefid(r);
     }
 
     /**
      * Ensures this data type is not a reference.
      *
      * <p>Calling this method as the first line of every bean method of
      * this data type (setXyz, addXyz, createXyz) ensure proper handling
      * of the refid attribute.</p>
      *
      * @throws BuildException if the refid attribute was already set, since
      *         refid and all other attributes are mutually exclusive.
      */
     protected final void assertNotReference() {
         if (isReference()) {
             throw tooManyAttributes();
         }
         noAttributeSet = false;
     }
 
     /**
      * Flag which tracks whether any attribute has been set; used by
      * {@link #assertNotReference()} and {@link #setRefid(Reference)}.
      */
     private boolean noAttributeSet = true;
 
     /**
      * Used for propertyref's builtin attribute.
      */
     public static class BuiltinPropertySetName extends EnumeratedAttribute {
         static final String ALL = "all";
         static final String SYSTEM = "system";
         static final String COMMANDLINE = "commandline";
         /** {@inheritDoc}. */
         public String[] getValues() {
             return new String[] {ALL, SYSTEM, COMMANDLINE};
         }
     }
 
     /**
      * A debug toString.
      * This gets a comma separated list of key=value pairs for
      * the properties in the set.
      * The output order is sorted according to the keys' <i>natural order</i>.
      * @return a string rep of this object.
      */
     public String toString() {
         if (isReference()) {
             return getRef().toString();
         }
         dieOnCircularReference();
         StringBuilder b = new StringBuilder();
         TreeMap<String, Object> sorted = new TreeMap<String, Object>(getPropertyMap());
         for (Entry<String, Object> e : sorted.entrySet()) {
             if (b.length() != 0) {
                 b.append(", ");
             }
             b.append(e.getKey());
             b.append("=");
             b.append(e.getValue());
         }
         return b.toString();
     }
 
     /**
      * Fulfill the ResourceCollection interface.
      * @return an Iterator of Resources.
      * @since Ant 1.7
      */
     public Iterator<Resource> iterator() {
         if (isReference()) {
             return getRef().iterator();
         }
         dieOnCircularReference();
         final Set<String> names = getPropertyNames(getEffectiveProperties());
 
         Mapper myMapper = getMapper();
         final FileNameMapper m = myMapper == null ? null : myMapper.getImplementation();
         final Iterator<String> iter = names.iterator();
 
         return new Iterator<Resource>() {
             public boolean hasNext() {
                 return iter.hasNext();
             }
             public Resource next() {
                 PropertyResource p = new PropertyResource(getProject(), iter.next());
                 return m == null ? (Resource) p : new MappedResource(p, m);
             }
             public void remove() {
                 throw new UnsupportedOperationException();
             }
         };
     }
 
     /**
      * Fulfill the ResourceCollection contract.
      * @return the size of this ResourceCollection.
      */
     public int size() {
         return isReference() ? getRef().size() : getProperties().size();
     }
 
     /**
      * Fulfill the ResourceCollection contract.
      * @return whether this is a filesystem-only resource collection.
      */
     public boolean isFilesystemOnly() {
         if (isReference()) {
             return getRef().isFilesystemOnly();
         }
         dieOnCircularReference();
         return false;
     }
 
     protected synchronized void dieOnCircularReference(Stack<Object> stk, Project p)
         throws BuildException {
         if (isChecked()) {
             return;
         }
         if (isReference()) {
             super.dieOnCircularReference(stk, p);
         } else {
             if (mapper != null) {
                 pushAndInvokeCircularReferenceCheck(mapper, stk, p);
             }
             for (PropertySet propertySet : setRefs) {
                 pushAndInvokeCircularReferenceCheck(propertySet, stk,
                                                     p);
             }
             setChecked(true);
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/types/selectors/TokenizedPattern.java b/src/main/org/apache/tools/ant/types/selectors/TokenizedPattern.java
index 82884deaf..dbe7ec81c 100644
--- a/src/main/org/apache/tools/ant/types/selectors/TokenizedPattern.java
+++ b/src/main/org/apache/tools/ant/types/selectors/TokenizedPattern.java
@@ -1,177 +1,177 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types.selectors;
 
 import java.io.File;
 
 /**
  * Provides reusable path pattern matching.  PathPattern is preferable
  * to equivalent SelectorUtils methods if you need to execute multiple
  * matching with the same pattern because here the pattern itself will
  * be parsed only once.
  * @see SelectorUtils#matchPath(String, String)
  * @see SelectorUtils#matchPath(String, String, boolean)
  * @since 1.8.0
  */
 public class TokenizedPattern {
 
     /**
      * Instance that holds no tokens at all.
      */
     public static final TokenizedPattern EMPTY_PATTERN =
         new TokenizedPattern("", new String[0]);
 
     private final String pattern;
     private final String[] tokenizedPattern;
 
     /**
     * Initialize the PathPattern by parsing it.
     * @param pattern The pattern to match against. Must not be
     *                <code>null</code>.
     */
     public TokenizedPattern(String pattern) {
         this(pattern, SelectorUtils.tokenizePathAsArray(pattern));
     }
 
     TokenizedPattern(String pattern, String[] tokens) {
         this.pattern = pattern;
         this.tokenizedPattern = tokens;
     }
 
     /**
      * Tests whether or not a given path matches a given pattern.
      *
      * @param path    The path to match, as a String. Must not be
      *                <code>null</code>.
      * @param isCaseSensitive Whether or not matching should be performed
      *                        case sensitively.
      *
      * @return <code>true</code> if the pattern matches against the string,
      *         or <code>false</code> otherwise.
      */
     public boolean matchPath(TokenizedPath path, boolean isCaseSensitive) {
         return SelectorUtils.matchPath(tokenizedPattern, path.getTokens(),
                                        isCaseSensitive);
     }
 
     /**
      * Tests whether or not this pattern matches the start of
      * a path.
      */
     public boolean matchStartOf(TokenizedPath path,
                                 boolean caseSensitive) {
         return SelectorUtils.matchPatternStart(tokenizedPattern,
                                                path.getTokens(), caseSensitive);
     }
 
     /**
      * @return The pattern String
      */
     public String toString() {
         return pattern;
     }
 
     public String getPattern() {
         return pattern;
     }
 
     /**
      * true if the original patterns are equal.
      */
     public boolean equals(Object o) {
         return o instanceof TokenizedPattern
             && pattern.equals(((TokenizedPattern) o).pattern);
     }
 
     public int hashCode() {
         return pattern.hashCode();
     }
 
     /**
      * The depth (or length) of a pattern.
      */
     public int depth() {
         return tokenizedPattern.length;
     }
 
     /**
      * Does the tokenized pattern contain the given string?
      */
     public boolean containsPattern(String pat) {
         for (int i = 0; i < tokenizedPattern.length; i++) {
             if (tokenizedPattern[i].equals(pat)) {
                 return true;
             }
         }
         return false;
     }
 
     /**
      * Returns a new TokenizedPath where all tokens of this pattern to
      * the right containing wildcards have been removed
      * @return the leftmost part of the pattern without wildcards
      */
     public TokenizedPath rtrimWildcardTokens() {
         StringBuilder sb = new StringBuilder();
         int newLen = 0;
         for (; newLen < tokenizedPattern.length; newLen++) {
             if (SelectorUtils.hasWildcards(tokenizedPattern[newLen])) {
                 break;
             }
             if (newLen > 0
                 && sb.charAt(sb.length() - 1) != File.separatorChar) {
                 sb.append(File.separator);
             }
             sb.append(tokenizedPattern[newLen]);
         }
         if (newLen == 0) {
             return TokenizedPath.EMPTY_PATH;
         }
         String[] newPats = new String[newLen];
         System.arraycopy(tokenizedPattern, 0, newPats, 0, newLen);
         return new TokenizedPath(sb.toString(), newPats);
     }
 
     /**
      * true if the last token equals the given string.
      */
     public boolean endsWith(String s) {
         return tokenizedPattern.length > 0
             && tokenizedPattern[tokenizedPattern.length - 1].equals(s);
     }
 
     /**
      * Returns a new pattern without the last token of this pattern.
      */
     public TokenizedPattern withoutLastToken() {
         if (tokenizedPattern.length == 0) {
-            throw new IllegalStateException("cant strip a token from nothing");
+            throw new IllegalStateException("can't strip a token from nothing");
         } else if (tokenizedPattern.length == 1) {
             return EMPTY_PATTERN;
         } else {
             String toStrip = tokenizedPattern[tokenizedPattern.length - 1];
             int index = pattern.lastIndexOf(toStrip);
             String[] tokens = new String[tokenizedPattern.length - 1];
             System.arraycopy(tokenizedPattern, 0, tokens, 0,
                              tokenizedPattern.length - 1);
             return new TokenizedPattern(pattern.substring(0, index), tokens);
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/util/DateUtils.java b/src/main/org/apache/tools/ant/util/DateUtils.java
index 1ed95ecbf..9ce737b0a 100644
--- a/src/main/org/apache/tools/ant/util/DateUtils.java
+++ b/src/main/org/apache/tools/ant/util/DateUtils.java
@@ -1,301 +1,301 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 import java.text.ChoiceFormat;
 import java.text.DateFormat;
 import java.text.MessageFormat;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Locale;
 import java.util.TimeZone;
 
 /**
  * Helper methods to deal with date/time formatting with a specific
  * defined format (<a href="http://www.w3.org/TR/NOTE-datetime">ISO8601</a>)
  * or a plurialization correct elapsed time in minutes and seconds.
  *
  * @since Ant 1.5
  *
  */
 public final class DateUtils {
 
     private static final int ONE_SECOND = 1000;
     private static final int ONE_MINUTE = 60;
     private static final int ONE_HOUR = 60;
     private static final int TEN = 10;
     /**
      * ISO8601-like pattern for date-time. It does not support timezone.
      *  <tt>yyyy-MM-ddTHH:mm:ss</tt>
      */
     public static final String ISO8601_DATETIME_PATTERN
             = "yyyy-MM-dd'T'HH:mm:ss";
 
     /**
      * ISO8601-like pattern for date. <tt>yyyy-MM-dd</tt>
      */
     public static final String ISO8601_DATE_PATTERN
             = "yyyy-MM-dd";
 
     /**
      * ISO8601-like pattern for time.  <tt>HH:mm:ss</tt>
      */
     public static final String ISO8601_TIME_PATTERN
             = "HH:mm:ss";
 
     /**
      * Format used for SMTP (and probably other) Date headers.
      * @deprecated DateFormat is not thread safe, and we cannot guarantee that
      * some other code is using the format in parallel.
      * Deprecated since ant 1.8
      */
     public static final DateFormat DATE_HEADER_FORMAT
         = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss ", Locale.US);
 
     private static final DateFormat DATE_HEADER_FORMAT_INT
     = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss ", Locale.US);
 
 
 // code from Magesh moved from DefaultLogger and slightly modified
     private static final MessageFormat MINUTE_SECONDS
             = new MessageFormat("{0}{1}");
 
     private static final double[] LIMITS = {0, 1, 2};
 
     private static final String[] MINUTES_PART = {"", "1 minute ", "{0,number,###############} minutes "};
 
     private static final String[] SECONDS_PART = {"0 seconds", "1 second", "{1,number} seconds"};
 
     private static final ChoiceFormat MINUTES_FORMAT =
             new ChoiceFormat(LIMITS, MINUTES_PART);
 
     private static final ChoiceFormat SECONDS_FORMAT =
             new ChoiceFormat(LIMITS, SECONDS_PART);
 
     static {
         MINUTE_SECONDS.setFormat(0, MINUTES_FORMAT);
         MINUTE_SECONDS.setFormat(1, SECONDS_FORMAT);
     }
 
     /** private constructor */
     private DateUtils() {
     }
 
 
     /**
      * Format a date/time into a specific pattern.
      * @param date the date to format expressed in milliseconds.
      * @param pattern the pattern to use to format the date.
      * @return the formatted date.
      */
     public static String format(long date, String pattern) {
         return format(new Date(date), pattern);
     }
 
 
     /**
      * Format a date/time into a specific pattern.
      * @param date the date to format expressed in milliseconds.
      * @param pattern the pattern to use to format the date.
      * @return the formatted date.
      */
     public static String format(Date date, String pattern) {
         DateFormat df = createDateFormat(pattern);
         return df.format(date);
     }
 
 
     /**
      * Format an elapsed time into a plurialization correct string.
      * It is limited only to report elapsed time in minutes and
      * seconds and has the following behavior.
      * <ul>
      * <li>minutes are not displayed when 0. (ie: "45 seconds")</li>
      * <li>seconds are always displayed in plural form (ie "0 seconds" or
      * "10 seconds") except for 1 (ie "1 second")</li>
      * </ul>
      * @param millis the elapsed time to report in milliseconds.
      * @return the formatted text in minutes/seconds.
      */
     public static String formatElapsedTime(long millis) {
         long seconds = millis / ONE_SECOND;
         long minutes = seconds / ONE_MINUTE;
         Object[] args = {new Long(minutes), new Long(seconds % ONE_MINUTE)};
         return MINUTE_SECONDS.format(args);
     }
 
     /**
      * return a lenient date format set to GMT time zone.
      * @param pattern the pattern used for date/time formatting.
      * @return the configured format for this pattern.
      */
     private static DateFormat createDateFormat(String pattern) {
         SimpleDateFormat sdf = new SimpleDateFormat(pattern);
         TimeZone gmt = TimeZone.getTimeZone("GMT");
         sdf.setTimeZone(gmt);
         sdf.setLenient(true);
         return sdf;
     }
 
     /**
      * Calculate the phase of the moon for a given date.
      *
      * <p>Code heavily influenced by hacklib.c in <a
      * href="http://www.nethack.org/">Nethack</a></p>
      *
      * <p>The Algorithm:
      *
      * <pre>
      * moon period = 29.53058 days ~= 30, year = 365.2422 days
      *
      * days moon phase advances on first day of year compared to preceding year
      *  = 365.2422 - 12*29.53058 ~= 11
      *
      * years in Metonic cycle (time until same phases fall on the same days of
      *  the month) = 18.6 ~= 19
      *
      * moon phase on first day of year (epact) ~= (11*(year%19) + 18) % 30
      *  (18 as initial condition for 1900)
      *
      * current phase in days = first day phase + days elapsed in year
      *
      * 6 moons ~= 177 days
      * 177 ~= 8 reported phases * 22
      * + 11/22 for rounding
      * </pre>
      *
-     * @param cal the calander.
+     * @param cal the calendar.
      *
      * @return The phase of the moon as a number between 0 and 7 with
      *         0 meaning new moon and 4 meaning full moon.
      *
      * @since 1.2, Ant 1.5
      */
     public static int getPhaseOfMoon(Calendar cal) {
         // CheckStyle:MagicNumber OFF
         int dayOfTheYear = cal.get(Calendar.DAY_OF_YEAR);
         int yearInMetonicCycle = ((cal.get(Calendar.YEAR) - 1900) % 19) + 1;
         int epact = (11 * yearInMetonicCycle + 18) % 30;
         if ((epact == 25 && yearInMetonicCycle > 11) || epact == 24) {
             epact++;
         }
         return (((((dayOfTheYear + epact) * 6) + 11) % 177) / 22) & 7;
         // CheckStyle:MagicNumber ON
     }
 
     /**
      * Returns the current Date in a format suitable for a SMTP date
      * header.
      * @return the current date.
      * @since Ant 1.5.2
      */
     public static String getDateForHeader() {
         Calendar cal = Calendar.getInstance();
         TimeZone tz = cal.getTimeZone();
         int offset = tz.getOffset(cal.get(Calendar.ERA),
                                   cal.get(Calendar.YEAR),
                                   cal.get(Calendar.MONTH),
                                   cal.get(Calendar.DAY_OF_MONTH),
                                   cal.get(Calendar.DAY_OF_WEEK),
                                   cal.get(Calendar.MILLISECOND));
         StringBuffer tzMarker = new StringBuffer(offset < 0 ? "-" : "+");
         offset = Math.abs(offset);
         int hours = offset / (ONE_HOUR * ONE_MINUTE * ONE_SECOND);
         int minutes = offset / (ONE_MINUTE * ONE_SECOND) - ONE_HOUR * hours;
         if (hours < TEN) {
             tzMarker.append("0");
         }
         tzMarker.append(hours);
         if (minutes < TEN) {
             tzMarker.append("0");
         }
         tzMarker.append(minutes);
         synchronized (DATE_HEADER_FORMAT_INT) {
             return DATE_HEADER_FORMAT_INT.format(cal.getTime()) + tzMarker.toString();
         }
     }
 
     /**
      * Parses the string in a format suitable for a SMTP date header.
      *
      * @param datestr string to be parsed
      *
      * @return a java.util.Date object as parsed by the format.
      * @exception ParseException if the supplied string cannot be parsed by
      * this pattern.
      * @since Ant 1.8.0
      */
     public static Date parseDateFromHeader(String datestr) throws ParseException {
         synchronized (DATE_HEADER_FORMAT_INT) {
             return DATE_HEADER_FORMAT_INT.parse(datestr);
         }
     }
 
     /**
      * Parse a string as a datetime using the ISO8601_DATETIME format which is
      * <code>yyyy-MM-dd'T'HH:mm:ss</code>
      *
      * @param datestr string to be parsed
      *
      * @return a java.util.Date object as parsed by the format.
      * @exception ParseException if the supplied string cannot be parsed by
      * this pattern.
      * @since Ant 1.6
      */
     public static Date parseIso8601DateTime(String datestr)
         throws ParseException {
         return new SimpleDateFormat(ISO8601_DATETIME_PATTERN).parse(datestr);
     }
 
     /**
      * Parse a string as a date using the ISO8601_DATE format which is
      * <code>yyyy-MM-dd</code>
      *
      * @param datestr string to be parsed
      *
      * @return a java.util.Date object as parsed by the format.
      * @exception ParseException if the supplied string cannot be parsed by
      * this pattern.
      * @since Ant 1.6
      */
     public static Date parseIso8601Date(String datestr) throws ParseException {
         return new SimpleDateFormat(ISO8601_DATE_PATTERN).parse(datestr);
     }
 
     /**
      * Parse a string as a date using the either the ISO8601_DATETIME
      * or ISO8601_DATE formats.
      *
      * @param datestr string to be parsed
      *
      * @return a java.util.Date object as parsed by the formats.
      * @exception ParseException if the supplied string cannot be parsed by
      * either of these patterns.
      * @since Ant 1.6
      */
     public static Date parseIso8601DateTimeOrDate(String datestr)
         throws ParseException {
         try {
             return parseIso8601DateTime(datestr);
         } catch (ParseException px) {
             return parseIso8601Date(datestr);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/util/LineOrientedOutputStream.java b/src/main/org/apache/tools/ant/util/LineOrientedOutputStream.java
index 1d081bf42..073a89f1e 100644
--- a/src/main/org/apache/tools/ant/util/LineOrientedOutputStream.java
+++ b/src/main/org/apache/tools/ant/util/LineOrientedOutputStream.java
@@ -1,158 +1,158 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.util;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 
 /**
  * Invokes {@link #processLine processLine} whenever a full line has
  * been written to this stream.
  *
  * <p>Tries to be smart about line separators.</p>
  */
 public abstract class LineOrientedOutputStream extends OutputStream {
 
     /** Initial buffer size. */
-    private static final int INTIAL_SIZE = 132;
+    private static final int INITIAL_SIZE = 132;
 
     /** Carriage return */
     private static final int CR = 0x0d;
 
     /** Linefeed */
     private static final int LF = 0x0a;
 
     private ByteArrayOutputStream buffer
-        = new ByteArrayOutputStream(INTIAL_SIZE);
+        = new ByteArrayOutputStream(INITIAL_SIZE);
     private boolean skip = false;
 
     /**
      * Write the data to the buffer and flush the buffer, if a line
      * separator is detected.
      *
      * @param cc data to log (byte).
      * @throws IOException if there is an error.
      */
     @Override
     public final void write(int cc) throws IOException {
         final byte c = (byte) cc;
         if ((c == LF) || (c == CR)) {
             if (!skip) {
               processBuffer();
             }
         } else {
             buffer.write(cc);
         }
         skip = (c == CR);
     }
 
     /**
      * Flush this log stream
      * @throws IOException if there is an error.
      */
     @Override
     public void flush() throws IOException {
     }
 
     /**
      * Converts the buffer to a byte[] and sends it to
      * <code>processLine</code>
      * @throws IOException if there is an error.
      */
     protected void processBuffer() throws IOException {
         try {
             processLine(buffer.toByteArray());
         } finally {
             buffer.reset();
         }
     }
 
     /**
      * Processes a line.
      *
      * @param line the line to log.
      * @throws IOException if there is an error.
      */
     protected abstract void processLine(String line) throws IOException;
 
     /**
      * Processes a line.
      *
      * <p>This implementations invokes the string-arg version
      * converting the byte array using the default encoding.
      * Subclasses are encouraged to override this method (and provide
      * a dummy implementation of the String-arg version) so they don't
      * interfere with the encoding of the underlying stream.</p>
      *
      * @param line the line to log.
      * @throws IOException if there is an error.
      * @since Ant 1.8.3
      */
     protected void processLine(byte[] line) throws IOException {
         processLine(new String(line));
     }
 
     /**
      * Writes all remaining
      * @throws IOException if there is an error.
      */
     @Override
     public void close() throws IOException {
         if (buffer.size() > 0) {
             processBuffer();
         }
         super.close();
     }
 
     /**
      * Write a block of characters to the output stream
      *
      * @param b the array containing the data
      * @param off the offset into the array where data starts
      * @param len the length of block
      *
      * @throws IOException if the data cannot be written into the stream.
      */
     @Override
     public final void write(byte[] b, int off, int len) throws IOException {
         // find the line breaks and pass other chars through in blocks
         int offset = off;
         int blockStartOffset = offset;
         int remaining = len;
         while (remaining > 0) {
             while (remaining > 0 && b[offset] != LF && b[offset] != CR) {
                 offset++;
                 remaining--;
             }
             // either end of buffer or a line separator char
             int blockLength = offset - blockStartOffset;
             if (blockLength > 0) {
                 buffer.write(b, blockStartOffset, blockLength);
             }
             while (remaining > 0 && (b[offset] == LF || b[offset] == CR)) {
                 write(b[offset]);
                 offset++;
                 remaining--;
             }
             blockStartOffset = offset;
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/util/regexp/RegexpMatcherFactory.java b/src/main/org/apache/tools/ant/util/regexp/RegexpMatcherFactory.java
index ff221d10a..a0a8a155c 100644
--- a/src/main/org/apache/tools/ant/util/regexp/RegexpMatcherFactory.java
+++ b/src/main/org/apache/tools/ant/util/regexp/RegexpMatcherFactory.java
@@ -1,114 +1,114 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util.regexp;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.MagicNames;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.util.ClasspathUtils;
 
 /**
  * Simple Factory Class that produces an implementation of RegexpMatcher based on the system
  * property <code>ant.regexp.regexpimpl</code> and the classes available.
  *
  * <p>
  * In a more general framework this class would be abstract and have a static newInstance method.
  * </p>
  *
  */
 public class RegexpMatcherFactory {
 
     /** Constructor for RegexpMatcherFactory. */
     public RegexpMatcherFactory() {
     }
 
     /***
      * Create a new regular expression instance.
      * @return the matcher
      * @throws BuildException on error
      */
     public RegexpMatcher newRegexpMatcher() throws BuildException {
         return newRegexpMatcher(null);
     }
 
     /***
      * Create a new regular expression instance.
      *
      * @param p Project whose ant.regexp.regexpimpl property will be used.
      * @return the matcher
      * @throws BuildException on error
      */
     public RegexpMatcher newRegexpMatcher(Project p) throws BuildException {
         String systemDefault = null;
         if (p == null) {
             systemDefault = System.getProperty(MagicNames.REGEXP_IMPL);
         } else {
             systemDefault = p.getProperty(MagicNames.REGEXP_IMPL);
         }
 
         if (systemDefault != null) {
             return createInstance(systemDefault);
             // TODO     should we silently catch possible exceptions and try to
             //         load a different implementation?
         }
 
         return new Jdk14RegexpMatcher();
     }
 
     /**
      * Create an instance of a matcher from a classname.
      *
      * @param className a <code>String</code> value
      * @return a <code>RegexpMatcher</code> value
      * @exception BuildException if an error occurs
      */
     protected RegexpMatcher createInstance(String className) throws BuildException {
         return (RegexpMatcher) ClasspathUtils.newInstance(className, RegexpMatcherFactory.class
                 .getClassLoader(), RegexpMatcher.class);
     }
 
     /**
      * Test if a particular class is available to be used.
      *
      * @param className a <code>String</code> value
      * @exception BuildException if an error occurs
      */
     protected void testAvailability(String className) throws BuildException {
         try {
             Class.forName(className);
         } catch (Throwable t) {
             throw new BuildException(t);
         }
     }
 
     /**
      * Checks if a RegExp-Matcher is available.
      * @param project  The project to check for (may be <code>null</code>)
      * @return <code>true</code> if available otherwise <code>false</code>
      */
     public static boolean regexpMatcherPresent(Project project) {
         try {
             // The factory throws a BuildException if no usable matcher
-            // cant be instantiated. We dont need the matcher itself here.
+            // cannot be instantiated. We dont need the matcher itself here.
             new RegexpMatcherFactory().newRegexpMatcher(project);
             return true;
         } catch (Throwable ex) {
             return false;
         }
     }
 }
diff --git a/src/main/org/apache/tools/bzip2/BlockSort.java b/src/main/org/apache/tools/bzip2/BlockSort.java
index f997bab39..eb9066ee9 100644
--- a/src/main/org/apache/tools/bzip2/BlockSort.java
+++ b/src/main/org/apache/tools/bzip2/BlockSort.java
@@ -1,1081 +1,1081 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
 package org.apache.tools.bzip2;
 
 import java.util.BitSet;
 
 /**
  * Encapsulates the Burrows-Wheeler sorting algorithm needed by {@link
  * CBZip2OutputStream}.
  *
  * <p>This class is based on a Java port of Julian Seward's
  * blocksort.c in his libbzip2</p>
  *
  * <p>The Burrows-Wheeler transform is a reversible transform of the
- * original data that is supposed to group similiar bytes close to
+ * original data that is supposed to group similar bytes close to
  * each other.  The idea is to sort all permutations of the input and
  * only keep the last byte of each permutation.  E.g. for "Commons
  * Compress" you'd get:</p>
  *
  * <pre>
  *  CompressCommons
  * Commons Compress
  * CompressCommons 
  * essCommons Compr
  * mmons CompressCo
  * mons CompressCom
  * mpressCommons Co
  * ns CompressCommo
  * ommons CompressC
  * ompressCommons C
  * ons CompressComm
  * pressCommons Com
  * ressCommons Comp
  * s CompressCommon
  * sCommons Compres
  * ssCommons Compre
  * </pre>
  *
  * <p>Which results in a new text "ss romooCCmmpnse", in adition the
  * index of the first line that contained the original text is kept -
  * in this case it is 1.  The idea is that in a long English text all
  * permutations that start with "he" are likely suffixes of a "the" and
  * thus they end in "t" leading to a larger block of "t"s that can
  * better be compressed by the subsequent Move-to-Front, run-length
  * und Huffman encoding steps.</p>
  *
  * <p>For more information see for example:</p>
  * <ul>
  *   <li><a
  *   href="http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-124.pdf">Burrows,
  *   M. and Wheeler, D.: A Block-sorting Lossless Data Compression
  *   Algorithm</a></li>
  *   <li><a href="http://webglimpse.net/pubs/suffix.pdf">Manber, U. and
  *   Myers, G.: Suffix arrays: A new method for on-line string
  *   searches</a></li>
  *   <li><a
  *   href="http://www.cs.tufts.edu/~nr/comp150fp/archive/bob-sedgewick/fast-strings.pdf">Bentley,
  *   J.L. and Sedgewick, R.: Fast Algorithms for Sorting and Searching
  *   Strings</a></li>
  * </ul>
  *
  * @NotThreadSafe
  */
 class BlockSort {
 
     /*
      * Some of the constructs used in the C code cannot be ported
      * literally to Java - for example macros, unsigned types.  Some
      * code has been hand-tuned to improve performance.  In order to
      * avoid memory pressure some structures are reused for several
      * blocks and some memory is even shared between sorting and the
      * MTF stage even though either algorithm uses it for its own
      * purpose.
      *
      * Comments preserved from the actual C code are prefixed with
      * "LBZ2:".
      */
 
     /*
      * 2012-05-20 Stefan Bodewig:
      *
      * This class seems to mix several revisions of libbzip2's code.
      * The mainSort function and those used by it look closer to the
      * 0.9.5 version but show some variations introduced later.  At
      * the same time the logic of Compress 1.4 to randomize the block
      * on bad input has been dropped after libbzip2 0.9.0 and replaced
      * by a fallback sorting algorithm.
      *
      * I've added the fallbackSort function of 1.0.6 and tried to
      * integrate it with the existing code without touching too much.
      * I've also removed the now unused randomization code.
      */
 
     /*
      * LBZ2: If you are ever unlucky/improbable enough to get a stack
      * overflow whilst sorting, increase the following constant and
      * try again. In practice I have never seen the stack go above 27
      * elems, so the following limit seems very generous.
      */
     private static final int QSORT_STACK_SIZE = 1000;
 
     private static final int FALLBACK_QSORT_STACK_SIZE = 100;
 
     private static final int STACK_SIZE =
         QSORT_STACK_SIZE < FALLBACK_QSORT_STACK_SIZE
         ? FALLBACK_QSORT_STACK_SIZE : QSORT_STACK_SIZE;
 
     /*
      * Used when sorting. If too many long comparisons happen, we stop sorting,
      * and use fallbackSort instead.
      */
     private int workDone;
     private int workLimit;
     private boolean firstAttempt;
 
     private final int[] stack_ll = new int[STACK_SIZE]; // 4000 byte
     private final int[] stack_hh = new int[STACK_SIZE]; // 4000 byte
     private final int[] stack_dd = new int[QSORT_STACK_SIZE]; // 4000 byte
 
     private final int[] mainSort_runningOrder = new int[256]; // 1024 byte
     private final int[] mainSort_copy = new int[256]; // 1024 byte
     private final boolean[] mainSort_bigDone = new boolean[256]; // 256 byte
 
     private final int[] ftab = new int[65537]; // 262148 byte
 
     /**
      * Array instance identical to Data's sfmap, both are used only
      * temporarily and indepently, so we do not need to allocate
      * additional memory.
      */
     private final char[] quadrant;
 
     BlockSort(final CBZip2OutputStream.Data data) {
         this.quadrant = data.sfmap;
     }
 
     void blockSort(final CBZip2OutputStream.Data data, final int last) {
         this.workLimit = WORK_FACTOR * last;
         this.workDone = 0;
         this.firstAttempt = true;
 
         if (last + 1 < 10000) {
             fallbackSort(data, last);
         } else {
             mainSort(data, last);
 
             if (this.firstAttempt && (this.workDone > this.workLimit)) {
                 fallbackSort(data, last);
             }
         }
 
         final int[] fmap = data.fmap;
         data.origPtr = -1;
         for (int i = 0; i <= last; i++) {
             if (fmap[i] == 0) {
                 data.origPtr = i;
                 break;
             }
         }
 
         // assert (data.origPtr != -1) : data.origPtr;
     }
 
     /**
      * Adapt fallbackSort to the expected interface of the rest of the
      * code, in particular deal with the fact that block starts at
      * offset 1 (in libbzip2 1.0.6 it starts at 0).
      */
     final void fallbackSort(final CBZip2OutputStream.Data data,
                             final int last) {
         data.block[0] = data.block[last + 1];
         fallbackSort(data.fmap, data.block, last + 1);
         for (int i = 0; i < last + 1; i++) {
             --data.fmap[i];
         }
         for (int i = 0; i < last + 1; i++) {
             if (data.fmap[i] == -1) {
                 data.fmap[i] = last;
                 break;
             }
         }
     }
 
 /*---------------------------------------------*/
 
 /*---------------------------------------------*/
 /*--- LBZ2: Fallback O(N log(N)^2) sorting        ---*/
 /*--- algorithm, for repetitive blocks      ---*/
 /*---------------------------------------------*/
 
     /*
      * This is the fallback sorting algorithm libbzip2 1.0.6 uses for
      * repetitive or very short inputs.
      *
      * The idea is inspired by Manber-Myers string suffix sorting
      * algorithm.  First a bucket sort places each permutation of the
      * block into a bucket based on its first byte.  Permutations are
      * represented by pointers to their first character kept in
      * (partially) sorted order inside the array ftab.
      *
      * The next step visits all buckets in order and performs a
      * quicksort on all permutations of the bucket based on the index
      * of the bucket the second byte of the permutation belongs to,
      * thereby forming new buckets.  When arrived here the
      * permutations are sorted up to the second character and we have
      * buckets of permutations that are identical up to two
      * characters.
      *
      * Repeat the step of quicksorting each bucket, now based on the
      * bucket holding the sequence of the third and forth character
      * leading to four byte buckets.  Repeat this doubling of bucket
      * sizes until all buckets only contain single permutations or the
      * bucket size exceeds the block size.
      *
      * I.e.
      *
      * "abraba" form three buckets for the chars "a", "b", and "r" in
      * the first step with
      *
      * fmap = { 'a:' 5, 3, 0, 'b:' 4, 1, 'r', 2 }
      *
      * when looking at the bucket of "a"s the second characters are in
      * the buckets that start with fmap-index 0 (rolled over), 3 and 3
      * respectively, forming two new buckets "aa" and "ab", so we get
      *
      * fmap = { 'aa:' 5, 'ab:' 3, 0, 'ba:' 4, 'br': 1, 'ra:' 2 }
      *
      * since the last bucket only contained a single item it didn't
      * have to be sorted at all.
      *
      * There now is just one bucket with more than one permutation
      * that remains to be sorted.  For the permutation that starts
      * with index 3 the third and forth char are in bucket 'aa' at
      * index 0 and for the one starting at block index 0 they are in
      * bucket 'ra' with sort index 5.  The fully sorted order then becomes.
      *
      * fmap = { 5, 3, 0, 4, 1, 2 }
      * 
      */
 
     /**
      * @param fmap points to the index of the starting point of a
      *        permutation inside the block of data in the current
      *        partially sorted order
      * @param eclass points from the index of a character inside the
      *        block to the first index in fmap that contains the
      *        bucket of its suffix that is sorted in this step.
      * @param lo lower boundary of the fmap-interval to be sorted 
      * @param hi upper boundary of the fmap-interval to be sorted 
      */
     private void fallbackSimpleSort(int[] fmap, 
                                     int[] eclass, 
                                     int lo, 
                                     int hi) {
         if (lo == hi) {
             return;
         }
 
         int j;
         if (hi - lo > 3) {
             for (int i = hi - 4; i >= lo; i--) {
                 int tmp = fmap[i];
                 int ec_tmp = eclass[tmp];
                 for (j = i + 4; j <= hi && ec_tmp > eclass[fmap[j]];
                      j += 4) {
                     fmap[j - 4] = fmap[j];
                 }
                 fmap[j - 4] = tmp;
             }
         }
 
         for (int i = hi - 1; i >= lo; i--) {
             int tmp = fmap[i];
             int ec_tmp = eclass[tmp];
             for (j = i + 1; j <= hi && ec_tmp > eclass[fmap[j]]; j++) {
                 fmap[j - 1] = fmap[j];
             }
             fmap[j-1] = tmp;
         }
     }
 
     private static final int FALLBACK_QSORT_SMALL_THRESH = 10;
 
     /**
      * swaps two values in fmap
      */
     private void fswap(int[] fmap, int zz1, int zz2) {
         int zztmp = fmap[zz1];
         fmap[zz1] = fmap[zz2];
         fmap[zz2] = zztmp;
     }
 
     /**
      * swaps two intervals starting at yyp1 and yyp2 of length yyn inside fmap.
      */
     private void fvswap(int[] fmap, int yyp1, int yyp2, int yyn) {
         while (yyn > 0) {
             fswap(fmap, yyp1, yyp2);
             yyp1++; yyp2++; yyn--;
         }
     }
 
     private int fmin(int a, int b) {
         return a < b ? a : b;
     }
 
     private void fpush(int sp, int lz, int hz) {
         stack_ll[sp] = lz;
         stack_hh[sp] = hz;
     }
 
     private int[] fpop(int sp) {
         return new int[] { stack_ll[sp], stack_hh[sp] };
     }
 
     /**
      * @param fmap points to the index of the starting point of a
      *        permutation inside the block of data in the current
      *        partially sorted order
      * @param eclass points from the index of a character inside the
      *        block to the first index in fmap that contains the
      *        bucket of its suffix that is sorted in this step.
      * @param loSt lower boundary of the fmap-interval to be sorted 
      * @param hiSt upper boundary of the fmap-interval to be sorted 
      */
     private void fallbackQSort3(int[] fmap, 
                                 int[] eclass, 
                                 int loSt, 
                                 int hiSt) {
         int lo, unLo, ltLo, hi, unHi, gtHi, n;
 
         long r = 0;
         int sp = 0;
         fpush(sp++, loSt, hiSt);
 
         while (sp > 0) {
             int[] s = fpop(--sp);
             lo = s[0]; hi = s[1];
 
             if (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {
                 fallbackSimpleSort(fmap, eclass, lo, hi);
                 continue;
             }
 
             /* LBZ2: Random partitioning.  Median of 3 sometimes fails to
                avoid bad cases.  Median of 9 seems to help but 
                looks rather expensive.  This too seems to work but
                is cheaper.  Guidance for the magic constants 
                7621 and 32768 is taken from Sedgewick's algorithms
                book, chapter 35.
             */
             r = ((r * 7621) + 1) % 32768;
             long r3 = r % 3, med;
             if (r3 == 0) {
                 med = eclass[fmap[lo]]; 
             } else if (r3 == 1) {
                 med = eclass[fmap[(lo + hi) >>> 1]];
             } else {
                 med = eclass[fmap[hi]];
             }
 
             unLo = ltLo = lo;
             unHi = gtHi = hi;
 
             // looks like the ternary partition attributed to Wegner
             // in the cited Sedgewick paper
             while (true) {
                 while (true) {
                     if (unLo > unHi) {
                         break;
                     }
                     n = eclass[fmap[unLo]] - (int) med;
                     if (n == 0) { 
                         fswap(fmap, unLo, ltLo); 
                         ltLo++; unLo++; 
                         continue; 
                     }
                     if (n > 0) {
                         break;
                     }
                     unLo++;
                 }
                 while (true) {
                     if (unLo > unHi) {
                         break;
                     }
                     n = eclass[fmap[unHi]] - (int) med;
                     if (n == 0) {
                         fswap(fmap, unHi, gtHi); 
                         gtHi--; unHi--; 
                         continue; 
                     }
                     if (n < 0) {
                         break;
                     }
                     unHi--;
                 }
                 if (unLo > unHi) {
                     break;
                 }
                 fswap(fmap, unLo, unHi); unLo++; unHi--;
             }
 
             if (gtHi < ltLo) {
                 continue;
             }
 
             n = fmin(ltLo - lo, unLo - ltLo);
             fvswap(fmap, lo, unLo - n, n);
             int m = fmin(hi - gtHi, gtHi - unHi);
             fvswap(fmap, unHi + 1, hi - m + 1, m);
 
             n = lo + unLo - ltLo - 1;
             m = hi - (gtHi - unHi) + 1;
 
             if (n - lo > hi - m) {
                 fpush(sp++, lo, n);
                 fpush(sp++, m, hi);
             } else {
                 fpush(sp++, m, hi);
                 fpush(sp++, lo, n);
             }
         }
     }
 
 
 /*---------------------------------------------*/
 
     private int[] eclass;
 
     private int[] getEclass() {
         return eclass == null
             ? (eclass = new int[quadrant.length / 2]) : eclass;
     }
 
     /*
      * The C code uses an array of ints (each int holding 32 flags) to
      * represents the bucket-start flags (bhtab).  It also contains
      * optimizations to skip over 32 consecutively set or
      * consecutively unset bits on word boundaries at once.  For now
      * I've chosen to use the simpler but potentially slower code
      * using BitSet - also in the hope that using the BitSet#nextXXX
      * methods may be fast enough.
      */
 
     /**
      * @param fmap points to the index of the starting point of a
      *        permutation inside the block of data in the current
      *        partially sorted order
      * @param block the original data
      * @param nblock size of the block
      * @param off offset of first byte to sort in block
      */
     final void fallbackSort(int[] fmap, byte[] block, int nblock) {
         final int[] ftab = new int[257];
         int H, i, j, k, l, r, cc, cc1;
         int nNotDone;
         int nBhtab;
         final int[] eclass = getEclass();
 
         for (i = 0; i < nblock; i++) {
             eclass[i] = 0;
         }
         /*--
           LBZ2: Initial 1-char radix sort to generate
           initial fmap and initial BH bits.
           --*/
         for (i = 0; i < nblock; i++) {
             ftab[block[i] & 0xff]++;
         }
         for (i = 1; i < 257;    i++) {
             ftab[i] += ftab[i - 1];
         }
 
         for (i = 0; i < nblock; i++) {
             j = block[i] & 0xff;
             k = ftab[j] - 1;
             ftab[j] = k;
             fmap[k] = i;
         }
 
         nBhtab = 64 + nblock;
         BitSet bhtab = new BitSet(nBhtab);
         for (i = 0; i < 256; i++) {
             bhtab.set(ftab[i]);
         }
 
         /*--
           LBZ2: Inductively refine the buckets.  Kind-of an
           "exponential radix sort" (!), inspired by the
           Manber-Myers suffix array construction algorithm.
           --*/
 
         /*-- LBZ2: set sentinel bits for block-end detection --*/
         for (i = 0; i < 32; i++) { 
             bhtab.set(nblock + 2 * i);
             bhtab.clear(nblock + 2 * i + 1);
         }
 
         /*-- LBZ2: the log(N) loop --*/
         H = 1;
         while (true) {
 
             j = 0;
             for (i = 0; i < nblock; i++) {
                 if (bhtab.get(i)) {
                     j = i;
                 }
                 k = fmap[i] - H;
                 if (k < 0) {
                     k += nblock;
                 }
                 eclass[k] = j;
             }
 
             nNotDone = 0;
             r = -1;
             while (true) {
 
                 /*-- LBZ2: find the next non-singleton bucket --*/
                 k = r + 1;
                 k = bhtab.nextClearBit(k);
                 l = k - 1;
                 if (l >= nblock) {
                     break;
                 }
                 k = bhtab.nextSetBit(k + 1);
                 r = k - 1;
                 if (r >= nblock) {
                     break;
                 }
 
                 /*-- LBZ2: now [l, r] bracket current bucket --*/
                 if (r > l) {
                     nNotDone += (r - l + 1);
                     fallbackQSort3(fmap, eclass, l, r);
 
                     /*-- LBZ2: scan bucket and generate header bits-- */
                     cc = -1;
                     for (i = l; i <= r; i++) {
                         cc1 = eclass[fmap[i]];
                         if (cc != cc1) {
                             bhtab.set(i);
                             cc = cc1;
                         }
                     }
                 }
             }
 
             H *= 2;
             if (H > nblock || nNotDone == 0) {
                 break;
             }
         }
     }
 
 /*---------------------------------------------*/
 
     /*
      * LBZ2: Knuth's increments seem to work better than Incerpi-Sedgewick here.
      * Possibly because the number of elems to sort is usually small, typically
      * &lt;= 20.
      */
     private static final int[] INCS = { 1, 4, 13, 40, 121, 364, 1093, 3280,
                                         9841, 29524, 88573, 265720, 797161,
                                         2391484 };
 
     /**
      * This is the most hammered method of this class.
      *
      * <p>
      * This is the version using unrolled loops. Normally I never use such ones
-     * in Java code. The unrolling has shown a noticable performance improvement
+     * in Java code. The unrolling has shown a noticeable performance improvement
      * on JRE 1.4.2 (Linux i586 / HotSpot Client). Of course it depends on the
      * JIT compiler of the vm.
      * </p>
      */
     private boolean mainSimpleSort(final CBZip2OutputStream.Data dataShadow,
                                    final int lo, final int hi, final int d,
                                    final int lastShadow) {
         final int bigN = hi - lo + 1;
         if (bigN < 2) {
             return this.firstAttempt && (this.workDone > this.workLimit);
         }
 
         int hp = 0;
         while (INCS[hp] < bigN) {
             hp++;
         }
 
         final int[] fmap = dataShadow.fmap;
         final char[] quadrant = this.quadrant;
         final byte[] block = dataShadow.block;
         final int lastPlus1 = lastShadow + 1;
         final boolean firstAttemptShadow = this.firstAttempt;
         final int workLimitShadow = this.workLimit;
         int workDoneShadow = this.workDone;
 
         // Following block contains unrolled code which could be shortened by
         // coding it in additional loops.
 
         HP: while (--hp >= 0) {
             final int h = INCS[hp];
             final int mj = lo + h - 1;
 
             for (int i = lo + h; i <= hi;) {
                 // copy
                 for (int k = 3; (i <= hi) && (--k >= 0); i++) {
                     final int v = fmap[i];
                     final int vd = v + d;
                     int j = i;
 
                     // for (int a;
                     // (j > mj) && mainGtU((a = fmap[j - h]) + d, vd,
                     // block, quadrant, lastShadow);
                     // j -= h) {
                     // fmap[j] = a;
                     // }
                     //
                     // unrolled version:
 
                     // start inline mainGTU
                     boolean onceRunned = false;
                     int a = 0;
 
                     HAMMER: while (true) {
                         if (onceRunned) {
                             fmap[j] = a;
                             if ((j -= h) <= mj) {
                                 break HAMMER;
                             }
                         } else {
                             onceRunned = true;
                         }
 
                         a = fmap[j - h];
                         int i1 = a + d;
                         int i2 = vd;
 
                         // following could be done in a loop, but
                         // unrolled it for performance:
                         if (block[i1 + 1] == block[i2 + 1]) {
                             if (block[i1 + 2] == block[i2 + 2]) {
                                 if (block[i1 + 3] == block[i2 + 3]) {
                                     if (block[i1 + 4] == block[i2 + 4]) {
                                         if (block[i1 + 5] == block[i2 + 5]) {
                                             if (block[(i1 += 6)] == block[(i2 += 6)]) {
                                                 int x = lastShadow;
                                                 X: while (x > 0) {
                                                     x -= 4;
 
                                                     if (block[i1 + 1] == block[i2 + 1]) {
                                                         if (quadrant[i1] == quadrant[i2]) {
                                                             if (block[i1 + 2] == block[i2 + 2]) {
                                                                 if (quadrant[i1 + 1] == quadrant[i2 + 1]) {
                                                                     if (block[i1 + 3] == block[i2 + 3]) {
                                                                         if (quadrant[i1 + 2] == quadrant[i2 + 2]) {
                                                                             if (block[i1 + 4] == block[i2 + 4]) {
                                                                                 if (quadrant[i1 + 3] == quadrant[i2 + 3]) {
                                                                                     if ((i1 += 4) >= lastPlus1) {
                                                                                         i1 -= lastPlus1;
                                                                                     }
                                                                                     if ((i2 += 4) >= lastPlus1) {
                                                                                         i2 -= lastPlus1;
                                                                                     }
                                                                                     workDoneShadow++;
                                                                                     continue X;
                                                                                 } else if ((quadrant[i1 + 3] > quadrant[i2 + 3])) {
                                                                                     continue HAMMER;
                                                                                 } else {
                                                                                     break HAMMER;
                                                                                 }
                                                                             } else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {
                                                                                 continue HAMMER;
                                                                             } else {
                                                                                 break HAMMER;
                                                                             }
                                                                         } else if ((quadrant[i1 + 2] > quadrant[i2 + 2])) {
                                                                             continue HAMMER;
                                                                         } else {
                                                                             break HAMMER;
                                                                         }
                                                                     } else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {
                                                                         continue HAMMER;
                                                                     } else {
                                                                         break HAMMER;
                                                                     }
                                                                 } else if ((quadrant[i1 + 1] > quadrant[i2 + 1])) {
                                                                     continue HAMMER;
                                                                 } else {
                                                                     break HAMMER;
                                                                 }
                                                             } else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {
                                                                 continue HAMMER;
                                                             } else {
                                                                 break HAMMER;
                                                             }
                                                         } else if ((quadrant[i1] > quadrant[i2])) {
                                                             continue HAMMER;
                                                         } else {
                                                             break HAMMER;
                                                         }
                                                     } else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {
                                                         continue HAMMER;
                                                     } else {
                                                         break HAMMER;
                                                     }
 
                                                 }
                                                 break HAMMER;
                                             } // while x > 0
                                             else {
                                                 if ((block[i1] & 0xff) > (block[i2] & 0xff)) {
                                                     continue HAMMER;
                                                 } else {
                                                     break HAMMER;
                                                 }
                                             }
                                         } else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff)) {
                                             continue HAMMER;
                                         } else {
                                             break HAMMER;
                                         }
                                     } else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {
                                         continue HAMMER;
                                     } else {
                                         break HAMMER;
                                     }
                                 } else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {
                                     continue HAMMER;
                                 } else {
                                     break HAMMER;
                                 }
                             } else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {
                                 continue HAMMER;
                             } else {
                                 break HAMMER;
                             }
                         } else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {
                             continue HAMMER;
                         } else {
                             break HAMMER;
                         }
 
                     } // HAMMER
                     // end inline mainGTU
 
                     fmap[j] = v;
                 }
 
                 if (firstAttemptShadow && (i <= hi)
                     && (workDoneShadow > workLimitShadow)) {
                     break HP;
                 }
             }
         }
 
         this.workDone = workDoneShadow;
         return firstAttemptShadow && (workDoneShadow > workLimitShadow);
     }
 
 /*--
    LBZ2: The following is an implementation of
    an elegant 3-way quicksort for strings,
    described in a paper "Fast Algorithms for
    Sorting and Searching Strings", by Robert
    Sedgewick and Jon L. Bentley.
 --*/
 
     private static void vswap(int[] fmap, int p1, int p2, int n) {
         n += p1;
         while (p1 < n) {
             int t = fmap[p1];
             fmap[p1++] = fmap[p2];
             fmap[p2++] = t;
         }
     }
 
     private static byte med3(byte a, byte b, byte c) {
         return (a < b) ? (b < c ? b : a < c ? c : a) : (b > c ? b : a > c ? c
                                                         : a);
     }
 
     private static final int SMALL_THRESH = 20;
     private static final int DEPTH_THRESH = 10;
     private static final int WORK_FACTOR = 30;
 
     /**
      * Method "mainQSort3", file "blocksort.c", BZip2 1.0.2
      */
     private void mainQSort3(final CBZip2OutputStream.Data dataShadow,
                             final int loSt, final int hiSt, final int dSt,
                             final int last) {
         final int[] stack_ll = this.stack_ll;
         final int[] stack_hh = this.stack_hh;
         final int[] stack_dd = this.stack_dd;
         final int[] fmap = dataShadow.fmap;
         final byte[] block = dataShadow.block;
 
         stack_ll[0] = loSt;
         stack_hh[0] = hiSt;
         stack_dd[0] = dSt;
 
         for (int sp = 1; --sp >= 0;) {
             final int lo = stack_ll[sp];
             final int hi = stack_hh[sp];
             final int d = stack_dd[sp];
 
             if ((hi - lo < SMALL_THRESH) || (d > DEPTH_THRESH)) {
                 if (mainSimpleSort(dataShadow, lo, hi, d, last)) {
                     return;
                 }
             } else {
                 final int d1 = d + 1;
                 final int med = med3(block[fmap[lo] + d1],
                                      block[fmap[hi] + d1], block[fmap[(lo + hi) >>> 1] + d1]) & 0xff;
 
                 int unLo = lo;
                 int unHi = hi;
                 int ltLo = lo;
                 int gtHi = hi;
 
                 while (true) {
                     while (unLo <= unHi) {
                         final int n = (block[fmap[unLo] + d1] & 0xff)
                             - med;
                         if (n == 0) {
                             final int temp = fmap[unLo];
                             fmap[unLo++] = fmap[ltLo];
                             fmap[ltLo++] = temp;
                         } else if (n < 0) {
                             unLo++;
                         } else {
                             break;
                         }
                     }
 
                     while (unLo <= unHi) {
                         final int n = (block[fmap[unHi] + d1] & 0xff)
                             - med;
                         if (n == 0) {
                             final int temp = fmap[unHi];
                             fmap[unHi--] = fmap[gtHi];
                             fmap[gtHi--] = temp;
                         } else if (n > 0) {
                             unHi--;
                         } else {
                             break;
                         }
                     }
 
                     if (unLo <= unHi) {
                         final int temp = fmap[unLo];
                         fmap[unLo++] = fmap[unHi];
                         fmap[unHi--] = temp;
                     } else {
                         break;
                     }
                 }
 
                 if (gtHi < ltLo) {
                     stack_ll[sp] = lo;
                     stack_hh[sp] = hi;
                     stack_dd[sp] = d1;
                     sp++;
                 } else {
                     int n = ((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo)
                         : (unLo - ltLo);
                     vswap(fmap, lo, unLo - n, n);
                     int m = ((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi)
                         : (gtHi - unHi);
                     vswap(fmap, unLo, hi - m + 1, m);
 
                     n = lo + unLo - ltLo - 1;
                     m = hi - (gtHi - unHi) + 1;
 
                     stack_ll[sp] = lo;
                     stack_hh[sp] = n;
                     stack_dd[sp] = d;
                     sp++;
 
                     stack_ll[sp] = n + 1;
                     stack_hh[sp] = m - 1;
                     stack_dd[sp] = d1;
                     sp++;
 
                     stack_ll[sp] = m;
                     stack_hh[sp] = hi;
                     stack_dd[sp] = d;
                     sp++;
                 }
             }
         }
     }
 
     private static final int SETMASK = (1 << 21);
     private static final int CLEARMASK = (~SETMASK);
 
     final void mainSort(final CBZip2OutputStream.Data dataShadow,
                         final int lastShadow) {
         final int[] runningOrder = this.mainSort_runningOrder;
         final int[] copy = this.mainSort_copy;
         final boolean[] bigDone = this.mainSort_bigDone;
         final int[] ftab = this.ftab;
         final byte[] block = dataShadow.block;
         final int[] fmap = dataShadow.fmap;
         final char[] quadrant = this.quadrant;
         final int workLimitShadow = this.workLimit;
         final boolean firstAttemptShadow = this.firstAttempt;
 
         // LBZ2: Set up the 2-byte frequency table
         for (int i = 65537; --i >= 0;) {
             ftab[i] = 0;
         }
 
         /*
          * In the various block-sized structures, live data runs from 0 to
          * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area
          * for block.
          */
         for (int i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {
             block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];
         }
         for (int i = lastShadow + BZip2Constants.NUM_OVERSHOOT_BYTES +1; --i >= 0;) {
             quadrant[i] = 0;
         }
         block[0] = block[lastShadow + 1];
 
         // LBZ2: Complete the initial radix sort:
 
         int c1 = block[0] & 0xff;
         for (int i = 0; i <= lastShadow; i++) {
             final int c2 = block[i + 1] & 0xff;
             ftab[(c1 << 8) + c2]++;
             c1 = c2;
         }
 
         for (int i = 1; i <= 65536; i++) {
             ftab[i] += ftab[i - 1];
         }
 
         c1 = block[1] & 0xff;
         for (int i = 0; i < lastShadow; i++) {
             final int c2 = block[i + 2] & 0xff;
             fmap[--ftab[(c1 << 8) + c2]] = i;
             c1 = c2;
         }
 
         fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;
 
         /*
          * LBZ2: Now ftab contains the first loc of every small bucket. Calculate the
          * running order, from smallest to largest big bucket.
          */
         for (int i = 256; --i >= 0;) {
             bigDone[i] = false;
             runningOrder[i] = i;
         }
 
         for (int h = 364; h != 1;) {
             h /= 3;
             for (int i = h; i <= 255; i++) {
                 final int vv = runningOrder[i];
                 final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];
                 final int b = h - 1;
                 int j = i;
                 for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j
                                                                                                                 - h]) {
                     runningOrder[j] = ro;
                     j -= h;
                     if (j <= b) {
                         break;
                     }
                 }
                 runningOrder[j] = vv;
             }
         }
 
         /*
          * LBZ2: The main sorting loop.
          */
         for (int i = 0; i <= 255; i++) {
             /*
              * LBZ2: Process big buckets, starting with the least full.
              */
             final int ss = runningOrder[i];
 
             // Step 1:
             /*
              * LBZ2: Complete the big bucket [ss] by quicksorting any unsorted small
              * buckets [ss, j]. Hopefully previous pointer-scanning phases have
              * already completed many of the small buckets [ss, j], so we don't
              * have to sort them at all.
              */
             for (int j = 0; j <= 255; j++) {
                 final int sb = (ss << 8) + j;
                 final int ftab_sb = ftab[sb];
                 if ((ftab_sb & SETMASK) != SETMASK) {
                     final int lo = ftab_sb & CLEARMASK;
                     final int hi = (ftab[sb + 1] & CLEARMASK) - 1;
                     if (hi > lo) {
                         mainQSort3(dataShadow, lo, hi, 2, lastShadow);
                         if (firstAttemptShadow
                             && (this.workDone > workLimitShadow)) {
                             return;
                         }
                     }
                     ftab[sb] = ftab_sb | SETMASK;
                 }
             }
 
             // Step 2:
             // LBZ2: Now scan this big bucket so as to synthesise the
             // sorted order for small buckets [t, ss] for all t != ss.
 
             for (int j = 0; j <= 255; j++) {
                 copy[j] = ftab[(j << 8) + ss] & CLEARMASK;
             }
 
             for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++) {
                 final int fmap_j = fmap[j];
                 c1 = block[fmap_j] & 0xff;
                 if (!bigDone[c1]) {
                     fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);
                     copy[c1]++;
                 }
             }
 
             for (int j = 256; --j >= 0;) {
                 ftab[(j << 8) + ss] |= SETMASK;
             }
 
             // Step 3:
             /*
              * LBZ2: The ss big bucket is now done. Record this fact, and update the
              * quadrant descriptors. Remember to update quadrants in the
              * overshoot area too, if necessary. The "if (i < 255)" test merely
              * skips this updating for the last bucket processed, since updating
              * for the last bucket is pointless.
              */
             bigDone[ss] = true;
 
             if (i < 255) {
                 final int bbStart = ftab[ss << 8] & CLEARMASK;
                 final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;
                 int shifts = 0;
 
                 while ((bbSize >> shifts) > 65534) {
                     shifts++;
                 }
 
                 for (int j = 0; j < bbSize; j++) {
                     final int a2update = fmap[bbStart + j];
                     final char qVal = (char) (j >> shifts);
                     quadrant[a2update] = qVal;
                     if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {
                         quadrant[a2update + lastShadow + 1] = qVal;
                     }
                 }
             }
 
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/mail/MailMessage.java b/src/main/org/apache/tools/mail/MailMessage.java
index 71d0d379f..b4173a96b 100644
--- a/src/main/org/apache/tools/mail/MailMessage.java
+++ b/src/main/org/apache/tools/mail/MailMessage.java
@@ -1,526 +1,526 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 /*
  * The original version of this class was donated by Jason Hunter,
  * who wrote the class as part of the com.oreilly.servlet
  * package for his book "Java Servlet Programming" (O'Reilly).
  * See http://www.servlets.com.
  *
  */
 
 package org.apache.tools.mail;
 
 import java.io.BufferedOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.PrintStream;
 import java.net.InetAddress;
 import java.net.Socket;
 import java.util.Enumeration;
 import java.util.Vector;
 
 /**
  * A class to help send SMTP email.
  * This class is an improvement on the sun.net.smtp.SmtpClient class
  * found in the JDK.  This version has extra functionality, and can be used
  * with JVMs that did not extend from the JDK.  It's not as robust as
  * the JavaMail Standard Extension classes, but it's easier to use and
  * easier to install, and has an Open Source license.
  * <p>
  * It can be used like this:
  * <blockquote><pre>
  * String mailhost = "localhost";  // or another mail host
  * String from = "Mail Message Servlet &lt;MailMessage@server.com&gt;";
  * String to = "to@you.com";
  * String cc1 = "cc1@you.com";
  * String cc2 = "cc2@you.com";
  * String bcc = "bcc@you.com";
  * &nbsp;
  * MailMessage msg = new MailMessage(mailhost);
  * msg.setPort(25);
  * msg.from(from);
  * msg.to(to);
  * msg.cc(cc1);
  * msg.cc(cc2);
  * msg.bcc(bcc);
  * msg.setSubject("Test subject");
  * PrintStream out = msg.getPrintStream();
  * &nbsp;
  * Enumeration enum = req.getParameterNames();
  * while (enum.hasMoreElements()) {
  *   String name = (String)enum.nextElement();
  *   String value = req.getParameter(name);
  *   out.println(name + " = " + value);
  * }
  * &nbsp;
  * msg.sendAndClose();
  * </pre></blockquote>
  * <p>
  * Be sure to set the from address, then set the recipient
  * addresses, then set the subject and other headers, then get the
  * PrintStream, then write the message, and finally send and close.
  * The class does minimal error checking internally; it counts on the mail
  * host to complain if there's any malformatted input or out of order
  * execution.
  * <p>
  * An attachment mechanism based on RFC 1521 could be implemented on top of
  * this class.  In the meanwhile, JavaMail is the best solution for sending
  * email with attachments.
  * <p>
  * Still to do:
  * <ul>
  * <li>Figure out how to close the connection in case of error
  * </ul>
  *
  * @version 1.1, 2000/03/19, added angle brackets to address, helps some servers
  * version 1.0, 1999/12/29
  */
 public class MailMessage {
 
     /** default mailhost */
     public static final String DEFAULT_HOST = "localhost";
 
     /** default port for SMTP: 25 */
     public static final int DEFAULT_PORT = 25;
 
     /** host name for the mail server */
     private String host;
 
     /** host port for the mail server */
     private int port = DEFAULT_PORT;
 
     /** sender email address */
     private String from;
 
     /** list of email addresses to reply to */
     private Vector replyto;
 
     /** list of email addresses to send to */
     private Vector to;
 
     /** list of email addresses to cc to */
     private Vector cc;
 
     /** headers to send in the mail */
     private Vector headersKeys;
     private Vector headersValues;
 
     private MailPrintStream out;
 
     private SmtpResponseReader in;
 
     private Socket socket;
     private static final int OK_READY = 220;
     private static final int OK_HELO = 250;
     private static final int OK_FROM = 250;
     private static final int OK_RCPT_1 = 250;
     private static final int OK_RCPT_2 = 251;
     private static final int OK_DATA = 354;
     private static final int OK_DOT = 250;
     private static final int OK_QUIT = 221;
 
   /**
    * Constructs a new MailMessage to send an email.
    * Use localhost as the mail server with port 25.
    *
    * @exception IOException if there's any problem contacting the mail server
    */
   public MailMessage() throws IOException {
     this(DEFAULT_HOST, DEFAULT_PORT);
   }
 
   /**
    * Constructs a new MailMessage to send an email.
    * Use the given host as the mail server with port 25.
    *
    * @param host the mail server to use
    * @exception IOException if there's any problem contacting the mail server
    */
   public MailMessage(String host) throws IOException {
     this(host, DEFAULT_PORT);
   }
 
   /**
    * Constructs a new MailMessage to send an email.
    * Use the given host and port as the mail server.
    *
    * @param host the mail server to use
    * @param port the port to connect to
    * @exception IOException if there's any problem contacting the mail server
    */
   public MailMessage(String host, int port) throws IOException {
     this.port = port;
     this.host = host;
     replyto = new Vector();
     to = new Vector();
     cc = new Vector();
     headersKeys = new Vector();
     headersValues = new Vector();
     connect();
     sendHelo();
   }
 
     /**
      * Set the port to connect to the SMTP host.
      * @param port the port to use for connection.
      * @see #DEFAULT_PORT
      */
     public void setPort(int port) {
         this.port = port;
     }
 
     /**
      * Sets the from address.  Also sets the "From" header.  This method should
      * be called only once.
      * @param from the from address
      * @exception IOException if there's any problem reported by the mail server
      */
     public void from(String from) throws IOException {
         sendFrom(from);
         this.from = from;
     }
 
     /**
      * Sets the replyto address
      * This method may be
      * called multiple times.
      * @param rto the replyto address
      *
      */
     public void replyto(String rto) {
       this.replyto.addElement(rto);
     }
 
   /**
    * Sets the to address.  Also sets the "To" header.  This method may be
    * called multiple times.
    *
    * @param to the to address
    * @exception IOException if there's any problem reported by the mail server
    */
   public void to(String to) throws IOException {
     sendRcpt(to);
     this.to.addElement(to);
   }
 
   /**
    * Sets the cc address.  Also sets the "Cc" header.  This method may be
    * called multiple times.
    *
    * @param cc the cc address
    * @exception IOException if there's any problem reported by the mail server
    */
   public void cc(String cc) throws IOException {
     sendRcpt(cc);
     this.cc.addElement(cc);
   }
 
   /**
    * Sets the bcc address.  Does NOT set any header since it's a *blind* copy.
    * This method may be called multiple times.
    *
    * @param bcc the bcc address
    * @exception IOException if there's any problem reported by the mail server
    */
   public void bcc(String bcc) throws IOException {
     sendRcpt(bcc);
     // No need to keep track of Bcc'd addresses
   }
 
   /**
    * Sets the subject of the mail message.  Actually sets the "Subject"
    * header.
    * @param subj the subject of the mail message
    */
   public void setSubject(String subj) {
     setHeader("Subject", subj);
   }
 
   /**
    * Sets the named header to the given value.  RFC 822 provides the rules for
    * what text may constitute a header name and value.
    * @param name name of the header
    * @param value contents of the header
    */
   public void setHeader(String name, String value) {
     // Blindly trust the user doesn't set any invalid headers
     headersKeys.add(name);
     headersValues.add(value);
   }
 
   /**
    * Returns a PrintStream that can be used to write the body of the message.
    * A stream is used since email bodies are byte-oriented.  A writer can
    * be wrapped on top if necessary for internationalization.
    * This is actually done in Message.java
    *
    * @return a printstream containing the data and the headers of the email
    * @exception IOException if there's any problem reported by the mail server
    * @see org.apache.tools.ant.taskdefs.email.Message
    */
   public PrintStream getPrintStream() throws IOException {
     setFromHeader();
     setReplyToHeader();
     setToHeader();
     setCcHeader();
     setHeader("X-Mailer", "org.apache.tools.mail.MailMessage (ant.apache.org)");
     sendData();
     flushHeaders();
     return out;
   }
 
 
   // RFC 822 s4.1: "From:" header must be sent
   // We rely on error checking by the MTA
   void setFromHeader() {
     setHeader("From", from);
   }
 
   // RFC 822 s4.1: "Reply-To:" header is optional
   void setReplyToHeader() {
     if (!replyto.isEmpty()) {
       setHeader("Reply-To", vectorToList(replyto));
     }
   }
 
   void setToHeader() {
     if (!to.isEmpty()) {
       setHeader("To", vectorToList(to));
     }
   }
 
   void setCcHeader() {
     if (!cc.isEmpty()) {
       setHeader("Cc", vectorToList(cc));
     }
   }
 
   String vectorToList(Vector v) {
     StringBuffer buf = new StringBuffer();
     Enumeration e = v.elements();
     while (e.hasMoreElements()) {
       buf.append(e.nextElement());
       if (e.hasMoreElements()) {
         buf.append(", ");
       }
     }
     return buf.toString();
   }
 
   void flushHeaders() throws IOException {
     // RFC 822 s4.1:
     //   "Header fields are NOT required to occur in any particular order,
     //    except that the message body MUST occur AFTER the headers"
-    // (the same section specifies a reccommended order, which we ignore)
+    // (the same section specifies a recommended order, which we ignore)
    final int size = headersKeys.size();
    for (int i = 0; i < size; i++) {
       String name = (String) headersKeys.elementAt(i);
       String value = (String) headersValues.elementAt(i);
       out.println(name + ": " + value);
     }
     out.println();
     out.flush();
   }
 
   /**
    * Sends the message and closes the connection to the server.
    * The MailMessage object cannot be reused.
    *
    * @exception IOException if there's any problem reported by the mail server
    */
   public void sendAndClose() throws IOException {
       try {
           sendDot();
           sendQuit();
       } finally {
           disconnect();
       }
   }
 
   // Make a limited attempt to extract a sanitized email address
   // Prefer text in <brackets>, ignore anything in (parentheses)
   static String sanitizeAddress(String s) {
     int paramDepth = 0;
     int start = 0;
     int end = 0;
     int len = s.length();
 
     for (int i = 0; i < len; i++) {
       char c = s.charAt(i);
       if (c == '(') {
         paramDepth++;
         if (start == 0) {
           end = i;  // support "address (name)"
         }
       } else if (c == ')') {
         paramDepth--;
         if (end == 0) {
           start = i + 1;  // support "(name) address"
         }
       } else if (paramDepth == 0 && c == '<') {
         start = i + 1;
       } else if (paramDepth == 0 && c == '>') {
         end = i;
       }
     }
 
     if (end == 0) {
       end = len;
     }
 
     return s.substring(start, end);
   }
 
   // * * * * * Raw protocol methods below here * * * * *
 
   void connect() throws IOException {
     socket = new Socket(host, port);
     out = new MailPrintStream(
           new BufferedOutputStream(
           socket.getOutputStream()));
     in = new SmtpResponseReader(socket.getInputStream());
     getReady();
   }
 
   void getReady() throws IOException {
     String response = in.getResponse();
     int[] ok = {OK_READY};
     if (!isResponseOK(response, ok)) {
       throw new IOException(
         "Didn't get introduction from server: " + response);
     }
   }
   void sendHelo() throws IOException {
     String local = InetAddress.getLocalHost().getHostName();
     int[] ok = {OK_HELO};
     send("HELO " + local, ok);
   }
   void sendFrom(String from) throws IOException {
     int[] ok = {OK_FROM};
     send("MAIL FROM: " + "<" + sanitizeAddress(from) + ">", ok);
   }
   void sendRcpt(String rcpt) throws IOException {
     int[] ok = {OK_RCPT_1, OK_RCPT_2};
     send("RCPT TO: " + "<" + sanitizeAddress(rcpt) + ">", ok);
   }
 
   void sendData() throws IOException {
     int[] ok = {OK_DATA};
     send("DATA", ok);
   }
 
   void sendDot() throws IOException {
     int[] ok = {OK_DOT};
     send("\r\n.", ok);  // make sure dot is on new line
   }
 
     void sendQuit() throws IOException {
         int[] ok = {OK_QUIT};
         try {
             send("QUIT", ok);
         } catch (IOException e) {
             throw new ErrorInQuitException(e);
         }
     }
 
     void send(String msg, int[] ok) throws IOException {
         out.rawPrint(msg + "\r\n");  // raw supports <CRLF>.<CRLF>
         String response = in.getResponse();
         if (!isResponseOK(response, ok)) {
             throw new IOException("Unexpected reply to command: "
                                   + msg + ": " + response);
         }
     }
 
   boolean isResponseOK(String response, int[] ok) {
     // Check that the response is one of the valid codes
     for (int i = 0; i < ok.length; i++) {
       if (response.startsWith("" + ok[i])) {
         return true;
       }
     }
     return false;
   }
 
     void disconnect() throws IOException {
         if (out != null) {
             out.close();
         }
         if (in != null) {
             try {
                 in.close();
             } catch (IOException e) {
                 // ignore
             }
         }
         if (socket != null) {
             try {
                 socket.close();
             } catch (IOException e) {
                 // ignore
             }
         }
     }
 }
 
 /**
  * This PrintStream subclass makes sure that <CRLF>. becomes <CRLF>..
  *  per RFC 821.  It also ensures that new lines are always \r\n.
 */
 class MailPrintStream extends PrintStream {
 
   private int lastChar;
 
   public MailPrintStream(OutputStream out) {
     super(out, true);  // deprecated, but email is byte-oriented
   }
 
   // Mac does \n\r, but that's tough to distinguish from Windows \r\n\r\n.
   // Don't tackle that problem right now.
   public void write(int b) {
     if (b == '\n' && lastChar != '\r') {
       rawWrite('\r');  // ensure always \r\n
       rawWrite(b);
     } else if (b == '.' && lastChar == '\n') {
       rawWrite('.');  // add extra dot
       rawWrite(b);
     } else {
       rawWrite(b);
     }
     lastChar = b;
   }
 
   public void write(byte[] buf, int off, int len) {
     for (int i = 0; i < len; i++) {
       write(buf[off + i]);
     }
   }
 
   void rawWrite(int b) {
     super.write(b);
   }
 
   void rawPrint(String s) {
     int len = s.length();
     for (int i = 0; i < len; i++) {
       rawWrite(s.charAt(i));
     }
   }
 }
 
