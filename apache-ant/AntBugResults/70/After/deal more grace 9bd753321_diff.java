diff --git a/WHATSNEW b/WHATSNEW
index 4f2b9f7e4..a8c62f44c 100644
--- a/WHATSNEW
+++ b/WHATSNEW
@@ -1,1042 +1,1047 @@
 Changes from Ant 1.9.3 TO current
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * the prefixValues attribute of <property> didn't work as expected
    when set to false (the default).
    It is quite likely existing build files relied on the wrong
    behavior and expect Ant to resolve the value side against the
    properties defined in the property file itself - these build files
    must now explicitly set the prefixValues attribute to true.
    Bugzilla Report 54769
 
 Fixed bugs:
 -----------
 
  * <import>/<include> failed when the importing file was loaded from an
    URI or a jar and it imported a file from the local file system via
    an absolute path.
    Bugzilla Report 50953
 
  * <import> could import the same resource twice when imported via
    different resource types.
    Bugzilla Report 55097
 
  * several calls to File#mkdirs could fall victim to a race condition
    where another thread already created the same directory.
    Bugzilla Report 55290
 
  * <manifestclasspath> created '/' rather than './' for the parent
    directory of the given jarfile.
    Bugzilla Report 55049
 
  * <concat>'s fixlastline="true" didn't work when using certain filter
    readers.
    Bugzilla Report 54672
 
  * several places where resources are read from jars will now
    explicitly disable caching to avoid problems with reloading jars.
    Bugzilla Report 54473
 
+ * AntClassloader will now ignore files that are part of the classpath but
+   not valid zip files when scanning for resources.  It used to throw
+   an exception.
+   Bugzilla Report 53964
+
 Other changes:
 --------------
 
 
 Changes from Ant 1.9.2 TO Ant 1.9.3
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
 
 Fixed bugs:
 -----------
 
  * <parallel> swallowed the status code of nested <fail> tasks.
    Bugzilla Report 55539.
 
  * a race condition could make <fixcrlf> tasks of parallel builds to
    interfere with each other.
    Bugzilla Report 54393.
 
  * <mail>'s mailport still didn't work properly when using smtps.
    Bugzilla Report 49267.
 
  * using attributes belonging to the if and unless namespaces
    made macrodef fail.
    Bugzilla Report 55885.
 
  * Ant 1.8 exec task changes have slowed exec to a crawl
    Bugzilla Report 54128.
 
  * Apt is not available under JDK 1.8
    Bugzilla Report 55922.
 
 
 Other changes:
 --------------
 
  * Documentation fix for if/unless attributes.  PR 55359.
 
  * tar entries with long link names are now handled the same way as
    entries with long names.
 
  * Addition of 'skipNonTests' attribute to <junit> and <batchtest>
    tasks to allow the tasks to skip classes that don't contain tests.
 
  * <filterset> now supports a nested <propertyset> to specify filters.
    Bugzilla Report 55794.
 
  * <xslt>'s params can now be typed.
    Bugzilla Report 21525.
 
  * build of Mac OS X pkg installer
    Bugzilla Report 55899.
 
 Changes from Ant 1.9.1 TO Ant 1.9.2
 ===================================
 
 Fixed bugs:
 -----------
 
  * Parsing of zip64 extra fields has become more lenient in order to
    be able to read archives created by DotNetZip and maybe other
    archivers as well.
 
  * TarInputStream should now properly read GNU longlink entries' names.
    Bugzilla Report 55040.
 
  * <java> and <exec> used to be too restrictive when evaluating
    whether a given set of options is compatible with spawning the new
    process.
    Bugzilla Report 55112.
 
 Other changes:
 --------------
 
  * <javadoc> will now post-process the generated in order to mitigate
    the frame injection attack possible in javadocs generated by Oracle
    JDKs prior to Java7 Update 25.  The vulnerability is known as
    CVE-2013-1571.
    There is an option to turn off the post-processing but it is only
    recommended you do so if all your builds use a JDK that's not
    vulnerable.
    Bugzilla Report 55132.
 
 Changes from Ant 1.9.0 TO Ant 1.9.1
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Users who have their own ProjectHelper implementation will need to change it because the import and include tasks
    will now default the targetPrefix to ProjectHelper.USE_PROJECT_NAME_AS_TARGET_PREFIX.
    Users using the default ProjectHelper2 with ant need not worry about this change done to fix Bugzilla Report 54940.
 
 
 Fixed bugs:
 -----------
 
  * Corrected XSLTC error in <junitreport>.
    Bugzilla Report 54641.
 
  * Provide more control over Zip64 extensions created by <zip> and
    related tasks.  In particular no Zip64 extensions will be used at
    all by the <jar> task family by default - this is required for jars
    to be readably by Java5.
    Bugzilla Report 54762.
 
  * Fixed loading of external dependencies in JUnit task.
    Bugzilla Report 54835.
 
  * Target rewriting for nested "include" only works when "as" is specified.
    See also "Changes that could break older environments"
    Bugzilla Report 54940.
 
 
 Other changes:
 --------------
 
  * strict attribute added to <signjar>.
    Bugzilla Report 54889.
 
  * simplifying Execute.getEnvironmentVariables since we are only running on Java 1.5 or higher now
 
  * Added conditional attributes.
    Bugzilla Report 43362
 
  * Recommending to upgrade jsch to 0.1.50, particularly if you are using Java 1.7.
    jsch is the library behind the sshexec and scp Ant tasks.
    Versions of jsch older than 0.1.50 fail randomly under Java 1.7 with an error message "verify: false"
 
 Changes from Ant 1.8.4 TO Ant 1.9.0
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Ant now requires at least Java 1.5 to compile and to run
 
  * FixCRLF used to treat the EOL value ASIS to convert to the system property
    line.separator. Specified was that ASIS would leave the EOL characters alone,
    the task now really leaves the EOL characters alone. This also implies that
    EOL ASIS will not insert a newline even if fixlast is set to true.
    Bugzilla report 53036
 
  * The CommandLauncher hierarchy that used to be a set of inner
    classes of Execute has been extracted to the
    org.apache.tools.ant.taskdefs.launcher package.
 
  * Any FileResource whose represented File has a parent also has a basedir.
 
  * Removing the Perforce Ant tasks replaced by tasks supplied by Perforce Inc.
 
  * Setting the default encoding of StringResource to UTF-8 instead of null
 
  * Upgrade JUnit 4 to JUnit 4.11
 
 Fixed bugs:
 -----------
 
  * Made VectorSet faster.
    Bugzilla Report 53622.
 
  * Incorrect URLs in Ant child POMs.
    Bugzilla Report 53617.
 
  * Subclasses of JUnitTask did not correctly find junit.jar.
    Bugzilla Report 53571.
 
  * External XML catalog resolver failed to use project basedir when given an
    unmentioned relative path like the internal resolver does.
    Bugzilla Report 52754.
 
  * Fixed some potential stream leaks.
    Bugzilla Reports 52738, 52740, 52742, 52743.
 
  * Updated documentation to fix spelling errors / broken links.
    Bugzilla Reports 53215, 53291, 53202
    
  * Unable to override system properties. It was not possible not to override
    system properties from the command line (or from a property file).
    Bugzilla Report 51792
    
  * <javac> by default fails when run on JDK 8.
    Bugzilla Report 53347.
 
  * ExtensionPoint doesn't work with nested import/include
    Bugzilla Report 53405.
 
  * <packagemapper> failed to strip the non-matched parts with
    handledirsep="true".
    Bugzilla Report 53399.
 
  * <expandproperties> filter caused a NullPointerException when input
    was empty.
    Bugzilla Report 53626.
 
  * <get> now supports HTTP redirects using status code 307.
    Bugzilla Report 54374.
 
  * ssh tasks prompt for kerberos username/password under Java 7
    Bugzilla Report 53437.
 
  * Zip task on <mappedresources> that excludes certain files by way of the mapper resulted in a NullPointerException
    Bugzilla Report 54026
 
  * The ant launcher script should properly detect JAVA_HOME on
    MacOS X 10.7
    Bugzilla Report 52632
 
  * Depend task does not handle invokeDynamic constant pool entries - java.lang.ClassFormatError: Invalid Constant Pool entry Type 18
    Bugzilla Report 54090
 
  * Base64Converter not properly handling bytes with MSB set (not masking byte to int conversion)
    Bugzilla Report 54460
 
  * The size resource comparator would return wrong results if file
    sizes differed by more than 2 GB.
    Bugzilla Report 54623
 
  * Unable to encode properly into UTF-8 when the system property file.encoding is
    set to ANSI_X3.4-1968.
    Bugzilla Report 54606
 
  * JUnit4 tests marked @Ignore do not appear in XML output
    Bugzilla Report 43969
 
 Other changes:
 --------------
 
  * merged the ZIP package from Commons Compress, it can now read
    archives using Zip64 extensions (files and archives bigger that 4GB
    and with more that 64k entries).
 
  * a new task <commandlauncher> can be used to configure the
    CommandLauncher used by Ant when forking external programs or new
    Java VMs.
    Bugzilla Report 52706.
 
  * merged the TAR package from Commons Compress, it can now read
    archives using POSIX extension headers and STAR extensions.
 
  * merged the BZIP2 package from Commons Compress, it can now
    optionally read files that contain multiple streams properly.
 
  * <bunzip2> will now properly expand files created by pbzip2 and
    similar tools that create files with multiple bzip2 streams.
 
  * <tar> now supports a new "posix" option for longfile-mode which
    will make it create PAX extension headers for long file names.  PAX
    extension headers are supported by all modern implementations of
    tar including GNU tar.
    This option should now be used in preference to "warn" or "gnu" as
    it is more portable.  For backwards compatibility reasons "warn"
    will still create "gnu" extensions rather than "posix" extensions.
 
  * The ProjectHelper class now exposes a method to be used by third party
    implementations to properly resolve the binding between target extensions
    and extension points.
    Bugzilla Report 53549.
 
  * Make extension point bindable to imported prefixed targets
    Bugzilla Report 53550.
 
  * Add the possibility to register a custom command line argument processor.
    See org.apache.tools.ant.ArgumentProcessor and manual/argumentprocessor.html
 
  * add the possibility to suppress stdout in the sshexec task.
    Bugzilla Report 50270.
 
  * add an encoding attribute to the contains selector.
    This will be useful to use the contains selector if the encoding of the VM is different from the encoding
    of the files being selected.
 
  * support for GNU Classpath.
    Bugzilla report 54760.
 
 Changes from Ant 1.8.3 TO Ant 1.8.4
 ===================================
 
 Fixed bugs:
 -----------
 
  * Ported libbzip2's fallback sort algorithm to CBZip2OutputStream to
    speed up compression in certain edge cases.  Merge from Commons
    Compress.
 
    Using specially crafted inputs this can be used as a denial of
    service attack.
    See http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2098
 
 Changes from Ant 1.8.2 TO Ant 1.8.3
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * The Enumeration returned by AntClassLoader#getResources used to
    return null in nextElement after hasNextElement would return false.
    It has been changed to throw a NoSuchElementException instead so
    that it now adheres to the contract of java.util.Enumeration.
    Bugzilla Report 51579.
 
 Fixed bugs:
 -----------
 
  * Removed buggy duplicate JAR list in RPM mode.
    Bugzilla Report 52556.
 
  * Launcher fixed to pass the right class loader parent.
    Bugzilla Report 48633.
 
  * <junitreport> mishandled ${line.separator}.
    Bugzilla Report 51049.
 
  * <junitreport> did not work in embedded environments on JDK 7.
    Nor did <xslt> when using Xalan redirects.
    Bugzilla Report 51668, 52382.
 
  * Encoding of unicode escape sequences by the property file task
    Bugzilla Report 50515.
 
  * The code that implicitly sets the -source switch if only -target
    has been specified in <javac> was broken for Java 5 and 6.
    Bugzilla Report 50578.
 
  * MailLogger ignore the Maillogger.starttls.enable property.
    Bugzilla Report 50668.
 
  * Delete task example does not work
    Bugzilla Report 50816.
 
  * <splash>'s proxy handling has been delegated to <setproxy>
    internally so the two tasks are consistent.  <splash>'s way of not
    setting a proxy caused problems with other Java libraries.
    Bugzilla Report 50888.
 
  * Include task breaks dependencies or extension-points for multiple
    files.
    Bugzilla Report 50866.
 
  * Read on System.in hangs for forked java task.
    Bugzilla Report 50960.
 
  * FileResource specified using basedir/name attributes was non-functional.
 
  * Resource collection implementation of mapped PropertySet returned
    unusable resources.
 
  * The hasmethod condition failed with a NullPointerException when
    ignoresystemclasses is true and Ant tried to load a "restricted
    class" - i.e. a class that the Java VM will only accept when loaded
    via the bootclassloader (a java.* class).
    It will now fail with a more useful error message.
    Bugzilla Report 51035.
 
  * Exec task may mix the stderr and stdout output while logging it
    Bugzilla Report 50507.
 
  * Missing space between "finished" and timestamp in task/target 
    finish message from ProfileLogger.
    Bugzilla Report 51109.
 
  * Redirecting the output of a java, exec or apply task could print in the
    error output stream some "Pipe broken" errors.
    Bugzilla Report 48789.
 
  * ZipFile failed to clean up some resources which could lead to
    OutOfMemoryException while unzipping large archives.
    A similar problem in ZipArchiveOutputStream has been fixed as well.
    Bugzilla Report 42696.
 
  * quiet attribute added to the copy and move tasks, to be used together
    with failonerror=false, so warnings won't get logged 
    Bugzilla Report 48789.
 
  * System.in was closed and not readable anymore by the DefaultInputHandler 
    when Ant is used via its Java API.
    Bugzilla Report 51161
 
  * <sync> only supported a single non-fileset resource collection even
    though the manual said it could be multiple.
 
  * <sync> didn't work properly when working on resource collections.
    Bugzilla Report 51462.
 
  * <augment> cause a NullPointerException if it was used in a target
    that was invoked by multiple targets from the command line.
    Bugzilla Report 50894.
 
  * The ZipFile class could read past the start of the file if the
    given file is not a ZIP archive and it is smaller than the size of
    a ZIP "end of central directory record".
 
  * <javac> would create the empty package-info.class file in the wrong
    directory if no destdir was specified.  Note it may still pick the
    wrong directory if you specify more than one source directory but
    no destDir.  It is highly recommended that you always explicitly
    specify the destDir attribute.
    Bugzilla Report 51947.
 
  * packagemapper now honors the handleDirSep attribute.
    Bugzilla Report 51086.
 
  * the attributes of macrodef tasks had their values run through
    property expansion twice. Still true by default, but can be disabled.
    Bugzilla Report 42046.
 
  * jvc doesn't like it if source file names in argument files are
    quoted.
    Bugzilla Report 31667.
 
  * ZipFile didn't work properly for archives using unicode extra
    fields rather than UTF-8 filenames and the EFS-Flag.
 
  * Access to DirectoryScanner's default excludes wasn't synchronized.
    Bugzilla Report 52188.
 
  * When a Project instance was created by a custom tasks its
    createTask method didn't work.
    Bugzilla Report 50788.
 
 Other changes:
 --------------
 
  * -f/-file/-buildfile accepts a directory containing build.xml.
 
  * The <javacc>, <jjtree> and <jjdoc> now support a new maxmemory
    attribute.
    Bugzilla Report 50513.
 
  * the documented inputstring attribute of sshexec has been
    implemented and the actually existing attribute inputproperty
    documented.
    Bugzilla Report 50576.
 
  * The concat task now permits the name of its exposed resource
    by means of its 'resourcename' attribute.
 
  * The expandproperties filter now accepts a nested propertyset
    which, if specified, provides the properties for expansion.
    Bugzilla Report 51044.
 
  * <junit filtertrace="true"/> will no longer filter out the very
    first line of the stacktrace containing the original exception
    message even if it matches one of the filter expressions.
 
  * Upgraded to Apache AntUnit 1.2
 
  * Provide read access to Mkdir.dir.  Bugzilla Report 51684.
 
  * <delete> and <move> have a new attribute performGCOnFailedDelete
    that may - when set to true - help resolve some problems with
    deleting empty directories on NFS shares.
    Bugzilla Report 45786.
 
  * <loadfile> and <loadresource> used to log at level INFO to signal a
    property hasn't been set when the resource was empty even if the
    quiet attribute was set to true.  They will now use VERBOSE
    instead.
    Bugzilla Report 52107.
 
  * <javac> has a new attribute createMissingPackageInfoClass that can
    be set to false to prevent Ant from creating empty dummy classes
    used for up-to-date-ness checks.
    Bugzilla Report 52096.
 
  * URLResources#isExists has become less noisy.
    Bugzilla Report 51829.
 
  * The <retry> task has a new optional attribute retryDelay that can
    be used to make the task sleep between retry attempts.
    Bugzilla Report 52076.
 
  * <signjar> has new attributes that control the signature and digest
    algorithms.
    Bugzilla Report 52344.
 
  * Initial support for Java 8.
 
  * <sshexec> can optionally create a pseudo terminal (like ssh -t)
    Bugzilla Report 52554.
 
 Changes from Ant 1.8.1 TO Ant 1.8.2
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Prior to Ant 1.8.0 the <copy> task and several other tasks would
    overwrite read-only destination files.  Starting with 1.8.0 they
    would only do so under special circumstances.  Ant 1.8.2 now
    consistently won't replace a read-only file by default. The same is
    true for a number of other tasks.
    The <copy>, <move> and <echo> tasks now have a new force attribute
    and <concat> has a new forceReadonly attribute that can be used to
    make the task overwrite read-only destinations.
    Bugzilla Report 49261.
 
  * Removed ant-nodeps.jar; it is now merged into ant.jar.
 
  * DOMElementWriter#encode used to employ special code before encoding
    ampersands so that &#123; remained &#123; rather than being turned
    into &amp;#123;.  This is no longer the case, ampersands will now
    be encoded unconditionally.
    Also DOMElementWriter#encodeData will treat CDATA sections containing a
    literal "]]>" sequence different now - it will split the CDATA
    section between the second "]" and ">" and create two sections.
    This affects <echoxml> task as well as the XML logger or JUnit
    formatter where ampersands will now always get encoded.
    In addition DOMElementWriter will now replace the characters \t, \r
    and \n in attribute values by entity references.
    Bugzilla Report 49404.
 
  * The list elements returned by ProjectHelper#getExtensionStack are
    now String arrays of length 3 rather than 2 in order to support the
    onMissingExtensionPoint attribute.
    Bugzilla Report 49473.
 
  * When using <property file="..." prefix="..."/> properties defined
    inside the same file will only get used in expansions if the ${}
    reference uses the same prefix.  This is different from Ant 1.8.1
    but is the same behavior Ant 1.8.0 and earlier exhibited.
    A new attribute prefixValues can be used to re-enable the behavior
    of Ant 1.8.1.
    Bugzilla Report 49373.
 
  * The files and directories used by Git, Mercurial and Bazaar to
    store their information are now excluded by the defaultexcludes.
    Bugzilla Report 49624.
 
  * The <junit> task no longer generates TestListener events - which
    have been introduced in ant 1.7.0 - by default.  The task has a new
    attribute enableTestListenerEvents and a new "magic" property
    ant.junit.enabletestlistenerevents has been added that can be used
    to reinstate the old behavior.
 
 Fixed bugs:
 -----------
 
  * hostinfo now prefers addresses with a hostname over addresses without 
    a hostname, provided the addresses have the same scope.
    For local lookup, no IP address will be put in NAME / DOMAIN anymore.
    For remote lookup, if a host name was provided and only an IP address is 
    found, the IP address will no longer overwrite the host name provided to the
    task.
    Bugzilla Report 49513
 
  * mmap-based file copy problems under JDK 1.4 on Linux.
    Bugzilla Report 49430.
 
  * The Sun JVM tries to mmap the entire file during a copy. 
    For large files this is not feasible. 
    We now explicitly request to copy at most 16 MiB per request.
    Bugzilla Report 49326.
 
  * DemuxInputStream.read() should return unsigned values
    Bugzilla Report 49279.
 
  * The MIME mailer ignored the port parameter when using SSL.
    Bugzilla Report 49267.
 
  * <xslt> ignored the classpath when using the default TraX processor.
    Bugzilla Report 49271.
 
  * <checksum>'s totalproperty only worked reliably if the same file
    name didn't occur inside more than one directory.
    Bugzilla Report 36748.
 
  * <ftp> could fail to download files from remote subdirectories under
    certain circumstances.
    Bugzilla Report 49296.
 
  * <junit> will now produce better diagnostics when it fails to delete
    a temporary file.
    Bugzilla Report 49419.
 
  * Ant would often scan directories even though there were known to
    only hold excluded files when evaluating filesets.  This never
    resulted in wrong results but degraded performance of the scan
    itself.
    Bugzilla Report 49420.
 
  * <javac> failed for long command lines on OS/2.
    Bugzilla Report 49425.
 
  * <junitreport> did not handle encodings well for stdout/stderr.
    Bugzilla Report 49418.
 
  * <junit> could issue a warning about multiple versions of Ant on the
    CLASSPATH if two CLASSPATH entries differed in case on a
    case-insensitive file system.
    Bugzilla Report 49041.
 
  * The <restrict> resource collection was checking every resource even if
    we actually just want the first one, like in the example of use of
    resourcelist in the documentation (getting the first available resource
    from a mirror list).
 
  * A race condition could lead to build failures if multiple <mkdir>
    tasks were trying to create the same directory.
    Bugzilla Report 49572.
 
  * the toString() method of the Resources class - and thus any
    ${toString:} expansion of a reference to a <resources> element -
    didn't iterate over its nested elements if it hadn't done so prior
    to the toString invocation already.
    Bugzilla Report 49588.
 
  * <apply> in parallel mode didn't work together with a nested
    <redirector> if maxparallel was <= 0 (the default) or no source
    files matched.
    Bugzilla Report 49594.
 
  * <jar filesetmanifest="merge"> didn't work for manifests added via
    <zipfileset>s that used the prefix or fullpath attributes.
    Bugzilla Report 49605.
 
  * <tempfile createfile="true"> would cause an error unless the prefix
    attribute has been specified.
    Bugzilla Report 49755.
 
  * If forked, after finished <java> was still reading the input stream
    for a bunch of characters, then stealing them from a following <input>.
    Bugzilla Report 49119.
 
  * Ant could be leaking threads for each forked process (started by
    <exec>, <apply>, <java> or similar tasks) that didn't receive input
    from a resource or string explicitly.
    Bugzilla Report 49587.
 
  * Project#setDefault threw an exception when null was passed in as
    argument, even though the Javadoc says null is a valid value.
    Bugzilla Report 49803.
 
  * runant.py would swallow the first argument if CLASSPATH wasn't set.
    Bugzilla Report 49963.
 
  * <taskdef> failed to load resources from jar files contained in a
    directory that has a "!" in its name.
    Bugzilla Report 50007.
 
  * ant.bat exit strategy improvements and issues
    make the exit codes work in environments where 4NT or MKS are installed
    Bugzilla Report 41039.
 
  * <signjar> would fail if used via its Java API and the File passed
    into the setJar method was not "normalized" (i.e. contained ".."
    segments).
    Bugzilla Report 50081.
 
  * <delete> ignored <fileset>'s errorOnMissingDir attribute
    Bugzilla Report 50124.
 
  * <symlink> failed to close files when reading a list of symbolic
    links from a properties file.
    Bugzilla Report 50136.
 
  * <parallel> could allow tasks to start executing even if a task
    scheduled to run before them timed out.
    Bugzilla Report 49527.
 
  * If a <junit> batch with multiple tests times out Ant logs a message
    about a test named Batch-With-Multiple-Tests since 1.8.0 but the
    logic that determined the Java package of this pseudo-test has been
    wrong.
    Bugzilla Report 45227.
 
  * <propertyfile> didn't preserve the original linefeed style when
    updating a file.
    Bugzilla Report 50049.
 
  * <zip>'s whenEmpty behavior never consulted the non-fileset
    resources so the task could fail even though resources have been
    provided using non-fileset resource collections.
    Bugzilla Issue 50115.
 
 *  ftp chmod could throw a NPE.
    Bugzilla report 50217.
 
 *  The project help (-p option in the command line) will now print
    the dependencies of the targets in debug mode (-d on the command
    line)
 
 Other changes:
 --------------
 
  * <concat>'s force attribute has been deprecated in favor of a new
    overwrite attribute that is consistent with <copy>'s attribute
    names.
 
  * You can now specify a list of methods to run in a JUnit test case.
    Bugzilla Report 34748.
 
  * properties in files read because of the -propertyfile command line
    option will now get resolved against other properties that are
    defined before the project starts executing (those from the same or
    earlier -propertfiles or defined via the -D option).
    Bugzilla Report 18732.
 
  * <pathelement>s can now contain wildcards in order to use wildcard
    CLASSPATH entries introduced with Java6.
    The wildcards are not expanded or even evaluated by Ant and will be
    used literally.  The resulting path may be unusable as a CLASSPATH
    for Java versions prior to Java6 and likely doesn't mean anything
    when used in any other way than a CLASSPATH for a forked Java VM. 
    Bugzilla Report 46842.
 
  * A new attribute allows targets to deal with nonexistent extension
    points, i.e. they can extend an extension-point if it has been
    defined or silently work as plain targets if it hasn't.  This is
    useful for targets that get included/imported in different
    scenarios where a given extension-point may or may not exist.
    Bugzilla Report 49473.
 
  * Ant now logs a warning message if it fails to change the file
    modification time in for example when using <touch> or preserving
    timestamps in various tasks.
    Bugzilla Report 49485.
 
  * ProjectHelpers can now be installed dynamically via the <projecthelper>
    Ant task.
 
  * <import> is now able to switch to the proper ProjectHelper to parse
    the imported resource. This means that several kinds of different build
    files can import each other.
 
  * <copy tofile=""> now also works for non-filesystem resources.
    Bugzilla Report 49756.
 
  * The <linecontainsregexp> filter now supports a casesensitive
    attribute.
 
  * The <containsregexp> selector now supports casesensitive, multiline
    and singleline attributes.
    Bugzilla Report 49764.
 
  * A new <cutdirsmapper> can be used like wget's --cut-dirs option to
    strip leading directories from file names.
 
  * <javah> now supports the GNU project's gcjh compiler.
    Bugzilla Report 50149.
 
  * <checksum> supports additional views of a file's path as elements
    for a custom pattern.
    Bugzilla Report 50114.
 
  * JUnit XMLResultAggregator logs the stack trace of caught IO exceptions
    in verbose runs.
    Bugzilla Report 48836.
 
  * StringUtils.parseHumanSizes() should turn parse failures into
    BuildExceptions.
    Bugzilla Report 48835.
 
  * New task <bindtargets> to make a list of targets bound to some
    specified extension point.
 
  * Initial support for OpenJDK7 has been added.
 
  * Ant now uses java.net.CookieStore rather than
    java.util.ServiceLocator to detect whether the environment is a
    Java 1.6 system.  This means releases of gcj/gij at the time of
    this release of Ant are detected as Java 1.5 and not 1.6.
    Bugzilla Report 50256.
 
  * It is now possible to write a compiler adapter for <javac> that
    compiles sources with extensions other than .java (but that still
    compile to .class files).
    Bugzilla Report 48829.
 
  * The performance of VectorSet#add(Object) has been improved which
    should also benefit any operation that scans directories in Ant.
    Bugzilla Report 50200.
 
 Changes from Ant 1.8.0 TO Ant 1.8.1 
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * ant-trax.jar is no longer produced since TrAX is included in JDK 1.4+.
 
  * Ant no longer ships with Apache Xerces-J or the XML APIs but relies
    on the Java runtime to provide a parser and matching API versions.
 
  * The stylebook ant task and the ant-stylebook.jar are removed.
 
 Fixed bugs:
 -----------
 
  * Tasks that iterate over task or type definitions, references or
    targets now iterate over copies instead of the live maps to avoid
    ConcurrentModificationExceptions if another thread changes the
    maps.
    Bugzilla Report 48310.
 
  * The filesmatch condition threw a NullPointerException when
    comparing text files and the second file contained fewer lines than
    the first one.
    Bugzilla Report 48715.
 
  * Regression: The <ear> task would allow multiple
    META-INF/application.xml files to be added.
    Bugzilla Report 6836.
 
  * VectorSet#remove(Object) would fail if the size of the vector
    equaled its capacity.
 
  * Regression : ant -diagnostics was returning with exit code 1
    Bugzilla Report 48782
 
  * Fix for exec task sometimes inserts extraneous newlines
    Bugzilla Report 48746
 
  * SymlinkTest#testSymbolicLinkUtilsMethods failing on MacOS
    Bugzilla Report 48785.
 
  * If <concat>'s first resourcecollection child is a <resources>,
    any subsequently added child resourcecollection joins the first.
    Bugzilla Report 48816.
 
  * <get> with an invalid URL could trigger an NPE in some JVMs.
    Bugzilla Report 48833
 
  * Broken Pipe issue under Ubuntu Linux
    Bugzilla Report 48789
 
  * Properties wrongly read from file or not update during read
    Bugzilla Report 48768
 
  * AntClassLoader in Ant 1.8.0 has been considerably slower than in
    1.7.1
    Bugzilla Report 48853
 
  * ANT_CMD_LINE_ARGS are rippling through lower level Ant usage 
    Bugzilla Report 48876
 
  * email : IO error sending mail with plain mimetype
    Bugzilla Report 48932
 
  * the complete-ant-cmd.pl script failed to create a proper cache of
    target if "ant -p" failed.
    Bugzilla Report 48980
 
  * <rmic>'s sourcebase attribute was broken.
    Bugzilla Report 48970
 
  * <copy>'s failonerror didn't work as expected when copying a single
    element resource collection to a file.
    Bugzilla Report 49070
 
  * <get> no longer followed redirects if the redirect URL was relative
    and not an absolute URL.
    Bugzilla Report 48972
 
  * fixed a performance degradation in the code that expands property
    references.
    Bugzilla Reports 48961 and 49079
 
  * <jar filesetmanifest="merge"> was broken on Windows.
    Bugzilla Report 49090
 
  * <symlink> delete failed if the link attribute was a relative path
    to a link inside the current directory without a leading ".".
    Bugzilla Report 49137
 
  * <telnet> and <rexec> failed to find the expected strings when
    waiting for responses and thus always failed.
    Bugzilla Report 49173
 
 Other changes:
 --------------
 
  * Project provides new get methods that return copies instead of the
    live maps of task and type definitions, references and targets.
 
  * Ant is now more lenient with ZIP extra fields and will be able to
    read archives that it failed to read in earlier versions.
    Bugzilla Report 48781.
 
  * The <zip> family of tasks has been sped up for bigger archives.
    Bugzilla Report 48755.
 
  * Add removeKeepExtension option to NetRexxC task.
    Bugzilla Report 48788.
 
  * Add prefix attribute to loadproperties task.
 
  * Add resource attribute to length task.
 
  * PropertyResource will effectively proxy another Resource if ${name}
    evaluates to a Resource object.
 
  * Added forcestring attribute to equals condition to force evaluation
    of Object args as strings; previously only API-level usage of the
    equals condition allowed Object args, but Ant 1.8.x+ property
    evaluation may yield values of any type.
 
  * BuildFileTest.assertPropertyUnset() fails with a slightly more 
    meaningful error message
    Bugzilla Report 48834
 
  * <junit> will now throw an exception if a test name is empty.  This
    used to manifest itself in unrelated errors like
    Bugzilla Report 43586.
 
  * A change that made <exec> more reliable on Windows (Bugzilla Report
    5003) strongly impacts the performance for commands that execute
    quickly, like attrib.  Basically no single execution of a command
    could take less than a second on Windows.
    A few timeouts have been tweaked to allow these commands to finish
    more quickly but still they will take longer than they did with Ant
    1.7.1.
    Bugzilla Report 48734.
 
  * Added SimpleBigProjectLogger, intermediate between NoBannerLogger and
    BigProjectLogger.
 
  * <mappedresources> supports new attributes enablemultiplemappings
    and cache.
 
  * Added the augment task to manipulate existing references via Ant's basic
    introspection mechanisms.
 
 Changes from Ant 1.8.0RC1 TO Ant 1.8.0
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * the appendtolines filter has been renamed to suffixlines.
 
 Fixed bugs:
 -----------
 
  * stack traces were not reported at all by <junit/>
    when filtertrace="on", which is the default.
 
  * ant.bat can now also process the -noclasspath switch when it is 
    the first switch on a command line.
    Bugzilla Report 48186.
 
  * <fixcrlf> now tries to delete the created temporary files earlier.
    Bugzilla Report 48506.
 
  * the implementation of <zip> had been changed in a way that broke
    the jarjar links task and protentially other third-party subclasses
    as well.
    Bugzilla Report 48541.
 
  * <scp> task didn't report build file location when a remote operation failed
    Bugzilla Report 48578.
 
  * <propertyfile> would add the same comment and a date line each time
    it updated an existing property file.
    Bugzilla Report 48558.
 
  * <sound> didn't work properly in recent Java VMs.
    Bugzilla Report 48637.
 
 Other changes:
 --------------
 
 Changes from Ant 1.7.1 TO Ant 1.8.0RC1
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * if and unless attributes (on <target> as well as various tasks and other
    elements) have long permitted ${property} interpolation. Now, if the result
    evaluates to "true" or "false" (or "yes", "no", "on", "off"), that boolean
    value will be used; otherwise the traditional behavior of treating the value
    as a property name (defined ~ true, undefined ~ false) is used. Existing
    scripts could be broken if they perversely defined a property named "false"
    and expected if="false" to be true, or used if="true" expecting this to be
    triggered only if a property named "true" were defined.
 
  * Ant now requires Java 1.4 or later.
 
  * Improved handling of InterruptException (lets suppose someone/thing
    is trying to kill the thread when we receive an
    InterruptException), when an InterruptException is received, we do
    not wait anymore in a while loop till the end time has been
    reached.
    Bugzilla Report 42924.
 
  * Refactor PropertyHelper and introspection APIs to make extension
    more granular and support setting task/type attribute values to
    objects decoded by custom PropertyEvaluator delegates. Also add
    <propertyhelper> task for registering delegates and/or replacing
    the registered PropertyHelper instance.
    Bugzilla Report 42736.
 
  * Added a restricted form of typedef called <componentdef>. This
    allows definition of elements that can only be within tasks or
    types. This method is now used to define conditions, selectors,
    comparators and filterreaders. This means that tasks may now have
    nested conditions just by implementing the Condition interface,
diff --git a/src/main/org/apache/tools/ant/AntClassLoader.java b/src/main/org/apache/tools/ant/AntClassLoader.java
index 7be318b25..58351f9f2 100644
--- a/src/main/org/apache/tools/ant/AntClassLoader.java
+++ b/src/main/org/apache/tools/ant/AntClassLoader.java
@@ -1,1564 +1,1577 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant;
 
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.Constructor;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.security.CodeSource;
 import java.security.ProtectionDomain;
 import java.security.cert.Certificate;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.StringTokenizer;
 import java.util.Vector;
 import java.util.jar.Attributes;
 import java.util.jar.Attributes.Name;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
+import java.util.zip.ZipException;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.util.CollectionUtils;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.JavaEnvUtils;
 import org.apache.tools.ant.util.LoaderUtils;
 import org.apache.tools.ant.util.ReflectUtil;
 import org.apache.tools.ant.util.VectorSet;
 import org.apache.tools.ant.launch.Locator;
 
 /**
  * Used to load classes within ant with a different classpath from
  * that used to start ant. Note that it is possible to force a class
  * into this loader even when that class is on the system classpath by
  * using the forceLoadClass method. Any subsequent classes loaded by that
  * class will then use this loader rather than the system class loader.
  *
  * <p>
  * Note that this classloader has a feature to allow loading
  * in reverse order and for "isolation".
  * Due to the fact that a number of
  * methods in java.lang.ClassLoader are final (at least
  * in java 1.4 getResources) this means that the
  * class has to fake the given parent.
  * </p>
  *
  */
 public class AntClassLoader extends ClassLoader implements SubBuildListener {
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * An enumeration of all resources of a given name found within the
      * classpath of this class loader. This enumeration is used by the
      * ClassLoader.findResources method, which is in
      * turn used by the ClassLoader.getResources method.
      *
      * @see AntClassLoader#findResources(String)
      * @see java.lang.ClassLoader#getResources(String)
      */
     private class ResourceEnumeration implements Enumeration<URL> {
         /**
          * The name of the resource being searched for.
          */
         private String resourceName;
 
         /**
          * The index of the next classpath element to search.
          */
         private int pathElementsIndex;
 
         /**
          * The URL of the next resource to return in the enumeration. If this
          * field is <code>null</code> then the enumeration has been completed,
          * i.e., there are no more elements to return.
          */
         private URL nextResource;
 
         /**
          * Constructs a new enumeration of resources of the given name found
          * within this class loader's classpath.
          *
          * @param name the name of the resource to search for.
          */
         ResourceEnumeration(String name) {
             this.resourceName = name;
             this.pathElementsIndex = 0;
             findNextResource();
         }
 
         /**
          * Indicates whether there are more elements in the enumeration to
          * return.
          *
          * @return <code>true</code> if there are more elements in the
          *         enumeration; <code>false</code> otherwise.
          */
         public boolean hasMoreElements() {
             return (this.nextResource != null);
         }
 
         /**
          * Returns the next resource in the enumeration.
          *
          * @return the next resource in the enumeration
          */
         public URL nextElement() {
             URL ret = this.nextResource;
             if (ret == null) {
                 throw new NoSuchElementException();
             }
             findNextResource();
             return ret;
         }
 
         /**
          * Locates the next resource of the correct name in the classpath and
          * sets <code>nextResource</code> to the URL of that resource. If no
          * more resources can be found, <code>nextResource</code> is set to
          * <code>null</code>.
          */
         private void findNextResource() {
             URL url = null;
             while ((pathElementsIndex < pathComponents.size()) && (url == null)) {
                 try {
                     File pathComponent = (File) pathComponents.elementAt(pathElementsIndex);
                     url = getResourceURL(pathComponent, this.resourceName);
                     pathElementsIndex++;
                 } catch (BuildException e) {
                     // ignore path elements which are not valid relative to the
                     // project
                 }
             }
             this.nextResource = url;
         }
     }
 
     /**
      * The size of buffers to be used in this classloader.
      */
     private static final int BUFFER_SIZE = 8192;
 
     /**
      * Number of array elements in a test array of strings
      */
     private static final int NUMBER_OF_STRINGS = 256;
 
     /**
      * The components of the classpath that the classloader searches
      * for classes.
      */
     private Vector<File> pathComponents  = new VectorSet<File>();
 
     /**
      * The project to which this class loader belongs.
      */
     private Project project;
 
     /**
      * Indicates whether the parent class loader should be
      * consulted before trying to load with this class loader.
      */
     private boolean parentFirst = true;
 
     /**
      * These are the package roots that are to be loaded by the parent class
      * loader regardless of whether the parent class loader is being searched
      * first or not.
      */
     private Vector<String> systemPackages = new Vector<String>();
 
     /**
      * These are the package roots that are to be loaded by this class loader
      * regardless of whether the parent class loader is being searched first
      * or not.
      */
     private Vector<String> loaderPackages = new Vector<String>();
 
     /**
      * Whether or not this classloader will ignore the base
      * classloader if it can't find a class.
      *
      * @see #setIsolated(boolean)
      */
     private boolean ignoreBase = false;
 
     /**
      * The parent class loader, if one is given or can be determined.
      */
     private ClassLoader parent = null;
 
     /**
      * A hashtable of zip files opened by the classloader (File to JarFile).
      */
     private Hashtable<File, JarFile> jarFiles = new Hashtable<File, JarFile>();
 
     /** Static map of jar file/time to manifest class-path entries */
     private static Map<String,String> pathMap = Collections.synchronizedMap(new HashMap<String, String>());
 
     /**
      * The context loader saved when setting the thread's current
      * context loader.
      */
     private ClassLoader savedContextLoader = null;
 
     /**
      * Whether or not the context loader is currently saved.
      */
     private boolean isContextLoaderSaved = false;
 
     /**
      * Create an Ant ClassLoader for a given project, with
      * a parent classloader and an initial classpath.
      * @since Ant 1.7.
      * @param parent the parent for this classloader.
      * @param project The project to which this classloader is to
      *                belong.
      * @param classpath The classpath to use to load classes.
      */
     public AntClassLoader(ClassLoader parent, Project project, Path classpath) {
         setParent(parent);
         setClassPath(classpath);
         setProject(project);
     }
 
     /**
      * Create an Ant Class Loader
      */
     public AntClassLoader() {
         setParent(null);
     }
 
     /**
      * Creates a classloader for the given project using the classpath given.
      *
      * @param project The project to which this classloader is to belong.
      *                Must not be <code>null</code>.
      * @param classpath The classpath to use to load the classes.  This
      *                is combined with the system classpath in a manner
      *                determined by the value of ${build.sysclasspath}.
      *                May be <code>null</code>, in which case no path
      *                elements are set up to start with.
      */
     public AntClassLoader(Project project, Path classpath) {
         setParent(null);
         setProject(project);
         setClassPath(classpath);
     }
 
     /**
      * Creates a classloader for the given project using the classpath given.
      *
      * @param parent The parent classloader to which unsatisfied loading
      *               attempts are delegated. May be <code>null</code>,
      *               in which case the classloader which loaded this
      *               class is used as the parent.
      * @param project The project to which this classloader is to belong.
      *                Must not be <code>null</code>.
      * @param classpath the classpath to use to load the classes.
      *                  May be <code>null</code>, in which case no path
      *                  elements are set up to start with.
      * @param parentFirst If <code>true</code>, indicates that the parent
      *                    classloader should be consulted  before trying to
      *                    load the a class through this loader.
      */
     public AntClassLoader(
         ClassLoader parent, Project project, Path classpath, boolean parentFirst) {
         this(project, classpath);
         if (parent != null) {
             setParent(parent);
         }
         setParentFirst(parentFirst);
         addJavaLibraries();
     }
 
     /**
      * Creates a classloader for the given project using the classpath given.
      *
      * @param project The project to which this classloader is to belong.
      *                Must not be <code>null</code>.
      * @param classpath The classpath to use to load the classes. May be
      *                  <code>null</code>, in which case no path
      *                  elements are set up to start with.
      * @param parentFirst If <code>true</code>, indicates that the parent
      *                    classloader should be consulted before trying to
      *                    load the a class through this loader.
      */
     public AntClassLoader(Project project, Path classpath, boolean parentFirst) {
         this(null, project, classpath, parentFirst);
     }
 
     /**
      * Creates an empty class loader. The classloader should be configured
      * with path elements to specify where the loader is to look for
      * classes.
      *
      * @param parent The parent classloader to which unsatisfied loading
      *               attempts are delegated. May be <code>null</code>,
      *               in which case the classloader which loaded this
      *               class is used as the parent.
      * @param parentFirst If <code>true</code>, indicates that the parent
      *                    classloader should be consulted before trying to
      *                    load the a class through this loader.
      */
     public AntClassLoader(ClassLoader parent, boolean parentFirst) {
         setParent(parent);
         project = null;
         this.parentFirst = parentFirst;
     }
 
     /**
      * Set the project associated with this class loader
      *
      * @param project the project instance
      */
     public void setProject(Project project) {
         this.project = project;
         if (project != null) {
             project.addBuildListener(this);
         }
     }
 
     /**
      * Set the classpath to search for classes to load. This should not be
      * changed once the classloader starts to server classes
      *
      * @param classpath the search classpath consisting of directories and
      *        jar/zip files.
      */
     public void setClassPath(Path classpath) {
         pathComponents.removeAllElements();
         if (classpath != null) {
             Path actualClasspath = classpath.concatSystemClasspath("ignore");
             String[] pathElements = actualClasspath.list();
             for (int i = 0; i < pathElements.length; ++i) {
                 try {
                     addPathElement(pathElements[i]);
                 } catch (BuildException e) {
                     // ignore path elements which are invalid
                     // relative to the project
                 }
             }
         }
     }
 
     /**
      * Set the parent for this class loader. This is the class loader to which
      * this class loader will delegate to load classes
      *
      * @param parent the parent class loader.
      */
     public void setParent(ClassLoader parent) {
         this.parent = parent == null ? AntClassLoader.class.getClassLoader() : parent;
     }
 
     /**
      * Control whether class lookup is delegated to the parent loader first
      * or after this loader. Use with extreme caution. Setting this to
      * false violates the class loader hierarchy and can lead to Linkage errors
      *
      * @param parentFirst if true, delegate initial class search to the parent
      *                    classloader.
      */
     public void setParentFirst(boolean parentFirst) {
         this.parentFirst = parentFirst;
     }
 
     /**
      * Logs a message through the project object if one has been provided.
      *
      * @param message The message to log.
      *                Should not be <code>null</code>.
      *
      * @param priority The logging priority of the message.
      */
     protected void log(String message, int priority) {
         if (project != null) {
             project.log(message, priority);
         }
     }
 
     /**
      * Sets the current thread's context loader to this classloader, storing
      * the current loader value for later resetting.
      */
     public void setThreadContextLoader() {
         if (isContextLoaderSaved) {
             throw new BuildException("Context loader has not been reset");
         }
         if (LoaderUtils.isContextLoaderAvailable()) {
             savedContextLoader = LoaderUtils.getContextClassLoader();
             ClassLoader loader = this;
             if (project != null && "only".equals(project.getProperty("build.sysclasspath"))) {
                 loader = this.getClass().getClassLoader();
             }
             LoaderUtils.setContextClassLoader(loader);
             isContextLoaderSaved = true;
         }
     }
 
     /**
      * Resets the current thread's context loader to its original value.
      */
     public void resetThreadContextLoader() {
         if (LoaderUtils.isContextLoaderAvailable() && isContextLoaderSaved) {
             LoaderUtils.setContextClassLoader(savedContextLoader);
             savedContextLoader = null;
             isContextLoaderSaved = false;
         }
     }
 
 
     /**
      * Adds an element to the classpath to be searched.
      *
      * @param pathElement The path element to add. Must not be
      *                    <code>null</code>.
      *
      * @exception BuildException if the given path element cannot be resolved
      *                           against the project.
      */
     public void addPathElement(String pathElement) throws BuildException {
         File pathComponent = project != null ? project.resolveFile(pathElement) : new File(
                 pathElement);
         try {
             addPathFile(pathComponent);
         } catch (IOException e) {
             throw new BuildException(e);
         }
     }
 
     /**
      * Add a path component.
      * This simply adds the file, unlike addPathElement
      * it does not open jar files and load files from
      * their CLASSPATH entry in the manifest file.
      * @param file the jar file or directory to add.
      */
     public void addPathComponent(File file) {
         if (pathComponents.contains(file)) {
             return;
         }
         pathComponents.addElement(file);
     }
 
     /**
      * Add a file to the path.
      * Reads the manifest, if available, and adds any additional class path jars
      * specified in the manifest.
      *
      * @param pathComponent the file which is to be added to the path for
      *                      this class loader
      *
      * @throws IOException if data needed from the file cannot be read.
      */
     protected void addPathFile(File pathComponent) throws IOException {
         if (!pathComponents.contains(pathComponent)) {
             pathComponents.addElement(pathComponent);
         }
         if (pathComponent.isDirectory()) {
             return;
         }
 
         String absPathPlusTimeAndLength = pathComponent.getAbsolutePath()
                 + pathComponent.lastModified() + "-" + pathComponent.length();
         String classpath = (String) pathMap.get(absPathPlusTimeAndLength);
         if (classpath == null) {
             JarFile jarFile = null;
             try {
                 jarFile = new JarFile(pathComponent);
                 Manifest manifest = jarFile.getManifest();
                 if (manifest == null) {
                     return;
                 }
                 classpath = manifest.getMainAttributes()
                     .getValue(Attributes.Name.CLASS_PATH);
             } finally {
                 if (jarFile != null) {
                     jarFile.close();
                 }
             }
             if (classpath == null) {
                 classpath = "";
             }
             pathMap.put(absPathPlusTimeAndLength, classpath);
         }
 
         if (!"".equals(classpath)) {
             URL baseURL = FILE_UTILS.getFileURL(pathComponent);
             StringTokenizer st = new StringTokenizer(classpath);
             while (st.hasMoreTokens()) {
                 String classpathElement = st.nextToken();
                 URL libraryURL = new URL(baseURL, classpathElement);
                 if (!libraryURL.getProtocol().equals("file")) {
                     log("Skipping jar library " + classpathElement
                             + " since only relative URLs are supported by this" + " loader",
                             Project.MSG_VERBOSE);
                     continue;
                 }
                 String decodedPath = Locator.decodeUri(libraryURL.getFile());
                 File libraryFile = new File(decodedPath);
                 if (libraryFile.exists() && !isInPath(libraryFile)) {
                     addPathFile(libraryFile);
                 }
             }
         }
     }
 
     /**
      * Returns the classpath this classloader will consult.
      *
      * @return the classpath used for this classloader, with elements
      *         separated by the path separator for the system.
      */
     public String getClasspath() {
         final StringBuilder sb = new StringBuilder();
         boolean firstPass = true;
         Enumeration<File> componentEnum = pathComponents.elements();
         while (componentEnum.hasMoreElements()) {
             if (!firstPass) {
                 sb.append(System.getProperty("path.separator"));
             } else {
                 firstPass = false;
             }
             sb.append(componentEnum.nextElement().getAbsolutePath());
         }
         return sb.toString();
     }
 
     /**
      * Sets whether this classloader should run in isolated mode. In
      * isolated mode, classes not found on the given classpath will
      * not be referred to the parent class loader but will cause a
      * ClassNotFoundException.
      *
      * @param isolated Whether or not this classloader should run in
      *                 isolated mode.
      */
     public synchronized void setIsolated(boolean isolated) {
         ignoreBase = isolated;
     }
 
     /**
      * Forces initialization of a class in a JDK 1.1 compatible, albeit hacky
      * way.
      *
      * @param theClass The class to initialize.
      *                 Must not be <code>null</code>.
      *
      * @deprecated since 1.6.x.
      *             Use Class.forName with initialize=true instead.
      */
     public static void initializeClass(Class<?> theClass) {
         // ***HACK*** We ask the VM to create an instance
         // by voluntarily providing illegal arguments to force
         // the VM to run the class' static initializer, while
         // at the same time not running a valid constructor.
 
         final Constructor<?>[] cons = theClass.getDeclaredConstructors();
         //At least one constructor is guaranteed to be there, but check anyway.
         if (cons != null) {
             if (cons.length > 0 && cons[0] != null) {
                 final String[] strs = new String[NUMBER_OF_STRINGS];
                 try {
                     cons[0].newInstance((Object[]) strs);
                     // Expecting an exception to be thrown by this call:
                     // IllegalArgumentException: wrong number of Arguments
                 } catch (Exception e) {
                     // Ignore - we are interested only in the side
                     // effect - that of getting the static initializers
                     // invoked.  As we do not want to call a valid
                     // constructor to get this side effect, an
                     // attempt is made to call a hopefully
                     // invalid constructor - come on, nobody
                     // would have a constructor that takes in
                     // 256 String arguments ;-)
                     // (In fact, they can't - according to JVM spec
                     // section 4.10, the number of method parameters is limited
                     // to 255 by the definition of a method descriptor.
                     // Constructors count as methods here.)
                 }
             }
         }
     }
 
     /**
      * Adds a package root to the list of packages which must be loaded on the
      * parent loader.
      *
      * All subpackages are also included.
      *
      * @param packageRoot The root of all packages to be included.
      *                    Should not be <code>null</code>.
      */
     public void addSystemPackageRoot(String packageRoot) {
         systemPackages.addElement(packageRoot + (packageRoot.endsWith(".") ? "" : "."));
     }
 
     /**
      * Adds a package root to the list of packages which must be loaded using
      * this loader.
      *
      * All subpackages are also included.
      *
      * @param packageRoot The root of all packages to be included.
      *                    Should not be <code>null</code>.
      */
     public void addLoaderPackageRoot(String packageRoot) {
         loaderPackages.addElement(packageRoot + (packageRoot.endsWith(".") ? "" : "."));
     }
 
     /**
      * Loads a class through this class loader even if that class is available
      * on the parent classpath.
      *
      * This ensures that any classes which are loaded by the returned class
      * will use this classloader.
      *
      * @param classname The name of the class to be loaded.
      *                  Must not be <code>null</code>.
      *
      * @return the required Class object
      *
      * @exception ClassNotFoundException if the requested class does not exist
      *                                   on this loader's classpath.
      */
     public Class<?> forceLoadClass(String classname) throws ClassNotFoundException {
         log("force loading " + classname, Project.MSG_DEBUG);
 
         Class<?> theClass = findLoadedClass(classname);
 
         if (theClass == null) {
             theClass = findClass(classname);
         }
         return theClass;
     }
 
     /**
      * Loads a class through this class loader but defer to the parent class
      * loader.
      *
      * This ensures that instances of the returned class will be compatible
      * with instances which have already been loaded on the parent
      * loader.
      *
      * @param classname The name of the class to be loaded.
      *                  Must not be <code>null</code>.
      *
      * @return the required Class object
      *
      * @exception ClassNotFoundException if the requested class does not exist
      * on this loader's classpath.
      */
     public Class<?> forceLoadSystemClass(String classname) throws ClassNotFoundException {
         log("force system loading " + classname, Project.MSG_DEBUG);
 
         Class<?> theClass = findLoadedClass(classname);
 
         if (theClass == null) {
             theClass = findBaseClass(classname);
         }
         return theClass;
     }
 
     /**
      * Returns a stream to read the requested resource name.
      *
      * @param name The name of the resource for which a stream is required.
      *             Must not be <code>null</code>.
      *
      * @return a stream to the required resource or <code>null</code> if the
      *         resource cannot be found on the loader's classpath.
      */
     public InputStream getResourceAsStream(String name) {
         InputStream resourceStream = null;
         if (isParentFirst(name)) {
             resourceStream = loadBaseResource(name);
         }
         if (resourceStream != null) {
             log("ResourceStream for " + name
                 + " loaded from parent loader", Project.MSG_DEBUG);
         } else {
             resourceStream = loadResource(name);
             if (resourceStream != null) {
                 log("ResourceStream for " + name
                     + " loaded from ant loader", Project.MSG_DEBUG);
             }
         }
         if (resourceStream == null && !isParentFirst(name)) {
             if (ignoreBase) {
                 resourceStream = getRootLoader() == null ? null : getRootLoader().getResourceAsStream(name);
             } else {
                 resourceStream = loadBaseResource(name);
             }
             if (resourceStream != null) {
                 log("ResourceStream for " + name + " loaded from parent loader",
                     Project.MSG_DEBUG);
             }
         }
         if (resourceStream == null) {
             log("Couldn't load ResourceStream for " + name, Project.MSG_DEBUG);
         }
         return resourceStream;
     }
 
     /**
      * Returns a stream to read the requested resource name from this loader.
      *
      * @param name The name of the resource for which a stream is required.
      *             Must not be <code>null</code>.
      *
      * @return a stream to the required resource or <code>null</code> if
      *         the resource cannot be found on the loader's classpath.
      */
     private InputStream loadResource(String name) {
         // we need to search the components of the path to see if we can
         // find the class we want.
         InputStream stream = null;
 
         Enumeration<File> e = pathComponents.elements();
         while (e.hasMoreElements() && stream == null) {
             File pathComponent = e.nextElement();
             stream = getResourceStream(pathComponent, name);
         }
         return stream;
     }
 
     /**
      * Finds a system resource (which should be loaded from the parent
      * classloader).
      *
      * @param name The name of the system resource to load.
      *             Must not be <code>null</code>.
      *
      * @return a stream to the named resource, or <code>null</code> if
      *         the resource cannot be found.
      */
     private InputStream loadBaseResource(String name) {
         return parent == null ? super.getResourceAsStream(name) : parent.getResourceAsStream(name);
     }
 
     /**
      * Returns an inputstream to a given resource in the given file which may
      * either be a directory or a zip file.
      *
      * @param file the file (directory or jar) in which to search for the
      *             resource. Must not be <code>null</code>.
      * @param resourceName The name of the resource for which a stream is
      *                     required. Must not be <code>null</code>.
      *
      * @return a stream to the required resource or <code>null</code> if
      *         the resource cannot be found in the given file.
      */
     private InputStream getResourceStream(File file, String resourceName) {
         try {
             JarFile jarFile = (JarFile) jarFiles.get(file);
             if (jarFile == null && file.isDirectory()) {
                 File resource = new File(file, resourceName);
                 if (resource.exists()) {
                     return new FileInputStream(resource);
                 }
             } else {
                 if (jarFile == null) {
                     if (file.exists()) {
                         jarFile = new JarFile(file);
                         jarFiles.put(file, jarFile);
                     } else {
                         return null;
                     }
                     //to eliminate a race condition, retrieve the entry
                     //that is in the hash table under that filename
                     jarFile = (JarFile) jarFiles.get(file);
                 }
                 JarEntry entry = jarFile.getJarEntry(resourceName);
                 if (entry != null) {
                     return jarFile.getInputStream(entry);
                 }
             }
         } catch (Exception e) {
             log("Ignoring Exception " + e.getClass().getName() + ": " + e.getMessage()
                     + " reading resource " + resourceName + " from " + file, Project.MSG_VERBOSE);
         }
         return null;
     }
 
     /**
      * Tests whether or not the parent classloader should be checked for a
      * resource before this one. If the resource matches both the "use parent
      * classloader first" and the "use this classloader first" lists, the latter
      * takes priority.
      *
      * @param resourceName
      *            The name of the resource to check. Must not be
      *            <code>null</code>.
      *
      * @return whether or not the parent classloader should be checked for a
      *         resource before this one is.
      */
     private boolean isParentFirst(String resourceName) {
         // default to the global setting and then see
         // if this class belongs to a package which has been
         // designated to use a specific loader first
         // (this one or the parent one)
 
         // TODO - shouldn't this always return false in isolated mode?
 
         boolean useParentFirst = parentFirst;
 
         for (Enumeration<String> e = systemPackages.elements(); e.hasMoreElements();) {
             String packageName = e.nextElement();
             if (resourceName.startsWith(packageName)) {
                 useParentFirst = true;
                 break;
             }
         }
         for (Enumeration<String> e = loaderPackages.elements(); e.hasMoreElements();) {
             String packageName = e.nextElement();
             if (resourceName.startsWith(packageName)) {
                 useParentFirst = false;
                 break;
             }
         }
         return useParentFirst;
     }
 
     /**
      * Used for isolated resource seaching.
      * @return the root classloader of AntClassLoader.
      */
     private ClassLoader getRootLoader() {
         ClassLoader ret = getClass().getClassLoader();
         while (ret != null && ret.getParent() != null) {
             ret = ret.getParent();
         }
         return ret;
     }
 
     /**
      * Finds the resource with the given name. A resource is
      * some data (images, audio, text, etc) that can be accessed by class
      * code in a way that is independent of the location of the code.
      *
      * @param name The name of the resource for which a stream is required.
      *             Must not be <code>null</code>.
      *
      * @return a URL for reading the resource, or <code>null</code> if the
      *         resource could not be found or the caller doesn't have
      *         adequate privileges to get the resource.
      */
     public URL getResource(String name) {
         // we need to search the components of the path to see if
         // we can find the class we want.
         URL url = null;
         if (isParentFirst(name)) {
             url = parent == null ? super.getResource(name) : parent.getResource(name);
         }
         if (url != null) {
             log("Resource " + name + " loaded from parent loader", Project.MSG_DEBUG);
         } else {
             // try and load from this loader if the parent either didn't find
             // it or wasn't consulted.
             Enumeration<File> e = pathComponents.elements();
             while (e.hasMoreElements() && url == null) {
                 File pathComponent = e.nextElement();
                 url = getResourceURL(pathComponent, name);
                 if (url != null) {
                     log("Resource " + name + " loaded from ant loader", Project.MSG_DEBUG);
                 }
             }
         }
         if (url == null && !isParentFirst(name)) {
             // this loader was first but it didn't find it - try the parent
             if (ignoreBase) {
                 url = getRootLoader() == null ? null : getRootLoader().getResource(name);
             } else {
                 url = parent == null ? super.getResource(name) : parent.getResource(name);
             }
             if (url != null) {
                 log("Resource " + name + " loaded from parent loader", Project.MSG_DEBUG);
             }
         }
         if (url == null) {
             log("Couldn't load Resource " + name, Project.MSG_DEBUG);
         }
         return url;
     }
 
     /**
      * Finds all the resources with the given name. A resource is some
      * data (images, audio, text, etc) that can be accessed by class
      * code in a way that is independent of the location of the code.
      *
      * <p>Would override getResources if that wasn't final in Java
      * 1.4.</p>
      *
      * @since Ant 1.8.0
      */
     public Enumeration<URL> getNamedResources(String name)
         throws IOException {
         return findResources(name, false);
     }
 
     /**
      * Returns an enumeration of URLs representing all the resources with the
      * given name by searching the class loader's classpath.
      *
      * @param name The resource name to search for.
      *             Must not be <code>null</code>.
      * @return an enumeration of URLs for the resources
      * @exception IOException if I/O errors occurs (can't happen)
      */
     protected Enumeration<URL> findResources(String name) throws IOException {
         return findResources(name, true);
     }
 
     /**
      * Returns an enumeration of URLs representing all the resources with the
      * given name by searching the class loader's classpath.
      *
      * @param name The resource name to search for.
      *             Must not be <code>null</code>.
      * @param parentHasBeenSearched whether ClassLoader.this.parent
      * has been searched - will be true if the method is (indirectly)
      * called from ClassLoader.getResources
      * @return an enumeration of URLs for the resources
      * @exception IOException if I/O errors occurs (can't happen)
      */
     protected Enumeration<URL> findResources(String name,
                                                  boolean parentHasBeenSearched)
         throws IOException {
         Enumeration<URL> mine = new ResourceEnumeration(name);
         Enumeration<URL> base;
         if (parent != null && (!parentHasBeenSearched || parent != getParent())) {
             // Delegate to the parent:
             base = parent.getResources(name);
             // Note: could cause overlaps in case
             // ClassLoader.this.parent has matches and
             // parentHasBeenSearched is true
         } else {
             // ClassLoader.this.parent is already delegated to for example from
             // ClassLoader.getResources, no need:
             base = new CollectionUtils.EmptyEnumeration<URL>();
         }
         if (isParentFirst(name)) {
             // Normal case.
             return CollectionUtils.append(base, mine);
         }
         if (ignoreBase) {
             return getRootLoader() == null ? mine : CollectionUtils.append(mine, getRootLoader()
                     .getResources(name));
         }
         // parent last:
         return CollectionUtils.append(mine, base);
     }
 
     /**
      * Returns the URL of a given resource in the given file which may
      * either be a directory or a zip file.
      *
      * @param file The file (directory or jar) in which to search for
      *             the resource. Must not be <code>null</code>.
      * @param resourceName The name of the resource for which a stream
      *                     is required. Must not be <code>null</code>.
      *
      * @return a stream to the required resource or <code>null</code> if the
      *         resource cannot be found in the given file object.
      */
     protected URL getResourceURL(File file, String resourceName) {
         try {
             JarFile jarFile = (JarFile) jarFiles.get(file);
             if (jarFile == null && file.isDirectory()) {
                 File resource = new File(file, resourceName);
 
                 if (resource.exists()) {
                     try {
                         return FILE_UTILS.getFileURL(resource);
                     } catch (MalformedURLException ex) {
                         return null;
                     }
                 }
             } else {
                 if (jarFile == null) {
                     if (file.exists()) {
-                        jarFile = new JarFile(file);
+                        try {
+                            jarFile = new JarFile(file);
+                        } catch (ZipException notAJar) {
+                            // raised if a file that is not a ZIP
+                            // happens to be part of the classpath -
+                            // this obviously cannot contain the
+                            // resource
+                            String msg = "CLASSPATH element " + file
+                                + " is not a JAR.";
+                            log(msg, Project.MSG_WARN);
+                            System.err.println(msg);
+                            return null;
+                        }
                         jarFiles.put(file, jarFile);
                     } else {
                         return null;
                     }
                     // potential race-condition
                     jarFile = (JarFile) jarFiles.get(file);
                 }
                 JarEntry entry = jarFile.getJarEntry(resourceName);
                 if (entry != null) {
                     try {
                         return new URL("jar:" + FILE_UTILS.getFileURL(file) + "!/" + entry);
                     } catch (MalformedURLException ex) {
                         return null;
                     }
                 }
             }
         } catch (Exception e) {
             String msg = "Unable to obtain resource from " + file + ": ";
             log(msg + e, Project.MSG_WARN);
             System.err.println(msg);
             e.printStackTrace();
         }
         return null;
     }
 
     /**
      * Loads a class with this class loader.
      *
      * This class attempts to load the class in an order determined by whether
      * or not the class matches the system/loader package lists, with the
      * loader package list taking priority. If the classloader is in isolated
      * mode, failure to load the class in this loader will result in a
      * ClassNotFoundException.
      *
      * @param classname The name of the class to be loaded.
      *                  Must not be <code>null</code>.
      * @param resolve <code>true</code> if all classes upon which this class
      *                depends are to be loaded.
      *
      * @return the required Class object
      *
      * @exception ClassNotFoundException if the requested class does not exist
      * on the system classpath (when not in isolated mode) or this loader's
      * classpath.
      */
     protected synchronized Class<?> loadClass(String classname, boolean resolve)
             throws ClassNotFoundException {
         // 'sync' is needed - otherwise 2 threads can load the same class
         // twice, resulting in LinkageError: duplicated class definition.
         // findLoadedClass avoids that, but without sync it won't work.
 
         Class<?> theClass = findLoadedClass(classname);
         if (theClass != null) {
             return theClass;
         }
         if (isParentFirst(classname)) {
             try {
                 theClass = findBaseClass(classname);
                 log("Class " + classname + " loaded from parent loader " + "(parentFirst)",
                         Project.MSG_DEBUG);
             } catch (ClassNotFoundException cnfe) {
                 theClass = findClass(classname);
                 log("Class " + classname + " loaded from ant loader " + "(parentFirst)",
                         Project.MSG_DEBUG);
             }
         } else {
             try {
                 theClass = findClass(classname);
                 log("Class " + classname + " loaded from ant loader", Project.MSG_DEBUG);
             } catch (ClassNotFoundException cnfe) {
                 if (ignoreBase) {
                     throw cnfe;
                 }
                 theClass = findBaseClass(classname);
                 log("Class " + classname + " loaded from parent loader", Project.MSG_DEBUG);
             }
         }
         if (resolve) {
             resolveClass(theClass);
         }
         return theClass;
     }
 
     /**
      * Converts the class dot notation to a filesystem equivalent for
      * searching purposes.
      *
      * @param classname The class name in dot format (eg java.lang.Integer).
      *                  Must not be <code>null</code>.
      *
      * @return the classname in filesystem format (eg java/lang/Integer.class)
      */
     private String getClassFilename(String classname) {
         return classname.replace('.', '/') + ".class";
     }
 
     /**
      * Define a class given its bytes
      *
      * @param container the container from which the class data has been read
      *                  may be a directory or a jar/zip file.
      *
      * @param classData the bytecode data for the class
      * @param classname the name of the class
      *
      * @return the Class instance created from the given data
      *
      * @throws IOException if the class data cannot be read.
      */
     protected Class<?> defineClassFromData(File container, byte[] classData, String classname)
             throws IOException {
         definePackage(container, classname);
         ProtectionDomain currentPd = Project.class.getProtectionDomain();
         String classResource = getClassFilename(classname);
         CodeSource src = new CodeSource(FILE_UTILS.getFileURL(container),
                                         getCertificates(container,
                                                         classResource));
         ProtectionDomain classesPd =
             new ProtectionDomain(src, currentPd.getPermissions(),
                                  this,
                                  currentPd.getPrincipals());
         return defineClass(classname, classData, 0, classData.length,
                            classesPd);
     }
 
     /**
      * Define the package information associated with a class.
      *
      * @param container the file containing the class definition.
      * @param className the class name of for which the package information
      *        is to be determined.
      *
      * @exception IOException if the package information cannot be read from the
      *            container.
      */
     protected void definePackage(File container, String className) throws IOException {
         int classIndex = className.lastIndexOf('.');
         if (classIndex == -1) {
             return;
         }
         String packageName = className.substring(0, classIndex);
         if (getPackage(packageName) != null) {
             // already defined
             return;
         }
         // define the package now
         Manifest manifest = getJarManifest(container);
 
         if (manifest == null) {
             definePackage(packageName, null, null, null, null, null, null, null);
         } else {
             definePackage(container, packageName, manifest);
         }
     }
 
     /**
      * Get the manifest from the given jar, if it is indeed a jar and it has a
      * manifest
      *
      * @param container the File from which a manifest is required.
      *
      * @return the jar's manifest or null is the container is not a jar or it
      *         has no manifest.
      *
      * @exception IOException if the manifest cannot be read.
      */
     private Manifest getJarManifest(File container) throws IOException {
         if (container.isDirectory()) {
             return null;
         }
         JarFile jarFile = (JarFile) jarFiles.get(container);
         if (jarFile == null) {
             return null;
         }
         return jarFile.getManifest();
     }
 
     /**
      * Get the certificates for a given jar entry, if it is indeed a jar.
      *
      * @param container the File from which to read the entry
      * @param entry the entry of which the certificates are requested
      *
      * @return the entry's certificates or null is the container is
      *         not a jar or it has no certificates.
      *
      * @exception IOException if the manifest cannot be read.
      */
     private Certificate[] getCertificates(File container, String entry)
         throws IOException {
         if (container.isDirectory()) {
             return null;
         }
         JarFile jarFile = (JarFile) jarFiles.get(container);
         if (jarFile == null) {
             return null;
         }
         JarEntry ent = jarFile.getJarEntry(entry);
         return ent == null ? null : ent.getCertificates();
     }
 
     /**
      * Define the package information when the class comes from a
      * jar with a manifest
      *
      * @param container the jar file containing the manifest
      * @param packageName the name of the package being defined.
      * @param manifest the jar's manifest
      */
     protected void definePackage(File container, String packageName, Manifest manifest) {
         String sectionName = packageName.replace('.', '/') + "/";
 
         String specificationTitle = null;
         String specificationVendor = null;
         String specificationVersion = null;
         String implementationTitle = null;
         String implementationVendor = null;
         String implementationVersion = null;
         String sealedString = null;
         URL sealBase = null;
 
         Attributes sectionAttributes = manifest.getAttributes(sectionName);
         if (sectionAttributes != null) {
             specificationTitle = sectionAttributes.getValue(Name.SPECIFICATION_TITLE);
             specificationVendor = sectionAttributes.getValue(Name.SPECIFICATION_VENDOR);
             specificationVersion = sectionAttributes.getValue(Name.SPECIFICATION_VERSION);
             implementationTitle = sectionAttributes.getValue(Name.IMPLEMENTATION_TITLE);
             implementationVendor = sectionAttributes.getValue(Name.IMPLEMENTATION_VENDOR);
             implementationVersion = sectionAttributes.getValue(Name.IMPLEMENTATION_VERSION);
             sealedString = sectionAttributes.getValue(Name.SEALED);
         }
         Attributes mainAttributes = manifest.getMainAttributes();
         if (mainAttributes != null) {
             if (specificationTitle == null) {
                 specificationTitle = mainAttributes.getValue(Name.SPECIFICATION_TITLE);
             }
             if (specificationVendor == null) {
                 specificationVendor = mainAttributes.getValue(Name.SPECIFICATION_VENDOR);
             }
             if (specificationVersion == null) {
                 specificationVersion = mainAttributes.getValue(Name.SPECIFICATION_VERSION);
             }
             if (implementationTitle == null) {
                 implementationTitle = mainAttributes.getValue(Name.IMPLEMENTATION_TITLE);
             }
             if (implementationVendor == null) {
                 implementationVendor = mainAttributes.getValue(Name.IMPLEMENTATION_VENDOR);
             }
             if (implementationVersion == null) {
                 implementationVersion = mainAttributes.getValue(Name.IMPLEMENTATION_VERSION);
             }
             if (sealedString == null) {
                 sealedString = mainAttributes.getValue(Name.SEALED);
             }
         }
         if (sealedString != null && sealedString.equalsIgnoreCase("true")) {
             try {
                 sealBase = new URL(FileUtils.getFileUtils().toURI(container.getAbsolutePath()));
             } catch (MalformedURLException e) {
                 // ignore
             }
         }
         definePackage(packageName, specificationTitle, specificationVersion, specificationVendor,
                 implementationTitle, implementationVersion, implementationVendor, sealBase);
     }
 
     /**
      * Reads a class definition from a stream.
      *
      * @param stream The stream from which the class is to be read.
      *               Must not be <code>null</code>.
      * @param classname The name of the class in the stream.
      *                  Must not be <code>null</code>.
      * @param container the file or directory containing the class.
      *
      * @return the Class object read from the stream.
      *
      * @exception IOException if there is a problem reading the class from the
      * stream.
      * @exception SecurityException if there is a security problem while
      * reading the class from the stream.
      */
     private Class<?> getClassFromStream(InputStream stream, String classname, File container)
             throws IOException, SecurityException {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         int bytesRead = -1;
         byte[] buffer = new byte[BUFFER_SIZE];
 
         while ((bytesRead = stream.read(buffer, 0, BUFFER_SIZE)) != -1) {
             baos.write(buffer, 0, bytesRead);
         }
         byte[] classData = baos.toByteArray();
         return defineClassFromData(container, classData, classname);
     }
 
     /**
      * Searches for and load a class on the classpath of this class loader.
      *
      * @param name The name of the class to be loaded. Must not be
      *             <code>null</code>.
      *
      * @return the required Class object
      *
      * @exception ClassNotFoundException if the requested class does not exist
      *                                   on this loader's classpath.
      */
     public Class<?> findClass(String name) throws ClassNotFoundException {
         log("Finding class " + name, Project.MSG_DEBUG);
         return findClassInComponents(name);
     }
 
     /**
      * Indicate if the given file is in this loader's path
      *
      * @param component the file which is to be checked
      *
      * @return true if the file is in the class path
      */
     protected boolean isInPath(File component) {
         return pathComponents.contains(component);
     }
 
     /**
      * Finds a class on the given classpath.
      *
      * @param name The name of the class to be loaded. Must not be
      *             <code>null</code>.
      *
      * @return the required Class object
      *
      * @exception ClassNotFoundException if the requested class does not exist
      * on this loader's classpath.
      */
     private Class<?> findClassInComponents(String name)
         throws ClassNotFoundException {
         // we need to search the components of the path to see if
         // we can find the class we want.
         String classFilename = getClassFilename(name);
         Enumeration<File> e = pathComponents.elements();
         while (e.hasMoreElements()) {
             File pathComponent = (File) e.nextElement();
             InputStream stream = null;
             try {
                 stream = getResourceStream(pathComponent, classFilename);
                 if (stream != null) {
                     log("Loaded from " + pathComponent + " "
                         + classFilename, Project.MSG_DEBUG);
                     return getClassFromStream(stream, name, pathComponent);
                 }
             } catch (SecurityException se) {
                 throw se;
             } catch (IOException ioe) {
                 // ioe.printStackTrace();
                 log("Exception reading component " + pathComponent + " (reason: "
                         + ioe.getMessage() + ")", Project.MSG_VERBOSE);
             } finally {
                 FileUtils.close(stream);
             }
         }
         throw new ClassNotFoundException(name);
     }
 
     /**
      * Finds a system class (which should be loaded from the same classloader
      * as the Ant core).
      *
      * For JDK 1.1 compatibility, this uses the findSystemClass method if
      * no parent classloader has been specified.
      *
      * @param name The name of the class to be loaded.
      *             Must not be <code>null</code>.
      *
      * @return the required Class object
      *
      * @exception ClassNotFoundException if the requested class does not exist
      * on this loader's classpath.
      */
     private Class<?> findBaseClass(String name) throws ClassNotFoundException {
         return parent == null ? findSystemClass(name) : parent.loadClass(name);
     }
 
     /**
      * Cleans up any resources held by this classloader. Any open archive
      * files are closed.
      */
     public synchronized void cleanup() {
         for (Enumeration<JarFile> e = jarFiles.elements(); e.hasMoreElements();) {
             JarFile jarFile = e.nextElement();
             try {
                 jarFile.close();
             } catch (IOException ioe) {
                 // ignore
             }
         }
         jarFiles = new Hashtable<File, JarFile>();
         if (project != null) {
             project.removeBuildListener(this);
         }
         project = null;
     }
 
     /**
      * Gets the parent as has been specified in the constructor or via
      * setParent.
      *
      * @since Ant 1.8.0
      */
     public ClassLoader getConfiguredParent() {
         return parent;
     }
 
     /**
      * Empty implementation to satisfy the BuildListener interface.
      *
      * @param event the buildStarted event
      */
     public void buildStarted(BuildEvent event) {
         // Not significant for the class loader.
     }
 
     /**
      * Cleans up any resources held by this classloader at the end
      * of a build.
      *
      * @param event the buildFinished event
      */
     public void buildFinished(BuildEvent event) {
         cleanup();
     }
 
     /**
      * Cleans up any resources held by this classloader at the end of
      * a subbuild if it has been created for the subbuild's project
      * instance.
      *
      * @param event the buildFinished event
      *
      * @since Ant 1.6.2
      */
     public void subBuildFinished(BuildEvent event) {
         if (event.getProject() == project) {
             cleanup();
         }
     }
 
     /**
      * Empty implementation to satisfy the BuildListener interface.
      *
      * @param event the buildStarted event
      *
      * @since Ant 1.6.2
      */
     public void subBuildStarted(BuildEvent event) {
         // Not significant for the class loader.
     }
 
     /**
      * Empty implementation to satisfy the BuildListener interface.
      *
      * @param event the targetStarted event
      */
     public void targetStarted(BuildEvent event) {
         // Not significant for the class loader.
     }
 
     /**
      * Empty implementation to satisfy the BuildListener interface.
      *
      * @param event the targetFinished event
      */
     public void targetFinished(BuildEvent event) {
         // Not significant for the class loader.
     }
 
     /**
      * Empty implementation to satisfy the BuildListener interface.
      *
      * @param event the taskStarted event
      */
     public void taskStarted(BuildEvent event) {
         // Not significant for the class loader.
     }
 
     /**
      * Empty implementation to satisfy the BuildListener interface.
      *
      * @param event the taskFinished event
      */
     public void taskFinished(BuildEvent event) {
         // Not significant for the class loader.
     }
 
     /**
      * Empty implementation to satisfy the BuildListener interface.
      *
      * @param event the messageLogged event
      */
     public void messageLogged(BuildEvent event) {
         // Not significant for the class loader.
     }
 
     /**
      * add any libraries that come with different java versions
      * here
      */
     public void addJavaLibraries() {
         Vector<String> packages = JavaEnvUtils.getJrePackages();
         Enumeration<String> e = packages.elements();
         while (e.hasMoreElements()) {
             String packageName = e.nextElement();
             addSystemPackageRoot(packageName);
         }
     }
 
     /**
      * Returns a <code>String</code> representing this loader.
      * @return the path that this classloader has.
      */
     public String toString() {
         return "AntClassLoader[" + getClasspath() + "]";
     }
 
     private static Class<?> subClassToLoad = null;
     private static final Class<?>[] CONSTRUCTOR_ARGS = new Class[] {
         ClassLoader.class, Project.class, Path.class, Boolean.TYPE
     };
 
     static {
         if (JavaEnvUtils.isAtLeastJavaVersion(JavaEnvUtils.JAVA_1_5)) {
             try {
                 subClassToLoad =
                     Class.forName("org.apache.tools.ant.loader.AntClassLoader5");
             } catch (ClassNotFoundException e) {
                 // this is Java5 but the installation is lacking our subclass
             }
         }
     }
 
     /**
      * Factory method
      */
     public static AntClassLoader newAntClassLoader(ClassLoader parent,
                                                    Project project,
                                                    Path path,
                                                    boolean parentFirst) {
         if (subClassToLoad != null) {
             return (AntClassLoader)
                 ReflectUtil.newInstance(subClassToLoad,
                                         CONSTRUCTOR_ARGS,
                                         new Object[] {
                                             parent, project, path,
                                             Boolean.valueOf(parentFirst)
                                         });
         }
         return new AntClassLoader(parent, project, path, parentFirst);
     }
 
 }
diff --git a/src/tests/antunit/taskdefs/optional/junit/junit-test.xml b/src/tests/antunit/taskdefs/optional/junit/junit-test.xml
index c3efbeca5..873ce0e0b 100644
--- a/src/tests/antunit/taskdefs/optional/junit/junit-test.xml
+++ b/src/tests/antunit/taskdefs/optional/junit/junit-test.xml
@@ -1,348 +1,368 @@
 <?xml version="1.0"?>
 <!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at
 
       http://www.apache.org/licenses/LICENSE-2.0
 
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
 <project default="antunit" xmlns:au="antlib:org.apache.ant.antunit">
   <import file="../../../antunit-base.xml" />
 
   <path id="junit">
     <fileset dir="../../../../../../lib/optional" includes="junit*" />
     <fileset dir="../../../../../../lib/optional" includes="hamcrest-core*" />
   </path>
 
   <macrodef name="empty-test">
     <attribute name="classname" />
     <attribute name="package" default="test" />
     <sequential>
       <echo file="${input}/@{classname}.java">
         <![CDATA[
 package @{package};
 import junit.framework.TestCase;
 
 public class @{classname} extends TestCase {
     public void testEmpty() {}
 }
 ]]>
       </echo>
     </sequential>
   </macrodef>
 
   <target name="setUp">
     <mkdir dir="${input}" />
     <mkdir dir="${output}" />
   </target>
 
   <target name="testTimeoutLogOfBatchTests">
     <mkdir dir="${input}" />
     <mkdir dir="${output}" />
     <empty-test classname="ATest" package="org.apache.ant.test" />
     <echo file="${input}/BTest.java">
       <![CDATA[
 package org.apache.ant.test;
 import junit.framework.TestCase;
 
 public class BTest extends TestCase {
     public void testEmpty() throws Exception {
         Thread.sleep(20 * 1000);
     }
 }
 ]]>
     </echo>
     <empty-test classname="CTest" package="org.apache.ant.test" />
     <empty-test classname="DTest" package="org.apache.ant.test" />
     <javac srcdir="${input}" destdir="${output}">
       <classpath refid="junit" />
     </javac>
     <junit fork="true" forkMode="perBatch" timeout="5000" printsummary="yes">
       <classpath refid="junit" />
       <classpath location="${output}" />
       <batchtest>
         <fileset dir="${output}">
           <include name="**/*Test.class" />
         </fileset>
       </batchtest>
     </junit>
     <au:assertLogContains text="ATest" />
     <au:assertLogContains text="BTest" />
     <au:assertLogContains text="org.apache.ant.test.Batch-With-Multiple-Tests" />
     <au:assertLogDoesntContain text="CTest" />
     <au:assertLogDoesntContain text="DTest" />
   </target>
 
   <target name="testFailurePropertyOnTestCase">
     <mkdir dir="${input}" />
     <mkdir dir="${output}" />
     <echo file="${input}/ATest.java">
       <![CDATA[
 package test;
 import junit.framework.TestCase;
 
 public class ATest extends TestCase {
     public void testFail() {
         assertTrue(false);
     }
 }
 ]]>
     </echo>
     <javac srcdir="${input}" destdir="${output}">
       <classpath refid="junit" />
     </javac>
     <junit failureProperty="testcase.failed" haltonfailure="false">
       <classpath refid="junit" />
       <classpath location="${output}" />
       <batchtest>
         <fileset dir="${output}">
           <include name="**/*Test.class" />
         </fileset>
       </batchtest>
     </junit>
     <au:assertPropertySet name="testcase.failed" />
   </target>
 
   <target name="testFailurePropertyOnTestSuite">
     <mkdir dir="${input}" />
     <mkdir dir="${output}" />
     <echo file="${input}/ATest.java">
       <![CDATA[
 package test;
 import junit.framework.Assert;
 import junit.framework.TestSuite;
 
 public class ATest extends TestSuite {
     public ATest() {
         super(test.ATest.class);
     }
     public void testFail() {
         Assert.assertTrue(false);
     }
 }
 ]]>
     </echo>
     <javac srcdir="${input}" destdir="${output}">
       <classpath refid="junit" />
     </javac>
     <junit failureProperty="testsuite.failed" haltonfailure="false">
       <classpath refid="junit" />
       <classpath location="${output}" />
       <batchtest>
         <fileset dir="${output}">
           <include name="**/*Test.class" />
         </fileset>
       </batchtest>
     </junit>
     <au:assertPropertySet name="testsuite.failed" />
   </target>
 
   <target name="testTimeoutAndFormattersForkPerTest">
     <antcall target="runTimeoutAndFormattersTest">
       <param name="forkMode" value="perTest" />
     </antcall>
     <au:assertFileExists file="${output}/TEST-test.CTest.txt" />
     <au:assertFileExists file="${output}/TEST-test.CTest.xml" />
     <au:assertFileExists file="${output}/TEST-test.DTest.txt" />
     <au:assertFileExists file="${output}/TEST-test.DTest.xml" />
   </target>
 
   <target name="testTimeoutAndFormattersForkOnce">
     <antcall target="runTimeoutAndFormattersTest">
       <param name="forkMode" value="once" />
     </antcall>
     <au:assertFileDoesntExist file="${output}/TEST-test.CTest.txt" />
     <au:assertFileDoesntExist file="${output}/TEST-test.CTest.xml" />
     <au:assertFileDoesntExist file="${output}/TEST-test.DTest.txt" />
     <au:assertFileDoesntExist file="${output}/TEST-test.DTest.xml" />
   </target>
 
   <target name="runTimeoutAndFormattersTest" description="https://issues.apache.org/bugzilla/show_bug.cgi?id=35634">
     <mkdir dir="${input}" />
     <mkdir dir="${output}" />
     <empty-test classname="ATest" />
     <echo file="${input}/BTest.java">
       <![CDATA[
 package test;
 import junit.framework.TestCase;
 
 public class BTest extends TestCase {
     public void testEmpty() throws Exception {
         Thread.sleep(20 * 1000);
     }
 }
 ]]>
     </echo>
     <empty-test classname="CTest" />
     <empty-test classname="DTest" />
     <javac srcdir="${input}" destdir="${output}">
       <classpath refid="junit" />
     </javac>
     <junit fork="true" timeout="5000" forkmode="${forkMode}">
       <classpath refid="junit" />
       <classpath location="${output}" />
       <batchtest todir="${output}">
         <fileset dir="${output}">
           <include name="**/*Test.class" />
         </fileset>
       </batchtest>
       <formatter type="brief" />
       <formatter type="xml" />
     </junit>
     <au:assertFileExists file="${output}/TEST-test.ATest.txt" />
     <au:assertFileExists file="${output}/TEST-test.ATest.xml" />
    <!--
     <au:assertFileExists file="${output}/TEST-test.BTest.txt" />
     <au:assertFileExists file="${output}/TEST-test.BTest.xml" />
 
     These files should only exist if something was written to the log by te runner.
     The test previously passed even though the files were empty, which isn't a meaningful result.
     TODO we should probably improve the testing around reporting of tests that have timed-out
     -->
   </target>
 
   <target name="-ifUnlessSetup" depends="setUp">
     <empty-test classname="ATest" />
     <empty-test classname="BTest" />
     <empty-test classname="CTest" />
     <empty-test classname="DTest" />
     <empty-test classname="ETest" />
     <empty-test classname="FTest" />
     <empty-test classname="GTest" />
     <empty-test classname="HTest" />
     <javac srcdir="${input}" destdir="${output}">
       <classpath refid="junit" />
     </javac>
     <macrodef name="j">
       <sequential>
         <junit fork="true" forkMode="perBatch" printsummary="yes">
           <classpath refid="junit" />
           <classpath location="${output}" />
           <test name="test.ATest" if="${if}" />
           <test name="test.BTest" if="if" />
           <test name="test.CTest" unless="${if}" />
           <test name="test.DTest" unless="if" />
           <batchtest if="${if}">
             <fileset dir="${output}">
               <include name="**/ETest.class" />
             </fileset>
           </batchtest>
           <batchtest if="if">
             <fileset dir="${output}">
               <include name="**/FTest.class" />
             </fileset>
           </batchtest>
           <batchtest unless="${if}">
             <fileset dir="${output}">
               <include name="**/GTest.class" />
             </fileset>
           </batchtest>
           <batchtest unless="if">
             <fileset dir="${output}">
               <include name="**/HTest.class" />
             </fileset>
           </batchtest>
         </junit>
       </sequential>
     </macrodef>
   </target>
 
   <target name="testPropertiesNotSet" depends="-ifUnlessSetup">
     <j />
     <au:assertLogDoesntContain text="Running test.ATest" />
     <au:assertLogDoesntContain text="Running test.BTest" />
     <au:assertLogContains text="Running test.CTest" />
     <au:assertLogContains text="Running test.DTest" />
     <au:assertLogDoesntContain text="Running test.ETest" />
     <au:assertLogDoesntContain text="Running test.FTest" />
     <au:assertLogContains text="Running test.GTest" />
     <au:assertLogContains text="Running test.HTest" />
   </target>
 
   <target name="testPropertiesSet" depends="-ifUnlessSetup">
     <property name="if" value="whatever" />
     <j />
     <au:assertLogDoesntContain text="Running test.ATest" />
     <au:assertLogContains text="Running test.BTest" />
     <au:assertLogContains text="Running test.CTest" />
     <au:assertLogDoesntContain text="Running test.DTest" />
     <au:assertLogDoesntContain text="Running test.ETest" />
     <au:assertLogContains text="Running test.FTest" />
     <au:assertLogContains text="Running test.GTest" />
     <au:assertLogDoesntContain text="Running test.HTest" />
   </target>
 
   <target name="testPropertiesTrue" depends="-ifUnlessSetup">
     <property name="if" value="true" />
     <j />
     <au:assertLogContains text="Running test.ATest" />
     <au:assertLogContains text="Running test.BTest" />
     <au:assertLogDoesntContain text="Running test.CTest" />
     <au:assertLogDoesntContain text="Running test.DTest" />
     <au:assertLogContains text="Running test.ETest" />
     <au:assertLogContains text="Running test.FTest" />
     <au:assertLogDoesntContain text="Running test.GTest" />
     <au:assertLogDoesntContain text="Running test.HTest" />
   </target>
 
   <target name="testPropertiesFalse" depends="-ifUnlessSetup">
     <property name="if" value="false" />
     <j />
     <au:assertLogDoesntContain text="Running test.ATest" />
     <au:assertLogContains text="Running test.BTest" />
     <au:assertLogContains text="Running test.CTest" />
     <au:assertLogDoesntContain text="Running test.DTest" />
     <au:assertLogDoesntContain text="Running test.ETest" />
     <au:assertLogContains text="Running test.FTest" />
     <au:assertLogContains text="Running test.GTest" />
     <au:assertLogDoesntContain text="Running test.HTest" />
   </target>
 
   <target name="testMissingTestName">
     <property name="test.name" value="null" />
     <au:expectfailure message="test name must be specified">
       <junit fork="false">
         <test name="${test.name}" />
       </junit>
     </au:expectfailure>
   </target>
 
   <target name="testTestMethods" if="jdk1.5+">
     <echo file="${input}/T1.java">public class T1 extends
 			junit.framework.TestCase {
 			public void testOK() {}
 			public void testBad() {throw new RuntimeException("failed");}
 			}</echo>
     <echo file="${input}/T2.java">
 		    import org.junit.Test;
 		    public class T2 {
 			@Test 
 			public void ok() {}
 			@Test 
 			public void bad() {
 			throw new RuntimeException("failed");}
 			}</echo>
     <javac srcdir="${input}" destdir="${output}" includes="T1.java,T2.java" source="5" includeantruntime="false">
       <classpath>
         <path refid="junit" />
       </classpath>
     </javac>
     <junit fork="true" printsummary="true" haltonerror="true">
       <classpath>
         <pathelement location="${output}" />
         <path refid="junit" />
       </classpath>
       <test name="T1" methods="testOK" />
       <test name="T2" methods="ok" />
     </junit>
   </target>
+
+  <target name="testClasspathBuildingSurvivesNonZips" depends="setUp"
+          description="https://issues.apache.org/bugzilla/show_bug.cgi?id=53964">
+    <empty-test classname="ATest" package="org.apache.ant.test" />
+    <javac srcdir="${input}" destdir="${output}">
+      <classpath refid="junit" />
+    </javac>
+    <junit fork="true" printsummary="true" haltonerror="true">
+      <classpath>
+        <pathelement location="${output}" />
+        <pathelement location="${ant.file}" />
+        <path refid="junit" />
+      </classpath>
+      <batchtest>
+        <fileset dir="${output}">
+          <include name="**/*Test.class" />
+        </fileset>
+      </batchtest>
+    </junit>
+  </target>
 </project>
diff --git a/src/tests/junit/org/apache/tools/ant/AntClassLoaderTest.java b/src/tests/junit/org/apache/tools/ant/AntClassLoaderTest.java
index 32503ac21..963fa7b19 100644
--- a/src/tests/junit/org/apache/tools/ant/AntClassLoaderTest.java
+++ b/src/tests/junit/org/apache/tools/ant/AntClassLoaderTest.java
@@ -1,191 +1,191 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant;
 
 import java.io.File;
 import java.io.PrintStream;
 import java.net.URL;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * Test case for ant class loader
  *
  */
 public class AntClassLoaderTest extends BuildFileTest {
 
     private Project p;
     private AntClassLoader loader;
 
     public AntClassLoaderTest(String name) {
         super(name);
     }
 
     public void setUp() {
         p = new Project();
         p.init();
         configureProject("src/etc/testcases/core/antclassloader.xml");
         getProject().executeTarget("setup");
     }
 
     public void tearDown() {
         if (loader != null) {
             loader.cleanup();
         }
         getProject().executeTarget("cleanup");
     }
     //test inspired by bug report 37085
     public void testJarWithManifestInDirWithSpace() {
         String mainjarstring = getProject().getProperty("main.jar");
         String extjarstring = getProject().getProperty("ext.jar");
         Path myPath = new Path(getProject());
         myPath.setLocation(new File(mainjarstring));
         getProject().setUserProperty("build.sysclasspath","ignore");
         loader = getProject().createClassLoader(myPath);
         String path = loader.getClasspath();
         assertEquals(mainjarstring + File.pathSeparator + extjarstring, path);
     }
     public void testJarWithManifestInNonAsciiDir() {
         String mainjarstring = getProject().getProperty("main.jar.nonascii");
         String extjarstring = getProject().getProperty("ext.jar.nonascii");
         Path myPath = new Path(getProject());
         myPath.setLocation(new File(mainjarstring));
         getProject().setUserProperty("build.sysclasspath","ignore");
         loader = getProject().createClassLoader(myPath);
         String path = loader.getClasspath();
         assertEquals(mainjarstring + File.pathSeparator + extjarstring, path);
     }
     public void testCleanup() throws BuildException {
         Path path = new Path(p, ".");
         loader = p.createClassLoader(path);
         try {
             // we don't expect to find this
             loader.findClass("fubar");
             fail("Did not expect to find fubar class");
         } catch (ClassNotFoundException e) {
             // ignore expected
         }
 
         loader.cleanup();
         try {
             // we don't expect to find this
             loader.findClass("fubar");
             fail("Did not expect to find fubar class");
         } catch (ClassNotFoundException e) {
             // ignore expected
         } catch (NullPointerException e) {
             fail("loader should not fail even if cleaned up");
         }
 
         // tell the build it is finished
         p.fireBuildFinished(null);
         try {
             // we don't expect to find this
             loader.findClass("fubar");
             fail("Did not expect to find fubar class");
         } catch (ClassNotFoundException e) {
             // ignore expected
         } catch (NullPointerException e) {
             fail("loader should not fail even if project finished");
         }
     }
 
     public void testGetPackage() throws Exception {
         executeTarget("prepareGetPackageTest");
         Path myPath = new Path(getProject());
         myPath.setLocation(new File(getProject().getProperty("test.jar")));
         getProject().setUserProperty("build.sysclasspath","ignore");
         loader = getProject().createClassLoader(myPath);
         assertNotNull("should find class", loader.findClass("org.example.Foo"));
         assertNotNull("should find package",
                       new GetPackageWrapper(loader).getPackage("org.example"));
     }
 
     public void testCodeSource() throws Exception {
         executeTarget("prepareGetPackageTest");
         Path myPath = new Path(getProject());
         File testJar = new File(getProject().getProperty("test.jar"));
         myPath.setLocation(testJar);
         getProject().setUserProperty("build.sysclasspath","ignore");
         loader = getProject().createClassLoader(myPath);
         Class foo = loader.findClass("org.example.Foo");
         URL codeSourceLocation =
             foo.getProtectionDomain().getCodeSource().getLocation();
         assertEquals(codeSourceLocation + " should point to test.jar",
                    FileUtils.getFileUtils().getFileURL(testJar), codeSourceLocation);
     }
 
     public void testSignedJar() throws Exception {
         executeTarget("signTestJar");
         File jar = new File(getProject().getProperty("test.jar"));
 
         Path myPath = new Path(getProject());
         myPath.setLocation(jar);
         getProject().setUserProperty("build.sysclasspath","ignore");
         loader = getProject().createClassLoader(myPath);
         Class foo = loader.findClass("org.example.Foo");
 
         assertNotNull("should find class", foo);
         assertNotNull("should have certificates",
                       foo.getProtectionDomain().getCodeSource()
                       .getCertificates());
         assertNotNull("should be signed", foo.getSigners());
     }
 
     /**
      * @see https://issues.apache.org/bugzilla/show_bug.cgi?id=47593
      */
     public void testInvalidZipException() throws Exception {
         executeTarget("createNonJar");
         File jar = new File(getProject().getProperty("tmp.dir")
                             + "/foo.jar");
 
         Path myPath = new Path(getProject());
         myPath.setLocation(jar);
         getProject().setUserProperty("build.sysclasspath","ignore");
         loader = getProject().createClassLoader(myPath);
         PrintStream sysErr = System.err;
         try {
             StringBuffer errBuffer = new StringBuffer();
             PrintStream err =
                 new PrintStream(new BuildFileTest.AntOutputStream(errBuffer));
             System.setErr(err);
             loader.getResource("foo.txt");
             String log = getLog();
-            int startMessage = log.indexOf("Unable to obtain resource from ");
+            int startMessage = log.indexOf("CLASSPATH element ");
             assertTrue(startMessage >= 0);
-            assertTrue(log.indexOf("foo.jar", startMessage) > 0);
+            assertTrue(log.indexOf("foo.jar is not a JAR", startMessage) > 0);
             log = errBuffer.toString();
-            startMessage = log.indexOf("Unable to obtain resource from ");
+            startMessage = log.indexOf("CLASSPATH element ");
             assertTrue(startMessage >= 0);
-            assertTrue(log.indexOf("foo.jar", startMessage) > 0);
+            assertTrue(log.indexOf("foo.jar is not a JAR", startMessage) > 0);
         } finally {
             System.setErr(sysErr);
         }
     }
 
     private static class GetPackageWrapper extends ClassLoader {
         GetPackageWrapper(ClassLoader parent) {
             super(parent);
         }
         public Package getPackage(String s) {
             return super.getPackage(s);
         }
     }
 }
