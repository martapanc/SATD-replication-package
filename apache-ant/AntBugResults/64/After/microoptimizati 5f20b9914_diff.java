diff --git a/src/main/org/apache/tools/ant/IntrospectionHelper.java b/src/main/org/apache/tools/ant/IntrospectionHelper.java
index 9cb89c9a0..dd0e123af 100644
--- a/src/main/org/apache/tools/ant/IntrospectionHelper.java
+++ b/src/main/org/apache/tools/ant/IntrospectionHelper.java
@@ -588,1144 +588,1147 @@ public final class IntrospectionHelper {
      *                Must not be <code>null</code>. If the resulting
      *                object is an instance of ProjectComponent, its
      *                Project reference is set to this parameter value.
      * @param parent  Parent object used to create the instance.
      *                Must not be <code>null</code>.
      * @param elementName Name of the element to create an instance of.
      *                    Must not be <code>null</code>.
      *
      * @return an instance of the specified element type
      * @deprecated since 1.6.x.
      *             This is not a namespace aware method.
      *
      * @exception BuildException if no method is available to create the
      *                           element instance, or if the creating method fails.
      */
     public Object createElement(Project project, Object parent, String elementName)
             throws BuildException {
         NestedCreator nc = getNestedCreator(project, "", parent, elementName, null);
         try {
             Object nestedElement = nc.create(project, parent, null);
             if (project != null) {
                 project.setProjectReference(nestedElement);
             }
             return nestedElement;
         } catch (IllegalAccessException ie) {
             // impossible as getMethods should only return public methods
             throw new BuildException(ie);
         } catch (InstantiationException ine) {
             // impossible as getMethods should only return public methods
             throw new BuildException(ine);
         } catch (InvocationTargetException ite) {
             throw extractBuildException(ite);
         }
     }
 
     /**
      * returns an object that creates and stores an object
      * for an element of a parent.
      *
      * @param project      Project to which the parent object belongs.
      * @param parentUri    The namespace uri of the parent object.
      * @param parent       Parent object used to create the creator object to
      *                     create and store and instance of a subelement.
      * @param elementName  Name of the element to create an instance of.
      * @param ue           The unknown element associated with the element.
      * @return a creator object to create and store the element instance.
      */
     public Creator getElementCreator(
         Project project, String parentUri, Object parent, String elementName, UnknownElement ue) {
         NestedCreator nc = getNestedCreator(project, parentUri, parent, elementName, ue);
         return new Creator(project, parent, nc);
     }
 
     /**
      * Indicates whether the introspected class is a dynamic one,
      * supporting arbitrary nested elements and/or attributes.
      *
      * @return <code>true<code> if the introspected class is dynamic;
      *         <code>false<code> otherwise.
      * @since Ant 1.6.3
      *
      * @see DynamicElement
      * @see DynamicElementNS
      */
     public boolean isDynamic() {
         return DynamicElement.class.isAssignableFrom(bean)
                 || DynamicElementNS.class.isAssignableFrom(bean);
     }
 
     /**
      * Indicates whether the introspected class is a task container,
      * supporting arbitrary nested tasks/types.
      *
      * @return <code>true<code> if the introspected class is a container;
      *         <code>false<code> otherwise.
      * @since Ant 1.6.3
      *
      * @see TaskContainer
      */
     public boolean isContainer() {
         return TaskContainer.class.isAssignableFrom(bean);
     }
 
     /**
      * Indicates if this element supports a nested element of the
      * given name.
      *
      * @param elementName the name of the nested element being checked
      *
      * @return true if the given nested element is supported
      */
     public boolean supportsNestedElement(String elementName) {
         return supportsNestedElement("", elementName);
     }
 
     /**
      * Indicate if this element supports a nested element of the
      * given name.
      *
      * <p>Note that this method will always return true if the
      * introspected class is {@link #isDynamic dynamic} or contains a
      * method named "add" with void return type and a single argument.
      * To ge a more thorough answer, use the four-arg version of this
      * method instead.</p>
      *
      * @param parentUri   the uri of the parent
      * @param elementName the name of the nested element being checked
      *
      * @return true if the given nested element is supported
      */
     public boolean supportsNestedElement(String parentUri, String elementName) {
         if (isDynamic() || addTypeMethods.size() > 0) {
             return true;
         }
         return supportsReflectElement(parentUri, elementName);
     }
 
     /**
      * Indicate if this element supports a nested element of the
      * given name.
      *
      * <p>Note that this method will always return true if the
      * introspected class is {@link #isDynamic dynamic}, so be
      * prepared to catch an exception about unsupported children when
      * calling {@link #getElementCreator getElementCreator}.</p>
      *
      * @param parentUri   the uri of the parent
      * @param elementName the name of the nested element being checked
      * @param project currently executing project instance
      * @param parent the parent element
      *
      * @return true if the given nested element is supported
      * @since Ant 1.8.0.
      */
     public boolean supportsNestedElement(String parentUri, String elementName,
                                          Project project, Object parent) {
         if (addTypeMethods.size() > 0
             && createAddTypeCreator(project, parent, elementName) != null) {
             return true;
         }
         return isDynamic() || supportsReflectElement(parentUri, elementName);
     }
 
     /**
      * Check if this element supports a nested element from reflection.
      *
      * @param parentUri   the uri of the parent
      * @param elementName the name of the nested element being checked
      *
      * @return true if the given nested element is supported
      * @since Ant 1.8.0
      */
     public boolean supportsReflectElement(
         String parentUri, String elementName) {
         String name = ProjectHelper.extractNameFromComponentName(elementName);
         if (!nestedCreators.containsKey(name.toLowerCase(Locale.ENGLISH))) {
             return false;
         }
         String uri = ProjectHelper.extractUriFromComponentName(elementName);
         if (uri.equals(ProjectHelper.ANT_CORE_URI)) {
             uri = "";
         }
         if ("".equals(uri)) {
             return true;
         }
         if (parentUri.equals(ProjectHelper.ANT_CORE_URI)) {
             parentUri = "";
         }
         return uri.equals(parentUri);
     }
 
     /**
      * Stores a named nested element using a storage method determined
      * by the initial introspection. If no appropriate storage method
      * is available, this method returns immediately.
      *
      * @param project Ignored in this implementation.
      *                May be <code>null</code>.
      *
      * @param parent  Parent instance to store the child in.
      *                Must not be <code>null</code>.
      *
      * @param child   Child instance to store in the parent.
      *                Should not be <code>null</code>.
      *
      * @param elementName  Name of the child element to store.
      *                     May be <code>null</code>, in which case
      *                     this method returns immediately.
      *
      * @exception BuildException if the storage method fails.
      */
     public void storeElement(Project project, Object parent, Object child,
         String elementName) throws BuildException {
         if (elementName == null) {
             return;
         }
         NestedCreator ns = (NestedCreator) nestedCreators.get(elementName.toLowerCase(Locale.ENGLISH));
         if (ns == null) {
             return;
         }
         try {
             ns.store(parent, child);
         } catch (IllegalAccessException ie) {
             // impossible as getMethods should only return public methods
             throw new BuildException(ie);
         } catch (InstantiationException ine) {
             // impossible as getMethods should only return public methods
             throw new BuildException(ine);
         } catch (InvocationTargetException ite) {
             throw extractBuildException(ite);
         }
     }
 
     /**
      * Helper method to extract the inner fault from an {@link InvocationTargetException}, and turn
      * it into a BuildException. If it is already a BuildException, it is type cast and returned; if
      * not a new BuildException is created containing the child as nested text.
      * @param ite
      * @return the nested exception
      */
     private static BuildException extractBuildException(InvocationTargetException ite) {
         Throwable t = ite.getTargetException();
         if (t instanceof BuildException) {
             return (BuildException) t;
         }
         return new BuildException(t);
     }
 
     /**
      * Returns the type of a named nested element.
      *
      * @param elementName The name of the element to find the type of.
      *                    Must not be <code>null</code>.
      *
      * @return the type of the nested element with the specified name.
      *         This will never be <code>null</code>.
      *
      * @exception BuildException if the introspected class does not
      *                           support the named nested element.
      */
     public Class getElementType(String elementName) throws BuildException {
         Class nt = (Class) nestedTypes.get(elementName);
         if (nt == null) {
             throw new UnsupportedElementException("Class "
                     + bean.getName() + " doesn't support the nested \""
                     + elementName + "\" element.", elementName);
         }
         return nt;
     }
 
     /**
      * Returns the type of a named attribute.
      *
      * @param attributeName The name of the attribute to find the type of.
      *                      Must not be <code>null</code>.
      *
      * @return the type of the attribute with the specified name.
      *         This will never be <code>null</code>.
      *
      * @exception BuildException if the introspected class does not
      *                           support the named attribute.
      */
     public Class getAttributeType(String attributeName) throws BuildException {
         Class at = (Class) attributeTypes.get(attributeName);
         if (at == null) {
             throw new UnsupportedAttributeException("Class "
                     + bean.getName() + " doesn't support the \""
                     + attributeName + "\" attribute.", attributeName);
         }
         return at;
     }
 
     /**
      * Returns the addText method when the introspected
      * class supports nested text.
      *
      * @return the method on this introspected class that adds nested text.
      *         Cannot be <code>null</code>.
      * @throws BuildException if the introspected class does not
      *         support the nested text.
      * @since Ant 1.6.3
      */
     public Method getAddTextMethod() throws BuildException {
         if (!supportsCharacters()) {
             throw new BuildException("Class " + bean.getName()
                     + " doesn't support nested text data.");
         }
         return addText;
     }
 
     /**
      * Returns the adder or creator method of a named nested element.
      *
      * @param  elementName The name of the attribute to find the setter
      *         method of. Must not be <code>null</code>.
      * @return the method on this introspected class that adds or creates this
      *         nested element. Can be <code>null</code> when the introspected
      *         class is a dynamic configurator!
      * @throws BuildException if the introspected class does not
      *         support the named nested element.
      * @since Ant 1.6.3
      */
     public Method getElementMethod(String elementName) throws BuildException {
         Object creator = nestedCreators.get(elementName);
         if (creator == null) {
             throw new UnsupportedElementException("Class "
                     + bean.getName() + " doesn't support the nested \""
                     + elementName + "\" element.", elementName);
         }
         return ((NestedCreator) creator).method;
     }
 
     /**
      * Returns the setter method of a named attribute.
      *
      * @param  attributeName The name of the attribute to find the setter
      *         method of. Must not be <code>null</code>.
      * @return the method on this introspected class that sets this attribute.
      *         This will never be <code>null</code>.
      * @throws BuildException if the introspected class does not
      *         support the named attribute.
      * @since Ant 1.6.3
      */
     public Method getAttributeMethod(String attributeName) throws BuildException {
         Object setter = attributeSetters.get(attributeName);
         if (setter == null) {
             throw new UnsupportedAttributeException("Class "
                     + bean.getName() + " doesn't support the \""
                     + attributeName + "\" attribute.", attributeName);
         }
         return ((AttributeSetter) setter).method;
     }
 
     /**
      * Returns whether or not the introspected class supports PCDATA.
      *
      * @return whether or not the introspected class supports PCDATA.
      */
     public boolean supportsCharacters() {
         return addText != null;
     }
 
     /**
      * Returns an enumeration of the names of the attributes supported by the introspected class.
      *
      * @return an enumeration of the names of the attributes supported by the introspected class.
      * @see #getAttributeMap
      */
     public Enumeration getAttributes() {
         return attributeSetters.keys();
     }
 
     /**
      * Returns a read-only map of attributes supported by the introspected class.
      *
      * @return an attribute name to attribute <code>Class</code>
      *         unmodifiable map. Can be empty, but never <code>null</code>.
      * @since Ant 1.6.3
      */
     public Map getAttributeMap() {
         return attributeTypes.isEmpty()
             ? Collections.EMPTY_MAP : Collections.unmodifiableMap(attributeTypes);
     }
 
     /**
      * Returns an enumeration of the names of the nested elements supported
      * by the introspected class.
      *
      * @return an enumeration of the names of the nested elements supported
      *         by the introspected class.
      * @see #getNestedElementMap
      */
     public Enumeration getNestedElements() {
         return nestedTypes.keys();
     }
 
     /**
      * Returns a read-only map of nested elements supported
      * by the introspected class.
      *
      * @return a nested-element name to nested-element <code>Class</code>
      *         unmodifiable map. Can be empty, but never <code>null</code>.
      * @since Ant 1.6.3
      */
     public Map getNestedElementMap() {
         return nestedTypes.isEmpty()
             ? Collections.EMPTY_MAP : Collections.unmodifiableMap(nestedTypes);
     }
 
     /**
      * Returns a read-only list of extension points supported
      * by the introspected class.
      * <p>
      * A task/type or nested element with void methods named <code>add()<code>
      * or <code>addConfigured()</code>, taking a single class or interface
      * argument, supports extensions point. This method returns the list of
      * all these <em>void add[Configured](type)</em> methods.
      *
      * @return a list of void, single argument add() or addConfigured()
      *         <code>Method<code>s of all supported extension points.
      *         These methods are sorted such that if the argument type of a
      *         method derives from another type also an argument of a method
      *         of this list, the method with the most derived argument will
      *         always appear first. Can be empty, but never <code>null</code>.
      * @since Ant 1.6.3
      */
     public List getExtensionPoints() {
         return addTypeMethods.isEmpty()
                 ? Collections.EMPTY_LIST : Collections.unmodifiableList(addTypeMethods);
     }
 
     /**
      * Creates an implementation of AttributeSetter for the given
      * attribute type. Conversions (where necessary) are automatically
      * made for the following types:
      * <ul>
      * <li>String (left as it is)
      * <li>Character/char (first character is used)
      * <li>Boolean/boolean
      * ({@link Project#toBoolean(String) Project.toBoolean(String)} is used)
      * <li>Class (Class.forName is used)
      * <li>File (resolved relative to the appropriate project)
      * <li>Path (resolve relative to the appropriate project)
      * <li>Resource (resolved as a FileResource relative to the appropriate project)
      * <li>FileProvider (resolved as a FileResource relative to the appropriate project)
      * <li>EnumeratedAttribute (uses its own
      * {@link EnumeratedAttribute#setValue(String) setValue} method)
      * <li>Other primitive types (wrapper classes are used with constructors
      * taking String)
      * </ul>
      *
      * If none of the above covers the given parameters, a constructor for the
      * appropriate class taking a String parameter is used if it is available.
      *
      * @param m The method to invoke on the bean when the setter is invoked.
      *          Must not be <code>null</code>.
      * @param arg The type of the single argument of the bean's method.
      *            Must not be <code>null</code>.
      * @param attrName the name of the attribute for which the setter is being
      *                 created.
      *
      * @return an appropriate AttributeSetter instance, or <code>null</code>
      *         if no appropriate conversion is available.
      */
     private AttributeSetter createAttributeSetter(final Method m,
                                                   Class arg,
                                                   final String attrName) {
         // use wrappers for primitive classes, e.g. int and
         // Integer are treated identically
         final Class reflectedArg = PRIMITIVE_TYPE_MAP.containsKey(arg)
             ? (Class) PRIMITIVE_TYPE_MAP.get(arg) : arg;
 
         // Object.class - it gets handled differently by AttributeSetter
         if (java.lang.Object.class == reflectedArg) {
             return new AttributeSetter(m, arg) {
                 public void set(Project p, Object parent, String value)
                         throws InvocationTargetException,
                     IllegalAccessException {
                     throw new BuildException(
                         "Internal ant problem - this should not get called");
                 }
             };
         }
         // simplest case - setAttribute expects String
         if (java.lang.String.class.equals(reflectedArg)) {
             return new AttributeSetter(m, arg) {
                 public void set(Project p, Object parent, String value)
                         throws InvocationTargetException, IllegalAccessException {
                     m.invoke(parent, (Object[]) new String[] {value});
                 }
             };
         }
         // char and Character get special treatment - take the first character
         if (java.lang.Character.class.equals(reflectedArg)) {
             return new AttributeSetter(m, arg) {
                 public void set(Project p, Object parent, String value)
                         throws InvocationTargetException, IllegalAccessException {
                     if (value.length() == 0) {
                         throw new BuildException("The value \"\" is not a "
                                 + "legal value for attribute \"" + attrName + "\"");
                     }
                     m.invoke(parent, (Object[]) new Character[] {new Character(value.charAt(0))});
                 }
             };
         }
         // boolean and Boolean get special treatment because we have a nice method in Project
         if (java.lang.Boolean.class.equals(reflectedArg)) {
             return new AttributeSetter(m, arg) {
                 public void set(Project p, Object parent, String value)
                         throws InvocationTargetException, IllegalAccessException {
                     m.invoke(parent, (Object[]) new Boolean[] {
                             Project.toBoolean(value) ? Boolean.TRUE : Boolean.FALSE });
                 }
             };
         }
         // Class doesn't have a String constructor but a decent factory method
         if (java.lang.Class.class.equals(reflectedArg)) {
             return new AttributeSetter(m, arg) {
                 public void set(Project p, Object parent, String value)
                         throws InvocationTargetException, IllegalAccessException, BuildException {
                     try {
                         m.invoke(parent, new Object[] {Class.forName(value)});
                     } catch (ClassNotFoundException ce) {
                         throw new BuildException(ce);
                     }
                 }
             };
         }
         // resolve relative paths through Project
         if (java.io.File.class.equals(reflectedArg)) {
             return new AttributeSetter(m, arg) {
                 public void set(Project p, Object parent, String value)
                         throws InvocationTargetException, IllegalAccessException {
                     m.invoke(parent, new Object[] {p.resolveFile(value)});
                 }
             };
         }
         // resolve Resources/FileProviders as FileResources relative to Project:
         if (Resource.class.equals(reflectedArg) || FileProvider.class.equals(reflectedArg)) {
             return new AttributeSetter(m, arg) {
                 void set(Project p, Object parent, String value) throws InvocationTargetException,
                         IllegalAccessException, BuildException {
                     m.invoke(parent, new Object[] { new FileResource(p, p.resolveFile(value)) });
                 };
             };
         }
         // EnumeratedAttributes have their own helper class
         if (EnumeratedAttribute.class.isAssignableFrom(reflectedArg)) {
             return new AttributeSetter(m, arg) {
                 public void set(Project p, Object parent, String value)
                         throws InvocationTargetException, IllegalAccessException, BuildException {
                     try {
                         EnumeratedAttribute ea = (EnumeratedAttribute) reflectedArg.newInstance();
                         ea.setValue(value);
                         m.invoke(parent, new Object[] {ea});
                     } catch (InstantiationException ie) {
                         throw new BuildException(ie);
                     }
                 }
             };
         }
 
         AttributeSetter setter = getEnumSetter(reflectedArg, m, arg);
         if (setter != null) {
             return setter;
         }
 
         if (java.lang.Long.class.equals(reflectedArg)) {
             return new AttributeSetter(m, arg) {
                 public void set(Project p, Object parent, String value)
                         throws InvocationTargetException, IllegalAccessException, BuildException {
                     try {
                         m.invoke(parent, new Object[] {
                                 new Long(StringUtils.parseHumanSizes(value)) });
                     } catch (NumberFormatException e) {
                         throw new BuildException("Can't assign non-numeric"
                                                  + " value '" + value + "' to"
                                                  + " attribute " + attrName);
                     } catch (InvocationTargetException e) {
                         throw e;
                     } catch (IllegalAccessException e) {
                         throw e;
                     } catch (Exception e) {
                         throw new BuildException(e);
                     }
                 }
             };
         }
         // worst case. look for a public String constructor and use it
         // also supports new Whatever(Project, String) as for Path or Reference
         // This is used (deliberately) for all primitives/wrappers other than
         // char, boolean, and long.
         boolean includeProject;
         Constructor c;
         try {
             // First try with Project.
             c = reflectedArg.getConstructor(new Class[] {Project.class, String.class});
             includeProject = true;
         } catch (NoSuchMethodException nme) {
             // OK, try without.
             try {
                 c = reflectedArg.getConstructor(new Class[] {String.class});
                 includeProject = false;
             } catch (NoSuchMethodException nme2) {
                 // Well, no matching constructor.
                 return null;
             }
         }
         final boolean finalIncludeProject = includeProject;
         final Constructor finalConstructor = c;
 
         return new AttributeSetter(m, arg) {
             public void set(Project p, Object parent, String value)
                     throws InvocationTargetException, IllegalAccessException, BuildException {
                 try {
                     Object[] args = finalIncludeProject
                             ? new Object[] {p, value} : new Object[] {value};
 
                     Object attribute = finalConstructor.newInstance(args);
                     if (p != null) {
                         p.setProjectReference(attribute);
                     }
                     m.invoke(parent, new Object[] {attribute});
                 } catch (InvocationTargetException e) {
                     Throwable cause = e.getCause();
                     if (cause instanceof IllegalArgumentException) {
                         throw new BuildException("Can't assign value '" + value
                                                  + "' to attribute " + attrName
                                                  + ", reason: "
                                                  + cause.getClass()
                                                  + " with message '"
                                                  + cause.getMessage() + "'");
                     }
                     throw e;
                 } catch (InstantiationException ie) {
                     throw new BuildException(ie);
                 }
             }
         };
     }
 
     private AttributeSetter getEnumSetter(
         final Class reflectedArg, final Method m, Class arg) {
         Class enumClass = null;
         try {
             enumClass = Class.forName("java.lang.Enum");
         } catch (ClassNotFoundException e) {
             //ignore
         }
         if (enumClass != null && enumClass.isAssignableFrom(reflectedArg)) {
             return new AttributeSetter(m, arg) {
                 public void set(Project p, Object parent, String value)
                     throws InvocationTargetException, IllegalAccessException,
                     BuildException {
                     try {
                         m.invoke(
                             parent, new Object[] {
                                 reflectedArg.getMethod(
                                     "valueOf", new Class[] {String.class}).
                                 invoke(null, new Object[] {value})});
                     } catch (InvocationTargetException x) {
                         //there is specific logic here for the value
                         // being out of the allowed set of enumerations.
                         if (x.getTargetException() instanceof IllegalArgumentException) {
                             throw new BuildException(
                                 "'" + value + "' is not a permitted value for "
                                 + reflectedArg.getName());
                         }
                         //only if the exception is not an IllegalArgument do we
                         // request the
                         //BuildException via extractBuildException():
                         throw extractBuildException(x);
                     } catch (Exception x) {
                         //any other failure of invoke() to work.
                         throw new BuildException(x);
                     }
                 }
             };
         }
         return null;
     }
 
     /**
      * Returns a description of the type of the given element in
      * relation to a given project. This is used for logging purposes
      * when the element is asked to cope with some data it has no way of handling.
      *
      * @param project The project the element is defined in. Must not be <code>null</code>.
      *
      * @param element The element to describe. Must not be <code>null</code>.
      *
      * @return a description of the element type
      */
     private String getElementName(Project project, Object element) {
         return project.getElementName(element);
     }
 
     /**
      * Extracts the name of a property from a method name by subtracting
      * a given prefix and converting into lower case. It is up to calling
      * code to make sure the method name does actually begin with the
      * specified prefix - no checking is done in this method.
      *
      * @param methodName The name of the method in question. Must not be <code>null</code>.
      * @param prefix     The prefix to remove. Must not be <code>null</code>.
      *
      * @return the lower-cased method name with the prefix removed.
      */
     private static String getPropertyName(String methodName, String prefix) {
         return methodName.substring(prefix.length()).toLowerCase(Locale.ENGLISH);
     }
 
     /**
      * creator - allows use of create/store external
      * to IntrospectionHelper.
      * The class is final as it has a private constructor.
      */
     public static final class Creator {
         private NestedCreator nestedCreator;
         private Object parent;
         private Project project;
         private Object nestedObject;
         private String polyType;
 
         /**
          * Creates a new Creator instance.
          * This object is given to the UnknownElement to create
          * objects for sub-elements. UnknownElement calls
          * create to create an object, the object then gets
          * configured and then UnknownElement calls store.
          * SetPolyType may be used to override the type used
          * to create the object with. SetPolyType gets called before create.
          *
          * @param project the current project
          * @param parent  the parent object to create the object in
          * @param nestedCreator the nested creator object to use
          */
         private Creator(Project project, Object parent, NestedCreator nestedCreator) {
             this.project = project;
             this.parent = parent;
             this.nestedCreator = nestedCreator;
         }
 
         /**
          * Used to override the class used to create the object.
          *
          * @param polyType a ant component type name
          */
         public void setPolyType(String polyType) {
             this.polyType = polyType;
         }
 
         /**
          * Create an object using this creator, which is determined by introspection.
          *
          * @return the created object
          */
         public Object create() {
             if (polyType != null) {
                 if (!nestedCreator.isPolyMorphic()) {
                     throw new BuildException(
                             "Not allowed to use the polymorphic form for this element");
                 }
                 ComponentHelper helper = ComponentHelper.getComponentHelper(project);
                 nestedObject = helper.createComponent(polyType);
                 if (nestedObject == null) {
                     throw new BuildException("Unable to create object of type " + polyType);
                 }
             }
             try {
                 nestedObject = nestedCreator.create(project, parent, nestedObject);
                 if (project != null) {
                     project.setProjectReference(nestedObject);
                 }
                 return nestedObject;
             } catch (IllegalAccessException ex) {
                 throw new BuildException(ex);
             } catch (InstantiationException ex) {
                 throw new BuildException(ex);
             } catch (IllegalArgumentException ex) {
                 if (polyType == null) {
                     throw ex;
                 }
                 throw new BuildException("Invalid type used " + polyType);
             } catch (InvocationTargetException ex) {
                 throw extractBuildException(ex);
             }
         }
 
         /**
          * @return the real object (used currently only for presetdef).
          */
         public Object getRealObject() {
             return nestedCreator.getRealObject();
         }
 
         /**
          * Stores the nested element object using a storage method determined by introspection.
          *
          */
         public void store() {
             try {
                 nestedCreator.store(parent, nestedObject);
             } catch (IllegalAccessException ex) {
                 throw new BuildException(ex);
             } catch (InstantiationException ex) {
                 throw new BuildException(ex);
             } catch (IllegalArgumentException ex) {
                 if (polyType == null) {
                     throw ex;
                 }
                 throw new BuildException("Invalid type used " + polyType);
             } catch (InvocationTargetException ex) {
                 throw extractBuildException(ex);
             }
         }
     }
 
     /**
      * Internal interface used to create nested elements. Not documented
      * in detail for reasons of source code readability.
      */
     private abstract static class NestedCreator {
         private Method method; // the method called to add/create the nested element
 
         protected NestedCreator(Method m) {
             method = m;
         }
         Method getMethod() {
             return method;
         }
         boolean isPolyMorphic() {
             return false;
         }
         Object getRealObject() {
             return null;
         }
         abstract Object create(Project project, Object parent, Object child)
                 throws InvocationTargetException, IllegalAccessException, InstantiationException;
 
         void store(Object parent, Object child)
                  throws InvocationTargetException, IllegalAccessException, InstantiationException {
             // DO NOTHING
         }
     }
 
     private static class CreateNestedCreator extends NestedCreator {
         CreateNestedCreator(Method m) {
             super(m);
         }
 
         Object create(Project project, Object parent, Object ignore)
                 throws InvocationTargetException, IllegalAccessException {
             return getMethod().invoke(parent, new Object[] {});
         }
     }
 
     /** Version to use for addXXX and addConfiguredXXX */
     private static class AddNestedCreator extends NestedCreator {
 
         static final int ADD = 1;
         static final int ADD_CONFIGURED = 2;
 
         private Constructor constructor;
         private int behavior; // ADD or ADD_CONFIGURED
 
         AddNestedCreator(Method m, Constructor c, int behavior) {
             super(m);
             this.constructor = c;
             this.behavior = behavior;
         }
 
         boolean isPolyMorphic() {
             return true;
         }
 
         Object create(Project project, Object parent, Object child)
                 throws InvocationTargetException, IllegalAccessException, InstantiationException {
             if (child == null) {
                 child = constructor.newInstance(
                         constructor.getParameterTypes().length == 0
                                 ? new Object[] {} : new Object[] {project});
             }
             if (child instanceof PreSetDef.PreSetDefinition) {
                 child = ((PreSetDef.PreSetDefinition) child).createObject(project);
             }
             if (behavior == ADD) {
                 istore(parent, child);
             }
             return child;
         }
 
         void store(Object parent, Object child)
                 throws InvocationTargetException, IllegalAccessException, InstantiationException {
             if (behavior == ADD_CONFIGURED) {
                 istore(parent, child);
             }
         }
 
         private void istore(Object parent, Object child)
                 throws InvocationTargetException, IllegalAccessException, InstantiationException {
             getMethod().invoke(parent, new Object[] {child});
         }
     }
 
     /**
      * Internal interface used to setting element attributes. Not documented
      * in detail for reasons of source code readability.
      */
     private abstract static class AttributeSetter {
         private Method method; // the method called to set the attribute
         private Class type;
         protected AttributeSetter(Method m, Class type) {
             method = m;
             this.type = type;
         }
         void setObject(Project p, Object parent, Object value)
                 throws InvocationTargetException, IllegalAccessException, BuildException {
             if (type != null) {
                 Class useType = type;
                 if (type.isPrimitive()) {
                     if (value == null) {
                         throw new BuildException(
                             "Attempt to set primitive "
                             + getPropertyName(method.getName(), "set")
                             + " to null on " + parent);
                     }
                     useType = (Class) PRIMITIVE_TYPE_MAP.get(type);
                 }
                 if (value == null || useType.isInstance(value)) {
                     method.invoke(parent, new Object[] {value});
                     return;
                 }
             }
             set(p, parent, value.toString());
         }
         abstract void set(Project p, Object parent, String value)
                 throws InvocationTargetException, IllegalAccessException, BuildException;
     }
 
     /**
      * Clears the static cache of on build finished.
      */
     public static void clearCache() {
         HELPERS.clear();
     }
 
     /**
      * Create a NestedCreator for the given element.
      * @param project owning project
      * @param parent Parent object used to create the instance.
      * @param elementName name of the element
      * @return a nested creator, or null if there is no component of the given name, or it
      *        has no matching add type methods
      * @throws BuildException
      */
     private NestedCreator createAddTypeCreator(
             Project project, Object parent, String elementName) throws BuildException {
         if (addTypeMethods.size() == 0) {
             return null;
         }
         ComponentHelper helper = ComponentHelper.getComponentHelper(project);
 
         MethodAndObject restricted =  createRestricted(
             helper, elementName, addTypeMethods);
         MethodAndObject topLevel = createTopLevel(
             helper, elementName, addTypeMethods);
 
         if (restricted == null && topLevel == null) {
             return null;
         }
 
         if (restricted != null && topLevel != null) {
             throw new BuildException(
                 "ambiguous: type and component definitions for "
                 + elementName);
         }
 
         MethodAndObject methodAndObject
             = restricted != null ? restricted : topLevel;
 
         Object rObject = methodAndObject.object;
         if (methodAndObject.object instanceof PreSetDef.PreSetDefinition) {
             rObject = ((PreSetDef.PreSetDefinition) methodAndObject.object)
                 .createObject(project);
         }
         final Object nestedObject = methodAndObject.object;
         final Object realObject = rObject;
 
         return new NestedCreator(methodAndObject.method) {
             Object create(Project project, Object parent, Object ignore)
                     throws InvocationTargetException, IllegalAccessException {
                 if (!getMethod().getName().endsWith("Configured")) {
                     getMethod().invoke(parent, new Object[] {realObject});
                 }
                 return nestedObject;
             }
 
             Object getRealObject() {
                 return realObject;
             }
 
             void store(Object parent, Object child) throws InvocationTargetException,
                     IllegalAccessException, InstantiationException {
                 if (getMethod().getName().endsWith("Configured")) {
                     getMethod().invoke(parent, new Object[] {realObject});
                 }
             }
         };
     }
 
     /**
      * Inserts an add or addConfigured method into
      * the addTypeMethods array. The array is
      * ordered so that the more derived classes are first.
      * If both add and addConfigured are present, the addConfigured will take priority.
      * @param method the <code>Method</code> to insert.
      */
     private void insertAddTypeMethod(Method method) {
         Class argClass = method.getParameterTypes()[0];
-        for (int c = 0; c < addTypeMethods.size(); ++c) {
+        final int size = addTypeMethods.size();
+        for (int c = 0; c < size; ++c) {
             Method current = (Method) addTypeMethods.get(c);
             if (current.getParameterTypes()[0].equals(argClass)) {
                 if (method.getName().equals("addConfigured")) {
                     // add configured replaces the add method
                     addTypeMethods.set(c, method);
                 }
                 return; // Already present
             }
             if (current.getParameterTypes()[0].isAssignableFrom(argClass)) {
                 addTypeMethods.add(c, method);
                 return; // higher derived
             }
         }
         addTypeMethods.add(method);
     }
 
     /**
      * Search the list of methods to find the first method
      * that has a parameter that accepts the nested element object.
      * @param paramClass the <code>Class</code> type to search for.
      * @param methods the <code>List</code> of methods to search.
      * @return a matching <code>Method</code>; null if none found.
      */
     private Method findMatchingMethod(Class paramClass, List methods) {
         if (paramClass == null) {
             return null;
         }
         Class matchedClass = null;
         Method matchedMethod = null;
 
-        for (int i = 0; i < methods.size(); ++i) {
+        final int size = methods.size();
+        for (int i = 0; i < size; ++i) {
             Method method = (Method) methods.get(i);
             Class  methodClass = method.getParameterTypes()[0];
             if (methodClass.isAssignableFrom(paramClass)) {
                 if (matchedClass == null) {
                     matchedClass = methodClass;
                     matchedMethod = method;
                 } else if (!methodClass.isAssignableFrom(matchedClass)) {
                     throw new BuildException("ambiguous: types " + matchedClass.getName() + " and "
                             + methodClass.getName() + " match " + paramClass.getName());
                 }
             }
         }
         return matchedMethod;
     }
 
     private String condenseText(final String text) {
         if (text.length() <= MAX_REPORT_NESTED_TEXT) {
             return text;
         }
         int ends = (MAX_REPORT_NESTED_TEXT - ELLIPSIS.length()) / 2;
         return new StringBuffer(text).replace(ends, text.length() - ends, ELLIPSIS).toString();
     }
 
 
     private class MethodAndObject {
         private Method method;
         private Object object;
         public MethodAndObject(Method method, Object object) {
             this.method = method;
             this.object = object;
         }
     }
 
     /**
      *
      */
     private AntTypeDefinition findRestrictedDefinition(
         ComponentHelper helper, String componentName, List methods) {
         AntTypeDefinition definition = null;
         Class matchedDefinitionClass = null;
 
         List definitions = helper.getRestrictedDefinitions(componentName);
         if (definitions == null) {
             return null;
         }
         synchronized (definitions) {
-            for (int i = 0; i < definitions.size(); ++i) {
+            final int size = definitions.size();
+            for (int i = 0; i < size; ++i) {
                 AntTypeDefinition d = (AntTypeDefinition) definitions.get(i);
                 Class exposedClass = d.getExposedClass(helper.getProject());
                 if (exposedClass == null) {
                     continue;
                 }
                 Method method  = findMatchingMethod(exposedClass, methods);
                 if (method == null) {
                     continue;
                 }
                 if (matchedDefinitionClass != null) {
                     throw new BuildException(
                         "ambiguous: restricted definitions for "
                         + componentName + " "
                         + matchedDefinitionClass + " and " + exposedClass);
                 }
                 matchedDefinitionClass = exposedClass;
                 definition = d;
             }
         }
         return definition;
     }
 
     private MethodAndObject createRestricted(
         ComponentHelper helper, String elementName, List addTypeMethods) {
 
         Project project = helper.getProject();
 
         AntTypeDefinition restrictedDefinition =
             findRestrictedDefinition(helper, elementName, addTypeMethods);
 
         if (restrictedDefinition == null) {
             return null;
         }
 
         Method addMethod = findMatchingMethod(
             restrictedDefinition.getExposedClass(project), addTypeMethods);
         if (addMethod == null) {
             throw new BuildException(
                 "Ant Internal Error - contract mismatch for "
                 + elementName);
         }
         Object addedObject = restrictedDefinition.create(project);
         if (addedObject == null) {
             throw new BuildException(
                 "Failed to create object " + elementName
                 + " of type " + restrictedDefinition.getTypeClass(project));
         }
         return new MethodAndObject(addMethod, addedObject);
     }
 
     private MethodAndObject createTopLevel(
         ComponentHelper helper, String elementName, List methods) {
         Class clazz = helper.getComponentClass(elementName);
         if (clazz == null) {
             return null;
         }
         Method addMethod = findMatchingMethod(clazz, addTypeMethods);
         if (addMethod == null) {
             return null;
         }
         Object addedObject = helper.createComponent(elementName);
         return new MethodAndObject(addMethod, addedObject);
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/Main.java b/src/main/org/apache/tools/ant/Main.java
index 80f44c61f..c03e69526 100644
--- a/src/main/org/apache/tools/ant/Main.java
+++ b/src/main/org/apache/tools/ant/Main.java
@@ -1,1225 +1,1228 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintStream;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.Vector;
 
 import org.apache.tools.ant.input.DefaultInputHandler;
 import org.apache.tools.ant.input.InputHandler;
 import org.apache.tools.ant.launch.AntMain;
 import org.apache.tools.ant.property.ResolvePropertyMap;
 import org.apache.tools.ant.util.ClasspathUtils;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.ProxySetup;
 
 
 /**
  * Command line entry point into Ant. This class is entered via the
  * canonical `public static void main` entry point and reads the
  * command line arguments. It then assembles and executes an Ant
  * project.
  * <p>
  * If you integrating Ant into some other tool, this is not the class
  * to use as an entry point. Please see the source code of this
  * class to see how it manipulates the Ant project classes.
  *
  */
 public class Main implements AntMain {
 
     /**
      * A Set of args are are handled by the launcher and should
      * not be seen by Main.
      */
     private static final Set LAUNCH_COMMANDS = new HashSet();
     static {
         LAUNCH_COMMANDS.add("-lib");
         LAUNCH_COMMANDS.add("-cp");
         LAUNCH_COMMANDS.add("-noclasspath");
         LAUNCH_COMMANDS.add("--noclasspath");
         LAUNCH_COMMANDS.add("-nouserlib");
         LAUNCH_COMMANDS.add("-main");
     }
 
     /** The default build file name. {@value} */
     public static final String DEFAULT_BUILD_FILENAME = "build.xml";
 
     /** Our current message output status. Follows Project.MSG_XXX. */
     private int msgOutputLevel = Project.MSG_INFO;
 
     /** File that we are using for configuration. */
     private File buildFile; /* null */
 
     /** Stream to use for logging. */
     private static PrintStream out = System.out;
 
     /** Stream that we are using for logging error messages. */
     private static PrintStream err = System.err;
 
     /** The build targets. */
     private Vector targets = new Vector();
 
     /** Set of properties that can be used by tasks. */
     private Properties definedProps = new Properties();
 
     /** Names of classes to add as listeners to project. */
     private Vector listeners = new Vector(1);
 
     /** File names of property files to load on startup. */
     private Vector propertyFiles = new Vector(1);
 
     /** Indicates whether this build is to support interactive input */
     private boolean allowInput = true;
 
     /** keep going mode */
     private boolean keepGoingMode = false;
 
     /**
      * The Ant logger class. There may be only one logger. It will have
      * the right to use the 'out' PrintStream. The class must implements the
      * BuildLogger interface.
      */
     private String loggerClassname = null;
 
     /**
      * The Ant InputHandler class.  There may be only one input
      * handler.
      */
     private String inputHandlerClassname = null;
 
     /**
      * Whether or not output to the log is to be unadorned.
      */
     private boolean emacsMode = false;
 
     /**
      * Whether or not this instance has successfully been
      * constructed and is ready to run.
      */
     private boolean readyToRun = false;
 
     /**
      * Whether or not we should only parse and display the project help
      * information.
      */
     private boolean projectHelp = false;
 
     /**
      * Whether or not a logfile is being used. This is used to
      * check if the output streams must be closed.
      */
     private static boolean isLogFileUsed = false;
 
     /**
      * optional thread priority
      */
     private Integer threadPriority = null;
 
     /**
      * proxy flag: default is false
      */
     private boolean proxy = false;
 
     /**
      * Prints the message of the Throwable if it (the message) is not
      * <code>null</code>.
      *
      * @param t Throwable to print the message of.
      *          Must not be <code>null</code>.
      */
     private static void printMessage(Throwable t) {
         String message = t.getMessage();
         if (message != null) {
             System.err.println(message);
         }
     }
 
     /**
      * Creates a new instance of this class using the
      * arguments specified, gives it any extra user properties which have been
      * specified, and then runs the build using the classloader provided.
      *
      * @param args Command line arguments. Must not be <code>null</code>.
      * @param additionalUserProperties Any extra properties to use in this
      *        build. May be <code>null</code>, which is the equivalent to
      *        passing in an empty set of properties.
      * @param coreLoader Classloader used for core classes. May be
      *        <code>null</code> in which case the system classloader is used.
      */
     public static void start(String[] args, Properties additionalUserProperties,
                              ClassLoader coreLoader) {
         Main m = new Main();
         m.startAnt(args, additionalUserProperties, coreLoader);
     }
 
     /**
      * Start Ant
      * @param args command line args
      * @param additionalUserProperties properties to set beyond those that
      *        may be specified on the args list
      * @param coreLoader - not used
      *
      * @since Ant 1.6
      */
     public void startAnt(String[] args, Properties additionalUserProperties,
                          ClassLoader coreLoader) {
 
         try {
             processArgs(args);
         } catch (Throwable exc) {
             handleLogfile();
             printMessage(exc);
             exit(1);
             return;
         }
 
         if (additionalUserProperties != null) {
             for (Enumeration e = additionalUserProperties.keys();
                     e.hasMoreElements();) {
                 String key = (String) e.nextElement();
                 String property = additionalUserProperties.getProperty(key);
                 definedProps.put(key, property);
             }
         }
 
         // expect the worst
         int exitCode = 1;
         try {
             try {
                 runBuild(coreLoader);
                 exitCode = 0;
             } catch (ExitStatusException ese) {
                 exitCode = ese.getStatus();
                 if (exitCode != 0) {
                     throw ese;
                 }
             }
         } catch (BuildException be) {
             if (err != System.err) {
                 printMessage(be);
             }
         } catch (Throwable exc) {
             exc.printStackTrace();
             printMessage(exc);
         } finally {
             handleLogfile();
         }
         exit(exitCode);
     }
 
     /**
      * This operation is expected to call {@link System#exit(int)}, which
      * is what the base version does.
      * However, it is possible to do something else.
      * @param exitCode code to exit with
      */
     protected void exit(int exitCode) {
         System.exit(exitCode);
     }
 
     /**
      * Close logfiles, if we have been writing to them.
      *
      * @since Ant 1.6
      */
     private static void handleLogfile() {
         if (isLogFileUsed) {
             FileUtils.close(out);
             FileUtils.close(err);
         }
     }
 
     /**
      * Command line entry point. This method kicks off the building
      * of a project object and executes a build using either a given
      * target or the default target.
      *
      * @param args Command line arguments. Must not be <code>null</code>.
      */
     public static void main(String[] args) {
         start(args, null, null);
     }
 
     /**
      * Constructor used when creating Main for later arg processing
      * and startup
      */
     public Main() {
     }
 
     /**
      * Sole constructor, which parses and deals with command line
      * arguments.
      *
      * @param args Command line arguments. Must not be <code>null</code>.
      *
      * @exception BuildException if the specified build file doesn't exist
      *                           or is a directory.
      *
      * @deprecated since 1.6.x
      */
     protected Main(String[] args) throws BuildException {
         processArgs(args);
     }
 
     /**
      * Process command line arguments.
      * When ant is started from Launcher, launcher-only arguments do not get
      * passed through to this routine.
      *
      * @param args the command line arguments.
      *
      * @since Ant 1.6
      */
     private void processArgs(String[] args) {
         String searchForThis = null;
         boolean searchForFile = false;
         PrintStream logTo = null;
 
         // cycle through given args
 
         boolean justPrintUsage = false;
         boolean justPrintVersion = false;
         boolean justPrintDiagnostics = false;
 
         for (int i = 0; i < args.length; i++) {
             String arg = args[i];
 
             if (arg.equals("-help") || arg.equals("-h")) {
                 justPrintUsage = true;
             } else if (arg.equals("-version")) {
                 justPrintVersion = true;
             } else if (arg.equals("-diagnostics")) {
                 justPrintDiagnostics = true;
             } else if (arg.equals("-quiet") || arg.equals("-q")) {
                 msgOutputLevel = Project.MSG_WARN;
             } else if (arg.equals("-verbose") || arg.equals("-v")) {
                 msgOutputLevel = Project.MSG_VERBOSE;
             } else if (arg.equals("-debug") || arg.equals("-d")) {
                 msgOutputLevel = Project.MSG_DEBUG;
             } else if (arg.equals("-noinput")) {
                 allowInput = false;
             } else if (arg.equals("-logfile") || arg.equals("-l")) {
                 try {
                     File logFile = new File(args[i + 1]);
                     i++;
                     logTo = new PrintStream(new FileOutputStream(logFile));
                     isLogFileUsed = true;
                 } catch (IOException ioe) {
                     String msg = "Cannot write on the specified log file. "
                         + "Make sure the path exists and you have write "
                         + "permissions.";
                     throw new BuildException(msg);
                 } catch (ArrayIndexOutOfBoundsException aioobe) {
                     String msg = "You must specify a log file when "
                         + "using the -log argument";
                     throw new BuildException(msg);
                 }
             } else if (arg.equals("-buildfile") || arg.equals("-file")
                        || arg.equals("-f")) {
                 i = handleArgBuildFile(args, i);
             } else if (arg.equals("-listener")) {
                 i = handleArgListener(args, i);
             } else if (arg.startsWith("-D")) {
                 i = handleArgDefine(args, i);
             } else if (arg.equals("-logger")) {
                 i = handleArgLogger(args, i);
             } else if (arg.equals("-inputhandler")) {
                 i = handleArgInputHandler(args, i);
             } else if (arg.equals("-emacs") || arg.equals("-e")) {
                 emacsMode = true;
             } else if (arg.equals("-projecthelp") || arg.equals("-p")) {
                 // set the flag to display the targets and quit
                 projectHelp = true;
             } else if (arg.equals("-find") || arg.equals("-s")) {
                 searchForFile = true;
                 // eat up next arg if present, default to build.xml
                 if (i < args.length - 1) {
                     searchForThis = args[++i];
                 }
             } else if (arg.startsWith("-propertyfile")) {
                 i = handleArgPropertyFile(args, i);
             } else if (arg.equals("-k") || arg.equals("-keep-going")) {
                 keepGoingMode = true;
             } else if (arg.equals("-nice")) {
                 i = handleArgNice(args, i);
             } else if (LAUNCH_COMMANDS.contains(arg)) {
                 //catch script/ant mismatch with a meaningful message
                 //we could ignore it, but there are likely to be other
                 //version problems, so we stamp down on the configuration now
                 String msg = "Ant's Main method is being handed "
                         + "an option " + arg + " that is only for the launcher class."
                         + "\nThis can be caused by a version mismatch between "
                         + "the ant script/.bat file and Ant itself.";
                 throw new BuildException(msg);
             } else if (arg.equals("-autoproxy")) {
                 proxy = true;
             } else if (arg.startsWith("-")) {
                 // we don't have any more args to recognize!
                 String msg = "Unknown argument: " + arg;
                 System.err.println(msg);
                 printUsage();
                 throw new BuildException("");
             } else {
                 // if it's no other arg, it may be the target
                 targets.addElement(arg);
             }
         }
 
         if (msgOutputLevel >= Project.MSG_VERBOSE || justPrintVersion) {
             printVersion(msgOutputLevel);
         }
 
         if (justPrintUsage || justPrintVersion || justPrintDiagnostics) {
             if (justPrintUsage) {
                 printUsage();
             }
             if (justPrintDiagnostics) {
                 Diagnostics.doReport(System.out, msgOutputLevel);
             }
             return;
         }
 
         // if buildFile was not specified on the command line,
         if (buildFile == null) {
             // but -find then search for it
             if (searchForFile) {
                 if (searchForThis != null) {
                     buildFile = findBuildFile(System.getProperty("user.dir"), searchForThis);
                     if (buildFile == null) {
                         throw new BuildException("Could not locate a build file!");
                     }
                 } else {
                     // no search file specified: so search an existing default file
                     Iterator it = ProjectHelperRepository.getInstance().getHelpers();
                     do {
                         ProjectHelper helper = (ProjectHelper) it.next();
                         searchForThis = helper.getDefaultBuildFile();
                         if (msgOutputLevel >= Project.MSG_VERBOSE) {
                             System.out.println("Searching the default build file: " + searchForThis);
                         }
                         buildFile = findBuildFile(System.getProperty("user.dir"), searchForThis);
                     } while (buildFile == null && it.hasNext());
                     if (buildFile == null) {
                         throw new BuildException("Could not locate a build file!");
                     }
                 }
             } else {
                 // no build file specified: so search an existing default file
                 Iterator it = ProjectHelperRepository.getInstance().getHelpers();
                 do {
                     ProjectHelper helper = (ProjectHelper) it.next();
                     buildFile = new File(helper.getDefaultBuildFile());
                     if (msgOutputLevel >= Project.MSG_VERBOSE) {
                         System.out.println("Trying the default build file: " + buildFile);
                     }
                 } while (!buildFile.exists() && it.hasNext());
             }
         }
 
         // make sure buildfile exists
         if (!buildFile.exists()) {
             System.out.println("Buildfile: " + buildFile + " does not exist!");
             throw new BuildException("Build failed");
         }
 
         // make sure it's not a directory (this falls into the ultra
         // paranoid lets check everything category
 
         if (buildFile.isDirectory()) {
             System.out.println("What? Buildfile: " + buildFile + " is a dir!");
             throw new BuildException("Build failed");
         }
 
         // Normalize buildFile for re-import detection
         buildFile =
             FileUtils.getFileUtils().normalize(buildFile.getAbsolutePath());
 
         // Load the property files specified by -propertyfile
         loadPropertyFiles();
 
         if (msgOutputLevel >= Project.MSG_INFO) {
             System.out.println("Buildfile: " + buildFile);
         }
 
         if (logTo != null) {
             out = logTo;
             err = logTo;
             System.setOut(out);
             System.setErr(err);
         }
         readyToRun = true;
     }
 
     // --------------------------------------------------------
     //    Methods for handling the command line arguments
     // --------------------------------------------------------
 
     /** Handle the -buildfile, -file, -f argument */
     private int handleArgBuildFile(String[] args, int pos) {
         try {
             buildFile = new File(
                 args[++pos].replace('/', File.separatorChar));
         } catch (ArrayIndexOutOfBoundsException aioobe) {
             throw new BuildException(
                 "You must specify a buildfile when using the -buildfile argument");
         }
         return pos;
     }
 
     /** Handle -listener argument */
     private int handleArgListener(String[] args, int pos) {
         try {
             listeners.addElement(args[pos + 1]);
             pos++;
         } catch (ArrayIndexOutOfBoundsException aioobe) {
             String msg = "You must specify a classname when "
                 + "using the -listener argument";
             throw new BuildException(msg);
         }
         return pos;
     }
 
     /** Handler -D argument */
     private int handleArgDefine(String[] args, int argPos) {
         /* Interestingly enough, we get to here when a user
          * uses -Dname=value. However, in some cases, the OS
          * goes ahead and parses this out to args
          *   {"-Dname", "value"}
          * so instead of parsing on "=", we just make the "-D"
          * characters go away and skip one argument forward.
          *
          * I don't know how to predict when the JDK is going
          * to help or not, so we simply look for the equals sign.
          */
         String arg = args[argPos];
         String name = arg.substring(2, arg.length());
         String value = null;
         int posEq = name.indexOf("=");
         if (posEq > 0) {
             value = name.substring(posEq + 1);
             name = name.substring(0, posEq);
         } else if (argPos < args.length - 1) {
             value = args[++argPos];
         } else {
             throw new BuildException("Missing value for property "
                                      + name);
         }
         definedProps.put(name, value);
         return argPos;
     }
 
     /** Handle the -logger argument. */
     private int handleArgLogger(String[] args, int pos) {
         if (loggerClassname != null) {
             throw new BuildException(
                 "Only one logger class may be specified.");
         }
         try {
             loggerClassname = args[++pos];
         } catch (ArrayIndexOutOfBoundsException aioobe) {
             throw new BuildException(
                 "You must specify a classname when using the -logger argument");
         }
         return pos;
     }
 
     /** Handle the -inputhandler argument. */
     private int handleArgInputHandler(String[] args, int pos) {
         if (inputHandlerClassname != null) {
             throw new BuildException("Only one input handler class may "
                                      + "be specified.");
         }
         try {
             inputHandlerClassname = args[++pos];
         } catch (ArrayIndexOutOfBoundsException aioobe) {
             throw new BuildException("You must specify a classname when"
                                      + " using the -inputhandler"
                                      + " argument");
         }
         return pos;
     }
 
     /** Handle the -propertyfile argument. */
     private int handleArgPropertyFile(String[] args, int pos) {
         try {
             propertyFiles.addElement(args[++pos]);
         } catch (ArrayIndexOutOfBoundsException aioobe) {
             String msg = "You must specify a property filename when "
                 + "using the -propertyfile argument";
             throw new BuildException(msg);
         }
         return pos;
     }
 
     /** Handle the -nice argument. */
     private int handleArgNice(String[] args, int pos) {
         try {
             threadPriority = Integer.decode(args[++pos]);
         } catch (ArrayIndexOutOfBoundsException aioobe) {
             throw new BuildException(
                 "You must supply a niceness value (1-10)"
                 + " after the -nice option");
         } catch (NumberFormatException e) {
             throw new BuildException("Unrecognized niceness value: "
                                      + args[pos]);
         }
 
         if (threadPriority.intValue() < Thread.MIN_PRIORITY
             || threadPriority.intValue() > Thread.MAX_PRIORITY) {
             throw new BuildException(
                 "Niceness value is out of the range 1-10");
         }
         return pos;
     }
 
     // --------------------------------------------------------
     //    other methods
     // --------------------------------------------------------
 
     /** Load the property files specified by -propertyfile */
     private void loadPropertyFiles() {
         for (int propertyFileIndex = 0;
              propertyFileIndex < propertyFiles.size();
              propertyFileIndex++) {
             String filename
                 = (String) propertyFiles.elementAt(propertyFileIndex);
             Properties props = new Properties();
             FileInputStream fis = null;
             try {
                 fis = new FileInputStream(filename);
                 props.load(fis);
             } catch (IOException e) {
                 System.out.println("Could not load property file "
                                    + filename + ": " + e.getMessage());
             } finally {
                 FileUtils.close(fis);
             }
 
             // ensure that -D properties take precedence
             Enumeration propertyNames = props.propertyNames();
             while (propertyNames.hasMoreElements()) {
                 String name = (String) propertyNames.nextElement();
                 if (definedProps.getProperty(name) == null) {
                     definedProps.put(name, props.getProperty(name));
                 }
             }
         }
     }
 
     /**
      * Helper to get the parent file for a given file.
      * <p>
      * Added to simulate File.getParentFile() from JDK 1.2.
      * @deprecated since 1.6.x
      *
      * @param file   File to find parent of. Must not be <code>null</code>.
      * @return       Parent file or null if none
      */
     private File getParentFile(File file) {
         File parent = file.getParentFile();
 
         if (parent != null && msgOutputLevel >= Project.MSG_VERBOSE) {
             System.out.println("Searching in " + parent.getAbsolutePath());
         }
 
         return parent;
     }
 
     /**
      * Search parent directories for the build file.
      * <p>
      * Takes the given target as a suffix to append to each
      * parent directory in search of a build file.  Once the
      * root of the file-system has been reached <code>null</code>
      * is returned.
      *
      * @param start  Leaf directory of search.
      *               Must not be <code>null</code>.
      * @param suffix  Suffix filename to look for in parents.
      *                Must not be <code>null</code>.
      *
      * @return A handle to the build file if one is found, <code>null</code> if not
      */
     private File findBuildFile(String start, String suffix) {
         if (msgOutputLevel >= Project.MSG_INFO) {
             System.out.println("Searching for " + suffix + " ...");
         }
 
         File parent = new File(new File(start).getAbsolutePath());
         File file = new File(parent, suffix);
 
         // check if the target file exists in the current directory
         while (!file.exists()) {
             // change to parent directory
             parent = getParentFile(parent);
 
             // if parent is null, then we are at the root of the fs,
             // complain that we can't find the build file.
             if (parent == null) {
                 return null;
             }
 
             // refresh our file handle
             file = new File(parent, suffix);
         }
 
         return file;
     }
 
     /**
      * Executes the build. If the constructor for this instance failed
      * (e.g. returned after issuing a warning), this method returns
      * immediately.
      *
      * @param coreLoader The classloader to use to find core classes.
      *                   May be <code>null</code>, in which case the
      *                   system classloader is used.
      *
      * @exception BuildException if the build fails
      */
     private void runBuild(ClassLoader coreLoader) throws BuildException {
 
         if (!readyToRun) {
             return;
         }
 
         final Project project = new Project();
         project.setCoreLoader(coreLoader);
 
         Throwable error = null;
 
         try {
             addBuildListeners(project);
             addInputHandler(project);
 
             PrintStream savedErr = System.err;
             PrintStream savedOut = System.out;
             InputStream savedIn = System.in;
 
             // use a system manager that prevents from System.exit()
             SecurityManager oldsm = null;
             oldsm = System.getSecurityManager();
 
                 //SecurityManager can not be installed here for backwards
                 //compatibility reasons (PD). Needs to be loaded prior to
                 //ant class if we are going to implement it.
                 //System.setSecurityManager(new NoExitSecurityManager());
             try {
                 if (allowInput) {
                     project.setDefaultInputStream(System.in);
                 }
                 System.setIn(new DemuxInputStream(project));
                 System.setOut(new PrintStream(new DemuxOutputStream(project, false)));
                 System.setErr(new PrintStream(new DemuxOutputStream(project, true)));
 
 
                 if (!projectHelp) {
                     project.fireBuildStarted();
                 }
 
                 // set the thread priorities
                 if (threadPriority != null) {
                     try {
                         project.log("Setting Ant's thread priority to "
                                 + threadPriority, Project.MSG_VERBOSE);
                         Thread.currentThread().setPriority(threadPriority.intValue());
                     } catch (SecurityException swallowed) {
                         //we cannot set the priority here.
                         project.log("A security manager refused to set the -nice value");
                     }
                 }
 
 
 
                 project.init();
 
                 // resolve properties
                 PropertyHelper propertyHelper
                     = (PropertyHelper) PropertyHelper.getPropertyHelper(project);
                 HashMap props = new HashMap(definedProps);
                 new ResolvePropertyMap(project, propertyHelper,
                                        propertyHelper.getExpanders())
                     .resolveAllProperties(props, null, false);
 
                 // set user-define properties
                 for (Iterator e = props.entrySet().iterator(); e.hasNext(); ) {
                     Map.Entry ent = (Map.Entry) e.next();
                     String arg = (String) ent.getKey();
                     Object value = ent.getValue();
                     project.setUserProperty(arg, String.valueOf(value));
                 }
 
                 project.setUserProperty(MagicNames.ANT_FILE,
                                         buildFile.getAbsolutePath());
                 project.setUserProperty(MagicNames.ANT_FILE_TYPE,
                                         MagicNames.ANT_FILE_TYPE_FILE);
 
                 project.setKeepGoingMode(keepGoingMode);
                 if (proxy) {
                     //proxy setup if enabled
                     ProxySetup proxySetup = new ProxySetup(project);
                     proxySetup.enableProxies();
                 }
 
                 ProjectHelper.configureProject(project, buildFile);
 
                 if (projectHelp) {
                     printDescription(project);
                     printTargets(project, msgOutputLevel > Project.MSG_INFO,
                             msgOutputLevel > Project.MSG_VERBOSE);
                     return;
                 }
 
                 // make sure that we have a target to execute
                 if (targets.size() == 0) {
                     if (project.getDefaultTarget() != null) {
                         targets.addElement(project.getDefaultTarget());
                     }
                 }
 
                 project.executeTargets(targets);
             } finally {
                 // put back the original security manager
                 //The following will never eval to true. (PD)
                 if (oldsm != null) {
                     System.setSecurityManager(oldsm);
                 }
 
                 System.setOut(savedOut);
                 System.setErr(savedErr);
                 System.setIn(savedIn);
             }
         } catch (RuntimeException exc) {
             error = exc;
             throw exc;
         } catch (Error e) {
             error = e;
             throw e;
         } finally {
             if (!projectHelp) {
                 try {
                     project.fireBuildFinished(error);
                 } catch (Throwable t) {
                     // yes, I know it is bad style to catch Throwable,
                     // but if we don't, we lose valuable information
                     System.err.println("Caught an exception while logging the"
                                        + " end of the build.  Exception was:");
                     t.printStackTrace();
                     if (error != null) {
                         System.err.println("There has been an error prior to"
                                            + " that:");
                         error.printStackTrace();
                     }
                     throw new BuildException(t);
                 }
             } else if (error != null) {
                 project.log(error.toString(), Project.MSG_ERR);
             }
         }
     }
 
     /**
      * Adds the listeners specified in the command line arguments,
      * along with the default listener, to the specified project.
      *
      * @param project The project to add listeners to.
      *                Must not be <code>null</code>.
      */
     protected void addBuildListeners(Project project) {
 
         // Add the default listener
         project.addBuildListener(createLogger());
 
-        for (int i = 0; i < listeners.size(); i++) {
+        final int count = listeners.size();
+        for (int i = 0; i < count; i++) {
             String className = (String) listeners.elementAt(i);
             BuildListener listener =
                     (BuildListener) ClasspathUtils.newInstance(className,
                             Main.class.getClassLoader(), BuildListener.class);
             project.setProjectReference(listener);
 
             project.addBuildListener(listener);
         }
     }
 
     /**
      * Creates the InputHandler and adds it to the project.
      *
      * @param project the project instance.
      *
      * @exception BuildException if a specified InputHandler
      *                           implementation could not be loaded.
      */
     private void addInputHandler(Project project) throws BuildException {
         InputHandler handler = null;
         if (inputHandlerClassname == null) {
             handler = new DefaultInputHandler();
         } else {
             handler = (InputHandler) ClasspathUtils.newInstance(
                     inputHandlerClassname, Main.class.getClassLoader(),
                     InputHandler.class);
             project.setProjectReference(handler);
         }
         project.setInputHandler(handler);
     }
 
     // XXX: (Jon Skeet) Any reason for writing a message and then using a bare
     // RuntimeException rather than just using a BuildException here? Is it
     // in case the message could end up being written to no loggers (as the
     // loggers could have failed to be created due to this failure)?
     /**
      * Creates the default build logger for sending build events to the ant
      * log.
      *
      * @return the logger instance for this build.
      */
     private BuildLogger createLogger() {
         BuildLogger logger = null;
         if (loggerClassname != null) {
             try {
                 logger = (BuildLogger) ClasspathUtils.newInstance(
                         loggerClassname, Main.class.getClassLoader(),
                         BuildLogger.class);
             } catch (BuildException e) {
                 System.err.println("The specified logger class "
                     + loggerClassname
                     + " could not be used because " + e.getMessage());
                 throw new RuntimeException();
             }
         } else {
             logger = new DefaultLogger();
         }
 
         logger.setMessageOutputLevel(msgOutputLevel);
         logger.setOutputPrintStream(out);
         logger.setErrorPrintStream(err);
         logger.setEmacsMode(emacsMode);
 
         return logger;
     }
 
     /**
      * Prints the usage information for this class to <code>System.out</code>.
      */
     private static void printUsage() {
         String lSep = System.getProperty("line.separator");
         StringBuffer msg = new StringBuffer();
         msg.append("ant [options] [target [target2 [target3] ...]]" + lSep);
         msg.append("Options: " + lSep);
         msg.append("  -help, -h              print this message" + lSep);
         msg.append("  -projecthelp, -p       print project help information" + lSep);
         msg.append("  -version               print the version information and exit" + lSep);
         msg.append("  -diagnostics           print information that might be helpful to" + lSep);
         msg.append("                         diagnose or report problems." + lSep);
         msg.append("  -quiet, -q             be extra quiet" + lSep);
         msg.append("  -verbose, -v           be extra verbose" + lSep);
         msg.append("  -debug, -d             print debugging information" + lSep);
         msg.append("  -emacs, -e             produce logging information without adornments"
                    + lSep);
         msg.append("  -lib <path>            specifies a path to search for jars and classes"
                    + lSep);
         msg.append("  -logfile <file>        use given file for log" + lSep);
         msg.append("    -l     <file>                ''" + lSep);
         msg.append("  -logger <classname>    the class which is to perform logging" + lSep);
         msg.append("  -listener <classname>  add an instance of class as a project listener"
                    + lSep);
         msg.append("  -noinput               do not allow interactive input" + lSep);
         msg.append("  -buildfile <file>      use given buildfile" + lSep);
         msg.append("    -file    <file>              ''" + lSep);
         msg.append("    -f       <file>              ''" + lSep);
         msg.append("  -D<property>=<value>   use value for given property" + lSep);
         msg.append("  -keep-going, -k        execute all targets that do not depend" + lSep);
         msg.append("                         on failed target(s)" + lSep);
         msg.append("  -propertyfile <name>   load all properties from file with -D" + lSep);
         msg.append("                         properties taking precedence" + lSep);
         msg.append("  -inputhandler <class>  the class which will handle input requests" + lSep);
         msg.append("  -find <file>           (s)earch for buildfile towards the root of" + lSep);
         msg.append("    -s  <file>           the filesystem and use it" + lSep);
         msg.append("  -nice  number          A niceness value for the main thread:" + lSep
                    + "                         1 (lowest) to 10 (highest); 5 is the default"
                    + lSep);
         msg.append("  -nouserlib             Run ant without using the jar files from" + lSep
                    + "                         ${user.home}/.ant/lib" + lSep);
         msg.append("  -noclasspath           Run ant without using CLASSPATH" + lSep);
         msg.append("  -autoproxy             Java1.5+: use the OS proxy settings"
                 + lSep);
         msg.append("  -main <class>          override Ant's normal entry point");
         System.out.println(msg.toString());
     }
 
     /**
      * Prints the Ant version information to <code>System.out</code>.
      *
      * @exception BuildException if the version information is unavailable
      */
     private static void printVersion(int logLevel) throws BuildException {
         System.out.println(getAntVersion());
     }
 
     /**
      * Cache of the Ant version information when it has been loaded.
      */
     private static String antVersion = null;
 
     /**
      * Returns the Ant version information, if available. Once the information
      * has been loaded once, it's cached and returned from the cache on future
      * calls.
      *
      * @return the Ant version information as a String
      *         (always non-<code>null</code>)
      *
      * @exception BuildException if the version information is unavailable
      */
     public static synchronized String getAntVersion() throws BuildException {
         if (antVersion == null) {
             try {
                 Properties props = new Properties();
                 InputStream in =
                     Main.class.getResourceAsStream("/org/apache/tools/ant/version.txt");
                 props.load(in);
                 in.close();
 
                 StringBuffer msg = new StringBuffer();
                 msg.append("Apache Ant(TM) version ");
                 msg.append(props.getProperty("VERSION"));
                 msg.append(" compiled on ");
                 msg.append(props.getProperty("DATE"));
                 antVersion = msg.toString();
             } catch (IOException ioe) {
                 throw new BuildException("Could not load the version information:"
                                          + ioe.getMessage());
             } catch (NullPointerException npe) {
                 throw new BuildException("Could not load the version information.");
             }
         }
         return antVersion;
     }
 
      /**
       * Prints the description of a project (if there is one) to
       * <code>System.out</code>.
       *
       * @param project The project to display a description of.
       *                Must not be <code>null</code>.
       */
     private static void printDescription(Project project) {
        if (project.getDescription() != null) {
           project.log(project.getDescription());
        }
     }
 
     /**
      * Targets in imported files with a project name
      * and not overloaded by the main build file will
      * be in the target map twice. This method
      * removes the duplicate target.
      * @param targets the targets to filter.
      * @return the filtered targets.
      */
     private static Map removeDuplicateTargets(Map targets) {
         Map locationMap = new HashMap();
         for (Iterator i = targets.entrySet().iterator(); i.hasNext();) {
             Map.Entry entry = (Map.Entry) i.next();
             String name = (String) entry.getKey();
             Target target = (Target) entry.getValue();
             Target otherTarget =
                 (Target) locationMap.get(target.getLocation());
             // Place this entry in the location map if
             //  a) location is not in the map
             //  b) location is in map, but it's name is longer
             //     (an imported target will have a name. prefix)
             if (otherTarget == null
                 || otherTarget.getName().length() > name.length()) {
                 locationMap.put(
                     target.getLocation(), target); // Smallest name wins
             }
         }
         Map ret = new HashMap();
         for (Iterator i = locationMap.values().iterator(); i.hasNext();) {
             Target target = (Target) i.next();
             ret.put(target.getName(), target);
         }
         return ret;
     }
 
     /**
      * Prints a list of all targets in the specified project to
      * <code>System.out</code>, optionally including subtargets.
      *
      * @param project The project to display a description of.
      *                Must not be <code>null</code>.
      * @param printSubTargets Whether or not subtarget names should also be
      *                        printed.
      */
     private static void printTargets(Project project, boolean printSubTargets,
             boolean printDependencies) {
         // find the target with the longest name
         int maxLength = 0;
         Map ptargets = removeDuplicateTargets(project.getTargets());
         String targetName;
         String targetDescription;
         Target currentTarget;
         // split the targets in top-level and sub-targets depending
         // on the presence of a description
         Vector topNames = new Vector();
         Vector topDescriptions = new Vector();
         Vector/*<Enumeration<String>>*/ topDependencies = new Vector();
         Vector subNames = new Vector();
         Vector/*<Enumeration<String>>*/ subDependencies = new Vector();
 
         for (Iterator i = ptargets.values().iterator(); i.hasNext();) {
             currentTarget = (Target) i.next();
             targetName = currentTarget.getName();
             if (targetName.equals("")) {
                 continue;
             }
             targetDescription = currentTarget.getDescription();
             // maintain a sorted list of targets
             if (targetDescription == null) {
                 int pos = findTargetPosition(subNames, targetName);
                 subNames.insertElementAt(targetName, pos);
                 if (printDependencies) {
                     subDependencies.insertElementAt(currentTarget.getDependencies(), pos);
                 }
             } else {
                 int pos = findTargetPosition(topNames, targetName);
                 topNames.insertElementAt(targetName, pos);
                 topDescriptions.insertElementAt(targetDescription, pos);
                 if (targetName.length() > maxLength) {
                     maxLength = targetName.length();
                 }
                 if (printDependencies) {
                     topDependencies.insertElementAt(currentTarget.getDependencies(), pos);
                 }
             }
         }
 
         printTargets(project, topNames, topDescriptions, topDependencies,
                 "Main targets:", maxLength);
         //if there were no main targets, we list all subtargets
         //as it means nothing has a description
         if (topNames.size() == 0) {
             printSubTargets = true;
         }
         if (printSubTargets) {
             printTargets(project, subNames, null, subDependencies, "Other targets:", 0);
         }
 
         String defaultTarget = project.getDefaultTarget();
         if (defaultTarget != null && !"".equals(defaultTarget)) {
             // shouldn't need to check but...
             project.log("Default target: " + defaultTarget);
         }
     }
 
     /**
      * Searches for the correct place to insert a name into a list so as
      * to keep the list sorted alphabetically.
      *
      * @param names The current list of names. Must not be <code>null</code>.
      * @param name  The name to find a place for.
      *              Must not be <code>null</code>.
      *
      * @return the correct place in the list for the given name
      */
     private static int findTargetPosition(Vector names, String name) {
-        int res = names.size();
-        for (int i = 0; i < names.size() && res == names.size(); i++) {
+        final int size = names.size();
+        int res = size;
+        for (int i = 0; i < size && res == size; i++) {
             if (name.compareTo((String) names.elementAt(i)) < 0) {
                 res = i;
             }
         }
         return res;
     }
 
     /**
      * Writes a formatted list of target names to <code>System.out</code>
      * with an optional description.
      *
      *
      * @param project the project instance.
      * @param names The names to be printed.
      *              Must not be <code>null</code>.
      * @param descriptions The associated target descriptions.
      *                     May be <code>null</code>, in which case
      *                     no descriptions are displayed.
      *                     If non-<code>null</code>, this should have
      *                     as many elements as <code>names</code>.
      * @param topDependencies The list of dependencies for each target.
      *                        The dependencies are listed as a non null
      *                        enumeration of String.
      * @param heading The heading to display.
      *                Should not be <code>null</code>.
      * @param maxlen The maximum length of the names of the targets.
      *               If descriptions are given, they are padded to this
      *               position so they line up (so long as the names really
      *               <i>are</i> shorter than this).
      */
     private static void printTargets(Project project, Vector names,
                                      Vector descriptions, Vector dependencies,
                                      String heading,
                                      int maxlen) {
         // now, start printing the targets and their descriptions
         String lSep = System.getProperty("line.separator");
         // got a bit annoyed that I couldn't find a pad function
         String spaces = "    ";
         while (spaces.length() <= maxlen) {
             spaces += spaces;
         }
         StringBuffer msg = new StringBuffer();
         msg.append(heading + lSep + lSep);
-        for (int i = 0; i < names.size(); i++) {
+        final int size = names.size();
+        for (int i = 0; i < size; i++) {
             msg.append(" ");
             msg.append(names.elementAt(i));
             if (descriptions != null) {
                 msg.append(
                     spaces.substring(0, maxlen - ((String) names.elementAt(i)).length() + 2));
                 msg.append(descriptions.elementAt(i));
             }
             msg.append(lSep);
             if (!dependencies.isEmpty()) {
                 Enumeration deps = (Enumeration) dependencies.elementAt(i);
                 if (deps.hasMoreElements()) {
                     msg.append("   depends on: ");
                     while (deps.hasMoreElements()) {
                         msg.append(deps.nextElement());
                         if (deps.hasMoreElements()) {
                             msg.append(", ");
                         }
                     }
                     msg.append(lSep);                
                 }
             }
         }
         project.log(msg.toString(), Project.MSG_WARN);
     }
 }
diff --git a/src/main/org/apache/tools/ant/Target.java b/src/main/org/apache/tools/ant/Target.java
index 7fb1abf7d..38ca7ad8f 100644
--- a/src/main/org/apache/tools/ant/Target.java
+++ b/src/main/org/apache/tools/ant/Target.java
@@ -1,479 +1,480 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.List;
 import java.util.StringTokenizer;
 
 import org.apache.tools.ant.property.LocalProperties;
 
 /**
  * Class to implement a target object with required parameters.
  *
  * <p>If you are creating Targets programmatically, make sure you set
  * the Location to a useful value.  In particular all targets should
  * have different location values.</p>
  */
 public class Target implements TaskContainer {
 
     /** Name of this target. */
     private String name;
 
     /** The "if" condition to test on execution. */
     private String ifCondition = "";
 
     /** The "unless" condition to test on execution. */
     private String unlessCondition = "";
 
     /** List of targets this target is dependent on. */
     private List/*<String>*/ dependencies = null;
 
     /** Children of this target (tasks and data types). */
     private List children = new ArrayList();
 
     /** Since Ant 1.6.2 */
     private Location location = Location.UNKNOWN_LOCATION;
 
     /** Project this target belongs to. */
     private Project project;
 
     /** Description of this target, if any. */
     private String description = null;
 
     /** Default constructor. */
     public Target() {
         //empty
     }
 
     /**
      * Cloning constructor.
      * @param other the Target to clone.
      */
     public Target(Target other) {
         this.name = other.name;
         this.ifCondition = other.ifCondition;
         this.unlessCondition = other.unlessCondition;
         this.dependencies = other.dependencies;
         this.location = other.location;
         this.project = other.project;
         this.description = other.description;
         // The children are added to after this cloning
         this.children = other.children;
     }
 
     /**
      * Sets the project this target belongs to.
      *
      * @param project The project this target belongs to.
      *                Must not be <code>null</code>.
      */
     public void setProject(Project project) {
         this.project = project;
     }
 
     /**
      * Returns the project this target belongs to.
      *
      * @return The project this target belongs to, or <code>null</code> if
      *         the project has not been set yet.
      */
     public Project getProject() {
         return project;
     }
 
     /**
      * Sets the location of this target's definition.
      *
      * @param location   <code>Location</code>
      * @since 1.6.2
      */
     public void setLocation(Location location) {
         this.location = location;
     }
 
     /**
      * Get the location of this target's definition.
      *
      * @return <code>Location</code>
      * @since 1.6.2
      */
     public Location getLocation() {
         return location;
     }
 
     /**
      * Sets the list of targets this target is dependent on.
      * The targets themselves are not resolved at this time.
      *
      * @param depS A comma-separated list of targets this target
      *             depends on. Must not be <code>null</code>.
      */
     public void setDepends(String depS) {
         for (Iterator iter = parseDepends(depS, getName(), "depends").iterator();
              iter.hasNext(); ) {
             addDependency((String) iter.next());
         }
     }
 
     public static List/*<String>*/ parseDepends(String depends,
                                                 String targetName,
                                                 String attributeName) {
         ArrayList list = new ArrayList();
         if (depends.length() > 0) {
             StringTokenizer tok =
                 new StringTokenizer(depends, ",", true);
             while (tok.hasMoreTokens()) {
                 String token = tok.nextToken().trim();
 
                 // Make sure the dependency is not empty string
                 if ("".equals(token) || ",".equals(token)) {
                     throw new BuildException("Syntax Error: "
                                              + attributeName
                                              + " attribute of target \""
                                              + targetName
                                              + "\" contains an empty string.");
                 }
 
                 list.add(token);
 
                 // Make sure that depends attribute does not
                 // end in a ,
                 if (tok.hasMoreTokens()) {
                     token = tok.nextToken();
                     if (!tok.hasMoreTokens() || !",".equals(token)) {
                         throw new BuildException("Syntax Error: "
                                                  + attributeName
                                                  + " attribute for target \""
                                                  + targetName
                                                  + "\" ends with a \",\" "
                                                  + "character");
                     }
                 }
             }
         }
         return list;
     }
 
     /**
      * Sets the name of this target.
      *
      * @param name The name of this target. Should not be <code>null</code>.
      */
     public void setName(String name) {
         this.name = name;
     }
 
     /**
      * Returns the name of this target.
      *
      * @return the name of this target, or <code>null</code> if the
      *         name has not been set yet.
      */
     public String getName() {
         return name;
     }
 
     /**
      * Adds a task to this target.
      *
      * @param task The task to be added. Must not be <code>null</code>.
      */
     public void addTask(Task task) {
         children.add(task);
     }
 
     /**
      * Adds the wrapper for a data type element to this target.
      *
      * @param r The wrapper for the data type element to be added.
      *          Must not be <code>null</code>.
      */
     public void addDataType(RuntimeConfigurable r) {
         children.add(r);
     }
 
     /**
      * Returns the current set of tasks to be executed by this target.
      *
      * @return an array of the tasks currently within this target
      */
     public Task[] getTasks() {
         List tasks = new ArrayList(children.size());
         Iterator it = children.iterator();
         while (it.hasNext()) {
             Object o = it.next();
             if (o instanceof Task) {
                 tasks.add(o);
             }
         }
         return (Task[]) tasks.toArray(new Task[tasks.size()]);
     }
 
     /**
      * Adds a dependency to this target.
      *
      * @param dependency The name of a target this target is dependent on.
      *                   Must not be <code>null</code>.
      */
     public void addDependency(String dependency) {
         if (dependencies == null) {
             dependencies = new ArrayList(2);
         }
         dependencies.add(dependency);
     }
 
     /**
      * Returns an enumeration of the dependencies of this target.
      *
      * @return an enumeration of the dependencies of this target (enumeration of String)
      */
     public Enumeration getDependencies() {
         return Collections
                 .enumeration(dependencies == null ? Collections.EMPTY_LIST : dependencies);
     }
 
     /**
      * Does this target depend on the named target?
      * @param other the other named target.
      * @return true if the target does depend on the named target
      * @since Ant 1.6
      */
     public boolean dependsOn(String other) {
         Project p = getProject();
         Hashtable t = p == null ? null : p.getTargets();
         return p != null && p.topoSort(getName(), t, false).contains(t.get(other));
     }
 
     /**
      * Sets the "if" condition to test on execution. This is the
      * name of a property to test for existence - if the property
      * is not set, the task will not execute. The property goes
      * through property substitution once before testing, so if
      * property <code>foo</code> has value <code>bar</code>, setting
      * the "if" condition to <code>${foo}_x</code> will mean that the
      * task will only execute if property <code>bar_x</code> is set.
      *
      * @param property The property condition to test on execution.
      *                 May be <code>null</code>, in which case
      *                 no "if" test is performed.
      */
     public void setIf(String property) {
         ifCondition = property == null ? "" : property;
     }
 
     /**
      * Returns the "if" property condition of this target.
      *
      * @return the "if" property condition or <code>null</code> if no
      *         "if" condition had been defined.
      * @since 1.6.2
      */
     public String getIf() {
         return "".equals(ifCondition) ? null : ifCondition;
     }
 
     /**
      * Sets the "unless" condition to test on execution. This is the
      * name of a property to test for existence - if the property
      * is set, the task will not execute. The property goes
      * through property substitution once before testing, so if
      * property <code>foo</code> has value <code>bar</code>, setting
      * the "unless" condition to <code>${foo}_x</code> will mean that the
      * task will only execute if property <code>bar_x</code> isn't set.
      *
      * @param property The property condition to test on execution.
      *                 May be <code>null</code>, in which case
      *                 no "unless" test is performed.
      */
     public void setUnless(String property) {
         unlessCondition = property == null ? "" : property;
     }
 
     /**
      * Returns the "unless" property condition of this target.
      *
      * @return the "unless" property condition or <code>null</code>
      *         if no "unless" condition had been defined.
      * @since 1.6.2
      */
     public String getUnless() {
         return "".equals(unlessCondition) ? null : unlessCondition;
     }
 
     /**
      * Sets the description of this target.
      *
      * @param description The description for this target.
      *                    May be <code>null</code>, indicating that no
      *                    description is available.
      */
     public void setDescription(String description) {
         this.description = description;
     }
 
     /**
      * Returns the description of this target.
      *
      * @return the description of this target, or <code>null</code> if no
      *         description is available.
      */
     public String getDescription() {
         return description;
     }
 
     /**
      * Returns the name of this target.
      *
      * @return the name of this target, or <code>null</code> if the
      *         name has not been set yet.
      */
     public String toString() {
         return name;
     }
 
     /**
      * Executes the target if the "if" and "unless" conditions are
      * satisfied. Dependency checking should be done before calling this
      * method, as it does no checking of its own. If either the "if"
      * or "unless" test prevents this target from being executed, a verbose
      * message is logged giving the reason. It is recommended that clients
      * of this class call performTasks rather than this method so that
      * appropriate build events are fired.
      *
      * @exception BuildException if any of the tasks fail or if a data type
      *                           configuration fails.
      *
      * @see #performTasks()
      * @see #setIf(String)
      * @see #setUnless(String)
      */
     public void execute() throws BuildException {
         if (!testIfAllows()) {
             project.log(this, "Skipped because property '" + project.replaceProperties(ifCondition)
                     + "' not set.", Project.MSG_VERBOSE);
             return;
         }
         if (!testUnlessAllows()) {
             project.log(this, "Skipped because property '"
                     + project.replaceProperties(unlessCondition) + "' set.", Project.MSG_VERBOSE);
             return;
         }
         LocalProperties localProperties = LocalProperties.get(getProject());
         localProperties.enterScope();
         try {
             // use index-based approach to avoid ConcurrentModificationExceptions;
             // also account for growing target children
-            for (int i = 0; i < children.size(); i++) {
+            final int size = children.size();
+            for (int i = 0; i < size; i++) {
                 Object o = children.get(i);
                 if (o instanceof Task) {
                     Task task = (Task) o;
                     task.perform();
                 } else {
                     ((RuntimeConfigurable) o).maybeConfigure(project);
                 }
             }
         } finally {
             localProperties.exitScope();
         }
     }
 
     /**
      * Performs the tasks within this target (if the conditions are met),
      * firing target started/target finished messages around a call to
      * execute.
      *
      * @see #execute()
      */
     public final void performTasks() {
         RuntimeException thrown = null;
         project.fireTargetStarted(this);
         try {
             execute();
         } catch (RuntimeException exc) {
             thrown = exc;
             throw exc;
         } finally {
             project.fireTargetFinished(this, thrown);
         }
     }
 
     /**
      * Replaces all occurrences of the given task in the list
      * of children with the replacement data type wrapper.
      *
      * @param el The task to replace.
      *           Must not be <code>null</code>.
      * @param o  The data type wrapper to replace <code>el</code> with.
      */
     void replaceChild(Task el, RuntimeConfigurable o) {
         int index;
         while ((index = children.indexOf(el)) >= 0) {
             children.set(index, o);
         }
     }
 
     /**
      * Replaces all occurrences of the given task in the list
      * of children with the replacement task.
      *
      * @param el The task to replace.
      *           Must not be <code>null</code>.
      * @param o  The task to replace <code>el</code> with.
      */
     void replaceChild(Task el, Task o) {
         int index;
         while ((index = children.indexOf(el)) >= 0) {
             children.set(index, o);
         }
     }
 
     /**
      * Tests whether or not the "if" condition allows the execution of this target.
      *
      * @return whether or not the "if" condition is satisfied. If no
      *         condition (or an empty condition) has been set,
      *         <code>true</code> is returned.
      *
      * @see #setIf(String)
      */
     private boolean testIfAllows() {
         PropertyHelper propertyHelper = PropertyHelper.getPropertyHelper(getProject());
         Object o = propertyHelper.parseProperties(ifCondition);
         return propertyHelper.testIfCondition(o);
     }
 
     /**
      * Tests whether or not the "unless" condition allows the execution of this target.
      *
      * @return whether or not the "unless" condition is satisfied. If no
      *         condition (or an empty condition) has been set,
      *         <code>true</code> is returned.
      *
      * @see #setUnless(String)
      */
     private boolean testUnlessAllows() {
         PropertyHelper propertyHelper = PropertyHelper.getPropertyHelper(getProject());
         Object o = propertyHelper.parseProperties(unlessCondition);
         return propertyHelper.testUnlessCondition(o);
     }
 }
diff --git a/src/main/org/apache/tools/ant/UnknownElement.java b/src/main/org/apache/tools/ant/UnknownElement.java
index 5eb781105..bd525368c 100644
--- a/src/main/org/apache/tools/ant/UnknownElement.java
+++ b/src/main/org/apache/tools/ant/UnknownElement.java
@@ -1,687 +1,688 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant;
 
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.io.IOException;
 import org.apache.tools.ant.taskdefs.PreSetDef;
 
 /**
  * Wrapper class that holds all the information necessary to create a task
  * or data type that did not exist when Ant started, or one which
  * has had its definition updated to use a different implementation class.
  *
  */
 public class UnknownElement extends Task {
 
     /**
      * Holds the name of the task/type or nested child element of a
      * task/type that hasn't been defined at parser time or has
      * been redefined since original creation.
      */
     private final String elementName;
 
     /**
      * Holds the namespace of the element.
      */
     private String namespace = "";
 
     /**
      * Holds the namespace qname of the element.
      */
     private String qname;
 
     /**
      * The real object after it has been loaded.
      */
     private Object realThing;
 
     /**
      * List of child elements (UnknownElements).
      */
     private List/*<UnknownElement>*/ children = null;
 
     /** Specifies if a predefined definition has been done */
     private boolean presetDefed = false;
 
     /**
      * Creates an UnknownElement for the given element name.
      *
      * @param elementName The name of the unknown element.
      *                    Must not be <code>null</code>.
      */
     public UnknownElement(String elementName) {
         this.elementName = elementName;
     }
 
     /**
      * @return the list of nested UnknownElements for this UnknownElement.
      */
     public List getChildren() {
         return children;
     }
 
     /**
      * Returns the name of the XML element which generated this unknown
      * element.
      *
      * @return the name of the XML element which generated this unknown
      *         element.
      */
     public String getTag() {
         return elementName;
     }
 
     /**
      * Return the namespace of the XML element associated with this component.
      *
      * @return Namespace URI used in the xmlns declaration.
      */
     public String getNamespace() {
         return namespace;
     }
 
     /**
      * Set the namespace of the XML element associated with this component.
      * This method is typically called by the XML processor.
      * If the namespace is "ant:current", the component helper
      * is used to get the current antlib uri.
      *
      * @param namespace URI used in the xmlns declaration.
      */
     public void setNamespace(String namespace) {
         if (namespace.equals(ProjectHelper.ANT_CURRENT_URI)) {
             ComponentHelper helper = ComponentHelper.getComponentHelper(
                 getProject());
             namespace = helper.getCurrentAntlibUri();
         }
         this.namespace = namespace == null ? "" : namespace;
     }
 
     /**
      * Return the qname of the XML element associated with this component.
      *
      * @return namespace Qname used in the element declaration.
      */
     public String getQName() {
         return qname;
     }
 
     /**
      * Set the namespace qname of the XML element.
      * This method is typically called by the XML processor.
      *
      * @param qname the qualified name of the element
      */
     public void setQName(String qname) {
         this.qname = qname;
     }
 
 
     /**
      * Get the RuntimeConfigurable instance for this UnknownElement, containing
      * the configuration information.
      *
      * @return the configuration info.
      */
     public RuntimeConfigurable getWrapper() {
         return super.getWrapper();
     }
 
     /**
      * Creates the real object instance and child elements, then configures
      * the attributes and text of the real object. This unknown element
      * is then replaced with the real object in the containing target's list
      * of children.
      *
      * @exception BuildException if the configuration fails
      */
     public void maybeConfigure() throws BuildException {
         if (realThing != null) {
             return;
         }
         configure(makeObject(this, getWrapper()));
     }
 
     /**
      * Configure the given object from this UnknownElement
      *
      * @param realObject the real object this UnknownElement is representing.
      *
      */
     public void configure(Object realObject) {
         realThing = realObject;
 
         getWrapper().setProxy(realThing);
         Task task = null;
         if (realThing instanceof Task) {
             task = (Task) realThing;
 
             task.setRuntimeConfigurableWrapper(getWrapper());
 
             // For Script example that modifies id'ed tasks in other
             // targets to work. *very* Ugly
             // The reference is replaced by RuntimeConfigurable
             if (getWrapper().getId() != null) {
                 this.getOwningTarget().replaceChild(this, (Task) realThing);
             }
        }
 
 
         // configure attributes of the object and it's children. If it is
         // a task container, defer the configuration till the task container
         // attempts to use the task
 
         if (task != null) {
             task.maybeConfigure();
         } else {
             getWrapper().maybeConfigure(getProject());
         }
 
         handleChildren(realThing, getWrapper());
     }
 
     /**
      * Handles output sent to System.out by this task or its real task.
      *
      * @param output The output to log. Should not be <code>null</code>.
      */
     protected void handleOutput(String output) {
         if (realThing instanceof Task) {
             ((Task) realThing).handleOutput(output);
         } else {
             super.handleOutput(output);
         }
     }
 
     /**
      * Delegate to realThing if present and if it as task.
      * @see Task#handleInput(byte[], int, int)
      * @param buffer the buffer into which data is to be read.
      * @param offset the offset into the buffer at which data is stored.
      * @param length the amount of data to read.
      *
      * @return the number of bytes read.
      *
      * @exception IOException if the data cannot be read.
      * @since Ant 1.6
      */
     protected int handleInput(byte[] buffer, int offset, int length)
         throws IOException {
         if (realThing instanceof Task) {
             return ((Task) realThing).handleInput(buffer, offset, length);
         } else {
             return super.handleInput(buffer, offset, length);
         }
 
     }
 
     /**
      * Handles output sent to System.out by this task or its real task.
      *
      * @param output The output to log. Should not be <code>null</code>.
      */
     protected void handleFlush(String output) {
         if (realThing instanceof Task) {
             ((Task) realThing).handleFlush(output);
         } else {
             super.handleFlush(output);
         }
     }
 
     /**
      * Handles error output sent to System.err by this task or its real task.
      *
      * @param output The error output to log. Should not be <code>null</code>.
      */
     protected void handleErrorOutput(String output) {
         if (realThing instanceof Task) {
             ((Task) realThing).handleErrorOutput(output);
         } else {
             super.handleErrorOutput(output);
         }
     }
 
     /**
      * Handles error output sent to System.err by this task or its real task.
      *
      * @param output The error output to log. Should not be <code>null</code>.
      */
     protected void handleErrorFlush(String output) {
         if (realThing instanceof Task) {
             ((Task) realThing).handleErrorFlush(output);
         } else {
             super.handleErrorFlush(output);
         }
     }
 
     /**
      * Executes the real object if it's a task. If it's not a task
      * (e.g. a data type) then this method does nothing.
      */
     public void execute() {
         if (realThing == null) {
             // plain impossible to get here, maybeConfigure should
             // have thrown an exception.
             throw new BuildException("Could not create task of type: "
                                      + elementName, getLocation());
         }
         try {
             if (realThing instanceof Task) {
                 ((Task) realThing).execute();
             }
         } finally {
             // Finished executing the task
             // null it (unless it has an ID) to allow
             // GC do its job
             // If this UE is used again, a new "realthing" will be made
             if (getWrapper().getId() == null) {
                 realThing = null;
                 getWrapper().setProxy(null);
             }
         }
     }
 
     /**
      * Adds a child element to this element.
      *
      * @param child The child element to add. Must not be <code>null</code>.
      */
     public void addChild(UnknownElement child) {
         if (children == null) {
             children = new ArrayList();
         }
         children.add(child);
     }
 
     /**
      * Creates child elements, creates children of the children
      * (recursively), and sets attributes of the child elements.
      *
      * @param parent The configured object for the parent.
      *               Must not be <code>null</code>.
      *
      * @param parentWrapper The wrapper containing child wrappers
      *                      to be configured. Must not be <code>null</code>
      *                      if there are any children.
      *
      * @exception BuildException if the children cannot be configured.
      */
     protected void handleChildren(
         Object parent,
         RuntimeConfigurable parentWrapper)
         throws BuildException {
         if (parent instanceof TypeAdapter) {
             parent = ((TypeAdapter) parent).getProxy();
         }
 
         String parentUri = getNamespace();
         Class parentClass = parent.getClass();
         IntrospectionHelper ih = IntrospectionHelper.getHelper(getProject(), parentClass);
 
 
         if (children != null) {
             Iterator it = children.iterator();
             for (int i = 0; it.hasNext(); i++) {
                 RuntimeConfigurable childWrapper = parentWrapper.getChild(i);
                 UnknownElement child = (UnknownElement) it.next();
                 try {
                     if (!handleChild(
                             parentUri, ih, parent, child, childWrapper)) {
                         if (!(parent instanceof TaskContainer)) {
                             ih.throwNotSupported(getProject(), parent,
                                                  child.getTag());
                         } else {
                             // a task container - anything could happen - just add the
                             // child to the container
                             TaskContainer container = (TaskContainer) parent;
                             container.addTask(child);
                         }
                     }
                 } catch (UnsupportedElementException ex) {
                     throw new BuildException(
                         parentWrapper.getElementTag()
                         + " doesn't support the nested \"" + ex.getElement()
                         + "\" element.", ex);
                 }
             }
         }
     }
 
     /**
      * @return the component name - uses ProjectHelper#genComponentName()
      */
     protected String getComponentName() {
         return ProjectHelper.genComponentName(getNamespace(), getTag());
     }
 
     /**
      * This is used then the realobject of the UE is a PreSetDefinition.
      * This is also used when a presetdef is used on a presetdef
      * The attributes, elements and text are applied to this
      * UE.
      *
      * @param u an UnknownElement containing the attributes, elements and text
      */
     public void applyPreSet(UnknownElement u) {
         if (presetDefed) {
             return;
         }
         // Do the runtime
         getWrapper().applyPreSet(u.getWrapper());
         if (u.children != null) {
             List newChildren = new ArrayList();
             newChildren.addAll(u.children);
             if (children != null) {
                 newChildren.addAll(children);
             }
             children = newChildren;
         }
         presetDefed = true;
     }
 
     /**
      * Creates a named task or data type. If the real object is a task,
      * it is configured up to the init() stage.
      *
      * @param ue The unknown element to create the real object for.
      *           Must not be <code>null</code>.
      * @param w  Ignored in this implementation.
      *
      * @return the task or data type represented by the given unknown element.
      */
     protected Object makeObject(UnknownElement ue, RuntimeConfigurable w) {
         ComponentHelper helper = ComponentHelper.getComponentHelper(
             getProject());
         String name = ue.getComponentName();
         Object o = helper.createComponent(ue, ue.getNamespace(), name);
         if (o == null) {
             throw getNotFoundException("task or type", name);
         }
         if (o instanceof PreSetDef.PreSetDefinition) {
             PreSetDef.PreSetDefinition def = (PreSetDef.PreSetDefinition) o;
             o = def.createObject(ue.getProject());
             if (o == null) {
                 throw getNotFoundException(
                     "preset " + name,
                     def.getPreSets().getComponentName());
             }
             ue.applyPreSet(def.getPreSets());
             if (o instanceof Task) {
                 Task task = (Task) o;
                 task.setTaskType(ue.getTaskType());
                 task.setTaskName(ue.getTaskName());
                 task.init();
             }
         }
         if (o instanceof UnknownElement) {
             o = ((UnknownElement) o).makeObject((UnknownElement) o, w);
         }
         if (o instanceof Task) {
             ((Task) o).setOwningTarget(getOwningTarget());
         }
         if (o instanceof ProjectComponent) {
             ((ProjectComponent) o).setLocation(getLocation());
         }
         return o;
     }
 
     /**
      * Creates a named task and configures it up to the init() stage.
      *
      * @param ue The UnknownElement to create the real task for.
      *           Must not be <code>null</code>.
      * @param w  Ignored.
      *
      * @return the task specified by the given unknown element, or
      *         <code>null</code> if the task name is not recognised.
      */
     protected Task makeTask(UnknownElement ue, RuntimeConfigurable w) {
         Task task = getProject().createTask(ue.getTag());
 
         if (task != null) {
             task.setLocation(getLocation());
             // UnknownElement always has an associated target
             task.setOwningTarget(getOwningTarget());
             task.init();
         }
         return task;
     }
 
     /**
      * Returns a very verbose exception for when a task/data type cannot
      * be found.
      *
      * @param what The kind of thing being created. For example, when
      *             a task name could not be found, this would be
      *             <code>"task"</code>. Should not be <code>null</code>.
      * @param name The name of the element which could not be found.
      *             Should not be <code>null</code>.
      *
      * @return a detailed description of what might have caused the problem.
      */
     protected BuildException getNotFoundException(String what,
                                                   String name) {
         ComponentHelper helper = ComponentHelper.getComponentHelper(getProject());
         String msg = helper.diagnoseCreationFailure(name, what);
         return new BuildException(msg, getLocation());
     }
 
     /**
      * Returns the name to use in logging messages.
      *
      * @return the name to use in logging messages.
      */
     public String getTaskName() {
         //return elementName;
         return realThing == null
             || !(realThing instanceof Task) ? super.getTaskName()
                                             : ((Task) realThing).getTaskName();
     }
 
     /**
      * Returns the task instance after it has been created and if it is a task.
      *
      * @return a task instance or <code>null</code> if the real object is not
      *         a task.
      */
     public Task getTask() {
         if (realThing instanceof Task) {
             return (Task) realThing;
         }
         return null;
     }
 
     /**
      * Return the configured object
      *
      * @return the real thing whatever it is
      *
      * @since ant 1.6
      */
     public Object getRealThing() {
         return realThing;
     }
 
     /**
      * Set the configured object
      * @param realThing the configured object
      * @since ant 1.7
      */
     public void setRealThing(Object realThing) {
         this.realThing = realThing;
     }
 
     /**
      * Try to create a nested element of <code>parent</code> for the
      * given tag.
      *
      * @return whether the creation has been successful
      */
     private boolean handleChild(
         String parentUri,
         IntrospectionHelper ih,
         Object parent, UnknownElement child,
         RuntimeConfigurable childWrapper) {
         String childName = ProjectHelper.genComponentName(
             child.getNamespace(), child.getTag());
         if (ih.supportsNestedElement(parentUri, childName, getProject(),
                                      parent)) {
             IntrospectionHelper.Creator creator = null;
             try {
                 creator = ih.getElementCreator(getProject(), parentUri,
                                                parent, childName, child);
             } catch (UnsupportedElementException use) {
                 if (!ih.isDynamic()) {
                     throw use;
                 }
                 // can't trust supportsNestedElement for dynamic elements
                 return false;
             }
             creator.setPolyType(childWrapper.getPolyType());
             Object realChild = creator.create();
             if (realChild instanceof PreSetDef.PreSetDefinition) {
                 PreSetDef.PreSetDefinition def =
                     (PreSetDef.PreSetDefinition) realChild;
                 realChild = creator.getRealObject();
                 child.applyPreSet(def.getPreSets());
             }
             childWrapper.setCreator(creator);
             childWrapper.setProxy(realChild);
             if (realChild instanceof Task) {
                 Task childTask = (Task) realChild;
                 childTask.setRuntimeConfigurableWrapper(childWrapper);
                 childTask.setTaskName(childName);
                 childTask.setTaskType(childName);
             }
             if (realChild instanceof ProjectComponent) {
                 ((ProjectComponent) realChild).setLocation(child.getLocation());
             }
             childWrapper.maybeConfigure(getProject());
             child.handleChildren(realChild, childWrapper);
             creator.store();
             return true;
         }
         return false;
     }
 
     /**
      * like contents equals, but ignores project
      * @param obj the object to check against
      * @return true if this unknownelement has the same contents the other
      */
     public boolean similar(Object obj) {
         if (obj == null) {
             return false;
         }
         if (!getClass().getName().equals(obj.getClass().getName())) {
             return false;
         }
         UnknownElement other = (UnknownElement) obj;
         // Are the names the same ?
         if (!equalsString(elementName, other.elementName)) {
             return false;
         }
         if (!namespace.equals(other.namespace)) {
             return false;
         }
         if (!qname.equals(other.qname)) {
             return false;
         }
         // Are attributes the same ?
         if (!getWrapper().getAttributeMap().equals(
                 other.getWrapper().getAttributeMap())) {
             return false;
         }
         // Is the text the same?
         //   Need to use equals on the string and not
         //   on the stringbuffer as equals on the string buffer
         //   does not compare the contents.
         if (!getWrapper().getText().toString().equals(
                 other.getWrapper().getText().toString())) {
             return false;
         }
         // Are the sub elements the same ?
-        if (children == null || children.size() == 0) {
+        final int childrenSize = children == null ? 0 : children.size();
+        if (childrenSize == 0) {
             return other.children == null || other.children.size() == 0;
         }
         if (other.children == null) {
             return false;
         }
-        if (children.size() != other.children.size()) {
+        if (childrenSize != other.children.size()) {
             return false;
         }
-        for (int i = 0; i < children.size(); ++i) {
+        for (int i = 0; i < childrenSize; ++i) {
             UnknownElement child = (UnknownElement) children.get(i);
             if (!child.similar(other.children.get(i))) {
                 return false;
             }
         }
         return true;
     }
 
     private static boolean equalsString(String a, String b) {
         return (a == null) ? (b == null) : a.equals(b);
     }
 
     /**
      * Make a copy of the unknown element and set it in the new project.
      * @param newProject the project to create the UE in.
      * @return the copied UE.
      */
     public UnknownElement copy(Project newProject) {
         UnknownElement ret = new UnknownElement(getTag());
         ret.setNamespace(getNamespace());
         ret.setProject(newProject);
         ret.setQName(getQName());
         ret.setTaskType(getTaskType());
         ret.setTaskName(getTaskName());
         ret.setLocation(getLocation());
         if (getOwningTarget() == null) {
             Target t = new Target();
             t.setProject(getProject());
             ret.setOwningTarget(t);
         } else {
             ret.setOwningTarget(getOwningTarget());
         }
         RuntimeConfigurable copyRC = new RuntimeConfigurable(
             ret, getTaskName());
         copyRC.setPolyType(getWrapper().getPolyType());
         Map m = getWrapper().getAttributeMap();
         for (Iterator i = m.entrySet().iterator(); i.hasNext();) {
             Map.Entry entry = (Map.Entry) i.next();
             copyRC.setAttribute(
                 (String) entry.getKey(), (String) entry.getValue());
         }
         copyRC.addText(getWrapper().getText().toString());
 
         for (Enumeration e = getWrapper().getChildren(); e.hasMoreElements();) {
             RuntimeConfigurable r = (RuntimeConfigurable) e.nextElement();
             UnknownElement ueChild = (UnknownElement) r.getProxy();
             UnknownElement copyChild = ueChild.copy(newProject);
             copyRC.addChild(copyChild.getWrapper());
             ret.addChild(copyChild);
         }
         return ret;
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/AbstractCvsTask.java b/src/main/org/apache/tools/ant/taskdefs/AbstractCvsTask.java
index 518a03560..dd4025dd8 100644
--- a/src/main/org/apache/tools/ant/taskdefs/AbstractCvsTask.java
+++ b/src/main/org/apache/tools/ant/taskdefs/AbstractCvsTask.java
@@ -1,871 +1,872 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.types.Environment;
 import org.apache.tools.ant.util.StringUtils;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * original Cvs.java 1.20
  *
  *  NOTE: This implementation has been moved here from Cvs.java with
  *  the addition of some accessors for extensibility.  Another task
  *  can extend this with some customized output processing.
  *
  * @since Ant 1.5
  */
 public abstract class AbstractCvsTask extends Task {
     /**
      * Default compression level to use, if compression is enabled via
      * setCompression( true ).
      */
     public static final int DEFAULT_COMPRESSION_LEVEL = 3;
     private static final int MAXIMUM_COMRESSION_LEVEL = 9;
 
     private Commandline cmd = new Commandline();
 
     private ArrayList modules = new ArrayList();
 
     /** list of Commandline children */
     private Vector vecCommandlines = new Vector();
 
     /**
      * the CVSROOT variable.
      */
     private String cvsRoot;
 
     /**
      * the CVS_RSH variable.
      */
     private String cvsRsh;
 
     /**
      * the package/module to check out.
      */
     private String cvsPackage;
     /**
      * the tag
      */
     private String tag;
     /**
      * the default command.
      */
     private static final String DEFAULT_COMMAND = "checkout";
     /**
      * the CVS command to execute.
      */
     private String command = null;
 
     /**
      * suppress information messages.
      */
     private boolean quiet = false;
 
     /**
      * suppress all messages.
      */
     private boolean reallyquiet = false;
 
     /**
      * compression level to use.
      */
     private int compression = 0;
 
     /**
      * report only, don't change any files.
      */
     private boolean noexec = false;
 
     /**
      * CVS port
      */
     private int port = 0;
 
     /**
      * CVS password file
      */
     private File passFile = null;
 
     /**
      * the directory where the checked out files should be placed.
      */
     private File dest;
 
     /** whether or not to append stdout/stderr to existing files */
     private boolean append = false;
 
     /**
      * the file to direct standard output from the command.
      */
     private File output;
 
     /**
      * the file to direct standard error from the command.
      */
     private File error;
 
     /**
      * If true it will stop the build if cvs exits with error.
      * Default is false. (Iulian)
      */
     private boolean failOnError = false;
 
     /**
      * Create accessors for the following, to allow different handling of
      * the output.
      */
     private ExecuteStreamHandler executeStreamHandler;
     private OutputStream outputStream;
     private OutputStream errorStream;
 
     /** empty no-arg constructor*/
     public AbstractCvsTask() {
         super();
     }
 
     /**
      * sets the handler
      * @param handler a handler able of processing the output and error streams from the cvs exe
      */
     public void setExecuteStreamHandler(ExecuteStreamHandler handler) {
         this.executeStreamHandler = handler;
     }
 
     /**
      * find the handler and instantiate it if it does not exist yet
      * @return handler for output and error streams
      */
     protected ExecuteStreamHandler getExecuteStreamHandler() {
 
         if (this.executeStreamHandler == null) {
             setExecuteStreamHandler(new PumpStreamHandler(getOutputStream(),
                                                           getErrorStream()));
         }
 
         return this.executeStreamHandler;
     }
 
     /**
      * sets a stream to which the output from the cvs executable should be sent
      * @param outputStream stream to which the stdout from cvs should go
      */
     protected void setOutputStream(OutputStream outputStream) {
 
         this.outputStream = outputStream;
     }
 
     /**
      * access the stream to which the stdout from cvs should go
      * if this stream has already been set, it will be returned
      * if the stream has not yet been set, if the attribute output
      * has been set, the output stream will go to the output file
      * otherwise the output will go to ant's logging system
      * @return output stream to which cvs' stdout should go to
      */
     protected OutputStream getOutputStream() {
 
         if (this.outputStream == null) {
 
             if (output != null) {
                 try {
                     setOutputStream(new PrintStream(
                                         new BufferedOutputStream(
                                             new FileOutputStream(output
                                                                  .getPath(),
                                                                  append))));
                 } catch (IOException e) {
                     throw new BuildException(e, getLocation());
                 }
             } else {
                 setOutputStream(new LogOutputStream(this, Project.MSG_INFO));
             }
         }
 
         return this.outputStream;
     }
 
     /**
      * sets a stream to which the stderr from the cvs exe should go
      * @param errorStream an output stream willing to process stderr
      */
     protected void setErrorStream(OutputStream errorStream) {
 
         this.errorStream = errorStream;
     }
 
     /**
      * access the stream to which the stderr from cvs should go
      * if this stream has already been set, it will be returned
      * if the stream has not yet been set, if the attribute error
      * has been set, the output stream will go to the file denoted by the error attribute
      * otherwise the stderr output will go to ant's logging system
      * @return output stream to which cvs' stderr should go to
      */
     protected OutputStream getErrorStream() {
 
         if (this.errorStream == null) {
 
             if (error != null) {
 
                 try {
                     setErrorStream(new PrintStream(
                                        new BufferedOutputStream(
                                            new FileOutputStream(error.getPath(),
                                                                 append))));
                 } catch (IOException e) {
                     throw new BuildException(e, getLocation());
                 }
             } else {
                 setErrorStream(new LogOutputStream(this, Project.MSG_WARN));
             }
         }
 
         return this.errorStream;
     }
 
     /**
      * Sets up the environment for toExecute and then runs it.
      * @param toExecute the command line to execute
      * @throws BuildException if failonError is set to true and the cvs command fails
      */
     protected void runCommand(Commandline toExecute) throws BuildException {
         // XXX: we should use JCVS (www.ice.com/JCVS) instead of
         // command line execution so that we don't rely on having
         // native CVS stuff around (SM)
 
         // We can't do it ourselves as jCVS is GPLed, a third party task
         // outside of Apache repositories would be possible though (SB).
 
         Environment env = new Environment();
 
         if (port > 0) {
             Environment.Variable var = new Environment.Variable();
             var.setKey("CVS_CLIENT_PORT");
             var.setValue(String.valueOf(port));
             env.addVariable(var);
 
             // non-standard environment variable used by CVSNT, WinCVS
             // and others
             var = new Environment.Variable();
             var.setKey("CVS_PSERVER_PORT");
             var.setValue(String.valueOf(port));
             env.addVariable(var);
         }
 
         /**
          * Need a better cross platform integration with <cvspass>, so
          * use the same filename.
          */
         if (passFile == null) {
 
             File defaultPassFile = new File(
                 System.getProperty("cygwin.user.home",
                     System.getProperty("user.home"))
                 + File.separatorChar + ".cvspass");
 
             if (defaultPassFile.exists()) {
                 this.setPassfile(defaultPassFile);
             }
         }
 
         if (passFile != null) {
             if (passFile.isFile() && passFile.canRead()) {
                 Environment.Variable var = new Environment.Variable();
                 var.setKey("CVS_PASSFILE");
                 var.setValue(String.valueOf(passFile));
                 env.addVariable(var);
                 log("Using cvs passfile: " + String.valueOf(passFile),
                     Project.MSG_VERBOSE);
             } else if (!passFile.canRead()) {
                 log("cvs passfile: " + String.valueOf(passFile)
                     + " ignored as it is not readable",
                     Project.MSG_WARN);
             } else {
                 log("cvs passfile: " + String.valueOf(passFile)
                     + " ignored as it is not a file",
                     Project.MSG_WARN);
             }
         }
 
         if (cvsRsh != null) {
             Environment.Variable var = new Environment.Variable();
             var.setKey("CVS_RSH");
             var.setValue(String.valueOf(cvsRsh));
             env.addVariable(var);
         }
 
         //
         // Just call the getExecuteStreamHandler() and let it handle
         //     the semantics of instantiation or retrieval.
         //
         Execute exe = new Execute(getExecuteStreamHandler(), null);
 
         exe.setAntRun(getProject());
         if (dest == null) {
             dest = getProject().getBaseDir();
         }
 
         if (!dest.exists()) {
             dest.mkdirs();
         }
 
         exe.setWorkingDirectory(dest);
         exe.setCommandline(toExecute.getCommandline());
         exe.setEnvironment(env.getVariables());
 
         try {
             String actualCommandLine = executeToString(exe);
 
             log(actualCommandLine, Project.MSG_VERBOSE);
             int retCode = exe.execute();
             log("retCode=" + retCode, Project.MSG_DEBUG);
 
             if (failOnError && Execute.isFailure(retCode)) {
                 throw new BuildException("cvs exited with error code "
                                          + retCode
                                          + StringUtils.LINE_SEP
                                          + "Command line was ["
                                          + actualCommandLine + "]",
                                          getLocation());
             }
         } catch (IOException e) {
             if (failOnError) {
                 throw new BuildException(e, getLocation());
             }
             log("Caught exception: " + e.getMessage(), Project.MSG_WARN);
         } catch (BuildException e) {
             if (failOnError) {
                 throw(e);
             }
             Throwable t = e.getCause();
             if (t == null) {
                 t = e;
             }
             log("Caught exception: " + t.getMessage(), Project.MSG_WARN);
         } catch (Exception e) {
             if (failOnError) {
                 throw new BuildException(e, getLocation());
             }
             log("Caught exception: " + e.getMessage(), Project.MSG_WARN);
         }
     }
 
     /**
      * do the work
      * @throws BuildException if failonerror is set to true and the
      * cvs command fails.
      */
     public void execute() throws BuildException {
 
         String savedCommand = getCommand();
 
         if (this.getCommand() == null && vecCommandlines.size() == 0) {
             // re-implement legacy behaviour:
             this.setCommand(AbstractCvsTask.DEFAULT_COMMAND);
         }
 
         String c = this.getCommand();
         Commandline cloned = null;
         if (c != null) {
             cloned = (Commandline) cmd.clone();
             cloned.createArgument(true).setLine(c);
             this.addConfiguredCommandline(cloned, true);
         }
 
         try {
-            for (int i = 0; i < vecCommandlines.size(); i++) {
+            final int size = vecCommandlines.size();
+            for (int i = 0; i < size; i++) {
                 this.runCommand((Commandline) vecCommandlines.elementAt(i));
             }
         } finally {
             if (cloned != null) {
                 removeCommandline(cloned);
             }
             setCommand(savedCommand);
             FileUtils.close(outputStream);
             FileUtils.close(errorStream);
         }
     }
 
     private String executeToString(Execute execute) {
 
         String cmdLine = Commandline.describeCommand(execute
                 .getCommandline());
         StringBuffer stringBuffer = removeCvsPassword(cmdLine);
 
         String newLine = StringUtils.LINE_SEP;
         String[] variableArray = execute.getEnvironment();
 
         if (variableArray != null) {
             stringBuffer.append(newLine);
             stringBuffer.append(newLine);
             stringBuffer.append("environment:");
             stringBuffer.append(newLine);
             for (int z = 0; z < variableArray.length; z++) {
                 stringBuffer.append(newLine);
                 stringBuffer.append("\t");
                 stringBuffer.append(variableArray[z]);
             }
         }
 
         return stringBuffer.toString();
     }
 
     /**
      * Removes the cvs password from the command line, if given on the command
      * line. This password can be given on the command line in the cvsRoot
      * -d:pserver:user:password@server:path
      * It has to be noted that the password may be omitted altogether.
      * @param cmdLine the CVS command line
      * @return a StringBuffer where the password has been removed (if available)
      */
     private StringBuffer removeCvsPassword(String cmdLine) {
         StringBuffer stringBuffer = new StringBuffer(cmdLine);
 
         int start = cmdLine.indexOf("-d:");
 
         if (start >= 0) {
             int stop = cmdLine.indexOf("@", start);
             int startproto = cmdLine.indexOf(":", start);
             int startuser = cmdLine.indexOf(":", startproto + 1);
             int startpass = cmdLine.indexOf(":", startuser + 1);
             stop = cmdLine.indexOf("@", start);
             if (stop >= 0 && startpass > startproto && startpass < stop) {
                 for (int i = startpass + 1; i < stop; i++) {
                     stringBuffer.replace(i, i + 1, "*");
                 }
             }
         }
         return stringBuffer;
     }
 
     /**
      * The CVSROOT variable.
      *
      * @param root
      *            the CVSROOT variable
      */
     public void setCvsRoot(String root) {
 
         // Check if not real cvsroot => set it to null
         if (root != null) {
             if (root.trim().equals("")) {
                 root = null;
             }
         }
 
         this.cvsRoot = root;
     }
 
     /**
      * access the CVSROOT variable
      * @return CVSROOT
      */
     public String getCvsRoot() {
 
         return this.cvsRoot;
     }
 
     /**
      * The CVS_RSH variable.
      *
      * @param rsh the CVS_RSH variable
      */
     public void setCvsRsh(String rsh) {
         // Check if not real cvsrsh => set it to null
         if (rsh != null) {
             if (rsh.trim().equals("")) {
                 rsh = null;
             }
         }
 
         this.cvsRsh = rsh;
     }
 
     /**
      * access the CVS_RSH variable
      * @return the CVS_RSH variable
      */
     public String getCvsRsh() {
 
         return this.cvsRsh;
     }
 
     /**
      * Port used by CVS to communicate with the server.
      *
      * @param port port of CVS
      */
     public void setPort(int port) {
         this.port = port;
     }
 
     /**
      * access the port of CVS
      * @return the port of CVS
      */
     public int getPort() {
 
         return this.port;
     }
 
     /**
      * Password file to read passwords from.
      *
      * @param passFile password file to read passwords from
      */
     public void setPassfile(File passFile) {
         this.passFile = passFile;
     }
 
     /**
      * find the password file
      * @return password file
      */
     public File getPassFile() {
 
         return this.passFile;
     }
 
     /**
      * The directory where the checked out files should be placed.
      *
      * <p>Note that this is different from CVS's -d command line
      * switch as Ant will never shorten pathnames to avoid empty
      * directories.</p>
      *
      * @param dest directory where the checked out files should be placed
      */
     public void setDest(File dest) {
         this.dest = dest;
     }
 
     /**
      * get the file where the checked out files should be placed
      *
      * @return directory where the checked out files should be placed
      */
     public File getDest() {
 
         return this.dest;
     }
 
     /**
      * The package/module to operate upon.
      *
      * @param p package or module to operate upon
      */
     public void setPackage(String p) {
         this.cvsPackage = p;
     }
 
     /**
      * access the package or module to operate upon
      *
      * @return package/module
      */
     public String getPackage() {
 
         return this.cvsPackage;
     }
     /**
      * tag or branch
      * @return tag or branch
      * @since ant 1.6.1
      */
     public String getTag() {
         return tag;
     }
 
     /**
      * The tag of the package/module to operate upon.
      * @param p tag
      */
     public void setTag(String p) {
         // Check if not real tag => set it to null
         if (p != null && p.trim().length() > 0) {
             tag = p;
             addCommandArgument("-r" + p);
         }
     }
 
     /**
      * This needs to be public to allow configuration
      *      of commands externally.
      * @param arg command argument
      */
     public void addCommandArgument(String arg) {
         this.addCommandArgument(cmd, arg);
     }
 
     /**
      * This method adds a command line argument to an external command.
      *
      * I do not understand what this method does in this class ???
      * particularly not why it is public ????
      * AntoineLL July 23d 2003
      *
      * @param c  command line to which one argument should be added
      * @param arg argument to add
      */
     public void addCommandArgument(Commandline c, String arg) {
         c.createArgument().setValue(arg);
     }
 
 
     /**
      * Use the most recent revision no later than the given date.
      * @param p a date as string in a format that the CVS executable
      * can understand see man cvs
      */
     public void setDate(String p) {
         if (p != null && p.trim().length() > 0) {
             addCommandArgument("-D");
             addCommandArgument(p);
         }
     }
 
     /**
      * The CVS command to execute.
      *
      * This should be deprecated, it is better to use the Commandline class ?
      * AntoineLL July 23d 2003
      *
      * @param c a command as string
      */
     public void setCommand(String c) {
         this.command = c;
     }
     /**
      * accessor to a command line as string
      *
      * This should be deprecated
      * AntoineLL July 23d 2003
      *
      * @return command line as string
      */
     public String getCommand() {
         return this.command;
     }
 
     /**
      * If true, suppress informational messages.
      * @param q  if true, suppress informational messages
      */
     public void setQuiet(boolean q) {
         quiet = q;
     }
 
     /**
      * If true, suppress all messages.
      * @param q  if true, suppress all messages
      * @since Ant 1.6
      */
     public void setReallyquiet(boolean q) {
         reallyquiet = q;
     }
 
 
     /**
      * If true, report only and don't change any files.
      *
      * @param ne if true, report only and do not change any files.
      */
     public void setNoexec(boolean ne) {
         noexec = ne;
     }
 
     /**
      * The file to direct standard output from the command.
      * @param output a file to which stdout should go
      */
     public void setOutput(File output) {
         this.output = output;
     }
 
     /**
      * The file to direct standard error from the command.
      *
      * @param error a file to which stderr should go
      */
     public void setError(File error) {
         this.error = error;
     }
 
     /**
      * Whether to append output/error when redirecting to a file.
      * @param value true indicated you want to append
      */
     public void setAppend(boolean value) {
         this.append = value;
     }
 
     /**
      * Stop the build process if the command exits with
      * a return code other than 0.
      * Defaults to false.
      * @param failOnError stop the build process if the command exits with
      * a return code other than 0
      */
     public void setFailOnError(boolean failOnError) {
         this.failOnError = failOnError;
     }
 
     /**
      * Configure a commandline element for things like cvsRoot, quiet, etc.
      * @param c the command line which will be configured
      * if the commandline is initially null, the function is a noop
      * otherwise the function append to the commandline arguments concerning
      * <ul>
      * <li>
      * cvs package
      * </li>
      * <li>
      * compression
      * </li>
      * <li>
      * quiet or reallyquiet
      * </li>
      * <li>cvsroot</li>
      * <li>noexec</li>
      * </ul>
      */
     protected void configureCommandline(Commandline c) {
         if (c == null) {
             return;
         }
         c.setExecutable("cvs");
         if (cvsPackage != null) {
             c.createArgument().setLine(cvsPackage);
         }
         for (Iterator iter = modules.iterator(); iter.hasNext(); ) {
             Module m = (Module) iter.next();
             c.createArgument().setValue(m.getName());
         }
         if (this.compression > 0
             && this.compression <= MAXIMUM_COMRESSION_LEVEL) {
             c.createArgument(true).setValue("-z" + this.compression);
         }
         if (quiet && !reallyquiet) {
             c.createArgument(true).setValue("-q");
         }
         if (reallyquiet) {
             c.createArgument(true).setValue("-Q");
         }
         if (noexec) {
             c.createArgument(true).setValue("-n");
         }
         if (cvsRoot != null) {
             c.createArgument(true).setLine("-d" + cvsRoot);
         }
     }
 
     /**
      * remove a particular command from a vector of command lines
      * @param c command line which should be removed
      */
     protected void removeCommandline(Commandline c) {
         vecCommandlines.removeElement(c);
     }
 
     /**
      * Adds direct command-line to execute.
      * @param c command line to execute
      */
     public void addConfiguredCommandline(Commandline c) {
         this.addConfiguredCommandline(c, false);
     }
 
     /**
      * Configures and adds the given Commandline.
      * @param c commandline to insert
      * @param insertAtStart If true, c is
      * inserted at the beginning of the vector of command lines
     */
     public void addConfiguredCommandline(Commandline c,
                                          boolean insertAtStart) {
         if (c == null) {
             return;
         }
         this.configureCommandline(c);
         if (insertAtStart) {
             vecCommandlines.insertElementAt(c, 0);
         } else {
             vecCommandlines.addElement(c);
         }
     }
 
     /**
     * If set to a value 1-9 it adds -zN to the cvs command line, else
     * it disables compression.
      * @param level compression level 1 to 9
     */
     public void setCompressionLevel(int level) {
         this.compression = level;
     }
 
     /**
      * If true, this is the same as compressionlevel="3".
      *
      * @param usecomp If true, turns on compression using default
      * level, AbstractCvsTask.DEFAULT_COMPRESSION_LEVEL.
      */
     public void setCompression(boolean usecomp) {
         setCompressionLevel(usecomp
             ? AbstractCvsTask.DEFAULT_COMPRESSION_LEVEL : 0);
     }
 
     /**
      * add a named module/package.
      *
      * @since Ant 1.8.0
      */
     public void addModule(Module m) {
         modules.add(m);
     }
 
     protected List getModules() {
         return (List) modules.clone();
     }
 
     public static final class Module {
         private String name;
         public void setName(String s) {
             name = s;
         }
         public String getName() {
             return name;
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Copy.java b/src/main/org/apache/tools/ant/taskdefs/Copy.java
index cbb4728b8..d55bf2386 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Copy.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Copy.java
@@ -1,1100 +1,1101 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Vector;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.types.Mapper;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.FilterSet;
 import org.apache.tools.ant.types.FilterChain;
 import org.apache.tools.ant.types.FilterSetCollection;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.ResourceFactory;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.IdentityMapper;
 import org.apache.tools.ant.util.LinkedHashtable;
 import org.apache.tools.ant.util.ResourceUtils;
 import org.apache.tools.ant.util.SourceFileScanner;
 import org.apache.tools.ant.util.FlatFileNameMapper;
 
 /**
  * Copies a file or directory to a new file
  * or directory.  Files are only copied if the source file is newer
  * than the destination file, or when the destination file does not
  * exist.  It is possible to explicitly overwrite existing files.</p>
  *
  * <p>This implementation is based on Arnout Kuiper's initial design
  * document, the following mailing list discussions, and the
  * copyfile/copydir tasks.</p>
  *
  *
  * @since Ant 1.2
  *
  * @ant.task category="filesystem"
  */
 public class Copy extends Task {
     private static final String MSG_WHEN_COPYING_EMPTY_RC_TO_FILE =
         "Cannot perform operation from directory to file.";
 
     static final File NULL_FILE_PLACEHOLDER = new File("/NULL_FILE");
     static final String LINE_SEPARATOR = System.getProperty("line.separator");
     // CheckStyle:VisibilityModifier OFF - bc
     protected File file = null;     // the source file
     protected File destFile = null; // the destination file
     protected File destDir = null;  // the destination directory
     protected Vector rcs = new Vector();
     // here to provide API backwards compatibility
     protected Vector filesets = rcs;
 
     private boolean enableMultipleMappings = false;
     protected boolean filtering = false;
     protected boolean preserveLastModified = false;
     protected boolean forceOverwrite = false;
     protected boolean flatten = false;
     protected int verbosity = Project.MSG_VERBOSE;
     protected boolean includeEmpty = true;
     protected boolean failonerror = true;
 
     protected Hashtable fileCopyMap = new LinkedHashtable();
     protected Hashtable dirCopyMap = new LinkedHashtable();
     protected Hashtable completeDirMap = new LinkedHashtable();
 
     protected Mapper mapperElement = null;
     protected FileUtils fileUtils;
     //CheckStyle:VisibilityModifier ON
     private Vector filterChains = new Vector();
     private Vector filterSets = new Vector();
     private String inputEncoding = null;
     private String outputEncoding = null;
     private long granularity = 0;
     private boolean force = false;
 
     // used to store the single non-file resource to copy when the
     // tofile attribute has been used
     private Resource singleResource = null;
 
     /**
      * Copy task constructor.
      */
     public Copy() {
         fileUtils = FileUtils.getFileUtils();
         granularity = fileUtils.getFileTimestampGranularity();
     }
 
     /**
      * Get the FileUtils for this task.
      * @return the fileutils object.
      */
     protected FileUtils getFileUtils() {
         return fileUtils;
     }
 
     /**
      * Set a single source file to copy.
      * @param file the file to copy.
      */
     public void setFile(File file) {
         this.file = file;
     }
 
     /**
      * Set the destination file.
      * @param destFile the file to copy to.
      */
     public void setTofile(File destFile) {
         this.destFile = destFile;
     }
 
     /**
      * Set the destination directory.
      * @param destDir the destination directory.
      */
     public void setTodir(File destDir) {
         this.destDir = destDir;
     }
 
     /**
      * Add a FilterChain.
      * @return a filter chain object.
      */
     public FilterChain createFilterChain() {
         FilterChain filterChain = new FilterChain();
         filterChains.addElement(filterChain);
         return filterChain;
     }
 
     /**
      * Add a filterset.
      * @return a filter set object.
      */
     public FilterSet createFilterSet() {
         FilterSet filterSet = new FilterSet();
         filterSets.addElement(filterSet);
         return filterSet;
     }
 
     /**
      * Give the copied files the same last modified time as the original files.
      * @param preserve a boolean string.
      * @deprecated since 1.5.x.
      *             setPreserveLastModified(String) has been deprecated and
      *             replaced with setPreserveLastModified(boolean) to
      *             consistently let the Introspection mechanism work.
      */
     public void setPreserveLastModified(String preserve) {
         setPreserveLastModified(Project.toBoolean(preserve));
     }
 
     /**
      * Give the copied files the same last modified time as the original files.
      * @param preserve if true preserve the modified time; default is false.
      */
     public void setPreserveLastModified(boolean preserve) {
         preserveLastModified = preserve;
     }
 
     /**
      * Get whether to give the copied files the same last modified time as
      * the original files.
      * @return the whether destination files will inherit the modification
      *         times of the corresponding source files.
      * @since 1.32, Ant 1.5
      */
     public boolean getPreserveLastModified() {
         return preserveLastModified;
     }
 
     /**
      * Get the filtersets being applied to this operation.
      *
      * @return a vector of FilterSet objects.
      */
     protected Vector getFilterSets() {
         return filterSets;
     }
 
     /**
      * Get the filterchains being applied to this operation.
      *
      * @return a vector of FilterChain objects.
      */
     protected Vector getFilterChains() {
         return filterChains;
     }
 
     /**
      * Set filtering mode.
      * @param filtering if true enable filtering; default is false.
      */
     public void setFiltering(boolean filtering) {
         this.filtering = filtering;
     }
 
     /**
      * Set overwrite mode regarding existing destination file(s).
      * @param overwrite if true force overwriting of destination file(s)
      *                  even if the destination file(s) are younger than
      *                  the corresponding source file. Default is false.
      */
     public void setOverwrite(boolean overwrite) {
         this.forceOverwrite = overwrite;
     }
 
     /**
      * Whether read-only destinations will be overwritten.
      *
      * <p>Defaults to false</p>
      *
      * @since Ant 1.8.2
      */
     public void setForce(boolean f) {
         force = f;
     }
 
     /**
      * Whether read-only destinations will be overwritten.
      *
      * @since Ant 1.8.2
      */
     public boolean getForce() {
         return force;
     }
 
     /**
      * Set whether files copied from directory trees will be "flattened"
      * into a single directory.  If there are multiple files with
      * the same name in the source directory tree, only the first
      * file will be copied into the "flattened" directory, unless
      * the forceoverwrite attribute is true.
      * @param flatten if true flatten the destination directory. Default
      *                is false.
      */
     public void setFlatten(boolean flatten) {
         this.flatten = flatten;
     }
 
     /**
      * Set verbose mode. Used to force listing of all names of copied files.
      * @param verbose whether to output the names of copied files.
      *                Default is false.
      */
     public void setVerbose(boolean verbose) {
         this.verbosity = verbose ? Project.MSG_INFO : Project.MSG_VERBOSE;
     }
 
     /**
      * Set whether to copy empty directories.
      * @param includeEmpty if true copy empty directories. Default is true.
      */
     public void setIncludeEmptyDirs(boolean includeEmpty) {
         this.includeEmpty = includeEmpty;
     }
 
     /**
      * Set method of handling mappers that return multiple
      * mappings for a given source path.
      * @param enableMultipleMappings If true the task will
      *        copy to all the mappings for a given source path, if
      *        false, only the first file or directory is
      *        processed.
      *        By default, this setting is false to provide backward
      *        compatibility with earlier releases.
      * @since Ant 1.6
      */
     public void setEnableMultipleMappings(boolean enableMultipleMappings) {
         this.enableMultipleMappings = enableMultipleMappings;
     }
 
     /**
      * Get whether multiple mapping is enabled.
      * @return true if multiple mapping is enabled; false otherwise.
      */
     public boolean isEnableMultipleMapping() {
         return enableMultipleMappings;
     }
 
     /**
      * Set whether to fail when errors are encountered. If false, note errors
      * to the output but keep going. Default is true.
      * @param failonerror true or false.
      */
     public void setFailOnError(boolean failonerror) {
         this.failonerror = failonerror;
     }
 
     /**
      * Add a set of files to copy.
      * @param set a set of files to copy.
      */
     public void addFileset(FileSet set) {
         add(set);
     }
 
     /**
      * Add a collection of files to copy.
      * @param res a resource collection to copy.
      * @since Ant 1.7
      */
     public void add(ResourceCollection res) {
         rcs.add(res);
     }
 
     /**
      * Define the mapper to map source to destination files.
      * @return a mapper to be configured.
      * @exception BuildException if more than one mapper is defined.
      */
     public Mapper createMapper() throws BuildException {
         if (mapperElement != null) {
             throw new BuildException("Cannot define more than one mapper",
                                      getLocation());
         }
         mapperElement = new Mapper(getProject());
         return mapperElement;
     }
 
     /**
      * Add a nested filenamemapper.
      * @param fileNameMapper the mapper to add.
      * @since Ant 1.6.3
      */
     public void add(FileNameMapper fileNameMapper) {
         createMapper().add(fileNameMapper);
     }
 
     /**
      * Set the character encoding.
      * @param encoding the character encoding.
      * @since 1.32, Ant 1.5
      */
     public void setEncoding(String encoding) {
         this.inputEncoding = encoding;
         if (outputEncoding == null) {
             outputEncoding = encoding;
         }
     }
 
     /**
      * Get the character encoding to be used.
      * @return the character encoding, <code>null</code> if not set.
      *
      * @since 1.32, Ant 1.5
      */
     public String getEncoding() {
         return inputEncoding;
     }
 
     /**
      * Set the character encoding for output files.
      * @param encoding the output character encoding.
      * @since Ant 1.6
      */
     public void setOutputEncoding(String encoding) {
         this.outputEncoding = encoding;
     }
 
     /**
      * Get the character encoding for output files.
      * @return the character encoding for output files,
      * <code>null</code> if not set.
      *
      * @since Ant 1.6
      */
     public String getOutputEncoding() {
         return outputEncoding;
     }
 
     /**
      * Set the number of milliseconds leeway to give before deciding a
      * target is out of date.
      *
      * <p>Default is 1 second, or 2 seconds on DOS systems.</p>
      * @param granularity the granularity used to decide if a target is out of
      *                    date.
      * @since Ant 1.6.2
      */
     public void setGranularity(long granularity) {
         this.granularity = granularity;
     }
 
     /**
      * Perform the copy operation.
      * @exception BuildException if an error occurs.
      */
     public void execute() throws BuildException {
         File savedFile = file; // may be altered in validateAttributes
         File savedDestFile = destFile;
         File savedDestDir = destDir;
         ResourceCollection savedRc = null;
         if (file == null && destFile != null && rcs.size() == 1) {
             // will be removed in validateAttributes
             savedRc = (ResourceCollection) rcs.elementAt(0);
         }
 
         try {
             // make sure we don't have an illegal set of options
             try {
                 validateAttributes();
             } catch (BuildException e) {
                 if (failonerror
                     || !getMessage(e)
                     .equals(MSG_WHEN_COPYING_EMPTY_RC_TO_FILE)) {
                     throw e;
                 } else {
                     log("Warning: " + getMessage(e), Project.MSG_ERR);
                     return;
                 }
             }
 
             // deal with the single file
             copySingleFile();
 
             // deal with the ResourceCollections
 
             /* for historical and performance reasons we have to do
                things in a rather complex way.
 
                (1) Move is optimized to move directories if a fileset
                has been included completely, therefore FileSets need a
                special treatment.  This is also required to support
                the failOnError semantice (skip filesets with broken
                basedir but handle the remaining collections).
 
                (2) We carry around a few protected methods that work
                on basedirs and arrays of names.  To optimize stuff, all
                resources with the same basedir get collected in
                separate lists and then each list is handled in one go.
             */
 
             HashMap filesByBasedir = new HashMap();
             HashMap dirsByBasedir = new HashMap();
             HashSet baseDirs = new HashSet();
             ArrayList nonFileResources = new ArrayList();
-            for (int i = 0; i < rcs.size(); i++) {
+            final int size = rcs.size();
+            for (int i = 0; i < size; i++) {
                 ResourceCollection rc = (ResourceCollection) rcs.elementAt(i);
 
                 // Step (1) - beware of the ZipFileSet
                 if (rc instanceof FileSet && rc.isFilesystemOnly()) {
                     FileSet fs = (FileSet) rc;
                     DirectoryScanner ds = null;
                     try {
                         ds = fs.getDirectoryScanner(getProject());
                     } catch (BuildException e) {
                         if (failonerror
                             || !getMessage(e).endsWith(DirectoryScanner
                                                        .DOES_NOT_EXIST_POSTFIX)) {
                             throw e;
                         } else {
                             log("Warning: " + getMessage(e), Project.MSG_ERR);
                             continue;
                         }
                     }
                     File fromDir = fs.getDir(getProject());
 
                     String[] srcFiles = ds.getIncludedFiles();
                     String[] srcDirs = ds.getIncludedDirectories();
                     if (!flatten && mapperElement == null
                         && ds.isEverythingIncluded() && !fs.hasPatterns()) {
                         completeDirMap.put(fromDir, destDir);
                     }
                     add(fromDir, srcFiles, filesByBasedir);
                     add(fromDir, srcDirs, dirsByBasedir);
                     baseDirs.add(fromDir);
                 } else { // not a fileset or contains non-file resources
 
                     if (!rc.isFilesystemOnly() && !supportsNonFileResources()) {
                         throw new BuildException(
                                    "Only FileSystem resources are supported.");
                     }
 
                     Iterator resources = rc.iterator();
                     while (resources.hasNext()) {
                         Resource r = (Resource) resources.next();
                         if (!r.isExists()) {
                             String message = "Warning: Could not find resource "
                                 + r.toLongString() + " to copy.";
                             if (!failonerror) {
                                 log(message, Project.MSG_ERR);
                             } else {
                                 throw new BuildException(message);
                             }
                             continue;
                         }
 
                         File baseDir = NULL_FILE_PLACEHOLDER;
                         String name = r.getName();
                         FileProvider fp = (FileProvider) r.as(FileProvider.class);
                         if (fp != null) {
                             FileResource fr = ResourceUtils.asFileResource(fp);
                             baseDir = getKeyFile(fr.getBaseDir());
                             if (fr.getBaseDir() == null) {
                                 name = fr.getFile().getAbsolutePath();
                             }
                         }
 
                         // copying of dirs is trivial and can be done
                         // for non-file resources as well as for real
                         // files.
                         if (r.isDirectory() || fp != null) {
                             add(baseDir, name,
                                 r.isDirectory() ? dirsByBasedir
                                                 : filesByBasedir);
                             baseDirs.add(baseDir);
                         } else { // a not-directory file resource
                             // needs special treatment
                             nonFileResources.add(r);
                         }
                     }
                 }
             }
 
             iterateOverBaseDirs(baseDirs, dirsByBasedir, filesByBasedir);
 
             // do all the copy operations now...
             try {
                 doFileOperations();
             } catch (BuildException e) {
                 if (!failonerror) {
                     log("Warning: " + getMessage(e), Project.MSG_ERR);
                 } else {
                     throw e;
                 }
             }
 
             if (nonFileResources.size() > 0 || singleResource != null) {
                 Resource[] nonFiles =
                     (Resource[]) nonFileResources.toArray(new Resource[nonFileResources.size()]);
                 // restrict to out-of-date resources
                 Map map = scan(nonFiles, destDir);
                 if (singleResource != null) {
                     map.put(singleResource,
                             new String[] { destFile.getAbsolutePath() });
                 }
                 try {
                     doResourceOperations(map);
                 } catch (BuildException e) {
                     if (!failonerror) {
                         log("Warning: " + getMessage(e), Project.MSG_ERR);
                     } else {
                         throw e;
                     }
                 }
             }
         } finally {
             // clean up again, so this instance can be used a second
             // time
             singleResource = null;
             file = savedFile;
             destFile = savedDestFile;
             destDir = savedDestDir;
             if (savedRc != null) {
                 rcs.insertElementAt(savedRc, 0);
             }
             fileCopyMap.clear();
             dirCopyMap.clear();
             completeDirMap.clear();
         }
     }
 
     /************************************************************************
      **  protected and private methods
      ************************************************************************/
 
     private void copySingleFile() {
         // deal with the single file
         if (file != null) {
             if (file.exists()) {
                 if (destFile == null) {
                     destFile = new File(destDir, file.getName());
                 }
                 if (forceOverwrite || !destFile.exists()
                     || (file.lastModified() - granularity
                         > destFile.lastModified())) {
                     fileCopyMap.put(file.getAbsolutePath(),
                                     new String[] {destFile.getAbsolutePath()});
                 } else {
                     log(file + " omitted as " + destFile
                         + " is up to date.", Project.MSG_VERBOSE);
                 }
             } else {
                 String message = "Warning: Could not find file "
                     + file.getAbsolutePath() + " to copy.";
                 if (!failonerror) {
                     log(message, Project.MSG_ERR);
                 } else {
                     throw new BuildException(message);
                 }
             }
         }
     }
 
     private void iterateOverBaseDirs(
         HashSet baseDirs, HashMap dirsByBasedir, HashMap filesByBasedir) {
 
         Iterator iter = baseDirs.iterator();
         while (iter.hasNext()) {
             File f = (File) iter.next();
             List files = (List) filesByBasedir.get(f);
             List dirs = (List) dirsByBasedir.get(f);
 
             String[] srcFiles = new String[0];
             if (files != null) {
                 srcFiles = (String[]) files.toArray(srcFiles);
             }
             String[] srcDirs = new String[0];
             if (dirs != null) {
                 srcDirs = (String[]) dirs.toArray(srcDirs);
             }
             scan(f == NULL_FILE_PLACEHOLDER ? null : f, destDir, srcFiles,
                  srcDirs);
         }
     }
 
     /**
      * Ensure we have a consistent and legal set of attributes, and set
      * any internal flags necessary based on different combinations
      * of attributes.
      * @exception BuildException if an error occurs.
      */
     protected void validateAttributes() throws BuildException {
         if (file == null && rcs.size() == 0) {
             throw new BuildException(
                 "Specify at least one source--a file or a resource collection.");
         }
         if (destFile != null && destDir != null) {
             throw new BuildException(
                 "Only one of tofile and todir may be set.");
         }
         if (destFile == null && destDir == null) {
             throw new BuildException("One of tofile or todir must be set.");
         }
         if (file != null && file.isDirectory()) {
             throw new BuildException("Use a resource collection to copy directories.");
         }
         if (destFile != null && rcs.size() > 0) {
             if (rcs.size() > 1) {
                 throw new BuildException(
                     "Cannot concatenate multiple files into a single file.");
             } else {
                 ResourceCollection rc = (ResourceCollection) rcs.elementAt(0);
                 if (!rc.isFilesystemOnly() && !supportsNonFileResources()) {
                     throw new BuildException("Only FileSystem resources are"
                                              + " supported.");
                 }
                 if (rc.size() == 0) {
                     throw new BuildException(MSG_WHEN_COPYING_EMPTY_RC_TO_FILE);
                 } else if (rc.size() == 1) {
                     Resource res = (Resource) rc.iterator().next();
                     FileProvider r = (FileProvider) res.as(FileProvider.class);
                     if (file == null) {
                         if (r != null) {
                             file = r.getFile();
                         } else {
                             singleResource = res;
                         }
                         rcs.removeElementAt(0);
                     } else {
                         throw new BuildException(
                             "Cannot concatenate multiple files into a single file.");
                     }
                 } else {
                     throw new BuildException(
                         "Cannot concatenate multiple files into a single file.");
                 }
             }
         }
         if (destFile != null) {
             destDir = destFile.getParentFile();
         }
     }
 
     /**
      * Compares source files to destination files to see if they should be
      * copied.
      *
      * @param fromDir  The source directory.
      * @param toDir    The destination directory.
      * @param files    A list of files to copy.
      * @param dirs     A list of directories to copy.
      */
     protected void scan(File fromDir, File toDir, String[] files,
                         String[] dirs) {
         FileNameMapper mapper = getMapper();
         buildMap(fromDir, toDir, files, mapper, fileCopyMap);
 
         if (includeEmpty) {
             buildMap(fromDir, toDir, dirs, mapper, dirCopyMap);
         }
     }
 
     /**
      * Compares source resources to destination files to see if they
      * should be copied.
      *
      * @param fromResources  The source resources.
      * @param toDir          The destination directory.
      *
      * @return a Map with the out-of-date resources as keys and an
      * array of target file names as values.
      *
      * @since Ant 1.7
      */
     protected Map scan(Resource[] fromResources, File toDir) {
         return buildMap(fromResources, toDir, getMapper());
     }
 
     /**
      * Add to a map of files/directories to copy.
      *
      * @param fromDir the source directory.
      * @param toDir   the destination directory.
      * @param names   a list of filenames.
      * @param mapper  a <code>FileNameMapper</code> value.
      * @param map     a map of source file to array of destination files.
      */
     protected void buildMap(File fromDir, File toDir, String[] names,
                             FileNameMapper mapper, Hashtable map) {
         String[] toCopy = null;
         if (forceOverwrite) {
             Vector v = new Vector();
             for (int i = 0; i < names.length; i++) {
                 if (mapper.mapFileName(names[i]) != null) {
                     v.addElement(names[i]);
                 }
             }
             toCopy = new String[v.size()];
             v.copyInto(toCopy);
         } else {
             SourceFileScanner ds = new SourceFileScanner(this);
             toCopy = ds.restrict(names, fromDir, toDir, mapper, granularity);
         }
         for (int i = 0; i < toCopy.length; i++) {
             File src = new File(fromDir, toCopy[i]);
             String[] mappedFiles = mapper.mapFileName(toCopy[i]);
 
             if (!enableMultipleMappings) {
                 map.put(src.getAbsolutePath(),
                         new String[] {new File(toDir, mappedFiles[0]).getAbsolutePath()});
             } else {
                 // reuse the array created by the mapper
                 for (int k = 0; k < mappedFiles.length; k++) {
                     mappedFiles[k] = new File(toDir, mappedFiles[k]).getAbsolutePath();
                 }
                 map.put(src.getAbsolutePath(), mappedFiles);
             }
         }
     }
 
     /**
      * Create a map of resources to copy.
      *
      * @param fromResources  The source resources.
      * @param toDir   the destination directory.
      * @param mapper  a <code>FileNameMapper</code> value.
      * @return a map of source resource to array of destination files.
      * @since Ant 1.7
      */
     protected Map buildMap(Resource[] fromResources, final File toDir,
                            FileNameMapper mapper) {
         HashMap map = new HashMap();
         Resource[] toCopy = null;
         if (forceOverwrite) {
             Vector v = new Vector();
             for (int i = 0; i < fromResources.length; i++) {
                 if (mapper.mapFileName(fromResources[i].getName()) != null) {
                     v.addElement(fromResources[i]);
                 }
             }
             toCopy = new Resource[v.size()];
             v.copyInto(toCopy);
         } else {
             toCopy =
                 ResourceUtils.selectOutOfDateSources(this, fromResources,
                                                      mapper,
                                                      new ResourceFactory() {
                            public Resource getResource(String name) {
                                return new FileResource(toDir, name);
                            }
                                                      },
                                                      granularity);
         }
         for (int i = 0; i < toCopy.length; i++) {
             String[] mappedFiles = mapper.mapFileName(toCopy[i].getName());
             for (int j = 0; j < mappedFiles.length; j++) {
                 if (mappedFiles[j] == null) {
                     throw new BuildException("Can't copy a resource without a"
                                              + " name if the mapper doesn't"
                                              + " provide one.");
                 }
             }
 
             if (!enableMultipleMappings) {
                 map.put(toCopy[i],
                         new String[] {new File(toDir, mappedFiles[0]).getAbsolutePath()});
             } else {
                 // reuse the array created by the mapper
                 for (int k = 0; k < mappedFiles.length; k++) {
                     mappedFiles[k] = new File(toDir, mappedFiles[k]).getAbsolutePath();
                 }
                 map.put(toCopy[i], mappedFiles);
             }
         }
         return map;
     }
 
     /**
      * Actually does the file (and possibly empty directory) copies.
      * This is a good method for subclasses to override.
      */
     protected void doFileOperations() {
         if (fileCopyMap.size() > 0) {
             log("Copying " + fileCopyMap.size()
                 + " file" + (fileCopyMap.size() == 1 ? "" : "s")
                 + " to " + destDir.getAbsolutePath());
 
             Enumeration e = fileCopyMap.keys();
             while (e.hasMoreElements()) {
                 String fromFile = (String) e.nextElement();
                 String[] toFiles = (String[]) fileCopyMap.get(fromFile);
 
                 for (int i = 0; i < toFiles.length; i++) {
                     String toFile = toFiles[i];
 
                     if (fromFile.equals(toFile)) {
                         log("Skipping self-copy of " + fromFile, verbosity);
                         continue;
                     }
                     try {
                         log("Copying " + fromFile + " to " + toFile, verbosity);
 
                         FilterSetCollection executionFilters =
                             new FilterSetCollection();
                         if (filtering) {
                             executionFilters
                                 .addFilterSet(getProject().getGlobalFilterSet());
                         }
                         for (Enumeration filterEnum = filterSets.elements();
                             filterEnum.hasMoreElements();) {
                             executionFilters
                                 .addFilterSet((FilterSet) filterEnum.nextElement());
                         }
                         fileUtils.copyFile(new File(fromFile), new File(toFile),
                                            executionFilters,
                                            filterChains, forceOverwrite,
                                            preserveLastModified,
                                            /* append: */ false, inputEncoding,
                                            outputEncoding, getProject(),
                                            getForce());
                     } catch (IOException ioe) {
                         String msg = "Failed to copy " + fromFile + " to " + toFile
                             + " due to " + getDueTo(ioe);
                         File targetFile = new File(toFile);
                         if (targetFile.exists() && !targetFile.delete()) {
                             msg += " and I couldn't delete the corrupt " + toFile;
                         }
                         if (failonerror) {
                             throw new BuildException(msg, ioe, getLocation());
                         }
                         log(msg, Project.MSG_ERR);
                     }
                 }
             }
         }
         if (includeEmpty) {
             Enumeration e = dirCopyMap.elements();
             int createCount = 0;
             while (e.hasMoreElements()) {
                 String[] dirs = (String[]) e.nextElement();
                 for (int i = 0; i < dirs.length; i++) {
                     File d = new File(dirs[i]);
                     if (!d.exists()) {
                         if (!d.mkdirs()) {
                             log("Unable to create directory "
                                 + d.getAbsolutePath(), Project.MSG_ERR);
                         } else {
                             createCount++;
                         }
                     }
                 }
             }
             if (createCount > 0) {
                 log("Copied " + dirCopyMap.size()
                     + " empty director"
                     + (dirCopyMap.size() == 1 ? "y" : "ies")
                     + " to " + createCount
                     + " empty director"
                     + (createCount == 1 ? "y" : "ies") + " under "
                     + destDir.getAbsolutePath());
             }
         }
     }
 
     /**
      * Actually does the resource copies.
      * This is a good method for subclasses to override.
      * @param map a map of source resource to array of destination files.
      * @since Ant 1.7
      */
     protected void doResourceOperations(Map map) {
         if (map.size() > 0) {
             log("Copying " + map.size()
                 + " resource" + (map.size() == 1 ? "" : "s")
                 + " to " + destDir.getAbsolutePath());
 
             Iterator iter = map.keySet().iterator();
             while (iter.hasNext()) {
                 Resource fromResource = (Resource) iter.next();
                 String[] toFiles = (String[]) map.get(fromResource);
 
                 for (int i = 0; i < toFiles.length; i++) {
                     String toFile = toFiles[i];
 
                     try {
                         log("Copying " + fromResource + " to " + toFile,
                             verbosity);
 
                         FilterSetCollection executionFilters =
                             new FilterSetCollection();
                         if (filtering) {
                             executionFilters
                                 .addFilterSet(getProject().getGlobalFilterSet());
                         }
                         for (Enumeration filterEnum = filterSets.elements();
                             filterEnum.hasMoreElements();) {
                             executionFilters
                                 .addFilterSet((FilterSet) filterEnum.nextElement());
                         }
                         ResourceUtils.copyResource(fromResource,
                                                    new FileResource(destDir,
                                                                     toFile),
                                                    executionFilters,
                                                    filterChains,
                                                    forceOverwrite,
                                                    preserveLastModified,
                                                    /* append: */ false,
                                                    inputEncoding,
                                                    outputEncoding,
                                                    getProject(),
                                                    getForce());
                     } catch (IOException ioe) {
                         String msg = "Failed to copy " + fromResource
                             + " to " + toFile
                             + " due to " + getDueTo(ioe);
                         File targetFile = new File(toFile);
                         if (targetFile.exists() && !targetFile.delete()) {
                             msg += " and I couldn't delete the corrupt " + toFile;
                         }
                         if (failonerror) {
                             throw new BuildException(msg, ioe, getLocation());
                         }
                         log(msg, Project.MSG_ERR);
                     }
                 }
             }
         }
     }
 
     /**
      * Whether this task can deal with non-file resources.
      *
      * <p>&lt;copy&gt; can while &lt;move&gt; can't since we don't
      * know how to remove non-file resources.</p>
      *
      * <p>This implementation returns true only if this task is
      * &lt;copy&gt;.  Any subclass of this class that also wants to
      * support non-file resources needs to override this method.  We
      * need to do so for backwards compatibility reasons since we
      * can't expect subclasses to support resources.</p>
      * @return true if this task supports non file resources.
      * @since Ant 1.7
      */
     protected boolean supportsNonFileResources() {
         return getClass().equals(Copy.class);
     }
 
     /**
      * Adds the given strings to a list contained in the given map.
      * The file is the key into the map.
      */
     private static void add(File baseDir, String[] names, Map m) {
         if (names != null) {
             baseDir = getKeyFile(baseDir);
             List l = (List) m.get(baseDir);
             if (l == null) {
                 l = new ArrayList(names.length);
                 m.put(baseDir, l);
             }
             l.addAll(java.util.Arrays.asList(names));
         }
     }
 
     /**
      * Adds the given string to a list contained in the given map.
      * The file is the key into the map.
      */
     private static void add(File baseDir, String name, Map m) {
         if (name != null) {
             add(baseDir, new String[] {name}, m);
         }
     }
 
     /**
      * Either returns its argument or a plaeholder if the argument is null.
      */
     private static File getKeyFile(File f) {
         return f == null ? NULL_FILE_PLACEHOLDER : f;
     }
 
     /**
      * returns the mapper to use based on nested elements or the
      * flatten attribute.
      */
     private FileNameMapper getMapper() {
         FileNameMapper mapper = null;
         if (mapperElement != null) {
             mapper = mapperElement.getImplementation();
         } else if (flatten) {
             mapper = new FlatFileNameMapper();
         } else {
             mapper = new IdentityMapper();
         }
         return mapper;
     }
 
     /**
      * Handle getMessage() for exceptions.
      * @param ex the exception to handle
      * @return ex.getMessage() if ex.getMessage() is not null
      *         otherwise return ex.toString()
      */
     private String getMessage(Exception ex) {
         return ex.getMessage() == null ? ex.toString() : ex.getMessage();
     }
 
     /**
      * Returns a reason for failure based on
      * the exception thrown.
      * If the exception is not IOException output the class name,
      * output the message
      * if the exception is MalformedInput add a little note.
      */
     private String getDueTo(Exception ex) {
         boolean baseIOException = ex.getClass() == IOException.class;
         StringBuffer message = new StringBuffer();
         if (!baseIOException || ex.getMessage() == null) {
             message.append(ex.getClass().getName());
         }
         if (ex.getMessage() != null) {
             if (!baseIOException) {
                 message.append(" ");
             }
             message.append(ex.getMessage());
         }
         if (ex.getClass().getName().indexOf("MalformedInput") != -1) {
             message.append(LINE_SEPARATOR);
             message.append(
                 "This is normally due to the input file containing invalid");
              message.append(LINE_SEPARATOR);
             message.append("bytes for the character encoding used : ");
             message.append(
                 (inputEncoding == null
                  ? fileUtils.getDefaultEncoding() : inputEncoding));
             message.append(LINE_SEPARATOR);
         }
         return message.toString();
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Delete.java b/src/main/org/apache/tools/ant/taskdefs/Delete.java
index dbb690c68..0f881fdf2 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Delete.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Delete.java
@@ -1,821 +1,822 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.util.Arrays;
 import java.util.Vector;
 import java.util.Iterator;
 import java.util.Comparator;
 
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.PatternSet;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.Sort;
 import org.apache.tools.ant.types.resources.Restrict;
 import org.apache.tools.ant.types.resources.Resources;
 import org.apache.tools.ant.types.resources.FileResourceIterator;
 import org.apache.tools.ant.types.resources.comparators.Reverse;
 import org.apache.tools.ant.types.resources.comparators.FileSystem;
 import org.apache.tools.ant.types.resources.comparators.ResourceComparator;
 import org.apache.tools.ant.types.resources.selectors.Exists;
 import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
 import org.apache.tools.ant.types.selectors.OrSelector;
 import org.apache.tools.ant.types.selectors.AndSelector;
 import org.apache.tools.ant.types.selectors.NotSelector;
 import org.apache.tools.ant.types.selectors.DateSelector;
 import org.apache.tools.ant.types.selectors.FileSelector;
 import org.apache.tools.ant.types.selectors.NoneSelector;
 import org.apache.tools.ant.types.selectors.SizeSelector;
 import org.apache.tools.ant.types.selectors.DepthSelector;
 import org.apache.tools.ant.types.selectors.DependSelector;
 import org.apache.tools.ant.types.selectors.ExtendSelector;
 import org.apache.tools.ant.types.selectors.SelectSelector;
 import org.apache.tools.ant.types.selectors.PresentSelector;
 import org.apache.tools.ant.types.selectors.ContainsSelector;
 import org.apache.tools.ant.types.selectors.FilenameSelector;
 import org.apache.tools.ant.types.selectors.MajoritySelector;
 import org.apache.tools.ant.types.selectors.ContainsRegexpSelector;
 import org.apache.tools.ant.types.selectors.modifiedselector.ModifiedSelector;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.SymbolicLinkUtils;
 
 /**
  * Deletes a file or directory, or set of files defined by a fileset.
  * The original delete task would delete a file, or a set of files
  * using the include/exclude syntax.  The deltree task would delete a
  * directory tree.  This task combines the functionality of these two
  * originally distinct tasks.
  * <p>Currently Delete extends MatchingTask.  This is intended <i>only</i>
  * to provide backwards compatibility for a release.  The future position
  * is to use nested filesets exclusively.</p>
  *
  * @since Ant 1.2
  *
  * @ant.task category="filesystem"
  */
 public class Delete extends MatchingTask {
     private static final ResourceComparator REVERSE_FILESYSTEM = new Reverse(new FileSystem());
     private static final ResourceSelector EXISTS = new Exists();
 
     private static class ReverseDirs implements ResourceCollection {
         static final Comparator REVERSE = new Comparator() {
             public int compare(Object foo, Object bar) {
                 return ((Comparable) foo).compareTo(bar) * -1;
             }
         };
         private Project project;
         private File basedir;
         private String[] dirs;
         ReverseDirs(Project project, File basedir, String[] dirs) {
             this.project = project;
             this.basedir = basedir;
             this.dirs = dirs;
             Arrays.sort(this.dirs, REVERSE);
         }
         public Iterator iterator() {
             return new FileResourceIterator(project, basedir, dirs);
         }
         public boolean isFilesystemOnly() { return true; }
         public int size() { return dirs.length; }
     }
 
     // CheckStyle:VisibilityModifier OFF - bc
     protected File file = null;
     protected File dir = null;
     protected Vector filesets = new Vector();
     protected boolean usedMatchingTask = false;
     // by default, remove matching empty dirs
     protected boolean includeEmpty = false;
     // CheckStyle:VisibilityModifier ON
 
     private int verbosity = Project.MSG_VERBOSE;
     private boolean quiet = false;
     private boolean failonerror = true;
     private boolean deleteOnExit = false;
     private boolean removeNotFollowedSymlinks = false;
     private Resources rcs = null;
     private static FileUtils FILE_UTILS = FileUtils.getFileUtils();
     private static SymbolicLinkUtils SYMLINK_UTILS =
         SymbolicLinkUtils.getSymbolicLinkUtils();
 
     /**
      * Set the name of a single file to be removed.
      *
      * @param file the file to be deleted
      */
     public void setFile(File file) {
         this.file = file;
     }
 
     /**
      * Set the directory from which files are to be deleted
      *
      * @param dir the directory path.
      */
     public void setDir(File dir) {
         this.dir = dir;
         getImplicitFileSet().setDir(dir);
     }
 
     /**
      * If true, list all names of deleted files.
      *
      * @param verbose "true" or "on"
      */
     public void setVerbose(boolean verbose) {
         if (verbose) {
             this.verbosity = Project.MSG_INFO;
         } else {
             this.verbosity = Project.MSG_VERBOSE;
         }
     }
 
     /**
      * If true and the file does not exist, do not display a diagnostic
      * message or modify the exit status to reflect an error.
      * This means that if a file or directory cannot be deleted,
      * then no error is reported. This setting emulates the
      * -f option to the Unix &quot;rm&quot; command.
      * Default is false meaning things are &quot;noisy&quot;
      * @param quiet "true" or "on"
      */
     public void setQuiet(boolean quiet) {
         this.quiet = quiet;
         if (quiet) {
             this.failonerror = false;
         }
     }
 
     /**
      * If false, note errors but continue.
      *
      * @param failonerror true or false
      */
      public void setFailOnError(boolean failonerror) {
          this.failonerror = failonerror;
      }
 
     /**
      * If true, on failure to delete, note the error and set
      * the deleteonexit flag, and continue
      *
      * @param deleteOnExit true or false
      */
      public void setDeleteOnExit(boolean deleteOnExit) {
          this.deleteOnExit = deleteOnExit;
      }
 
 
     /**
      * If true, delete empty directories.
      * @param includeEmpty if true delete empty directories (only
      *                     for filesets). Default is false.
      */
     public void setIncludeEmptyDirs(boolean includeEmpty) {
         this.includeEmpty = includeEmpty;
     }
 
    /**
     * Adds a set of files to be deleted.
     * @param set the set of files to be deleted
     */
     public void addFileset(FileSet set) {
         filesets.addElement(set);
     }
 
     /**
      * Add an arbitrary ResourceCollection to be deleted.
      * @param rc the filesystem-only ResourceCollection.
      */
     public void add(ResourceCollection rc) {
         if (rc == null) {
             return;
         }
         if (rcs == null) {
             rcs = new Resources();
             rcs.setCache(true);
         }
         rcs.add(rc);
     }
 
     /**
      * add a name entry on the include list
      * @return a NameEntry object to be configured
      */
     public PatternSet.NameEntry createInclude() {
         usedMatchingTask = true;
         return super.createInclude();
     }
 
     /**
      * add a name entry on the include files list
      * @return an NameEntry object to be configured
      */
     public PatternSet.NameEntry createIncludesFile() {
         usedMatchingTask = true;
         return super.createIncludesFile();
     }
 
     /**
      * add a name entry on the exclude list
      * @return an NameEntry object to be configured
      */
     public PatternSet.NameEntry createExclude() {
         usedMatchingTask = true;
         return super.createExclude();
     }
 
     /**
      * add a name entry on the include files list
      * @return an NameEntry object to be configured
      */
     public PatternSet.NameEntry createExcludesFile() {
         usedMatchingTask = true;
         return super.createExcludesFile();
     }
 
     /**
      * add a set of patterns
      * @return PatternSet object to be configured
      */
     public PatternSet createPatternSet() {
         usedMatchingTask = true;
         return super.createPatternSet();
     }
 
     /**
      * Sets the set of include patterns. Patterns may be separated by a comma
      * or a space.
      *
      * @param includes the string containing the include patterns
      */
     public void setIncludes(String includes) {
         usedMatchingTask = true;
         super.setIncludes(includes);
     }
 
     /**
      * Sets the set of exclude patterns. Patterns may be separated by a comma
      * or a space.
      *
      * @param excludes the string containing the exclude patterns
      */
     public void setExcludes(String excludes) {
         usedMatchingTask = true;
         super.setExcludes(excludes);
     }
 
     /**
      * Sets whether default exclusions should be used or not.
      *
      * @param useDefaultExcludes "true"|"on"|"yes" when default exclusions
      *                           should be used, "false"|"off"|"no" when they
      *                           shouldn't be used.
      */
     public void setDefaultexcludes(boolean useDefaultExcludes) {
         usedMatchingTask = true;
         super.setDefaultexcludes(useDefaultExcludes);
     }
 
     /**
      * Sets the name of the file containing the includes patterns.
      *
      * @param includesfile A string containing the filename to fetch
      * the include patterns from.
      */
     public void setIncludesfile(File includesfile) {
         usedMatchingTask = true;
         super.setIncludesfile(includesfile);
     }
 
     /**
      * Sets the name of the file containing the includes patterns.
      *
      * @param excludesfile A string containing the filename to fetch
      * the include patterns from.
      */
     public void setExcludesfile(File excludesfile) {
         usedMatchingTask = true;
         super.setExcludesfile(excludesfile);
     }
 
     /**
      * Sets case sensitivity of the file system
      *
      * @param isCaseSensitive "true"|"on"|"yes" if file system is case
      *                           sensitive, "false"|"off"|"no" when not.
      */
     public void setCaseSensitive(boolean isCaseSensitive) {
         usedMatchingTask = true;
         super.setCaseSensitive(isCaseSensitive);
     }
 
     /**
      * Sets whether or not symbolic links should be followed.
      *
      * @param followSymlinks whether or not symbolic links should be followed
      */
     public void setFollowSymlinks(boolean followSymlinks) {
         usedMatchingTask = true;
         super.setFollowSymlinks(followSymlinks);
     }
 
     /**
      * Sets whether the symbolic links that have not been followed
      * shall be removed (the links, not the locations they point at).
      *
      * @since Ant 1.8.0
      */
     public void setRemoveNotFollowedSymlinks(boolean b) {
         removeNotFollowedSymlinks = b;
     }
 
     /**
      * add a "Select" selector entry on the selector list
      * @param selector the selector to be added
      */
     public void addSelector(SelectSelector selector) {
         usedMatchingTask = true;
         super.addSelector(selector);
     }
 
     /**
      * add an "And" selector entry on the selector list
      * @param selector the selector to be added
      */
     public void addAnd(AndSelector selector) {
         usedMatchingTask = true;
         super.addAnd(selector);
     }
 
     /**
      * add an "Or" selector entry on the selector list
      * @param selector the selector to be added
      */
     public void addOr(OrSelector selector) {
         usedMatchingTask = true;
         super.addOr(selector);
     }
 
     /**
      * add a "Not" selector entry on the selector list
      * @param selector the selector to be added
      */
     public void addNot(NotSelector selector) {
         usedMatchingTask = true;
         super.addNot(selector);
     }
 
     /**
      * add a "None" selector entry on the selector list
      * @param selector the selector to be added
      */
     public void addNone(NoneSelector selector) {
         usedMatchingTask = true;
         super.addNone(selector);
     }
 
     /**
      * add a majority selector entry on the selector list
      * @param selector the selector to be added
      */
     public void addMajority(MajoritySelector selector) {
         usedMatchingTask = true;
         super.addMajority(selector);
     }
 
     /**
      * add a selector date entry on the selector list
      * @param selector the selector to be added
      */
     public void addDate(DateSelector selector) {
         usedMatchingTask = true;
         super.addDate(selector);
     }
 
     /**
      * add a selector size entry on the selector list
      * @param selector the selector to be added
      */
     public void addSize(SizeSelector selector) {
         usedMatchingTask = true;
         super.addSize(selector);
     }
 
     /**
      * add a selector filename entry on the selector list
      * @param selector the selector to be added
      */
     public void addFilename(FilenameSelector selector) {
         usedMatchingTask = true;
         super.addFilename(selector);
     }
 
     /**
      * add an extended selector entry on the selector list
      * @param selector the selector to be added
      */
     public void addCustom(ExtendSelector selector) {
         usedMatchingTask = true;
         super.addCustom(selector);
     }
 
     /**
      * add a contains selector entry on the selector list
      * @param selector the selector to be added
      */
     public void addContains(ContainsSelector selector) {
         usedMatchingTask = true;
         super.addContains(selector);
     }
 
     /**
      * add a present selector entry on the selector list
      * @param selector the selector to be added
      */
     public void addPresent(PresentSelector selector) {
         usedMatchingTask = true;
         super.addPresent(selector);
     }
 
     /**
      * add a depth selector entry on the selector list
      * @param selector the selector to be added
      */
     public void addDepth(DepthSelector selector) {
         usedMatchingTask = true;
         super.addDepth(selector);
     }
 
     /**
      * add a depends selector entry on the selector list
      * @param selector the selector to be added
      */
     public void addDepend(DependSelector selector) {
         usedMatchingTask = true;
         super.addDepend(selector);
     }
 
     /**
      * add a regular expression selector entry on the selector list
      * @param selector the selector to be added
      */
     public void addContainsRegexp(ContainsRegexpSelector selector) {
         usedMatchingTask = true;
         super.addContainsRegexp(selector);
     }
 
     /**
      * add the modified selector
      * @param selector the selector to add
      * @since ant 1.6
      */
     public void addModified(ModifiedSelector selector) {
         usedMatchingTask = true;
         super.addModified(selector);
     }
 
     /**
      * add an arbitrary selector
      * @param selector the selector to be added
      * @since Ant 1.6
      */
     public void add(FileSelector selector) {
         usedMatchingTask = true;
         super.add(selector);
     }
 
     /**
      * Delete the file(s).
      * @exception BuildException if an error occurs
      */
     public void execute() throws BuildException {
         if (usedMatchingTask) {
             log("DEPRECATED - Use of the implicit FileSet is deprecated.  "
                 + "Use a nested fileset element instead.", quiet ? Project.MSG_VERBOSE : verbosity);
         }
 
         if (file == null && dir == null && filesets.size() == 0 && rcs == null) {
             throw new BuildException("At least one of the file or dir "
                                      + "attributes, or a nested resource collection, "
                                      + "must be set.");
         }
 
         if (quiet && failonerror) {
             throw new BuildException("quiet and failonerror cannot both be "
                                      + "set to true", getLocation());
         }
 
         // delete the single file
         if (file != null) {
             if (file.exists()) {
                 if (file.isDirectory()) {
                     log("Directory " + file.getAbsolutePath()
                         + " cannot be removed using the file attribute.  "
                         + "Use dir instead.", quiet ? Project.MSG_VERBOSE : verbosity);
                 } else {
                     log("Deleting: " + file.getAbsolutePath());
 
                     if (!delete(file)) {
                         handle("Unable to delete file " + file.getAbsolutePath());
                     }
                 }
             } else if (isDanglingSymlink(file)) {
                 log("Trying to delete file " + file.getAbsolutePath()
                     + " which looks like a broken symlink.",
                     quiet ? Project.MSG_VERBOSE : verbosity);
                 if (!delete(file)) {
                     handle("Unable to delete file " + file.getAbsolutePath());
                 }
             } else {
                 log("Could not find file " + file.getAbsolutePath()
                     + " to delete.", quiet ? Project.MSG_VERBOSE : verbosity);
             }
         }
 
         // delete the directory
         if (dir != null && !usedMatchingTask) {
             if (dir.exists() && dir.isDirectory()) {
                 /*
                   If verbosity is MSG_VERBOSE, that mean we are doing
                   regular logging (backwards as that sounds).  In that
                   case, we want to print one message about deleting the
                   top of the directory tree.  Otherwise, the removeDir
                   method will handle messages for _all_ directories.
                 */
                 if (verbosity == Project.MSG_VERBOSE) {
                     log("Deleting directory " + dir.getAbsolutePath());
                 }
                 removeDir(dir);
             } else if (isDanglingSymlink(dir)) {
                 log("Trying to delete directory " + dir.getAbsolutePath()
                     + " which looks like a broken symlink.",
                     quiet ? Project.MSG_VERBOSE : verbosity);
                 if (!delete(dir)) {
                     handle("Unable to delete directory "
                            + dir.getAbsolutePath());
                 }
             }
         }
         Resources resourcesToDelete = new Resources();
         resourcesToDelete.setProject(getProject());
         resourcesToDelete.setCache(true);
         Resources filesetDirs = new Resources();
         filesetDirs.setProject(getProject());
         filesetDirs.setCache(true);
         FileSet implicit = null;
         if (usedMatchingTask && dir != null && dir.isDirectory()) {
             //add the files from the default fileset:
             implicit = getImplicitFileSet();
             implicit.setProject(getProject());
             filesets.add(implicit);
         }
 
-        for (int i = 0, size = filesets.size(); i < size; i++) {
+        final int size = filesets.size();
+        for (int i = 0; i < size; i++) {
             FileSet fs = (FileSet) filesets.get(i);
             if (fs.getProject() == null) {
                 log("Deleting fileset with no project specified;"
                     + " assuming executing project", Project.MSG_VERBOSE);
                 fs = (FileSet) fs.clone();
                 fs.setProject(getProject());
             }
             final File fsDir = fs.getDir();
             if (!fs.getErrorOnMissingDir() &&
                 (fsDir == null || !fsDir.exists())) {
                 continue;
             }
             if (fsDir == null) {
                 throw new BuildException(
                         "File or Resource without directory or file specified");
             } else if (!fsDir.isDirectory()) {
                 handle("Directory does not exist: " + fsDir);
             } else {
                 DirectoryScanner ds = fs.getDirectoryScanner();
                 // the previous line has already scanned the
                 // filesystem, in order to avoid a rescan when later
                 // iterating, capture the results now and store them
                 final String[] files = ds.getIncludedFiles();
                 resourcesToDelete.add(new ResourceCollection() {
                         public boolean isFilesystemOnly() {
                             return true;
                         }
                         public int size() {
                             return files.length;
                         }
                         public Iterator iterator() {
                             return new FileResourceIterator(getProject(),
                                                             fsDir, files);
                         }
                     });
                 if (includeEmpty) {
                     filesetDirs.add(new ReverseDirs(getProject(), fsDir,
                                                     ds
                                                     .getIncludedDirectories()));
                 }
 
                 if (removeNotFollowedSymlinks) {
                     String[] n = ds.getNotFollowedSymlinks();
                     if (n.length > 0) {
                         String[] links = new String[n.length];
                         System.arraycopy(n, 0, links, 0, n.length);
                         Arrays.sort(links, ReverseDirs.REVERSE);
                         for (int l = 0; l < links.length; l++) {
                             try {
                                 SYMLINK_UTILS
                                     .deleteSymbolicLink(new File(links[l]),
                                                         this);
                             } catch (java.io.IOException ex) {
                                 handle(ex);
                             }
                         }
                     }
                 }
             }
         }
         resourcesToDelete.add(filesetDirs);
         if (rcs != null) {
             // sort first to files, then dirs
             Restrict exists = new Restrict();
             exists.add(EXISTS);
             exists.add(rcs);
             Sort s = new Sort();
             s.add(REVERSE_FILESYSTEM);
             s.add(exists);
             resourcesToDelete.add(s);
         }
         try {
             if (resourcesToDelete.isFilesystemOnly()) {
                 for (Iterator iter = resourcesToDelete.iterator(); iter.hasNext();) {
                     // nonexistent resources could only occur if we already
                     // deleted something from a fileset:
                     Resource r = (Resource) iter.next();
                     File f = ((FileProvider) r.as(FileProvider.class))
                               .getFile();
                     if (!f.exists()) {
                         continue;
                     }
                     if (!(f.isDirectory()) || f.list().length == 0) {
                         log("Deleting " + f, verbosity);
                         if (!delete(f) && failonerror) {
                             handle("Unable to delete "
                                 + (f.isDirectory() ? "directory " : "file ") + f);
                         }
                     }
                 }
             } else {
                  handle(getTaskName() + " handles only filesystem resources");
             }
         } catch (Exception e) {
             handle(e);
         } finally {
             if (implicit != null) {
                 filesets.remove(implicit);
             }
         }
     }
 
 //************************************************************************
 //  protected and private methods
 //************************************************************************
 
     private void handle(String msg) {
         handle(new BuildException(msg));
     }
 
     private void handle(Exception e) {
         if (failonerror) {
             throw (e instanceof BuildException)
                 ? (BuildException) e : new BuildException(e);
         }
         log(e, quiet ? Project.MSG_VERBOSE : verbosity);
     }
 
     /**
      * Accommodate Windows bug encountered in both Sun and IBM JDKs.
      * Others possible. If the delete does not work, call System.gc(),
      * wait a little and try again.
      */
     private boolean delete(File f) {
         if (!FILE_UTILS.tryHardToDelete(f)) {
             if (deleteOnExit) {
                 int level = quiet ? Project.MSG_VERBOSE : Project.MSG_INFO;
                 log("Failed to delete " + f + ", calling deleteOnExit."
                     + " This attempts to delete the file when the Ant jvm"
                     + " has exited and might not succeed.", level);
                 f.deleteOnExit();
                 return true;
             }
             return false;
         }
         return true;
     }
 
     /**
      * Delete a directory
      *
      * @param d the directory to delete
      */
     protected void removeDir(File d) {
         String[] list = d.list();
         if (list == null) {
             list = new String[0];
         }
         for (int i = 0; i < list.length; i++) {
             String s = list[i];
             File f = new File(d, s);
             if (f.isDirectory()) {
                 removeDir(f);
             } else {
                 log("Deleting " + f.getAbsolutePath(), quiet ? Project.MSG_VERBOSE : verbosity);
                 if (!delete(f)) {
                     handle("Unable to delete file " + f.getAbsolutePath());
                 }
             }
         }
         log("Deleting directory " + d.getAbsolutePath(), verbosity);
         if (!delete(d)) {
             handle("Unable to delete directory " + d.getAbsolutePath());
         }
     }
 
     /**
      * remove an array of files in a directory, and a list of subdirectories
      * which will only be deleted if 'includeEmpty' is true
      * @param d directory to work from
      * @param files array of files to delete; can be of zero length
      * @param dirs array of directories to delete; can of zero length
      */
     protected void removeFiles(File d, String[] files, String[] dirs) {
         if (files.length > 0) {
             log("Deleting " + files.length + " files from "
                 + d.getAbsolutePath(), quiet ? Project.MSG_VERBOSE : verbosity);
             for (int j = 0; j < files.length; j++) {
                 File f = new File(d, files[j]);
                 log("Deleting " + f.getAbsolutePath(),
                         quiet ? Project.MSG_VERBOSE : verbosity);
                 if (!delete(f)) {
                     handle("Unable to delete file " + f.getAbsolutePath());
                 }
             }
         }
 
         if (dirs.length > 0 && includeEmpty) {
             int dirCount = 0;
             for (int j = dirs.length - 1; j >= 0; j--) {
                 File currDir = new File(d, dirs[j]);
                 String[] dirFiles = currDir.list();
                 if (dirFiles == null || dirFiles.length == 0) {
                     log("Deleting " + currDir.getAbsolutePath(),
                             quiet ? Project.MSG_VERBOSE : verbosity);
                     if (!delete(currDir)) {
                         handle("Unable to delete directory "
                                 + currDir.getAbsolutePath());
                     } else {
                         dirCount++;
                     }
                 }
             }
 
             if (dirCount > 0) {
                 log("Deleted "
                      + dirCount
                      + " director" + (dirCount == 1 ? "y" : "ies")
                      + " form " + d.getAbsolutePath(),
                      quiet ? Project.MSG_VERBOSE : verbosity);
             }
         }
     }
 
     private boolean isDanglingSymlink(File f) {
         try {
             return SYMLINK_UTILS.isDanglingSymbolicLink(f);
         } catch (java.io.IOException e) {
             log("Error while trying to detect " + f.getAbsolutePath()
                 + " as broken symbolic link. " + e.getMessage(),
                 quiet ? Project.MSG_VERBOSE : verbosity);
             return false;
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/ExecuteOn.java b/src/main/org/apache/tools/ant/taskdefs/ExecuteOn.java
index b8f0c24f9..ca4f2c67f 100644
--- a/src/main/org/apache/tools/ant/taskdefs/ExecuteOn.java
+++ b/src/main/org/apache/tools/ant/taskdefs/ExecuteOn.java
@@ -1,785 +1,786 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.IOException;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.types.AbstractFileSet;
 import org.apache.tools.ant.types.DirSet;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.FileList;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.Mapper;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.ResourceUtils;
 import org.apache.tools.ant.util.SourceFileScanner;
 
 /**
  * Executes a given command, supplying a set of files as arguments.
  *
  * @since Ant 1.2
  *
  * @ant.task category="control" name="apply"
  */
 public class ExecuteOn extends ExecTask {
 
     // CheckStyle:VisibilityModifier OFF - bc
 
     // filesets has been protected so we need to keep that even after
     // switching to resource collections.  In fact, they will still
     // get a different treatment form the other resource collections
     // even in execute since we have some subtle special features like
     // switching type to "dir" when we encounter a DirSet that would
     // be more difficult to achieve otherwise.
 
     protected Vector filesets = new Vector(); // contains AbstractFileSet
                                               // (both DirSet and FileSet)
     private Union resources = null;
     private boolean relative = false;
     private boolean parallel = false;
     private boolean forwardSlash = false;
     protected String type = FileDirBoth.FILE;
     protected Commandline.Marker srcFilePos = null;
     private boolean skipEmpty = false;
     protected Commandline.Marker targetFilePos = null;
     protected Mapper mapperElement = null;
     protected FileNameMapper mapper = null;
     protected File destDir = null;
     private int maxParallel = -1;
     private boolean addSourceFile = true;
     private boolean verbose = false;
     private boolean ignoreMissing = true;
     private boolean force = false;
 
     /**
      * Has &lt;srcfile&gt; been specified before &lt;targetfile&gt;
      */
     protected boolean srcIsFirst = true;
 
     // CheckStyle:VisibilityModifier ON
     /**
      * Add a set of files upon which to operate.
      * @param set the FileSet to add.
      */
     public void addFileset(FileSet set) {
         filesets.addElement(set);
     }
 
     /**
      * Add a set of directories upon which to operate.
      *
      * @param  set the DirSet to add.
      *
      * @since Ant 1.6
      */
     public void addDirset(DirSet set) {
         filesets.addElement(set);
     }
 
     /**
      * Add a list of source files upon which to operate.
      * @param list the FileList to add.
      */
     public void addFilelist(FileList list) {
         add(list);
     }
 
     /**
      * Add a collection of resources upon which to operate.
      * @param rc resource collection to add.
      * @since Ant 1.7
      */
     public void add(ResourceCollection rc) {
         if (resources == null) {
             resources = new Union();
         }
         resources.add(rc);
     }
 
     /**
      * Set whether the filenames should be passed on the command line as
      * absolute or relative pathnames. Paths are relative to the base
      * directory of the corresponding fileset for source files or the
      * dest attribute for target files.
      * @param relative whether to pass relative pathnames.
      */
     public void setRelative(boolean relative) {
         this.relative = relative;
     }
 
 
     /**
      * Set whether to execute in parallel mode.
      * If true, run the command only once, appending all files as arguments.
      * If false, command will be executed once for every file. Defaults to false.
      * @param parallel whether to run in parallel.
      */
     public void setParallel(boolean parallel) {
         this.parallel = parallel;
     }
 
     /**
      * Set whether the command works only on files, directories or both.
      * @param type a FileDirBoth EnumeratedAttribute.
      */
     public void setType(FileDirBoth type) {
         this.type = type.getValue();
     }
 
     /**
      * Set whether empty filesets will be skipped.  If true and
      * no source files have been found or are newer than their
      * corresponding target files, the command will not be run.
      * @param skip whether to skip empty filesets.
      */
     public void setSkipEmptyFilesets(boolean skip) {
         skipEmpty = skip;
     }
 
     /**
      * Specify the directory where target files are to be placed.
      * @param destDir the File object representing the destination directory.
      */
     public void setDest(File destDir) {
         this.destDir = destDir;
     }
 
     /**
      * Set whether the source and target file names on Windows and OS/2
      * must use the forward slash as file separator.
      * @param forwardSlash whether the forward slash will be forced.
      */
     public void setForwardslash(boolean forwardSlash) {
         this.forwardSlash = forwardSlash;
     }
 
     /**
      * Limit the command line length by passing at maximum this many
      * sourcefiles at once to the command.
      *
      * <p>Set to &lt;= 0 for unlimited - this is the default.</p>
      *
      * @param max <code>int</code> maximum number of sourcefiles
      *            passed to the executable.
      *
      * @since Ant 1.6
      */
     public void setMaxParallel(int max) {
         maxParallel = max;
     }
 
     /**
      * Set whether to send the source file name on the command line.
      *
      * <p>Defaults to <code>true</code>.
      *
      * @param b whether to add the source file to the command line.
      *
      * @since Ant 1.6
      */
     public void setAddsourcefile(boolean b) {
         addSourceFile = b;
     }
 
     /**
      * Set whether to operate in verbose mode.
      * If true, a verbose summary will be printed after execution.
      * @param b whether to operate in verbose mode.
      *
      * @since Ant 1.6
      */
     public void setVerbose(boolean b) {
         verbose = b;
     }
 
     /**
      * Set whether to ignore nonexistent files from filelists.
      * @param b whether to ignore missing files.
      *
      * @since Ant 1.6.2
      */
     public void setIgnoremissing(boolean b) {
         ignoreMissing = b;
     }
 
     /**
      * Set whether to bypass timestamp comparisons for target files.
      * @param b whether to bypass timestamp comparisons.
      *
      * @since Ant 1.6.3
      */
     public void setForce(boolean b) {
         force = b;
     }
 
     /**
      * Create a placeholder indicating where on the command line
      * the name of the source file should be inserted.
      * @return <code>Commandline.Marker</code>.
      */
     public Commandline.Marker createSrcfile() {
         if (srcFilePos != null) {
             throw new BuildException(getTaskType() + " doesn\'t support multiple "
                                      + "srcfile elements.", getLocation());
         }
         srcFilePos = cmdl.createMarker();
         return srcFilePos;
     }
 
     /**
      * Create a placeholder indicating where on the command line
      * the name of the target file should be inserted.
      * @return <code>Commandline.Marker</code>.
      */
     public Commandline.Marker createTargetfile() {
         if (targetFilePos != null) {
             throw new BuildException(getTaskType() + " doesn\'t support multiple "
                                      + "targetfile elements.", getLocation());
         }
         targetFilePos = cmdl.createMarker();
         srcIsFirst = (srcFilePos != null);
         return targetFilePos;
     }
 
     /**
      * Create a nested Mapper element to use for mapping
      * source files to target files.
      * @return <code>Mapper</code>.
      * @throws BuildException if more than one mapper is defined.
      */
     public Mapper createMapper() throws BuildException {
         if (mapperElement != null) {
             throw new BuildException("Cannot define more than one mapper",
                                      getLocation());
         }
         mapperElement = new Mapper(getProject());
         return mapperElement;
     }
 
     /**
      * Add a nested FileNameMapper.
      * @param fileNameMapper the mapper to add.
      * @since Ant 1.6.3
      */
     public void add(FileNameMapper fileNameMapper) {
         createMapper().add(fileNameMapper);
     }
 
     /**
      * Check the configuration of this ExecuteOn instance.
      */
     protected void checkConfiguration() {
 //     * @TODO using taskName here is brittle, as a user could override it.
 //     *       this should probably be modified to use the classname instead.
         if ("execon".equals(getTaskName())) {
             log("!! execon is deprecated. Use apply instead. !!");
         }
         super.checkConfiguration();
         if (filesets.size() == 0 && resources == null) {
             throw new BuildException("no resources specified",
                                      getLocation());
         }
         if (targetFilePos != null && mapperElement == null) {
             throw new BuildException("targetfile specified without mapper",
                                      getLocation());
         }
         if (destDir != null && mapperElement == null) {
             throw new BuildException("dest specified without mapper",
                                      getLocation());
         }
         if (mapperElement != null) {
             mapper = mapperElement.getImplementation();
         }
     }
 
     /**
      * Create the ExecuteStreamHandler instance that will be used
      * during execution.
      * @return <code>ExecuteStreamHandler</code>.
      * @throws BuildException on error.
      */
     protected ExecuteStreamHandler createHandler() throws BuildException {
         //if we have a RedirectorElement, return a decoy
         return (redirectorElement == null)
             ? super.createHandler() : new PumpStreamHandler();
     }
 
     /**
      * Set up the I/O Redirector.
      */
     protected void setupRedirector() {
         super.setupRedirector();
         redirector.setAppendProperties(true);
     }
 
     /**
      * Run the specified Execute object.
      * @param exe the Execute instance representing the external process.
      * @throws BuildException on error
      */
     protected void runExec(Execute exe) throws BuildException {
         int totalFiles = 0;
         int totalDirs = 0;
         boolean haveExecuted = false;
         try {
             Vector fileNames = new Vector();
             Vector baseDirs = new Vector();
-            for (int i = 0; i < filesets.size(); i++) {
+            final int size = filesets.size();
+            for (int i = 0; i < size; i++) {
                 String currentType = type;
                 AbstractFileSet fs = (AbstractFileSet) filesets.elementAt(i);
                 if (fs instanceof DirSet) {
                     if (!FileDirBoth.DIR.equals(type)) {
                         log("Found a nested dirset but type is " + type + ". "
                             + "Temporarily switching to type=\"dir\" on the"
                             + " assumption that you really did mean"
                             + " <dirset> not <fileset>.", Project.MSG_DEBUG);
                         currentType = FileDirBoth.DIR;
                     }
                 }
                 File base = fs.getDir(getProject());
 
                 DirectoryScanner ds = fs.getDirectoryScanner(getProject());
 
                 if (!FileDirBoth.DIR.equals(currentType)) {
                     String[] s = getFiles(base, ds);
                     for (int j = 0; j < s.length; j++) {
                         totalFiles++;
                         fileNames.addElement(s[j]);
                         baseDirs.addElement(base);
                     }
                 }
                 if (!FileDirBoth.FILE.equals(currentType)) {
                     String[] s = getDirs(base, ds);
                     for (int j = 0; j < s.length; j++) {
                         totalDirs++;
                         fileNames.addElement(s[j]);
                         baseDirs.addElement(base);
                     }
                 }
                 if (fileNames.size() == 0 && skipEmpty) {
                     logSkippingFileset(currentType, ds, base);
                     continue;
                 }
                 if (!parallel) {
                     String[] s = new String[fileNames.size()];
                     fileNames.copyInto(s);
                     for (int j = 0; j < s.length; j++) {
                         String[] command = getCommandline(s[j], base);
                         log(Commandline.describeCommand(command),
                             Project.MSG_VERBOSE);
                         exe.setCommandline(command);
 
                         if (redirectorElement != null) {
                             setupRedirector();
                             redirectorElement.configure(redirector, s[j]);
                         }
                         if (redirectorElement != null || haveExecuted) {
                             // need to reset the stream handler to restart
                             // reading of pipes;
                             // go ahead and do it always w/ nested redirectors
                             exe.setStreamHandler(redirector.createHandler());
                         }
                         runExecute(exe);
                         haveExecuted = true;
                     }
                     fileNames.removeAllElements();
                     baseDirs.removeAllElements();
                 }
             }
 
             if (resources != null) {
                 Iterator iter = resources.iterator();
                 while (iter.hasNext()) {
                     Resource res = (Resource) iter.next();
 
                     if (!res.isExists() && ignoreMissing) {
                         continue;
                     }
 
                     File base = null;
                     String name = res.getName();
                     FileProvider fp = (FileProvider) res.as(FileProvider.class);
                     if (fp != null) {
                         FileResource fr = ResourceUtils.asFileResource(fp);
                         base = fr.getBaseDir();
                         if (base == null) {
                             name = fr.getFile().getAbsolutePath();
                         }
                     }
 
                     if (restrict(new String[] {name}, base).length == 0) {
                         continue;
                     }
 
                     if ((!res.isDirectory() || !res.isExists())
                         && !FileDirBoth.DIR.equals(type)) {
                         totalFiles++;
                     } else if (res.isDirectory()
                                && !FileDirBoth.FILE.equals(type)) {
                         totalDirs++;
                     } else {
                         continue;
                     }
 
                     baseDirs.add(base);
                     fileNames.add(name);
 
                     if (!parallel) {
                         String[] command = getCommandline(name, base);
                         log(Commandline.describeCommand(command),
                             Project.MSG_VERBOSE);
                         exe.setCommandline(command);
 
                         if (redirectorElement != null) {
                             setupRedirector();
                             redirectorElement.configure(redirector, name);
                         }
                         if (redirectorElement != null || haveExecuted) {
                             // need to reset the stream handler to restart
                             // reading of pipes;
                             // go ahead and do it always w/ nested redirectors
                             exe.setStreamHandler(redirector.createHandler());
                         }
                         runExecute(exe);
                         haveExecuted = true;
                         fileNames.removeAllElements();
                         baseDirs.removeAllElements();
                     }
                 }
             }
             if (parallel && (fileNames.size() > 0 || !skipEmpty)) {
                 runParallel(exe, fileNames, baseDirs);
                 haveExecuted = true;
             }
             if (haveExecuted) {
                 log("Applied " + cmdl.getExecutable() + " to "
                     + totalFiles + " file"
                     + (totalFiles != 1 ? "s" : "") + " and "
                     + totalDirs + " director"
                     + (totalDirs != 1 ? "ies" : "y") + ".",
                     verbose ? Project.MSG_INFO : Project.MSG_VERBOSE);
             }
         } catch (IOException e) {
             throw new BuildException("Execute failed: " + e, e, getLocation());
         } finally {
             // close the output file if required
             logFlush();
             redirector.setAppendProperties(false);
             redirector.setProperties();
         }
     }
 
     /**
      * log a message for skipping a fileset.
      * @param currentType the current type.
      * @param ds the directory scanner.
      * @param base the dir base
      */
     private void logSkippingFileset(
         String currentType, DirectoryScanner ds, File base) {
         int includedCount
             = ((!FileDirBoth.DIR.equals(currentType))
                ? ds.getIncludedFilesCount() : 0)
             + ((!FileDirBoth.FILE.equals(currentType))
                ? ds.getIncludedDirsCount() : 0);
 
         log("Skipping fileset for directory " + base + ". It is "
             + ((includedCount > 0) ? "up to date." : "empty."),
              verbose ? Project.MSG_INFO : Project.MSG_VERBOSE);
     }
 
     /**
      * Construct the command line for parallel execution.
      *
      * @param srcFiles The filenames to add to the commandline.
      * @param baseDirs filenames are relative to this dir.
      * @return the command line in the form of a String[].
      */
     protected String[] getCommandline(String[] srcFiles, File[] baseDirs) {
         final char fileSeparator = File.separatorChar;
         Vector targets = new Vector();
         if (targetFilePos != null) {
             HashSet addedFiles = new HashSet();
             for (int i = 0; i < srcFiles.length; i++) {
                 String[] subTargets = mapper.mapFileName(srcFiles[i]);
                 if (subTargets != null) {
                     for (int j = 0; j < subTargets.length; j++) {
                         String name = null;
                         if (!relative) {
                             name = (new File(destDir, subTargets[j])).getAbsolutePath();
                         } else {
                             name = subTargets[j];
                         }
                         if (forwardSlash && fileSeparator != '/') {
                             name = name.replace(fileSeparator, '/');
                         }
                         if (!addedFiles.contains(name)) {
                             targets.addElement(name);
                             addedFiles.add(name);
                         }
                     }
                 }
             }
         }
         String[] targetFiles = (String[]) targets.toArray(new String[targets.size()]);
 
         if (!addSourceFile) {
             srcFiles = new String[0];
         }
         String[] orig = cmdl.getCommandline();
         String[] result
             = new String[orig.length + srcFiles.length + targetFiles.length];
 
         int srcIndex = orig.length;
         if (srcFilePos != null) {
             srcIndex = srcFilePos.getPosition();
         }
         if (targetFilePos != null) {
             int targetIndex = targetFilePos.getPosition();
 
             if (srcIndex < targetIndex
                 || (srcIndex == targetIndex && srcIsFirst)) {
 
                 // 0 --> srcIndex
                 System.arraycopy(orig, 0, result, 0, srcIndex);
 
                 // srcIndex --> targetIndex
                 System.arraycopy(orig, srcIndex, result,
                                  srcIndex + srcFiles.length,
                                  targetIndex - srcIndex);
 
                 insertTargetFiles(targetFiles, result,
                                   targetIndex + srcFiles.length,
                                   targetFilePos.getPrefix(),
                                   targetFilePos.getSuffix());
 
                 // targetIndex --> end
                 System.arraycopy(orig, targetIndex, result,
                     targetIndex + srcFiles.length + targetFiles.length,
                     orig.length - targetIndex);
             } else {
                 // 0 --> targetIndex
                 System.arraycopy(orig, 0, result, 0, targetIndex);
 
                 insertTargetFiles(targetFiles, result, targetIndex,
                                   targetFilePos.getPrefix(),
                                   targetFilePos.getSuffix());
 
                 // targetIndex --> srcIndex
                 System.arraycopy(orig, targetIndex, result,
                                  targetIndex + targetFiles.length,
                                  srcIndex - targetIndex);
 
                 // srcIndex --> end
                 System.arraycopy(orig, srcIndex, result,
                     srcIndex + srcFiles.length + targetFiles.length,
                     orig.length - srcIndex);
                 srcIndex += targetFiles.length;
             }
 
         } else { // no targetFilePos
 
             // 0 --> srcIndex
             System.arraycopy(orig, 0, result, 0, srcIndex);
             // srcIndex --> end
             System.arraycopy(orig, srcIndex, result,
                              srcIndex + srcFiles.length,
                              orig.length - srcIndex);
         }
         // fill in source file names
         for (int i = 0; i < srcFiles.length; i++) {
             String src;
             if (relative) {
                 src = srcFiles[i];
             } else {
                 src = new File(baseDirs[i], srcFiles[i]).getAbsolutePath();
             }
             if (forwardSlash && fileSeparator != '/') {
                 src = src.replace(fileSeparator, '/');
             }
             if (srcFilePos != null &&
                 (srcFilePos.getPrefix().length() > 0
                  || srcFilePos.getSuffix().length() > 0)) {
                 src = srcFilePos.getPrefix() + src + srcFilePos.getSuffix();
             }
             result[srcIndex + i] = src;
         }
         return result;
     }
 
     /**
      * Construct the command line for serial execution.
      *
      * @param srcFile The filename to add to the commandline.
      * @param baseDir filename is relative to this dir.
      * @return the command line in the form of a String[].
      */
     protected String[] getCommandline(String srcFile, File baseDir) {
         return getCommandline(new String[] {srcFile}, new File[] {baseDir});
     }
 
     /**
      * Return the list of files from this DirectoryScanner that should
      * be included on the command line.
      * @param baseDir the File base directory.
      * @param ds the DirectoryScanner to use for file scanning.
      * @return a String[] containing the filenames.
      */
     protected String[] getFiles(File baseDir, DirectoryScanner ds) {
         return restrict(ds.getIncludedFiles(), baseDir);
     }
 
     /**
      * Return the list of Directories from this DirectoryScanner that
      * should be included on the command line.
      * @param baseDir the File base directory.
      * @param ds the DirectoryScanner to use for file scanning.
      * @return a String[] containing the directory names.
      */
     protected String[] getDirs(File baseDir, DirectoryScanner ds) {
         return restrict(ds.getIncludedDirectories(), baseDir);
     }
 
     /**
      * Return the list of files or directories from this FileList that
      * should be included on the command line.
      * @param list the FileList to check.
      * @return a String[] containing the directory names.
      *
      * @since Ant 1.6.2
      */
     protected String[] getFilesAndDirs(FileList list) {
         return restrict(list.getFiles(getProject()), list.getDir(getProject()));
     }
 
     private String[] restrict(String[] s, File baseDir) {
         return (mapper == null || force) ? s
             : new SourceFileScanner(this).restrict(s, baseDir, destDir, mapper);
     }
 
     /**
      * Run the command in "parallel" mode, making sure that at most
      * maxParallel sourcefiles get passed on the command line.
      * @param exe the Executable to use.
      * @param fileNames the Vector of filenames.
      * @param baseDirs the Vector of base directories corresponding to fileNames.
      * @throws IOException  on I/O errors.
      * @throws BuildException on other errors.
      * @since Ant 1.6
      */
     protected void runParallel(Execute exe, Vector fileNames,
                                Vector baseDirs)
         throws IOException, BuildException {
         String[] s = new String[fileNames.size()];
         fileNames.copyInto(s);
         File[] b = new File[baseDirs.size()];
         baseDirs.copyInto(b);
 
         if (maxParallel <= 0
             || s.length == 0 /* this is skipEmpty == false */) {
             String[] command = getCommandline(s, b);
             log(Commandline.describeCommand(command), Project.MSG_VERBOSE);
             exe.setCommandline(command);
             if (redirectorElement != null) {
                 setupRedirector();
                 redirectorElement.configure(redirector, null);
                 exe.setStreamHandler(redirector.createHandler());
             }
             runExecute(exe);
         } else {
             int stillToDo = fileNames.size();
             int currentOffset = 0;
             while (stillToDo > 0) {
                 int currentAmount = Math.min(stillToDo, maxParallel);
                 String[] cs = new String[currentAmount];
                 System.arraycopy(s, currentOffset, cs, 0, currentAmount);
                 File[] cb = new File[currentAmount];
                 System.arraycopy(b, currentOffset, cb, 0, currentAmount);
                 String[] command = getCommandline(cs, cb);
                 log(Commandline.describeCommand(command), Project.MSG_VERBOSE);
                 exe.setCommandline(command);
                 if (redirectorElement != null) {
                     setupRedirector();
                     redirectorElement.configure(redirector, null);
                 }
                 if (redirectorElement != null || currentOffset > 0) {
                     // need to reset the stream handler to restart
                     // reading of pipes;
                     // go ahead and do it always w/ nested redirectors
                     exe.setStreamHandler(redirector.createHandler());
                 }
                 runExecute(exe);
 
                 stillToDo -= currentAmount;
                 currentOffset += currentAmount;
             }
         }
     }
 
     /**
      * Inserts target file names (which are already absolute paths)
      * into the list of arguments, taking prefix and postfix into
      * account.
      */
     private static void insertTargetFiles(String[] targetFiles,
                                           String[] arguments,
                                           int insertPosition,
                                           String prefix, String suffix) {
         if (prefix.length() == 0 && suffix.length() == 0) {
             System.arraycopy(targetFiles, 0, arguments, insertPosition,
                              targetFiles.length);
         } else {
             for (int i = 0; i < targetFiles.length; i++) {
                 arguments[insertPosition + i] =
                     prefix + targetFiles[i] + suffix;
             }
         }
     }
 
     /**
      * Enumerated attribute with the values "file", "dir" and "both"
      * for the type attribute.
      */
     public static class FileDirBoth extends EnumeratedAttribute {
         /** File value */
         public static final String FILE = "file";
         /** Dir value */
         public static final String DIR = "dir";
         /**
          * @see EnumeratedAttribute#getValues
          */
         /** {@inheritDoc}. */
        public String[] getValues() {
             return new String[] {FILE, DIR, "both"};
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Expand.java b/src/main/org/apache/tools/ant/taskdefs/Expand.java
index 741ad9df7..696cbbf08 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Expand.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Expand.java
@@ -1,512 +1,513 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.Vector;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.Mapper;
 import org.apache.tools.ant.types.PatternSet;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.types.selectors.SelectorUtils;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.IdentityMapper;
 import org.apache.tools.zip.ZipEntry;
 import org.apache.tools.zip.ZipFile;
 
 /**
  * Unzip a file.
  *
  * @since Ant 1.1
  *
  * @ant.task category="packaging"
  *           name="unzip"
  *           name="unjar"
  *           name="unwar"
  */
 public class Expand extends Task {
     private static final int BUFFER_SIZE = 1024;
     private File dest; //req
     private File source; // req
     private boolean overwrite = true;
     private Mapper mapperElement = null;
     private Vector patternsets = new Vector();
     private Union resources = new Union();
     private boolean resourcesSpecified = false;
     private boolean failOnEmptyArchive = false;
     private boolean stripAbsolutePathSpec = false;
     private boolean scanForUnicodeExtraFields = true;
 
     public static final String NATIVE_ENCODING = "native-encoding";
 
     private String encoding = "UTF8";
     /** Error message when more that one mapper is defined */
     public static final String ERROR_MULTIPLE_MAPPERS = "Cannot define more than one mapper";
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * Whether try ing to expand an empty archive would be an error.
      *
      * @since Ant 1.8.0
      */
     public void setFailOnEmptyArchive(boolean b) {
         failOnEmptyArchive = b;
     }
 
     /**
      * Whether try ing to expand an empty archive would be an error.
      *
      * @since Ant 1.8.0
      */
     public boolean getFailOnEmptyArchive() {
         return failOnEmptyArchive;
     }
 
     /**
      * Do the work.
      *
      * @exception BuildException Thrown in unrecoverable error.
      */
     public void execute() throws BuildException {
         if ("expand".equals(getTaskType())) {
             log("!! expand is deprecated. Use unzip instead. !!");
         }
 
         if (source == null && !resourcesSpecified) {
             throw new BuildException("src attribute and/or resources must be "
                                      + "specified");
         }
 
         if (dest == null) {
             throw new BuildException(
                 "Dest attribute must be specified");
         }
 
         if (dest.exists() && !dest.isDirectory()) {
             throw new BuildException("Dest must be a directory.", getLocation());
         }
 
         if (source != null) {
             if (source.isDirectory()) {
                 throw new BuildException("Src must not be a directory."
                     + " Use nested filesets instead.", getLocation());
             } else if (!source.exists()) {
                 throw new BuildException("src '" + source + "' doesn't exist.");
             } else if (!source.canRead()) {
                 throw new BuildException("src '" + source + "' cannot be read.");
             } else {
                 expandFile(FILE_UTILS, source, dest);
             }
         }
         Iterator iter = resources.iterator();
         while (iter.hasNext()) {
             Resource r = (Resource) iter.next();
             if (!r.isExists()) {
                 log("Skipping '" + r.getName() + "' because it doesn't exist.");
                 continue;
             }
 
             FileProvider fp = (FileProvider) r.as(FileProvider.class);
             if (fp != null) {
                 expandFile(FILE_UTILS, fp.getFile(), dest);
             } else {
                 expandResource(r, dest);
             }
         }
     }
 
     /**
      * This method is to be overridden by extending unarchival tasks.
      *
      * @param fileUtils the fileUtils
      * @param srcF      the source file
      * @param dir       the destination directory
      */
     protected void expandFile(FileUtils fileUtils, File srcF, File dir) {
         log("Expanding: " + srcF + " into " + dir, Project.MSG_INFO);
         ZipFile zf = null;
         FileNameMapper mapper = getMapper();
         if (!srcF.exists()) {
             throw new BuildException("Unable to expand "
                     + srcF
                     + " as the file does not exist",
                     getLocation());
         }
         try {
             zf = new ZipFile(srcF, encoding, scanForUnicodeExtraFields);
             boolean empty = true;
             Enumeration e = zf.getEntries();
             while (e.hasMoreElements()) {
                 empty = false;
                 ZipEntry ze = (ZipEntry) e.nextElement();
                 InputStream is = null;
                 log("extracting " + ze.getName(), Project.MSG_DEBUG);
                 try {
                     extractFile(fileUtils, srcF, dir,
                                 is = zf.getInputStream(ze),
                                 ze.getName(), new Date(ze.getTime()),
                                 ze.isDirectory(), mapper);
                 } finally {
                     FileUtils.close(is);
                 }
             }
             if (empty && getFailOnEmptyArchive()) {
                 throw new BuildException("archive '" + srcF + "' is empty");
             }
             log("expand complete", Project.MSG_VERBOSE);
         } catch (IOException ioe) {
             throw new BuildException(
                 "Error while expanding " + srcF.getPath()
                 + "\n" + ioe.toString(),
                 ioe);
         } finally {
             ZipFile.closeQuietly(zf);
         }
     }
 
     /**
      * This method is to be overridden by extending unarchival tasks.
      *
      * @param srcR      the source resource
      * @param dir       the destination directory
      */
     protected void expandResource(Resource srcR, File dir) {
         throw new BuildException("only filesystem based resources are"
                                  + " supported by this task.");
     }
 
     /**
      * get a mapper for a file
      * @return a filenamemapper for a file
      */
     protected FileNameMapper getMapper() {
         FileNameMapper mapper = null;
         if (mapperElement != null) {
             mapper = mapperElement.getImplementation();
         } else {
             mapper = new IdentityMapper();
         }
         return mapper;
     }
 
     // CheckStyle:ParameterNumberCheck OFF - bc
     /**
      * extract a file to a directory
      * @param fileUtils             a fileUtils object
      * @param srcF                  the source file
      * @param dir                   the destination directory
      * @param compressedInputStream the input stream
      * @param entryName             the name of the entry
      * @param entryDate             the date of the entry
      * @param isDirectory           if this is true the entry is a directory
      * @param mapper                the filename mapper to use
      * @throws IOException on error
      */
     protected void extractFile(FileUtils fileUtils, File srcF, File dir,
                                InputStream compressedInputStream,
                                String entryName, Date entryDate,
                                boolean isDirectory, FileNameMapper mapper)
                                throws IOException {
 
         if (stripAbsolutePathSpec && entryName.length() > 0
             && (entryName.charAt(0) == File.separatorChar
                 || entryName.charAt(0) == '/'
                 || entryName.charAt(0) == '\\')) {
             log("stripped absolute path spec from " + entryName,
                 Project.MSG_VERBOSE);
             entryName = entryName.substring(1);
         }
 
         if (patternsets != null && patternsets.size() > 0) {
             String name = entryName.replace('/', File.separatorChar)
                 .replace('\\', File.separatorChar);
 
             boolean included = false;
             Set includePatterns = new HashSet();
             Set excludePatterns = new HashSet();
-            for (int v = 0, size = patternsets.size(); v < size; v++) {
+            final int size = patternsets.size();
+            for (int v = 0; v < size; v++) {
                 PatternSet p = (PatternSet) patternsets.elementAt(v);
                 String[] incls = p.getIncludePatterns(getProject());
                 if (incls == null || incls.length == 0) {
                     // no include pattern implicitly means includes="**"
                     incls = new String[] {"**"};
                 }
 
                 for (int w = 0; w < incls.length; w++) {
                     String pattern = incls[w].replace('/', File.separatorChar)
                         .replace('\\', File.separatorChar);
                     if (pattern.endsWith(File.separator)) {
                         pattern += "**";
                     }
                     includePatterns.add(pattern);
                 }
 
                 String[] excls = p.getExcludePatterns(getProject());
                 if (excls != null) {
                     for (int w = 0; w < excls.length; w++) {
                         String pattern = excls[w]
                             .replace('/', File.separatorChar)
                             .replace('\\', File.separatorChar);
                         if (pattern.endsWith(File.separator)) {
                             pattern += "**";
                         }
                         excludePatterns.add(pattern);
                     }
                 }
             }
 
             for (Iterator iter = includePatterns.iterator();
                  !included && iter.hasNext();) {
                 String pattern = (String) iter.next();
                 included = SelectorUtils.matchPath(pattern, name);
             }
 
             for (Iterator iter = excludePatterns.iterator();
                  included && iter.hasNext();) {
                 String pattern = (String) iter.next();
                 included = !SelectorUtils.matchPath(pattern, name);
             }
 
             if (!included) {
                 //Do not process this file
                 log("skipping " + entryName
                     + " as it is excluded or not included.",
                     Project.MSG_VERBOSE);
                 return;
             }
         }
         String[] mappedNames = mapper.mapFileName(entryName);
         if (mappedNames == null || mappedNames.length == 0) {
             mappedNames = new String[] {entryName};
         }
         File f = fileUtils.resolveFile(dir, mappedNames[0]);
         try {
             if (!overwrite && f.exists()
                 && f.lastModified() >= entryDate.getTime()) {
                 log("Skipping " + f + " as it is up-to-date",
                     Project.MSG_DEBUG);
                 return;
             }
 
             log("expanding " + entryName + " to " + f,
                 Project.MSG_VERBOSE);
             // create intermediary directories - sometimes zip don't add them
             File dirF = f.getParentFile();
             if (dirF != null) {
                 dirF.mkdirs();
             }
 
             if (isDirectory) {
                 f.mkdirs();
             } else {
                 byte[] buffer = new byte[BUFFER_SIZE];
                 int length = 0;
                 FileOutputStream fos = null;
                 try {
                     fos = new FileOutputStream(f);
 
                     while ((length =
                             compressedInputStream.read(buffer)) >= 0) {
                         fos.write(buffer, 0, length);
                     }
 
                     fos.close();
                     fos = null;
                 } finally {
                     FileUtils.close(fos);
                 }
             }
 
             fileUtils.setFileLastModified(f, entryDate.getTime());
         } catch (FileNotFoundException ex) {
             log("Unable to expand to file " + f.getPath(),
                     ex,
                     Project.MSG_WARN);
         }
 
     }
     // CheckStyle:ParameterNumberCheck ON
 
     /**
      * Set the destination directory. File will be unzipped into the
      * destination directory.
      *
      * @param d Path to the directory.
      */
     public void setDest(File d) {
         this.dest = d;
     }
 
     /**
      * Set the path to zip-file.
      *
      * @param s Path to zip-file.
      */
     public void setSrc(File s) {
         this.source = s;
     }
 
     /**
      * Should we overwrite files in dest, even if they are newer than
      * the corresponding entries in the archive?
      * @param b a <code>boolean</code> value
      */
     public void setOverwrite(boolean b) {
         overwrite = b;
     }
 
     /**
      * Add a patternset.
      * @param set a pattern set
      */
     public void addPatternset(PatternSet set) {
         patternsets.addElement(set);
     }
 
     /**
      * Add a fileset
      * @param set a file set
      */
     public void addFileset(FileSet set) {
         add(set);
     }
 
     /**
      * Add a resource collection.
      * @param rc a resource collection.
      * @since Ant 1.7
      */
     public void add(ResourceCollection rc) {
         resourcesSpecified = true;
         resources.add(rc);
     }
 
     /**
      * Defines the mapper to map source entries to destination files.
      * @return a mapper to be configured
      * @exception BuildException if more than one mapper is defined
      * @since Ant1.7
      */
     public Mapper createMapper() throws BuildException {
         if (mapperElement != null) {
             throw new BuildException(ERROR_MULTIPLE_MAPPERS,
                                      getLocation());
         }
         mapperElement = new Mapper(getProject());
         return mapperElement;
     }
 
     /**
      * A nested filenamemapper
      * @param fileNameMapper the mapper to add
      * @since Ant 1.6.3
      */
     public void add(FileNameMapper fileNameMapper) {
         createMapper().add(fileNameMapper);
     }
 
 
     /**
      * Sets the encoding to assume for file names and comments.
      *
      * <p>Set to <code>native-encoding</code> if you want your
      * platform's native encoding, defaults to UTF8.</p>
      * @param encoding the name of the character encoding
      * @since Ant 1.6
      */
     public void setEncoding(String encoding) {
         internalSetEncoding(encoding);
     }
 
     /**
      * Supports grand-children that want to support the attribute
      * where the child-class doesn't (i.e. Unzip in the compress
      * Antlib).
      *
      * @since Ant 1.8.0
      */
     protected void internalSetEncoding(String encoding) {
         if (NATIVE_ENCODING.equals(encoding)) {
             encoding = null;
         }
         this.encoding = encoding;
     }
 
     /**
      * @since Ant 1.8.0
      */
     public String getEncoding() {
         return encoding;
     }
 
     /**
      * Whether leading path separators should be stripped.
      *
      * @since Ant 1.8.0
      */
     public void setStripAbsolutePathSpec(boolean b) {
         stripAbsolutePathSpec = b;
     }
 
     /**
      * Whether unicode extra fields will be used if present.
      *
      * @since Ant 1.8.0
      */
     public void setScanForUnicodeExtraFields(boolean b) {
         internalSetScanForUnicodeExtraFields(b);
     }
 
     /**
      * Supports grand-children that want to support the attribute
      * where the child-class doesn't (i.e. Unzip in the compress
      * Antlib).
      *
      * @since Ant 1.8.0
      */
     protected void internalSetScanForUnicodeExtraFields(boolean b) {
         scanForUnicodeExtraFields = b;
     }
 
     /**
      * @since Ant 1.8.0
      */
     public boolean getScanForUnicodeExtraFields() {
         return scanForUnicodeExtraFields;
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Java.java b/src/main/org/apache/tools/ant/taskdefs/Java.java
index 19f4e32a6..e1553e8b0 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Java.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Java.java
@@ -1,963 +1,964 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.ExitException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.ExitStatusException;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.types.CommandlineJava;
 import org.apache.tools.ant.types.Environment;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.PropertySet;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.types.Assertions;
 import org.apache.tools.ant.types.Permissions;
 import org.apache.tools.ant.types.RedirectorElement;
 import org.apache.tools.ant.taskdefs.condition.Os;
 import org.apache.tools.ant.util.KeepAliveInputStream;
 
 /**
  * Launcher for Java applications. Allows use of
  * the same JVM for the called application thus resulting in much
  * faster operation.
  *
  * @since Ant 1.1
  *
  * @ant.task category="java"
  */
 public class Java extends Task {
 
     private CommandlineJava cmdl = new CommandlineJava();
     private Environment env = new Environment();
     private boolean fork = false;
     private boolean newEnvironment = false;
     private File dir = null;
     private boolean failOnError = false;
     private Long timeout = null;
 
     //include locally for screening purposes
     private String inputString;
     private File input;
     private File output;
     private File error;
 
     // CheckStyle:VisibilityModifier OFF - bc
     protected Redirector redirector = new Redirector(this);
     protected RedirectorElement redirectorElement;
     // CheckStyle:VisibilityModifier ON
 
     private String resultProperty;
     private Permissions perm = null;
 
     private boolean spawn = false;
     private boolean incompatibleWithSpawn = false;
 
     private static final String TIMEOUT_MESSAGE = 
         "Timeout: killed the sub-process";
 
     /**
      * Normal constructor
      */
     public Java() {
     }
 
     /**
      * create a bound task
      * @param owner owner
      */
     public Java(Task owner) {
         bindToOwner(owner);
     }
 
     /**
      * Do the execution.
      * @throws BuildException if failOnError is set to true and the application
      * returns a nonzero result code.
      */
     public void execute() throws BuildException {
         File savedDir = dir;
         Permissions savedPermissions = perm;
 
         int err = -1;
         try {
             checkConfiguration();
             err = executeJava();
             if (err != 0) {
                 if (failOnError) {
                     throw new ExitStatusException("Java returned: " + err,
                             err,
                             getLocation());
                 } else {
                     log("Java Result: " + err, Project.MSG_ERR);
                 }
             }
             maybeSetResultPropertyValue(err);
         } finally {
             dir = savedDir;
             perm = savedPermissions;
         }
     }
 
     /**
      * Do the execution and return a return code.
      *
      * @return the return code from the execute java class if it was
      * executed in a separate VM (fork = "yes") or a security manager was
      * installed that prohibits ExitVM (default).
      *
      * @throws BuildException if required parameters are missing.
      */
     public int executeJava() throws BuildException {
         return executeJava(getCommandLine());
     }
 
     /**
      * Check configuration.
      * @throws BuildException if required parameters are missing.
      */
     protected void checkConfiguration() throws BuildException {
         String classname = getCommandLine().getClassname();
         if (classname == null && getCommandLine().getJar() == null) {
             throw new BuildException("Classname must not be null.");
         }
         if (!fork && getCommandLine().getJar() != null) {
             throw new BuildException("Cannot execute a jar in non-forked mode."
                                      + " Please set fork='true'. ");
         }
         if (spawn && !fork) {
             throw new BuildException("Cannot spawn a java process in non-forked mode."
                                      + " Please set fork='true'. ");
         }
         if (getCommandLine().getClasspath() != null
             && getCommandLine().getJar() != null) {
             log("When using 'jar' attribute classpath-settings are ignored. "
                 + "See the manual for more information.", Project.MSG_VERBOSE);
         }
         if (spawn && incompatibleWithSpawn) {
             getProject().log("spawn does not allow attributes related to input, "
             + "output, error, result", Project.MSG_ERR);
             getProject().log("spawn also does not allow timeout", Project.MSG_ERR);
             getProject().log("finally, spawn is not compatible "
                 + "with a nested I/O <redirector>", Project.MSG_ERR);
             throw new BuildException("You have used an attribute "
                 + "or nested element which is not compatible with spawn");
         }
         if (getCommandLine().getAssertions() != null && !fork) {
             log("Assertion statements are currently ignored in non-forked mode");
         }
         if (fork) {
             if (perm != null) {
                 log("Permissions can not be set this way in forked mode.", Project.MSG_WARN);
             }
             log(getCommandLine().describeCommand(), Project.MSG_VERBOSE);
         } else {
             if (getCommandLine().getVmCommand().size() > 1) {
                 log("JVM args ignored when same JVM is used.",
                     Project.MSG_WARN);
             }
             if (dir != null) {
                 log("Working directory ignored when same JVM is used.",
                     Project.MSG_WARN);
             }
             if (newEnvironment || null != env.getVariables()) {
                 log("Changes to environment variables are ignored when same "
                     + "JVM is used.", Project.MSG_WARN);
             }
             if (getCommandLine().getBootclasspath() != null) {
                 log("bootclasspath ignored when same JVM is used.",
                     Project.MSG_WARN);
             }
             if (perm == null) {
                 perm = new Permissions(true);
                 log("running " + this.getCommandLine().getClassname()
                     + " with default permissions (exit forbidden)", Project.MSG_VERBOSE);
             }
             log("Running in same VM " + getCommandLine().describeJavaCommand(),
                 Project.MSG_VERBOSE);
         }
         setupRedirector();
     }
 
     /**
      * Execute the specified CommandlineJava.
      * @param commandLine CommandLineJava instance.
      * @return the exit value of the process if forked, 0 otherwise.
      */
     protected int executeJava(CommandlineJava commandLine) {
         try {
             if (fork) {
                 if (!spawn) {
                     return fork(commandLine.getCommandline());
                 } else {
                     spawn(commandLine.getCommandline());
                     return 0;
                 }
             } else {
                 try {
                     run(commandLine);
                     return 0;
                 } catch (ExitException ex) {
                     return ex.getStatus();
                 }
             }
         } catch (BuildException e) {
             if (e.getLocation() == null && getLocation() != null) {
                 e.setLocation(getLocation());
             }
             if (failOnError) {
                 throw e;
             } else {
                 if (TIMEOUT_MESSAGE.equals(e.getMessage())) {
                     log(TIMEOUT_MESSAGE);
                 } else {
                     log(e);
                 }
                 return -1;
             }
         } catch (ThreadDeath t) {
             throw t; // cf. NB #47191
         } catch (Throwable t) {
             if (failOnError) {
                 throw new BuildException(t, getLocation());
             } else {
                 log(t);
                 return -1;
             }
         }
     }
 
     /**
      * Set whether or not you want the process to be spawned;
      * default is not spawned.
      * @param spawn if true you do not want Ant to wait for the end of the process.
      * @since Ant 1.6
      */
     public void setSpawn(boolean spawn) {
         this.spawn = spawn;
     }
 
     /**
      * Set the classpath to be used when running the Java class.
      *
      * @param s an Ant Path object containing the classpath.
      */
     public void setClasspath(Path s) {
         createClasspath().append(s);
     }
 
     /**
      * Add a path to the classpath.
      *
      * @return created classpath.
      */
     public Path createClasspath() {
         return getCommandLine().createClasspath(getProject()).createPath();
     }
 
     /**
      * Add a path to the bootclasspath.
      * @since Ant 1.6
      *
      * @return created bootclasspath.
      */
     public Path createBootclasspath() {
         return getCommandLine().createBootclasspath(getProject()).createPath();
     }
 
     /**
      * Set the permissions for the application run inside the same JVM.
      * @since Ant 1.6
      * @return Permissions.
      */
     public Permissions createPermissions() {
         perm = (perm == null) ? new Permissions() : perm;
         return perm;
     }
 
     /**
      * Set the classpath to use by reference.
      *
      * @param r a reference to an existing classpath.
      */
     public void setClasspathRef(Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * Set the location of the JAR file to execute.
      *
      * @param jarfile the jarfile to execute.
      *
      * @throws BuildException if there is also a main class specified.
      */
     public void setJar(File jarfile) throws BuildException {
         if (getCommandLine().getClassname() != null) {
             throw new BuildException("Cannot use 'jar' and 'classname' "
                                      + "attributes in same command.");
         }
         getCommandLine().setJar(jarfile.getAbsolutePath());
     }
 
     /**
      * Set the Java class to execute.
      *
      * @param s the name of the main class.
      *
      * @throws BuildException if the jar attribute has been set.
      */
     public void setClassname(String s) throws BuildException {
         if (getCommandLine().getJar() != null) {
             throw new BuildException("Cannot use 'jar' and 'classname' "
                                      + "attributes in same command");
         }
         getCommandLine().setClassname(s);
     }
 
     /**
      * Deprecated: use nested arg instead.
      * Set the command line arguments for the class.
      *
      * @param s arguments.
      *
      * @ant.attribute ignore="true"
      */
     public void setArgs(String s) {
         log("The args attribute is deprecated. "
             + "Please use nested arg elements.", Project.MSG_WARN);
         getCommandLine().createArgument().setLine(s);
     }
 
     /**
      * If set, system properties will be copied to the cloned VM--as
      * well as the bootclasspath unless you have explicitly specified
      * a bootclaspath.
      *
      * <p>Doesn't have any effect unless fork is true.</p>
      * @param cloneVm if true copy system properties.
      * @since Ant 1.7
      */
     public void setCloneVm(boolean cloneVm) {
         getCommandLine().setCloneVm(cloneVm);
     }
 
     /**
      * Add a command-line argument.
      *
      * @return created argument.
      */
     public Commandline.Argument createArg() {
         return getCommandLine().createArgument();
     }
 
     /**
      * Set the name of the property in which the return code of the
      * command should be stored. Only of interest if failonerror=false.
      *
      * @param resultProperty name of property.
      *
      * @since Ant 1.6
      */
     public void setResultProperty(String resultProperty) {
         this.resultProperty = resultProperty;
         incompatibleWithSpawn = true;
     }
 
     /**
      * Helper method to set result property to the
      * passed in value if appropriate.
      *
      * @param result the exit code
      */
     protected void maybeSetResultPropertyValue(int result) {
         String res = Integer.toString(result);
         if (resultProperty != null) {
             getProject().setNewProperty(resultProperty, res);
         }
     }
 
     /**
      * If true, execute in a new VM.
      *
      * @param s do you want to run Java in a new VM.
      */
     public void setFork(boolean s) {
         this.fork = s;
     }
 
     /**
      * Set the command line arguments for the JVM.
      *
      * @param s jvmargs.
      */
     public void setJvmargs(String s) {
         log("The jvmargs attribute is deprecated. "
             + "Please use nested jvmarg elements.", Project.MSG_WARN);
         getCommandLine().createVmArgument().setLine(s);
     }
 
     /**
      * Adds a JVM argument.
      *
      * @return JVM argument created.
      */
     public Commandline.Argument createJvmarg() {
         return getCommandLine().createVmArgument();
     }
 
     /**
      * Set the command used to start the VM (only if forking).
      *
      * @param s command to start the VM.
      */
     public void setJvm(String s) {
         getCommandLine().setVm(s);
     }
 
     /**
      * Add a system property.
      *
      * @param sysp system property.
      */
     public void addSysproperty(Environment.Variable sysp) {
         getCommandLine().addSysproperty(sysp);
     }
 
     /**
      * Add a set of properties as system properties.
      *
      * @param sysp set of properties to add.
      *
      * @since Ant 1.6
      */
     public void addSyspropertyset(PropertySet sysp) {
         getCommandLine().addSyspropertyset(sysp);
     }
 
     /**
      * If true, then fail if the command exits with a
      * returncode other than zero.
      *
      * @param fail if true fail the build when the command exits with a
      * nonzero returncode.
      */
     public void setFailonerror(boolean fail) {
         failOnError = fail;
         incompatibleWithSpawn |= fail;
     }
 
     /**
      * Set the working directory of the process.
      *
      * @param d working directory.
      *
      */
     public void setDir(File d) {
         this.dir = d;
     }
 
     /**
      * Set the File to which the output of the process is redirected.
      *
      * @param out the output File.
      */
     public void setOutput(File out) {
         this.output = out;
         incompatibleWithSpawn = true;
     }
 
     /**
      * Set the input to use for the task.
      *
      * @param input name of the input file.
      */
     public void setInput(File input) {
         if (inputString != null) {
             throw new BuildException("The \"input\" and \"inputstring\" "
                 + "attributes cannot both be specified");
         }
         this.input = input;
         incompatibleWithSpawn = true;
     }
 
     /**
      * Set the string to use as input.
      *
      * @param inputString the string which is used as the input source.
      */
     public void setInputString(String inputString) {
         if (input != null) {
             throw new BuildException("The \"input\" and \"inputstring\" "
                 + "attributes cannot both be specified");
         }
         this.inputString = inputString;
         incompatibleWithSpawn = true;
     }
 
     /**
      * Set whether error output of exec is logged. This is only useful
      * when output is being redirected and error output is desired in the
      * Ant log.
      *
      * @param logError get in the ant log the messages coming from stderr
      * in the case that fork = true.
      */
     public void setLogError(boolean logError) {
         redirector.setLogError(logError);
         incompatibleWithSpawn |= logError;
     }
 
     /**
      * Set the File to which the error stream of the process is redirected.
      *
      * @param error file getting the error stream.
      *
      * @since Ant 1.6
      */
     public void setError(File error) {
         this.error = error;
         incompatibleWithSpawn = true;
     }
 
     /**
      * Set the property name whose value should be set to the output of
      * the process.
      *
      * @param outputProp property name.
      *
      */
     public void setOutputproperty(String outputProp) {
         redirector.setOutputProperty(outputProp);
         incompatibleWithSpawn = true;
     }
 
     /**
      * Set the property name whose value should be set to the error of
      * the process.
      *
      * @param errorProperty property name.
      *
      * @since Ant 1.6
      */
     public void setErrorProperty(String errorProperty) {
         redirector.setErrorProperty(errorProperty);
         incompatibleWithSpawn = true;
     }
 
     /**
      * Corresponds to -mx or -Xmx depending on VM version.
      *
      * @param max max memory parameter.
      */
     public void setMaxmemory(String max) {
         getCommandLine().setMaxmemory(max);
     }
 
     /**
      * Set the JVM version.
      * @param value JVM version.
      */
     public void setJVMVersion(String value) {
         getCommandLine().setVmversion(value);
     }
 
     /**
      * Add an environment variable.
      *
      * <p>Will be ignored if we are not forking a new VM.
      *
      * @param var new environment variable.
      *
      * @since Ant 1.5
      */
     public void addEnv(Environment.Variable var) {
         env.addVariable(var);
     }
 
     /**
      * If true, use a completely new environment.
      *
      * <p>Will be ignored if we are not forking a new VM.
      *
      * @param newenv if true, use a completely new environment.
      *
      * @since Ant 1.5
      */
     public void setNewenvironment(boolean newenv) {
         newEnvironment = newenv;
     }
 
     /**
      * If true, append output to existing file.
      *
      * @param append if true, append output to existing file.
      *
      * @since Ant 1.5
      */
     public void setAppend(boolean append) {
         redirector.setAppend(append);
         incompatibleWithSpawn = true;
     }
 
     /**
      * Set the timeout in milliseconds after which the process will be killed.
      *
      * @param value timeout in milliseconds.
      *
      * @since Ant 1.5
      */
     public void setTimeout(Long value) {
         timeout = value;
         incompatibleWithSpawn |= timeout != null;
     }
 
     /**
      * Add assertions to enable in this program (if fork=true).
      * @param asserts assertion set.
      * @since Ant 1.6
      */
     public void addAssertions(Assertions asserts) {
         if (getCommandLine().getAssertions() != null) {
             throw new BuildException("Only one assertion declaration is allowed");
         }
         getCommandLine().setAssertions(asserts);
     }
 
     /**
      * Add a <code>RedirectorElement</code> to this task.
      * @param redirectorElement   <code>RedirectorElement</code>.
      */
     public void addConfiguredRedirector(RedirectorElement redirectorElement) {
         if (this.redirectorElement != null) {
             throw new BuildException("cannot have > 1 nested redirectors");
         }
         this.redirectorElement = redirectorElement;
         incompatibleWithSpawn = true;
     }
 
     /**
      * Pass output sent to System.out to specified output file.
      *
      * @param output a string of output on its way to the handlers.
      *
      * @since Ant 1.5
      */
     protected void handleOutput(String output) {
         if (redirector.getOutputStream() != null) {
             redirector.handleOutput(output);
         } else {
             super.handleOutput(output);
         }
     }
 
     /**
      * Handle an input request by this task.
      *
      * @param buffer the buffer into which data is to be read.
      * @param offset the offset into the buffer at which data is stored.
      * @param length the amount of data to read.
      *
      * @return the number of bytes read.
      *
      * @exception IOException if the data cannot be read.
      * @since Ant 1.6
      */
     public int handleInput(byte[] buffer, int offset, int length)
         throws IOException {
         // Should work whether or not redirector.inputStream == null:
         return redirector.handleInput(buffer, offset, length);
     }
 
     /**
      * Pass output sent to System.out to specified output file.
      *
      * @param output string of output on its way to its handlers.
      *
      * @since Ant 1.5.2
      */
     protected void handleFlush(String output) {
         if (redirector.getOutputStream() != null) {
             redirector.handleFlush(output);
         } else {
             super.handleFlush(output);
         }
     }
 
     /**
      * Handle output sent to System.err.
      *
      * @param output string of stderr.
      *
      * @since Ant 1.5
      */
     protected void handleErrorOutput(String output) {
         if (redirector.getErrorStream() != null) {
             redirector.handleErrorOutput(output);
         } else {
             super.handleErrorOutput(output);
         }
     }
 
     /**
      * Handle output sent to System.err and flush the stream.
      *
      * @param output string of stderr.
      *
      * @since Ant 1.5.2
      */
     protected void handleErrorFlush(String output) {
         if (redirector.getErrorStream() != null) {
             redirector.handleErrorFlush(output);
         } else {
             super.handleErrorFlush(output);
         }
     }
 
     /**
      * Set up properties on the redirector that we needed to store locally.
      */
     protected void setupRedirector() {
         redirector.setInput(input);
         redirector.setInputString(inputString);
         redirector.setOutput(output);
         redirector.setError(error);
         if (redirectorElement != null) {
             redirectorElement.configure(redirector);
         }
         if (!spawn && input == null && inputString == null) {
             // #24918: send standard input to the process by default.
             redirector.setInputStream(
                 new KeepAliveInputStream(getProject().getDefaultInputStream()));
         }
     }
 
     /**
      * Executes the given classname with the given arguments as it
      * were a command line application.
      * @param command CommandlineJava.
      */
     private void run(CommandlineJava command) throws BuildException {
         try {
             ExecuteJava exe = new ExecuteJava();
             exe.setJavaCommand(command.getJavaCommand());
             exe.setClasspath(command.getClasspath());
             exe.setSystemProperties(command.getSystemProperties());
             exe.setPermissions(perm);
             exe.setTimeout(timeout);
             redirector.createStreams();
             exe.execute(getProject());
             redirector.complete();
             if (exe.killedProcess()) {
                 throw new BuildException(TIMEOUT_MESSAGE);
             }
         } catch (IOException e) {
             throw new BuildException(e);
         }
     }
 
     /**
      * Executes the given classname with the given arguments in a separate VM.
      * @param command String[] of command-line arguments.
      */
     private int fork(String[] command) throws BuildException {
         Execute exe
             = new Execute(redirector.createHandler(), createWatchdog());
         setupExecutable(exe, command);
 
         try {
             int rc = exe.execute();
             redirector.complete();
             if (exe.killedProcess()) {
                 throw new BuildException(TIMEOUT_MESSAGE);
             }
             return rc;
         } catch (IOException e) {
             throw new BuildException(e, getLocation());
         }
     }
 
     /**
      * Executes the given classname with the given arguments in a separate VM.
      * @param command String[] of command-line arguments.
      */
     private void spawn(String[] command) throws BuildException {
         Execute exe = new Execute();
         setupExecutable(exe, command);
         try {
             exe.spawn();
         } catch (IOException e) {
             throw new BuildException(e, getLocation());
         }
     }
 
     /**
      * Do all configuration for an executable that
      * is common across the {@link #fork(String[])} and
      * {@link #spawn(String[])} methods.
      * @param exe executable.
      * @param command command to execute.
      */
     private void setupExecutable(Execute exe, String[] command) {
         exe.setAntRun(getProject());
         setupWorkingDir(exe);
         setupEnvironment(exe);
         setupCommandLine(exe, command);
     }
 
     /**
      * Set up our environment variables.
      * @param exe executable.
      */
     private void setupEnvironment(Execute exe) {
         String[] environment = env.getVariables();
         if (environment != null) {
             for (int i = 0; i < environment.length; i++) {
                 log("Setting environment variable: " + environment[i],
                     Project.MSG_VERBOSE);
             }
         }
         exe.setNewenvironment(newEnvironment);
         exe.setEnvironment(environment);
     }
 
     /**
      * Set the working dir of the new process.
      * @param exe executable.
      * @throws BuildException if the dir doesn't exist.
      */
     private void setupWorkingDir(Execute exe) {
         if (dir == null) {
             dir = getProject().getBaseDir();
         } else if (!dir.exists() || !dir.isDirectory()) {
             throw new BuildException(dir.getAbsolutePath()
                                      + " is not a valid directory",
                                      getLocation());
         }
         exe.setWorkingDirectory(dir);
     }
 
     /**
      * Set the command line for the exe.
      * On VMS, hands off to {@link #setupCommandLineForVMS(Execute, String[])}.
      * @param exe executable.
      * @param command command to execute.
      */
     private void setupCommandLine(Execute exe, String[] command) {
         //On VMS platform, we need to create a special java options file
         //containing the arguments and classpath for the java command.
         //The special file is supported by the "-V" switch on the VMS JVM.
         if (Os.isFamily("openvms")) {
             setupCommandLineForVMS(exe, command);
         } else {
             exe.setCommandline(command);
         }
     }
 
     /**
      * On VMS platform, we need to create a special java options file
      * containing the arguments and classpath for the java command.
      * The special file is supported by the "-V" switch on the VMS JVM.
      *
      * @param exe executable.
      * @param command command to execute.
      */
     private void setupCommandLineForVMS(Execute exe, String[] command) {
         ExecuteJava.setupCommandLineForVMS(exe, command);
     }
 
     /**
      * Executes the given classname with the given arguments as if it
      * were a command line application.
      *
      * @param classname the name of the class to run.
      * @param args  arguments for the class.
      * @throws BuildException in case of IOException in the execution.
      */
     protected void run(String classname, Vector args) throws BuildException {
         CommandlineJava cmdj = new CommandlineJava();
         cmdj.setClassname(classname);
-        for (int i = 0; i < args.size(); i++) {
+        final int size = args.size();
+        for (int i = 0; i < size; i++) {
             cmdj.createArgument().setValue((String) args.elementAt(i));
         }
         run(cmdj);
     }
 
     /**
      * Clear out the arguments to this java task.
      */
     public void clearArgs() {
         getCommandLine().clearJavaArgs();
     }
 
     /**
      * Create the Watchdog to kill a runaway process.
      *
      * @return new watchdog.
      *
      * @throws BuildException under unknown circumstances.
      *
      * @since Ant 1.5
      */
     protected ExecuteWatchdog createWatchdog() throws BuildException {
         if (timeout == null) {
             return null;
         }
         return new ExecuteWatchdog(timeout.longValue());
     }
 
     /**
      * Log the specified Throwable.
      * @param t the Throwable to log.
      * @since 1.6.2
      */
     private void log(Throwable t) {
         StringWriter sw = new StringWriter();
         PrintWriter w = new PrintWriter(sw);
         t.printStackTrace(w);
         w.close();
         log(sw.toString(), Project.MSG_ERR);
     }
 
     /**
      * Accessor to the command line.
      *
      * @return the current command line.
      * @since 1.6.3
      */
     public CommandlineJava getCommandLine() {
         return cmdl;
     }
 
     /**
      * Get the system properties of the command line.
      *
      * @return the current properties of this java invocation.
      * @since 1.6.3
      */
     public CommandlineJava.SysProperties getSysProperties() {
         return getCommandLine().getSystemProperties();
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Javadoc.java b/src/main/org/apache/tools/ant/taskdefs/Javadoc.java
index 0d1f526cb..8115c7bd9 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Javadoc.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Javadoc.java
@@ -512,1962 +512,1963 @@ public class Javadoc extends Task {
      * @param src a Path instance containing the various source directories.
      */
     public void setSourcepath(Path src) {
         if (sourcePath == null) {
             sourcePath = src;
         } else {
             sourcePath.append(src);
         }
     }
 
     /**
      * Create a path to be configured with the locations of the source
      * files.
      *
      * @return a new Path instance to be configured by the Ant core.
      */
     public Path createSourcepath() {
         if (sourcePath == null) {
             sourcePath = new Path(getProject());
         }
         return sourcePath.createPath();
     }
 
     /**
      * Adds a reference to a CLASSPATH defined elsewhere.
      *
      * @param r the reference containing the source path definition.
      */
     public void setSourcepathRef(Reference r) {
         createSourcepath().setRefid(r);
     }
 
     /**
      * Set the directory where the Javadoc output will be generated.
      *
      * @param dir the destination directory.
      */
     public void setDestdir(File dir) {
         destDir = dir;
         cmd.createArgument().setValue("-d");
         cmd.createArgument().setFile(destDir);
     }
 
     /**
      * Set the list of source files to process.
      *
      * @param src a comma separated list of source files.
      */
     public void setSourcefiles(String src) {
         StringTokenizer tok = new StringTokenizer(src, ",");
         while (tok.hasMoreTokens()) {
             String f = tok.nextToken();
             SourceFile sf = new SourceFile();
             sf.setFile(getProject().resolveFile(f.trim()));
             addSource(sf);
         }
     }
 
     /**
      * Add a single source file.
      *
      * @param sf the source file to be processed.
      */
     public void addSource(SourceFile sf) {
         sourceFiles.addElement(sf);
     }
 
     /**
      * Set the package names to be processed.
      *
      * @param packages a comma separated list of packages specs
      *        (may be wildcarded).
      *
      * @see #addPackage for wildcard information.
      */
     public void setPackagenames(String packages) {
         StringTokenizer tok = new StringTokenizer(packages, ",");
         while (tok.hasMoreTokens()) {
             String p = tok.nextToken();
             PackageName pn = new PackageName();
             pn.setName(p);
             addPackage(pn);
         }
     }
 
     /**
      * Add a single package to be processed.
      *
      * If the package name ends with &quot;.*&quot; the Javadoc task
      * will find and process all subpackages.
      *
      * @param pn the package name, possibly wildcarded.
      */
     public void addPackage(PackageName pn) {
         packageNames.addElement(pn);
     }
 
     /**
      * Set the list of packages to be excluded.
      *
      * @param packages a comma separated list of packages to be excluded.
      *        This may not include wildcards.
      */
     public void setExcludePackageNames(String packages) {
         StringTokenizer tok = new StringTokenizer(packages, ",");
         while (tok.hasMoreTokens()) {
             String p = tok.nextToken();
             PackageName pn = new PackageName();
             pn.setName(p);
             addExcludePackage(pn);
         }
     }
 
     /**
      * Add a package to be excluded from the Javadoc run.
      *
      * @param pn the name of the package (wildcards are not permitted).
      */
     public void addExcludePackage(PackageName pn) {
         excludePackageNames.addElement(pn);
     }
 
     /**
      * Specify the file containing the overview to be included in the generated
      * documentation.
      *
      * @param f the file containing the overview.
      */
     public void setOverview(File f) {
         cmd.createArgument().setValue("-overview");
         cmd.createArgument().setFile(f);
     }
 
     /**
      * Indicate whether only public classes and members are to be included in
      * the scope processed
      *
      * @param b true if scope is to be public.
      */
     public void setPublic(boolean b) {
         addArgIf(b, "-public");
     }
 
     /**
      * Indicate whether only protected and public classes and members are to
      * be included in the scope processed
      *
      * @param b true if scope is to be protected.
      */
     public void setProtected(boolean b) {
         addArgIf(b, "-protected");
     }
 
     /**
      * Indicate whether only package, protected and public classes and
      * members are to be included in the scope processed
      *
      * @param b true if scope is to be package level.
      */
     public void setPackage(boolean b) {
         addArgIf(b, "-package");
     }
 
     /**
      * Indicate whether all classes and
      * members are to be included in the scope processed
      *
      * @param b true if scope is to be private level.
      */
     public void setPrivate(boolean b) {
         addArgIf(b, "-private");
     }
 
     /**
      * Set the scope to be processed. This is an alternative to the
      * use of the setPublic, setPrivate, etc methods. It gives better build
      * file control over what scope is processed.
      *
      * @param at the scope to be processed.
      */
     public void setAccess(AccessType at) {
         cmd.createArgument().setValue("-" + at.getValue());
     }
 
     /**
      * Set the class that starts the doclet used in generating the
      * documentation.
      *
      * @param docletName the name of the doclet class.
      */
     public void setDoclet(String docletName) {
         if (doclet == null) {
             doclet = new DocletInfo();
             doclet.setProject(getProject());
         }
         doclet.setName(docletName);
     }
 
     /**
      * Set the classpath used to find the doclet class.
      *
      * @param docletPath the doclet classpath.
      */
     public void setDocletPath(Path docletPath) {
         if (doclet == null) {
             doclet = new DocletInfo();
             doclet.setProject(getProject());
         }
         doclet.setPath(docletPath);
     }
 
     /**
      * Set the classpath used to find the doclet class by reference.
      *
      * @param r the reference to the Path instance to use as the doclet
      *        classpath.
      */
     public void setDocletPathRef(Reference r) {
         if (doclet == null) {
             doclet = new DocletInfo();
             doclet.setProject(getProject());
         }
         doclet.createPath().setRefid(r);
     }
 
     /**
      * Create a doclet to be used in the documentation generation.
      *
      * @return a new DocletInfo instance to be configured.
      */
     public DocletInfo createDoclet() {
         if (doclet == null) {
             doclet = new DocletInfo();
         }
         return doclet;
     }
 
     /**
      * Add a taglet
      *
      * @param tagletInfo information about the taglet.
      */
     public void addTaglet(ExtensionInfo tagletInfo) {
         tags.addElement(tagletInfo);
     }
 
     /**
      * Indicate whether Javadoc should produce old style (JDK 1.1)
      * documentation.
      *
      * This is not supported by JDK 1.1 and has been phased out in JDK 1.4
      *
      * @param b if true attempt to generate old style documentation.
      */
     public void setOld(boolean b) {
         log("Javadoc 1.4 doesn't support the -1.1 switch anymore",
             Project.MSG_WARN);
     }
 
     /**
      * Set the classpath to be used for this Javadoc run.
      *
      * @param path an Ant Path object containing the compilation
      *        classpath.
      */
     public void setClasspath(Path path) {
         if (classpath == null) {
             classpath = path;
         } else {
             classpath.append(path);
         }
     }
 
     /**
      * Create a Path to be configured with the classpath to use
      *
      * @return a new Path instance to be configured with the classpath.
      */
     public Path createClasspath() {
         if (classpath == null) {
             classpath = new Path(getProject());
         }
         return classpath.createPath();
     }
 
     /**
      * Adds a reference to a CLASSPATH defined elsewhere.
      *
      * @param r the reference to an instance defining the classpath.
      */
     public void setClasspathRef(Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * Set the boot classpath to use.
      *
      * @param path the boot classpath.
      */
     public void setBootclasspath(Path path) {
         if (bootclasspath == null) {
             bootclasspath = path;
         } else {
             bootclasspath.append(path);
         }
     }
 
     /**
      * Create a Path to be configured with the boot classpath
      *
      * @return a new Path instance to be configured with the boot classpath.
      */
     public Path createBootclasspath() {
         if (bootclasspath == null) {
             bootclasspath = new Path(getProject());
         }
         return bootclasspath.createPath();
     }
 
     /**
      * Adds a reference to a CLASSPATH defined elsewhere.
      *
      * @param r the reference to an instance defining the bootclasspath.
      */
     public void setBootClasspathRef(Reference r) {
         createBootclasspath().setRefid(r);
     }
 
     /**
      * Set the location of the extensions directories.
      *
      * @param path the string version of the path.
      * @deprecated since 1.5.x.
      *             Use the {@link #setExtdirs(Path)} version.
      */
     public void setExtdirs(String path) {
         cmd.createArgument().setValue("-extdirs");
         cmd.createArgument().setValue(path);
     }
 
     /**
      * Set the location of the extensions directories.
      *
      * @param path a path containing the extension directories.
      */
     public void setExtdirs(Path path) {
         cmd.createArgument().setValue("-extdirs");
         cmd.createArgument().setPath(path);
     }
 
     /**
      * Run javadoc in verbose mode
      *
      * @param b true if operation is to be verbose.
      */
     public void setVerbose(boolean b) {
         addArgIf(b, "-verbose");
     }
 
     /**
      * Set the local to use in documentation generation.
      *
      * @param locale the locale to use.
      */
     public void setLocale(String locale) {
         // createArgument(true) is necessary to make sure -locale
         // is the first argument (required in 1.3+).
         cmd.createArgument(true).setValue(locale);
         cmd.createArgument(true).setValue("-locale");
     }
 
     /**
      * Set the encoding name of the source files,
      *
      * @param enc the name of the encoding for the source files.
      */
     public void setEncoding(String enc) {
         cmd.createArgument().setValue("-encoding");
         cmd.createArgument().setValue(enc);
     }
 
     /**
      * Include the version tag in the generated documentation.
      *
      * @param b true if the version tag should be included.
      */
     public void setVersion(boolean b) {
         this.version = b;
     }
 
     /**
      * Generate the &quot;use&quot page for each package.
      *
      * @param b true if the use page should be generated.
      */
     public void setUse(boolean b) {
         addArgIf(b, "-use");
     }
 
 
     /**
      * Include the author tag in the generated documentation.
      *
      * @param b true if the author tag should be included.
      */
     public void setAuthor(boolean b) {
         author = b;
     }
 
     /**
      * Generate a split index
      *
      * @param b true if the index should be split into a file per letter.
      */
     public void setSplitindex(boolean b) {
         addArgIf(b, "-splitindex");
     }
 
     /**
      * Set the title to be placed in the HTML &lt;title&gt; tag of the
      * generated documentation.
      *
      * @param title the window title to use.
      */
     public void setWindowtitle(String title) {
         addArgIfNotEmpty("-windowtitle", title);
     }
 
     /**
      * Set the title of the generated overview page.
      *
      * @param doctitle the Document title.
      */
     public void setDoctitle(String doctitle) {
         Html h = new Html();
         h.addText(doctitle);
         addDoctitle(h);
     }
 
     /**
      * Add a document title to use for the overview page.
      *
      * @param text the HTML element containing the document title.
      */
     public void addDoctitle(Html text) {
         doctitle = text;
     }
 
     /**
      * Set the header text to be placed at the top of each output file.
      *
      * @param header the header text
      */
     public void setHeader(String header) {
         Html h = new Html();
         h.addText(header);
         addHeader(h);
     }
 
     /**
      * Set the header text to be placed at the top of each output file.
      *
      * @param text the header text
      */
     public void addHeader(Html text) {
         header = text;
     }
 
     /**
      * Set the footer text to be placed at the bottom of each output file.
      *
      * @param footer the footer text.
      */
     public void setFooter(String footer) {
         Html h = new Html();
         h.addText(footer);
         addFooter(h);
     }
 
     /**
      * Set the footer text to be placed at the bottom of each output file.
      *
      * @param text the footer text.
      */
     public void addFooter(Html text) {
         footer = text;
     }
 
     /**
      * Set the text to be placed at the bottom of each output file.
      *
      * @param bottom the bottom text.
      */
     public void setBottom(String bottom) {
         Html h = new Html();
         h.addText(bottom);
         addBottom(h);
     }
 
     /**
      * Set the text to be placed at the bottom of each output file.
      *
      * @param text the bottom text.
      */
     public void addBottom(Html text) {
         bottom = text;
     }
 
     /**
      * Link to docs at "url" using package list at "url2"
      * - separate the URLs by using a space character.
      *
      * @param src the offline link specification (url and package list)
      */
     public void setLinkoffline(String src) {
         LinkArgument le = createLink();
         le.setOffline(true);
         String linkOfflineError = "The linkoffline attribute must include"
             + " a URL and a package-list file location separated by a"
             + " space";
         if (src.trim().length() == 0) {
             throw new BuildException(linkOfflineError);
         }
         StringTokenizer tok = new StringTokenizer(src, " ", false);
         le.setHref(tok.nextToken());
 
         if (!tok.hasMoreTokens()) {
             throw new BuildException(linkOfflineError);
         }
         le.setPackagelistLoc(getProject().resolveFile(tok.nextToken()));
     }
 
     /**
      * Group specified packages together in overview page.
      *
      * @param src the group packages - a command separated list of group specs,
      *        each one being a group name and package specification separated
      *        by a space.
      */
     public void setGroup(String src) {
         group = src;
     }
 
     /**
      * Create links to Javadoc output at the given URL.
      * @param src the URL to link to
      */
     public void setLink(String src) {
         createLink().setHref(src);
     }
 
     /**
      * Control deprecation infromation
      *
      * @param b If true, do not include deprecated information.
      */
     public void setNodeprecated(boolean b) {
         addArgIf(b, "-nodeprecated");
     }
 
     /**
      * Control deprecated list generation
      *
      * @param b if true, do not generate deprecated list.
      */
     public void setNodeprecatedlist(boolean b) {
         addArgIf(b, "-nodeprecatedlist");
     }
 
     /**
      * Control class tree generation.
      *
      * @param b if true, do not generate class hierarchy.
      */
     public void setNotree(boolean b) {
         addArgIf(b, "-notree");
     }
 
     /**
      * Control generation of index.
      *
      * @param b if true, do not generate index.
      */
     public void setNoindex(boolean b) {
         addArgIf(b, "-noindex");
     }
 
     /**
      * Control generation of help link.
      *
      * @param b if true, do not generate help link
      */
     public void setNohelp(boolean b) {
         addArgIf(b, "-nohelp");
     }
 
     /**
      * Control generation of the navigation bar.
      *
      * @param b if true, do not generate navigation bar.
      */
     public void setNonavbar(boolean b) {
         addArgIf(b, "-nonavbar");
     }
 
     /**
      * Control warnings about serial tag.
      *
      * @param b if true, generate warning about the serial tag.
      */
     public void setSerialwarn(boolean b) {
         addArgIf(b, "-serialwarn");
     }
 
     /**
      * Specifies the CSS stylesheet file to use.
      *
      * @param f the file with the CSS to use.
      */
     public void setStylesheetfile(File f) {
         cmd.createArgument().setValue("-stylesheetfile");
         cmd.createArgument().setFile(f);
     }
 
     /**
      * Specifies the HTML help file to use.
      *
      * @param f the file containing help content.
      */
     public void setHelpfile(File f) {
         cmd.createArgument().setValue("-helpfile");
         cmd.createArgument().setFile(f);
     }
 
     /**
      * Output file encoding name.
      *
      * @param enc name of the encoding to use.
      */
     public void setDocencoding(String enc) {
         cmd.createArgument().setValue("-docencoding");
         cmd.createArgument().setValue(enc);
     }
 
     /**
      * The name of a file containing the packages to process.
      *
      * @param src the file containing the package list.
      */
     public void setPackageList(String src) {
         packageList = src;
     }
 
     /**
      * Create link to Javadoc output at the given URL.
      *
      * @return link argument to configure
      */
     public LinkArgument createLink() {
         LinkArgument la = new LinkArgument();
         links.addElement(la);
         return la;
     }
 
     /**
      * Represents a link triplet (href, whether link is offline,
      * location of the package list if off line)
      */
     public class LinkArgument {
         private String href;
         private boolean offline = false;
         private File packagelistLoc;
         private URL packagelistURL;
         private boolean resolveLink = false;
 
         /** Constructor for LinkArguement */
         public LinkArgument() {
             //empty
         }
 
         /**
          * Set the href attribute.
          * @param hr a <code>String</code> value
          */
         public void setHref(String hr) {
             href = hr;
         }
 
         /**
          * Get the href attribute.
          * @return the href attribute.
          */
         public String getHref() {
             return href;
         }
 
         /**
          * Set the packetlist location attribute.
          * @param src a <code>File</code> value
          */
         public void setPackagelistLoc(File src) {
             packagelistLoc = src;
         }
 
         /**
          * Get the packetList location attribute.
          * @return the packetList location attribute.
          */
         public File getPackagelistLoc() {
             return packagelistLoc;
         }
 
         /**
          * Set the packetlist location attribute.
          * @param src an <code>URL</code> value
          */
         public void setPackagelistURL(URL src) {
             packagelistURL = src;
         }
 
         /**
          * Get the packetList location attribute.
          * @return the packetList location attribute.
          */
         public URL getPackagelistURL() {
             return packagelistURL;
         }
 
         /**
          * Set the offline attribute.
          * @param offline a <code>boolean</code> value
          */
         public void setOffline(boolean offline) {
             this.offline = offline;
         }
 
         /**
          * Get the linkOffline attribute.
          * @return the linkOffline attribute.
          */
         public boolean isLinkOffline() {
             return offline;
         }
 
         /**
          * Sets whether Ant should resolve the link attribute relative
          * to the current basedir.
          * @param resolve a <code>boolean</code> value
          */
         public void setResolveLink(boolean resolve) {
             this.resolveLink = resolve;
         }
 
         /**
          * should Ant resolve the link attribute relative to the
          * current basedir?
          * @return the resolveLink attribute.
          */
         public boolean shouldResolveLink() {
             return resolveLink;
         }
 
     }
 
     /**
      * Creates and adds a -tag argument. This is used to specify
      * custom tags. This argument is only available for Javadoc 1.4,
      * and will generate a verbose message (and then be ignored)
      * when run on Java versions below 1.4.
      * @return tag argument to be configured
      */
     public TagArgument createTag() {
         TagArgument ta = new TagArgument();
         tags.addElement (ta);
         return ta;
     }
 
     /**
      * Scope element verbose names. (Defined here as fields
      * cannot be static in inner classes.) The first letter
      * from each element is used to build up the scope string.
      */
     static final String[] SCOPE_ELEMENTS = {
         "overview", "packages", "types", "constructors",
         "methods", "fields"
     };
 
     /**
      * Class representing a -tag argument.
      */
     public class TagArgument extends FileSet {
         /** Name of the tag. */
         private String name = null;
         /** Whether or not the tag is enabled. */
         private boolean enabled = true;
         /**
          * Scope string of the tag. This will form the middle
          * argument of the -tag parameter when the tag is enabled
          * (with an X prepended for and is parsed from human-readable form.
          */
         private String scope = "a";
 
         /** Sole constructor. */
         public TagArgument () {
             //empty
         }
 
         /**
          * Sets the name of the tag.
          *
          * @param name The name of the tag.
          *             Must not be <code>null</code> or empty.
          */
         public void setName (String name) {
             this.name = name;
         }
 
         /**
          * Sets the scope of the tag. This is in comma-separated
          * form, with each element being one of "all" (the default),
          * "overview", "packages", "types", "constructors", "methods",
          * "fields". The elements are treated in a case-insensitive
          * manner.
          *
          * @param verboseScope The scope of the tag.
          *                     Must not be <code>null</code>,
          *                     should not be empty.
          *
          * @exception BuildException if all is specified along with
          * other elements, if any elements are repeated, if no
          * elements are specified, or if any unrecognised elements are
          * specified.
          */
         public void setScope (String verboseScope) throws BuildException {
             verboseScope = verboseScope.toLowerCase(Locale.ENGLISH);
 
             boolean[] elements = new boolean[SCOPE_ELEMENTS.length];
 
             boolean gotAll = false;
             boolean gotNotAll = false;
 
             // Go through the tokens one at a time, updating the
             // elements array and issuing warnings where appropriate.
             StringTokenizer tok = new StringTokenizer (verboseScope, ",");
             while (tok.hasMoreTokens()) {
                 String next = tok.nextToken().trim();
                 if (next.equals("all")) {
                     if (gotAll) {
                         getProject().log ("Repeated tag scope element: all",
                                           Project.MSG_VERBOSE);
                     }
                     gotAll = true;
                 } else {
                     int i;
                     for (i = 0; i < SCOPE_ELEMENTS.length; i++) {
                         if (next.equals (SCOPE_ELEMENTS[i])) {
                             break;
                         }
                     }
                     if (i == SCOPE_ELEMENTS.length) {
                         throw new BuildException ("Unrecognised scope element: "
                                                   + next);
                     } else {
                         if (elements[i]) {
                             getProject().log ("Repeated tag scope element: "
                                               + next, Project.MSG_VERBOSE);
                         }
                         elements[i] = true;
                         gotNotAll = true;
                     }
                 }
             }
 
             if (gotNotAll && gotAll) {
                 throw new BuildException ("Mixture of \"all\" and other scope "
                                           + "elements in tag parameter.");
             }
             if (!gotNotAll && !gotAll) {
                 throw new BuildException ("No scope elements specified in tag "
                                           + "parameter.");
             }
             if (gotAll) {
                 this.scope = "a";
             } else {
                 StringBuffer buff = new StringBuffer (elements.length);
                 for (int i = 0; i < elements.length; i++) {
                     if (elements[i]) {
                         buff.append (SCOPE_ELEMENTS[i].charAt(0));
                     }
                 }
                 this.scope = buff.toString();
             }
         }
 
         /**
          * Sets whether or not the tag is enabled.
          *
          * @param enabled Whether or not this tag is enabled.
          */
         public void setEnabled (boolean enabled) {
             this.enabled = enabled;
         }
 
         /**
          * Returns the -tag parameter this argument represented.
          * @return the -tag parameter as a string
          * @exception BuildException if either the name or description
          *                           is <code>null</code> or empty.
          */
         public String getParameter() throws BuildException {
             if (name == null || name.equals("")) {
                 throw new BuildException ("No name specified for custom tag.");
             }
             if (getDescription() != null) {
                 return name + ":" + (enabled ? "" : "X")
                     + scope + ":" + getDescription();
             } else if (!enabled || !"a".equals(scope)) {
                 return name + ":" + (enabled ? "" : "X") + scope;
             } else {
                 return name;
             }
         }
     }
 
     /**
      * Separates packages on the overview page into whatever
      * groups you specify, one group per table.
      * @return a group argument to be configured
      */
     public GroupArgument createGroup() {
         GroupArgument ga = new GroupArgument();
         groups.addElement(ga);
         return ga;
     }
 
 
     /**
      * A class corresponding to the group nested element.
      */
     public class GroupArgument {
         private Html title;
         private Vector packages = new Vector();
 
         /** Constructor for GroupArgument */
         public GroupArgument() {
             //empty
         }
 
         /**
          * Set the title attribute using a string.
          * @param src a <code>String</code> value
          */
         public void setTitle(String src) {
             Html h = new Html();
             h.addText(src);
             addTitle(h);
         }
         /**
          * Set the title attribute using a nested Html value.
          * @param text a <code>Html</code> value
          */
         public void addTitle(Html text) {
             title = text;
         }
 
         /**
          * Get the title.
          * @return the title
          */
         public String getTitle() {
             return title != null ? title.getText() : null;
         }
 
         /**
          * Set the packages to Javadoc on.
          * @param src a comma separated list of packages
          */
         public void setPackages(String src) {
             StringTokenizer tok = new StringTokenizer(src, ",");
             while (tok.hasMoreTokens()) {
                 String p = tok.nextToken();
                 PackageName pn = new PackageName();
                 pn.setName(p);
                 addPackage(pn);
             }
         }
         /**
          * Add a package nested element.
          * @param pn a nested element specifing the package.
          */
         public void addPackage(PackageName pn) {
             packages.addElement(pn);
         }
 
         /**
          * Get the packages as a collon separated list.
          * @return the packages as a string
          */
         public String getPackages() {
             StringBuffer p = new StringBuffer();
-            for (int i = 0; i < packages.size(); i++) {
+            final int size = packages.size();
+            for (int i = 0; i < size; i++) {
                 if (i > 0) {
                     p.append(":");
                 }
                 p.append(packages.elementAt(i).toString());
             }
             return p.toString();
         }
     }
 
     /**
      * Charset for cross-platform viewing of generated documentation.
      * @param src the name of the charset
      */
     public void setCharset(String src) {
         this.addArgIfNotEmpty("-charset", src);
     }
 
     /**
      * Should the build process fail if Javadoc fails (as indicated by
      * a non zero return code)?
      *
      * <p>Default is false.</p>
      * @param b a <code>boolean</code> value
      */
     public void setFailonerror(boolean b) {
         failOnError = b;
     }
 
     /**
      * Enables the -source switch, will be ignored if Javadoc is not
      * the 1.4 version.
      * @param source a <code>String</code> value
      * @since Ant 1.5
      */
     public void setSource(String source) {
         this.source = source;
     }
 
     /**
      * Sets the actual executable command to invoke, instead of the binary
      * <code>javadoc</code> found in Ant's JDK.
      * @param executable the command to invoke.
      * @since Ant 1.6.3
      */
     public void setExecutable(String executable) {
         this.executable = executable;
     }
 
     /**
      * Adds a packageset.
      *
      * <p>All included directories will be translated into package
      * names be converting the directory separator into dots.</p>
      * @param packageSet a directory set
      * @since 1.5
      */
     public void addPackageset(DirSet packageSet) {
         packageSets.addElement(packageSet);
     }
 
     /**
      * Adds a fileset.
      *
      * <p>All included files will be added as sourcefiles.  The task
      * will automatically add
      * <code>includes=&quot;**&#47;*.java&quot;</code> to the
      * fileset.</p>
      * @param fs a file set
      * @since 1.5
      */
     public void addFileset(FileSet fs) {
         createSourceFiles().add(fs);
     }
 
     /**
      * Adds a container for resource collections.
      *
      * <p>All included files will be added as sourcefiles.</p>
      * @return the source files to configure.
      * @since 1.7
      */
     public ResourceCollectionContainer createSourceFiles() {
         return nestedSourceFiles;
     }
 
     /**
      * Enables the -linksource switch, will be ignored if Javadoc is not
      * the 1.4 version. Default is false
      * @param b a <code>String</code> value
      * @since Ant 1.6
      */
     public void setLinksource(boolean b) {
         this.linksource = b;
     }
 
     /**
      * Enables the -linksource switch, will be ignored if Javadoc is not
      * the 1.4 version. Default is false
      * @param b a <code>String</code> value
      * @since Ant 1.6
      */
     public void setBreakiterator(boolean b) {
         this.breakiterator = b;
     }
 
     /**
      * Enables the -noqualifier switch, will be ignored if Javadoc is not
      * the 1.4 version.
      * @param noqualifier the parameter to the -noqualifier switch
      * @since Ant 1.6
      */
     public void setNoqualifier(String noqualifier) {
         this.noqualifier = noqualifier;
     }
 
     /**
      * If set to true, Ant will also accept packages that only hold
      * package.html files but no Java sources.
      * @param b a <code>boolean</code> value.
      * @since Ant 1.6.3
      */
     public void setIncludeNoSourcePackages(boolean b) {
         this.includeNoSourcePackages = b;
     }
 
     /**
      * Enables deep-copying of <code>doc-files</code> directories.
      *
      * @since Ant 1.8.0
      */
     public void setDocFilesSubDirs(boolean b) {
         docFilesSubDirs = b;
     }
 
     /**
      * Colon-separated list of <code>doc-files</code> subdirectories
      * to skip if {@link #setDocFilesSubDirs docFilesSubDirs is true}.
      *
      * @since Ant 1.8.0
      */
     public void setExcludeDocFilesSubDir(String s) {
         excludeDocFilesSubDir = s;
     }
 
     /**
      * Execute the task.
      * @throws BuildException on error
      */
     public void execute() throws BuildException {
         checkTaskName();
 
         Vector packagesToDoc = new Vector();
         Path sourceDirs = new Path(getProject());
 
         checkPackageAndSourcePath();
 
         if (sourcePath != null) {
             sourceDirs.addExisting(sourcePath);
         }
 
         parsePackages(packagesToDoc, sourceDirs);
         checkPackages(packagesToDoc, sourceDirs);
 
         Vector sourceFilesToDoc = (Vector) sourceFiles.clone();
         addSourceFiles(sourceFilesToDoc);
 
         checkPackagesToDoc(packagesToDoc, sourceFilesToDoc);
 
         log("Generating Javadoc", Project.MSG_INFO);
 
         Commandline toExecute = (Commandline) cmd.clone();
         if (executable != null) {
             toExecute.setExecutable(executable);
         } else {
             toExecute.setExecutable(JavaEnvUtils.getJdkExecutable("javadoc"));
         }
 
         //  Javadoc arguments
         generalJavadocArguments(toExecute);  // general Javadoc arguments
         doSourcePath(toExecute, sourceDirs); // sourcepath
         doDoclet(toExecute);   // arguments for default doclet
         doBootPath(toExecute); // bootpath
         doLinks(toExecute);    // links arguments
         doGroup(toExecute);    // group attribute
         doGroups(toExecute);  // groups attribute
         doDocFilesSubDirs(toExecute); // docfilessubdir attribute
 
         doJava14(toExecute);
         if (breakiterator && (doclet == null || JAVADOC_5)) {
             toExecute.createArgument().setValue("-breakiterator");
         }
         // If using an external file, write the command line options to it
         if (useExternalFile) {
             writeExternalArgs(toExecute);
         }
 
         File tmpList = null;
         BufferedWriter srcListWriter = null;
 
         try {
             /**
              * Write sourcefiles and package names to a temporary file
              * if requested.
              */
             if (useExternalFile) {
                 tmpList = FILE_UTILS.createTempFile("javadoc", "", null, true, true);
                 toExecute.createArgument()
                     .setValue("@" + tmpList.getAbsolutePath());
                 srcListWriter = new BufferedWriter(
                     new FileWriter(tmpList.getAbsolutePath(),
                                    true));
             }
 
             doSourceAndPackageNames(
                 toExecute, packagesToDoc, sourceFilesToDoc,
                 useExternalFile, tmpList, srcListWriter);
         } catch (IOException e) {
             tmpList.delete();
             throw new BuildException("Error creating temporary file",
                                      e, getLocation());
         } finally {
             FileUtils.close(srcListWriter);
         }
 
         if (packageList != null) {
             toExecute.createArgument().setValue("@" + packageList);
         }
         log(toExecute.describeCommand(), Project.MSG_VERBOSE);
 
         log("Javadoc execution", Project.MSG_INFO);
 
         JavadocOutputStream out = new JavadocOutputStream(Project.MSG_INFO);
         JavadocOutputStream err = new JavadocOutputStream(Project.MSG_WARN);
         Execute exe = new Execute(new PumpStreamHandler(out, err));
         exe.setAntRun(getProject());
 
         /*
          * No reason to change the working directory as all filenames and
          * path components have been resolved already.
          *
          * Avoid problems with command line length in some environments.
          */
         exe.setWorkingDirectory(null);
         try {
             exe.setCommandline(toExecute.getCommandline());
             int ret = exe.execute();
             if (ret != 0 && failOnError) {
                 throw new BuildException("Javadoc returned " + ret,
                                          getLocation());
             }
         } catch (IOException e) {
             throw new BuildException("Javadoc failed: " + e, e, getLocation());
         } finally {
             if (tmpList != null) {
                 tmpList.delete();
                 tmpList = null;
             }
 
             out.logFlush();
             err.logFlush();
             try {
                 out.close();
                 err.close();
             } catch (IOException e) {
                 // ignore
             }
         }
     }
 
     private void checkTaskName() {
         if ("javadoc2".equals(getTaskType())) {
             log("Warning: the task name <javadoc2> is deprecated."
                 + " Use <javadoc> instead.",
                 Project.MSG_WARN);
         }
     }
 
     private void checkPackageAndSourcePath() {
         if (packageList != null && sourcePath == null) {
             String msg = "sourcePath attribute must be set when "
                 + "specifying packagelist.";
             throw new BuildException(msg);
         }
     }
 
     private void checkPackages(Vector packagesToDoc, Path sourceDirs) {
         if (packagesToDoc.size() != 0 && sourceDirs.size() == 0) {
             String msg = "sourcePath attribute must be set when "
                 + "specifying package names.";
             throw new BuildException(msg);
         }
     }
 
     private void checkPackagesToDoc(
         Vector packagesToDoc, Vector sourceFilesToDoc) {
         if (packageList == null && packagesToDoc.size() == 0
             && sourceFilesToDoc.size() == 0) {
             throw new BuildException("No source files and no packages have "
                                      + "been specified.");
         }
     }
 
     private void doSourcePath(Commandline toExecute, Path sourceDirs) {
         if (sourceDirs.size() > 0) {
             toExecute.createArgument().setValue("-sourcepath");
             toExecute.createArgument().setPath(sourceDirs);
         }
     }
 
     private void generalJavadocArguments(Commandline toExecute) {
         if (doctitle != null) {
             toExecute.createArgument().setValue("-doctitle");
             toExecute.createArgument().setValue(expand(doctitle.getText()));
         }
         if (header != null) {
             toExecute.createArgument().setValue("-header");
             toExecute.createArgument().setValue(expand(header.getText()));
         }
         if (footer != null) {
             toExecute.createArgument().setValue("-footer");
             toExecute.createArgument().setValue(expand(footer.getText()));
         }
         if (bottom != null) {
             toExecute.createArgument().setValue("-bottom");
             toExecute.createArgument().setValue(expand(bottom.getText()));
         }
 
         if (classpath == null) {
             classpath = (new Path(getProject())).concatSystemClasspath("last");
         } else {
             classpath = classpath.concatSystemClasspath("ignore");
         }
 
         if (classpath.size() > 0) {
             toExecute.createArgument().setValue("-classpath");
             toExecute.createArgument().setPath(classpath);
         }
 
         if (version && doclet == null) {
             toExecute.createArgument().setValue("-version");
         }
         if (author && doclet == null) {
             toExecute.createArgument().setValue("-author");
         }
 
         if (doclet == null && destDir == null) {
             throw new BuildException("destdir attribute must be set!");
         }
     }
 
     private void doDoclet(Commandline toExecute) {
         if (doclet != null) {
             if (doclet.getName() == null) {
                 throw new BuildException("The doclet name must be "
                                          + "specified.", getLocation());
             } else {
                 toExecute.createArgument().setValue("-doclet");
                 toExecute.createArgument().setValue(doclet.getName());
                 if (doclet.getPath() != null) {
                     Path docletPath
                         = doclet.getPath().concatSystemClasspath("ignore");
                     if (docletPath.size() != 0) {
                         toExecute.createArgument().setValue("-docletpath");
                         toExecute.createArgument().setPath(docletPath);
                     }
                 }
                 for (Enumeration e = doclet.getParams();
                      e.hasMoreElements();) {
                     DocletParam param = (DocletParam) e.nextElement();
                     if (param.getName() == null) {
                         throw new BuildException("Doclet parameters must "
                                                  + "have a name");
                     }
 
                     toExecute.createArgument().setValue(param.getName());
                     if (param.getValue() != null) {
                         toExecute.createArgument()
                             .setValue(param.getValue());
                     }
                 }
             }
         }
     }
 
     private void writeExternalArgs(Commandline toExecute) {
         // If using an external file, write the command line options to it
         File optionsTmpFile = null;
         BufferedWriter optionsListWriter = null;
         try {
             optionsTmpFile = FILE_UTILS.createTempFile(
                 "javadocOptions", "", null, true, true);
             String[] listOpt = toExecute.getArguments();
             toExecute.clearArgs();
             toExecute.createArgument().setValue(
                 "@" + optionsTmpFile.getAbsolutePath());
             optionsListWriter = new BufferedWriter(
                 new FileWriter(optionsTmpFile.getAbsolutePath(), true));
             for (int i = 0; i < listOpt.length; i++) {
                 String string = listOpt[i];
                 if (string.startsWith("-J-")) {
                     toExecute.createArgument().setValue(string);
                 } else  {
                     if (string.startsWith("-")) {
                         optionsListWriter.write(string);
                         optionsListWriter.write(" ");
                     } else {
                         optionsListWriter.write(quoteString(string));
                         optionsListWriter.newLine();
                     }
                 }
             }
             optionsListWriter.close();
         } catch (IOException ex) {
             if (optionsTmpFile != null) {
                 optionsTmpFile.delete();
             }
             throw new BuildException(
                 "Error creating or writing temporary file for javadoc options",
                 ex, getLocation());
         } finally {
             FileUtils.close(optionsListWriter);
         }
     }
 
     private void doBootPath(Commandline toExecute) {
         Path bcp = new Path(getProject());
         if (bootclasspath != null) {
             bcp.append(bootclasspath);
         }
         bcp = bcp.concatSystemBootClasspath("ignore");
         if (bcp.size() > 0) {
             toExecute.createArgument().setValue("-bootclasspath");
             toExecute.createArgument().setPath(bcp);
         }
     }
 
     private void doLinks(Commandline toExecute) {
         if (links.size() != 0) {
             for (Enumeration e = links.elements(); e.hasMoreElements();) {
                 LinkArgument la = (LinkArgument) e.nextElement();
 
                 if (la.getHref() == null || la.getHref().length() == 0) {
                     log("No href was given for the link - skipping",
                         Project.MSG_VERBOSE);
                     continue;
                 }
                 String link = null;
                 if (la.shouldResolveLink()) {
                     File hrefAsFile =
                         getProject().resolveFile(la.getHref());
                     if (hrefAsFile.exists()) {
                         try {
                             link = FILE_UTILS.getFileURL(hrefAsFile)
                                 .toExternalForm();
                         } catch (MalformedURLException ex) {
                             // should be impossible
                             log("Warning: link location was invalid "
                                 + hrefAsFile, Project.MSG_WARN);
                         }
                     }
                 }
                 if (link == null) {
                     // is the href a valid URL
                     try {
                         URL base = new URL("file://.");
                         new URL(base, la.getHref());
                         link = la.getHref();
                     } catch (MalformedURLException mue) {
                         // ok - just skip
                         log("Link href \"" + la.getHref()
                             + "\" is not a valid url - skipping link",
                             Project.MSG_WARN);
                         continue;
                     }
                 }
 
                 if (la.isLinkOffline()) {
                     File packageListLocation = la.getPackagelistLoc();
                     URL packageListURL = la.getPackagelistURL();
                     if (packageListLocation == null
                         && packageListURL == null) {
                         throw new BuildException("The package list"
                                                  + " location for link "
                                                  + la.getHref()
                                                  + " must be provided "
                                                  + "because the link is "
                                                  + "offline");
                     }
                     if (packageListLocation != null) {
                         File packageListFile =
                             new File(packageListLocation, "package-list");
                         if (packageListFile.exists()) {
                             try {
                                 packageListURL =
                                     FILE_UTILS.getFileURL(packageListLocation);
                             } catch (MalformedURLException ex) {
                                 log("Warning: Package list location was "
                                     + "invalid " + packageListLocation,
                                     Project.MSG_WARN);
                             }
                         } else {
                             log("Warning: No package list was found at "
                                 + packageListLocation, Project.MSG_VERBOSE);
                         }
                     }
                     if (packageListURL != null) {
                         toExecute.createArgument().setValue("-linkoffline");
                         toExecute.createArgument().setValue(link);
                         toExecute.createArgument()
                             .setValue(packageListURL.toExternalForm());
                     }
                 } else {
                     toExecute.createArgument().setValue("-link");
                     toExecute.createArgument().setValue(link);
                 }
             }
         }
     }
 
     private void doGroup(Commandline toExecute) {
         // add the single group arguments
         // Javadoc 1.2 rules:
         //   Multiple -group args allowed.
         //   Each arg includes 3 strings: -group [name] [packagelist].
         //   Elements in [packagelist] are colon-delimited.
         //   An element in [packagelist] may end with the * wildcard.
 
         // Ant javadoc task rules for group attribute:
         //   Args are comma-delimited.
         //   Each arg is 2 space-delimited strings.
         //   E.g., group="XSLT_Packages org.apache.xalan.xslt*,
         //                XPath_Packages org.apache.xalan.xpath*"
         if (group != null) {
             StringTokenizer tok = new StringTokenizer(group, ",", false);
             while (tok.hasMoreTokens()) {
                 String grp = tok.nextToken().trim();
                 int space = grp.indexOf(" ");
                 if (space > 0) {
                     String name = grp.substring(0, space);
                     String pkgList = grp.substring(space + 1);
                     toExecute.createArgument().setValue("-group");
                     toExecute.createArgument().setValue(name);
                     toExecute.createArgument().setValue(pkgList);
                 }
             }
         }
     }
 
     // add the group arguments
     private void doGroups(Commandline toExecute) {
         if (groups.size() != 0) {
             for (Enumeration e = groups.elements(); e.hasMoreElements();) {
                 GroupArgument ga = (GroupArgument) e.nextElement();
                 String title = ga.getTitle();
                 String packages = ga.getPackages();
                 if (title == null || packages == null) {
                     throw new BuildException("The title and packages must "
                                              + "be specified for group "
                                              + "elements.");
                 }
                 toExecute.createArgument().setValue("-group");
                 toExecute.createArgument().setValue(expand(title));
                 toExecute.createArgument().setValue(packages);
             }
         }
     }
 
     // Do java1.4 arguments
     private void doJava14(Commandline toExecute) {
         for (Enumeration e = tags.elements(); e.hasMoreElements();) {
             Object element = e.nextElement();
             if (element instanceof TagArgument) {
                 TagArgument ta = (TagArgument) element;
                 File tagDir = ta.getDir(getProject());
                 if (tagDir == null) {
                     // The tag element is not used as a fileset,
                     // but specifies the tag directly.
                     toExecute.createArgument().setValue ("-tag");
                     toExecute.createArgument()
                         .setValue (ta.getParameter());
                 } else {
                     // The tag element is used as a
                     // fileset. Parse all the files and create
                     // -tag arguments.
                     DirectoryScanner tagDefScanner =
                         ta.getDirectoryScanner(getProject());
                     String[] files = tagDefScanner.getIncludedFiles();
                     for (int i = 0; i < files.length; i++) {
                         File tagDefFile = new File(tagDir, files[i]);
                         try {
                             BufferedReader in
                                 = new BufferedReader(
                                     new FileReader(tagDefFile)
                                                      );
                             String line = null;
                             while ((line = in.readLine()) != null) {
                                 toExecute.createArgument()
                                     .setValue("-tag");
                                 toExecute.createArgument()
                                     .setValue(line);
                             }
                             in.close();
                         } catch (IOException ioe) {
                             throw new BuildException(
                                 "Couldn't read "
                                 + " tag file from "
                                 + tagDefFile.getAbsolutePath(), ioe);
                         }
                     }
                 }
             } else {
                 ExtensionInfo tagletInfo = (ExtensionInfo) element;
                 toExecute.createArgument().setValue("-taglet");
                 toExecute.createArgument().setValue(tagletInfo
                                                     .getName());
                 if (tagletInfo.getPath() != null) {
                     Path tagletPath = tagletInfo.getPath()
                         .concatSystemClasspath("ignore");
                     if (tagletPath.size() != 0) {
                         toExecute.createArgument()
                             .setValue("-tagletpath");
                         toExecute.createArgument().setPath(tagletPath);
                     }
                 }
             }
         }
 
         String sourceArg = source != null ? source
             : getProject().getProperty(MagicNames.BUILD_JAVAC_SOURCE);
         if (sourceArg != null) {
             toExecute.createArgument().setValue("-source");
             toExecute.createArgument().setValue(sourceArg);
         }
 
         if (linksource && doclet == null) {
             toExecute.createArgument().setValue("-linksource");
         }
         if (noqualifier != null && doclet == null) {
             toExecute.createArgument().setValue("-noqualifier");
             toExecute.createArgument().setValue(noqualifier);
         }
     }
 
     private void doDocFilesSubDirs(Commandline toExecute) {
         if (docFilesSubDirs) {
             toExecute.createArgument().setValue("-docfilessubdirs");
             if (excludeDocFilesSubDir != null
                 && excludeDocFilesSubDir.trim().length() > 0) {
                 toExecute.createArgument().setValue("-excludedocfilessubdir");
                 toExecute.createArgument().setValue(excludeDocFilesSubDir);
             }
         }
     }
 
     private void doSourceAndPackageNames(
         Commandline toExecute,
         Vector packagesToDoc,
         Vector sourceFilesToDoc,
         boolean useExternalFile,
         File    tmpList,
         BufferedWriter srcListWriter)
         throws IOException {
         Enumeration e = packagesToDoc.elements();
         while (e.hasMoreElements()) {
             String packageName = (String) e.nextElement();
             if (useExternalFile) {
                 srcListWriter.write(packageName);
                 srcListWriter.newLine();
             } else {
                 toExecute.createArgument().setValue(packageName);
             }
         }
 
         e = sourceFilesToDoc.elements();
         while (e.hasMoreElements()) {
             SourceFile sf = (SourceFile) e.nextElement();
             String sourceFileName = sf.getFile().getAbsolutePath();
             if (useExternalFile) {
                 // XXX what is the following doing?
                 //     should it run if !javadoc4 && executable != null?
                 if (sourceFileName.indexOf(" ") > -1) {
                     String name = sourceFileName;
                     if (File.separatorChar == '\\') {
                         name = sourceFileName.replace(File.separatorChar, '/');
                     }
                     srcListWriter.write("\"" + name + "\"");
                 } else {
                     srcListWriter.write(sourceFileName);
                 }
                 srcListWriter.newLine();
             } else {
                 toExecute.createArgument().setValue(sourceFileName);
             }
         }
     }
 
     /**
      * Quote a string to place in a @ file.
      * @param str the string to quote
      * @return the quoted string, if there is no need to quote the string,
      *         return the original string.
      */
     private String quoteString(final String str) {
         if (!containsWhitespace(str)
             && str.indexOf('\'') == -1
             && str.indexOf('"') == -1) {
             return str;
         }
         if (str.indexOf('\'') == -1) {
             return quoteString(str, '\'');
         } else {
             return quoteString(str, '"');
         }
     }
 
     private boolean containsWhitespace(final String s) {
         final int len = s.length();
         for (int i = 0; i < len; i++) {
             if (Character.isWhitespace(s.charAt(i))) {
                 return true;
             }
         }
         return false;
     }
 
     private String quoteString(final String str, final char delim) {
         StringBuffer buf = new StringBuffer(str.length() * 2);
         buf.append(delim);
         final int len = str.length();
         boolean lastCharWasCR = false;
         for (int i = 0; i < len; i++) {
             char c = str.charAt(i);
             if (c == delim) { // can't put the non-constant delim into a case
                 buf.append('\\').append(c);
                 lastCharWasCR = false;
             } else {
                 switch (c) {
                 case '\\':
                     buf.append("\\\\");
                     lastCharWasCR = false;
                     break;
                 case '\r':
                     // insert a line continuation marker
                     buf.append("\\\r");
                     lastCharWasCR = true;
                     break;
                 case '\n':
                     // insert a line continuation marker unless this
                     // is a \r\n sequence in which case \r already has
                     // created the marker
                     if (!lastCharWasCR) {
                         buf.append("\\\n");
                     } else {
                         buf.append("\n");
                     }
                     lastCharWasCR = false;
                     break;
                 default:
                     buf.append(c);
                     lastCharWasCR = false;
                     break;
                 }
             }
         }
         buf.append(delim);
         return buf.toString();
     }
 
     /**
      * Add the files matched by the nested source files to the Vector
      * as SourceFile instances.
      *
      * @since 1.7
      */
     private void addSourceFiles(Vector sf) {
         Iterator e = nestedSourceFiles.iterator();
         while (e.hasNext()) {
             ResourceCollection rc = (ResourceCollection) e.next();
             if (!rc.isFilesystemOnly()) {
                 throw new BuildException("only file system based resources are"
                                          + " supported by javadoc");
             }
             if (rc instanceof FileSet) {
                 FileSet fs = (FileSet) rc;
                 if (!fs.hasPatterns() && !fs.hasSelectors()) {
                     FileSet fs2 = (FileSet) fs.clone();
                     fs2.createInclude().setName("**/*.java");
                     if (includeNoSourcePackages) {
                         fs2.createInclude().setName("**/package.html");
                     }
                     rc = fs2;
                 }
             }
             Iterator iter = rc.iterator();
             while (iter.hasNext()) {
                 Resource r = (Resource) iter.next();
                 sf.addElement(new SourceFile(((FileProvider) r.as(FileProvider.class))
                                              .getFile()));
             }
         }
     }
 
     /**
      * Add the directories matched by the nested dirsets to the Vector
      * and the base directories of the dirsets to the Path.  It also
      * handles the packages and excludepackages attributes and
      * elements.
      *
      * @since 1.5
      */
     private void parsePackages(Vector pn, Path sp) {
         HashSet addedPackages = new HashSet();
         Vector dirSets = (Vector) packageSets.clone();
 
         // for each sourcePath entry, add a directoryset with includes
         // taken from packagenames attribute and nested package
         // elements and excludes taken from excludepackages attribute
         // and nested excludepackage elements
         if (sourcePath != null) {
             PatternSet ps = new PatternSet();
             ps.setProject(getProject());
             if (packageNames.size() > 0) {
                 Enumeration e = packageNames.elements();
                 while (e.hasMoreElements()) {
                     PackageName p = (PackageName) e.nextElement();
                     String pkg = p.getName().replace('.', '/');
                     if (pkg.endsWith("*")) {
                         pkg += "*";
                     }
                     ps.createInclude().setName(pkg);
                 }
             } else {
                 ps.createInclude().setName("**");
             }
 
             Enumeration e = excludePackageNames.elements();
             while (e.hasMoreElements()) {
                 PackageName p = (PackageName) e.nextElement();
                 String pkg = p.getName().replace('.', '/');
                 if (pkg.endsWith("*")) {
                     pkg += "*";
                 }
                 ps.createExclude().setName(pkg);
             }
 
 
             String[] pathElements = sourcePath.list();
             for (int i = 0; i < pathElements.length; i++) {
                 File dir = new File(pathElements[i]);
                 if (dir.isDirectory()) {
                     DirSet ds = new DirSet();
                     ds.setProject(getProject());
                     ds.setDefaultexcludes(useDefaultExcludes);
                     ds.setDir(dir);
                     ds.createPatternSet().addConfiguredPatternset(ps);
                     dirSets.addElement(ds);
                 } else {
                     log("Skipping " + pathElements[i]
                         + " since it is no directory.", Project.MSG_WARN);
                 }
             }
         }
 
         Enumeration e = dirSets.elements();
         while (e.hasMoreElements()) {
             DirSet ds = (DirSet) e.nextElement();
             File baseDir = ds.getDir(getProject());
             log("scanning " + baseDir + " for packages.", Project.MSG_DEBUG);
             DirectoryScanner dsc = ds.getDirectoryScanner(getProject());
             String[] dirs = dsc.getIncludedDirectories();
             boolean containsPackages = false;
             for (int i = 0; i < dirs.length; i++) {
                 // are there any java files in this directory?
                 File pd = new File(baseDir, dirs[i]);
                 String[] files = pd.list(new FilenameFilter () {
                         public boolean accept(File dir1, String name) {
                             return name.endsWith(".java")
                                 || (includeNoSourcePackages
                                     && name.equals("package.html"));
                         }
                     });
 
                 if (files.length > 0) {
                     if ("".equals(dirs[i])) {
                         log(baseDir
                             + " contains source files in the default package,"
                             + " you must specify them as source files"
                             + " not packages.",
                             Project.MSG_WARN);
                     } else {
                         containsPackages = true;
                         String packageName =
                             dirs[i].replace(File.separatorChar, '.');
                         if (!addedPackages.contains(packageName)) {
                             addedPackages.add(packageName);
                             pn.addElement(packageName);
                         }
                     }
                 }
             }
             if (containsPackages) {
                 // We don't need to care for duplicates here,
                 // Path.list does it for us.
                 sp.createPathElement().setLocation(baseDir);
             } else {
                 log(baseDir + " doesn\'t contain any packages, dropping it.",
                     Project.MSG_VERBOSE);
             }
         }
     }
 
     private class JavadocOutputStream extends LogOutputStream {
         JavadocOutputStream(int level) {
             super(Javadoc.this, level);
         }
 
         //
         // Override the logging of output in order to filter out Generating
         // messages.  Generating messages are set to a priority of VERBOSE
         // unless they appear after what could be an informational message.
         //
         private String queuedLine = null;
         protected void processLine(String line, int messageLevel) {
             if (messageLevel == Project.MSG_INFO
                 && line.startsWith("Generating ")) {
                 if (queuedLine != null) {
                     super.processLine(queuedLine, Project.MSG_VERBOSE);
                 }
                 queuedLine = line;
             } else {
                 if (queuedLine != null) {
                     if (line.startsWith("Building ")) {
                         super.processLine(queuedLine, Project.MSG_VERBOSE);
                     } else {
                         super.processLine(queuedLine, Project.MSG_INFO);
                     }
                     queuedLine = null;
                 }
                 super.processLine(line, messageLevel);
             }
         }
 
 
         protected void logFlush() {
             if (queuedLine != null) {
                 super.processLine(queuedLine, Project.MSG_VERBOSE);
                 queuedLine = null;
             }
         }
     }
 
     /**
      * Convenience method to expand properties.
      * @param content the string to expand
      * @return the converted string
      */
     protected String expand(String content) {
         return getProject().replaceProperties(content);
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/MacroDef.java b/src/main/org/apache/tools/ant/taskdefs/MacroDef.java
index 6054f2072..55bdca654 100644
--- a/src/main/org/apache/tools/ant/taskdefs/MacroDef.java
+++ b/src/main/org/apache/tools/ant/taskdefs/MacroDef.java
@@ -1,830 +1,833 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Locale;
 import java.util.HashMap;
 import java.util.Iterator;
 
 import org.apache.tools.ant.AntTypeDefinition;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.ComponentHelper;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.ProjectHelper;
 import org.apache.tools.ant.RuntimeConfigurable;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.TaskContainer;
 import org.apache.tools.ant.UnknownElement;
 
 /**
  * Describe class <code>MacroDef</code> here.
  *
  * @since Ant 1.6
  */
 public class MacroDef extends AntlibDefinition  {
 
     private NestedSequential nestedSequential;
     private String     name;
     private boolean    backTrace = true;
     private List       attributes = new ArrayList();
     private Map        elements   = new HashMap();
     private String     textName   = null;
     private Text       text       = null;
     private boolean    hasImplicitElement = false;
 
     /**
      * Name of the definition
      * @param name the name of the definition
      */
      public void setName(String name) {
         this.name = name;
     }
 
     /**
      * Add the text element.
      * @param text the nested text element to add
      * @since ant 1.6.1
      */
     public void addConfiguredText(Text text) {
         if (this.text != null) {
             throw new BuildException(
                 "Only one nested text element allowed");
         }
         if (text.getName() == null) {
             throw new BuildException(
                 "the text nested element needed a \"name\" attribute");
         }
         // Check if used by attributes
         for (Iterator i = attributes.iterator(); i.hasNext();) {
             Attribute attribute = (Attribute) i.next();
             if (text.getName().equals(attribute.getName())) {
                 throw new BuildException(
                     "the name \"" + text.getName()
                     + "\" is already used as an attribute");
             }
         }
         this.text = text;
         this.textName = text.getName();
     }
 
     /**
      * @return the nested text element
      * @since ant 1.6.1
      */
     public Text getText() {
         return text;
     }
 
     /**
      * Set the backTrace attribute.
      *
      * @param backTrace if true and the macro instance generates
      *                  an error, a backtrace of the location within
      *                  the macro and call to the macro will be output.
      *                  if false, only the location of the call to the
      *                  macro will be shown. Default is true.
      * @since ant 1.7
      */
     public void setBackTrace(boolean backTrace) {
         this.backTrace = backTrace;
     }
 
     /**
      * @return the backTrace attribute.
      * @since ant 1.7
      */
     public boolean getBackTrace() {
         return backTrace;
     }
 
     /**
      * This is the sequential nested element of the macrodef.
      *
      * @return a sequential element to be configured.
      */
     public NestedSequential createSequential() {
         if (this.nestedSequential != null) {
             throw new BuildException("Only one sequential allowed");
         }
         this.nestedSequential = new NestedSequential();
         return this.nestedSequential;
     }
 
     /**
      * The class corresponding to the sequential nested element.
      * This is a simple task container.
      */
     public static class NestedSequential implements TaskContainer {
         private List nested = new ArrayList();
 
         /**
          * Add a task or type to the container.
          *
          * @param task an unknown element.
          */
         public void addTask(Task task) {
             nested.add(task);
         }
 
         /**
          * @return the list of unknown elements
          */
         public List getNested() {
             return nested;
         }
 
         /**
          * A compare function to compare this with another
          * NestedSequential.
          * It calls similar on the nested unknown elements.
          *
          * @param other the nested sequential to compare with.
          * @return true if they are similar, false otherwise
          */
         public boolean similar(NestedSequential other) {
-            if (nested.size() != other.nested.size()) {
+            final int size = nested.size();
+            if (size != other.nested.size()) {
                 return false;
             }
-            for (int i = 0; i < nested.size(); ++i) {
+            for (int i = 0; i < size; ++i) {
                 UnknownElement me = (UnknownElement) nested.get(i);
                 UnknownElement o = (UnknownElement) other.nested.get(i);
                 if (!me.similar(o)) {
                     return false;
                 }
             }
             return true;
         }
     }
 
     /**
      * Convert the nested sequential to an unknown element
      * @return the nested sequential as an unknown element.
      */
     public UnknownElement getNestedTask() {
         UnknownElement ret = new UnknownElement("sequential");
         ret.setTaskName("sequential");
         ret.setNamespace("");
         ret.setQName("sequential");
         new RuntimeConfigurable(ret, "sequential");
-        for (int i = 0; i < nestedSequential.getNested().size(); ++i) {
+        final int size = nestedSequential.getNested().size();
+        for (int i = 0; i < size; ++i) {
             UnknownElement e =
                 (UnknownElement) nestedSequential.getNested().get(i);
             ret.addChild(e);
             ret.getWrapper().addChild(e.getWrapper());
         }
         return ret;
     }
 
     /**
      * Gets this macro's attribute (and define?) list.
      *
      * @return the nested Attributes
      */
     public List getAttributes() {
         return attributes;
     }
 
     /**
      * Gets this macro's elements.
      *
      * @return the map nested elements, keyed by element name, with
      *         {@link TemplateElement} values.
      */
     public Map getElements() {
         return elements;
     }
 
     /**
      * Check if a character is a valid character for an element or
      * attribute name.
      *
      * @param c the character to check
      * @return true if the character is a letter or digit or '.' or '-'
      *         attribute name
      */
     public static boolean isValidNameCharacter(char c) {
         // ? is there an xml api for this ?
         return Character.isLetterOrDigit(c) || c == '.' || c == '-';
     }
 
     /**
      * Check if a string is a valid name for an element or attribute.
      *
      * @param name the string to check
      * @return true if the name consists of valid name characters
      */
     private static boolean isValidName(String name) {
         if (name.length() == 0) {
             return false;
         }
         for (int i = 0; i < name.length(); ++i) {
             if (!isValidNameCharacter(name.charAt(i))) {
                 return false;
             }
         }
         return true;
     }
 
     /**
      * Add an attribute element.
      *
      * @param attribute an attribute nested element.
      */
     public void addConfiguredAttribute(Attribute attribute) {
         if (attribute.getName() == null) {
             throw new BuildException(
                 "the attribute nested element needed a \"name\" attribute");
         }
         if (attribute.getName().equals(textName)) {
             throw new BuildException(
                 "the name \"" + attribute.getName()
                 + "\" has already been used by the text element");
         }
-        for (int i = 0; i < attributes.size(); ++i) {
+        final int size = attributes.size();
+        for (int i = 0; i < size; ++i) {
             Attribute att = (Attribute) attributes.get(i);
             if (att.getName().equals(attribute.getName())) {
                 throw new BuildException(
                     "the name \"" + attribute.getName()
                         + "\" has already been used in "
                         + "another attribute element");
             }
         }
         attributes.add(attribute);
     }
 
     /**
      * Add an element element.
      *
      * @param element an element nested element.
      */
     public void addConfiguredElement(TemplateElement element) {
         if (element.getName() == null) {
             throw new BuildException(
                 "the element nested element needed a \"name\" attribute");
         }
         if (elements.get(element.getName()) != null) {
             throw new BuildException(
                 "the element " + element.getName()
                 + " has already been specified");
         }
         if (hasImplicitElement
             || (element.isImplicit() && elements.size() != 0)) {
             throw new BuildException(
                 "Only one element allowed when using implicit elements");
         }
         hasImplicitElement = element.isImplicit();
         elements.put(element.getName(), element);
     }
 
     /**
      * Create a new ant type based on the embedded tasks and types.
      */
     public void execute() {
         if (nestedSequential == null) {
             throw new BuildException("Missing sequential element");
         }
         if (name == null) {
             throw new BuildException("Name not specified");
         }
 
         name = ProjectHelper.genComponentName(getURI(), name);
 
         MyAntTypeDefinition def = new MyAntTypeDefinition(this);
         def.setName(name);
         def.setClass(MacroInstance.class);
 
         ComponentHelper helper = ComponentHelper.getComponentHelper(
             getProject());
 
         helper.addDataTypeDefinition(def);
         log("creating macro  " + name, Project.MSG_VERBOSE);
     }
 
 
     /**
      * An attribute for the MacroDef task.
      *
      */
     public static class Attribute {
         private String name;
         private String defaultValue;
         private String description;
 
         /**
          * The name of the attribute.
          *
          * @param name the name of the attribute
          */
         public void setName(String name) {
             if (!isValidName(name)) {
                 throw new BuildException(
                     "Illegal name [" + name + "] for attribute");
             }
             this.name = name.toLowerCase(Locale.ENGLISH);
         }
 
         /**
          * @return the name of the attribute
          */
         public String getName() {
             return name;
         }
 
         /**
          * The default value to use if the parameter is not
          * used in the templated instance.
          *
          * @param defaultValue the default value
          */
         public void setDefault(String defaultValue) {
             this.defaultValue = defaultValue;
         }
 
         /**
          * @return the default value, null if not set
          */
         public String getDefault() {
             return defaultValue;
         }
 
         /**
          * @param desc Description of the element.
          * @since ant 1.6.1
          */
         public void setDescription(String desc) {
             description = desc;
         }
 
         /**
          * @return the description of the element, or <code>null</code> if
          *         no description is available.
          * @since ant 1.6.1
          */
         public String getDescription() {
             return description;
         }
 
         /**
          * equality method
          *
          * @param obj an <code>Object</code> value
          * @return a <code>boolean</code> value
          */
         public boolean equals(Object obj) {
             if (obj == null) {
                 return false;
             }
             if (obj.getClass() != getClass()) {
                 return false;
             }
             Attribute other = (Attribute) obj;
             if (name == null) {
                 if (other.name != null) {
                     return false;
                 }
             } else if (!name.equals(other.name)) {
                 return false;
             }
             if (defaultValue == null) {
                 if (other.defaultValue != null) {
                     return false;
                 }
             } else if (!defaultValue.equals(other.defaultValue)) {
                 return false;
             }
             return true;
         }
 
         /**
          * @return a hash code value for this object.
          */
         public int hashCode() {
             return objectHashCode(defaultValue) + objectHashCode(name);
         }
     }
 
     /**
      * A nested text element for the MacroDef task.
      * @since ant 1.6.1
      */
     public static class Text {
         private String  name;
         private boolean optional;
         private boolean trim;
         private String  description;
         private String  defaultString;
 
         /**
          * The name of the attribute.
          *
          * @param name the name of the attribute
          */
         public void setName(String name) {
             if (!isValidName(name)) {
                 throw new BuildException(
                     "Illegal name [" + name + "] for attribute");
             }
             this.name = name.toLowerCase(Locale.ENGLISH);
         }
 
         /**
          * @return the name of the attribute
          */
         public String getName() {
             return name;
         }
 
         /**
          * The optional attribute of the text element.
          *
          * @param optional if true this is optional
          */
         public void setOptional(boolean optional) {
             this.optional = optional;
         }
 
         /**
          * @return true if the text is optional
          */
         public boolean getOptional() {
             return optional;
         }
 
         /**
          * The trim attribute of the text element.
          *
          * @param trim if true this String.trim() is called on
          *             the contents of the text element.
          */
         public void setTrim(boolean trim) {
             this.trim = trim;
         }
 
         /**
          * @return true if the text is trim
          */
         public boolean getTrim() {
             return trim;
         }
 
         /**
          * @param desc Description of the text.
          */
         public void setDescription(String desc) {
             description = desc;
         }
 
         /**
          * @return the description of the text, or <code>null</code> if
          *         no description is available.
          */
         public String getDescription() {
             return description;
         }
 
         /**
          * @param defaultString default text for the string.
          */
         public void setDefault(String defaultString) {
             this.defaultString = defaultString;
         }
 
         /**
          * @return the default text if set, null otherwise.
          */
         public String getDefault() {
             return defaultString;
         }
 
         /**
          * equality method
          *
          * @param obj an <code>Object</code> value
          * @return a <code>boolean</code> value
          */
         public boolean equals(Object obj) {
             if (obj == null) {
                 return false;
             }
             if (obj.getClass() != getClass()) {
                 return false;
             }
             Text other = (Text) obj;
             return safeCompare(name, other.name)
                 && optional == other.optional
                 && trim == other.trim
                 && safeCompare(defaultString, other.defaultString);
         }
 
         /**
          * @return a hash code value for this object.
          */
         public int hashCode() {
             return objectHashCode(name);
         }
     }
 
     private static boolean safeCompare(Object a, Object b) {
         return a == null ? b == null : a.equals(b);
     }
 
     /**
      * A nested element for the MacroDef task.
      */
     public static class TemplateElement {
 
         private String name;
         private String description;
         private boolean optional = false;
         private boolean implicit = false;
 
         /**
          * Sets the name of this element.
          *
          * @param name the name of the element
          */
         public void setName(String name) {
             if (!isValidName(name)) {
                 throw new BuildException(
                     "Illegal name [" + name + "] for macro element");
             }
             this.name = name.toLowerCase(Locale.ENGLISH);
         }
 
         /**
          * Gets the name of this element.
          *
          * @return the name of the element.
          */
         public String getName() {
             return name;
         }
 
         /**
          * Sets a textual description of this element,
          * for build documentation purposes only.
          *
          * @param desc Description of the element.
          * @since ant 1.6.1
          */
         public void setDescription(String desc) {
             description = desc;
         }
 
         /**
          * Gets the description of this element.
          *
          * @return the description of the element, or <code>null</code> if
          *         no description is available.
          * @since ant 1.6.1
          */
         public String getDescription() {
             return description;
         }
 
         /**
          * Sets whether this element is optional.
          *
          * @param optional if true this element may be left out, default
          *                 is false.
          */
         public void setOptional(boolean optional) {
             this.optional = optional;
         }
 
         /**
          * Gets whether this element is optional.
          *
          * @return the optional attribute
          */
         public boolean isOptional() {
             return optional;
         }
 
         /**
          * Sets whether this element is implicit.
          *
          * @param implicit if true this element may be left out, default
          *                 is false.
          */
         public void setImplicit(boolean implicit) {
             this.implicit = implicit;
         }
 
         /**
          * Gets whether this element is implicit.
          *
          * @return the implicit attribute
          */
         public boolean isImplicit() {
             return implicit;
         }
 
         /**
          * equality method.
          *
          * @param obj an <code>Object</code> value
          * @return a <code>boolean</code> value
          */
         public boolean equals(Object obj) {
             if (obj == this) {
               return true;
             }
             if (obj == null || !obj.getClass().equals(getClass())) {
                 return false;
             }
             TemplateElement t = (TemplateElement) obj;
             return
                 (name == null ? t.name == null : name.equals(t.name))
                 && optional == t.optional
                 && implicit == t.implicit;
         }
 
         /**
          * @return a hash code value for this object.
          */
         public int hashCode() {
             return objectHashCode(name)
                 + (optional ? 1 : 0) + (implicit ? 1 : 0);
         }
 
     } // END static class TemplateElement
 
     /**
      * same or similar equality method for macrodef, ignores project and
      * runtime info.
      *
      * @param obj an <code>Object</code> value
      * @param same if true test for sameness, otherwise just similiar
      * @return a <code>boolean</code> value
      */
     private boolean sameOrSimilar(Object obj, boolean same) {
         if (obj == this) {
             return true;
         }
 
         if (obj == null) {
             return false;
         }
         if (!obj.getClass().equals(getClass())) {
             return false;
         }
         MacroDef other = (MacroDef) obj;
         if (name == null) {
             return other.name == null;
         }
         if (!name.equals(other.name)) {
             return false;
         }
         // Allow two macro definitions with the same location
         // to be treated as similar - bugzilla 31215
         if (other.getLocation() != null
             && other.getLocation().equals(getLocation())
             && !same) {
             return true;
         }
         if (text == null) {
             if (other.text != null) {
                 return false;
             }
         } else {
             if (!text.equals(other.text)) {
                 return false;
             }
         }
         if (getURI() == null || getURI().equals("")
             || getURI().equals(ProjectHelper.ANT_CORE_URI)) {
             if (!(other.getURI() == null || other.getURI().equals("")
                   || other.getURI().equals(ProjectHelper.ANT_CORE_URI))) {
                 return false;
             }
         } else {
             if (!getURI().equals(other.getURI())) {
                 return false;
             }
         }
 
         if (!nestedSequential.similar(other.nestedSequential)) {
             return false;
         }
         if (!attributes.equals(other.attributes)) {
             return false;
         }
         if (!elements.equals(other.elements)) {
             return false;
         }
         return true;
     }
 
     /**
      * Similar method for this definition
      *
      * @param obj another definition
      * @return true if the definitions are similar
      */
     public boolean similar(Object obj) {
         return sameOrSimilar(obj, false);
     }
 
     /**
      * Equality method for this definition
      *
      * @param obj another definition
      * @return true if the definitions are the same
      */
     public boolean sameDefinition(Object obj) {
         return sameOrSimilar(obj, true);
     }
 
     /**
      * extends AntTypeDefinition, on create
      * of the object, the template macro definition
      * is given.
      */
     private static class MyAntTypeDefinition extends AntTypeDefinition {
         private MacroDef macroDef;
 
         /**
          * Creates a new <code>MyAntTypeDefinition</code> instance.
          *
          * @param macroDef a <code>MacroDef</code> value
          */
         public MyAntTypeDefinition(MacroDef macroDef) {
             this.macroDef = macroDef;
         }
 
         /**
          * Create an instance of the definition.
          * The instance may be wrapped in a proxy class.
          * @param project the current project
          * @return the created object
          */
         public Object create(Project project) {
             Object o = super.create(project);
             if (o == null) {
                 return null;
             }
             ((MacroInstance) o).setMacroDef(macroDef);
             return o;
         }
 
         /**
          * Equality method for this definition
          *
          * @param other another definition
          * @param project the current project
          * @return true if the definitions are the same
          */
         public boolean sameDefinition(AntTypeDefinition other, Project project) {
             if (!super.sameDefinition(other, project)) {
                 return false;
             }
             MyAntTypeDefinition otherDef = (MyAntTypeDefinition) other;
             return macroDef.sameDefinition(otherDef.macroDef);
         }
 
         /**
          * Similar method for this definition
          *
          * @param other another definition
          * @param project the current project
          * @return true if the definitions are the same
          */
         public boolean similarDefinition(
             AntTypeDefinition other, Project project) {
             if (!super.similarDefinition(other, project)) {
                 return false;
             }
             MyAntTypeDefinition otherDef = (MyAntTypeDefinition) other;
             return macroDef.similar(otherDef.macroDef);
         }
     }
 
     private static int objectHashCode(Object o) {
         if (o == null) {
             return 0;
         } else {
             return o.hashCode();
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Replace.java b/src/main/org/apache/tools/ant/taskdefs/Replace.java
index fac1b4018..40d764300 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Replace.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Replace.java
@@ -1,968 +1,973 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.io.Reader;
 import java.io.Writer;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Properties;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.StringUtils;
 
 /**
  * Replaces all occurrences of one or more string tokens with given
  * values in the indicated files. Each value can be either a string
  * or the value of a property available in a designated property file.
  * If you want to replace a text that crosses line boundaries, you
  * must use a nested <code>&lt;replacetoken&gt;</code> element.
  *
  * @since Ant 1.1
  *
  * @ant.task category="filesystem"
  */
 public class Replace extends MatchingTask {
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     private File sourceFile = null;
     private NestedString token = null;
     private NestedString value = new NestedString();
 
     private Resource propertyResource = null;
     private Resource replaceFilterResource = null;
     private Properties properties = null;
     private ArrayList replacefilters = new ArrayList();
 
     private File dir = null;
 
     private int fileCount;
     private int replaceCount;
     private boolean summary = false;
 
     /** The encoding used to read and write files - if null, uses default */
     private String encoding = null;
 
     private Union resources;
 
     private boolean preserveLastModified = false;
     private boolean failOnNoReplacements = false;
 
     /**
      * An inline string to use as the replacement text.
      */
     public class NestedString {
 
         private boolean expandProperties = false;
         private StringBuffer buf = new StringBuffer();
 
         /**
          * Whether properties should be expanded in nested test.
          *
          * <p>If you use this class via its Java interface the text
          * you add via {@link #addText addText} has most likely been
          * expanded already so you do <b>not</b> want to set this to
          * true.</p>
          *
          * @since Ant 1.8.0
          */
         public void setExpandProperties(boolean b) {
             expandProperties = b;
         }
 
         /**
          * The text of the element.
          *
          * @param val the string to add
          */
         public void addText(String val) {
             buf.append(val);
         }
 
         /**
          * @return the text
          */
         public String getText() {
             String s = buf.toString();
             return expandProperties ? getProject().replaceProperties(s) : s;
         }
     }
 
     /**
      * A filter to apply.
      */
     public class Replacefilter {
         private NestedString token;
         private NestedString value;
         private String replaceValue;
         private String property;
 
         private StringBuffer inputBuffer;
         private StringBuffer outputBuffer = new StringBuffer();
 
         /**
          * Validate the filter's configuration.
          * @throws BuildException if any part is invalid.
          */
         public void validate() throws BuildException {
             //Validate mandatory attributes
             if (token == null) {
                 String message = "token is a mandatory for replacefilter.";
                 throw new BuildException(message);
             }
 
             if ("".equals(token.getText())) {
                 String message = "The token must not be an empty "
                     + "string.";
                 throw new BuildException(message);
             }
 
             //value and property are mutually exclusive attributes
             if ((value != null) && (property != null)) {
                 String message = "Either value or property "
                     + "can be specified, but a replacefilter "
                     + "element cannot have both.";
                 throw new BuildException(message);
             }
 
             if ((property != null)) {
                 //the property attribute must have access to a property file
                 if (propertyResource == null) {
                     String message = "The replacefilter's property attribute "
                         + "can only be used with the replacetask's "
                         + "propertyFile/Resource attribute.";
                     throw new BuildException(message);
                 }
 
                 //Make sure property exists in property file
                 if (properties == null
                     || properties.getProperty(property) == null) {
                     String message = "property \"" + property
                         + "\" was not found in " + propertyResource.getName();
                     throw new BuildException(message);
                 }
             }
 
             replaceValue = getReplaceValue();
         }
 
         /**
          * Get the replacement value for this filter token.
          * @return the replacement value
          */
         public String getReplaceValue() {
             if (property != null) {
                 return properties.getProperty(property);
             } else if (value != null) {
                 return value.getText();
             } else if (Replace.this.value != null) {
                 return Replace.this.value.getText();
             } else {
                 //Default is empty string
                 return "";
             }
         }
 
         /**
          * Set the token to replace.
          * @param t <code>String</code> token.
          */
         public void setToken(String t) {
             createReplaceToken().addText(t);
         }
 
         /**
          * Get the string to search for.
          * @return current <code>String</code> token.
          */
         public String getToken() {
             return token.getText();
         }
 
         /**
          * The replacement string; required if <code>property<code>
          * is not set.
          * @param value <code>String</code> value to replace.
          */
         public void setValue(String value) {
             createReplaceValue().addText(value);
         }
 
         /**
          * Get replacement <code>String</code>.
          * @return replacement or null.
          */
         public String getValue() {
             return value.getText();
         }
 
         /**
          * Set the name of the property whose value is to serve as
          * the replacement value; required if <code>value</code> is not set.
          * @param property property name.
          */
         public void setProperty(String property) {
             this.property = property;
         }
 
         /**
          * Get the name of the property whose value is to serve as
          * the replacement value.
          * @return property or null.
          */
         public String getProperty() {
             return property;
         }
 
         /**
          * Create a token to filter as the text of a nested element.
          * @return nested token <code>NestedString</code> to configure.
          * @since Ant 1.8.0
          */
         public NestedString createReplaceToken() {
             if (token == null) {
                 token = new NestedString();
             }
             return token;
         }
 
         /**
          * Create a string to replace the token as the text of a nested element.
          * @return replacement value <code>NestedString</code> to configure.
          * @since Ant 1.8.0
          */
         public NestedString createReplaceValue() {
             if (value == null) {
                 value = new NestedString();
             }
             return value;
         }
 
         /**
          * Retrieves the output buffer of this filter. The filter guarantees
          * that data is only appended to the end of this StringBuffer.
          * @return The StringBuffer containing the output of this filter.
          */
         StringBuffer getOutputBuffer() {
             return outputBuffer;
         }
 
         /**
          * Sets the input buffer for this filter.
          * The filter expects from the component providing the input that data
          * is only added by that component to the end of this StringBuffer.
          * This StringBuffer will be modified by this filter, and expects that
          * another component will only apped to this StringBuffer.
          * @param input The input for this filter.
          */
         void setInputBuffer(StringBuffer input) {
             inputBuffer = input;
         }
 
         /**
          * Processes the buffer as far as possible. Takes into account that
          * appended data may make it possible to replace the end of the already
          * received data, when the token is split over the "old" and the "new"
          * part.
          * @return true if some data has been made available in the
          *         output buffer.
          */
         boolean process() {
             String t = getToken();
             if (inputBuffer.length() > t.length()) {
                 int pos = replace();
                 pos = Math.max((inputBuffer.length() - t.length()), pos);
                 outputBuffer.append(inputBuffer.substring(0, pos));
                 inputBuffer.delete(0, pos);
                 return true;
             }
             return false;
         }
 
         /**
          * Processes the buffer to the end. Does not take into account that
          * appended data may make it possible to replace the end of the already
          * received data.
          */
         void flush() {
             replace();
             outputBuffer.append(inputBuffer);
             inputBuffer.delete(0, inputBuffer.length());
         }
 
         /**
          * Performs the replace operation.
          * @return The position of the last character that was inserted as
          *         replacement.
          */
         private int replace() {
             String t = getToken();
             int found = inputBuffer.indexOf(t);
             int pos = -1;
             final int tokenLength = t.length();
             final int replaceValueLength = replaceValue.length();
             while (found >= 0) {
                 inputBuffer.replace(found, found + tokenLength, replaceValue);
                 pos = found + replaceValueLength;
                 found = inputBuffer.indexOf(t, pos);
                 ++replaceCount;
             }
             return pos;
         }
     }
 
     /**
      * Class reading a file in small chunks, and presenting these chunks in
      * a StringBuffer. Compatible with the Replacefilter.
      * @since 1.7
      */
     private class FileInput {
         private StringBuffer outputBuffer;
         private Reader reader;
         private char[] buffer;
         private static final int BUFF_SIZE = 4096;
 
         /**
          * Constructs the input component. Opens the file for reading.
          * @param source The file to read from.
          * @throws IOException When the file cannot be read from.
          */
         FileInput(File source) throws IOException {
             outputBuffer = new StringBuffer();
             buffer = new char[BUFF_SIZE];
             if (encoding == null) {
                 reader = new BufferedReader(new FileReader(source));
             } else {
                 reader = new BufferedReader(new InputStreamReader(
                         new FileInputStream(source), encoding));
             }
         }
 
         /**
          * Retrieves the output buffer of this filter. The component guarantees
          * that data is only appended to the end of this StringBuffer.
          * @return The StringBuffer containing the output of this filter.
          */
         StringBuffer getOutputBuffer() {
             return outputBuffer;
         }
 
         /**
          * Reads some data from the file.
          * @return true when the end of the file has not been reached.
          * @throws IOException When the file cannot be read from.
          */
         boolean readChunk() throws IOException {
             int bufferLength = 0;
             bufferLength = reader.read(buffer);
             if (bufferLength < 0) {
                 return false;
             }
             outputBuffer.append(new String(buffer, 0, bufferLength));
             return true;
         }
 
         /**
          * Closes the file.
          * @throws IOException When the file cannot be closed.
          */
         void close() throws IOException {
             reader.close();
         }
 
         /**
          * Closes file but doesn't throw exception
          */
         void closeQuietly() {
             FileUtils.close(reader);
         }
 
     }
 
     /**
      * Component writing a file in chunks, taking the chunks from the
      * Replacefilter.
      * @since 1.7
      */
     private class FileOutput {
         private StringBuffer inputBuffer;
         private Writer writer;
 
         /**
          * Constructs the output component. Opens the file for writing.
          * @param out The file to read to.
          * @throws IOException When the file cannot be read from.
          */
         FileOutput(File out) throws IOException {
                 if (encoding == null) {
                     writer = new BufferedWriter(new FileWriter(out));
                 } else {
                     writer = new BufferedWriter(new OutputStreamWriter
                             (new FileOutputStream(out), encoding));
                 }
         }
 
         /**
          * Sets the input buffer for this component.
          * The filter expects from the component providing the input that data
          * is only added by that component to the end of this StringBuffer.
          * This StringBuffer will be modified by this filter, and expects that
          * another component will only append to this StringBuffer.
          * @param input The input for this filter.
          */
         void setInputBuffer(StringBuffer input) {
             inputBuffer = input;
         }
 
         /**
          * Writes the buffer as far as possible.
          * @return false to be inline with the Replacefilter.
          * (Yes defining an interface crossed my mind, but would publish the
          * internal behavior.)
          * @throws IOException when the output cannot be written.
          */
         boolean process() throws IOException {
             writer.write(inputBuffer.toString());
             inputBuffer.delete(0, inputBuffer.length());
             return false;
         }
 
         /**
          * Processes the buffer to the end.
          * @throws IOException when the output cannot be flushed.
          */
         void flush() throws IOException {
             process();
             writer.flush();
         }
 
         /**
          * Closes the file.
          * @throws IOException When the file cannot be closed.
          */
         void close() throws IOException {
             writer.close();
         }
 
         /**
          * Closes file but doesn't throw exception
          */
         void closeQuietly() {
             FileUtils.close(writer);
         }
     }
 
     /**
      * Do the execution.
      * @throws BuildException if we cant build
      */
     public void execute() throws BuildException {
 
         ArrayList savedFilters = (ArrayList) replacefilters.clone();
         Properties savedProperties =
             properties == null ? null : (Properties) properties.clone();
 
         if (token != null) {
             // line separators in values and tokens are "\n"
             // in order to compare with the file contents, replace them
             // as needed
             StringBuffer val = new StringBuffer(value.getText());
             stringReplace(val, "\r\n", "\n");
             stringReplace(val, "\n", StringUtils.LINE_SEP);
             StringBuffer tok = new StringBuffer(token.getText());
             stringReplace(tok, "\r\n", "\n");
             stringReplace(tok, "\n", StringUtils.LINE_SEP);
             Replacefilter firstFilter = createPrimaryfilter();
             firstFilter.setToken(tok.toString());
             firstFilter.setValue(val.toString());
         }
 
         try {
             if (replaceFilterResource != null) {
                 Properties props = getProperties(replaceFilterResource);
                 Iterator e = props.keySet().iterator();
                 while (e.hasNext()) {
                     String tok =  e.next().toString();
                     Replacefilter replaceFilter = createReplacefilter();
                     replaceFilter.setToken(tok);
                     replaceFilter.setValue(props.getProperty(tok));
                 }
             }
 
             validateAttributes();
 
             if (propertyResource != null) {
                 properties = getProperties(propertyResource);
             }
 
             validateReplacefilters();
             fileCount = 0;
             replaceCount = 0;
 
             if (sourceFile != null) {
                 processFile(sourceFile);
             }
 
             if (dir != null) {
                 DirectoryScanner ds = super.getDirectoryScanner(dir);
                 String[] srcs = ds.getIncludedFiles();
 
                 for (int i = 0; i < srcs.length; i++) {
                     File file = new File(dir, srcs[i]);
                     processFile(file);
                 }
             }
 
             if (resources != null) {
                 for (Iterator i = resources.iterator(); i.hasNext(); ) {
                     FileProvider fp =
                         (FileProvider) ((Resource) i.next())
                         .as(FileProvider.class);
                     processFile(fp.getFile());
                 }
             }
 
             if (summary) {
                 log("Replaced " + replaceCount + " occurrences in "
                     + fileCount + " files.", Project.MSG_INFO);
             }
             if (failOnNoReplacements && replaceCount == 0) {
                 throw new BuildException("didn't replace anything");
             }
         } finally {
             replacefilters = savedFilters;
             properties = savedProperties;
         } // end of finally
 
     }
 
     /**
      * Validate attributes provided for this task in .xml build file.
      *
      * @exception BuildException if any supplied attribute is invalid or any
      * mandatory attribute is missing.
      */
     public void validateAttributes() throws BuildException {
         if (sourceFile == null && dir == null && resources == null) {
             String message = "Either the file or the dir attribute "
                 + "or nested resources must be specified";
             throw new BuildException(message, getLocation());
         }
         if (propertyResource != null && !propertyResource.isExists()) {
             String message = "Property file " + propertyResource.getName()
                 + " does not exist.";
             throw new BuildException(message, getLocation());
         }
         if (token == null && replacefilters.size() == 0) {
             String message = "Either token or a nested replacefilter "
                 + "must be specified";
             throw new BuildException(message, getLocation());
         }
         if (token != null && "".equals(token.getText())) {
             String message = "The token attribute must not be an empty string.";
             throw new BuildException(message, getLocation());
         }
     }
 
     /**
      * Validate nested elements.
      *
      * @exception BuildException if any supplied attribute is invalid or any
      * mandatory attribute is missing.
      */
     public void validateReplacefilters()
             throws BuildException {
-        for (int i = 0; i < replacefilters.size(); i++) {
+        final int size = replacefilters.size();
+        for (int i = 0; i < size; i++) {
             Replacefilter element =
                 (Replacefilter) replacefilters.get(i);
             element.validate();
         }
     }
 
     /**
      * Load a properties file.
      * @param propertyFile the file to load the properties from.
      * @return loaded <code>Properties</code> object.
      * @throws BuildException if the file could not be found or read.
      */
     public Properties getProperties(File propertyFile) throws BuildException {
         return getProperties(new FileResource(getProject(), propertyFile));
     }
 
     /**
      * Load a properties resource.
      * @param propertyResource the resource to load the properties from.
      * @return loaded <code>Properties</code> object.
      * @throws BuildException if the resource could not be found or read.
      * @since Ant 1.8.0
      */
     public Properties getProperties(Resource propertyResource)
         throws BuildException {
         Properties props = new Properties();
 
         InputStream in = null;
         try {
             in = propertyResource.getInputStream();
             props.load(in);
         } catch (IOException e) {
             String message = "Property resource (" + propertyResource.getName()
                 + ") cannot be loaded.";
             throw new BuildException(message);
         } finally {
             FileUtils.close(in);
         }
 
         return props;
     }
 
     /**
      * Perform the replacement on the given file.
      *
      * The replacement is performed on a temporary file which then
      * replaces the original file.
      *
      * @param src the source <code>File</code>.
      */
     private void processFile(File src) throws BuildException {
         if (!src.exists()) {
             throw new BuildException("Replace: source file " + src.getPath()
                                      + " doesn't exist", getLocation());
         }
 
         File temp = null;
         FileInput in = null;
         FileOutput out = null;
         try {
             in = new FileInput(src);
 
             temp = FILE_UTILS.createTempFile("rep", ".tmp",
                     src.getParentFile(), false, true);
             out = new FileOutput(temp);
 
             int repCountStart = replaceCount;
 
             logFilterChain(src.getPath());
 
             out.setInputBuffer(buildFilterChain(in.getOutputBuffer()));
 
             while (in.readChunk()) {
                 if (processFilterChain()) {
                     out.process();
                 }
             }
 
             flushFilterChain();
 
             out.flush();
             in.close();
             in = null;
             out.close();
             out = null;
 
             boolean changes = (replaceCount != repCountStart);
             if (changes) {
                 fileCount++;
                 long origLastModified = src.lastModified();
                 FILE_UTILS.rename(temp, src);
                 if (preserveLastModified) {
                     FILE_UTILS.setFileLastModified(src, origLastModified);
                 }
                 temp = null;
             }
         } catch (IOException ioe) {
             throw new BuildException("IOException in " + src + " - "
                     + ioe.getClass().getName() + ":"
                     + ioe.getMessage(), ioe, getLocation());
         } finally {
             if (null != in) {
                 in.closeQuietly();
             }
             if (null != out) {
                 out.closeQuietly();
             }
             if (temp != null) {
                 if (!temp.delete()) {
                     temp.deleteOnExit();
                 }
             }
         }
     }
 
     /**
      * Flushes all filters.
      */
     private void flushFilterChain() {
-        for (int i = 0; i < replacefilters.size(); i++) {
+        final int size = replacefilters.size();
+        for (int i = 0; i < size; i++) {
             Replacefilter filter = (Replacefilter) replacefilters.get(i);
             filter.flush();
         }
     }
 
     /**
      * Performs the normal processing of the filters.
      * @return true if the filter chain produced new output.
      */
     private boolean processFilterChain() {
-        for (int i = 0; i < replacefilters.size(); i++) {
+        final int size = replacefilters.size();
+        for (int i = 0; i < size; i++) {
             Replacefilter filter = (Replacefilter) replacefilters.get(i);
             if (!filter.process()) {
                 return false;
             }
         }
         return true;
     }
 
     /**
      * Creates the chain of filters to operate.
      * @param inputBuffer <code>StringBuffer</code> containing the input for the
      *                    first filter.
      * @return <code>StringBuffer</code> containing the output of the last filter.
      */
     private StringBuffer buildFilterChain(StringBuffer inputBuffer) {
         StringBuffer buf = inputBuffer;
-        for (int i = 0; i < replacefilters.size(); i++) {
+        final int size = replacefilters.size();
+        for (int i = 0; i < size; i++) {
             Replacefilter filter = (Replacefilter) replacefilters.get(i);
             filter.setInputBuffer(buf);
             buf = filter.getOutputBuffer();
         }
         return buf;
     }
 
     /**
      * Logs the chain of filters to operate on the file.
      * @param filename <code>String</code>.
      */
     private void logFilterChain(String filename) {
-        for (int i = 0; i < replacefilters.size(); i++) {
+        final int size = replacefilters.size();
+        for (int i = 0; i < size; i++) {
             Replacefilter filter = (Replacefilter) replacefilters.get(i);
             log("Replacing in " + filename + ": " + filter.getToken()
                     + " --> " + filter.getReplaceValue(), Project.MSG_VERBOSE);
         }
     }
     /**
      * Set the source file; required unless <code>dir</code> is set.
      * @param file source <code>File</code>.
      */
     public void setFile(File file) {
         this.sourceFile = file;
     }
 
     /**
      * Indicates whether a summary of the replace operation should be
      * produced, detailing how many token occurrences and files were
      * processed; optional, default=<code>false</code>.
      *
      * @param summary <code>boolean</code> whether a summary of the
      *                replace operation should be logged.
      */
     public void setSummary(boolean summary) {
         this.summary = summary;
     }
 
 
     /**
      * Sets the name of a property file containing filters; optional.
      * Each property will be treated as a replacefilter where token is the name
      * of the property and value is the value of the property.
      * @param replaceFilterFile <code>File</code> to load.
      */
     public void setReplaceFilterFile(File replaceFilterFile) {
         setReplaceFilterResource(new FileResource(getProject(),
                                                   replaceFilterFile));
     }
 
     /**
      * Sets the name of a resource containing filters; optional.
      * Each property will be treated as a replacefilter where token is the name
      * of the property and value is the value of the property.
      * @param replaceFilter <code>Resource</code> to load.
      * @since Ant 1.8.0
      */
     public void setReplaceFilterResource(Resource replaceFilter) {
         this.replaceFilterResource = replaceFilter;
     }
 
     /**
      * The base directory to use when replacing a token in multiple files;
      * required if <code>file</code> is not defined.
      * @param dir <code>File</code> representing the base directory.
      */
     public void setDir(File dir) {
         this.dir = dir;
     }
 
     /**
      * Set the string token to replace; required unless a nested
      * <code>replacetoken</code> element or the
      * <code>replacefilterresource</code> attribute is used.
      * @param token token <code>String</code>.
      */
     public void setToken(String token) {
         createReplaceToken().addText(token);
     }
 
     /**
      * Set the string value to use as token replacement;
      * optional, default is the empty string "".
      * @param value replacement value.
      */
     public void setValue(String value) {
         createReplaceValue().addText(value);
     }
 
     /**
      * Set the file encoding to use on the files read and written by the task;
      * optional, defaults to default JVM encoding.
      *
      * @param encoding the encoding to use on the files.
      */
     public void setEncoding(String encoding) {
         this.encoding = encoding;
     }
 
     /**
      * Create a token to filter as the text of a nested element.
      * @return nested token <code>NestedString</code> to configure.
      */
     public NestedString createReplaceToken() {
         if (token == null) {
             token = new NestedString();
         }
         return token;
     }
 
     /**
      * Create a string to replace the token as the text of a nested element.
      * @return replacement value <code>NestedString</code> to configure.
      */
     public NestedString createReplaceValue() {
         return value;
     }
 
     /**
      * The name of a property file from which properties specified using nested
      * <code>&lt;replacefilter&gt;</code> elements are drawn; required only if
      * the <i>property</i> attribute of <code>&lt;replacefilter&gt;</code> is used.
      * @param propertyFile <code>File</code> to load.
      */
     public void setPropertyFile(File propertyFile) {
         setPropertyResource(new FileResource(propertyFile));
     }
 
     /**
      * A resource from which properties specified using nested
      * <code>&lt;replacefilter&gt;</code> elements are drawn; required
      * only if the <i>property</i> attribute of
      * <code>&lt;replacefilter&gt;</code> is used.
      * @param propertyResource <code>Resource</code> to load.
      *
      * @since Ant 1.8.0
      */
     public void setPropertyResource(Resource propertyResource) {
         this.propertyResource = propertyResource;
     }
 
     /**
      * Add a nested &lt;replacefilter&gt; element.
      * @return a nested <code>Replacefilter</code> object to be configured.
      */
     public Replacefilter createReplacefilter() {
         Replacefilter filter = new Replacefilter();
         replacefilters.add(filter);
         return filter;
     }
 
     /**
      * Support arbitrary file system based resource collections.
      *
      * @since Ant 1.8.0
      */
     public void addConfigured(ResourceCollection rc) {
         if (!rc.isFilesystemOnly()) {
             throw new BuildException("only filesystem resources are supported");
         }
         if (resources == null) {
             resources = new Union();
         }
         resources.add(rc);
     }
 
     /**
      * Whether the file timestamp shall be preserved even if the file
      * is modified.
      *
      * @since Ant 1.8.0
      */
     public void setPreserveLastModified(boolean b) {
         preserveLastModified = b;
     }
 
     /**
      * Whether the build should fail if nothing has been replaced.
      *
      * @since Ant 1.8.0
      */
     public void setFailOnNoReplacements(boolean b) {
         failOnNoReplacements = b;
     }
 
     /**
      * Adds the token and value as first &lt;replacefilter&gt; element.
      * The token and value are always processed first.
      * @return a nested <code>Replacefilter</code> object to be configured.
      */
     private Replacefilter createPrimaryfilter() {
         Replacefilter filter = new Replacefilter();
         replacefilters.add(0, filter);
         return filter;
     }
 
     /**
      * Replace occurrences of str1 in StringBuffer str with str2.
      */
     private void stringReplace(StringBuffer str, String str1, String str2) {
         int found = str.indexOf(str1);
         final int str1Length = str1.length();
         final int str2Length = str2.length();
         while (found >= 0) {
             str.replace(found, found + str1Length, str2);
             found = str.indexOf(str1, found + str2Length);
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/SubAnt.java b/src/main/org/apache/tools/ant/taskdefs/SubAnt.java
index 56ebedab0..b8c5b1660 100644
--- a/src/main/org/apache/tools/ant/taskdefs/SubAnt.java
+++ b/src/main/org/apache/tools/ant/taskdefs/SubAnt.java
@@ -1,634 +1,635 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.IOException;
 
 import java.util.Vector;
 import java.util.Enumeration;
 
 import org.apache.tools.ant.Main;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.BuildException;
 
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.DirSet;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.FileList;
 import org.apache.tools.ant.types.PropertySet;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.types.ResourceCollection;
 
 import org.apache.tools.ant.taskdefs.Ant.TargetElement;
 
 
 /**
  * Calls a given target for all defined sub-builds. This is an extension
  * of ant for bulk project execution.
  * <p>
  * <h2> Use with directories </h2>
  * <p>
  * subant can be used with directory sets to execute a build from different directories.
  * 2 different options are offered
  * </p>
  * <ul>
  * <li>
  * run the same build file /somepath/otherpath/mybuild.xml
  * with different base directories use the genericantfile attribute
  * </li>
  * <li>if you want to run directory1/build.xml, directory2/build.xml, ....
  * use the antfile attribute. The base directory does not get set by the subant task in this case,
  * because you can specify it in each build file.
  * </li>
  * </ul>
  * @since Ant1.6
  * @ant.task name="subant" category="control"
  */
 public class SubAnt extends Task {
 
     private Path buildpath;
 
     private Ant ant = null;
     private String subTarget = null;
     private String antfile = getDefaultBuildFile();
     private File genericantfile = null;
     private boolean verbose = false;
     private boolean inheritAll = false;
     private boolean inheritRefs = false;
     private boolean failOnError = true;
     private String output  = null;
 
     private Vector properties = new Vector();
     private Vector references = new Vector();
     private Vector propertySets = new Vector();
 
     /** the targets to call on the new project */
     private Vector/*<TargetElement>*/ targets = new Vector();
 
     /**
      * Get the default build file name to use when launching the task.
      * <p>
      * This function may be overrided by providers of custom ProjectHelper so they can implement easily their sub
      * launcher.
      * 
      * @return the name of the default file
      * @since Ant 1.8.0
      */
     protected String getDefaultBuildFile() {
         return Main.DEFAULT_BUILD_FILENAME;
     }
 
     /**
      * Pass output sent to System.out to the new project.
      *
      * @param output a line of output
      * @since Ant 1.6.2
      */
     public void handleOutput(String output) {
         if (ant != null) {
             ant.handleOutput(output);
         } else {
             super.handleOutput(output);
         }
     }
 
     /**
      * Process input into the ant task
      *
      * @param buffer the buffer into which data is to be read.
      * @param offset the offset into the buffer at which data is stored.
      * @param length the amount of data to read
      *
      * @return the number of bytes read
      *
      * @exception IOException if the data cannot be read
      *
      * @see Task#handleInput(byte[], int, int)
      *
      * @since Ant 1.6.2
      */
     public int handleInput(byte[] buffer, int offset, int length)
         throws IOException {
         if (ant != null) {
             return ant.handleInput(buffer, offset, length);
         } else {
             return super.handleInput(buffer, offset, length);
         }
     }
 
     /**
      * Pass output sent to System.out to the new project.
      *
      * @param output The output to log. Should not be <code>null</code>.
      *
      * @since Ant 1.6.2
      */
     public void handleFlush(String output) {
         if (ant != null) {
             ant.handleFlush(output);
         } else {
             super.handleFlush(output);
         }
     }
 
     /**
      * Pass output sent to System.err to the new project.
      *
      * @param output The error output to log. Should not be <code>null</code>.
      *
      * @since Ant 1.6.2
      */
     public void handleErrorOutput(String output) {
         if (ant != null) {
             ant.handleErrorOutput(output);
         } else {
             super.handleErrorOutput(output);
         }
     }
 
     /**
      * Pass output sent to System.err to the new project.
      *
      * @param output The error output to log. Should not be <code>null</code>.
      *
      * @since Ant 1.6.2
      */
     public void handleErrorFlush(String output) {
         if (ant != null) {
             ant.handleErrorFlush(output);
         } else {
             super.handleErrorFlush(output);
         }
     }
 
     /**
      * Runs the various sub-builds.
      */
     public void execute() {
         if (buildpath == null) {
             throw new BuildException("No buildpath specified");
         }
 
         final String[] filenames = buildpath.list();
         final int count = filenames.length;
         if (count < 1) {
             log("No sub-builds to iterate on", Project.MSG_WARN);
             return;
         }
 /*
     //REVISIT: there must be cleaner way of doing this, if it is merited at all
         if (subTarget == null) {
             subTarget = getOwningTarget().getName();
         }
 */
         BuildException buildException = null;
         for (int i = 0; i < count; ++i) {
             File file = null;
             String subdirPath = null;
             Throwable thrownException = null;
             try {
                 File directory = null;
                 file = new File(filenames[i]);
                 if (file.isDirectory()) {
                     if (verbose) {
                         subdirPath = file.getPath();
                         log("Entering directory: " + subdirPath + "\n", Project.MSG_INFO);
                     }
                     if (genericantfile != null) {
                         directory = file;
                         file = genericantfile;
                     } else {
                         file = new File(file, antfile);
                     }
                 }
                 execute(file, directory);
                 if (verbose && subdirPath != null) {
                     log("Leaving directory: " + subdirPath + "\n", Project.MSG_INFO);
                 }
             } catch (RuntimeException ex) {
                 if (!(getProject().isKeepGoingMode())) {
                     if (verbose && subdirPath != null) {
                         log("Leaving directory: " + subdirPath + "\n", Project.MSG_INFO);
                     }
                     throw ex; // throw further
                 }
                 thrownException = ex;
             } catch (Throwable ex) {
                 if (!(getProject().isKeepGoingMode())) {
                     if (verbose && subdirPath != null) {
                         log("Leaving directory: " + subdirPath + "\n", Project.MSG_INFO);
                     }
                     throw new BuildException(ex);
                 }
                 thrownException = ex;
             }
             if (thrownException != null) {
                 if (thrownException instanceof BuildException) {
                     log("File '" + file
                         + "' failed with message '"
                         + thrownException.getMessage() + "'.", Project.MSG_ERR);
                     // only the first build exception is reported
                     if (buildException == null) {
                         buildException = (BuildException) thrownException;
                     }
                 } else {
                     log("Target '" + file
                         + "' failed with message '"
                         + thrownException.getMessage() + "'.", Project.MSG_ERR);
                     thrownException.printStackTrace(System.err);
                     if (buildException == null) {
                         buildException =
                             new BuildException(thrownException);
                     }
                 }
                 if (verbose && subdirPath != null) {
                     log("Leaving directory: " + subdirPath + "\n", Project.MSG_INFO);
                 }
             }
         }
         // check if one of the builds failed in keep going mode
         if (buildException != null) {
             throw buildException;
         }
     }
 
     /**
      * Runs the given target on the provided build file.
      *
      * @param  file the build file to execute
      * @param  directory the directory of the current iteration
      * @throws BuildException is the file cannot be found, read, is
      *         a directory, or the target called failed, but only if
      *         <code>failOnError</code> is <code>true</code>. Otherwise,
      *         a warning log message is simply output.
      */
     private void execute(File file, File directory)
                 throws BuildException {
         if (!file.exists() || file.isDirectory() || !file.canRead()) {
             String msg = "Invalid file: " + file;
             if (failOnError) {
                 throw new BuildException(msg);
             }
             log(msg, Project.MSG_WARN);
             return;
         }
 
         ant = createAntTask(directory);
         String antfilename = file.getAbsolutePath();
         ant.setAntfile(antfilename);
-        for (int i = 0; i < targets.size(); i++) {
+        final int size = targets.size();
+        for (int i = 0; i < size; i++) {
             TargetElement targetElement = (TargetElement) targets.get(i);
             ant.addConfiguredTarget(targetElement);
         }
 
         try {
             ant.execute();
         } catch (BuildException e) {
             if (failOnError || isHardError(e)) {
                 throw e;
             }
             log("Failure for target '" + subTarget
                + "' of: " +  antfilename + "\n"
                + e.getMessage(), Project.MSG_WARN);
         } catch (Throwable e) {
             if (failOnError || isHardError(e)) {
                 throw new BuildException(e);
             }
             log("Failure for target '" + subTarget
                 + "' of: " + antfilename + "\n"
                 + e.toString(),
                 Project.MSG_WARN);
         } finally {
             ant = null;
         }
     }
     /** whether we should even try to continue after this error */
     private boolean isHardError(Throwable t) {
         if (t instanceof BuildException) {
             return isHardError(t.getCause());
         } else if (t instanceof OutOfMemoryError) {
             return true;
         } else if (t instanceof ThreadDeath) {
             return true;
         } else { // incl. t == null
             return false;
         }
     }
 
     /**
      * This method builds the file name to use in conjunction with directories.
      *
      * <p>Defaults to "build.xml".
      * If <code>genericantfile</code> is set, this attribute is ignored.</p>
      *
      * @param  antfile the short build file name. Defaults to "build.xml".
      */
     public void setAntfile(String antfile) {
         this.antfile = antfile;
     }
 
     /**
      * This method builds a file path to use in conjunction with directories.
      *
      * <p>Use <code>genericantfile</code>, in order to run the same build file
      * with different basedirs.</p>
      * If this attribute is set, <code>antfile</code> is ignored.
      *
      * @param afile (path of the generic ant file, absolute or relative to
      *               project base directory)
      * */
     public void setGenericAntfile(File afile) {
         this.genericantfile = afile;
     }
 
     /**
      * Sets whether to fail with a build exception on error, or go on.
      *
      * @param  failOnError the new value for this boolean flag.
      */
     public void setFailonerror(boolean failOnError) {
         this.failOnError = failOnError;
     }
 
     /**
      * The target to call on the different sub-builds. Set to "" to execute
      * the default target.
      * @param target the target
      * <p>
      */
     //     REVISIT: Defaults to the target name that contains this task if not specified.
     public void setTarget(String target) {
         this.subTarget = target;
     }
 
     /**
      * Add a target to this Ant invocation.
      * @param t the <code>TargetElement</code> to add.
      * @since Ant 1.7
      */
     public void addConfiguredTarget(TargetElement t) {
         String name = t.getName();
         if ("".equals(name)) {
             throw new BuildException("target name must not be empty");
         }
         targets.add(t);
     }
 
     /**
      * Enable/ disable verbose log messages showing when each sub-build path is entered/ exited.
      * The default value is "false".
      * @param on true to enable verbose mode, false otherwise (default).
      */
     public void setVerbose(boolean on) {
         this.verbose = on;
     }
 
     /**
      * Corresponds to <code>&lt;ant&gt;</code>'s
      * <code>output</code> attribute.
      *
      * @param  s the filename to write the output to.
      */
     public void setOutput(String s) {
         this.output = s;
     }
 
     /**
      * Corresponds to <code>&lt;ant&gt;</code>'s
      * <code>inheritall</code> attribute.
      *
      * @param  b the new value for this boolean flag.
      */
     public void setInheritall(boolean b) {
         this.inheritAll = b;
     }
 
     /**
      * Corresponds to <code>&lt;ant&gt;</code>'s
      * <code>inheritrefs</code> attribute.
      *
      * @param  b the new value for this boolean flag.
      */
     public void setInheritrefs(boolean b) {
         this.inheritRefs = b;
     }
 
     /**
      * Corresponds to <code>&lt;ant&gt;</code>'s
      * nested <code>&lt;property&gt;</code> element.
      *
      * @param  p the property to pass on explicitly to the sub-build.
      */
     public void addProperty(Property p) {
         properties.addElement(p);
     }
 
     /**
      * Corresponds to <code>&lt;ant&gt;</code>'s
      * nested <code>&lt;reference&gt;</code> element.
      *
      * @param  r the reference to pass on explicitly to the sub-build.
      */
     public void addReference(Ant.Reference r) {
         references.addElement(r);
     }
 
     /**
      * Corresponds to <code>&lt;ant&gt;</code>'s
      * nested <code>&lt;propertyset&gt;</code> element.
      * @param ps the propertset
      */
     public void addPropertyset(PropertySet ps) {
         propertySets.addElement(ps);
     }
 
     /**
      * Adds a directory set to the implicit build path.
      * <p>
      * <em>Note that the directories will be added to the build path
      * in no particular order, so if order is significant, one should
      * use a file list instead!</em>
      *
      * @param  set the directory set to add.
      */
     public void addDirset(DirSet set) {
         add(set);
     }
 
     /**
      * Adds a file set to the implicit build path.
      * <p>
      * <em>Note that the directories will be added to the build path
      * in no particular order, so if order is significant, one should
      * use a file list instead!</em>
      *
      * @param  set the file set to add.
      */
     public void addFileset(FileSet set) {
         add(set);
     }
 
     /**
      * Adds an ordered file list to the implicit build path.
      * <p>
      * <em>Note that contrary to file and directory sets, file lists
      * can reference non-existent files or directories!</em>
      *
      * @param  list the file list to add.
      */
     public void addFilelist(FileList list) {
         add(list);
     }
 
     /**
      * Adds a resource collection to the implicit build path.
      *
      * @param  rc the resource collection to add.
      * @since Ant 1.7
      */
     public void add(ResourceCollection rc) {
         getBuildpath().add(rc);
     }
 
     /**
      * Set the buildpath to be used to find sub-projects.
      *
      * @param  s an Ant Path object containing the buildpath.
      */
     public void setBuildpath(Path s) {
         getBuildpath().append(s);
     }
 
     /**
      * Creates a nested build path, and add it to the implicit build path.
      *
      * @return the newly created nested build path.
      */
     public Path createBuildpath() {
         return getBuildpath().createPath();
     }
 
     /**
      * Creates a nested <code>&lt;buildpathelement&gt;</code>,
      * and add it to the implicit build path.
      *
      * @return the newly created nested build path element.
      */
     public Path.PathElement createBuildpathElement() {
         return getBuildpath().createPathElement();
     }
 
     /**
      * Gets the implicit build path, creating it if <code>null</code>.
      *
      * @return the implicit build path.
      */
     private Path getBuildpath() {
         if (buildpath == null) {
             buildpath = new Path(getProject());
         }
         return buildpath;
     }
 
     /**
      * Buildpath to use, by reference.
      *
      * @param  r a reference to an Ant Path object containing the buildpath.
      */
     public void setBuildpathRef(Reference r) {
         createBuildpath().setRefid(r);
     }
 
     /**
      * Creates the &lt;ant&gt; task configured to run a specific target.
      *
      * @param directory : if not null the directory where the build should run
      *
      * @return the ant task, configured with the explicit properties and
      *         references necessary to run the sub-build.
      */
     private Ant createAntTask(File directory) {
         Ant antTask = new Ant(this);
         antTask.init();
         if (subTarget != null && subTarget.length() > 0) {
             antTask.setTarget(subTarget);
         }
 
 
         if (output != null) {
             antTask.setOutput(output);
         }
 
         if (directory != null) {
             antTask.setDir(directory);
         } else {
             antTask.setUseNativeBasedir(true);
         }
 
         antTask.setInheritAll(inheritAll);
         for (Enumeration i = properties.elements(); i.hasMoreElements();) {
             copyProperty(antTask.createProperty(), (Property) i.nextElement());
         }
 
         for (Enumeration i = propertySets.elements(); i.hasMoreElements();) {
             antTask.addPropertyset((PropertySet) i.nextElement());
         }
 
         antTask.setInheritRefs(inheritRefs);
         for (Enumeration i = references.elements(); i.hasMoreElements();) {
             antTask.addReference((Ant.Reference) i.nextElement());
         }
 
         return antTask;
     }
 
     /**
      * Assigns an Ant property to another.
      *
      * @param  to the destination property whose content is modified.
      * @param  from the source property whose content is copied.
      */
     private static void copyProperty(Property to, Property from) {
         to.setName(from.getName());
 
         if (from.getValue() != null) {
             to.setValue(from.getValue());
         }
         if (from.getFile() != null) {
             to.setFile(from.getFile());
         }
         if (from.getResource() != null) {
             to.setResource(from.getResource());
         }
         if (from.getPrefix() != null) {
             to.setPrefix(from.getPrefix());
         }
         if (from.getRefid() != null) {
             to.setRefid(from.getRefid());
         }
         if (from.getEnvironment() != null) {
             to.setEnvironment(from.getEnvironment());
         }
         if (from.getClasspath() != null) {
             to.setClasspath(from.getClasspath());
         }
     }
 
 } // END class SubAnt
diff --git a/src/main/org/apache/tools/ant/taskdefs/Touch.java b/src/main/org/apache/tools/ant/taskdefs/Touch.java
index a4f344ef8..36cc3365f 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Touch.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Touch.java
@@ -1,382 +1,383 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.IOException;
 import java.text.DateFormat;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.Mapper;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.FileList;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.Touchable;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.FileNameMapper;
 
 /**
  * Touch a file and/or fileset(s) and/or filelist(s);
  * corresponds to the Unix touch command.
  *
  * <p>If the file to touch doesn't exist, an empty one is created.</p>
  *
  * @since Ant 1.1
  *
  * @ant.task category="filesystem"
  */
 public class Touch extends Task {
 
     public interface DateFormatFactory {
         DateFormat getPrimaryFormat();
         DateFormat getFallbackFormat();
     }
 
     public static final DateFormatFactory DEFAULT_DF_FACTORY
         = new DateFormatFactory() {
         /*
          * The initial version used DateFormat.SHORT for the
          * time format, which ignores seconds.  If we want
          * seconds as well, we need DateFormat.MEDIUM, which
          * in turn would break all old build files.
          *
          * First try to parse with DateFormat.SHORT and if
          * that fails with MEDIUM - throw an exception if both
          * fail.
          */
         public DateFormat getPrimaryFormat() {
             return DateFormat.getDateTimeInstance(DateFormat.SHORT,
                 DateFormat.SHORT, Locale.US);
         }
         public DateFormat getFallbackFormat() {
             return DateFormat.getDateTimeInstance(DateFormat.SHORT,
                 DateFormat.MEDIUM, Locale.US);
         }
     };
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     private File file;
     private long millis = -1;
     private String dateTime;
     private Vector filesets = new Vector();
     private Union resources;
     private boolean dateTimeConfigured;
     private boolean mkdirs;
     private boolean verbose = true;
     private FileNameMapper fileNameMapper = null;
     private DateFormatFactory dfFactory = DEFAULT_DF_FACTORY;
 
     /**
      * Construct a new <code>Touch</code> task.
      */
     public Touch() {
     }
 
     /**
      * Sets a single source file to touch.  If the file does not exist
      * an empty file will be created.
      * @param file the <code>File</code> to touch.
      */
     public void setFile(File file) {
         this.file = file;
     }
 
     /**
      * Set the new modification time of file(s) touched
      * in milliseconds since midnight Jan 1 1970. Optional, default=now.
      * @param millis the <code>long</code> timestamp to use.
      */
     public void setMillis(long millis) {
         this.millis = millis;
     }
 
     /**
      * Set the new modification time of file(s) touched
      * in the format &quot;MM/DD/YYYY HH:MM AM <i>or</i> PM&quot;
      * or &quot;MM/DD/YYYY HH:MM:SS AM <i>or</i> PM&quot;.
      * Optional, default=now.
      * @param dateTime the <code>String</code> date in the specified format.
      */
     public void setDatetime(String dateTime) {
         if (this.dateTime != null) {
             log("Resetting datetime attribute to " + dateTime, Project.MSG_VERBOSE);
         }
         this.dateTime = dateTime;
         dateTimeConfigured = false;
     }
 
     /**
      * Set whether nonexistent parent directories should be created
      * when touching new files.
      * @param mkdirs <code>boolean</code> whether to create parent directories.
      * @since Ant 1.6.3
      */
     public void setMkdirs(boolean mkdirs) {
         this.mkdirs = mkdirs;
     }
 
     /**
      * Set whether the touch task will report every file it creates;
      * defaults to <code>true</code>.
      * @param verbose <code>boolean</code> flag.
      * @since Ant 1.6.3
      */
     public void setVerbose(boolean verbose) {
         this.verbose = verbose;
     }
 
     /**
      * Set the format of the datetime attribute.
      * @param pattern the <code>SimpleDateFormat</code>-compatible format pattern.
      * @since Ant 1.6.3
      */
     public void setPattern(final String pattern) {
         dfFactory = new DateFormatFactory() {
             public DateFormat getPrimaryFormat() {
                 return new SimpleDateFormat(pattern);
             }
             public DateFormat getFallbackFormat() {
                 return null;
             }
         };
     }
 
     /**
      * Add a <code>Mapper</code>.
      * @param mapper the <code>Mapper</code> to add.
      * @since Ant 1.6.3
      */
     public void addConfiguredMapper(Mapper mapper) {
         add(mapper.getImplementation());
     }
 
     /**
      * Add a <code>FileNameMapper</code>.
      * @param fileNameMapper the <code>FileNameMapper</code> to add.
      * @since Ant 1.6.3
      * @throws BuildException if multiple mappers are added.
      */
     public void add(FileNameMapper fileNameMapper) throws BuildException {
         if (this.fileNameMapper != null) {
             throw new BuildException("Only one mapper may be added to the "
                 + getTaskName() + " task.");
         }
         this.fileNameMapper = fileNameMapper;
     }
 
     /**
      * Add a set of files to touch.
      * @param set the <code>Fileset</code> to add.
      */
     public void addFileset(FileSet set) {
         filesets.add(set);
         add(set);
     }
 
     /**
      * Add a filelist to touch.
      * @param list the <code>Filelist</code> to add.
      */
     public void addFilelist(FileList list) {
         add(list);
     }
 
     /**
      * Add a collection of resources to touch.
      * @param rc the collection to add.
      * @since Ant 1.7
      */
     public synchronized void add(ResourceCollection rc) {
         resources = resources == null ? new Union() : resources;
         resources.add(rc);
     }
 
     /**
      * Check that this task has been configured properly.
      * @throws BuildException if configuration errors are detected.
      * @since Ant 1.6.3
      */
     protected synchronized void checkConfiguration() throws BuildException {
         if (file == null && resources == null) {
             throw new BuildException("Specify at least one source"
                                    + "--a file or resource collection.");
         }
         if (file != null && file.exists() && file.isDirectory()) {
             throw new BuildException("Use a resource collection to touch directories.");
         }
         if (dateTime != null && !dateTimeConfigured) {
             long workmillis = millis;
             if ("now".equalsIgnoreCase(dateTime)) {
                 workmillis = System.currentTimeMillis();
             } else {
                 DateFormat df = dfFactory.getPrimaryFormat();
                 ParseException pe = null;
                 try {
                     workmillis = df.parse(dateTime).getTime();
                 } catch (ParseException peOne) {
                     df = dfFactory.getFallbackFormat();
                     if (df == null) {
                         pe = peOne;
                     } else {
                         try {
                             workmillis = df.parse(dateTime).getTime();
                         } catch (ParseException peTwo) {
                             pe = peTwo;
                         }
                     }
                 }
                 if (pe != null) {
                     throw new BuildException(pe.getMessage(), pe, getLocation());
                 }
                 if (workmillis < 0) {
                     throw new BuildException("Date of " + dateTime
                             + " results in negative " + "milliseconds value "
                             + "relative to epoch " + "(January 1, 1970, "
                             + "00:00:00 GMT).");
                 }
             }
             log("Setting millis to " + workmillis + " from datetime attribute",
                     ((millis < 0) ? Project.MSG_DEBUG : Project.MSG_VERBOSE));
             setMillis(workmillis);
             // only set if successful to this point:
             dateTimeConfigured = true;
         }
     }
 
     /**
      * Execute the touch operation.
      *
      * @throws BuildException
      *             if an error occurs.
      */
     public void execute() throws BuildException {
         checkConfiguration();
         touch();
     }
 
     /**
      * Does the actual work; assumes everything has been checked by now.
      * @throws BuildException if an error occurs.
      */
     protected void touch() throws BuildException {
         long defaultTimestamp = getTimestamp();
 
         if (file != null) {
             touch(new FileResource(file.getParentFile(), file.getName()),
                   defaultTimestamp);
         }
         if (resources == null) {
             return;
         }
         // deal with the resource collections
         Iterator iter = resources.iterator();
         while (iter.hasNext()) {
             Resource r = (Resource) iter.next();
             Touchable t = (Touchable) r.as(Touchable.class);
             if (t == null) {
                 throw new BuildException("Can't touch " + r);
             }
             touch(r, defaultTimestamp);
         }
 
         // deal with filesets in a special way since the task
         // originally also used the directories and Union won't return
         // them.
-        for (int i = 0; i < filesets.size(); i++) {
+        final int size = filesets.size();
+        for (int i = 0; i < size; i++) {
             FileSet fs = (FileSet) filesets.elementAt(i);
             DirectoryScanner ds = fs.getDirectoryScanner(getProject());
             File fromDir = fs.getDir(getProject());
 
             String[] srcDirs = ds.getIncludedDirectories();
 
             for (int j = 0; j < srcDirs.length; j++) {
                 touch(new FileResource(fromDir, srcDirs[j]), defaultTimestamp);
             }
         }
     }
 
     /**
      * Touch a single file with the current timestamp (this.millis). This method
      * does not interact with any nested mappers and remains for reasons of
      * backwards-compatibility only.
      * @param file file to touch
      * @throws BuildException on error
      * @deprecated since 1.6.x.
      */
     protected void touch(File file) {
         touch(file, getTimestamp());
     }
 
     private long getTimestamp() {
         return (millis < 0) ? System.currentTimeMillis() : millis;
     }
 
     private void touch(Resource r, long defaultTimestamp) {
         if (fileNameMapper == null) {
             FileProvider fp = (FileProvider) r.as(FileProvider.class);
             if (fp != null) {
                 // use this to create file and deal with non-writable files
                 touch(fp.getFile(), defaultTimestamp);
             } else {
                 ((Touchable) r.as(Touchable.class)).touch(defaultTimestamp);
             }
         } else {
             String[] mapped = fileNameMapper.mapFileName(r.getName());
             if (mapped != null && mapped.length > 0) {
                 long modTime = defaultTimestamp;
                 if (millis < 0 && r.isExists()) {
                     modTime = r.getLastModified();
                 }
                 for (int i = 0; i < mapped.length; i++) {
                     touch(getProject().resolveFile(mapped[i]), modTime);
                 }
             }
         }
     }
 
     private void touch(File file, long modTime) {
         if (!file.exists()) {
             log("Creating " + file,
                 ((verbose) ? Project.MSG_INFO : Project.MSG_VERBOSE));
             try {
                 FILE_UTILS.createNewFile(file, mkdirs);
             } catch (IOException ioe) {
                 throw new BuildException("Could not create " + file, ioe,
                                          getLocation());
             }
         }
         if (!file.canWrite()) {
             throw new BuildException("Can not change modification date of "
                                      + "read-only file " + file);
         }
         FILE_UTILS.setFileLastModified(file, modTime);
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Zip.java b/src/main/org/apache/tools/ant/taskdefs/Zip.java
index 69e2df6c2..53b809eea 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Zip.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Zip.java
@@ -1,1826 +1,1829 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Stack;
 import java.util.Vector;
 import java.util.zip.CRC32;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.FileScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.ArchiveFileSet;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.PatternSet;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.ZipFileSet;
 import org.apache.tools.ant.types.ZipScanner;
 import org.apache.tools.ant.types.resources.ArchiveResource;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.types.resources.ZipResource;
 import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.GlobPatternMapper;
 import org.apache.tools.ant.util.IdentityMapper;
 import org.apache.tools.ant.util.MergingMapper;
 import org.apache.tools.ant.util.ResourceUtils;
 import org.apache.tools.zip.UnixStat;
 import org.apache.tools.zip.ZipEntry;
 import org.apache.tools.zip.ZipExtraField;
 import org.apache.tools.zip.ZipFile;
 import org.apache.tools.zip.ZipOutputStream;
 
 /**
  * Create a Zip file.
  *
  * @since Ant 1.1
  *
  * @ant.task category="packaging"
  */
 public class Zip extends MatchingTask {
     private static final int BUFFER_SIZE = 8 * 1024;
     private static final int ROUNDUP_MILLIS = 1999; // 2 seconds - 1
     // CheckStyle:VisibilityModifier OFF - bc
 
     protected File zipFile;
     // use to scan own archive
     private ZipScanner zs;
     private File baseDir;
     protected Hashtable entries = new Hashtable();
     private Vector groupfilesets = new Vector();
     private Vector filesetsFromGroupfilesets = new Vector();
     protected String duplicate = "add";
     private boolean doCompress = true;
     private boolean doUpdate = false;
     // shadow of the above if the value is altered in execute
     private boolean savedDoUpdate = false;
     private boolean doFilesonly = false;
     protected String archiveType = "zip";
 
     // For directories:
     private static final long EMPTY_CRC = new CRC32 ().getValue ();
     protected String emptyBehavior = "skip";
     private Vector resources = new Vector();
     protected Hashtable addedDirs = new Hashtable();
     private Vector addedFiles = new Vector();
 
     private static final ResourceSelector MISSING_SELECTOR =
         new ResourceSelector() {
             public boolean isSelected(Resource target) {
                 return !target.isExists();
             }
         };
 
     private static final ResourceUtils.ResourceSelectorProvider
         MISSING_DIR_PROVIDER = new ResourceUtils.ResourceSelectorProvider() {
                 public ResourceSelector
                     getTargetSelectorForSource(Resource sr) {
                     return MISSING_SELECTOR;
                 }
             };
 
     /**
      * If this flag is true, execute() will run most operations twice,
      * the first time with {@link #skipWriting skipWriting} set to
      * true and the second time with setting it to false.
      *
      * <p>The only situation in Ant's current code base where this is
      * ever going to be true is if the jar task has been configured
      * with a filesetmanifest other than "skip".</p>
      */
     protected boolean doubleFilePass = false;
     /**
      * whether the methods should just perform some sort of dry-run.
      *
      * <p>Will only ever be true in the first pass if the task
      * performs two passes because {@link #doubleFilePass
      * doubleFilePass} is true.</p>
      */
     protected boolean skipWriting = false;
 
     /**
      * Whether this is the first time the archive building methods are invoked.
      *
      * @return true if either {@link #doubleFilePass doubleFilePass}
      * is false or {@link #skipWriting skipWriting} is true.
      *
      * @since Ant 1.8.0
      */
     protected final boolean isFirstPass() {
         return !doubleFilePass || skipWriting;
     }
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     // CheckStyle:VisibilityModifier ON
 
     // This boolean is set if the task detects that the
     // target is outofdate and has written to the target file.
     private boolean updatedFile = false;
 
     /**
      * true when we are adding new files into the Zip file, as opposed
      * to adding back the unchanged files
      */
     private boolean addingNewFiles = false;
 
     /**
      * Encoding to use for filenames, defaults to the platform's
      * default encoding.
      */
     private String encoding;
 
     /**
      * Whether the original compression of entries coming from a ZIP
      * archive should be kept (for example when updating an archive).
      *
      * @since Ant 1.6
      */
     private boolean keepCompression = false;
 
     /**
      * Whether the file modification times will be rounded up to the
      * next even number of seconds.
      *
      * @since Ant 1.6.2
      */
     private boolean roundUp = true;
 
     /**
      * Comment for the archive.
      * @since Ant 1.6.3
      */
     private String comment = "";
 
     private int level = ZipOutputStream.DEFAULT_COMPRESSION;
 
     /**
      * Assume 0 Unix mode is intentional.
      * @since Ant 1.8.0
      */
     private boolean preserve0Permissions = false;
 
     /**
      * Whether to set the language encoding flag when creating the archive.
      *
      * @since Ant 1.8.0
      */
     private boolean useLanguageEncodingFlag = true;
 
     /**
      * Whether to add unicode extra fields.
      *
      * @since Ant 1.8.0
      */
     private UnicodeExtraField createUnicodeExtraFields =
         UnicodeExtraField.NEVER;
 
     /**
      * Whether to fall back to UTF-8 if a name cannot be enoded using
      * the specified encoding.
      *
      * @since Ant 1.8.0
      */
     private boolean fallBackToUTF8 = false;
 
     /**
      * This is the name/location of where to
      * create the .zip file.
      * @param zipFile the path of the zipFile
      * @deprecated since 1.5.x.
      *             Use setDestFile(File) instead.
      * @ant.attribute ignore="true"
      */
     public void setZipfile(File zipFile) {
         setDestFile(zipFile);
     }
 
     /**
      * This is the name/location of where to
      * create the file.
      * @param file the path of the zipFile
      * @since Ant 1.5
      * @deprecated since 1.5.x.
      *             Use setDestFile(File) instead.
      * @ant.attribute ignore="true"
      */
     public void setFile(File file) {
         setDestFile(file);
     }
 
 
     /**
      * The file to create; required.
      * @since Ant 1.5
      * @param destFile The new destination File
      */
     public void setDestFile(File destFile) {
        this.zipFile = destFile;
     }
 
     /**
      * The file to create.
      * @return the destination file
      * @since Ant 1.5.2
      */
     public File getDestFile() {
         return zipFile;
     }
 
 
     /**
      * Directory from which to archive files; optional.
      * @param baseDir the base directory
      */
     public void setBasedir(File baseDir) {
         this.baseDir = baseDir;
     }
 
     /**
      * Whether we want to compress the files or only store them;
      * optional, default=true;
      * @param c if true, compress the files
      */
     public void setCompress(boolean c) {
         doCompress = c;
     }
 
     /**
      * Whether we want to compress the files or only store them;
      * @return true if the files are to be compressed
      * @since Ant 1.5.2
      */
     public boolean isCompress() {
         return doCompress;
     }
 
     /**
      * If true, emulate Sun's jar utility by not adding parent directories;
      * optional, defaults to false.
      * @param f if true, emulate sun's jar by not adding parent directories
      */
     public void setFilesonly(boolean f) {
         doFilesonly = f;
     }
 
     /**
      * If true, updates an existing file, otherwise overwrite
      * any existing one; optional defaults to false.
      * @param c if true, updates an existing zip file
      */
     public void setUpdate(boolean c) {
         doUpdate = c;
         savedDoUpdate = c;
     }
 
     /**
      * Are we updating an existing archive?
      * @return true if updating an existing archive
      */
     public boolean isInUpdateMode() {
         return doUpdate;
     }
 
     /**
      * Adds a set of files.
      * @param set the fileset to add
      */
     public void addFileset(FileSet set) {
         add(set);
     }
 
     /**
      * Adds a set of files that can be
      * read from an archive and be given a prefix/fullpath.
      * @param set the zipfileset to add
      */
     public void addZipfileset(ZipFileSet set) {
         add(set);
     }
 
     /**
      * Add a collection of resources to be archived.
      * @param a the resources to archive
      * @since Ant 1.7
      */
     public void add(ResourceCollection a) {
         resources.add(a);
     }
 
     /**
      * Adds a group of zip files.
      * @param set the group (a fileset) to add
      */
     public void addZipGroupFileset(FileSet set) {
         groupfilesets.addElement(set);
     }
 
     /**
      * Sets behavior for when a duplicate file is about to be added -
      * one of <code>add</code>, <code>preserve</code> or <code>fail</code>.
      * Possible values are: <code>add</code> (keep both
      * of the files); <code>preserve</code> (keep the first version
      * of the file found); <code>fail</code> halt a problem
      * Default for zip tasks is <code>add</code>
      * @param df a <code>Duplicate</code> enumerated value
      */
     public void setDuplicate(Duplicate df) {
         duplicate = df.getValue();
     }
 
     /**
      * Possible behaviors when there are no matching files for the task:
      * "fail", "skip", or "create".
      */
     public static class WhenEmpty extends EnumeratedAttribute {
         /**
          * The string values for the enumerated value
          * @return the values
          */
         public String[] getValues() {
             return new String[] {"fail", "skip", "create"};
         }
     }
 
     /**
      * Sets behavior of the task when no files match.
      * Possible values are: <code>fail</code> (throw an exception
      * and halt the build); <code>skip</code> (do not create
      * any archive, but issue a warning); <code>create</code>
      * (make an archive with no entries).
      * Default for zip tasks is <code>skip</code>;
      * for jar tasks, <code>create</code>.
      * @param we a <code>WhenEmpty</code> enumerated value
      */
     public void setWhenempty(WhenEmpty we) {
         emptyBehavior = we.getValue();
     }
 
     /**
      * Encoding to use for filenames, defaults to the platform's
      * default encoding.
      *
      * <p>For a list of possible values see <a
      * href="http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.</p>
      * @param encoding the encoding name
      */
     public void setEncoding(String encoding) {
         this.encoding = encoding;
     }
 
     /**
      * Encoding to use for filenames.
      * @return the name of the encoding to use
      * @since Ant 1.5.2
      */
     public String getEncoding() {
         return encoding;
     }
 
     /**
      * Whether the original compression of entries coming from a ZIP
      * archive should be kept (for example when updating an archive).
      * Default is false.
      * @param keep if true, keep the original compression
      * @since Ant 1.6
      */
     public void setKeepCompression(boolean keep) {
         keepCompression = keep;
     }
 
     /**
      * Comment to use for archive.
      *
      * @param comment The content of the comment.
      * @since Ant 1.6.3
      */
     public void setComment(String comment) {
         this.comment = comment;
     }
 
     /**
      * Comment of the archive
      *
      * @return Comment of the archive.
      * @since Ant 1.6.3
      */
     public String getComment() {
         return comment;
     }
 
     /**
      * Set the compression level to use.  Default is
      * ZipOutputStream.DEFAULT_COMPRESSION.
      * @param level compression level.
      * @since Ant 1.7
      */
     public void setLevel(int level) {
         this.level = level;
     }
 
     /**
      * Get the compression level.
      * @return compression level.
      * @since Ant 1.7
      */
     public int getLevel() {
         return level;
     }
 
     /**
      * Whether the file modification times will be rounded up to the
      * next even number of seconds.
      *
      * <p>Zip archives store file modification times with a
      * granularity of two seconds, so the times will either be rounded
      * up or down.  If you round down, the archive will always seem
      * out-of-date when you rerun the task, so the default is to round
      * up.  Rounding up may lead to a different type of problems like
      * JSPs inside a web archive that seem to be slightly more recent
      * than precompiled pages, rendering precompilation useless.</p>
      * @param r a <code>boolean</code> value
      * @since Ant 1.6.2
      */
     public void setRoundUp(boolean r) {
         roundUp = r;
     }
 
     /**
      * Assume 0 Unix mode is intentional.
      * @since Ant 1.8.0
      */
     public void setPreserve0Permissions(boolean b) {
         preserve0Permissions = b;
     }
 
     /**
      * Assume 0 Unix mode is intentional.
      * @since Ant 1.8.0
      */
     public boolean getPreserve0Permissions() {
         return preserve0Permissions;
     }
 
     /**
      * Whether to set the language encoding flag.
      * @since Ant 1.8.0
      */
     public void setUseLanguageEncodingFlag(boolean b) {
         useLanguageEncodingFlag = b;
     }
 
     /**
      * Whether the language encoding flag will be used.
      * @since Ant 1.8.0
      */
     public boolean getUseLanguageEnodingFlag() {
         return useLanguageEncodingFlag;
     }
 
     /**
      * Whether Unicode extra fields will be created.
      * @since Ant 1.8.0
      */
     public void setCreateUnicodeExtraFields(UnicodeExtraField b) {
         createUnicodeExtraFields = b;
     }
 
     /**
      * Whether Unicode extra fields will be created.
      * @since Ant 1.8.0
      */
     public UnicodeExtraField getCreateUnicodeExtraFields() {
         return createUnicodeExtraFields;
     }
 
     /**
      * Whether to fall back to UTF-8 if a name cannot be enoded using
      * the specified encoding.
      *
      * <p>Defaults to false.</p>
      *
      * @since Ant 1.8.0
      */
     public void setFallBackToUTF8(boolean b) {
         fallBackToUTF8 = b;
     }
 
     /**
      * Whether to fall back to UTF-8 if a name cannot be enoded using
      * the specified encoding.
      *
      * @since Ant 1.8.0
      */
     public boolean getFallBackToUTF8() {
         return fallBackToUTF8;
     }
 
     /**
      * validate and build
      * @throws BuildException on error
      */
     public void execute() throws BuildException {
 
         if (doubleFilePass) {
             skipWriting = true;
             executeMain();
             skipWriting = false;
             executeMain();
         } else {
             executeMain();
         }
     }
 
     /**
      * Get the value of the updatedFile attribute.
      * This should only be called after executeMain has been
      * called.
      * @return true if executeMain has written to the zip file.
      */
     protected boolean hasUpdatedFile() {
         return updatedFile;
     }
 
     /**
      * Build the zip file.
      * This is called twice if doubleFilePass is true.
      * @throws BuildException on error
      */
     public void executeMain() throws BuildException {
 
         checkAttributesAndElements();
 
         // Renamed version of original file, if it exists
         File renamedFile = null;
         addingNewFiles = true;
 
         processDoUpdate();
         processGroupFilesets();
 
         // collect filesets to pass them to getResourcesToAdd
         Vector vfss = new Vector();
         if (baseDir != null) {
             FileSet fs = (FileSet) getImplicitFileSet().clone();
             fs.setDir(baseDir);
             vfss.addElement(fs);
         }
-        for (int i = 0; i < resources.size(); i++) {
+        final int size = resources.size();
+        for (int i = 0; i < size; i++) {
             ResourceCollection rc = (ResourceCollection) resources.elementAt(i);
             vfss.addElement(rc);
         }
 
         ResourceCollection[] fss = new ResourceCollection[vfss.size()];
         vfss.copyInto(fss);
         boolean success = false;
         try {
             // can also handle empty archives
             ArchiveState state = getResourcesToAdd(fss, zipFile, false);
 
             // quick exit if the target is up to date
             if (!state.isOutOfDate()) {
                 return;
             }
 
             File parent = zipFile.getParentFile();
             if (parent != null && !parent.isDirectory() && !parent.mkdirs()) {
                 throw new BuildException("Failed to create missing parent"
                                          + " directory for " + zipFile);
             }
 
             updatedFile = true;
             if (!zipFile.exists() && state.isWithoutAnyResources()) {
                 createEmptyZip(zipFile);
                 return;
             }
             Resource[][] addThem = state.getResourcesToAdd();
 
             if (doUpdate) {
                 renamedFile = renameFile();
             }
 
             String action = doUpdate ? "Updating " : "Building ";
 
             if (!skipWriting) {
                 log(action + archiveType + ": " + zipFile.getAbsolutePath());
             }
 
             ZipOutputStream zOut = null;
             try {
                 if (!skipWriting) {
                     zOut = new ZipOutputStream(zipFile);
 
                     zOut.setEncoding(encoding);
                     zOut.setUseLanguageEncodingFlag(useLanguageEncodingFlag);
                     zOut.setCreateUnicodeExtraFields(createUnicodeExtraFields.
                                                      getPolicy());
                     zOut.setFallbackToUTF8(fallBackToUTF8);
                     zOut.setMethod(doCompress
                         ? ZipOutputStream.DEFLATED : ZipOutputStream.STORED);
                     zOut.setLevel(level);
                 }
                 initZipOutputStream(zOut);
 
                 // Add the explicit resource collections to the archive.
                 for (int i = 0; i < fss.length; i++) {
                     if (addThem[i].length != 0) {
                         addResources(fss[i], addThem[i], zOut);
                     }
                 }
 
                 if (doUpdate) {
                     addingNewFiles = false;
                     ZipFileSet oldFiles = new ZipFileSet();
                     oldFiles.setProject(getProject());
                     oldFiles.setSrc(renamedFile);
                     oldFiles.setDefaultexcludes(false);
 
-                    for (int i = 0; i < addedFiles.size(); i++) {
+                    final int addSize = addedFiles.size();
+                    for (int i = 0; i < addSize; i++) {
                         PatternSet.NameEntry ne = oldFiles.createExclude();
                         ne.setName((String) addedFiles.elementAt(i));
                     }
                     DirectoryScanner ds =
                         oldFiles.getDirectoryScanner(getProject());
                     ((ZipScanner) ds).setEncoding(encoding);
 
                     String[] f = ds.getIncludedFiles();
                     Resource[] r = new Resource[f.length];
                     for (int i = 0; i < f.length; i++) {
                         r[i] = ds.getResource(f[i]);
                     }
 
                     if (!doFilesonly) {
                         String[] d = ds.getIncludedDirectories();
                         Resource[] dr = new Resource[d.length];
                         for (int i = 0; i < d.length; i++) {
                             dr[i] = ds.getResource(d[i]);
                         }
                         Resource[] tmp = r;
                         r = new Resource[tmp.length + dr.length];
                         System.arraycopy(dr, 0, r, 0, dr.length);
                         System.arraycopy(tmp, 0, r, dr.length, tmp.length);
                     }
                     addResources(oldFiles, r, zOut);
                 }
                 if (zOut != null) {
                     zOut.setComment(comment);
                 }
                 finalizeZipOutputStream(zOut);
 
                 // If we've been successful on an update, delete the
                 // temporary file
                 if (doUpdate) {
                     if (!renamedFile.delete()) {
                         log ("Warning: unable to delete temporary file "
                             + renamedFile.getName(), Project.MSG_WARN);
                     }
                 }
                 success = true;
             } finally {
                 // Close the output stream.
                 closeZout(zOut, success);
             }
         } catch (IOException ioe) {
             String msg = "Problem creating " + archiveType + ": "
                 + ioe.getMessage();
 
             // delete a bogus ZIP file (but only if it's not the original one)
             if ((!doUpdate || renamedFile != null) && !zipFile.delete()) {
                 msg += " (and the archive is probably corrupt but I could not "
                     + "delete it)";
             }
 
             if (doUpdate && renamedFile != null) {
                 try {
                     FILE_UTILS.rename(renamedFile, zipFile);
                 } catch (IOException e) {
                     msg += " (and I couldn't rename the temporary file "
                             + renamedFile.getName() + " back)";
                 }
             }
 
             throw new BuildException(msg, ioe, getLocation());
         } finally {
             cleanUp();
         }
     }
 
     /** rename the zip file. */
     private File renameFile() {
         File renamedFile = FILE_UTILS.createTempFile(
             "zip", ".tmp", zipFile.getParentFile(), true, false);
         try {
             FILE_UTILS.rename(zipFile, renamedFile);
         } catch (SecurityException e) {
             throw new BuildException(
                 "Not allowed to rename old file ("
                 + zipFile.getAbsolutePath()
                 + ") to temporary file");
         } catch (IOException e) {
             throw new BuildException(
                 "Unable to rename old file ("
                 + zipFile.getAbsolutePath()
                 + ") to temporary file");
         }
         return renamedFile;
     }
 
     /** Close zout */
     private void closeZout(ZipOutputStream zOut, boolean success)
         throws IOException {
         if (zOut == null) {
             return;
         }
         try {
             zOut.close();
         } catch (IOException ex) {
             // If we're in this finally clause because of an
             // exception, we don't really care if there's an
             // exception when closing the stream. E.g. if it
             // throws "ZIP file must have at least one entry",
             // because an exception happened before we added
             // any files, then we must swallow this
             // exception. Otherwise, the error that's reported
             // will be the close() error, which is not the
             // real cause of the problem.
             if (success) {
                 throw ex;
             }
         }
     }
 
     /** Check the attributes and elements */
     private void checkAttributesAndElements() {
         if (baseDir == null && resources.size() == 0
             && groupfilesets.size() == 0 && "zip".equals(archiveType)) {
             throw new BuildException("basedir attribute must be set, "
                                      + "or at least one "
                                      + "resource collection must be given!");
         }
 
         if (zipFile == null) {
             throw new BuildException("You must specify the "
                                      + archiveType + " file to create!");
         }
 
         if (zipFile.exists() && !zipFile.isFile()) {
             throw new BuildException(zipFile + " is not a file.");
         }
 
         if (zipFile.exists() && !zipFile.canWrite()) {
             throw new BuildException(zipFile + " is read-only.");
         }
     }
 
     /** Process doupdate */
     private void processDoUpdate() {
         // Whether or not an actual update is required -
         // we don't need to update if the original file doesn't exist
         if (doUpdate && !zipFile.exists()) {
             doUpdate = false;
             logWhenWriting("ignoring update attribute as " + archiveType
                            + " doesn't exist.", Project.MSG_DEBUG);
         }
     }
 
     /** Process groupfilesets */
     private void processGroupFilesets() {
         // Add the files found in groupfileset to fileset
-        for (int i = 0; i < groupfilesets.size(); i++) {
+        final int size = groupfilesets.size();
+        for (int i = 0; i < size; i++) {
 
             logWhenWriting("Processing groupfileset ", Project.MSG_VERBOSE);
             FileSet fs = (FileSet) groupfilesets.elementAt(i);
             FileScanner scanner = fs.getDirectoryScanner(getProject());
             String[] files = scanner.getIncludedFiles();
             File basedir = scanner.getBasedir();
             for (int j = 0; j < files.length; j++) {
 
                 logWhenWriting("Adding file " + files[j] + " to fileset",
                                Project.MSG_VERBOSE);
                 ZipFileSet zf = new ZipFileSet();
                 zf.setProject(getProject());
                 zf.setSrc(new File(basedir, files[j]));
                 add(zf);
                 filesetsFromGroupfilesets.addElement(zf);
             }
         }
     }
 
     /**
      * Indicates if the task is adding new files into the archive as opposed to
      * copying back unchanged files from the backup copy
      * @return true if adding new files
      */
     protected final boolean isAddingNewFiles() {
         return addingNewFiles;
     }
 
     /**
      * Add the given resources.
      *
      * @param fileset may give additional information like fullpath or
      * permissions.
      * @param resources the resources to add
      * @param zOut the stream to write to
      * @throws IOException on error
      *
      * @since Ant 1.5.2
      */
     protected final void addResources(FileSet fileset, Resource[] resources,
                                       ZipOutputStream zOut)
         throws IOException {
 
         String prefix = "";
         String fullpath = "";
         int dirMode = ArchiveFileSet.DEFAULT_DIR_MODE;
         int fileMode = ArchiveFileSet.DEFAULT_FILE_MODE;
 
         ArchiveFileSet zfs = null;
         if (fileset instanceof ArchiveFileSet) {
             zfs = (ArchiveFileSet) fileset;
             prefix = zfs.getPrefix(getProject());
             fullpath = zfs.getFullpath(getProject());
             dirMode = zfs.getDirMode(getProject());
             fileMode = zfs.getFileMode(getProject());
         }
 
         if (prefix.length() > 0 && fullpath.length() > 0) {
             throw new BuildException("Both prefix and fullpath attributes must"
                                      + " not be set on the same fileset.");
         }
 
         if (resources.length != 1 && fullpath.length() > 0) {
             throw new BuildException("fullpath attribute may only be specified"
                                      + " for filesets that specify a single"
                                      + " file.");
         }
 
         if (prefix.length() > 0) {
             if (!prefix.endsWith("/") && !prefix.endsWith("\\")) {
                 prefix += "/";
             }
             addParentDirs(null, prefix, zOut, "", dirMode);
         }
 
         ZipFile zf = null;
         try {
             boolean dealingWithFiles = false;
             File base = null;
 
             if (zfs == null || zfs.getSrc(getProject()) == null) {
                 dealingWithFiles = true;
                 base = fileset.getDir(getProject());
             } else if (zfs instanceof ZipFileSet) {
                 zf = new ZipFile(zfs.getSrc(getProject()), encoding);
             }
 
             for (int i = 0; i < resources.length; i++) {
                 String name = null;
                 if (fullpath.length() > 0) {
                     name = fullpath;
                 } else {
                     name = resources[i].getName();
                 }
                 name = name.replace(File.separatorChar, '/');
 
                 if ("".equals(name)) {
                     continue;
                 }
 
                 if (resources[i].isDirectory()) {
                     if (doFilesonly) {
                         continue;
                     }
                     int thisDirMode = zfs != null && zfs.hasDirModeBeenSet()
                         ? dirMode : getUnixMode(resources[i], zf, dirMode);
                     addDirectoryResource(resources[i], name, prefix,
                                          base, zOut,
                                          dirMode, thisDirMode);
 
                 } else { // !isDirectory
 
                     addParentDirs(base, name, zOut, prefix, dirMode);
 
                     if (dealingWithFiles) {
                         File f = FILE_UTILS.resolveFile(base,
                                                         resources[i].getName());
                         zipFile(f, zOut, prefix + name, fileMode);
                     } else {
                         int thisFileMode =
                             zfs != null && zfs.hasFileModeBeenSet()
                             ? fileMode : getUnixMode(resources[i], zf,
                                                      fileMode);
                         addResource(resources[i], name, prefix,
                                     zOut, thisFileMode, zf,
                                     zfs == null
                                     ? null : zfs.getSrc(getProject()));
                     }
                 }
             }
         } finally {
             if (zf != null) {
                 zf.close();
             }
         }
     }
 
     /**
      * Add a directory entry to the archive using a specified
      * Unix-mode and the default mode for its parent directories (if
      * necessary).
      */
     private void addDirectoryResource(Resource r, String name, String prefix,
                                       File base, ZipOutputStream zOut,
                                       int defaultDirMode, int thisDirMode)
         throws IOException {
 
         if (!name.endsWith("/")) {
             name = name + "/";
         }
 
         int nextToLastSlash = name.lastIndexOf("/", name.length() - 2);
         if (nextToLastSlash != -1) {
             addParentDirs(base, name.substring(0, nextToLastSlash + 1),
                           zOut, prefix, defaultDirMode);
         }
         zipDir(r, zOut, prefix + name, thisDirMode,
                r instanceof ZipResource
                ? ((ZipResource) r).getExtraFields() : null);
     }
 
     /**
      * Determine a Resource's Unix mode or return the given default
      * value if not available.
      */
     private int getUnixMode(Resource r, ZipFile zf, int defaultMode)
         throws IOException {
 
         int unixMode = defaultMode;
         if (zf != null) {
             ZipEntry ze = zf.getEntry(r.getName());
             unixMode = ze.getUnixMode();
             if ((unixMode == 0 || unixMode == UnixStat.DIR_FLAG)
                 && !preserve0Permissions) {
                 unixMode = defaultMode;
             }
         } else if (r instanceof ArchiveResource) {
             unixMode = ((ArchiveResource) r).getMode();
         }
         return unixMode;
     }
 
     /**
      * Add a file entry.
      */
     private void addResource(Resource r, String name, String prefix,
                              ZipOutputStream zOut, int mode,
                              ZipFile zf, File fromArchive)
         throws IOException {
 
         if (zf != null) {
             ZipEntry ze = zf.getEntry(r.getName());
 
             if (ze != null) {
                 boolean oldCompress = doCompress;
                 if (keepCompression) {
                     doCompress = (ze.getMethod() == ZipEntry.DEFLATED);
                 }
                 InputStream is = null;
                 try {
                     is = zf.getInputStream(ze);
                     zipFile(is, zOut, prefix + name, ze.getTime(),
                             fromArchive, mode, ze.getExtraFields(true));
                 } finally {
                     doCompress = oldCompress;
                     FileUtils.close(is);
                 }
             }
         } else {
             InputStream is = null;
             try {
                 is = r.getInputStream();
                 zipFile(is, zOut, prefix + name, r.getLastModified(),
                         fromArchive, mode, r instanceof ZipResource
                         ? ((ZipResource) r).getExtraFields() : null);
             } finally {
                 FileUtils.close(is);
             }
         }
     }
 
     /**
      * Add the given resources.
      *
      * @param rc may give additional information like fullpath or
      * permissions.
      * @param resources the resources to add
      * @param zOut the stream to write to
      * @throws IOException on error
      *
      * @since Ant 1.7
      */
     protected final void addResources(ResourceCollection rc,
                                       Resource[] resources,
                                       ZipOutputStream zOut)
         throws IOException {
         if (rc instanceof FileSet) {
             addResources((FileSet) rc, resources, zOut);
             return;
         }
         for (int i = 0; i < resources.length; i++) {
             String name = resources[i].getName().replace(File.separatorChar,
                                                          '/');
             if ("".equals(name)) {
                 continue;
             }
             if (resources[i].isDirectory() && doFilesonly) {
                 continue;
             }
             File base = null;
             FileProvider fp = (FileProvider) resources[i].as(FileProvider.class);
             if (fp != null) {
                 base = ResourceUtils.asFileResource(fp).getBaseDir();
             }
 
             if (resources[i].isDirectory()) {
                 addDirectoryResource(resources[i], name, "", base, zOut,
                                      ArchiveFileSet.DEFAULT_DIR_MODE,
                                      ArchiveFileSet.DEFAULT_DIR_MODE);
 
             } else {
                 addParentDirs(base, name, zOut, "",
                               ArchiveFileSet.DEFAULT_DIR_MODE);
 
                 if (fp != null) {
                     File f = (fp).getFile();
                     zipFile(f, zOut, name, ArchiveFileSet.DEFAULT_FILE_MODE);
                 } else {
                     addResource(resources[i], name, "", zOut,
                                 ArchiveFileSet.DEFAULT_FILE_MODE,
                                 null, null);
                 }
             }
         }
     }
 
     /**
      * method for subclasses to override
      * @param zOut the zip output stream
      * @throws IOException on output error
      * @throws BuildException on other errors
      */
     protected void initZipOutputStream(ZipOutputStream zOut)
         throws IOException, BuildException {
     }
 
     /**
      * method for subclasses to override
      * @param zOut the zip output stream
      * @throws IOException on output error
      * @throws BuildException on other errors
      */
     protected void finalizeZipOutputStream(ZipOutputStream zOut)
         throws IOException, BuildException {
     }
 
     /**
      * Create an empty zip file
      * @param zipFile the zip file
      * @return true for historic reasons
      * @throws BuildException on error
      */
     protected boolean createEmptyZip(File zipFile) throws BuildException {
         // In this case using java.util.zip will not work
         // because it does not permit a zero-entry archive.
         // Must create it manually.
         if (!skipWriting) {
             log("Note: creating empty " + archiveType + " archive " + zipFile,
                 Project.MSG_INFO);
         }
         OutputStream os = null;
         try {
             os = new FileOutputStream(zipFile);
             // CheckStyle:MagicNumber OFF
             // Cf. PKZIP specification.
             byte[] empty = new byte[22];
             empty[0] = 80; // P
             empty[1] = 75; // K
             empty[2] = 5;
             empty[3] = 6;
             // remainder zeros
             // CheckStyle:MagicNumber ON
             os.write(empty);
         } catch (IOException ioe) {
             throw new BuildException("Could not create empty ZIP archive "
                                      + "(" + ioe.getMessage() + ")", ioe,
                                      getLocation());
         } finally {
             FileUtils.close(os);
         }
         return true;
     }
 
     /**
      * @since Ant 1.5.2
      */
     private synchronized ZipScanner getZipScanner() {
         if (zs == null) {
             zs = new ZipScanner();
             zs.setEncoding(encoding);
             zs.setSrc(zipFile);
         }
         return zs;
     }
 
     /**
      * Collect the resources that are newer than the corresponding
      * entries (or missing) in the original archive.
      *
      * <p>If we are going to recreate the archive instead of updating
      * it, all resources should be considered as new, if a single one
      * is.  Because of this, subclasses overriding this method must
      * call <code>super.getResourcesToAdd</code> and indicate with the
      * third arg if they already know that the archive is
      * out-of-date.</p>
      *
      * <p>This method first delegates to getNonFileSetResourceToAdd
      * and then invokes the FileSet-arg version.  All this to keep
      * backwards compatibility for subclasses that don't know how to
      * deal with non-FileSet ResourceCollections.</p>
      *
      * @param rcs The resource collections to grab resources from
      * @param zipFile intended archive file (may or may not exist)
      * @param needsUpdate whether we already know that the archive is
      * out-of-date.  Subclasses overriding this method are supposed to
      * set this value correctly in their call to
      * <code>super.getResourcesToAdd</code>.
      * @return an array of resources to add for each fileset passed in as well
      *         as a flag that indicates whether the archive is uptodate.
      *
      * @exception BuildException if it likes
      * @since Ant 1.7
      */
     protected ArchiveState getResourcesToAdd(ResourceCollection[] rcs,
                                              File zipFile,
                                              boolean needsUpdate)
         throws BuildException {
         ArrayList filesets = new ArrayList();
         ArrayList rest = new ArrayList();
         for (int i = 0; i < rcs.length; i++) {
             if (rcs[i] instanceof FileSet) {
                 filesets.add(rcs[i]);
             } else {
                 rest.add(rcs[i]);
             }
         }
         ResourceCollection[] rc = (ResourceCollection[])
             rest.toArray(new ResourceCollection[rest.size()]);
         ArchiveState as = getNonFileSetResourcesToAdd(rc, zipFile,
                                                       needsUpdate);
 
         FileSet[] fs = (FileSet[]) filesets.toArray(new FileSet[filesets
                                                                 .size()]);
         ArchiveState as2 = getResourcesToAdd(fs, zipFile, as.isOutOfDate());
         if (!as.isOutOfDate() && as2.isOutOfDate()) {
             /*
              * Bad luck.
              *
              * There are resources in the filesets that make the
              * archive out of date, but not in the non-fileset
              * resources. We need to rescan the non-FileSets to grab
              * all of them now.
              */
             as = getNonFileSetResourcesToAdd(rc, zipFile, true);
         }
 
         Resource[][] toAdd = new Resource[rcs.length][];
         int fsIndex = 0;
         int restIndex = 0;
         for (int i = 0; i < rcs.length; i++) {
             if (rcs[i] instanceof FileSet) {
                 toAdd[i] = as2.getResourcesToAdd()[fsIndex++];
             } else {
                 toAdd[i] = as.getResourcesToAdd()[restIndex++];
             }
         }
         return new ArchiveState(as2.isOutOfDate(), toAdd);
     }
 
     /*
      * This is yet another hacky construct to extend the FileSet[]
      * getResourcesToAdd method so we can pass the information whether
      * non-fileset resources have been available to it without having
      * to move the withEmpty behavior checks (since either would break
      * subclasses in several ways).
      */
     private static ThreadLocal haveNonFileSetResourcesToAdd = new ThreadLocal() {
             protected Object initialValue() {
                 return Boolean.FALSE;
             }
         };
 
     /**
      * Collect the resources that are newer than the corresponding
      * entries (or missing) in the original archive.
      *
      * <p>If we are going to recreate the archive instead of updating
      * it, all resources should be considered as new, if a single one
      * is.  Because of this, subclasses overriding this method must
      * call <code>super.getResourcesToAdd</code> and indicate with the
      * third arg if they already know that the archive is
      * out-of-date.</p>
      *
      * @param filesets The filesets to grab resources from
      * @param zipFile intended archive file (may or may not exist)
      * @param needsUpdate whether we already know that the archive is
      * out-of-date.  Subclasses overriding this method are supposed to
      * set this value correctly in their call to
      * <code>super.getResourcesToAdd</code>.
      * @return an array of resources to add for each fileset passed in as well
      *         as a flag that indicates whether the archive is uptodate.
      *
      * @exception BuildException if it likes
      */
     protected ArchiveState getResourcesToAdd(FileSet[] filesets,
                                              File zipFile,
                                              boolean needsUpdate)
         throws BuildException {
 
         Resource[][] initialResources = grabResources(filesets);
         if (isEmpty(initialResources)) {
             if (Boolean.FALSE.equals(haveNonFileSetResourcesToAdd.get())) {
                 if (needsUpdate && doUpdate) {
                     /*
                      * This is a rather hairy case.
                      *
                      * One of our subclasses knows that we need to
                      * update the archive, but at the same time, there
                      * are no resources known to us that would need to
                      * be added.  Only the subclass seems to know
                      * what's going on.
                      *
                      * This happens if <jar> detects that the manifest
                      * has changed, for example.  The manifest is not
                      * part of any resources because of our support
                      * for inline <manifest>s.
                      *
                      * If we invoke createEmptyZip like Ant 1.5.2 did,
                      * we'll loose all stuff that has been in the
                      * original archive (bugzilla report 17780).
                      */
                     return new ArchiveState(true, initialResources);
                 }
 
                 if (emptyBehavior.equals("skip")) {
                     if (doUpdate) {
                         logWhenWriting(archiveType + " archive " + zipFile
                                        + " not updated because no new files were"
                                        + " included.", Project.MSG_VERBOSE);
                     } else {
                         logWhenWriting("Warning: skipping " + archiveType
                                        + " archive " + zipFile
                                        + " because no files were included.",
                                        Project.MSG_WARN);
                     }
                 } else if (emptyBehavior.equals("fail")) {
                     throw new BuildException("Cannot create " + archiveType
                                              + " archive " + zipFile
                                              + ": no files were included.",
                                              getLocation());
                 } else {
                     // Create.
                     if (!zipFile.exists())  {
                         needsUpdate = true;
                     }
                 }
             }
 
             // either there are non-fileset resources or we
             // (re-)create the archive anyway
             return new ArchiveState(needsUpdate, initialResources);
         }
 
         // initialResources is not empty
 
         if (!zipFile.exists()) {
             return new ArchiveState(true, initialResources);
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         Resource[][] newerResources = new Resource[filesets.length][];
 
         for (int i = 0; i < filesets.length; i++) {
             if (!(fileset instanceof ZipFileSet)
                 || ((ZipFileSet) fileset).getSrc(getProject()) == null) {
                 File base = filesets[i].getDir(getProject());
 
                 for (int j = 0; j < initialResources[i].length; j++) {
                     File resourceAsFile =
                         FILE_UTILS.resolveFile(base,
                                               initialResources[i][j].getName());
                     if (resourceAsFile.equals(zipFile)) {
                         throw new BuildException("A zip file cannot include "
                                                  + "itself", getLocation());
                     }
                 }
             }
         }
 
         for (int i = 0; i < filesets.length; i++) {
             if (initialResources[i].length == 0) {
                 newerResources[i] = new Resource[] {};
                 continue;
             }
 
             FileNameMapper myMapper = new IdentityMapper();
             if (filesets[i] instanceof ZipFileSet) {
                 ZipFileSet zfs = (ZipFileSet) filesets[i];
                 if (zfs.getFullpath(getProject()) != null
                     && !zfs.getFullpath(getProject()).equals("")) {
                     // in this case all files from origin map to
                     // the fullPath attribute of the zipfileset at
                     // destination
                     MergingMapper fm = new MergingMapper();
                     fm.setTo(zfs.getFullpath(getProject()));
                     myMapper = fm;
 
                 } else if (zfs.getPrefix(getProject()) != null
                            && !zfs.getPrefix(getProject()).equals("")) {
                     GlobPatternMapper gm = new GlobPatternMapper();
                     gm.setFrom("*");
                     String prefix = zfs.getPrefix(getProject());
                     if (!prefix.endsWith("/") && !prefix.endsWith("\\")) {
                         prefix += "/";
                     }
                     gm.setTo(prefix + "*");
                     myMapper = gm;
                 }
             }
 
             newerResources[i] = selectOutOfDateResources(initialResources[i],
                                                          myMapper);
             needsUpdate = needsUpdate || (newerResources[i].length > 0);
 
             if (needsUpdate && !doUpdate) {
                 // we will return initialResources anyway, no reason
                 // to scan further.
                 break;
             }
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         return new ArchiveState(needsUpdate, newerResources);
     }
 
     /**
      * Collect the resources that are newer than the corresponding
      * entries (or missing) in the original archive.
      *
      * <p>If we are going to recreate the archive instead of updating
      * it, all resources should be considered as new, if a single one
      * is.  Because of this, subclasses overriding this method must
      * call <code>super.getResourcesToAdd</code> and indicate with the
      * third arg if they already know that the archive is
      * out-of-date.</p>
      *
      * @param rcs The filesets to grab resources from
      * @param zipFile intended archive file (may or may not exist)
      * @param needsUpdate whether we already know that the archive is
      * out-of-date.  Subclasses overriding this method are supposed to
      * set this value correctly in their call to
      * <code>super.getResourcesToAdd</code>.
      * @return an array of resources to add for each fileset passed in as well
      *         as a flag that indicates whether the archive is uptodate.
      *
      * @exception BuildException if it likes
      */
     protected ArchiveState getNonFileSetResourcesToAdd(ResourceCollection[] rcs,
                                                        File zipFile,
                                                        boolean needsUpdate)
         throws BuildException {
         /*
          * Backwards compatibility forces us to repeat the logic of
          * getResourcesToAdd(FileSet[], ...) here once again.
          */
 
         Resource[][] initialResources = grabNonFileSetResources(rcs);
         boolean empty = isEmpty(initialResources);
         haveNonFileSetResourcesToAdd.set(Boolean.valueOf(!empty));
         if (empty) {
             // no emptyBehavior handling since the FileSet version
             // will take care of it.
             return new ArchiveState(needsUpdate, initialResources);
         }
 
         // initialResources is not empty
 
         if (!zipFile.exists()) {
             return new ArchiveState(true, initialResources);
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         Resource[][] newerResources = new Resource[rcs.length][];
 
         for (int i = 0; i < rcs.length; i++) {
             if (initialResources[i].length == 0) {
                 newerResources[i] = new Resource[] {};
                 continue;
             }
 
             for (int j = 0; j < initialResources[i].length; j++) {
                 FileProvider fp =
                     (FileProvider) initialResources[i][j].as(FileProvider.class);
                 if (fp != null && zipFile.equals(fp.getFile())) {
                     throw new BuildException("A zip file cannot include "
                                              + "itself", getLocation());
                 }
             }
 
             newerResources[i] = selectOutOfDateResources(initialResources[i],
                                                          new IdentityMapper());
             needsUpdate = needsUpdate || (newerResources[i].length > 0);
 
             if (needsUpdate && !doUpdate) {
                 // we will return initialResources anyway, no reason
                 // to scan further.
                 break;
             }
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         return new ArchiveState(needsUpdate, newerResources);
     }
 
     private Resource[] selectOutOfDateResources(Resource[] initial,
                                                 FileNameMapper mapper) {
         Resource[] rs = selectFileResources(initial);
         Resource[] result =
             ResourceUtils.selectOutOfDateSources(this, rs, mapper,
                                                  getZipScanner());
         if (!doFilesonly) {
             Union u = new Union();
             u.addAll(Arrays.asList(selectDirectoryResources(initial)));
             ResourceCollection rc =
                 ResourceUtils.selectSources(this, u, mapper,
                                             getZipScanner(),
                                             MISSING_DIR_PROVIDER);
             if (rc.size() > 0) {
                 ArrayList newer = new ArrayList();
                 newer.addAll(Arrays.asList(((Union) rc).listResources()));
                 newer.addAll(Arrays.asList(result));
                 result = (Resource[]) newer.toArray(result);
             }
         }
         return result;
     }
 
     /**
      * Fetch all included and not excluded resources from the sets.
      *
      * <p>Included directories will precede included files.</p>
      * @param filesets an array of filesets
      * @return the resources included
      * @since Ant 1.5.2
      */
     protected Resource[][] grabResources(FileSet[] filesets) {
         Resource[][] result = new Resource[filesets.length][];
         for (int i = 0; i < filesets.length; i++) {
             boolean skipEmptyNames = true;
             if (filesets[i] instanceof ZipFileSet) {
                 ZipFileSet zfs = (ZipFileSet) filesets[i];
                 skipEmptyNames = zfs.getPrefix(getProject()).equals("")
                     && zfs.getFullpath(getProject()).equals("");
             }
             DirectoryScanner rs =
                 filesets[i].getDirectoryScanner(getProject());
             if (rs instanceof ZipScanner) {
                 ((ZipScanner) rs).setEncoding(encoding);
             }
             Vector resources = new Vector();
             if (!doFilesonly) {
                 String[] directories = rs.getIncludedDirectories();
                 for (int j = 0; j < directories.length; j++) {
                     if (!"".equals(directories[j]) || !skipEmptyNames) {
                         resources.addElement(rs.getResource(directories[j]));
                     }
                 }
             }
             String[] files = rs.getIncludedFiles();
             for (int j = 0; j < files.length; j++) {
                 if (!"".equals(files[j]) || !skipEmptyNames) {
                     resources.addElement(rs.getResource(files[j]));
                 }
             }
 
             result[i] = new Resource[resources.size()];
             resources.copyInto(result[i]);
         }
         return result;
     }
 
     /**
      * Fetch all included and not excluded resources from the collections.
      *
      * <p>Included directories will precede included files.</p>
      * @param rcs an array of resource collections
      * @return the resources included
      * @since Ant 1.7
      */
     protected Resource[][] grabNonFileSetResources(ResourceCollection[] rcs) {
         Resource[][] result = new Resource[rcs.length][];
         for (int i = 0; i < rcs.length; i++) {
             Iterator iter = rcs[i].iterator();
             ArrayList dirs = new ArrayList();
             ArrayList files = new ArrayList();
             while (iter.hasNext()) {
                 Resource r = (Resource) iter.next();
                 if (r.isExists()) {
                     if (r.isDirectory()) {
                         dirs.add(r);
                     } else {
                         files.add(r);
                     }
                 }
             }
             // make sure directories are in alpha-order - this also
             // ensures parents come before their children
             Collections.sort(dirs, new Comparator() {
                     public int compare(Object o1, Object o2) {
                         Resource r1 = (Resource) o1;
                         Resource r2 = (Resource) o2;
                         return r1.getName().compareTo(r2.getName());
                     }
                 });
             ArrayList rs = new ArrayList(dirs);
             rs.addAll(files);
             result[i] = (Resource[]) rs.toArray(new Resource[rs.size()]);
         }
         return result;
     }
 
     /**
      * Add a directory to the zip stream.
      * @param dir  the directort to add to the archive
      * @param zOut the stream to write to
      * @param vPath the name this entry shall have in the archive
      * @param mode the Unix permissions to set.
      * @throws IOException on error
      * @since Ant 1.5.2
      */
     protected void zipDir(File dir, ZipOutputStream zOut, String vPath,
                           int mode)
         throws IOException {
         zipDir(dir, zOut, vPath, mode, null);
     }
 
     /**
      * Add a directory to the zip stream.
      * @param dir  the directory to add to the archive
      * @param zOut the stream to write to
      * @param vPath the name this entry shall have in the archive
      * @param mode the Unix permissions to set.
      * @param extra ZipExtraFields to add
      * @throws IOException on error
      * @since Ant 1.6.3
      */
     protected void zipDir(File dir, ZipOutputStream zOut, String vPath,
                           int mode, ZipExtraField[] extra)
         throws IOException {
         zipDir(dir == null ? (Resource) null : new FileResource(dir),
                zOut, vPath, mode, extra);
     }
 
     /**
      * Add a directory to the zip stream.
      * @param dir  the directory to add to the archive
      * @param zOut the stream to write to
      * @param vPath the name this entry shall have in the archive
      * @param mode the Unix permissions to set.
      * @param extra ZipExtraFields to add
      * @throws IOException on error
      * @since Ant 1.8.0
      */
     protected void zipDir(Resource dir, ZipOutputStream zOut, String vPath,
                           int mode, ZipExtraField[] extra)
         throws IOException {
         if (doFilesonly) {
             logWhenWriting("skipping directory " + vPath
                            + " for file-only archive",
                            Project.MSG_VERBOSE);
             return;
         }
         if (addedDirs.get(vPath) != null) {
             // don't add directories we've already added.
             // no warning if we try, it is harmless in and of itself
             return;
         }
 
         logWhenWriting("adding directory " + vPath, Project.MSG_VERBOSE);
         addedDirs.put(vPath, vPath);
 
         if (!skipWriting) {
             ZipEntry ze = new ZipEntry (vPath);
 
             // ZIPs store time with a granularity of 2 seconds, round up
             int millisToAdd = roundUp ? ROUNDUP_MILLIS : 0;
 
             if (dir != null && dir.isExists()) {
                 ze.setTime(dir.getLastModified() + millisToAdd);
             } else {
                 ze.setTime(System.currentTimeMillis() + millisToAdd);
             }
             ze.setSize (0);
             ze.setMethod (ZipEntry.STORED);
             // This is faintly ridiculous:
             ze.setCrc (EMPTY_CRC);
             ze.setUnixMode(mode);
 
             if (extra != null) {
                 ze.setExtraFields(extra);
             }
 
             zOut.putNextEntry(ze);
         }
     }
 
     /*
      * This is a hacky construct to extend the zipFile method to
      * support a new parameter (extra fields to preserve) without
      * breaking subclasses that override the old method signature.
      */
     private static ThreadLocal currentZipExtra = new ThreadLocal() {
             protected Object initialValue() {
                 return null;
             }
         };
 
     /**
      * Provides the extra fields for the zip entry currently being
      * added to the archive - if any.
      * @since Ant 1.8.0
      */
     protected final ZipExtraField[] getCurrentExtraFields() {
         return (ZipExtraField[]) currentZipExtra.get();
     }
 
     /**
      * Sets the extra fields for the zip entry currently being
      * added to the archive - if any.
      * @since Ant 1.8.0
      */
     protected final void setCurrentExtraFields(ZipExtraField[] extra) {
         currentZipExtra.set(extra);
     }
 
     /**
      * Adds a new entry to the archive, takes care of duplicates as well.
      *
      * @param in the stream to read data for the entry from.  The
      * caller of the method is responsible for closing the stream.
      * @param zOut the stream to write to.
      * @param vPath the name this entry shall have in the archive.
      * @param lastModified last modification time for the entry.
      * @param fromArchive the original archive we are copying this
      * entry from, will be null if we are not copying from an archive.
      * @param mode the Unix permissions to set.
      *
      * @since Ant 1.5.2
      * @throws IOException on error
      */
     protected void zipFile(InputStream in, ZipOutputStream zOut, String vPath,
                            long lastModified, File fromArchive, int mode)
         throws IOException {
         // fromArchive is used in subclasses overriding this method
 
         if (entries.containsKey(vPath)) {
 
             if (duplicate.equals("preserve")) {
                 logWhenWriting(vPath + " already added, skipping",
                                Project.MSG_INFO);
                 return;
             } else if (duplicate.equals("fail")) {
                 throw new BuildException("Duplicate file " + vPath
                                          + " was found and the duplicate "
                                          + "attribute is 'fail'.");
             } else {
                 // duplicate equal to add, so we continue
                 logWhenWriting("duplicate file " + vPath
                                + " found, adding.", Project.MSG_VERBOSE);
             }
         } else {
             logWhenWriting("adding entry " + vPath, Project.MSG_VERBOSE);
         }
 
         entries.put(vPath, vPath);
 
         if (!skipWriting) {
             ZipEntry ze = new ZipEntry(vPath);
             ze.setTime(lastModified);
             ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);
 
             /*
              * ZipOutputStream.putNextEntry expects the ZipEntry to
              * know its size and the CRC sum before you start writing
              * the data when using STORED mode - unless it is seekable.
              *
              * This forces us to process the data twice.
              */
             if (!zOut.isSeekable() && !doCompress) {
                 long size = 0;
                 CRC32 cal = new CRC32();
                 if (!in.markSupported()) {
                     // Store data into a byte[]
                     ByteArrayOutputStream bos = new ByteArrayOutputStream();
 
                     byte[] buffer = new byte[BUFFER_SIZE];
                     int count = 0;
                     do {
                         size += count;
                         cal.update(buffer, 0, count);
                         bos.write(buffer, 0, count);
                         count = in.read(buffer, 0, buffer.length);
                     } while (count != -1);
                     in = new ByteArrayInputStream(bos.toByteArray());
 
                 } else {
                     in.mark(Integer.MAX_VALUE);
                     byte[] buffer = new byte[BUFFER_SIZE];
                     int count = 0;
                     do {
                         size += count;
                         cal.update(buffer, 0, count);
                         count = in.read(buffer, 0, buffer.length);
                     } while (count != -1);
                     in.reset();
                 }
                 ze.setSize(size);
                 ze.setCrc(cal.getValue());
             }
 
             ze.setUnixMode(mode);
             ZipExtraField[] extra = getCurrentExtraFields();
             if (extra != null) {
                 ze.setExtraFields(extra);
             }
 
             zOut.putNextEntry(ze);
 
             byte[] buffer = new byte[BUFFER_SIZE];
             int count = 0;
             do {
                 if (count != 0) {
                     zOut.write(buffer, 0, count);
                 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/cvslib/ChangeLogTask.java b/src/main/org/apache/tools/ant/taskdefs/cvslib/ChangeLogTask.java
index 83cd03081..a5495df6d 100644
--- a/src/main/org/apache/tools/ant/taskdefs/cvslib/ChangeLogTask.java
+++ b/src/main/org/apache/tools/ant/taskdefs/cvslib/ChangeLogTask.java
@@ -1,487 +1,488 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.cvslib;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.io.UnsupportedEncodingException;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.Properties;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.AbstractCvsTask;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * Examines the output of cvs log and group related changes together.
  *
  * It produces an XML output representing the list of changes.
  * <pre>
  * <font color=#0000ff>&lt;!-- Root element --&gt;</font>
  * <font color=#6a5acd>&lt;!ELEMENT</font> changelog <font color=#ff00ff>
  * (entry</font><font color=#ff00ff>+</font><font color=#ff00ff>)
  * </font><font color=#6a5acd>&gt;</font>
  * <font color=#0000ff>&lt;!-- CVS Entry --&gt;</font>
  * <font color=#6a5acd>&lt;!ELEMENT</font> entry <font color=#ff00ff>
  * (date,author,file</font><font color=#ff00ff>+</font><font color=#ff00ff>,msg)
  * </font><font color=#6a5acd>&gt;</font>
  * <font color=#0000ff>&lt;!-- Date of cvs entry --&gt;</font>
  * <font color=#6a5acd>&lt;!ELEMENT</font> date <font color=#ff00ff>(#PCDATA)
  * </font><font color=#6a5acd>&gt;</font>
  * <font color=#0000ff>&lt;!-- Author of change --&gt;</font>
  * <font color=#6a5acd>&lt;!ELEMENT</font> author <font color=#ff00ff>(#PCDATA)
  * </font><font color=#6a5acd>&gt;</font>
  * <font color=#0000ff>&lt;!-- List of files affected --&gt;</font>
  * <font color=#6a5acd>&lt;!ELEMENT</font> msg <font color=#ff00ff>(#PCDATA)
  * </font><font color=#6a5acd>&gt;</font>
  * <font color=#0000ff>&lt;!-- File changed --&gt;</font>
  * <font color=#6a5acd>&lt;!ELEMENT</font> file <font color=#ff00ff>
  * (name,revision,prevrevision</font><font color=#ff00ff>?</font>
  * <font color=#ff00ff>)</font><font color=#6a5acd>&gt;</font>
  * <font color=#0000ff>&lt;!-- Name of the file --&gt;</font>
  * <font color=#6a5acd>&lt;!ELEMENT</font> name <font color=#ff00ff>(#PCDATA)
  * </font><font color=#6a5acd>&gt;</font>
  * <font color=#0000ff>&lt;!-- Revision number --&gt;</font>
  * <font color=#6a5acd>&lt;!ELEMENT</font> revision <font color=#ff00ff>
  * (#PCDATA)</font><font color=#6a5acd>&gt;</font>
  * <font color=#0000ff>&lt;!-- Previous revision number --&gt;</font>
  * <font color=#6a5acd>&lt;!ELEMENT</font> prevrevision <font color=#ff00ff>
  * (#PCDATA)</font><font color=#6a5acd>&gt;</font>
  * </pre>
  *
  * @since Ant 1.5
  * @ant.task name="cvschangelog" category="scm"
  */
 public class ChangeLogTask extends AbstractCvsTask {
     /** User list */
     private File usersFile;
 
     /** User list */
     private Vector cvsUsers = new Vector();
 
     /** Input dir */
     private File inputDir;
 
     /** Output file */
     private File destFile;
 
     /** The earliest date at which to start processing entries.  */
     private Date startDate;
 
     /** The latest date at which to stop processing entries.  */
     private Date endDate;
 
     /** Determines whether log (false) or rlog (true) is used */
     private boolean remote = false;
 
     /** Start tag when doing tag ranges. */
     private String startTag;
 
     /** End tag when doing tag ranges. */
     private String endTag;
 
     /**
      * Filesets containing list of files against which the cvs log will be
      * performed. If empty then all files in the working directory will
      * be checked.
      */
     private final Vector filesets = new Vector();
 
 
     /**
      * Set the base dir for cvs.
      *
      * @param inputDir The new dir value
      */
     public void setDir(final File inputDir) {
         this.inputDir = inputDir;
     }
 
 
     /**
      * Set the output file for the log.
      *
      * @param destFile The new destfile value
      */
     public void setDestfile(final File destFile) {
         this.destFile = destFile;
     }
 
 
     /**
      * Set a lookup list of user names & addresses
      *
      * @param usersFile The file containing the users info.
      */
     public void setUsersfile(final File usersFile) {
         this.usersFile = usersFile;
     }
 
 
     /**
      * Add a user to list changelog knows about.
      *
      * @param user the user
      */
     public void addUser(final CvsUser user) {
         cvsUsers.addElement(user);
     }
 
 
     /**
      * Set the date at which the changelog should start.
      *
      * @param start The date at which the changelog should start.
      */
     public void setStart(final Date start) {
         this.startDate = start;
     }
 
 
     /**
      * Set the date at which the changelog should stop.
      *
      * @param endDate The date at which the changelog should stop.
      */
     public void setEnd(final Date endDate) {
         this.endDate = endDate;
     }
 
 
     /**
      * Set the number of days worth of log entries to process.
      *
      * @param days the number of days of log to process.
      */
     public void setDaysinpast(final int days) {
         // CheckStyle:MagicNumber OFF
         final long time = System.currentTimeMillis()
              - (long) days * 24 * 60 * 60 * 1000;
         // CheckStyle:MagicNumber ON
 
         setStart(new Date(time));
     }
 
     /**
      * Whether to use rlog against a remote repository instead of log
      * in a working copy's directory.
      *
      * @since Ant 1.8.0
      */
     public void setRemote(final boolean remote) {
         this.remote = remote;
     }
 
     /**
      * Set the tag at which the changelog should start.
      *
      * @param start The date at which the changelog should start.
      */
     public void setStartTag(final String start) {
         this.startTag = start;
     }
 
 
     /**
      * Set the tag at which the changelog should stop.
      *
      * @param end The date at which the changelog should stop.
      */
     public void setEndTag(final String end) {
         this.endTag = end;
     }
 
     /**
      * Adds a set of files about which cvs logs will be generated.
      *
      * @param fileSet a set of files about which cvs logs will be generated.
      */
     public void addFileset(final FileSet fileSet) {
         filesets.addElement(fileSet);
     }
 
 
     /**
      * Execute task
      *
      * @exception BuildException if something goes wrong executing the
      *            cvs command
      */
     public void execute() throws BuildException {
         File savedDir = inputDir; // may be altered in validate
 
         try {
 
             validate();
             final Properties userList = new Properties();
 
             loadUserlist(userList);
 
-            for (int i = 0, size = cvsUsers.size(); i < size; i++) {
+            final int size = cvsUsers.size();
+            for (int i = 0; i < size; i++) {
                 final CvsUser user = (CvsUser) cvsUsers.get(i);
                 user.validate();
                 userList.put(user.getUserID(), user.getDisplayname());
             }
 
             if (!remote) {
                 setCommand("log");
 
                 if (getTag() != null) {
                     CvsVersion myCvsVersion = new CvsVersion();
                     myCvsVersion.setProject(getProject());
                     myCvsVersion.setTaskName("cvsversion");
                     myCvsVersion.setCvsRoot(getCvsRoot());
                     myCvsVersion.setCvsRsh(getCvsRsh());
                     myCvsVersion.setPassfile(getPassFile());
                     myCvsVersion.setDest(inputDir);
                     myCvsVersion.execute();
                     if (myCvsVersion.supportsCvsLogWithSOption()) {
                         addCommandArgument("-S");
                     }
                 }
             } else {
                 // supply 'rlog' as argument instead of command
                 setCommand("");
                 addCommandArgument("rlog");
                 // Do not print name/header if no revisions
                 // selected. This is quicker: less output to parse.
                 addCommandArgument("-S");
                 // Do not list tags. This is quicker: less output to
                 // parse.
                 addCommandArgument("-N");
             }
             if (null != startTag || null != endTag) {
                 // man, do I get spoiled by C#'s ?? operator
                 String startValue = startTag == null ? "" : startTag;
                 String endValue = endTag == null ? "" : endTag;
                 addCommandArgument("-r" + startValue + "::" + endValue);
             } else if (null != startDate) {
                 final SimpleDateFormat outputDate =
                     new SimpleDateFormat("yyyy-MM-dd");
 
                 // We want something of the form: -d ">=YYYY-MM-dd"
                 final String dateRange = ">=" + outputDate.format(startDate);
 
                 // Supply '-d' as a separate argument - Bug# 14397
                 addCommandArgument("-d");
                 addCommandArgument(dateRange);
             }
 
             // Check if list of files to check has been specified
             if (!filesets.isEmpty()) {
                 final Enumeration e = filesets.elements();
 
                 while (e.hasMoreElements()) {
                     final FileSet fileSet = (FileSet) e.nextElement();
                     final DirectoryScanner scanner =
                         fileSet.getDirectoryScanner(getProject());
                     final String[] files = scanner.getIncludedFiles();
 
                     for (int i = 0; i < files.length; i++) {
                         addCommandArgument(files[i]);
                     }
                 }
             }
 
             final ChangeLogParser parser = new ChangeLogParser(remote,
                                                                getPackage(),
                                                                getModules());
             final RedirectingStreamHandler handler =
                 new RedirectingStreamHandler(parser);
 
             log(getCommand(), Project.MSG_VERBOSE);
 
             setDest(inputDir);
             setExecuteStreamHandler(handler);
             try {
                 super.execute();
             } finally {
                 final String errors = handler.getErrors();
 
                 if (null != errors) {
                     log(errors, Project.MSG_ERR);
                 }
             }
             final CVSEntry[] entrySet = parser.getEntrySetAsArray();
             final CVSEntry[] filteredEntrySet = filterEntrySet(entrySet);
 
             replaceAuthorIdWithName(userList, filteredEntrySet);
 
             writeChangeLog(filteredEntrySet);
 
         } finally {
             inputDir = savedDir;
         }
     }
 
     /**
      * Validate the parameters specified for task.
      *
      * @throws BuildException if fails validation checks
      */
     private void validate()
          throws BuildException {
         if (null == inputDir) {
             inputDir = getProject().getBaseDir();
         }
         if (null == destFile) {
             final String message = "Destfile must be set.";
 
             throw new BuildException(message);
         }
         if (!inputDir.exists()) {
             final String message = "Cannot find base dir "
                  + inputDir.getAbsolutePath();
 
             throw new BuildException(message);
         }
         if (null != usersFile && !usersFile.exists()) {
             final String message = "Cannot find user lookup list "
                  + usersFile.getAbsolutePath();
 
             throw new BuildException(message);
         }
         if ((null != startTag || null != endTag)
             && (null != startDate || null != endDate)) {
             final String message = "Specify either a tag or date range,"
                 + " not both";
             throw new BuildException(message);
         }
     }
 
     /**
      * Load the userlist from the userList file (if specified) and add to
      * list of users.
      *
      * @param userList the file of users
      * @throws BuildException if file can not be loaded for some reason
      */
     private void loadUserlist(final Properties userList)
          throws BuildException {
         if (null != usersFile) {
             try {
                 userList.load(new FileInputStream(usersFile));
             } catch (final IOException ioe) {
                 throw new BuildException(ioe.toString(), ioe);
             }
         }
     }
 
     /**
      * Filter the specified entries according to an appropriate rule.
      *
      * @param entrySet the entry set to filter
      * @return the filtered entry set
      */
     private CVSEntry[] filterEntrySet(final CVSEntry[] entrySet) {
         final Vector results = new Vector();
 
         for (int i = 0; i < entrySet.length; i++) {
             final CVSEntry cvsEntry = entrySet[i];
             final Date date = cvsEntry.getDate();
 
             //bug#30471
             //this is caused by Date.after throwing a NullPointerException
             //for some reason there's no date set in the CVSEntry
             //Java 1.3.1 API
             //http://java.sun.com/j2se/1.3/docs/api/java/util/Date.html#after(java.util.Date)
             //doesn't throw NullPointerException
             //Java 1.4.2 + 1.5 API
             //http://java.sun.com/j2se/1.4.2/docs/api/java/util/Date.html#after(java.util.Date)
             //according to the docs it doesn't throw, according to the bug report it does
             //http://java.sun.com/j2se/1.5.0/docs/api/java/util/Date.html#after(java.util.Date)
             //according to the docs it does throw
 
             //for now skip entries which are missing a date
             if (null == date) {
                 continue;
             }
 
             if (null != startDate && startDate.after(date)) {
                 //Skip dates that are too early
                 continue;
             }
             if (null != endDate && endDate.before(date)) {
                 //Skip dates that are too late
                 continue;
             }
             results.addElement(cvsEntry);
         }
 
         final CVSEntry[] resultArray = new CVSEntry[results.size()];
 
         results.copyInto(resultArray);
         return resultArray;
     }
 
     /**
      * replace all known author's id's with their maven specified names
      */
     private void replaceAuthorIdWithName(final Properties userList,
                                          final CVSEntry[] entrySet) {
         for (int i = 0; i < entrySet.length; i++) {
 
             final CVSEntry entry = entrySet[ i ];
             if (userList.containsKey(entry.getAuthor())) {
                 entry.setAuthor(userList.getProperty(entry.getAuthor()));
             }
         }
     }
 
     /**
      * Print changelog to file specified in task.
      *
      * @param entrySet the entry set to write.
      * @throws BuildException if there is an error writing changelog.
      */
     private void writeChangeLog(final CVSEntry[] entrySet)
          throws BuildException {
         FileOutputStream output = null;
 
         try {
             output = new FileOutputStream(destFile);
 
             final PrintWriter writer =
                 new PrintWriter(new OutputStreamWriter(output, "UTF-8"));
 
             final ChangeLogWriter serializer = new ChangeLogWriter();
 
             serializer.printChangeLog(writer, entrySet);
 
             if (writer.checkError()) {
                 throw new IOException("Encountered an error writing changelog");
             }
         } catch (final UnsupportedEncodingException uee) {
             getProject().log(uee.toString(), Project.MSG_ERR);
         } catch (final IOException ioe) {
             throw new BuildException(ioe.toString(), ioe);
         } finally {
             FileUtils.close(output);
         }
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/email/MimeMailer.java b/src/main/org/apache/tools/ant/taskdefs/email/MimeMailer.java
index 965d898c5..85a022e4a 100644
--- a/src/main/org/apache/tools/ant/taskdefs/email/MimeMailer.java
+++ b/src/main/org/apache/tools/ant/taskdefs/email/MimeMailer.java
@@ -1,343 +1,344 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.email;
 
 import java.io.File;
 import java.io.InputStream;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.io.OutputStream;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.UnsupportedEncodingException;
 
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.Properties;
 import java.util.StringTokenizer;
 import java.util.Vector;
 
 import java.security.Provider;
 import java.security.Security;
 
 import javax.activation.DataHandler;
 import javax.activation.FileDataSource;
 
 import javax.mail.Authenticator;
 import javax.mail.Address;
 import javax.mail.Message;
 import javax.mail.MessagingException;
 import javax.mail.PasswordAuthentication;
 import javax.mail.SendFailedException;
 import javax.mail.Session;
 import javax.mail.Transport;
 import javax.mail.internet.AddressException;
 import javax.mail.internet.InternetAddress;
 import javax.mail.internet.MimeBodyPart;
 import javax.mail.internet.MimeMessage;
 import javax.mail.internet.MimeMultipart;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 
 /**
  * Uses the JavaMail classes to send Mime format email.
  *
  * @since Ant 1.5
  */
 public class MimeMailer extends Mailer {
     private static final String SSL_FACTORY = "javax.net.ssl.SSLSocketFactory";
 
     private static final String GENERIC_ERROR =
         "Problem while sending mime mail:";
 
     /** Default character set */
     private static final String DEFAULT_CHARSET
         = System.getProperty("file.encoding");
 
     // To work properly with national charsets we have to use
     // implementation of interface javax.activation.DataSource
     /**
      * String data source implementation.
      * @since Ant 1.6
      */
     class StringDataSource implements javax.activation.DataSource {
         private String data = null;
         private String type = null;
         private String charset = null;
         private ByteArrayOutputStream out;
 
         public InputStream getInputStream() throws IOException {
             if (data == null && out == null) {
                 throw new IOException("No data");
             }
             if (out != null) {
                 String encodedOut = out.toString(charset);
                 data = (data != null) ? data.concat(encodedOut) : encodedOut;
                 out = null;
             }
             return new ByteArrayInputStream(data.getBytes(charset));
         }
 
         public OutputStream getOutputStream() throws IOException {
             out = (out == null) ? new ByteArrayOutputStream() : out;
             return out;
         }
 
         public void setContentType(String type) {
             this.type = type.toLowerCase(Locale.ENGLISH);
         }
 
         public String getContentType() {
             if (type != null && type.indexOf("charset") > 0
                 && type.startsWith("text/")) {
                 return type;
             }
             // Must be like "text/plain; charset=windows-1251"
             return new StringBuffer(type != null ? type : "text/plain").append(
                 "; charset=").append(charset).toString();
         }
 
         public String getName() {
             return "StringDataSource";
         }
 
         public void setCharset(String charset) {
             this.charset = charset;
         }
 
         public String getCharset() {
             return charset;
         }
     }
 
     /**
      * Send the email.
      *
      * @throws BuildException if the email can't be sent.
      */
     public void send() {
         try {
             Properties props = new Properties();
 
             props.put("mail.smtp.host", host);
             props.put("mail.smtp.port", String.valueOf(port));
 
             // Aside, the JDK is clearly unaware of the Scottish
             // 'session', which involves excessive quantities of
             // alcohol :-)
             Session sesh;
             Authenticator auth = null;
             if (SSL) {
                 try {
                     Provider p = (Provider) Class.forName(
                         "com.sun.net.ssl.internal.ssl.Provider").newInstance();
                     Security.addProvider(p);
                 } catch (Exception e) {
                     throw new BuildException("could not instantiate ssl "
                         + "security provider, check that you have JSSE in "
                         + "your classpath");
                 }
                 // SMTP provider
                 props.put("mail.smtp.socketFactory.class", SSL_FACTORY);
                 props.put("mail.smtp.socketFactory.fallback", "false");
                 if (isPortExplicitlySpecified()) {
                     props.put("mail.smtp.socketFactory.port",
                               String.valueOf(port));
                 }
             }
             if (user != null || password != null) {
                 props.put("mail.smtp.auth", "true");
                 auth = new SimpleAuthenticator(user, password);
             }
             if (isStartTLSEnabled()) {
                 props.put("mail.smtp.starttls.enable", "true");
             }
             sesh = Session.getInstance(props, auth);
 
             //create the message
             MimeMessage msg = new MimeMessage(sesh);
             MimeMultipart attachments = new MimeMultipart();
 
             //set the sender
             if (from.getName() == null) {
                 msg.setFrom(new InternetAddress(from.getAddress()));
             } else {
                 msg.setFrom(new InternetAddress(from.getAddress(),
                     from.getName()));
             }
             // set the reply to addresses
             msg.setReplyTo(internetAddresses(replyToList));
             msg.setRecipients(Message.RecipientType.TO,
                 internetAddresses(toList));
             msg.setRecipients(Message.RecipientType.CC,
                 internetAddresses(ccList));
             msg.setRecipients(Message.RecipientType.BCC,
                 internetAddresses(bccList));
 
             // Choosing character set of the mail message
             // First: looking it from MimeType
             String charset = parseCharSetFromMimeType(message.getMimeType());
             if (charset != null) {
                 // Assign/reassign message charset from MimeType
                 message.setCharset(charset);
             } else {
                 // Next: looking if charset having explicit definition
                 charset = message.getCharset();
                 if (charset == null) {
                     // Using default
                     charset = DEFAULT_CHARSET;
                     message.setCharset(charset);
                 }
             }
             // Using javax.activation.DataSource paradigm
             StringDataSource sds = new StringDataSource();
             sds.setContentType(message.getMimeType());
             sds.setCharset(charset);
 
             if (subject != null) {
                 msg.setSubject(subject, charset);
             }
             msg.addHeader("Date", getDate());
 
             if (headers != null) {
                 for (Iterator iter = headers.iterator(); iter.hasNext();) {
                     Header h = (Header) iter.next();
                     msg.addHeader(h.getName(), h.getValue());
                 }
             }
             PrintStream out = new PrintStream(sds.getOutputStream());
             message.print(out);
             out.close();
 
             MimeBodyPart textbody = new MimeBodyPart();
             textbody.setDataHandler(new DataHandler(sds));
             attachments.addBodyPart(textbody);
 
             Enumeration e = files.elements();
 
             while (e.hasMoreElements()) {
                 File file = (File) e.nextElement();
 
                 MimeBodyPart body;
 
                 body = new MimeBodyPart();
                 if (!file.exists() || !file.canRead()) {
                     throw new BuildException("File \"" + file.getAbsolutePath()
                          + "\" does not exist or is not "
                          + "readable.");
                 }
                 FileDataSource fileData = new FileDataSource(file);
                 DataHandler fileDataHandler = new DataHandler(fileData);
 
                 body.setDataHandler(fileDataHandler);
                 body.setFileName(file.getName());
                 attachments.addBodyPart(body);
             }
             msg.setContent(attachments);
             try {
                 // Send the message using SMTP, or SMTPS if the host uses SSL
                 Transport transport = sesh.getTransport(SSL ? "smtps" : "smtp");
                 transport.connect(host, user, password);
                 transport.sendMessage(msg, msg.getAllRecipients());
             } catch (SendFailedException sfe) {
                 if (!shouldIgnoreInvalidRecipients()) {
                     throw new BuildException(GENERIC_ERROR, sfe);
                 } else if (sfe.getValidSentAddresses() == null
                            || sfe.getValidSentAddresses().length == 0) {
                     throw new BuildException("Couldn't reach any recipient",
                                              sfe);
                 } else {
                     Address[] invalid = sfe.getInvalidAddresses();
                     if (invalid == null) {
                         invalid = new Address[0];
                     }
                     for (int i = 0; i < invalid.length; i++) {
                         didntReach(invalid[i], "invalid", sfe);
                     }
                     Address[] validUnsent = sfe.getValidUnsentAddresses();
                     if (validUnsent == null) {
                         validUnsent = new Address[0];
                     }
                     for (int i = 0; i < validUnsent.length; i++) {
                         didntReach(validUnsent[i], "valid", sfe);
                     }
                 }
             }
         } catch (MessagingException e) {
             throw new BuildException(GENERIC_ERROR, e);
         } catch (IOException e) {
             throw new BuildException(GENERIC_ERROR, e);
         }
     }
 
     private static InternetAddress[] internetAddresses(Vector list)
         throws AddressException, UnsupportedEncodingException {
-        InternetAddress[] addrs = new InternetAddress[list.size()];
+        final int size = list.size();
+        InternetAddress[] addrs = new InternetAddress[size];
 
-        for (int i = 0; i < list.size(); ++i) {
+        for (int i = 0; i < size; ++i) {
             EmailAddress addr = (EmailAddress) list.elementAt(i);
 
             String name = addr.getName();
             addrs[i] = (name == null)
                 ? new InternetAddress(addr.getAddress())
                 : new InternetAddress(addr.getAddress(), name);
         }
         return addrs;
     }
 
     private String parseCharSetFromMimeType(String type) {
         if (type == null) {
             return null;
         }
         int pos = type.indexOf("charset");
         if (pos < 0) {
           return null;
         }
         // Assuming mime type in form "text/XXXX; charset=XXXXXX"
         StringTokenizer token = new StringTokenizer(type.substring(pos), "=; ");
         token.nextToken(); // Skip 'charset='
         return token.nextToken();
     }
 
     private void didntReach(Address addr, String category,
                             MessagingException ex) {
         String msg = "Failed to send mail to " + category + " address "
             + addr + " because of " + ex.getMessage();
         if (task != null) {
             task.log(msg, Project.MSG_WARN);
         } else {
             System.err.println(msg);
         }
     }
 
     static class SimpleAuthenticator extends Authenticator {
         private String user = null;
         private String password = null;
         public SimpleAuthenticator(String user, String password) {
             this.user = user;
             this.password = password;
         }
         public PasswordAuthentication getPasswordAuthentication() {
 
             return new PasswordAuthentication(user, password);
         }
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/Cab.java b/src/main/org/apache/tools/ant/taskdefs/optional/Cab.java
index a0b540616..beb25b9e9 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/Cab.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/Cab.java
@@ -1,355 +1,356 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.Enumeration;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.ExecTask;
 import org.apache.tools.ant.taskdefs.Execute;
 import org.apache.tools.ant.taskdefs.LogOutputStream;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.taskdefs.StreamPumper;
 import org.apache.tools.ant.taskdefs.condition.Os;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.util.FileUtils;
 
 
 /**
  * Create a CAB archive.
  *
  */
 
 public class Cab extends MatchingTask {
     private static final int DEFAULT_RESULT = -99;
     private File cabFile;
     private File baseDir;
     private Vector filesets = new Vector();
     private boolean doCompress = true;
     private boolean doVerbose = false;
     private String cmdOptions;
 
     // CheckStyle:VisibilityModifier OFF - bc
     protected String archiveType = "cab";
     // CheckStyle:VisibilityModifier ON
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * The name/location of where to create the .cab file.
      * @param cabFile the location of the cab file.
      */
     public void setCabfile(File cabFile) {
         this.cabFile = cabFile;
     }
 
     /**
      * Base directory to look in for files to CAB.
      * @param baseDir base directory for files to cab.
      */
     public void setBasedir(File baseDir) {
         this.baseDir = baseDir;
     }
 
     /**
      * If true, compress the files otherwise only store them.
      * @param compress a <code>boolean</code> value.
      */
     public void setCompress(boolean compress) {
         doCompress = compress;
     }
 
     /**
      * If true, display cabarc output.
      * @param verbose a <code>boolean</code> value.
      */
     public void setVerbose(boolean verbose) {
         doVerbose = verbose;
     }
 
     /**
      * Sets additional cabarc options that are not supported directly.
      * @param options cabarc command line options.
      */
     public void setOptions(String options) {
         cmdOptions = options;
     }
 
     /**
      * Adds a set of files to archive.
      * @param set a set of files to archive.
      */
     public void addFileset(FileSet set) {
         if (filesets.size() > 0) {
             throw new BuildException("Only one nested fileset allowed");
         }
         filesets.addElement(set);
     }
 
     /*
      * I'm not fond of this pattern: "sub-method expected to throw
      * task-cancelling exceptions".  It feels too much like programming
      * for side-effects to me...
      */
     /**
      * Check if the attributes and nested elements are correct.
      * @throws BuildException on error.
      */
     protected void checkConfiguration() throws BuildException {
         if (baseDir == null && filesets.size() == 0) {
             throw new BuildException("basedir attribute or one "
                                      + "nested fileset is required!",
                                      getLocation());
         }
         if (baseDir != null && !baseDir.exists()) {
             throw new BuildException("basedir does not exist!", getLocation());
         }
         if (baseDir != null && filesets.size() > 0) {
             throw new BuildException(
                 "Both basedir attribute and a nested fileset is not allowed");
         }
         if (cabFile == null) {
             throw new BuildException("cabfile attribute must be set!",
                                      getLocation());
         }
     }
 
     /**
      * Create a new exec delegate.  The delegate task is populated so that
      * it appears in the logs to be the same task as this one.
      * @return the delegate.
      * @throws BuildException on error.
      */
     protected ExecTask createExec() throws BuildException {
         ExecTask exec = new ExecTask(this);
         return exec;
     }
 
     /**
      * Check to see if the target is up to date with respect to input files.
      * @param files the list of files to check.
      * @return true if the cab file is newer than its dependents.
      */
     protected boolean isUpToDate(Vector files) {
         boolean upToDate = true;
-        for (int i = 0; i < files.size() && upToDate; i++) {
+        final int size = files.size();
+        for (int i = 0; i < size && upToDate; i++) {
             String file = files.elementAt(i).toString();
             if (FILE_UTILS.resolveFile(baseDir, file).lastModified()
                     > cabFile.lastModified()) {
                 upToDate = false;
             }
         }
         return upToDate;
     }
 
     /**
      * Creates a list file.  This temporary file contains a list of all files
      * to be included in the cab, one file per line.
      *
      * <p>This method expects to only be called on Windows and thus
      * quotes the file names.</p>
      * @param files the list of files to use.
      * @return the list file created.
      * @throws IOException if there is an error.
      */
     protected File createListFile(Vector files)
         throws IOException {
         File listFile = FILE_UTILS.createTempFile("ant", "", null, true, true);
 
         BufferedWriter writer = null;
         try {
             writer = new BufferedWriter(new FileWriter(listFile));
 
-            int size = files.size();
+            final int size = files.size();
             for (int i = 0; i < size; i++) {
                 writer.write('\"' + files.elementAt(i).toString() + '\"');
                 writer.newLine();
             }
         } finally {
             FileUtils.close(writer);
         }
 
         return listFile;
     }
 
     /**
      * Append all files found by a directory scanner to a vector.
      * @param files the vector to append the files to.
      * @param ds the scanner to get the files from.
      */
     protected void appendFiles(Vector files, DirectoryScanner ds) {
         String[] dsfiles = ds.getIncludedFiles();
 
         for (int i = 0; i < dsfiles.length; i++) {
             files.addElement(dsfiles[i]);
         }
     }
 
     /**
      * Get the complete list of files to be included in the cab.  Filenames
      * are gathered from the fileset if it has been added, otherwise from the
      * traditional include parameters.
      * @return the list of files.
      * @throws BuildException if there is an error.
      */
     protected Vector getFileList() throws BuildException {
         Vector files = new Vector();
 
         if (baseDir != null) {
             // get files from old methods - includes and nested include
             appendFiles(files, super.getDirectoryScanner(baseDir));
         } else {
             FileSet fs = (FileSet) filesets.elementAt(0);
             baseDir = fs.getDir();
             appendFiles(files, fs.getDirectoryScanner(getProject()));
         }
 
         return files;
     }
 
     /**
      * execute this task.
      * @throws BuildException on error.
      */
     public void execute() throws BuildException {
 
         checkConfiguration();
 
         Vector files = getFileList();
 
         // quick exit if the target is up to date
         if (isUpToDate(files)) {
             return;
         }
 
         log("Building " + archiveType + ": " + cabFile.getAbsolutePath());
 
         if (!Os.isFamily("windows")) {
             log("Using listcab/libcabinet", Project.MSG_VERBOSE);
 
             StringBuffer sb = new StringBuffer();
 
             Enumeration fileEnum = files.elements();
 
             while (fileEnum.hasMoreElements()) {
                 sb.append(fileEnum.nextElement()).append("\n");
             }
             sb.append("\n").append(cabFile.getAbsolutePath()).append("\n");
 
             try {
                 Process p = Execute.launch(getProject(),
                                            new String[] {"listcab"}, null,
                                            baseDir != null ? baseDir
                                                    : getProject().getBaseDir(),
                                            true);
                 OutputStream out = p.getOutputStream();
 
                 // Create the stream pumpers to forward listcab's stdout and stderr to the log
                 // note: listcab is an interactive program, and issues prompts for every new line.
                 //       Therefore, make it show only with verbose logging turned on.
                 LogOutputStream outLog = new LogOutputStream(this, Project.MSG_VERBOSE);
                 LogOutputStream errLog = new LogOutputStream(this, Project.MSG_ERR);
                 StreamPumper    outPump = new StreamPumper(p.getInputStream(), outLog);
                 StreamPumper    errPump = new StreamPumper(p.getErrorStream(), errLog);
 
                 // Pump streams asynchronously
                 (new Thread(outPump)).start();
                 (new Thread(errPump)).start();
 
                 out.write(sb.toString().getBytes());
                 out.flush();
                 out.close();
 
                 // A wild default for when the thread is interrupted
                 int result = DEFAULT_RESULT;
 
                 try {
                     // Wait for the process to finish
                     result = p.waitFor();
 
                     // Wait for the end of output and error streams
                     outPump.waitFor();
                     outLog.close();
                     errPump.waitFor();
                     errLog.close();
                 } catch (InterruptedException ie) {
                     log("Thread interrupted: " + ie);
                 }
 
                 // Informative summary message in case of errors
                 if (Execute.isFailure(result)) {
                     log("Error executing listcab; error code: " + result);
                 }
             } catch (IOException ex) {
                 String msg = "Problem creating " + cabFile + " " + ex.getMessage();
                 throw new BuildException(msg, getLocation());
             }
         } else {
             try {
                 File listFile = createListFile(files);
                 ExecTask exec = createExec();
                 File outFile = null;
 
                 // die if cabarc fails
                 exec.setFailonerror(true);
                 exec.setDir(baseDir);
 
                 if (!doVerbose) {
                     outFile = FILE_UTILS.createTempFile("ant", "", null, true, true);
                     exec.setOutput(outFile);
                 }
 
                 exec.setExecutable("cabarc");
                 exec.createArg().setValue("-r");
                 exec.createArg().setValue("-p");
 
                 if (!doCompress) {
                     exec.createArg().setValue("-m");
                     exec.createArg().setValue("none");
                 }
 
                 if (cmdOptions != null) {
                     exec.createArg().setLine(cmdOptions);
                 }
 
                 exec.createArg().setValue("n");
                 exec.createArg().setFile(cabFile);
                 exec.createArg().setValue("@" + listFile.getAbsolutePath());
 
                 exec.execute();
 
                 if (outFile != null) {
                     outFile.delete();
                 }
 
                 listFile.delete();
             } catch (IOException ioe) {
                 String msg = "Problem creating " + cabFile + " " + ioe.getMessage();
                 throw new BuildException(msg, getLocation());
             }
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/EchoProperties.java b/src/main/org/apache/tools/ant/taskdefs/optional/EchoProperties.java
index dd21aa80b..27e3b9299 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/EchoProperties.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/EchoProperties.java
@@ -1,540 +1,541 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional;
 
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Properties;
 import java.util.Vector;
 import java.util.List;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.Collections;
 import java.util.Iterator;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.PropertySet;
 import org.apache.tools.ant.util.CollectionUtils;
 import org.apache.tools.ant.util.DOMElementWriter;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.JavaEnvUtils;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 
 /**
  *  Displays all the current properties in the build. The output can be sent to
  *  a file if desired. <P>
  *
  *  Attribute "destfile" defines a file to send the properties to. This can be
  *  processed as a standard property file later. <P>
  *
  *  Attribute "prefix" defines a prefix which is used to filter the properties
  *  only those properties starting with this prefix will be echoed. <P>
  *
  *  By default, the "failonerror" attribute is enabled. If an error occurs while
  *  writing the properties to a file, and this attribute is enabled, then a
  *  BuildException will be thrown. If disabled, then IO errors will be reported
  *  as a log statement, but no error will be thrown. <P>
  *
  *  Examples: <pre>
  *  &lt;echoproperties  /&gt;
  * </pre> Report the current properties to the log. <P>
  *
  *  <pre>
  *  &lt;echoproperties destfile="my.properties" /&gt;
  * </pre> Report the current properties to the file "my.properties", and will
  *  fail the build if the file could not be created or written to. <P>
  *
  *  <pre>
  *  &lt;echoproperties destfile="my.properties" failonerror="false"
  *      prefix="ant" /&gt;
  * </pre> Report all properties beginning with 'ant' to the file
  *  "my.properties", and will log a message if the file could not be created or
  *  written to, but will still allow the build to continue.
  *
  *@since      Ant 1.5
  */
 public class EchoProperties extends Task {
 
     /**
      * the properties element.
      */
     private static final String PROPERTIES = "properties";
 
     /**
      * the property element.
      */
     private static final String PROPERTY = "property";
 
     /**
      * name attribute for property, testcase and testsuite elements.
      */
     private static final String ATTR_NAME = "name";
 
     /**
      * value attribute for property elements.
      */
     private static final String ATTR_VALUE = "value";
 
     /**
      * the input file.
      */
     private File inFile = null;
 
     /**
      *  File object pointing to the output file. If this is null, then
      *  we output to the project log, not to a file.
      */
     private File destfile = null;
 
     /**
      *  If this is true, then errors generated during file output will become
      *  build errors, and if false, then such errors will be logged, but not
      *  thrown.
      */
     private boolean failonerror = true;
 
     private Vector propertySets = new Vector();
 
     private String format = "text";
 
     private String prefix;
 
     /**
      * @since Ant 1.7
      */
     private String regex;
 
     /**
      * Sets the input file.
      *
      * @param file  the input file
      */
     public void setSrcfile(File file) {
         inFile = file;
     }
 
     /**
      *  Set a file to store the property output.  If this is never specified,
      *  then the output will be sent to the Ant log.
      *
      *@param destfile file to store the property output
      */
     public void setDestfile(File destfile) {
         this.destfile = destfile;
     }
 
 
     /**
      * If true, the task will fail if an error occurs writing the properties
      * file, otherwise errors are just logged.
      *
      *@param  failonerror  <tt>true</tt> if IO exceptions are reported as build
      *      exceptions, or <tt>false</tt> if IO exceptions are ignored.
      */
     public void setFailOnError(boolean failonerror) {
         this.failonerror = failonerror;
     }
 
 
     /**
      *  If the prefix is set, then only properties which start with this
      *  prefix string will be recorded. If regex is not set and  if this
      *  is never set, or it is set to an empty string or <tt>null</tt>,
      *  then all properties will be recorded. <P>
      *
      *  For example, if the attribute is set as:
      *    <PRE>&lt;echoproperties  prefix="ant." /&gt;</PRE>
      *  then the property "ant.home" will be recorded, but "ant-example"
      *  will not.
      *
      * @param  prefix  The new prefix value
      */
     public void setPrefix(String prefix) {
         if (prefix != null && prefix.length() != 0) {
             this.prefix = prefix;
             PropertySet ps = new PropertySet();
             ps.setProject(getProject());
             ps.appendPrefix(prefix);
             addPropertyset(ps);
         }
     }
 
     /**
      *  If the regex is set, then only properties whose names match it
      *  will be recorded.  If prefix is not set and if this is never set,
      *  or it is set to an empty string or <tt>null</tt>, then all
      *  properties will be recorded.<P>
      *
      *  For example, if the attribute is set as:
      *    <PRE>&lt;echoproperties  prefix=".*ant.*" /&gt;</PRE>
      *  then the properties "ant.home" and "user.variant" will be recorded,
      *  but "ant-example" will not.
      *
      * @param  regex  The new regex value
      *
      * @since Ant 1.7
      */
     public void setRegex(String regex) {
         if (regex != null && regex.length() != 0) {
             this.regex = regex;
             PropertySet ps = new PropertySet();
             ps.setProject(getProject());
             ps.appendRegex(regex);
             addPropertyset(ps);
         }
     }
 
     /**
      * A set of properties to write.
      * @param ps the property set to write
      * @since Ant 1.6
      */
     public void addPropertyset(PropertySet ps) {
         propertySets.addElement(ps);
     }
 
     /**
      * Set the output format - xml or text.
      * @param ea an enumerated <code>FormatAttribute</code> value
      */
     public void setFormat(FormatAttribute ea) {
         format = ea.getValue();
     }
 
     /**
      * A enumerated type for the format attribute.
      * The values are "xml" and "text".
      */
     public static class FormatAttribute extends EnumeratedAttribute {
         private String [] formats = new String[]{"xml", "text"};
 
         /**
          * @see EnumeratedAttribute#getValues()
          * @return accepted values
          */
         public String[] getValues() {
             return formats;
         }
     }
 
     /**
      *  Run the task.
      *
      *@exception  BuildException  trouble, probably file IO
      */
     public void execute() throws BuildException {
         if (prefix != null && regex != null) {
             throw new BuildException("Please specify either prefix"
                     + " or regex, but not both", getLocation());
         }
         //copy the properties file
         Hashtable allProps = new Hashtable();
 
         /* load properties from file if specified, otherwise
         use Ant's properties */
         if (inFile == null && propertySets.size() == 0) {
             // add ant properties
             allProps.putAll(getProject().getProperties());
         } else if (inFile != null) {
             if (inFile.exists() && inFile.isDirectory()) {
                 String message = "srcfile is a directory!";
                 if (failonerror) {
                     throw new BuildException(message, getLocation());
                 } else {
                     log(message, Project.MSG_ERR);
                 }
                 return;
             }
 
             if (inFile.exists() && !inFile.canRead()) {
                 String message = "Can not read from the specified srcfile!";
                 if (failonerror) {
                     throw new BuildException(message, getLocation());
                 } else {
                     log(message, Project.MSG_ERR);
                 }
                 return;
             }
 
             FileInputStream in = null;
             try {
                 in = new FileInputStream(inFile);
                 Properties props = new Properties();
                 props.load(in);
                 allProps.putAll(props);
             } catch (FileNotFoundException fnfe) {
                 String message =
                     "Could not find file " + inFile.getAbsolutePath();
                 if (failonerror) {
                     throw new BuildException(message, fnfe, getLocation());
                 } else {
                     log(message, Project.MSG_WARN);
                 }
                 return;
             } catch (IOException ioe) {
                 String message =
                     "Could not read file " + inFile.getAbsolutePath();
                 if (failonerror) {
                     throw new BuildException(message, ioe, getLocation());
                 } else {
                     log(message, Project.MSG_WARN);
                 }
                 return;
             } finally {
                 FileUtils.close(in);
             }
         }
 
         Enumeration e = propertySets.elements();
         while (e.hasMoreElements()) {
             PropertySet ps = (PropertySet) e.nextElement();
             allProps.putAll(ps.getProperties());
         }
 
         OutputStream os = null;
         try {
             if (destfile == null) {
                 os = new ByteArrayOutputStream();
                 saveProperties(allProps, os);
                 log(os.toString(), Project.MSG_INFO);
             } else {
                 if (destfile.exists() && destfile.isDirectory()) {
                     String message = "destfile is a directory!";
                     if (failonerror) {
                         throw new BuildException(message, getLocation());
                     } else {
                         log(message, Project.MSG_ERR);
                     }
                     return;
                 }
 
                 if (destfile.exists() && !destfile.canWrite()) {
                     String message =
                         "Can not write to the specified destfile!";
                     if (failonerror) {
                         throw new BuildException(message, getLocation());
                     } else {
                         log(message, Project.MSG_ERR);
                     }
                     return;
                 }
                 os = new FileOutputStream(this.destfile);
                 saveProperties(allProps, os);
             }
         } catch (IOException ioe) {
             if (failonerror) {
                 throw new BuildException(ioe, getLocation());
             } else {
                 log(ioe.getMessage(), Project.MSG_INFO);
             }
         } finally {
             if (os != null) {
                 try {
                     os.close();
                 } catch (IOException ex) {
                     //ignore
                 }
             }
         }
     }
 
 
     /**
      *  Send the key/value pairs in the hashtable to the given output stream.
      *  Only those properties matching the <tt>prefix</tt> constraint will be
      *  sent to the output stream.
      *  The output stream will be closed when this method returns.
      *
      * @param  allProps         propfile to save
      * @param  os               output stream
      * @throws IOException      on output errors
      * @throws BuildException   on other errors
      */
     protected void saveProperties(Hashtable allProps, OutputStream os)
         throws IOException, BuildException {
         final List keyList = new ArrayList(allProps.keySet());
         Collections.sort(keyList);
         Properties props = new Properties() {
             private static final long serialVersionUID = 5090936442309201654L;
             public Enumeration keys() {
                 return CollectionUtils.asEnumeration(keyList.iterator());
             }
             public Set entrySet() {
                 Set result = super.entrySet();
                 if (JavaEnvUtils.isKaffe()) {
                     TreeSet t = new TreeSet(new Comparator() {
                         public int compare(Object o1, Object o2) {
                             String key1 = (String) ((Map.Entry) o1).getKey();
                             String key2 = (String) ((Map.Entry) o2).getKey();
                             return key1.compareTo(key2);
                         }
                     });
                     t.addAll(result);
                     result = t;
                 }
                 return result;
             }
         };
-        for (int i = 0; i < keyList.size(); i++) {
+        final int size = keyList.size();
+        for (int i = 0; i < size; i++) {
             String name = keyList.get(i).toString();
             String value = allProps.get(name).toString();
             props.setProperty(name, value);
         }
         if ("text".equals(format)) {
             jdkSaveProperties(props, os, "Ant properties");
         } else if ("xml".equals(format)) {
             xmlSaveProperties(props, os);
         }
     }
 
     /**
      * a tuple for the sort list.
      */
     private static final class Tuple implements Comparable {
         private String key;
         private String value;
 
         private Tuple(String key, String value) {
             this.key = key;
             this.value = value;
         }
 
         /**
          * Compares this object with the specified object for order.
          * @param o the Object to be compared.
          * @return a negative integer, zero, or a positive integer as this object is
          *         less than, equal to, or greater than the specified object.
          * @throws ClassCastException if the specified object's type prevents it
          *                            from being compared to this Object.
          */
         public int compareTo(Object o) {
             Tuple that = (Tuple) o;
             return key.compareTo(that.key);
         }
     }
 
     private List sortProperties(Properties props) {
         //sort the list. Makes SCM and manual diffs easier.
         List sorted = new ArrayList(props.size());
         Enumeration e = props.propertyNames();
         while (e.hasMoreElements()) {
             String name = (String) e.nextElement();
             sorted.add(new Tuple(name, props.getProperty(name)));
         }
         Collections.sort(sorted);
         return sorted;
     }
 
     /**
      * Output the properties as xml output.
      * @param props the properties to save
      * @param os    the output stream to write to (Note this gets closed)
      * @throws IOException on error in writing to the stream
      */
     protected void xmlSaveProperties(Properties props,
                                      OutputStream os) throws IOException {
         // create XML document
         Document doc = getDocumentBuilder().newDocument();
         Element rootElement = doc.createElement(PROPERTIES);
 
         List sorted = sortProperties(props);
 
 
         // output properties
         Iterator iten = sorted.iterator();
         while (iten.hasNext()) {
             Tuple tuple = (Tuple) iten.next();
             Element propElement = doc.createElement(PROPERTY);
             propElement.setAttribute(ATTR_NAME, tuple.key);
             propElement.setAttribute(ATTR_VALUE, tuple.value);
             rootElement.appendChild(propElement);
         }
 
         Writer wri = null;
         try {
             wri = new OutputStreamWriter(os, "UTF8");
             wri.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
             (new DOMElementWriter()).write(rootElement, wri, 0, "\t");
             wri.flush();
         } catch (IOException ioe) {
             throw new BuildException("Unable to write XML file", ioe);
         } finally {
             FileUtils.close(wri);
         }
     }
 
     /**
      *  JDK 1.2 allows for the safer method
      *  <tt>Properties.store(OutputStream, String)</tt>, which throws an
      *  <tt>IOException</tt> on an output error.
      *
      *@param props the properties to record
      *@param os record the properties to this output stream
      *@param header prepend this header to the property output
      *@exception IOException on an I/O error during a write.
      */
     protected void jdkSaveProperties(Properties props, OutputStream os,
                                      String header) throws IOException {
        try {
            props.store(os, header);
 
        } catch (IOException ioe) {
            throw new BuildException(ioe, getLocation());
        } finally {
            if (os != null) {
                try {
                    os.close();
                } catch (IOException ioex) {
                    log("Failed to close output stream");
                }
            }
        }
     }
 
 
     /**
      * Uses the DocumentBuilderFactory to get a DocumentBuilder instance.
      *
      * @return   The DocumentBuilder instance
      */
     private static DocumentBuilder getDocumentBuilder() {
         try {
             return DocumentBuilderFactory.newInstance().newDocumentBuilder();
         } catch (Exception e) {
             throw new ExceptionInInitializerError(e);
         }
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/NetRexxC.java b/src/main/org/apache/tools/ant/taskdefs/optional/NetRexxC.java
index ab7209469..5bd74870c 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/NetRexxC.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/NetRexxC.java
@@ -1,1040 +1,1041 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Properties;
 import java.util.StringTokenizer;
 import java.util.Vector;
 import netrexx.lang.Rexx;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.util.FileUtils;
 
 // CheckStyle:InnerAssignmentCheck OFF - used too much in the file to be removed
 /**
  * Compiles NetRexx source files.
  * This task can take the following
  * arguments:
  * <ul>
  * <li>binary</li>
  * <li>classpath</li>
  * <li>comments</li>
  * <li>compile</li>
  * <li>console</li>
  * <li>crossref</li>
  * <li>decimal</li>
  * <li>destdir</li>
  * <li>diag</li>
  * <li>explicit</li>
  * <li>format</li>
  * <li>keep</li>
  * <li>logo</li>
  * <li>replace</li>
  * <li>savelog</li>
  * <li>srcdir</li>
  * <li>sourcedir</li>
  * <li>strictargs</li>
  * <li>strictassign</li>
  * <li>strictcase</li>
  * <li>strictimport</li>
  * <li>symbols</li>
  * <li>time</li>
  * <li>trace</li>
  * <li>utf8</li>
  * <li>verbose</li>
  * <li>suppressMethodArgumentNotUsed</li>
  * <li>suppressPrivatePropertyNotUsed</li>
  * <li>suppressVariableNotUsed</li>
  * <li>suppressExceptionNotSignalled</li>
  * <li>suppressDeprecation</li>
  * <li>removeKeepExtension</li>
  * </ul>
  * Of these arguments, the <b>srcdir</b> argument is required.
  *
  * <p>When this task executes, it will recursively scan the srcdir
  * looking for NetRexx source files to compile. This task makes its
  * compile decision based on timestamp.
  * <p>Before files are compiled they and any other file in the
  * srcdir will be copied to the destdir allowing support files to be
  * located properly in the classpath. The reason for copying the source files
  * before the compile is that NetRexxC has only two destinations for classfiles:
  * <ol>
  * <li>The current directory, and,</li>
  * <li>The directory the source is in (see sourcedir option)
  * </ol>
  *
  */
 public class NetRexxC extends MatchingTask {
 
     // variables to hold arguments
     private boolean binary;
     private String classpath;
     private boolean comments;
     private boolean compact = true; // should be the default, as it integrates better in ant.
     private boolean compile = true;
     private boolean console;
     private boolean crossref;
     private boolean decimal = true;
     private File destDir;
     private boolean diag;
     private boolean explicit;
     private boolean format;
     private boolean keep;
     private boolean logo = true;
     private boolean replace;
     private boolean savelog;
     private File srcDir;
     private boolean sourcedir = true; // ?? Should this be the default for ant?
     private boolean strictargs;
     private boolean strictassign;
     private boolean strictcase;
     private boolean strictimport;
     private boolean strictprops;
     private boolean strictsignal;
     private boolean symbols;
     private boolean time;
     private String trace = "trace2";
     private boolean utf8;
     private String verbose = "verbose3";
     private boolean suppressMethodArgumentNotUsed = false;
     private boolean suppressPrivatePropertyNotUsed = false;
     private boolean suppressVariableNotUsed = false;
     private boolean suppressExceptionNotSignalled = false;
     private boolean suppressDeprecation = false;
     private boolean removeKeepExtension = false;
 
     // constants for the messages to suppress by flags and their corresponding properties
     static final String MSG_METHOD_ARGUMENT_NOT_USED
         = "Warning: Method argument is not used";
     static final String MSG_PRIVATE_PROPERTY_NOT_USED
         = "Warning: Private property is defined but not used";
     static final String MSG_VARIABLE_NOT_USED
         = "Warning: Variable is set but not used";
     static final String MSG_EXCEPTION_NOT_SIGNALLED
         = "is in SIGNALS list but is not signalled within the method";
     static final String MSG_DEPRECATION = "has been deprecated";
 
     // other implementation variables
     private Vector compileList = new Vector();
     private Hashtable filecopyList = new Hashtable();
 
     /**
      * Set whether literals are treated as binary, rather than NetRexx types.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default is false.
      * @param binary a <code>boolean</code> value.
      */
     public void setBinary(boolean binary) {
         this.binary = binary;
     }
 
 
     /**
      * Set the classpath used for NetRexx compilation.
      * @param classpath the classpath to use.
      */
     public void setClasspath(String classpath) {
         this.classpath = classpath;
     }
 
 
     /**
      * Set whether comments are passed through to the generated java source.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param comments a <code>boolean</code> value.
      */
     public void setComments(boolean comments) {
         this.comments = comments;
     }
 
 
     /**
      * Set whether error messages come out in compact or verbose format.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is true.
      * @param compact a <code>boolean</code> value.
      */
     public void setCompact(boolean compact) {
         this.compact = compact;
     }
 
 
     /**
      * Set whether the NetRexx compiler should compile the generated java code.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is true.
      * Setting this flag to false, will automatically set the keep flag to true.
      * @param compile a <code>boolean</code> value.
      */
     public void setCompile(boolean compile) {
         this.compile = compile;
         if (!this.compile && !this.keep) {
             this.keep = true;
         }
     }
 
 
     /**
      * Set whether or not compiler messages should be displayed on the 'console'.
      * Note that this task will rely on the default value for filtering compile messages.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param console a <code>boolean</code> value.
      */
     public void setConsole(boolean console) {
         this.console = console;
     }
 
 
     /**
      * Whether variable cross references are generated.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param crossref a <code>boolean</code> value.
      */
     public void setCrossref(boolean crossref) {
         this.crossref = crossref;
     }
 
 
     /**
      * Set whether decimal arithmetic should be used for the netrexx code.
      * Setting this to off will report decimal arithmetic as an error, for
      * performance critical applications.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is true.
      * @param decimal a <code>boolean</code> value.
      */
     public void setDecimal(boolean decimal) {
         this.decimal = decimal;
     }
 
 
     /**
      * Set the destination directory into which the NetRexx source files
      * should be copied and then compiled.
      * @param destDirName the destination directory.
      */
     public void setDestDir(File destDirName) {
         destDir = destDirName;
     }
 
 
     /**
      * Whether diagnostic information about the compile is generated
      * @param diag a <code>boolean</code> value.
      */
     public void setDiag(boolean diag) {
         this.diag = diag;
     }
 
 
     /**
      * Sets whether variables must be declared explicitly before use.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param explicit a <code>boolean</code> value.
      */
     public void setExplicit(boolean explicit) {
         this.explicit = explicit;
     }
 
 
     /**
      * Whether the generated java code is formatted nicely or left to match
      * NetRexx line numbers for call stack debugging.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value false.
      * @param format a <code>boolean</code> value.
      */
     public void setFormat(boolean format) {
         this.format = format;
     }
 
 
     /**
      * Whether the generated java code is produced.
      * This is not implemented yet.
      * @param java a <code>boolean</code> value.
      */
     public void setJava(boolean java) {
         log("The attribute java is currently unused.", Project.MSG_WARN);
     }
 
 
     /**
      * Sets whether the generated java source file should be kept after
      * compilation. The generated files will have an extension of .java.keep,
      * <b>not</b> .java. See setRemoveKeepExtension
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param keep a <code>boolean</code> value.
      * @see #setRemoveKeepExtension(boolean)
      */
     public void setKeep(boolean keep) {
         this.keep = keep;
     }
 
 
     /**
      * Whether the compiler text logo is displayed when compiling.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param logo a <code>boolean</code> value.
      */
     public void setLogo(boolean logo) {
         this.logo = logo;
     }
 
 
     /**
      * Whether the generated .java file should be replaced when compiling.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param replace a <code>boolean</code> value.
      */
     public void setReplace(boolean replace) {
         this.replace = replace;
     }
 
 
     /**
      * Sets whether the compiler messages will be written to NetRexxC.log as
      * well as to the console.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param savelog a <code>boolean</code> value.
      */
     public void setSavelog(boolean savelog) {
         this.savelog = savelog;
     }
 
 
     /**
      * Tells the NetRexx compiler to store the class files in the same
      * directory as the source files. The alternative is the working directory.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is true.
      * @param sourcedir a <code>boolean</code> value.
      */
     public void setSourcedir(boolean sourcedir) {
         this.sourcedir = sourcedir;
     }
 
 
     /**
      * Set the source dir to find the source Java files.
      * @param srcDirName the source directory.
      */
     public void setSrcDir(File srcDirName) {
         srcDir = srcDirName;
     }
 
 
     /**
      * Tells the NetRexx compiler that method calls always need parentheses,
      * even if no arguments are needed, e.g. <code>aStringVar.getBytes</code>
      * vs. <code>aStringVar.getBytes()</code>.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param strictargs a <code>boolean</code> value.
      */
     public void setStrictargs(boolean strictargs) {
         this.strictargs = strictargs;
     }
 
 
     /**
      * Tells the NetRexx compile that assignments must match exactly on type.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param strictassign a <code>boolean</code> value.
      */
     public void setStrictassign(boolean strictassign) {
         this.strictassign = strictassign;
     }
 
 
     /**
      * Specifies whether the NetRexx compiler should be case sensitive or not.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param strictcase a <code>boolean</code> value.
      */
     public void setStrictcase(boolean strictcase) {
         this.strictcase = strictcase;
     }
 
 
     /**
      * Sets whether classes need to be imported explicitly using an <code>import</code>
      * statement. By default the NetRexx compiler will import certain packages
      * automatically.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param strictimport a <code>boolean</code> value.
      */
     public void setStrictimport(boolean strictimport) {
         this.strictimport = strictimport;
     }
 
 
     /**
      * Sets whether local properties need to be qualified explicitly using
      * <code>this</code>.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param strictprops a <code>boolean</code> value.
      */
     public void setStrictprops(boolean strictprops) {
         this.strictprops = strictprops;
     }
 
 
     /**
      * Whether the compiler should force catching of exceptions by explicitly
      * named types.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false
      * @param strictsignal a <code>boolean</code> value.
      */
     public void setStrictsignal(boolean strictsignal) {
         this.strictsignal = strictsignal;
     }
 
 
     /**
      * Sets whether debug symbols should be generated into the class file.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param symbols a <code>boolean</code> value.
      */
     public void setSymbols(boolean symbols) {
         this.symbols = symbols;
     }
 
 
     /**
      * Asks the NetRexx compiler to print compilation times to the console
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param time a <code>boolean</code> value.
      */
     public void setTime(boolean time) {
         this.time = time;
     }
 
     /**
      * Turns on or off tracing and directs the resultant trace output Valid
      * values are: "trace", "trace1", "trace2" and "notrace". "trace" and
      * "trace2".
      * @param trace the value to set.
      */
     public void setTrace(TraceAttr trace) {
         this.trace = trace.getValue();
     }
 
     /**
      * Turns on or off tracing and directs the resultant trace output Valid
      * values are: "trace", "trace1", "trace2" and "notrace". "trace" and
      * "trace2".
      * @param trace the value to set.
      */
     public void setTrace(String trace) {
         TraceAttr t = new TraceAttr();
 
         t.setValue(trace);
         setTrace(t);
     }
 
 
     /**
      * Tells the NetRexx compiler that the source is in UTF8.
      * Valid true values are "yes", "on" or "true". Anything else sets the flag to false.
      * The default value is false.
      * @param utf8 a <code>boolean</code> value.
      */
     public void setUtf8(boolean utf8) {
         this.utf8 = utf8;
     }
 
 
     /**
      * Whether lots of warnings and error messages should be generated
      * @param verbose the value to set - verbose&lt;level&gt; or noverbose.
      */
     public void setVerbose(VerboseAttr verbose) {
         this.verbose = verbose.getValue();
     }
 
 
     /**
      * Whether lots of warnings and error messages should be generated
      * @param verbose the value to set - verbose&lt;level&gt; or noverbose.
      */
     public void setVerbose(String verbose) {
         VerboseAttr v = new VerboseAttr();
 
         v.setValue(verbose);
         setVerbose(v);
     }
 
     /**
      * Whether the task should suppress the "Method argument is not used" in
      * strictargs-Mode, which can not be suppressed by the compiler itself.
      * The warning is logged as verbose message, though.
      * @param suppressMethodArgumentNotUsed a <code>boolean</code> value.
      */
     public void setSuppressMethodArgumentNotUsed(boolean suppressMethodArgumentNotUsed) {
         this.suppressMethodArgumentNotUsed = suppressMethodArgumentNotUsed;
     }
 
 
     /**
      * Whether the task should suppress the "Private property is defined but
      * not used" in strictargs-Mode, which can be quite annoying while
      * developing. The warning is logged as verbose message, though.
      * @param suppressPrivatePropertyNotUsed a <code>boolean</code> value.
      */
     public void setSuppressPrivatePropertyNotUsed(boolean suppressPrivatePropertyNotUsed) {
         this.suppressPrivatePropertyNotUsed = suppressPrivatePropertyNotUsed;
     }
 
 
     /**
      * Whether the task should suppress the "Variable is set but not used" in
      * strictargs-Mode. Be careful with this one! The warning is logged as
      * verbose message, though.
      * @param suppressVariableNotUsed a <code>boolean</code> value.
      */
     public void setSuppressVariableNotUsed(boolean suppressVariableNotUsed) {
         this.suppressVariableNotUsed = suppressVariableNotUsed;
     }
 
 
     /**
      * Whether the task should suppress the "FooException is in SIGNALS list
      * but is not signalled within the method", which is sometimes rather
      * useless. The warning is logged as verbose message, though.
      * @param suppressExceptionNotSignalled a <code>boolean</code> value.
      */
     public void setSuppressExceptionNotSignalled(boolean suppressExceptionNotSignalled) {
         this.suppressExceptionNotSignalled = suppressExceptionNotSignalled;
     }
 
 
     /**
      * Tells whether we should filter out any deprecation-messages
      * of the compiler out.
      * @param suppressDeprecation a <code>boolean</code> value.
      */
     public void setSuppressDeprecation(boolean suppressDeprecation) {
         this.suppressDeprecation = suppressDeprecation;
     }
 
 
     /**
      * Tells wether the trailing .keep in nocompile-mode should be removed
      * so that the resulting java source really ends on .java.
      * This facilitates the use of the javadoc tool lateron.
      */
     public void setRemoveKeepExtension(boolean removeKeepExtension) {
         this.removeKeepExtension = removeKeepExtension;
     }
 
 
     /**
      * init-Method sets defaults from Properties. That way, when ant is called
      * with arguments like -Dant.netrexxc.verbose=verbose5 one can easily take
      * control of all netrexxc-tasks.
      */
     public void init() {
         String p;
 
         if ((p = getProject().getProperty("ant.netrexxc.binary")) != null) {
             this.binary = Project.toBoolean(p);
         }
         // classpath makes no sense
         if ((p = getProject().getProperty("ant.netrexxc.comments")) != null) {
             this.comments = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.compact")) != null) {
             this.compact = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.compile")) != null) {
             this.compile = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.console")) != null) {
             this.console = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.crossref")) != null) {
             this.crossref = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.decimal")) != null) {
             this.decimal = Project.toBoolean(p);
             // destDir
         }
         if ((p = getProject().getProperty("ant.netrexxc.diag")) != null) {
             this.diag = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.explicit")) != null) {
             this.explicit = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.format")) != null) {
             this.format = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.keep")) != null) {
             this.keep = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.logo")) != null) {
             this.logo = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.replace")) != null) {
             this.replace = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.savelog")) != null) {
             this.savelog = Project.toBoolean(p);
             // srcDir
         }
         if ((p = getProject().getProperty("ant.netrexxc.sourcedir")) != null) {
             this.sourcedir = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.strictargs")) != null) {
             this.strictargs = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.strictassign")) != null) {
             this.strictassign = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.strictcase")) != null) {
             this.strictcase = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.strictimport")) != null) {
             this.strictimport = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.strictprops")) != null) {
             this.strictprops = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.strictsignal")) != null) {
             this.strictsignal = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.symbols")) != null) {
             this.symbols = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.time")) != null) {
             this.time = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.trace")) != null) {
             setTrace(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.utf8")) != null) {
             this.utf8 = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.verbose")) != null) {
             setVerbose(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.suppressMethodArgumentNotUsed")) != null) {
             this.suppressMethodArgumentNotUsed = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.suppressPrivatePropertyNotUsed")) != null) {
             this.suppressPrivatePropertyNotUsed = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.suppressVariableNotUsed")) != null) {
             this.suppressVariableNotUsed = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.suppressExceptionNotSignalled")) != null) {
             this.suppressExceptionNotSignalled = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.suppressDeprecation")) != null) {
             this.suppressDeprecation = Project.toBoolean(p);
         }
         if ((p = getProject().getProperty("ant.netrexxc.removeKeepExtension")) != null) {
             this.removeKeepExtension = Project.toBoolean(p);
         }
     }
 
 
     /**
      * Executes the task - performs the actual compiler call.
      * @throws BuildException on error.
      */
     public void execute() throws BuildException {
 
         // first off, make sure that we've got a srcdir and destdir
         if (srcDir == null || destDir == null) {
             throw new BuildException("srcDir and destDir attributes must be set!");
         }
 
         // scan source and dest dirs to build up both copy lists and
         // compile lists
         //        scanDir(srcDir, destDir);
         DirectoryScanner ds = getDirectoryScanner(srcDir);
 
         String[] files = ds.getIncludedFiles();
 
         scanDir(srcDir, destDir, files);
 
         // copy the source and support files
         copyFilesToDestination();
 
         // compile the source files
         if (compileList.size() > 0) {
             log("Compiling " + compileList.size() + " source file"
                  + (compileList.size() == 1 ? "" : "s")
                  + " to " + destDir);
             doNetRexxCompile();
             if (removeKeepExtension && (!compile || keep)) {
                 removeKeepExtensions();
             }
         }
     }
 
 
     /**
      * Scans the directory looking for source files to be compiled and support
      * files to be copied.
      */
     private void scanDir(File srcDir, File destDir, String[] files) {
         for (int i = 0; i < files.length; i++) {
             File srcFile = new File(srcDir, files[i]);
             File destFile = new File(destDir, files[i]);
             String filename = files[i];
             // if it's a non source file, copy it if a later date than the
             // dest
             // if it's a source file, see if the destination class file
             // needs to be recreated via compilation
             if (filename.toLowerCase().endsWith(".nrx")) {
                 File classFile =
                     new File(destDir,
                     filename.substring(0, filename.lastIndexOf('.')) + ".class");
                 File javaFile =
                     new File(destDir,
                     filename.substring(0, filename.lastIndexOf('.'))
                     + (removeKeepExtension ? ".java" : ".java.keep"));
 
                 // nocompile case tests against .java[.keep] file
                 if (!compile && srcFile.lastModified() > javaFile.lastModified()) {
                     filecopyList.put(srcFile.getAbsolutePath(), destFile.getAbsolutePath());
                     compileList.addElement(destFile.getAbsolutePath());
                 }
                 // compile case tests against .class file
                 else if (compile && srcFile.lastModified() > classFile.lastModified()) {
                     filecopyList.put(srcFile.getAbsolutePath(), destFile.getAbsolutePath());
                     compileList.addElement(destFile.getAbsolutePath());
                 }
             } else {
                 if (srcFile.lastModified() > destFile.lastModified()) {
                     filecopyList.put(srcFile.getAbsolutePath(), destFile.getAbsolutePath());
                 }
             }
         }
     }
 
 
     /** Copy eligible files from the srcDir to destDir  */
     private void copyFilesToDestination() {
         if (filecopyList.size() > 0) {
             log("Copying " + filecopyList.size() + " file"
                  + (filecopyList.size() == 1 ? "" : "s")
                  + " to " + destDir.getAbsolutePath());
 
             Enumeration e = filecopyList.keys();
 
             while (e.hasMoreElements()) {
                 String fromFile = (String) e.nextElement();
                 String toFile = (String) filecopyList.get(fromFile);
 
                 try {
                     FileUtils.getFileUtils().copyFile(fromFile, toFile);
                 } catch (IOException ioe) {
                     String msg = "Failed to copy " + fromFile + " to " + toFile
                          + " due to " + ioe.getMessage();
 
                     throw new BuildException(msg, ioe);
                 }
             }
         }
     }
 
 
     /**
      * Rename .java.keep files (back) to .java. The netrexxc renames all
      * .java files to .java.keep if either -keep or -nocompile option is set.
      */
     private void removeKeepExtensions() {
         if (compileList.size() > 0) {
             log("Removing .keep extension on " + compileList.size() + " file"
                  + (compileList.size() == 1 ? "" : "s"));
             Enumeration e = compileList.elements();
             while (e.hasMoreElements()) {
                 String nrxName = (String) e.nextElement();
                 String baseName = nrxName.substring(0, nrxName.lastIndexOf('.'));
                 File fromFile = new File(baseName + ".java.keep");
                 File toFile = new File(baseName + ".java");
                 if (fromFile.renameTo(toFile)) {
                     log("Successfully renamed " + fromFile + " to " + toFile, Project.MSG_VERBOSE);
                 } else {
                     log("Failed to rename " + fromFile + " to " + toFile);
                 }
             }
         }
     }
 
 
     /** Performs a compile using the NetRexx 1.1.x compiler  */
     private void doNetRexxCompile() throws BuildException {
         log("Using NetRexx compiler", Project.MSG_VERBOSE);
 
         String classpath = getCompileClasspath();
         StringBuffer compileOptions = new StringBuffer();
 
         // create an array of strings for input to the compiler: one array
         // comes from the compile options, the other from the compileList
         String[] compileOptionsArray = getCompileOptionsAsArray();
         String[] fileListArray = new String[compileList.size()];
         Enumeration e = compileList.elements();
         int j = 0;
 
         while (e.hasMoreElements()) {
             fileListArray[j] = (String) e.nextElement();
             j++;
         }
         // create a single array of arguments for the compiler
         String[] compileArgs = new String[compileOptionsArray.length + fileListArray.length];
 
         for (int i = 0; i < compileOptionsArray.length; i++) {
             compileArgs[i] = compileOptionsArray[i];
         }
         for (int i = 0; i < fileListArray.length; i++) {
             compileArgs[i + compileOptionsArray.length] = fileListArray[i];
         }
 
         // print nice output about what we are doing for the log
         compileOptions.append("Compilation args: ");
         for (int i = 0; i < compileOptionsArray.length; i++) {
             compileOptions.append(compileOptionsArray[i]);
             compileOptions.append(" ");
         }
         log(compileOptions.toString(), Project.MSG_VERBOSE);
 
         String eol = System.getProperty("line.separator");
         StringBuffer niceSourceList = new StringBuffer("Files to be compiled:" + eol);
 
-        for (int i = 0; i < compileList.size(); i++) {
+        final int size = compileList.size();
+        for (int i = 0; i < size; i++) {
             niceSourceList.append("    ");
             niceSourceList.append(compileList.elementAt(i).toString());
             niceSourceList.append(eol);
         }
 
         log(niceSourceList.toString(), Project.MSG_VERBOSE);
 
         // need to set java.class.path property and restore it later
         // since the NetRexx compiler has no option for the classpath
         String currentClassPath = System.getProperty("java.class.path");
         Properties currentProperties = System.getProperties();
 
         currentProperties.put("java.class.path", classpath);
 
         try {
             StringWriter out = new StringWriter();
             PrintWriter w = null;
             int rc =
                 COM.ibm.netrexx.process.NetRexxC.main(new Rexx(compileArgs),
                                                       w = new PrintWriter(out));
             String sdir = srcDir.getAbsolutePath();
             String ddir = destDir.getAbsolutePath();
             boolean doReplace = !(sdir.equals(ddir));
             int dlen = ddir.length();
             String l;
             BufferedReader in = new BufferedReader(new StringReader(out.toString()));
 
             log("replacing destdir '" + ddir + "' through sourcedir '"
                 + sdir + "'", Project.MSG_VERBOSE);
             while ((l = in.readLine()) != null) {
                 int idx;
 
                 while (doReplace && ((idx = l.indexOf(ddir)) != -1)) {
                     // path is mentioned in the message
                     l = (new StringBuffer(l)).replace(idx, idx + dlen, sdir).toString();
                 }
                 // verbose level logging for suppressed messages
                 if (suppressMethodArgumentNotUsed
                     && l.indexOf(MSG_METHOD_ARGUMENT_NOT_USED) != -1) {
                     log(l, Project.MSG_VERBOSE);
                 } else if (suppressPrivatePropertyNotUsed
                     && l.indexOf(MSG_PRIVATE_PROPERTY_NOT_USED) != -1) {
                     log(l, Project.MSG_VERBOSE);
                 } else if (suppressVariableNotUsed
                     && l.indexOf(MSG_VARIABLE_NOT_USED) != -1) {
                     log(l, Project.MSG_VERBOSE);
                 } else if (suppressExceptionNotSignalled
                     && l.indexOf(MSG_EXCEPTION_NOT_SIGNALLED) != -1) {
                     log(l, Project.MSG_VERBOSE);
                 } else if (suppressDeprecation
                     && l.indexOf(MSG_DEPRECATION) != -1) {
                     log(l, Project.MSG_VERBOSE);
                 } else if (l.indexOf("Error:") != -1) {
                     // error level logging for compiler errors
                     log(l, Project.MSG_ERR);
                 } else if (l.indexOf("Warning:") != -1) {
                     // warning for all warning messages
                     log(l, Project.MSG_WARN);
                 } else {
                     log(l, Project.MSG_INFO); // info level for the rest.
                 }
             }
             if (rc > 1) {
                 throw new BuildException("Compile failed, messages should "
                     + "have been provided.");
             }
             if (w.checkError()) {
                 throw new IOException("Encountered an error");
             }
         } catch (IOException ioe) {
             throw new BuildException("Unexpected IOException while "
                 + "playing with Strings", ioe);
         } finally {
             // need to reset java.class.path property
             // since the NetRexx compiler has no option for the classpath
             currentProperties = System.getProperties();
             currentProperties.put("java.class.path", currentClassPath);
         }
 
     }
 
 
     /** Builds the compilation classpath.  */
     private String getCompileClasspath() {
         StringBuffer classpath = new StringBuffer();
 
         // add dest dir to classpath so that previously compiled and
         // untouched classes are on classpath
         classpath.append(destDir.getAbsolutePath());
 
         // add our classpath to the mix
         if (this.classpath != null) {
             addExistingToClasspath(classpath, this.classpath);
         }
 
         // add the system classpath
         // addExistingToClasspath(classpath,System.getProperty("java.class.path"));
         return classpath.toString();
     }
 
 
     /** This  */
     private String[] getCompileOptionsAsArray() {
         Vector options = new Vector();
 
         options.addElement(binary ? "-binary" : "-nobinary");
         options.addElement(comments ? "-comments" : "-nocomments");
         options.addElement(compile ? "-compile" : "-nocompile");
         options.addElement(compact ? "-compact" : "-nocompact");
         options.addElement(console ? "-console" : "-noconsole");
         options.addElement(crossref ? "-crossref" : "-nocrossref");
         options.addElement(decimal ? "-decimal" : "-nodecimal");
         options.addElement(diag ? "-diag" : "-nodiag");
         options.addElement(explicit ? "-explicit" : "-noexplicit");
         options.addElement(format ? "-format" : "-noformat");
         options.addElement(keep ? "-keep" : "-nokeep");
         options.addElement(logo ? "-logo" : "-nologo");
         options.addElement(replace ? "-replace" : "-noreplace");
         options.addElement(savelog ? "-savelog" : "-nosavelog");
         options.addElement(sourcedir ? "-sourcedir" : "-nosourcedir");
         options.addElement(strictargs ? "-strictargs" : "-nostrictargs");
         options.addElement(strictassign ? "-strictassign" : "-nostrictassign");
         options.addElement(strictcase ? "-strictcase" : "-nostrictcase");
         options.addElement(strictimport ? "-strictimport" : "-nostrictimport");
         options.addElement(strictprops ? "-strictprops" : "-nostrictprops");
         options.addElement(strictsignal ? "-strictsignal" : "-nostrictsignal");
         options.addElement(symbols ? "-symbols" : "-nosymbols");
         options.addElement(time ? "-time" : "-notime");
         options.addElement("-" + trace);
         options.addElement(utf8 ? "-utf8" : "-noutf8");
         options.addElement("-" + verbose);
 
         String[] results = new String[options.size()];
 
         options.copyInto(results);
         return results;
     }
 
 
     /**
      * Takes a classpath-like string, and adds each element of this string to
      * a new classpath, if the components exist. Components that don't exist,
      * aren't added. We do this, because jikes issues warnings for
      * non-existant files/dirs in his classpath, and these warnings are pretty
      * annoying.
      *
      * @param target - target classpath
      * @param source - source classpath to get file objects.
      */
     private void addExistingToClasspath(StringBuffer target, String source) {
         StringTokenizer tok = new StringTokenizer(source,
             System.getProperty("path.separator"), false);
 
         while (tok.hasMoreTokens()) {
             File f = getProject().resolveFile(tok.nextToken());
 
             if (f.exists()) {
                 target.append(File.pathSeparator);
                 target.append(f.getAbsolutePath());
             } else {
                 log("Dropping from classpath: "
                     + f.getAbsolutePath(), Project.MSG_VERBOSE);
             }
         }
 
     }
 
 
     /**
      * Enumerated class corresponding to the trace attribute.
      */
     public static class TraceAttr extends EnumeratedAttribute {
         /** {@inheritDoc}. */
         public String[] getValues() {
             return new String[]{"trace", "trace1", "trace2", "notrace"};
         }
     }
 
     /**
      * Enumerated class corresponding to the verbose attribute.
      */
     public static class VerboseAttr extends EnumeratedAttribute {
         /** {@inheritDoc}. */
         public String[] getValues() {
             return new String[]{"verbose", "verbose0", "verbose1",
                 "verbose2", "verbose3", "verbose4",
                 "verbose5", "noverbose"};
         }
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/TraXLiaison.java b/src/main/org/apache/tools/ant/taskdefs/optional/TraXLiaison.java
index 48f3ecd2e..9cacd71df 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/TraXLiaison.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/TraXLiaison.java
@@ -1,623 +1,625 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.Hashtable;
 import java.util.Vector;
 import java.util.Enumeration;
 import java.net.URL;
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.parsers.SAXParserFactory;
 import javax.xml.transform.ErrorListener;
 import javax.xml.transform.Source;
 import javax.xml.transform.SourceLocator;
 import javax.xml.transform.Templates;
 import javax.xml.transform.Transformer;
 import javax.xml.transform.TransformerException;
 import javax.xml.transform.TransformerFactory;
 import javax.xml.transform.URIResolver;
 import javax.xml.transform.sax.SAXSource;
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.transform.TransformerConfigurationException;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.XSLTLiaison3;
 import org.apache.tools.ant.taskdefs.XSLTLogger;
 import org.apache.tools.ant.taskdefs.XSLTLoggerAware;
 import org.apache.tools.ant.taskdefs.XSLTProcess;
 import org.apache.tools.ant.types.XMLCatalog;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.URLProvider;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.JAXPUtils;
 import org.xml.sax.EntityResolver;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 import org.xml.sax.XMLReader;
 
 /**
  * Concrete liaison for XSLT processor implementing TraX. (ie JAXP 1.1)
  *
  * @since Ant 1.3
  */
 public class TraXLiaison implements XSLTLiaison3, ErrorListener, XSLTLoggerAware {
 
     /**
      * Helper for transforming filenames to URIs.
      *
      * @since Ant 1.7
      */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * The current <code>Project</code>
      */
     private Project project;
 
     /**
      * the name of the factory implementation class to use
      * or null for default JAXP lookup.
      */
     private String factoryName = null;
 
     /** The trax TransformerFactory */
     private TransformerFactory tfactory = null;
 
     /** stylesheet to use for transformation */
     private Resource stylesheet;
 
     private XSLTLogger logger;
 
     /** possible resolver for publicIds */
     private EntityResolver entityResolver;
 
     /** transformer to use for processing files */
     private Transformer transformer;
 
     /** The In memory version of the stylesheet */
     private Templates templates;
 
     /**
      * The modification time of the stylesheet from which the templates
      * are read
      */
     private long templatesModTime;
 
     /** possible resolver for URIs */
     private URIResolver uriResolver;
 
     /** transformer output properties */
     private Vector outputProperties = new Vector();
 
     /** stylesheet parameters */
     private Hashtable params = new Hashtable();
 
     /** factory attributes */
     private Vector attributes = new Vector();
 
     /** whether to suppress warnings */
     private boolean suppressWarnings = false;
 
     /** optional trace configuration. */
     private XSLTProcess.TraceConfiguration traceConfiguration = null;
 
     /**
      * Constructor for TraXLiaison.
      * @throws Exception never
      */
     public TraXLiaison() throws Exception {
     }
 
     /**
      * Set the stylesheet file.
      * @param stylesheet a <code>File</code> value
      * @throws Exception on error
      */
     public void setStylesheet(File stylesheet) throws Exception {
         FileResource fr = new FileResource();
         fr.setProject(project);
         fr.setFile(stylesheet);
         setStylesheet(fr);
     }
 
     /**
      * Set the stylesheet file.
      * @param stylesheet a {@link org.apache.tools.ant.types.Resource} value
      * @throws Exception on error
      */
     public void setStylesheet(Resource stylesheet) throws Exception {
         if (this.stylesheet != null) {
             // resetting the stylesheet - reset transformer
             transformer = null;
 
             // do we need to reset templates as well
             if (!this.stylesheet.equals(stylesheet)
                 || (stylesheet.getLastModified() != templatesModTime)) {
                 templates = null;
             }
         }
         this.stylesheet = stylesheet;
     }
 
     /**
      * Transform an input file.
      * @param infile the file to transform
      * @param outfile the result file
      * @throws Exception on error
      */
     public void transform(File infile, File outfile) throws Exception {
         if (transformer == null) {
             createTransformer();
         }
 
         InputStream fis = null;
         OutputStream fos = null;
         try {
             fis = new BufferedInputStream(new FileInputStream(infile));
             fos = new BufferedOutputStream(new FileOutputStream(outfile));
             StreamResult res = new StreamResult(fos);
             // not sure what could be the need of this...
             res.setSystemId(JAXPUtils.getSystemId(outfile));
             Source src = getSource(fis, infile);
 
             // set parameters on each transformation, maybe something has changed
             //(e.g. value of file name parameter)
             setTransformationParameters();
 
             transformer.transform(src, res);
         } finally {
             // make sure to close all handles, otherwise the garbage
             // collector will close them...whenever possible and
             // Windows may complain about not being able to delete files.
             FileUtils.close(fis);
             FileUtils.close(fos);
         }
     }
 
     /**
      * Get the source instance from the stream and id of the file.
      * @param is the stream containing the stylesheet data.
      * @param infile the file that will be used for the systemid.
      * @return the configured source instance matching the stylesheet.
      * @throws ParserConfigurationException if a parser cannot be created which
      * satisfies the requested configuration.
      * @throws SAXException in case of problem detected by the SAX parser.
      */
     private Source getSource(InputStream is, File infile)
         throws ParserConfigurationException, SAXException {
         // todo: is this comment still relevant ??
         // FIXME: need to use a SAXSource as the source for the transform
         // so we can plug in our own entity resolver
         Source src = null;
         if (entityResolver != null) {
             if (getFactory().getFeature(SAXSource.FEATURE)) {
                 SAXParserFactory spFactory = SAXParserFactory.newInstance();
                 spFactory.setNamespaceAware(true);
                 XMLReader reader = spFactory.newSAXParser().getXMLReader();
                 reader.setEntityResolver(entityResolver);
                 src = new SAXSource(reader, new InputSource(is));
             } else {
                 throw new IllegalStateException("xcatalog specified, but "
                     + "parser doesn't support SAX");
             }
         } else {
             // WARN: Don't use the StreamSource(File) ctor. It won't work with
             // xalan prior to 2.2 because of systemid bugs.
             src = new StreamSource(is);
         }
         src.setSystemId(JAXPUtils.getSystemId(infile));
         return src;
     }
 
     private Source getSource(InputStream is, Resource resource)
         throws ParserConfigurationException, SAXException {
         // todo: is this comment still relevant ??
         // FIXME: need to use a SAXSource as the source for the transform
         // so we can plug in our own entity resolver
         Source src = null;
         if (entityResolver != null) {
             if (getFactory().getFeature(SAXSource.FEATURE)) {
                 SAXParserFactory spFactory = SAXParserFactory.newInstance();
                 spFactory.setNamespaceAware(true);
                 XMLReader reader = spFactory.newSAXParser().getXMLReader();
                 reader.setEntityResolver(entityResolver);
                 src = new SAXSource(reader, new InputSource(is));
             } else {
                 throw new IllegalStateException("xcatalog specified, but "
                     + "parser doesn't support SAX");
             }
         } else {
             // WARN: Don't use the StreamSource(File) ctor. It won't work with
             // xalan prior to 2.2 because of systemid bugs.
             src = new StreamSource(is);
         }
         // The line below is a hack: the system id must an URI, but it is not
         // cleat to get the URI of an resource, so just set the name of the
         // resource as a system id
         src.setSystemId(resourceToURI(resource));
         return src;
     }
 
     private String resourceToURI(Resource resource) {
         FileProvider fp = (FileProvider) resource.as(FileProvider.class);
         if (fp != null) {
             return FILE_UTILS.toURI(fp.getFile().getAbsolutePath());
         }
         URLProvider up = (URLProvider) resource.as(URLProvider.class);
         if (up != null) {
             URL u = up.getURL();
             return String.valueOf(u);
         } else {
             return resource.getName();
         }
     }
 
     /**
      * Read in templates from the stylesheet
      */
     private void readTemplates()
         throws IOException, TransformerConfigurationException,
                ParserConfigurationException, SAXException {
 
         // Use a stream so that you can close it yourself quickly
         // and avoid keeping the handle until the object is garbaged.
         // (always keep control), otherwise you won't be able to delete
         // the file quickly on windows.
         InputStream xslStream = null;
         try {
             xslStream
                 = new BufferedInputStream(stylesheet.getInputStream());
             templatesModTime = stylesheet.getLastModified();
             Source src = getSource(xslStream, stylesheet);
             templates = getFactory().newTemplates(src);
         } finally {
             if (xslStream != null) {
                 xslStream.close();
             }
         }
     }
 
     /**
      * Create a new transformer based on the liaison settings
      * @throws Exception thrown if there is an error during creation.
      * @see #setStylesheet(java.io.File)
      * @see #addParam(java.lang.String, java.lang.String)
      * @see #setOutputProperty(java.lang.String, java.lang.String)
      */
     private void createTransformer() throws Exception {
         if (templates == null) {
             readTemplates();
         }
 
         transformer = templates.newTransformer();
 
         // configure the transformer...
         transformer.setErrorListener(this);
         if (uriResolver != null) {
             transformer.setURIResolver(uriResolver);
         }
-        for (int i = 0; i < outputProperties.size(); i++) {
+        final int size = outputProperties.size();
+        for (int i = 0; i < size; i++) {
             final String[] pair = (String[]) outputProperties.elementAt(i);
             transformer.setOutputProperty(pair[0], pair[1]);
         }
 
         if (traceConfiguration != null) {
             if ("org.apache.xalan.transformer.TransformerImpl"
                 .equals(transformer.getClass().getName())) {
                 try {
                     Class traceSupport =
                         Class.forName("org.apache.tools.ant.taskdefs.optional."
                                       + "Xalan2TraceSupport", true,
                                       Thread.currentThread()
                                       .getContextClassLoader());
                     XSLTTraceSupport ts =
                         (XSLTTraceSupport) traceSupport.newInstance();
                     ts.configureTrace(transformer, traceConfiguration);
                 } catch (Exception e) {
                     String msg = "Failed to enable tracing because of " + e;
                     if (project != null) {
                         project.log(msg, Project.MSG_WARN);
                     } else {
                         System.err.println(msg);
                     }
                 }
             } else {
                 String msg = "Not enabling trace support for transformer"
                     + " implementation" + transformer.getClass().getName();
                 if (project != null) {
                     project.log(msg, Project.MSG_WARN);
                 } else {
                     System.err.println(msg);
                 }
             }
         }
     }
 
     /**
      * Sets the paramters for the transformer.
      */
     private void setTransformationParameters() {
         for (final Enumeration enumeration = params.keys();
              enumeration.hasMoreElements();) {
             final String name = (String) enumeration.nextElement();
             final String value = (String) params.get(name);
             transformer.setParameter(name, value);
         }
     }
 
     /**
      * return the Transformer factory associated to this liaison.
      * @return the Transformer factory associated to this liaison.
      * @throws BuildException thrown if there is a problem creating
      * the factory.
      * @see #setFactory(String)
      * @since Ant 1.5.2
      */
     private TransformerFactory getFactory() throws BuildException {
         if (tfactory != null) {
             return tfactory;
         }
         // not initialized yet, so create the factory
         if (factoryName == null) {
             tfactory = TransformerFactory.newInstance();
         } else {
             try {
                 Class clazz = null;
                 try {
                     clazz =
                         Class.forName(factoryName, true,
                                       Thread.currentThread()
                                       .getContextClassLoader());
                 } catch (ClassNotFoundException cnfe) {
                     String msg = "Failed to load " + factoryName
                         + " via the configured classpath, will try"
                         + " Ant's classpath instead.";
                     if (logger != null) {
                         logger.log(msg);
                     } else if (project != null) {
                         project.log(msg, Project.MSG_WARN);
                     } else {
                         System.err.println(msg);
                     }
                 }
 
                 if (clazz == null) {
                     clazz = Class.forName(factoryName);
                 }
                 tfactory = (TransformerFactory) clazz.newInstance();
             } catch (Exception e) {
                 throw new BuildException(e);
             }
         }
         tfactory.setErrorListener(this);
 
         // specific attributes for the transformer
-        for (int i = 0; i < attributes.size(); i++) {
+        final int size = attributes.size();
+        for (int i = 0; i < size; i++) {
             final Object[] pair = (Object[]) attributes.elementAt(i);
             tfactory.setAttribute((String) pair[0], pair[1]);
         }
 
         if (uriResolver != null) {
             tfactory.setURIResolver(uriResolver);
         }
         return tfactory;
     }
 
 
     /**
      * Set the factory name to use instead of JAXP default lookup.
      * @param name the fully qualified class name of the factory to use
      * or null for the default JAXP look up mechanism.
      * @since Ant 1.6
      */
     public void setFactory(String name) {
         factoryName = name;
     }
 
     /**
      * Set a custom attribute for the JAXP factory implementation.
      * @param name the attribute name.
      * @param value the value of the attribute, usually a boolean
      * string or object.
      * @since Ant 1.6
      */
     public void setAttribute(String name, Object value) {
         final Object[] pair = new Object[]{name, value};
         attributes.addElement(pair);
     }
 
     /**
      * Set the output property for the current transformer.
      * Note that the stylesheet must be set prior to calling
      * this method.
      * @param name the output property name.
      * @param value the output property value.
      * @since Ant 1.5
      * @since Ant 1.5
      */
     public void setOutputProperty(String name, String value) {
         final String[] pair = new String[]{name, value};
         outputProperties.addElement(pair);
     }
 
     /**
      * Set the class to resolve entities during the transformation.
      * @param aResolver the resolver class.
      */
     public void setEntityResolver(EntityResolver aResolver) {
         entityResolver = aResolver;
     }
 
     /**
      * Set the class to resolve URIs during the transformation
      * @param aResolver a <code>EntityResolver</code> value
      */
     public void setURIResolver(URIResolver aResolver) {
         uriResolver = aResolver;
     }
 
     /**
      * Add a parameter.
      * @param name the name of the parameter
      * @param value the value of the parameter
      */
     public void addParam(String name, String value) {
         params.put(name, value);
     }
 
     /**
      * Set a logger.
      * @param l a logger.
      */
     public void setLogger(XSLTLogger l) {
         logger = l;
     }
 
     /**
      * Log an error.
      * @param e the exception to log.
      */
     public void error(TransformerException e) {
         logError(e, "Error");
     }
 
     /**
      * Log a fatal error.
      * @param e the exception to log.
      */
     public void fatalError(TransformerException e) {
         logError(e, "Fatal Error");
         throw new BuildException("Fatal error during transformation", e);
     }
 
     /**
      * Log a warning.
      * @param e the exception to log.
      */
     public void warning(TransformerException e) {
         if (!suppressWarnings) {
             logError(e, "Warning");
         }
     }
 
     private void logError(TransformerException e, String type) {
         if (logger == null) {
             return;
         }
 
         StringBuffer msg = new StringBuffer();
         SourceLocator locator = e.getLocator();
         if (locator != null) {
             String systemid = locator.getSystemId();
             if (systemid != null) {
                 String url = systemid;
                 if (url.startsWith("file:")) {
                     url = FileUtils.getFileUtils().fromURI(url);
                 }
                 msg.append(url);
             } else {
                 msg.append("Unknown file");
             }
             int line = locator.getLineNumber();
             if (line != -1) {
                 msg.append(":");
                 msg.append(line);
                 int column = locator.getColumnNumber();
                 if (column != -1) {
                     msg.append(":");
                     msg.append(column);
                 }
             }
         }
         msg.append(": ");
         msg.append(type);
         msg.append("! ");
         msg.append(e.getMessage());
         if (e.getCause() != null) {
             msg.append(" Cause: ");
             msg.append(e.getCause());
         }
 
         logger.log(msg.toString());
     }
 
     // kept for backwards compatibility
     /**
      * @param file the filename to use for the systemid
      * @return the systemid
      * @deprecated since 1.5.x.
      *             Use org.apache.tools.ant.util.JAXPUtils#getSystemId instead.
      */
     protected String getSystemId(File file) {
         return JAXPUtils.getSystemId(file);
     }
 
 
     /**
      * Specific configuration for the TRaX liaison.
      * @param xsltTask the XSLTProcess task instance from which this liasion
      *        is to be configured.
      */
     public void configure(XSLTProcess xsltTask) {
         project = xsltTask.getProject();
         XSLTProcess.Factory factory = xsltTask.getFactory();
         if (factory != null) {
             setFactory(factory.getName());
 
             // configure factory attributes
             for (Enumeration attrs = factory.getAttributes();
                     attrs.hasMoreElements();) {
                 XSLTProcess.Factory.Attribute attr =
                         (XSLTProcess.Factory.Attribute) attrs.nextElement();
                 setAttribute(attr.getName(), attr.getValue());
             }
         }
 
         XMLCatalog xmlCatalog = xsltTask.getXMLCatalog();
         // use XMLCatalog as the entity resolver and URI resolver
         if (xmlCatalog != null) {
             setEntityResolver(xmlCatalog);
             setURIResolver(xmlCatalog);
         }
 
 
         // configure output properties
         for (Enumeration props = xsltTask.getOutputProperties();
                 props.hasMoreElements();) {
             XSLTProcess.OutputProperty prop
                 = (XSLTProcess.OutputProperty) props.nextElement();
             setOutputProperty(prop.getName(), prop.getValue());
         }
 
         suppressWarnings = xsltTask.getSuppressWarnings();
 
         traceConfiguration = xsltTask.getTraceConfiguration();
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/XMLValidateTask.java b/src/main/org/apache/tools/ant/taskdefs/optional/XMLValidateTask.java
index f9ef0632d..24798f4a5 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/XMLValidateTask.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/XMLValidateTask.java
@@ -1,762 +1,765 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.util.Vector;
 
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.DTDLocation;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.types.XMLCatalog;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.JAXPUtils;
 import org.apache.tools.ant.util.XmlConstants;
 
 import org.xml.sax.EntityResolver;
 import org.xml.sax.ErrorHandler;
 import org.xml.sax.InputSource;
 import org.xml.sax.Parser;
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXNotRecognizedException;
 import org.xml.sax.SAXNotSupportedException;
 import org.xml.sax.SAXParseException;
 import org.xml.sax.XMLReader;
 import org.xml.sax.helpers.ParserAdapter;
 
 /**
  * Checks XML files are valid (or only well formed). The
  * task uses the SAX2 parser implementation provided by JAXP by default
  * (probably the one that is used by Ant itself), but one can specify any
  * SAX1/2 parser if needed.
  *
  */
 public class XMLValidateTask extends Task {
 
     /**
      * helper for path -> URI and URI -> path conversions.
      */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     protected static final String INIT_FAILED_MSG =
         "Could not start xml validation: ";
 
     // ant task properties
     // defaults
     // CheckStyle:VisibilityModifier OFF - bc
     protected boolean failOnError = true;
     protected boolean warn = true;
     protected boolean lenient = false;
     protected String readerClassName = null;
 
     /** file to be validated */
     protected File file = null;
     /** sets of file to be validated */
     protected Vector filesets = new Vector();
     protected Path classpath;
 
     /**
      * the parser is viewed as a SAX2 XMLReader. If a SAX1 parser is specified,
      * it's wrapped in an adapter that make it behave as a XMLReader.
      * a more 'standard' way of doing this would be to use the JAXP1.1 SAXParser
      * interface.
      */
     protected XMLReader xmlReader = null;
     // XMLReader used to validation process
     protected ValidatorErrorHandler errorHandler = new ValidatorErrorHandler();
     // to report sax parsing errors
     // CheckStyle:VisibilityModifier ON
 
     /** The vector to store all attributes (features) to be set on the parser. **/
     private Vector attributeList = new Vector();
 
     /**
      * List of properties.
      */
     private final Vector propertyList = new Vector();
 
     private XMLCatalog xmlCatalog = new XMLCatalog();
     /** Message for sucessfull validation */
     public static final String MESSAGE_FILES_VALIDATED
         = " file(s) have been successfully validated.";
 
     private AntClassLoader readerLoader = null;
 
     /**
      * Specify how parser error are to be handled.
      * Optional, default is <code>true</code>.
      * <p>
      * If set to <code>true</code> (default), throw a buildException if the
      * parser yields an error.
      * @param fail if set to <code>false</code> do not fail on error
      */
     public void setFailOnError(boolean fail) {
         failOnError = fail;
     }
 
     /**
      * Specify how parser error are to be handled.
      * <p>
      * If set to <code>true</true> (default), log a warn message for each SAX warn event.
      * @param bool if set to <code>false</code> do not send warnings
      */
     public void setWarn(boolean bool) {
         warn = bool;
     }
 
     /**
      * Specify whether the parser should be validating. Default
      * is <code>true</code>.
      * <p>
      * If set to false, the validation will fail only if the parsed document
      * is not well formed XML.
      * <p>
      * this option is ignored if the specified class
      * with {@link #setClassName(String)} is not a SAX2 XMLReader.
      * @param bool if set to <code>false</code> only fail on malformed XML
      */
     public void setLenient(boolean bool) {
         lenient = bool;
     }
 
     /**
      * Specify the class name of the SAX parser to be used. (optional)
      * @param className should be an implementation of SAX2
      * <code>org.xml.sax.XMLReader</code> or SAX2 <code>org.xml.sax.Parser</code>.
      * <p> if className is an implementation of
      * <code>org.xml.sax.Parser</code>, {@link #setLenient(boolean)},
      * will be ignored.
      * <p> if not set, the default will be used.
      * @see org.xml.sax.XMLReader
      * @see org.xml.sax.Parser
      */
     public void setClassName(String className) {
         readerClassName = className;
     }
 
     /**
      * Specify the classpath to be searched to load the parser (optional)
      * @param classpath the classpath to load the parser
      */
     public void setClasspath(Path classpath) {
         if (this.classpath == null) {
             this.classpath = classpath;
         } else {
             this.classpath.append(classpath);
         }
     }
 
     /**
      * @see #setClasspath
      * @return the classpath created
      */
     public Path createClasspath() {
         if (this.classpath == null) {
             this.classpath = new Path(getProject());
         }
         return this.classpath.createPath();
     }
 
     /**
      * Where to find the parser class; optional.
      * @see #setClasspath
      * @param r reference to a classpath defined elsewhere
      */
     public void setClasspathRef(Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * specify the file to be checked; optional.
      * @param file the file to be checked
      */
     public void setFile(File file) {
         this.file = file;
     }
 
     /**
      * add an XMLCatalog as a nested element; optional.
      * @param catalog XMLCatalog to use
      */
     public void addConfiguredXMLCatalog(XMLCatalog catalog) {
         xmlCatalog.addConfiguredXMLCatalog(catalog);
     }
 
     /**
      * specify a set of file to be checked
      * @param set the fileset to check
      */
     public void addFileset(FileSet set) {
         filesets.addElement(set);
     }
 
     /**
      * Add an attribute nested element. This is used for setting arbitrary
      * features of the SAX parser.
      * Valid attributes
      * <a href=
      * "http://www.saxproject.org/apidoc/org/xml/sax/package-summary.html#package_description"
      * >include</a>
      * @return attribute created
      * @since ant1.6
      */
     public Attribute createAttribute() {
         final Attribute feature = new Attribute();
         attributeList.addElement(feature);
         return feature;
     }
 
     /**
      * Creates a property.
      *
      * @return a property.
      * @since ant 1.6.2
      */
     public Property createProperty() {
         final Property prop = new Property();
         propertyList.addElement(prop);
         return prop;
     }
 
     /**
      * Called by the project to let the task initialize properly.
      *
      * @exception BuildException if something goes wrong with the build
      */
     public void init() throws BuildException {
         super.init();
         xmlCatalog.setProject(getProject());
     }
 
     /**
      * Create a DTD location record; optional.
      * This stores the location of a DTD. The DTD is identified
      * by its public Id.
      * @return created DTD location
      */
     public DTDLocation createDTD() {
         DTDLocation dtdLocation = new DTDLocation();
         xmlCatalog.addDTD(dtdLocation);
         return dtdLocation;
     }
     /**
      * accessor to the xmlCatalog used in the task
      * @return xmlCatalog reference
      */
     protected EntityResolver getEntityResolver() {
         return xmlCatalog;
     }
 
     /**
      * get the XML reader. Non-null only after {@link #initValidator()}.
      * If the reader is an instance of  {@link ParserAdapter} then
      * the parser is a SAX1 parser, and you cannot call
      * {@link #setFeature(String, boolean)} or {@link #setProperty(String, String)}
      * on it.
      * @return the XML reader or null.
      */
     protected XMLReader getXmlReader() {
         return xmlReader;
     }
 
     /**
      * execute the task
      * @throws BuildException if <code>failonerror</code> is true and an error happens
      */
     public void execute() throws BuildException {
         try {
         int fileProcessed = 0;
         if (file == null && (filesets.size() == 0)) {
             throw new BuildException(
                 "Specify at least one source - " + "a file or a fileset.");
         }
 
 
 
         if (file != null) {
             if (file.exists() && file.canRead() && file.isFile()) {
                 doValidate(file);
                 fileProcessed++;
             } else {
                 String errorMsg = "File " + file + " cannot be read";
                 if (failOnError) {
                     throw new BuildException(errorMsg);
                 } else {
                     log(errorMsg, Project.MSG_ERR);
                 }
             }
         }
 
-        for (int i = 0; i < filesets.size(); i++) {
+        final int size = filesets.size();
+        for (int i = 0; i < size; i++) {
 
             FileSet fs = (FileSet) filesets.elementAt(i);
             DirectoryScanner ds = fs.getDirectoryScanner(getProject());
             String[] files = ds.getIncludedFiles();
 
             for (int j = 0; j < files.length; j++) {
                 File srcFile = new File(fs.getDir(getProject()), files[j]);
                 doValidate(srcFile);
                 fileProcessed++;
             }
         }
         onSuccessfulValidation(fileProcessed);
         } finally {
             cleanup();
         }
     }
 
     /**
      * handler called on successful file validation.
      * @param fileProcessed number of files processed.
      */
     protected void onSuccessfulValidation(int fileProcessed) {
         log(fileProcessed + MESSAGE_FILES_VALIDATED);
     }
 
     /**
      * init the parser :
      * load the parser class, and set features if necessary
      * It is only after this that the reader is valid
      * @throws BuildException if something went wrong
      */
     protected void initValidator() {
 
         xmlReader = createXmlReader();
 
         xmlReader.setEntityResolver(getEntityResolver());
         xmlReader.setErrorHandler(errorHandler);
 
         if (!isSax1Parser()) {
             // turn validation on
             if (!lenient) {
                 setFeature(XmlConstants.FEATURE_VALIDATION, true);
             }
             // set the feature from the attribute list
-            for (int i = 0; i < attributeList.size(); i++) {
+            final int attSize = attributeList.size();
+            for (int i = 0; i < attSize; i++) {
                 Attribute feature = (Attribute) attributeList.elementAt(i);
                 setFeature(feature.getName(), feature.getValue());
 
             }
             // Sets properties
-            for (int i = 0; i < propertyList.size(); i++) {
+            final int propSize = propertyList.size();
+            for (int i = 0; i < propSize; i++) {
                 final Property prop = (Property) propertyList.elementAt(i);
                 setProperty(prop.getName(), prop.getValue());
             }
         }
     }
 
     /**
      * test that returns true if we are using a SAX1 parser.
      * @return true when a SAX1 parser is in use
      */
     protected boolean isSax1Parser() {
         return (xmlReader instanceof ParserAdapter);
     }
 
     /**
      * create the XML reader.
      * This is one by instantiating anything specified by {@link #readerClassName},
      * falling back to a default reader if not.
      * If the returned reader is an instance of {@link ParserAdapter} then
      * we have created and wrapped a SAX1 parser.
      * @return the new XMLReader.
      */
     protected XMLReader createXmlReader() {
         Object reader = null;
         if (readerClassName == null) {
             reader = createDefaultReaderOrParser();
         } else {
 
             Class readerClass = null;
             try {
                 // load the parser class
                 if (classpath != null) {
                     readerLoader = getProject().createClassLoader(classpath);
                     readerClass = Class.forName(readerClassName, true,
                                                 readerLoader);
                 } else {
                     readerClass = Class.forName(readerClassName);
                 }
 
                 reader = readerClass.newInstance();
             } catch (ClassNotFoundException e) {
                 throw new BuildException(INIT_FAILED_MSG + readerClassName, e);
             } catch (InstantiationException e) {
                 throw new BuildException(INIT_FAILED_MSG + readerClassName, e);
             } catch (IllegalAccessException e) {
                 throw new BuildException(INIT_FAILED_MSG + readerClassName, e);
             }
         }
 
         // then check it implements XMLReader
         XMLReader newReader;
         if (reader instanceof XMLReader) {
             newReader = (XMLReader) reader;
             log(
                 "Using SAX2 reader " + reader.getClass().getName(),
                 Project.MSG_VERBOSE);
         } else {
 
             // see if it is a SAX1 Parser
             if (reader instanceof Parser) {
                 newReader = new ParserAdapter((Parser) reader);
                 log(
                     "Using SAX1 parser " + reader.getClass().getName(),
                     Project.MSG_VERBOSE);
             } else {
                 throw new BuildException(
                     INIT_FAILED_MSG
                         + reader.getClass().getName()
                         + " implements nor SAX1 Parser nor SAX2 XMLReader.");
             }
         }
         return newReader;
     }
 
     /**
      * Cleans up resources.
      *
      * @since Ant 1.8.0
      */
     protected void cleanup() {
         if (readerLoader != null) {
             readerLoader.cleanup();
             readerLoader = null;
         }
     }
 
     /**
      *
      * @return
      */
     private Object createDefaultReaderOrParser() {
         Object reader;
         try {
             reader = createDefaultReader();
         } catch (BuildException exc) {
             reader = JAXPUtils.getParser();
         }
         return reader;
     }
 
     /**
      * create a reader if the use of the class did not specify another one.
      * If a BuildException is thrown, the caller may revert to an alternate
      * reader.
      * @return a new reader.
      * @throws BuildException if something went wrong
      */
     protected XMLReader createDefaultReader() {
         return JAXPUtils.getXMLReader();
     }
 
     /**
      * Set a feature on the parser.
      * @param feature the name of the feature to set
      * @param value the value of the feature
      * @throws BuildException if the feature was not supported
      */
     protected void setFeature(String feature, boolean value)
         throws BuildException {
         log("Setting feature " + feature + "=" + value, Project.MSG_DEBUG);
         try {
             xmlReader.setFeature(feature, value);
         } catch (SAXNotRecognizedException e) {
             throw new BuildException(
                 "Parser "
                     + xmlReader.getClass().getName()
                     + " doesn't recognize feature "
                     + feature,
                 e,
                 getLocation());
         } catch (SAXNotSupportedException e) {
             throw new BuildException(
                 "Parser "
                     + xmlReader.getClass().getName()
                     + " doesn't support feature "
                     + feature,
                 e,
                 getLocation());
         }
     }
 
     /**
      * Sets a property.
      *
      * @param name a property name
      * @param value a property value.
      * @throws BuildException if an error occurs.
      * @throws BuildException if the property was not supported
      */
     protected void setProperty(String name, String value) throws BuildException {
         // Validates property
         if (name == null || value == null) {
             throw new BuildException("Property name and value must be specified.");
         }
 
         try {
             xmlReader.setProperty(name, value);
         } catch (SAXNotRecognizedException e) {
             throw new BuildException(
                 "Parser "
                     + xmlReader.getClass().getName()
                     + " doesn't recognize property "
                     + name,
                 e,
                 getLocation());
         } catch (SAXNotSupportedException e) {
             throw new BuildException(
                 "Parser "
                     + xmlReader.getClass().getName()
                     + " doesn't support property "
                     + name,
                 e,
                 getLocation());
         }
     }
 
     /**
      * parse the file
      * @param afile the file to validate.
      * @return true if the file validates.
      */
     protected boolean doValidate(File afile) {
         //for every file, we have a new instance of the validator
         initValidator();
         boolean result = true;
         try {
             log("Validating " + afile.getName() + "... ", Project.MSG_VERBOSE);
             errorHandler.init(afile);
             InputSource is = new InputSource(new FileInputStream(afile));
             String uri = FILE_UTILS.toURI(afile.getAbsolutePath());
             is.setSystemId(uri);
             xmlReader.parse(is);
         } catch (SAXException ex) {
             log("Caught when validating: " + ex.toString(), Project.MSG_DEBUG);
             if (failOnError) {
                 throw new BuildException(
                     "Could not validate document " + afile);
             }
             log("Could not validate document " + afile + ": " + ex.toString());
             result = false;
         } catch (IOException ex) {
             throw new BuildException(
                 "Could not validate document " + afile,
                 ex);
         }
         if (errorHandler.getFailure()) {
             if (failOnError) {
                 throw new BuildException(
                     afile + " is not a valid XML document.");
             }
             result = false;
             log(afile + " is not a valid XML document", Project.MSG_ERR);
         }
         return result;
     }
 
     /**
      * ValidatorErrorHandler role :
      * <ul>
      * <li> log SAX parse exceptions,
      * <li> remember if an error occurred
      * </ul>
      */
     protected class ValidatorErrorHandler implements ErrorHandler {
 
         // CheckStyle:VisibilityModifier OFF - bc
         protected File currentFile = null;
         protected String lastErrorMessage = null;
         protected boolean failed = false;
         // CheckStyle:VisibilityModifier ON
         /**
          * initialises the class
          * @param file file used
          */
         public void init(File file) {
             currentFile = file;
             failed = false;
         }
         /**
          * did an error happen during last parsing ?
          * @return did an error happen during last parsing ?
          */
         public boolean getFailure() {
             return failed;
         }
 
         /**
          * record a fatal error
          * @param exception the fatal error
          */
         public void fatalError(SAXParseException exception) {
             failed = true;
             doLog(exception, Project.MSG_ERR);
         }
         /**
          * receive notification of a recoverable error
          * @param exception the error
          */
         public void error(SAXParseException exception) {
             failed = true;
             doLog(exception, Project.MSG_ERR);
         }
         /**
          * receive notification of a warning
          * @param exception the warning
          */
         public void warning(SAXParseException exception) {
             // depending on implementation, XMLReader can yield hips of warning,
             // only output then if user explicitly asked for it
             if (warn) {
                 doLog(exception, Project.MSG_WARN);
             }
         }
 
         private void doLog(SAXParseException e, int logLevel) {
 
             log(getMessage(e), logLevel);
         }
 
         private String getMessage(SAXParseException e) {
             String sysID = e.getSystemId();
             if (sysID != null) {
                 String name = sysID;
                 if (sysID.startsWith("file:")) {
                     try {
                         name = FILE_UTILS.fromURI(sysID);
                     } catch (Exception ex) {
                         // if this is not a valid file: just use the uri
                     }
                 }
                 int line = e.getLineNumber();
                 int col = e.getColumnNumber();
                 return  name
                     + (line == -1
                        ? ""
                        : (":" + line + (col == -1 ? "" : (":" + col))))
                     + ": "
                     + e.getMessage();
             }
             return e.getMessage();
         }
     }
 
     /**
      * The class to create to set a feature of the parser.
      * @since ant1.6
      */
     public static class Attribute {
         /** The name of the attribute to set.
          *
          * Valid attributes <a href=
          * "http://www.saxproject.org/apidoc/org/xml/sax/package-summary.html#package_description"
          * >include.</a>
          */
         private String attributeName = null;
 
         /**
          * The value of the feature.
          **/
         private boolean attributeValue;
 
         /**
          * Set the feature name.
          * @param name the name to set
          */
         public void setName(String name) {
             attributeName = name;
         }
         /**
          * Set the feature value to true or false.
          * @param value feature value
          */
         public void setValue(boolean value) {
             attributeValue = value;
         }
 
         /**
          * Gets the attribute name.
          * @return the feature name
          */
         public String getName() {
             return attributeName;
         }
 
         /**
          * Gets the attribute value.
          * @return the feature value
          */
         public boolean getValue() {
             return attributeValue;
         }
     }
 
     /**
      * A Parser property.
      * See <a href="http://xml.apache.org/xerces-j/properties.html">
      * XML parser properties</a> for usable properties
      * @since ant 1.6.2
      */
     public static final class Property {
 
         private String name;
         private String value;
         /**
          * accessor to the name of the property
          * @return name of the property
          */
         public String getName() {
             return name;
         }
         /**
          * setter for the name of the property
          * @param name name of the property
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * getter for the value of the property
          * @return value of the property
          */
         public String getValue() {
             return value;
         }
         /**
          * sets the value of the property
          * @param value value of the property
          */
         public void setValue(String value) {
             this.value = value;
         }
 
     } // Property
 
 
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/depend/ClassFile.java b/src/main/org/apache/tools/ant/taskdefs/optional/depend/ClassFile.java
index 1f0c2d8f8..1435d63da 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/depend/ClassFile.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/depend/ClassFile.java
@@ -1,119 +1,120 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.depend;
 
 import java.io.DataInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Vector;
 import org.apache.tools.ant.taskdefs.optional.depend.constantpool.ClassCPInfo;
 import org.apache.tools.ant.taskdefs.optional.depend.constantpool.ConstantPool;
 import org.apache.tools.ant.taskdefs.optional.depend.constantpool.ConstantPoolEntry;
 
 /**
  * A ClassFile object stores information about a Java class. The class may
  * be read from a DataInputStream.and written to a DataOutputStream. These
  * are usually streams from a Java class file or a class file component of a
  * Jar file.
  *
  */
 public class ClassFile {
 
     /** The Magic Value that marks the start of a Java class file  */
     private static final int CLASS_MAGIC = 0xCAFEBABE;
 
     /** This class' constant pool.  */
     private ConstantPool constantPool;
 
     /** The class name for this class.  */
     private String className;
 
     /**
      * Read the class from a data stream. This method takes an InputStream
      * as input and parses the class from the stream. <p>
      *
      *
      *
      * @param stream an InputStream from which the class will be read
      * @exception IOException if there is a problem reading from the given
      *      stream.
      * @exception ClassFormatError if the class cannot be parsed correctly
      */
     public void read(InputStream stream) throws IOException, ClassFormatError {
         DataInputStream classStream = new DataInputStream(stream);
 
         if (classStream.readInt() != CLASS_MAGIC) {
             throw new ClassFormatError("No Magic Code Found "
                 + "- probably not a Java class file.");
         }
 
         // right we have a good looking class file.
         /* int minorVersion = */ classStream.readUnsignedShort();
         /* int majorVersion = */ classStream.readUnsignedShort();
 
         // read the constant pool in and resolve it
         constantPool = new ConstantPool();
 
         constantPool.read(classStream);
         constantPool.resolve();
 
         /* int accessFlags = */ classStream.readUnsignedShort();
         int thisClassIndex = classStream.readUnsignedShort();
         /* int superClassIndex = */ classStream.readUnsignedShort();
         ClassCPInfo classInfo
             = (ClassCPInfo) constantPool.getEntry(thisClassIndex);
         className  = classInfo.getClassName();
     }
 
 
     /**
      * Get the classes which this class references.
      *
      * @return a vector of class names which this class references
      */
     public Vector getClassRefs() {
 
         Vector classRefs = new Vector();
 
-        for (int i = 0; i < constantPool.size(); ++i) {
+        final int size = constantPool.size();
+        for (int i = 0; i < size; ++i) {
             ConstantPoolEntry entry = constantPool.getEntry(i);
 
             if (entry != null
                 && entry.getTag() == ConstantPoolEntry.CONSTANT_CLASS) {
                 ClassCPInfo classEntry = (ClassCPInfo) entry;
 
                 if (!classEntry.getClassName().equals(className)) {
                     classRefs.addElement(
                         ClassFileUtils.convertSlashName(classEntry.getClassName()));
                 }
             }
         }
 
         return classRefs;
     }
 
     /**
      * Get the class' fully qualified name in dot format.
      *
      * @return the class name in dot format (eg. java.lang.Object)
      */
     public String getFullClassName() {
         return ClassFileUtils.convertSlashName(className);
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/depend/constantpool/ConstantPool.java b/src/main/org/apache/tools/ant/taskdefs/optional/depend/constantpool/ConstantPool.java
index 2ce24db23..70168a098 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/depend/constantpool/ConstantPool.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/depend/constantpool/ConstantPool.java
@@ -1,357 +1,363 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.depend.constantpool;
 
 import java.io.DataInputStream;
 import java.io.IOException;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Vector;
 
 /**
  * The constant pool of a Java class. The constant pool is a collection of
  * constants used in a Java class file. It stores strings, constant values,
  * class names, method names, field names etc.
  *
  * @see <a href="http://java.sun.com/docs/books/vmspec/">The Java Virtual
  *      Machine Specification</a>
  */
 public class ConstantPool {
 
     /** The entries in the constant pool. */
     private Vector entries;
 
     /**
      * A Hashtable of UTF8 entries - used to get constant pool indexes of
      * the UTF8 values quickly
      */
     private Hashtable utf8Indexes;
 
     /** Initialise the constant pool. */
     public ConstantPool() {
         entries = new Vector();
 
         // The zero index is never present in the constant pool itself so
         // we add a null entry for it
         entries.addElement(null);
 
         utf8Indexes = new Hashtable();
     }
 
     /**
      * Read the constant pool from a class input stream.
      *
      * @param classStream the DataInputStream of a class file.
      * @exception IOException if there is a problem reading the constant pool
      *      from the stream
      */
     public void read(DataInputStream classStream) throws IOException {
         int numEntries = classStream.readUnsignedShort();
 
         for (int i = 1; i < numEntries;) {
             ConstantPoolEntry nextEntry
                  = ConstantPoolEntry.readEntry(classStream);
 
             i += nextEntry.getNumEntries();
 
             addEntry(nextEntry);
         }
     }
 
     /**
      * Get the size of the constant pool.
      *
      * @return the size of the constant pool
      */
     public int size() {
         return entries.size();
     }
 
     /**
      * Add an entry to the constant pool.
      *
      * @param entry the new entry to be added to the constant pool.
      * @return the index into the constant pool at which the entry is
      *      stored.
      */
     public int addEntry(ConstantPoolEntry entry) {
         int index = entries.size();
 
         entries.addElement(entry);
 
         int numSlots = entry.getNumEntries();
 
         // add null entries for any additional slots required.
         for (int j = 0; j < numSlots - 1; ++j) {
             entries.addElement(null);
         }
 
         if (entry instanceof Utf8CPInfo) {
             Utf8CPInfo utf8Info = (Utf8CPInfo) entry;
 
             utf8Indexes.put(utf8Info.getValue(), new Integer(index));
         }
 
         return index;
     }
 
     /**
      * Resolve the entries in the constant pool. Resolution of the constant
      * pool involves transforming indexes to other constant pool entries
      * into the actual data for that entry.
      */
     public void resolve() {
         for (Enumeration i = entries.elements(); i.hasMoreElements();) {
             ConstantPoolEntry poolInfo = (ConstantPoolEntry) i.nextElement();
 
             if (poolInfo != null && !poolInfo.isResolved()) {
                 poolInfo.resolve(this);
             }
         }
     }
 
 
     /**
      * Get an constant pool entry at a particular index.
      *
      * @param index the index into the constant pool.
      * @return the constant pool entry at that index.
      */
     public ConstantPoolEntry getEntry(int index) {
         return (ConstantPoolEntry) entries.elementAt(index);
     }
 
     /**
      * Get the index of a given UTF8 constant pool entry.
      *
      * @param value the string value of the UTF8 entry.
      * @return the index at which the given string occurs in the constant
      *      pool or -1 if the value does not occur.
      */
     public int getUTF8Entry(String value) {
         int index = -1;
         Integer indexInteger = (Integer) utf8Indexes.get(value);
 
         if (indexInteger != null) {
             index = indexInteger.intValue();
         }
 
         return index;
     }
 
     /**
      * Get the index of a given CONSTANT_CLASS entry in the constant pool.
      *
      * @param className the name of the class for which the class entry
      *      index is required.
      * @return the index at which the given class entry occurs in the
      *      constant pool or -1 if the value does not occur.
      */
     public int getClassEntry(String className) {
         int index = -1;
 
-        for (int i = 0; i < entries.size() && index == -1; ++i) {
+        final int size = entries.size();
+        for (int i = 0; i < size && index == -1; ++i) {
             Object element = entries.elementAt(i);
 
             if (element instanceof ClassCPInfo) {
                 ClassCPInfo classinfo = (ClassCPInfo) element;
 
                 if (classinfo.getClassName().equals(className)) {
                     index = i;
                 }
             }
         }
 
         return index;
     }
 
     /**
      * Get the index of a given constant value entry in the constant pool.
      *
      * @param constantValue the constant value for which the index is
      *      required.
      * @return the index at which the given value entry occurs in the
      *      constant pool or -1 if the value does not occur.
      */
     public int getConstantEntry(Object constantValue) {
         int index = -1;
 
-        for (int i = 0; i < entries.size() && index == -1; ++i) {
+        final int size = entries.size();
+        for (int i = 0; i < size && index == -1; ++i) {
             Object element = entries.elementAt(i);
 
             if (element instanceof ConstantCPInfo) {
                 ConstantCPInfo constantEntry = (ConstantCPInfo) element;
 
                 if (constantEntry.getValue().equals(constantValue)) {
                     index = i;
                 }
             }
         }
 
         return index;
     }
 
     /**
      * Get the index of a given CONSTANT_METHODREF entry in the constant
      * pool.
      *
      * @param methodClassName the name of the class which contains the
      *      method being referenced.
      * @param methodName the name of the method being referenced.
      * @param methodType the type descriptor of the method being referenced.
      * @return the index at which the given method ref entry occurs in the
      *      constant pool or -1 if the value does not occur.
      */
     public int getMethodRefEntry(String methodClassName, String methodName,
                                  String methodType) {
         int index = -1;
 
-        for (int i = 0; i < entries.size() && index == -1; ++i) {
+        final int size = entries.size();
+        for (int i = 0; i < size && index == -1; ++i) {
             Object element = entries.elementAt(i);
 
             if (element instanceof MethodRefCPInfo) {
                 MethodRefCPInfo methodRefEntry = (MethodRefCPInfo) element;
 
                 if (methodRefEntry.getMethodClassName().equals(methodClassName)
                      && methodRefEntry.getMethodName().equals(methodName)
                      && methodRefEntry.getMethodType().equals(methodType)) {
                     index = i;
                 }
             }
         }
 
         return index;
     }
 
     /**
      * Get the index of a given CONSTANT_INTERFACEMETHODREF entry in the
      * constant pool.
      *
      * @param interfaceMethodClassName the name of the interface which
      *      contains the method being referenced.
      * @param interfaceMethodName the name of the method being referenced.
      * @param interfaceMethodType the type descriptor of the method being
      *      referenced.
      * @return the index at which the given method ref entry occurs in the
      *      constant pool or -1 if the value does not occur.
      */
     public int getInterfaceMethodRefEntry(String interfaceMethodClassName,
                                           String interfaceMethodName,
                                           String interfaceMethodType) {
         int index = -1;
 
-        for (int i = 0; i < entries.size() && index == -1; ++i) {
+        final int size = entries.size();
+        for (int i = 0; i < size && index == -1; ++i) {
             Object element = entries.elementAt(i);
 
             if (element instanceof InterfaceMethodRefCPInfo) {
                 InterfaceMethodRefCPInfo interfaceMethodRefEntry
                      = (InterfaceMethodRefCPInfo) element;
 
                 if (interfaceMethodRefEntry.getInterfaceMethodClassName().equals(
                         interfaceMethodClassName)
                      && interfaceMethodRefEntry.getInterfaceMethodName().equals(
                          interfaceMethodName)
                      && interfaceMethodRefEntry.getInterfaceMethodType().equals(
                          interfaceMethodType)) {
                     index = i;
                 }
             }
         }
 
         return index;
     }
 
     /**
      * Get the index of a given CONSTANT_FIELDREF entry in the constant
      * pool.
      *
      * @param fieldClassName the name of the class which contains the field
      *      being referenced.
      * @param fieldName the name of the field being referenced.
      * @param fieldType the type descriptor of the field being referenced.
      * @return the index at which the given field ref entry occurs in the
      *      constant pool or -1 if the value does not occur.
      */
     public int getFieldRefEntry(String fieldClassName, String fieldName,
                                 String fieldType) {
         int index = -1;
 
-        for (int i = 0; i < entries.size() && index == -1; ++i) {
+        final int size = entries.size();
+        for (int i = 0; i < size && index == -1; ++i) {
             Object element = entries.elementAt(i);
 
             if (element instanceof FieldRefCPInfo) {
                 FieldRefCPInfo fieldRefEntry = (FieldRefCPInfo) element;
 
                 if (fieldRefEntry.getFieldClassName().equals(fieldClassName)
                      && fieldRefEntry.getFieldName().equals(fieldName)
                      && fieldRefEntry.getFieldType().equals(fieldType)) {
                     index = i;
                 }
             }
         }
 
         return index;
     }
 
     /**
      * Get the index of a given CONSTANT_NAMEANDTYPE entry in the constant
      * pool.
      *
      * @param name the name
      * @param type the type
      * @return the index at which the given NameAndType entry occurs in the
      *      constant pool or -1 if the value does not occur.
      */
     public int getNameAndTypeEntry(String name, String type) {
         int index = -1;
 
-        for (int i = 0; i < entries.size() && index == -1; ++i) {
+        final int size = entries.size();
+        for (int i = 0; i < size && index == -1; ++i) {
             Object element = entries.elementAt(i);
 
             if (element instanceof NameAndTypeCPInfo) {
                 NameAndTypeCPInfo nameAndTypeEntry
                     = (NameAndTypeCPInfo) element;
 
                 if (nameAndTypeEntry.getName().equals(name)
                      && nameAndTypeEntry.getType().equals(type)) {
                     index = i;
                 }
             }
         }
 
         return index;
     }
 
     /**
      * Dump the constant pool to a string.
      *
      * @return the constant pool entries as strings
      */
     public String toString() {
         StringBuffer sb = new StringBuffer("\n");
-        int size = entries.size();
+        final int size = entries.size();
 
         for (int i = 0; i < size; ++i) {
             sb.append("[" + i + "] = " + getEntry(i) + "\n");
         }
 
         return sb.toString();
     }
 
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/i18n/Translate.java b/src/main/org/apache/tools/ant/taskdefs/optional/i18n/Translate.java
index cf6fa5f1c..34f7a37a9 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/i18n/Translate.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/i18n/Translate.java
@@ -1,630 +1,631 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.i18n;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.util.Hashtable;
 import java.util.Locale;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.LineTokenizer;
 
 /**
  * Translates text embedded in files using Resource Bundle files.
  * Since ant 1.6 preserves line endings
  *
  */
 public class Translate extends MatchingTask {
     /**
      * search a bundle matching the specified language, the country and the variant
      */
     private static final int BUNDLE_SPECIFIED_LANGUAGE_COUNTRY_VARIANT = 0;
     /**
      * search a bundle matching the specified language, and the country
      */
     private static final int BUNDLE_SPECIFIED_LANGUAGE_COUNTRY = 1;
     /**
      * search a bundle matching the specified language only
      */
     private static final int BUNDLE_SPECIFIED_LANGUAGE = 2;
     /**
      * search a bundle matching nothing special
      */
     private static final int BUNDLE_NOMATCH = 3;
     /**
      * search a bundle matching the language, the country and the variant
      * of the current locale of the computer
      */
     private static final int BUNDLE_DEFAULT_LANGUAGE_COUNTRY_VARIANT = 4;
     /**
      * search a bundle matching the language, and the country
      * of the current locale of the computer
      */
     private static final int BUNDLE_DEFAULT_LANGUAGE_COUNTRY = 5;
     /**
      * search a bundle matching the language only
      * of the current locale of the computer
      */
     private static final int BUNDLE_DEFAULT_LANGUAGE = 6;
     /**
      * number of possibilities for the search
      */
      private static final int BUNDLE_MAX_ALTERNATIVES = BUNDLE_DEFAULT_LANGUAGE + 1;
     /**
      * Family name of resource bundle
      */
     private String bundle;
 
     /**
      * Locale specific language of the resource bundle
      */
     private String bundleLanguage;
 
     /**
      * Locale specific country of the resource bundle
      */
     private String bundleCountry;
 
     /**
      * Locale specific variant of the resource bundle
      */
     private String bundleVariant;
 
     /**
      * Destination directory
      */
     private File toDir;
 
     /**
      * Source file encoding scheme
      */
     private String srcEncoding;
 
     /**
      * Destination file encoding scheme
      */
     private String destEncoding;
 
     /**
      * Resource Bundle file encoding scheme, defaults to srcEncoding
      */
     private String bundleEncoding;
 
     /**
      * Starting token to identify keys
      */
     private String startToken;
 
     /**
      * Ending token to identify keys
      */
     private String endToken;
 
     /**
      * Whether or not to create a new destination file.
      * Defaults to <code>false</code>.
      */
     private boolean forceOverwrite;
 
     /**
      * Vector to hold source file sets.
      */
     private Vector filesets = new Vector();
 
     /**
      * Holds key value pairs loaded from resource bundle file
      */
     private Hashtable resourceMap = new Hashtable();
     /**
 
      * Used to resolve file names.
      */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * Last Modified Timestamp of resource bundle file being used.
      */
     private long[] bundleLastModified = new long[BUNDLE_MAX_ALTERNATIVES];
 
     /**
      * Last Modified Timestamp of source file being used.
      */
     private long srcLastModified;
 
     /**
      * Last Modified Timestamp of destination file being used.
      */
     private long destLastModified;
 
     /**
      * Has at least one file from the bundle been loaded?
      */
     private boolean loaded = false;
 
     /**
      * Sets Family name of resource bundle; required.
      * @param bundle family name of resource bundle
      */
     public void setBundle(String bundle) {
         this.bundle = bundle;
     }
 
     /**
      * Sets locale specific language of resource bundle; optional.
      * @param bundleLanguage langage of the bundle
      */
     public void setBundleLanguage(String bundleLanguage) {
         this.bundleLanguage = bundleLanguage;
     }
 
     /**
      * Sets locale specific country of resource bundle; optional.
      * @param bundleCountry country of the bundle
      */
     public void setBundleCountry(String bundleCountry) {
         this.bundleCountry = bundleCountry;
     }
 
     /**
      * Sets locale specific variant of resource bundle; optional.
      * @param bundleVariant locale variant of resource bundle
      */
     public void setBundleVariant(String bundleVariant) {
         this.bundleVariant = bundleVariant;
     }
 
     /**
      * Sets Destination directory; required.
      * @param toDir destination directory
      */
     public void setToDir(File toDir) {
         this.toDir = toDir;
     }
 
     /**
      * Sets starting token to identify keys; required.
      * @param startToken starting token to identify keys
      */
     public void setStartToken(String startToken) {
         this.startToken = startToken;
     }
 
     /**
      * Sets ending token to identify keys; required.
      * @param endToken ending token to identify keys
      */
     public void setEndToken(String endToken) {
         this.endToken = endToken;
     }
 
     /**
      * Sets source file encoding scheme; optional,
      * defaults to encoding of local system.
      * @param srcEncoding source file encoding
      */
     public void setSrcEncoding(String srcEncoding) {
         this.srcEncoding = srcEncoding;
     }
 
     /**
      * Sets destination file encoding scheme; optional.  Defaults to source file
      * encoding
      * @param destEncoding destination file encoding scheme
      */
     public void setDestEncoding(String destEncoding) {
         this.destEncoding = destEncoding;
     }
 
     /**
      * Sets Resource Bundle file encoding scheme; optional.  Defaults to source file
      * encoding
      * @param bundleEncoding bundle file encoding scheme
      */
     public void setBundleEncoding(String bundleEncoding) {
         this.bundleEncoding = bundleEncoding;
     }
 
     /**
      * Whether or not to overwrite existing file irrespective of
      * whether it is newer than the source file as well as the
      * resource bundle file.
      * Defaults to false.
      * @param forceOverwrite whether or not to overwrite existing files
      */
     public void setForceOverwrite(boolean forceOverwrite) {
         this.forceOverwrite = forceOverwrite;
     }
 
     /**
      * Adds a set of files to translate as a nested fileset element.
      * @param set the fileset to be added
      */
     public void addFileset(FileSet set) {
         filesets.addElement(set);
     }
 
     /**
      * Check attributes values, load resource map and translate
      * @throws BuildException if the required attributes are not set
      * Required : <ul>
      *       <li>bundle</li>
      *       <li>starttoken</li>
      *       <li>endtoken</li>
      *            </ul>
      */
     public void execute() throws BuildException {
         if (bundle == null) {
             throw new BuildException("The bundle attribute must be set.",
                                      getLocation());
         }
 
         if (startToken == null) {
             throw new BuildException("The starttoken attribute must be set.",
                                      getLocation());
         }
 
         if (endToken == null) {
             throw new BuildException("The endtoken attribute must be set.",
                                      getLocation());
         }
 
         if (bundleLanguage == null) {
             Locale l = Locale.getDefault();
             bundleLanguage  = l.getLanguage();
         }
 
         if (bundleCountry == null) {
             bundleCountry = Locale.getDefault().getCountry();
         }
 
         if (bundleVariant == null) {
             Locale l = new Locale(bundleLanguage, bundleCountry);
             bundleVariant = l.getVariant();
         }
 
         if (toDir == null) {
             throw new BuildException("The todir attribute must be set.",
                                      getLocation());
         }
 
         if (!toDir.exists()) {
             toDir.mkdirs();
         } else if (toDir.isFile()) {
             throw new BuildException(toDir + " is not a directory");
         }
 
         if (srcEncoding == null) {
             srcEncoding = System.getProperty("file.encoding");
         }
 
         if (destEncoding == null) {
             destEncoding = srcEncoding;
         }
 
         if (bundleEncoding == null) {
             bundleEncoding = srcEncoding;
         }
 
         loadResourceMaps();
 
         translate();
     }
 
     /**
      * Load resource maps based on resource bundle encoding scheme.
      * The resource bundle lookup searches for resource files with various
      * suffixes on the basis of (1) the desired locale and (2) the default
      * locale (basebundlename), in the following order from lower-level
      * (more specific) to parent-level (less specific):
      *
      * basebundlename + "_" + language1 + "_" + country1 + "_" + variant1
      * basebundlename + "_" + language1 + "_" + country1
      * basebundlename + "_" + language1
      * basebundlename
      * basebundlename + "_" + language2 + "_" + country2 + "_" + variant2
      * basebundlename + "_" + language2 + "_" + country2
      * basebundlename + "_" + language2
      *
      * To the generated name, a ".properties" string is appeneded and
      * once this file is located, it is treated just like a properties file
      * but with bundle encoding also considered while loading.
      */
     private void loadResourceMaps() throws BuildException {
         Locale locale = new Locale(bundleLanguage,
                                    bundleCountry,
                                    bundleVariant);
         String language = locale.getLanguage().length() > 0
             ? "_" + locale.getLanguage() : "";
         String country = locale.getCountry().length() > 0
             ? "_" + locale.getCountry() : "";
         String variant = locale.getVariant().length() > 0
             ? "_" + locale.getVariant() : "";
         String bundleFile = bundle + language + country + variant;
         processBundle(bundleFile, BUNDLE_SPECIFIED_LANGUAGE_COUNTRY_VARIANT, false);
 
         bundleFile = bundle + language + country;
         processBundle(bundleFile, BUNDLE_SPECIFIED_LANGUAGE_COUNTRY, false);
 
         bundleFile = bundle + language;
         processBundle(bundleFile, BUNDLE_SPECIFIED_LANGUAGE, false);
 
         bundleFile = bundle;
         processBundle(bundleFile, BUNDLE_NOMATCH, false);
 
         //Load default locale bundle files
         //using default file encoding scheme.
         locale = Locale.getDefault();
 
         language = locale.getLanguage().length() > 0
             ? "_" + locale.getLanguage() : "";
         country = locale.getCountry().length() > 0
             ? "_" + locale.getCountry() : "";
         variant = locale.getVariant().length() > 0
             ? "_" + locale.getVariant() : "";
         bundleEncoding = System.getProperty("file.encoding");
 
         bundleFile = bundle + language + country + variant;
         processBundle(bundleFile, BUNDLE_DEFAULT_LANGUAGE_COUNTRY_VARIANT, false);
 
         bundleFile = bundle + language + country;
         processBundle(bundleFile, BUNDLE_DEFAULT_LANGUAGE_COUNTRY, false);
 
         bundleFile = bundle + language;
         processBundle(bundleFile, BUNDLE_DEFAULT_LANGUAGE, true);
     }
 
     /**
      * Process each file that makes up this bundle.
      */
     private void processBundle(final String bundleFile, final int i,
                                final boolean checkLoaded) throws BuildException {
         final File propsFile = getProject().resolveFile(bundleFile + ".properties");
         FileInputStream ins = null;
         try {
             ins = new FileInputStream(propsFile);
             loaded = true;
             bundleLastModified[i] = propsFile.lastModified();
             log("Using " + propsFile, Project.MSG_DEBUG);
             loadResourceMap(ins);
         } catch (IOException ioe) {
             log(propsFile + " not found.", Project.MSG_DEBUG);
             //if all resource files associated with this bundle
             //have been scanned for and still not able to
             //find a single resrouce file, throw exception
             if (!loaded && checkLoaded) {
                 throw new BuildException(ioe.getMessage(), getLocation());
             }
         }
     }
 
     /**
      * Load resourceMap with key value pairs.  Values of existing keys
      * are not overwritten.  Bundle's encoding scheme is used.
      */
     private void loadResourceMap(FileInputStream ins) throws BuildException {
         try {
             BufferedReader in = null;
             InputStreamReader isr = new InputStreamReader(ins, bundleEncoding);
             in = new BufferedReader(isr);
             String line = null;
             while ((line = in.readLine()) != null) {
                 //So long as the line isn't empty and isn't a comment...
                 if (line.trim().length() > 1 && '#' != line.charAt(0) && '!' != line.charAt(0)) {
                     //Legal Key-Value separators are :, = and white space.
                     int sepIndex = line.indexOf('=');
                     if (-1 == sepIndex) {
                         sepIndex = line.indexOf(':');
                     }
                     if (-1 == sepIndex) {
                         for (int k = 0; k < line.length(); k++) {
                             if (Character.isSpaceChar(line.charAt(k))) {
                                 sepIndex = k;
                                 break;
                             }
                         }
                     }
                     //Only if we do have a key is there going to be a value
                     if (-1 != sepIndex) {
                         String key = line.substring(0, sepIndex).trim();
                         String value = line.substring(sepIndex + 1).trim();
                         //Handle line continuations, if any
                         while (value.endsWith("\\")) {
                             value = value.substring(0, value.length() - 1);
                             line = in.readLine();
                             if (line != null) {
                                 value = value + line.trim();
                             } else {
                                 break;
                             }
                         }
                         if (key.length() > 0) {
                             //Has key already been loaded into resourceMap?
                             if (resourceMap.get(key) == null) {
                                 resourceMap.put(key, value);
                             }
                         }
                     }
                 }
             }
             if (in != null) {
                 in.close();
             }
         } catch (IOException ioe) {
             throw new BuildException(ioe.getMessage(), getLocation());
         }
     }
 
     /**
      * Reads source file line by line using the source encoding and
      * searches for keys that are sandwiched between the startToken
      * and endToken.  The values for these keys are looked up from
      * the hashtable and substituted.  If the hashtable doesn't
      * contain the key, they key itself is used as the value.
      * Detination files and directories are created as needed.
      * The destination file is overwritten only if
      * the forceoverwritten attribute is set to true if
      * the source file or any associated bundle resource file is
      * newer than the destination file.
      */
     private void translate() throws BuildException {
         int filesProcessed = 0;
-        for (int i = 0; i < filesets.size(); i++) {
+        final int size = filesets.size();
+        for (int i = 0; i < size; i++) {
             FileSet fs = (FileSet) filesets.elementAt(i);
             DirectoryScanner ds = fs.getDirectoryScanner(getProject());
             String[] srcFiles = ds.getIncludedFiles();
             for (int j = 0; j < srcFiles.length; j++) {
                 try {
                     File dest = FILE_UTILS.resolveFile(toDir, srcFiles[j]);
                     //Make sure parent dirs exist, else, create them.
                     try {
                         File destDir = new File(dest.getParent());
                         if (!destDir.exists()) {
                             destDir.mkdirs();
                         }
                     } catch (Exception e) {
                         log("Exception occurred while trying to check/create "
                             + " parent directory.  " + e.getMessage(),
                             Project.MSG_DEBUG);
                     }
                     destLastModified = dest.lastModified();
                     File src = FILE_UTILS.resolveFile(ds.getBasedir(), srcFiles[j]);
                     srcLastModified = src.lastModified();
                     //Check to see if dest file has to be recreated
                     boolean needsWork = forceOverwrite
                         || destLastModified < srcLastModified;
                     if (!needsWork) {
                         for (int icounter = 0; icounter < BUNDLE_MAX_ALTERNATIVES; icounter++) {
                             needsWork = (destLastModified < bundleLastModified[icounter]);
                             if (needsWork) {
                                 break;
                             }
                         }
                     }
                     if (needsWork) {
                         log("Processing " + srcFiles[j],
                             Project.MSG_DEBUG);
                         translateOneFile(src, dest);
                         ++filesProcessed;
                     } else {
                         log("Skipping " + srcFiles[j]
                             + " as destination file is up to date",
                             Project.MSG_VERBOSE);
                     }
                 } catch (IOException ioe) {
                     throw new BuildException(ioe.getMessage(), getLocation());
                 }
             }
         }
         log("Translation performed on " + filesProcessed + " file(s).", Project.MSG_DEBUG);
     }
 
     private void translateOneFile(File src, File dest) throws IOException {
         BufferedWriter out = null;
         BufferedReader in = null;
         try {
             FileOutputStream fos = new FileOutputStream(dest);
             out = new BufferedWriter(new OutputStreamWriter(fos, destEncoding));
             FileInputStream fis = new FileInputStream(src);
             in = new BufferedReader(new InputStreamReader(fis, srcEncoding));
             String line;
             LineTokenizer lineTokenizer = new LineTokenizer();
             lineTokenizer.setIncludeDelims(true);
             line = lineTokenizer.getToken(in);
             while ((line) != null) {
                 // 2003-02-21 new replace algorithm by tbee (tbee@tbee.org)
                 // because it wasn't able to replace something like "@aaa;@bbb;"
 
                 // is there a startToken
                 // and there is still stuff following the startToken
                 int startIndex = line.indexOf(startToken);
                 while (startIndex >= 0
                        && (startIndex + startToken.length()) <= line.length()) {
                     // the new value, this needs to be here
                     // because it is required to calculate the next position to
                     // search from at the end of the loop
                     String replace = null;
 
                     // we found a starttoken, is there an endtoken following?
                     // start at token+tokenlength because start and end
                     // token may be indentical
                     int endIndex = line.indexOf(endToken, startIndex
                                                 + startToken.length());
                     if (endIndex < 0) {
                         startIndex += 1;
                     } else {
                         // grab the token
                         String token = line.substring(startIndex
                                                       + startToken.length(),
                                                       endIndex);
 
                         // If there is a white space or = or :, then
                         // it isn't to be treated as a valid key.
                         boolean validToken = true;
                         for (int k = 0; k < token.length() && validToken; k++) {
                             char c = token.charAt(k);
                             if (c == ':' || c == '='
                                 || Character.isSpaceChar(c)) {
                                 validToken = false;
                             }
                         }
                         if (!validToken) {
                             startIndex += 1;
                         } else {
                             // find the replace string
                             if (resourceMap.containsKey(token)) {
                                 replace = (String) resourceMap.get(token);
                             } else {
                                 log("Replacement string missing for: " + token,
                                     Project.MSG_VERBOSE);
                                 replace = startToken + token + endToken;
                             }
 
 
                             // generate the new line
                             line = line.substring(0, startIndex) + replace
                                 + line.substring(endIndex + endToken.length());
 
                             // set start position for next search
                             startIndex += replace.length();
                         }
                     }
 
                     // find next starttoken
                     startIndex = line.indexOf(startToken, startIndex);
                 }
                 out.write(line);
                 line = lineTokenizer.getToken(in);
             }
         } finally {
             FileUtils.close(in);
             FileUtils.close(out);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/image/Image.java b/src/main/org/apache/tools/ant/taskdefs/optional/image/Image.java
index 4b05c5b11..1b05751da 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/image/Image.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/image/Image.java
@@ -1,418 +1,420 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.image;
 
 import com.sun.media.jai.codec.FileSeekableStream;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.Mapper;
 import org.apache.tools.ant.types.optional.image.Draw;
 import org.apache.tools.ant.types.optional.image.ImageOperation;
 import org.apache.tools.ant.types.optional.image.Rotate;
 import org.apache.tools.ant.types.optional.image.Scale;
 import org.apache.tools.ant.types.optional.image.TransformOperation;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.IdentityMapper;
 
 import javax.media.jai.JAI;
 import javax.media.jai.PlanarImage;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.Vector;
 
 /**
  * A MatchingTask which relies on <a
  * href="http://java.sun.com/products/java-media/jai">JAI (Java
  * Advanced Imaging)</a> to perform image manipulation operations on
  * existing images.  The operations are represented as ImageOperation
  * DataType objects.  The operations are arranged to conform to the
  * Chaining Model of JAI.  Check out the <a
  * href="http://java.sun.com/products/java-media/jai/forDevelopers/jai1_0_1guide-unc/">
  * JAI Programming Guide</a>.
  *
  * @see org.apache.tools.ant.types.optional.image.ImageOperation
  * @see org.apache.tools.ant.types.DataType
  */
 public class Image extends MatchingTask {
     // CheckStyle:VisibilityModifier OFF - bc
     protected Vector instructions = new Vector();
     protected boolean overwrite = false;
     protected Vector filesets = new Vector();
     protected File srcDir = null;
     protected File destDir = null;
 
     // CheckStyle:MemberNameCheck OFF - bc
 
     //cannot remove underscores due to protected visibility >:(
     protected String str_encoding = "JPEG";
     protected boolean garbage_collect = false;
 
     private boolean failonerror = true;
 
     // CheckStyle:MemberNameCheck ON
 
     // CheckStyle:VisibilityModifier ON
 
     private Mapper mapperElement = null;
 
     /**
      * Add a set of files to be deleted.
      * @param set the FileSet to add.
      */
     public void addFileset(FileSet set) {
         filesets.addElement(set);
     }
 
     /**
      * Set whether to fail on error.
      * If false, note errors to the output but keep going.
      * @param failonerror true or false.
      */
     public void setFailOnError(boolean failonerror) {
         this.failonerror = failonerror;
     }
 
     /**
      * Set the source dir to find the image files.
      * @param srcDir the directory in which the image files reside.
      */
     public void setSrcdir(File srcDir) {
         this.srcDir = srcDir;
     }
 
     /**
      * Set the image encoding type.  <a
      * href="http://java.sun.com/products/java-media/jai/forDevelopers/jai1_0_1guide-unc/Encode.doc.html#56610">
      * See this table in the JAI Programming Guide</a>.
      * @param encoding the String image encoding.
      */
     public void setEncoding(String encoding) {
         str_encoding = encoding;
     }
 
     /**
      * Set whether to overwrite a file if there is a naming conflict.
      * @param overwrite whether to overwrite.
      */
     public void setOverwrite(boolean overwrite) {
         this.overwrite = overwrite;
     }
 
     /**
      * Set whether to invoke Garbage Collection after each image processed.
      * Defaults to false.
      * @param gc whether to invoke the garbage collector.
      */
     public void setGc(boolean gc) {
         garbage_collect = gc;
     }
 
     /**
      * Set the destination directory for manipulated images.
      * @param destDir The destination directory.
      */
     public void setDestDir(File destDir) {
         this.destDir = destDir;
     }
 
     /**
      * Add an ImageOperation to chain.
      * @param instr The ImageOperation to append to the chain.
      */
     public void addImageOperation(ImageOperation instr) {
         instructions.add(instr);
     }
 
     /**
      * Add a Rotate ImageOperation to the chain.
      * @param instr The Rotate operation to add to the chain.
      * @see org.apache.tools.ant.types.optional.image.Rotate
      */
     public void addRotate(Rotate instr) {
         instructions.add(instr);
     }
 
     /**
      * Add a Scale ImageOperation to the chain.
      * @param instr The Scale operation to add to the chain.
      * @see org.apache.tools.ant.types.optional.image.Scale
      */
     public void addScale(Scale instr) {
         instructions.add(instr);
     }
 
     /**
      * Add a Draw ImageOperation to the chain.  DrawOperation
      * DataType objects can be nested inside the Draw object.
      * @param instr The Draw operation to add to the chain.
      * @see org.apache.tools.ant.types.optional.image.Draw
      * @see org.apache.tools.ant.types.optional.image.DrawOperation
      */
     public void addDraw(Draw instr) {
         instructions.add(instr);
     }
 
     /**
     * Add an ImageOperation to chain.
     * @param instr The ImageOperation to append to the chain.
     * @since Ant 1.7
     */
     public void add(ImageOperation instr) {
         addImageOperation(instr);
     }
 
     /**
      * Defines the mapper to map source to destination files.
      * @return a mapper to be configured
      * @exception BuildException if more than one mapper is defined
      * @since Ant 1.8.0
      */
     public Mapper createMapper() throws BuildException {
         if (mapperElement != null) {
             throw new BuildException("Cannot define more than one mapper",
                                      getLocation());
         }
         mapperElement = new Mapper(getProject());
         return mapperElement;
     }
 
     /**
      * Add a nested filenamemapper.
      * @param fileNameMapper the mapper to add.
      * @since Ant 1.8.0
      */
     public void add(FileNameMapper fileNameMapper) {
         createMapper().add(fileNameMapper);
     }
 
     /**
      * Executes all the chained ImageOperations on the files inside
      * the directory.
      * @since Ant 1.8.0
      */
     public int processDir(final File srcDir, final String srcNames[],
                           final File dstDir, final FileNameMapper mapper) {
         int writeCount = 0;
 
         for (int i = 0; i < srcNames.length; ++i) {
             final String srcName = srcNames[i];
             final File srcFile = new File(srcDir, srcName).getAbsoluteFile();
 
             final String[] dstNames = mapper.mapFileName(srcName);
             if (dstNames == null) {
                 log(srcFile + " skipped, don't know how to handle it",
                     Project.MSG_VERBOSE);
                 continue;
             }
 
             for (int j = 0; j < dstNames.length; ++j){
 
                 final String dstName = dstNames[j];
                 final File dstFile = new File(dstDir, dstName).getAbsoluteFile();
 
                 if (dstFile.exists()){
                     // avoid overwriting unless necessary
                     if(!overwrite
                        && srcFile.lastModified() <= dstFile.lastModified()) {
 
                         log(srcFile + " omitted as " + dstFile
                             + " is up to date.", Project.MSG_VERBOSE);
 
                         // don't overwrite the file
                         continue;
                     }
 
                     // avoid extra work while overwriting
                     if (!srcFile.equals(dstFile)){
                         dstFile.delete();
                     }
                 }
                 processFile(srcFile, dstFile);
                 ++writeCount;
             }
         }
 
         // run the garbage collector if wanted
         if (garbage_collect) {
             System.gc();
         }
 
         return writeCount;
     }
 
     /**
      * Executes all the chained ImageOperations on the file
      * specified.
      * @param file The file to be processed.
      * @deprecated this method isn't used anymore
      */
     public void processFile(File file) {
         processFile(file, new File(destDir == null
                                    ? srcDir : destDir, file.getName()));
     }
 
     /**
      * Executes all the chained ImageOperations on the file
      * specified.
      * @param file The file to be processed.
      * @param newFile The file to write to.
      * @since Ant 1.8.0
      */
     public void processFile(File file, File newFile) {
         try {
             log("Processing File: " + file.getAbsolutePath());
 
             FileSeekableStream input = null;
             PlanarImage image = null;
             try {
                 input = new FileSeekableStream(file);
                 image = JAI.create("stream", input);
-                for (int i = 0; i < instructions.size(); i++) {
+                final int size = instructions.size();
+                for (int i = 0; i < size; i++) {
                     Object instr = instructions.elementAt(i);
                     if (instr instanceof TransformOperation) {
                         image = ((TransformOperation) instr)
                             .executeTransformOperation(image);
                     } else {
                         log("Not a TransformOperation: " + instr);
                     }
                 }
             } finally {
                 FileUtils.close(input);
             }
 
             File dstParent = newFile.getParentFile();
             if (!dstParent.isDirectory() && !dstParent.mkdirs()){
                 throw new BuildException("Failed to create parent directory "
                                          + dstParent);
             }
 
             if ((overwrite && newFile.exists()) && (!newFile.equals(file))) {
                 newFile.delete();
             }
 
             FileOutputStream stream = null;
             try {
                 stream = new FileOutputStream(newFile);
 
                 JAI.create("encode", image, stream,
                            str_encoding.toUpperCase(Locale.ENGLISH),
                            null);
                 stream.flush();
             } finally {
                 FileUtils.close(stream);
             }
         } catch (IOException err) {
             if (!file.equals(newFile)){
                 newFile.delete();
             }
             if (!failonerror) {
                 log("Error processing file:  " + err);
             } else {
                 throw new BuildException(err);
             }
         } catch (java.lang.RuntimeException rerr) {
             if (!file.equals(newFile)){
                 newFile.delete();
             }
             if (!failonerror) {
                 log("Error processing file:  " + rerr);
             } else {
                 throw new BuildException(rerr);
             }
         }
     }
 
     /**
      * Executes the Task.
      * @throws BuildException on error.
      */
     public void execute() throws BuildException {
 
         validateAttributes();
 
         try {
             File dest = destDir != null ? destDir : srcDir;
 
             int writeCount = 0;
 
             // build mapper
             final FileNameMapper mapper;
             if (mapperElement==null){
                 mapper = new IdentityMapper();
             } else {
                 mapper = mapperElement.getImplementation();
             }
 
             // deal with specified srcDir
             if (srcDir != null) {
                 final DirectoryScanner ds = super.getDirectoryScanner(srcDir);
 
                 final String[] files = ds.getIncludedFiles();
                 writeCount += processDir(srcDir, files, dest, mapper);
             }
             // deal with the filesets
-            for (int i = 0; i < filesets.size(); i++) {
+            final int size = filesets.size();
+            for (int i = 0; i < size; i++) {
                 final FileSet fs = (FileSet) filesets.elementAt(i);
                 final DirectoryScanner ds =
                     fs.getDirectoryScanner(getProject());
                 final String[] files = ds.getIncludedFiles();
                 final File fromDir = fs.getDir(getProject());
                 writeCount += processDir(fromDir, files, dest, mapper);
             }
 
             if (writeCount>0){
                 log("Processed " + writeCount +
                     (writeCount == 1 ? " image." : " images."));
             }
 
         } catch (Exception err) {
             err.printStackTrace();
             throw new BuildException(err.getMessage());
         }
     }
 
     /**
      * Ensure we have a consistent and legal set of attributes, and set
      * any internal flags necessary based on different combinations
      * of attributes.
      * @throws BuildException on error.
      */
     protected void validateAttributes() throws BuildException {
         if (srcDir == null && filesets.size() == 0) {
             throw new BuildException("Specify at least one source"
                                      + "--a srcDir or a fileset.");
         }
         if (srcDir == null && destDir == null) {
             throw new BuildException("Specify the destDir, or the srcDir.");
         }
         if (str_encoding.equalsIgnoreCase("jpg")) {
             str_encoding = "JPEG";
         } else if (str_encoding.equalsIgnoreCase("tif")) {
             str_encoding = "TIFF";
         }
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/jsp/WLJspc.java b/src/main/org/apache/tools/ant/taskdefs/optional/jsp/WLJspc.java
index d4b65880b..e0faf8ca3 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/jsp/WLJspc.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/jsp/WLJspc.java
@@ -1,332 +1,333 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.jsp;
 
 //apache/ant imports
 import java.io.File;
 import java.util.Date;
 import java.util.StringTokenizer;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.Java;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.types.Path;
 
 /**
  * Precompiles JSP's using WebLogic's JSP compiler (weblogic.jspc).
  *
  * Tested only on Weblogic 4.5.1 - NT4.0 and Solaris 5.7
  *
  * required attributes
  *      src : root of source tree for JSP, ie, the document root for your weblogic server
  *      dest : root of destination directory, what you have set as
  *             WorkingDir in the weblogic properties
  *      package : start package name under which your JSP's would be compiled
  *
  * other attributes
  *     classpath
  *
  * A classpath should be set which contains the weblogic classes as well as all
  * application classes referenced by the JSP. The system classpath is also
  * appended when the jspc is called, so you may choose to put everything in
  * the classpath while calling Ant. However, since presumably the JSP's will
  * reference classes being build by Ant, it would be better to explicitly add
  * the classpath in the task
  *
  * The task checks timestamps on the JSP's and the generated classes, and compiles
  * only those files that have changed.
  *
  * It follows the weblogic naming convention of putting classes in
  *  <b> _dirName/_fileName.class for dirname/fileName.jsp   </b>
  *
  * Limitation: It compiles the files thru the Classic compiler only.
  * Limitation: Since it is my experience that weblogic jspc throws out of
  *             memory error on being given too many files at one go, it is
  *             called multiple times with one jsp file each.
  *
  * <pre>
  * example
  * &lt;target name="jspcompile" depends="compile"&gt;
  *   &lt;wljspc src="c:\\weblogic\\myserver\\public_html"
  *           dest="c:\\weblogic\\myserver\\serverclasses" package="myapp.jsp"&gt;
  *   &lt;classpath&gt;
  *          &lt;pathelement location="${weblogic.classpath}" /&gt;
  *           &lt;pathelement path="${compile.dest}" /&gt;
  *      &lt;/classpath&gt;
  *
  *   &lt;/wljspc&gt;
  * &lt;/target&gt;
  * </pre>
  *
  */
 
 public class WLJspc extends MatchingTask {
     //TODO Test on other versions of weblogic
     //TODO add more attributes to the task, to take care of all jspc options
     //TODO Test on Unix
 
     /** root of compiled files tree */
     private File destinationDirectory;
 
     /** root of source files tree */
     private File sourceDirectory;
 
     /** package under which resultant classes will reside */
     private String destinationPackage;
 
     /** classpath used to compile the jsp files. */
     private Path compileClasspath;
 
     //private String compilerPath; //fully qualified name for the compiler executable
 
     private String pathToPackage = "";
     private Vector filesToDo = new Vector();
 
     /**
      * Run the task.
      * @throws BuildException if there is an error.
      */
     public void execute() throws BuildException {
         if (!destinationDirectory.isDirectory()) {
             throw new BuildException("destination directory "
                 + destinationDirectory.getPath() + " is not valid");
         }
 
         if (!sourceDirectory.isDirectory()) {
             throw new BuildException("src directory "
                 + sourceDirectory.getPath() + " is not valid");
         }
 
         if (destinationPackage == null) {
             throw new BuildException("package attribute must be present.",
                                      getLocation());
         }
 
 
         pathToPackage
             = this.destinationPackage.replace('.', File.separatorChar);
         // get all the files in the sourceDirectory
         DirectoryScanner ds = super.getDirectoryScanner(sourceDirectory);
 
         //use the systemclasspath as well, to include the ant jar
         if (compileClasspath == null) {
             compileClasspath = new Path(getProject());
         }
 
         compileClasspath = compileClasspath.concatSystemClasspath();
         String[] files = ds.getIncludedFiles();
 
         //Weblogic.jspc calls System.exit() ... have to fork
         // Therefore, takes loads of time
         // Can pass directories at a time (*.jsp) but easily runs out of
         // memory on hefty dirs (even on  a Sun)
         Java helperTask = new Java(this);
         helperTask.setFork(true);
         helperTask.setClassname("weblogic.jspc");
         helperTask.setTaskName(getTaskName());
         // CheckStyle:MagicNumber OFF
         String[] args = new String[12];
         // CheckStyle:MagicNumber ON
 
         File jspFile = null;
         String parents = "";
         int j = 0;
         //XXX  this array stuff is a remnant of prev trials.. gotta remove.
         args[j++] = "-d";
         args[j++] = destinationDirectory.getAbsolutePath().trim();
         args[j++] = "-docroot";
         args[j++] = sourceDirectory.getAbsolutePath().trim();
         args[j++] = "-keepgenerated";
         //Call compiler as class... dont want to fork again
         //Use classic compiler -- can be parameterised?
         args[j++] =  "-compilerclass";
         args[j++] = "sun.tools.javac.Main";
         //Weblogic jspc does not seem to work unless u explicitly set this...
         // Does not take the classpath from the env....
         // Am i missing something about the Java task??
         args[j++] = "-classpath";
         args[j++] = compileClasspath.toString();
 
         this.scanDir(files);
         log("Compiling " + filesToDo.size() + " JSP files");
 
-        for (int i = 0; i < filesToDo.size(); i++) {
+        final int size = filesToDo.size();
+        for (int i = 0; i < size; i++) {
             //XXX
             // All this to get package according to weblogic standards
             // Can be written better... this is too hacky!
             // Careful.. similar code in scanDir , but slightly different!!
             String filename = (String) filesToDo.elementAt(i);
             jspFile = new File(filename);
             args[j] = "-package";
             parents = jspFile.getParent();
             if ((parents != null)  && (!("").equals(parents))) {
                 parents =  this.replaceString(parents, File.separator, "_.");
                 args[j + 1] = destinationPackage + "." + "_" + parents;
             } else {
                 args[j + 1] = destinationPackage;
             }
 
 
             args[j + 2] =  sourceDirectory + File.separator + filename;
             helperTask.clearArgs();
 
             // CheckStyle:MagicNumber OFF
             for (int x = 0; x < j + 3; x++) {
                 helperTask.createArg().setValue(args[x]);
             }
             // CheckStyle:MagicNumber ON
 
             helperTask.setClasspath(compileClasspath);
             if (helperTask.executeJava() != 0) {
                 log(filename + " failed to compile", Project.MSG_WARN);
             }
         }
     }
 
 
 
     /**
      * Set the classpath to be used for this compilation.
      * @param classpath the classpath to use.
      */
     public void setClasspath(Path classpath) {
         if (compileClasspath == null) {
             compileClasspath = classpath;
         } else {
             compileClasspath.append(classpath);
         }
     }
 
     /**
      * Maybe creates a nested classpath element.
      * @return a path to be configured.
      */
     public Path createClasspath() {
         if (compileClasspath == null) {
             compileClasspath = new Path(getProject());
         }
         return compileClasspath;
     }
 
     /**
      * Set the directory containing the source jsp's
      *
      *
      * @param dirName the directory containg the source jsp's
      */
     public void setSrc(File dirName) {
 
         sourceDirectory = dirName;
     }
 
      /**
      * Set the directory containing the source jsp's
      *
      *
      * @param dirName the directory containg the source jsp's
      */
     public void setDest(File dirName) {
 
         destinationDirectory = dirName;
     }
 
     /**
      * Set the package under which the compiled classes go
      *
      * @param packageName the package name for the clases
      */
     public void setPackage(String packageName) {
 
         destinationPackage = packageName;
     }
 
     /**
      * Scan the array of files and add the jsp
      * files that need to be compiled to the filesToDo field.
      * @param files the files to scan.
      */
     protected void scanDir(String[] files) {
 
         long now = (new Date()).getTime();
         File jspFile = null;
         String parents = null;
         String pack = "";
         for (int i = 0; i < files.length; i++) {
             File srcFile = new File(this.sourceDirectory, files[i]);
             //XXX
             // All this to convert source to destination directory according
             // to weblogic standards Can be written better... this is too hacky!
             jspFile = new File(files[i]);
             parents = jspFile.getParent();
 
             if ((parents != null)  && (!("").equals(parents))) {
                 parents =  this.replaceString(parents, File.separator, "_/");
                 pack = pathToPackage + File.separator + "_" + parents;
             } else {
                 pack = pathToPackage;
             }
 
             String filePath = pack + File.separator + "_";
             int startingIndex = files[i].lastIndexOf(File.separator) != -1
                     ? files[i].lastIndexOf(File.separator) + 1 : 0;
             int endingIndex = files[i].indexOf(".jsp");
             if (endingIndex == -1) {
                 log("Skipping " + files[i] + ". Not a JSP",
                     Project.MSG_VERBOSE);
                 continue;
             }
 
             filePath += files[i].substring(startingIndex, endingIndex);
             filePath += ".class";
             File classFile = new File(this.destinationDirectory, filePath);
 
             if (srcFile.lastModified() > now) {
                 log("Warning: file modified in the future: "
                     + files[i], Project.MSG_WARN);
             }
             if (srcFile.lastModified() > classFile.lastModified()) {
                 filesToDo.addElement(files[i]);
                 log("Recompiling File " + files[i], Project.MSG_VERBOSE);
             }
         }
     }
 
 
     /**
      * Replace occurances of a string with a replacement string.
      * @param inpString the string to convert.
      * @param escapeChars the string to replace.
      * @param replaceChars the string to place.
      * @return the converted string.
      */
     protected String replaceString(String inpString, String escapeChars,
                                    String replaceChars) {
         String localString = "";
         int numTokens = 0;
         StringTokenizer st = new StringTokenizer(inpString, escapeChars, true);
         numTokens = st.countTokens();
         for (int i = 0; i < numTokens; i++) {
             String test = st.nextToken();
             test = (test.equals(escapeChars) ? replaceChars : test);
             localString += test;
         }
         return localString;
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/junit/FailureRecorder.java b/src/main/org/apache/tools/ant/taskdefs/optional/junit/FailureRecorder.java
index f51499e90..02fcac282 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/junit/FailureRecorder.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/junit/FailureRecorder.java
@@ -1,447 +1,448 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.junit;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.SortedSet;
 import java.util.TreeSet;
 import java.util.Vector;
 
 import junit.framework.AssertionFailedError;
 import junit.framework.Test;
 
 import org.apache.tools.ant.BuildEvent;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.BuildListener;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.ProjectComponent;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * <p>Collects all failing test <i>cases</i> and creates a new JUnit test class containing
  * a suite() method which calls these failed tests.</p>
  * <p>Having classes <i>A</i> ... <i>D</i> with each several testcases you could earn a new
  * test class like
  * <pre>
  * // generated on: 2007.08.06 09:42:34,555
  * import junit.framework.*;
  * public class FailedTests extends TestCase {
  *     public FailedTests(String testname) {
  *         super(testname);
  *     }
  *     public static Test suite() {
  *         TestSuite suite = new TestSuite();
  *         suite.addTest( new B("test04") );
  *         suite.addTest( new org.D("test10") );
  *         return suite;
  *     }
  * }
  * </pre>
  *
  * Because each running test case gets its own formatter, we collect
  * the failing test cases in a static list. Because we dont have a finalizer
  * method in the formatters "lifecycle", we register this formatter as
  * BuildListener and generate the new java source on taskFinished event.
  *
  * @since Ant 1.8.0
  */
 public class FailureRecorder extends ProjectComponent implements JUnitResultFormatter, BuildListener {
 
     /**
      * This is the name of a magic System property ({@value}). The value of this
      * <b>System</b> property should point to the location where to store the
      * generated class (without suffix).
      * Default location and name is defined in DEFAULT_CLASS_LOCATION.
      * @see #DEFAULT_CLASS_LOCATION
      */
     public static final String MAGIC_PROPERTY_CLASS_LOCATION
         = "ant.junit.failureCollector";
 
     /** Default location and name for the generated JUnit class file,
      *  in the temp directory + FailedTests */
     public static final String DEFAULT_CLASS_LOCATION
         = System.getProperty("java.io.tmpdir") + "FailedTests";
 
     /** Prefix for logging. {@value} */
     private static final String LOG_PREFIX = "    [junit]";
 
     /** Class names of failed tests without duplicates. */
     private static SortedSet/*<TestInfos>*/ failedTests = new TreeSet();
 
     /** A writer for writing the generated source to. */
     private BufferedWriter writer;
 
     /**
      * Location and name of the generated JUnit class.
      * Lazy instantiated via getLocationName().
      */
     private static String locationName;
 
     /**
      * Returns the (lazy evaluated) location for the collector class.
      * Order for evaluation: System property > Ant property > default value
      * @return location for the collector class
      * @see #MAGIC_PROPERTY_CLASS_LOCATION
      * @see #DEFAULT_CLASS_LOCATION
      */
     private String getLocationName() {
         if (locationName == null) {
             String syspropValue = System.getProperty(MAGIC_PROPERTY_CLASS_LOCATION);
             String antpropValue = getProject().getProperty(MAGIC_PROPERTY_CLASS_LOCATION);
 
             if (syspropValue != null) {
                 locationName = syspropValue;
                 verbose("System property '" + MAGIC_PROPERTY_CLASS_LOCATION + "' set, so use "
                         + "its value '" + syspropValue + "' as location for collector class.");
             } else if (antpropValue != null) {
                 locationName = antpropValue;
                 verbose("Ant property '" + MAGIC_PROPERTY_CLASS_LOCATION + "' set, so use "
                         + "its value '" + antpropValue + "' as location for collector class.");
             } else {
                 locationName = DEFAULT_CLASS_LOCATION;
                 verbose("System property '" + MAGIC_PROPERTY_CLASS_LOCATION + "' not set, so use "
                         + "value as location for collector class: '"
                         + DEFAULT_CLASS_LOCATION + "'");
             }
 
             File locationFile = new File(locationName);
             if (!locationFile.isAbsolute()) {
                 File f = new File(getProject().getBaseDir(), locationName);
                 locationName = f.getAbsolutePath();
                 verbose("Location file is relative (" + locationFile + ")"
                         + " use absolute path instead (" + locationName + ")");
             }
         }
 
         return locationName;
     }
 
     /**
      * This method is called by the Ant runtime by reflection. We use the project reference for
      * registration of this class as BuildListener.
      *
      * @param project
      *            project reference
      */
     public void setProject(Project project) {
         // store project reference for logging
         super.setProject(project);
         // check if already registered
         boolean alreadyRegistered = false;
         Vector allListeners = project.getBuildListeners();
-        for (int i = 0; i < allListeners.size(); i++) {
+        final int size = allListeners.size();
+        for (int i = 0; i < size; i++) {
             Object listener = allListeners.get(i);
             if (listener instanceof FailureRecorder) {
                 alreadyRegistered = true;
                 continue;
             }
         }
         // register if needed
         if (!alreadyRegistered) {
             verbose("Register FailureRecorder (@" + this.hashCode() + ") as BuildListener");
             project.addBuildListener(this);
         }
     }
 
     // ===== JUnitResultFormatter =====
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void endTestSuite(JUnitTest suite) throws BuildException {
     }
 
     /**
      * Add the failed test to the list.
      * @param test the test that errored.
      * @param throwable the reason it errored.
      * @see junit.framework.TestListener#addError(junit.framework.Test, java.lang.Throwable)
      */
     public void addError(Test test, Throwable throwable) {
         failedTests.add(new TestInfos(test));
     }
 
     // CheckStyle:LineLengthCheck OFF - @see is long
     /**
      * Add the failed test to the list.
      * @param test the test that failed.
      * @param error the assertion that failed.
      * @see junit.framework.TestListener#addFailure(junit.framework.Test, junit.framework.AssertionFailedError)
      */
     // CheckStyle:LineLengthCheck ON
     public void addFailure(Test test, AssertionFailedError error) {
         failedTests.add(new TestInfos(test));
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void setOutput(OutputStream out) {
         // unused, close output file so it can be deleted before the VM exits
         if (out != System.out) {
             FileUtils.close(out);
         }
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void setSystemError(String err) {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void setSystemOutput(String out) {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void startTestSuite(JUnitTest suite) throws BuildException {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void endTest(Test test) {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void startTest(Test test) {
     }
 
     // ===== "Templates" for generating the JUnit class =====
 
     private void writeJavaClass() {
         try {
             File sourceFile = new File((getLocationName() + ".java"));
             verbose("Write collector class to '" + sourceFile.getAbsolutePath() + "'");
 
             if (sourceFile.exists() && !sourceFile.delete()) {
                 throw new IOException("could not delete " + sourceFile);
             }
             writer = new BufferedWriter(new FileWriter(sourceFile));
 
             createClassHeader();
             createSuiteMethod();
             createClassFooter();
 
         } catch (IOException e) {
             e.printStackTrace();
         } finally {
             FileUtils.close(writer);
         }
     }
 
     private void createClassHeader() throws IOException {
         String className = getLocationName().replace('\\', '/');
         if (className.indexOf('/') > -1) {
             className = className.substring(className.lastIndexOf('/') + 1);
         }
         SimpleDateFormat sdf = new SimpleDateFormat("yyyy.MM.dd HH:mm:ss,SSS");
         writer.write("// generated on: ");
         writer.write(sdf.format(new Date()));
         writer.newLine();
         writer.write("import junit.framework.*;");
         writer.newLine();
         writer.write("public class ");
         writer.write(className);
         // If this class does not extend TC, Ant doesnt run these
         writer.write(" extends TestCase {");
         writer.newLine();
         // standard String-constructor
         writer.write("    public ");
         writer.write(className);
         writer.write("(String testname) {");
         writer.newLine();
         writer.write("        super(testname);");
         writer.newLine();
         writer.write("    }");
         writer.newLine();
     }
 
     private void createSuiteMethod() throws IOException {
         writer.write("    public static Test suite() {");
         writer.newLine();
         writer.write("        TestSuite suite = new TestSuite();");
         writer.newLine();
         for (Iterator iter = failedTests.iterator(); iter.hasNext();) {
             TestInfos testInfos = (TestInfos) iter.next();
             writer.write("        suite.addTest(");
             writer.write(String.valueOf(testInfos));
             writer.write(");");
             writer.newLine();
         }
         writer.write("        return suite;");
         writer.newLine();
         writer.write("    }");
         writer.newLine();
     }
 
     private void createClassFooter() throws IOException {
         writer.write("}");
         writer.newLine();
     }
 
     // ===== Helper classes and methods =====
 
     /**
      * Logging facade in INFO-mode.
      * @param message Log-message
      */
     public void log(String message) {
         getProject().log(LOG_PREFIX + " " + message, Project.MSG_INFO);
     }
 
     /**
      * Logging facade in VERBOSE-mode.
      * @param message Log-message
      */
     public void verbose(String message) {
         getProject().log(LOG_PREFIX + " " + message, Project.MSG_VERBOSE);
     }
 
     /**
      * TestInfos holds information about a given test for later use.
      */
     public static class TestInfos implements Comparable {
 
         /** The class name of the test. */
         private final String className;
 
         /** The method name of the testcase. */
         private final String methodName;
 
         /**
          * This constructor extracts the needed information from the given test.
          * @param test Test to analyze
          */
         public TestInfos(Test test) {
             className = test.getClass().getName();
             String _methodName = test.toString();
             methodName = _methodName.substring(0, _methodName.indexOf('('));
         }
 
         /**
          * This String-Representation can directly be used for instantiation of
          * the JUnit testcase.
          * @return the string representation.
          * @see java.lang.Object#toString()
          * @see FailureRecorder#createSuiteMethod()
          */
         public String toString() {
             return "new " + className + "(\"" + methodName + "\")";
         }
 
         /**
          * The SortedMap needs comparable elements.
          * @param other the object to compare to.
          * @return the result of the comparison.
          * @see java.lang.Comparable#compareTo
          * @see SortedSet#comparator()
          */
         public int compareTo(Object other) {
             if (other instanceof TestInfos) {
                 TestInfos otherInfos = (TestInfos) other;
                 return toString().compareTo(otherInfos.toString());
             } else {
                 return -1;
             }
         }
         public boolean equals(Object obj) {
             return obj instanceof TestInfos && toString().equals(obj.toString());
         }
         public int hashCode() {
             return toString().hashCode();
         }
     }
 
     // ===== BuildListener =====
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void buildFinished(BuildEvent event) {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void buildStarted(BuildEvent event) {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void messageLogged(BuildEvent event) {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void targetFinished(BuildEvent event) {
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void targetStarted(BuildEvent event) {
     }
 
     /**
      * The task outside of this JUnitResultFormatter is the <junit> task. So all tests passed
      * and we could create the new java class.
      * @param event  not used
      * @see org.apache.tools.ant.BuildListener#taskFinished(org.apache.tools.ant.BuildEvent)
      */
     public void taskFinished(BuildEvent event) {
         if (!failedTests.isEmpty()) {
             writeJavaClass();
         }
     }
 
     /**
      * Not used
      * {@inheritDoc}
      */
     public void taskStarted(BuildEvent event) {
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java b/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java
index efb49a15e..86f80dc4e 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/junit/JUnitTestRunner.java
@@ -1,1163 +1,1169 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.junit;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.PrintStream;
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.lang.reflect.Method;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Properties;
 import java.util.StringTokenizer;
 import java.util.Vector;
 import junit.framework.AssertionFailedError;
 import junit.framework.Test;
 import junit.framework.TestFailure;
 import junit.framework.TestListener;
 import junit.framework.TestResult;
 import junit.framework.TestSuite;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.Permissions;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.StringUtils;
 import org.apache.tools.ant.util.TeeOutputStream;
 
 /**
  * Simple Testrunner for JUnit that runs all tests of a testsuite.
  *
  * <p>This TestRunner expects a name of a TestCase class as its
  * argument. If this class provides a static suite() method it will be
  * called and the resulting Test will be run. So, the signature should be
  * <pre><code>
  *     public static junit.framework.Test suite()
  * </code></pre>
  *
  * <p> If no such method exists, all public methods starting with
  * "test" and taking no argument will be run.
  *
  * <p> Summary output is generated at the end.
  *
  * @since Ant 1.2
  */
 
 public class JUnitTestRunner implements TestListener, JUnitTaskMirror.JUnitTestRunnerMirror {
 
     /**
      * Holds the registered formatters.
      */
     private Vector formatters = new Vector();
 
     /**
      * Collects TestResults.
      */
     private TestResult res;
 
     /**
      * Do we filter junit.*.* stack frames out of failure and error exceptions.
      */
     private static boolean filtertrace = true;
 
     /**
      * Do we send output to System.out/.err in addition to the formatters?
      */
     private boolean showOutput = false;
 
     private boolean outputToFormatters = true;
 
     /**
      * The permissions set for the test to run.
      */
     private Permissions perm = null;
 
     private static final String JUNIT_4_TEST_ADAPTER
         = "junit.framework.JUnit4TestAdapter";
 
     private static final String[] DEFAULT_TRACE_FILTERS = new String[] {
                 "junit.framework.TestCase",
                 "junit.framework.TestResult",
                 "junit.framework.TestSuite",
                 "junit.framework.Assert.", // don't filter AssertionFailure
                 "junit.swingui.TestRunner",
                 "junit.awtui.TestRunner",
                 "junit.textui.TestRunner",
                 "java.lang.reflect.Method.invoke(",
                 "sun.reflect.",
                 "org.apache.tools.ant.",
                 // JUnit 4 support:
                 "org.junit.",
                 "junit.framework.JUnit4TestAdapter",
                 " more",
         };
 
 
     /**
      * Do we stop on errors.
      */
     private boolean haltOnError = false;
 
     /**
      * Do we stop on test failures.
      */
     private boolean haltOnFailure = false;
 
     /**
      * Returncode
      */
     private int retCode = SUCCESS;
 
     /**
      * The TestSuite we are currently running.
      */
     private JUnitTest junitTest;
 
     /** output written during the test */
     private PrintStream systemError;
 
     /** Error output during the test */
     private PrintStream systemOut;
 
     /** is this runner running in forked mode? */
     private boolean forked = false;
 
     /** Running more than one test suite? */
     private static boolean multipleTests = false;
 
     /** ClassLoader passed in in non-forked mode. */
     private ClassLoader loader;
 
     /** Do we print TestListener events? */
     private boolean logTestListenerEvents = false;
 
     /** Turned on if we are using JUnit 4 for this test suite. see #38811 */
     private boolean junit4;
 
     /**
      * The file used to indicate that the build crashed.
      * File will be empty in case the build did not crash.
      */
     private static String crashFile = null;
 
     /** Names of test methods to execute */
     private String[] methods = null;
     
     /**
      * Constructor for fork=true or when the user hasn't specified a
      * classpath.
      * @param test the test to run.
      * @param haltOnError whether to stop the run if an error is found.
      * @param filtertrace whether to filter junit.*.* stack frames out of exceptions
      * @param haltOnFailure whether to stop the run if failure is found.
      */
     public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure) {
         this(test, haltOnError, filtertrace, haltOnFailure, false);
     }
 
     /**
      * Constructor for fork=true or when the user hasn't specified a
      * classpath.
      * @param test the test to run.
      * @param haltOnError whether to stop the run if an error is found.
      * @param filtertrace whether to filter junit.*.* stack frames out of exceptions
      * @param haltOnFailure whether to stop the run if failure is found.
      * @param showOutput    whether to send output to System.out/.err as well as formatters.
      */
     public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure,
                            boolean showOutput) {
         this(test, haltOnError, filtertrace, haltOnFailure, showOutput, false);
     }
 
     /**
      * Constructor for fork=true or when the user hasn't specified a
      * classpath.
      * @param test the test to run.
      * @param haltOnError whether to stop the run if an error is found.
      * @param filtertrace whether to filter junit.*.* stack frames out of exceptions
      * @param haltOnFailure whether to stop the run if failure is found.
      * @param showOutput    whether to send output to System.out/.err as well as formatters.
      * @param logTestListenerEvents whether to print TestListener events.
      * @since Ant 1.7
      */
     public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure,
                            boolean showOutput, boolean logTestListenerEvents) {
         this(test, null, haltOnError, filtertrace, haltOnFailure, showOutput,
              logTestListenerEvents, null);
     }
 
     /**
      * Constructor for fork=true or when the user hasn't specified a
      * classpath.
      * @param test the test to run.
      * @param methods names of methods of the test to be executed.
      * @param haltOnError whether to stop the run if an error is found.
      * @param filtertrace whether to filter junit.*.* stack frames out of exceptions
      * @param haltOnFailure whether to stop the run if failure is found.
      * @param showOutput    whether to send output to System.out/.err as well as formatters.
      * @param logTestListenerEvents whether to print TestListener events.
      * @since 1.8.2
      */
     public JUnitTestRunner(JUnitTest test, String[] methods, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure,
                            boolean showOutput, boolean logTestListenerEvents) {
         this(test, methods, haltOnError, filtertrace, haltOnFailure, showOutput,
              logTestListenerEvents, null);
     }
 
     /**
      * Constructor to use when the user has specified a classpath.
      * @param test the test to run.
      * @param haltOnError whether to stop the run if an error is found.
      * @param filtertrace whether to filter junit.*.* stack frames out of exceptions
      * @param haltOnFailure whether to stop the run if failure is found.
      * @param loader the classloader to use running the test.
      */
     public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure,
                            ClassLoader loader) {
         this(test, haltOnError, filtertrace, haltOnFailure, false, loader);
     }
 
     /**
      * Constructor to use when the user has specified a classpath.
      * @param test the test to run.
      * @param haltOnError whether to stop the run if an error is found.
      * @param filtertrace whether to filter junit.*.* stack frames out of exceptions
      * @param haltOnFailure whether to stop the run if failure is found.
      * @param showOutput    whether to send output to System.out/.err as well as formatters.
      * @param loader the classloader to use running the test.
      */
     public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure,
                            boolean showOutput, ClassLoader loader) {
         this(test, haltOnError, filtertrace, haltOnFailure, showOutput,
              false, loader);
     }
 
     /**
      * Constructor to use when the user has specified a classpath.
      * @param test the test to run.
      * @param haltOnError whether to stop the run if an error is found.
      * @param filtertrace whether to filter junit.*.* stack frames out of exceptions
      * @param haltOnFailure whether to stop the run if failure is found.
      * @param showOutput    whether to send output to System.out/.err as well as formatters.
      * @param logTestListenerEvents whether to print TestListener events.
      * @param loader the classloader to use running the test.
      * @since Ant 1.7
      */
     public JUnitTestRunner(JUnitTest test, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure,
                            boolean showOutput, boolean logTestListenerEvents,
                            ClassLoader loader) {
         this(test, null, haltOnError, filtertrace, haltOnFailure, showOutput, 
              logTestListenerEvents, loader);
     }
 
 
     /**
      * Constructor to use when the user has specified a classpath.
      * @since 1.8.2
      */
     public JUnitTestRunner(JUnitTest test, String[] methods, boolean haltOnError,
                            boolean filtertrace, boolean haltOnFailure,
                            boolean showOutput, boolean logTestListenerEvents,
                            ClassLoader loader) {
         JUnitTestRunner.filtertrace = filtertrace; // XXX clumsy, should use instance field somehow
         this.junitTest = test;
         this.haltOnError = haltOnError;
         this.haltOnFailure = haltOnFailure;
         this.showOutput = showOutput;
         this.logTestListenerEvents = logTestListenerEvents;
         this.methods = methods != null ? (String[]) methods.clone() : null;
         this.loader = loader;
     }
 
     private PrintStream savedOut = null;
     private PrintStream savedErr = null;
 
     private PrintStream createEmptyStream() {
         return new PrintStream(
             new OutputStream() {
                 public void write(int b) {
                 }
             });
     }
 
     private PrintStream createTeePrint(PrintStream ps1, PrintStream ps2) {
         return new PrintStream(new TeeOutputStream(ps1, ps2));
     }
 
     private void setupIOStreams(ByteArrayOutputStream o,
                                 ByteArrayOutputStream e) {
         systemOut = new PrintStream(o);
         systemError = new PrintStream(e);
 
         if (forked) {
             if (!outputToFormatters) {
                 if (!showOutput) {
                     savedOut = System.out;
                     savedErr = System.err;
                     System.setOut(createEmptyStream());
                     System.setErr(createEmptyStream());
                 }
             } else {
                 savedOut = System.out;
                 savedErr = System.err;
                 if (!showOutput) {
                     System.setOut(systemOut);
                     System.setErr(systemError);
                 } else {
                     System.setOut(createTeePrint(savedOut, systemOut));
                     System.setErr(createTeePrint(savedErr, systemError));
                 }
                 perm = null;
             }
         } else {
             if (perm != null) {
                 perm.setSecurityManager();
             }
         }
     }
 
     /**
      * Run the test.
      */
     public void run() {
         res = new TestResult();
         res.addListener(wrapListener(this));
-        for (int i = 0; i < formatters.size(); i++) {
+        final int size = formatters.size();
+        for (int i = 0; i < size; i++) {
             res.addListener(wrapListener((TestListener) formatters.elementAt(i)));
         }
 
         ByteArrayOutputStream errStrm = new ByteArrayOutputStream();
         ByteArrayOutputStream outStrm = new ByteArrayOutputStream();
 
         setupIOStreams(outStrm, errStrm);
 
         Test suite = null;
         Throwable exception = null;
         boolean startTestSuiteSuccess = false;
 
         try {
 
             try {
                 Class testClass = null;
                 if (loader == null) {
                     testClass = Class.forName(junitTest.getName());
                 } else {
                     testClass = Class.forName(junitTest.getName(), true,
                                               loader);
                 }
 
                 final boolean testMethodsSpecified = (methods != null);
 
                 // check for a static suite method first, even when using
                 // JUnit 4
                 Method suiteMethod = null;
                 if (!testMethodsSpecified) {
                 try {
                     // check if there is a suite method
                     suiteMethod = testClass.getMethod("suite", new Class[0]);
                 } catch (NoSuchMethodException e) {
                     // no appropriate suite method found. We don't report any
                     // error here since it might be perfectly normal.
                 }
                 }
 
                 if (suiteMethod != null) {
                     // if there is a suite method available, then try
                     // to extract the suite from it. If there is an error
                     // here it will be caught below and reported.
                     suite = (Test) suiteMethod.invoke(null, new Class[0]);
 
                 } else {
                     Class junit4TestAdapterClass = null;
                     boolean useSingleMethodAdapter = false;
 
                     if (junit.framework.TestCase.class.isAssignableFrom(testClass)) {
                         // Do not use JUnit 4 API for running JUnit 3.x
                         // tests - it is not able to run individual test
                         // methods.
                         //
                         // Technical details:
                         // org.junit.runner.Request.method(Class, String).getRunner()
                         // would return a runner which always executes all
                         // test methods. The reason is that the Runner would be
                         // an instance of class
                         // org.junit.internal.runners.OldTestClassRunner
                         // that does not implement interface Filterable - so it
                         // is unable to filter out test methods not matching
                         // the requested name.
                     } else {
                     // Check for JDK 5 first. Will *not* help on JDK 1.4
                     // if only junit-4.0.jar in CP because in that case
                     // linkage of whole task will already have failed! But
                     // will help if CP has junit-3.8.2.jar:junit-4.0.jar.
 
                     // In that case first C.fN will fail with CNFE and we
                     // will avoid UnsupportedClassVersionError.
 
                     try {
                         Class.forName("java.lang.annotation.Annotation");
                         if (loader == null) {
                             junit4TestAdapterClass =
                                 Class.forName(JUNIT_4_TEST_ADAPTER);
                             if (testMethodsSpecified) {
                                 /*
                                  * We cannot try to load the JUnit4TestAdapter
                                  * before trying to load JUnit4TestMethodAdapter
                                  * because it might fail with
                                  * NoClassDefFoundException, instead of plain
                                  * ClassNotFoundException.
                                  */
                                 junit4TestAdapterClass = Class.forName(
                                     "org.apache.tools.ant.taskdefs.optional.junit.JUnit4TestMethodAdapter");
                                 useSingleMethodAdapter = true;
                             }
                         } else {
                             junit4TestAdapterClass =
                                 Class.forName(JUNIT_4_TEST_ADAPTER,
                                               true, loader);
                             if (testMethodsSpecified) {
                                 junit4TestAdapterClass =
                                     Class.forName(
                                         "org.apache.tools.ant.taskdefs.optional.junit.JUnit4TestMethodAdapter",
                                         true, loader);
                                 useSingleMethodAdapter = true;
                             }
                         }
                     } catch (ClassNotFoundException e) {
                         // OK, fall back to JUnit 3.
                     }
                     }
                     junit4 = junit4TestAdapterClass != null;
 
                     if (junit4) {
                         // Let's use it!
                         Class[] formalParams;
                         Object[] actualParams;
                         if (useSingleMethodAdapter) {
                             formalParams = new Class[] {Class.class, String[].class};
                             actualParams = new Object[] {testClass, methods};
                         } else {
                             formalParams = new Class[] {Class.class};
                             actualParams = new Object[] {testClass};
                         }
                         suite =
                             (Test) junit4TestAdapterClass
                             .getConstructor(formalParams).
                             newInstance(actualParams);
                     } else {
                         // Use JUnit 3.
 
                         // try to extract a test suite automatically this
                         // will generate warnings if the class is no
                         // suitable Test
                         if (!testMethodsSpecified) {
                             suite = new TestSuite(testClass);
                         } else if (methods.length == 1) {
                             suite = TestSuite.createTest(testClass, methods[0]);
                         } else {
                             TestSuite testSuite = new TestSuite(testClass.getName());
                             for (int i = 0; i < methods.length; i++) {
                                 testSuite.addTest(
                                     TestSuite.createTest(testClass, methods[i]));
                             }
                             suite = testSuite;
                         }
                     }
 
                 }
 
             } catch (Throwable e) {
                 retCode = ERRORS;
                 exception = e;
             }
 
             long start = System.currentTimeMillis();
 
             fireStartTestSuite();
             startTestSuiteSuccess = true;
             if (exception != null) { // had an exception constructing suite
-                for (int i = 0; i < formatters.size(); i++) {
+                final int formatterSize = formatters.size();
+                for (int i = 0; i < formatterSize; i++) {
                     ((TestListener) formatters.elementAt(i))
                         .addError(null, exception);
                 }
                 junitTest.setCounts(1, 0, 1);
                 junitTest.setRunTime(0);
             } else {
                 try {
                     logTestListenerEvent("tests to run: " + suite.countTestCases());
                     suite.run(res);
                 } finally {
                     if (junit4 ||
                         suite.getClass().getName().equals(JUNIT_4_TEST_ADAPTER)) {
                         int[] cnts = findJUnit4FailureErrorCount(res);
                         junitTest.setCounts(res.runCount(), cnts[0], cnts[1]);
                     } else {
                         junitTest.setCounts(res.runCount(), res.failureCount(),
                                 res.errorCount());
                     }
                     junitTest.setRunTime(System.currentTimeMillis() - start);
                 }
             }
         } finally {
             if (perm != null) {
                 perm.restoreSecurityManager();
             }
             if (savedOut != null) {
                 System.setOut(savedOut);
             }
             if (savedErr != null) {
                 System.setErr(savedErr);
             }
 
             systemError.close();
             systemError = null;
             systemOut.close();
             systemOut = null;
             if (startTestSuiteSuccess) {
                 sendOutAndErr(new String(outStrm.toByteArray()),
                               new String(errStrm.toByteArray()));
             }
         }
         fireEndTestSuite();
 
         // junitTest has the correct counts for JUnit4, while res doesn't
         if (retCode != SUCCESS || junitTest.errorCount() != 0) {
             retCode = ERRORS;
         } else if (junitTest.failureCount() != 0) {
             retCode = FAILURES;
         }
     }
 
     /**
      * Returns what System.exit() would return in the standalone version.
      *
      * @return 2 if errors occurred, 1 if tests failed else 0.
      */
     public int getRetCode() {
         return retCode;
     }
 
     /**
      * Interface TestListener.
      *
      * <p>A new Test is started.
      * @param t the test.
      */
     public void startTest(Test t) {
         String testName = JUnitVersionHelper.getTestCaseName(t);
         logTestListenerEvent("startTest(" + testName + ")");
     }
 
     /**
      * Interface TestListener.
      *
      * <p>A Test is finished.
      * @param test the test.
      */
     public void endTest(Test test) {
         String testName = JUnitVersionHelper.getTestCaseName(test);
         logTestListenerEvent("endTest(" + testName + ")");
     }
 
     private void logTestListenerEvent(String msg) {
         if (logTestListenerEvents) {
             PrintStream out = savedOut != null ? savedOut : System.out;
             out.flush();
             if (msg == null) {
                 msg = "null";
             }
             StringTokenizer msgLines = new StringTokenizer(msg, "\r\n", false);
             while (msgLines.hasMoreTokens()) {
                 out.println(JUnitTask.TESTLISTENER_PREFIX
                             + msgLines.nextToken());
             }
             out.flush();
         }
     }
 
     /**
      * Interface TestListener for JUnit &lt;= 3.4.
      *
      * <p>A Test failed.
      * @param test the test.
      * @param t    the exception thrown by the test.
      */
     public void addFailure(Test test, Throwable t) {
         String testName = JUnitVersionHelper.getTestCaseName(test);
         logTestListenerEvent("addFailure(" + testName + ", " + t.getMessage() + ")");
         if (haltOnFailure) {
             res.stop();
         }
     }
 
     /**
      * Interface TestListener for JUnit &gt; 3.4.
      *
      * <p>A Test failed.
      * @param test the test.
      * @param t    the assertion thrown by the test.
      */
     public void addFailure(Test test, AssertionFailedError t) {
         addFailure(test, (Throwable) t);
     }
 
     /**
      * Interface TestListener.
      *
      * <p>An error occurred while running the test.
      * @param test the test.
      * @param t    the error thrown by the test.
      */
     public void addError(Test test, Throwable t) {
         String testName = JUnitVersionHelper.getTestCaseName(test);
         logTestListenerEvent("addError(" + testName + ", " + t.getMessage() + ")");
         if (haltOnError) {
             res.stop();
         }
     }
 
     /**
      * Permissions for the test run.
      * @since Ant 1.6
      * @param permissions the permissions to use.
      */
     public void setPermissions(Permissions permissions) {
         perm = permissions;
     }
 
     /**
      * Handle a string destined for standard output.
      * @param output the string to output
      */
     public void handleOutput(String output) {
         if (!logTestListenerEvents && output.startsWith(JUnitTask.TESTLISTENER_PREFIX)) {
             // ignore
         } else if (systemOut != null) {
             systemOut.print(output);
         }
     }
 
     /**
      * Handle input.
      * @param buffer not used.
      * @param offset not used.
      * @param length not used.
      * @return -1 always.
      * @throws IOException never.
      * @see org.apache.tools.ant.Task#handleInput(byte[], int, int)
      *
      * @since Ant 1.6
      */
     public int handleInput(byte[] buffer, int offset, int length)
         throws IOException {
         return -1;
     }
 
     /** {@inheritDoc}. */
     public void handleErrorOutput(String output) {
         if (systemError != null) {
             systemError.print(output);
         }
     }
 
     /** {@inheritDoc}. */
     public void handleFlush(String output) {
         if (systemOut != null) {
             systemOut.print(output);
         }
     }
 
     /** {@inheritDoc}. */
     public void handleErrorFlush(String output) {
         if (systemError != null) {
             systemError.print(output);
         }
     }
 
     private void sendOutAndErr(String out, String err) {
-        for (int i = 0; i < formatters.size(); i++) {
+        final int size = formatters.size();
+        for (int i = 0; i < size; i++) {
             JUnitResultFormatter formatter =
                 ((JUnitResultFormatter) formatters.elementAt(i));
 
             formatter.setSystemOutput(out);
             formatter.setSystemError(err);
         }
     }
 
     private void fireStartTestSuite() {
-        for (int i = 0; i < formatters.size(); i++) {
+        final int size = formatters.size();
+        for (int i = 0; i < size; i++) {
             ((JUnitResultFormatter) formatters.elementAt(i))
                 .startTestSuite(junitTest);
         }
     }
 
     private void fireEndTestSuite() {
-        for (int i = 0; i < formatters.size(); i++) {
+        final int size = formatters.size();
+        for (int i = 0; i < size; i++) {
             ((JUnitResultFormatter) formatters.elementAt(i))
                 .endTestSuite(junitTest);
         }
     }
 
     /**
      * Add a formatter.
      * @param f the formatter to add.
      */
     public void addFormatter(JUnitResultFormatter f) {
         formatters.addElement(f);
     }
 
     /** {@inheritDoc}. */
     public void addFormatter(JUnitTaskMirror.JUnitResultFormatterMirror f) {
         formatters.addElement(f);
     }
 
     /**
      * Entry point for standalone (forked) mode.
      *
      * Parameters: testcaseclassname plus parameters in the format
      * key=value, none of which is required.
      *
      * <table cols="4" border="1">
      * <tr><th>key</th><th>description</th><th>default value</th></tr>
      *
      * <tr><td>haltOnError</td><td>halt test on
      * errors?</td><td>false</td></tr>
      *
      * <tr><td>haltOnFailure</td><td>halt test on
      * failures?</td><td>false</td></tr>
      *
      * <tr><td>formatter</td><td>A JUnitResultFormatter given as
      * classname,filename. If filename is ommitted, System.out is
      * assumed.</td><td>none</td></tr>
      *
      * <tr><td>showoutput</td><td>send output to System.err/.out as
      * well as to the formatters?</td><td>false</td></tr>
      *
      * <tr><td>logtestlistenerevents</td><td>log TestListener events to
      * System.out.</td><td>false</td></tr>
      *
      * <tr><td>methods</td><td>Comma-separated list of names of individual
      * test methods to execute.
      * </td><td>null</td></tr>
      *
      * </table>
      * @param args the command line arguments.
      * @throws IOException on error.
      */
     public static void main(String[] args) throws IOException {
         String[] methods = null;
         boolean haltError = false;
         boolean haltFail = false;
         boolean stackfilter = true;
         Properties props = new Properties();
         boolean showOut = false;
         boolean outputToFormat = true;
         boolean logFailedTests = true;
         boolean logTestListenerEvents = false;
 
 
         if (args.length == 0) {
             System.err.println("required argument TestClassName missing");
             System.exit(ERRORS);
         }
 
         if (args[0].startsWith(Constants.TESTSFILE)) {
             multipleTests = true;
             args[0] = args[0].substring(Constants.TESTSFILE.length());
         }
 
         for (int i = 1; i < args.length; i++) {
             if (args[i].startsWith(Constants.METHOD_NAMES)) {
                 try {
                     String methodsList = args[i].substring(Constants.METHOD_NAMES.length());
                     methods = JUnitTest.parseTestMethodNamesList(methodsList);
                 } catch (IllegalArgumentException ex) {
                     System.err.println("Invalid specification of test method names: " + args[i]);
                     System.exit(ERRORS);
                 }
             } else if (args[i].startsWith(Constants.HALT_ON_ERROR)) {
                 haltError = Project.toBoolean(args[i].substring(Constants.HALT_ON_ERROR.length()));
             } else if (args[i].startsWith(Constants.HALT_ON_FAILURE)) {
                 haltFail = Project.toBoolean(args[i].substring(Constants.HALT_ON_FAILURE.length()));
             } else if (args[i].startsWith(Constants.FILTERTRACE)) {
                 stackfilter = Project.toBoolean(args[i].substring(Constants.FILTERTRACE.length()));
             } else if (args[i].startsWith(Constants.CRASHFILE)) {
                 crashFile = args[i].substring(Constants.CRASHFILE.length());
                 registerTestCase(Constants.BEFORE_FIRST_TEST);
             } else if (args[i].startsWith(Constants.FORMATTER)) {
                 try {
                     createAndStoreFormatter(args[i].substring(Constants.FORMATTER.length()));
                 } catch (BuildException be) {
                     System.err.println(be.getMessage());
                     System.exit(ERRORS);
                 }
             } else if (args[i].startsWith(Constants.PROPSFILE)) {
                 FileInputStream in = new FileInputStream(args[i]
                                                          .substring(Constants.PROPSFILE.length()));
                 props.load(in);
                 in.close();
             } else if (args[i].startsWith(Constants.SHOWOUTPUT)) {
                 showOut = Project.toBoolean(args[i].substring(Constants.SHOWOUTPUT.length()));
             } else if (args[i].startsWith(Constants.LOGTESTLISTENEREVENTS)) {
                 logTestListenerEvents = Project.toBoolean(
                     args[i].substring(Constants.LOGTESTLISTENEREVENTS.length()));
             } else if (args[i].startsWith(Constants.OUTPUT_TO_FORMATTERS)) {
                 outputToFormat = Project.toBoolean(
                     args[i].substring(Constants.OUTPUT_TO_FORMATTERS.length()));
             } else if (args[i].startsWith(Constants.LOG_FAILED_TESTS)) {
                 logFailedTests = Project.toBoolean(
                     args[i].substring(Constants.LOG_FAILED_TESTS.length()));
             }
         }
 
         // Add/overlay system properties on the properties from the Ant project
         Hashtable p = System.getProperties();
         for (Enumeration e = p.keys(); e.hasMoreElements();) {
             Object key = e.nextElement();
             props.put(key, p.get(key));
         }
 
         int returnCode = SUCCESS;
         if (multipleTests) {
             try {
                 java.io.BufferedReader reader =
                     new java.io.BufferedReader(new java.io.FileReader(args[0]));
                 String testCaseName;
                 String[] testMethodNames;
                 int code = 0;
                 boolean errorOccurred = false;
                 boolean failureOccurred = false;
                 String line = null;
                 while ((line = reader.readLine()) != null) {
                     StringTokenizer st = new StringTokenizer(line, ",");
                     String testListSpec = st.nextToken();
                     int colonIndex = testListSpec.indexOf(':');
                     if (colonIndex == -1) {
                         testCaseName = testListSpec;
                         testMethodNames = null;
                     } else {
                         testCaseName = testListSpec.substring(0, colonIndex);
                         testMethodNames = JUnitTest.parseTestMethodNamesList(
                                                     testListSpec
                                                     .substring(colonIndex + 1)
                                                     .replace('+', ','));
                     }
                     JUnitTest t = new JUnitTest(testCaseName);
                     t.setTodir(new File(st.nextToken()));
                     t.setOutfile(st.nextToken());
                     t.setProperties(props);
                     code = launch(t, testMethodNames, haltError, stackfilter, haltFail,
                                   showOut, outputToFormat,
                                   logTestListenerEvents);
                     errorOccurred = (code == ERRORS);
                     failureOccurred = (code != SUCCESS);
                     if (errorOccurred || failureOccurred) {
                         if ((errorOccurred && haltError)
                             || (failureOccurred && haltFail)) {
                             registerNonCrash();
                             System.exit(code);
                         } else {
                             if (code > returnCode) {
                                 returnCode = code;
                             }
                             if (logFailedTests) {
                                 System.out.println("TEST " + t.getName()
                                                    + " FAILED");
                             }
                         }
                     }
                 }
             } catch (IOException e) {
                 e.printStackTrace();
             }
         } else {
             JUnitTest t = new JUnitTest(args[0]);
             t.setProperties(props);
             returnCode = launch(
                 t, methods, haltError, stackfilter, haltFail,
                 showOut, outputToFormat, logTestListenerEvents);
         }
 
         registerNonCrash();
         System.exit(returnCode);
     }
 
     private static Vector fromCmdLine = new Vector();
 
     private static void transferFormatters(JUnitTestRunner runner,
                                            JUnitTest test) {
         runner.addFormatter(new JUnitResultFormatter() {
 
             public void startTestSuite(JUnitTest suite) throws BuildException {
             }
 
             public void endTestSuite(JUnitTest suite) throws BuildException {
             }
 
             public void setOutput(OutputStream out) {
             }
 
             public void setSystemOutput(String out) {
             }
 
             public void setSystemError(String err) {
             }
 
             public void addError(Test arg0, Throwable arg1) {
             }
 
             public void addFailure(Test arg0, AssertionFailedError arg1) {
             }
 
             public void endTest(Test arg0) {
             }
 
             public void startTest(Test arg0) {
                 registerTestCase(JUnitVersionHelper.getTestCaseName(arg0));
             }
         });
-        for (int i = 0; i < fromCmdLine.size(); i++) {
+        final int size = fromCmdLine.size();
+        for (int i = 0; i < size; i++) {
             FormatterElement fe = (FormatterElement) fromCmdLine.elementAt(i);
             if (multipleTests && fe.getUseFile()) {
                 File destFile =
                     new File(test.getTodir(),
                              test.getOutfile() + fe.getExtension());
                 fe.setOutfile(destFile);
             }
             runner.addFormatter((JUnitResultFormatter) fe.createFormatter());
         }
     }
 
     /**
      * Line format is: formatter=<classname>(,<pathname>)?
      */
     private static void createAndStoreFormatter(String line)
         throws BuildException {
         FormatterElement fe = new FormatterElement();
         int pos = line.indexOf(',');
         if (pos == -1) {
             fe.setClassname(line);
             fe.setUseFile(false);
         } else {
             fe.setClassname(line.substring(0, pos));
             fe.setUseFile(true);
             if (!multipleTests) {
                 fe.setOutfile(new File(line.substring(pos + 1)));
             } else {
                 int fName = line.indexOf(IGNORED_FILE_NAME);
                 if (fName > -1) {
                     fe.setExtension(line
                                     .substring(fName
                                                + IGNORED_FILE_NAME.length()));
                 }
             }
         }
         fromCmdLine.addElement(fe);
     }
 
     /**
      * Returns a filtered stack trace.
      * This is ripped out of junit.runner.BaseTestRunner.
      * @param t the exception to filter.
      * @return the filtered stack trace.
      */
     public static String getFilteredTrace(Throwable t) {
         String trace = StringUtils.getStackTrace(t);
         return JUnitTestRunner.filterStack(trace);
     }
 
     /**
      * Filters stack frames from internal JUnit and Ant classes
      * @param stack the stack trace to filter.
      * @return the filtered stack.
      */
     public static String filterStack(String stack) {
         if (!filtertrace) {
             return stack;
         }
         StringWriter sw = new StringWriter();
         BufferedWriter pw = new BufferedWriter(sw);
         StringReader sr = new StringReader(stack);
         BufferedReader br = new BufferedReader(sr);
 
         String line;
         try {
             while ((line = br.readLine()) != null) {
                 if (!filterLine(line)) {
                     pw.write(line);
                     pw.newLine();
                 }
             }
         } catch (Exception e) {
             return stack; // return the stack unfiltered
         } finally {
             FileUtils.close(pw);
         }
         return sw.toString();
     }
 
     private static boolean filterLine(String line) {
         for (int i = 0; i < DEFAULT_TRACE_FILTERS.length; i++) {
             if (line.indexOf(DEFAULT_TRACE_FILTERS[i]) != -1) {
                 return true;
             }
         }
         return false;
     }
 
     /**
      * @since Ant 1.6.2
      */
     private static int launch(JUnitTest t, String[] methods, boolean haltError,
                               boolean stackfilter, boolean haltFail,
                               boolean showOut, boolean outputToFormat,
                               boolean logTestListenerEvents) {
         JUnitTestRunner runner =
             new JUnitTestRunner(t, methods, haltError, stackfilter, haltFail, showOut,
                                 logTestListenerEvents, null);
         runner.forked = true;
         runner.outputToFormatters = outputToFormat;
         transferFormatters(runner, t);
 
         runner.run();
         return runner.getRetCode();
      }
 
     /**
      * @since Ant 1.7
      */
     private static void registerNonCrash()
             throws IOException {
         if (crashFile != null) {
             FileWriter out = null;
             try {
                 out = new FileWriter(crashFile);
                 out.write(Constants.TERMINATED_SUCCESSFULLY + "\n");
                 out.flush();
             } finally {
                 FileUtils.close(out);
             }
         }
     }
 
     private static void registerTestCase(String testCase) {
         if (crashFile != null) {
             try {
                 FileWriter out = null;
                 try {
                     out = new FileWriter(crashFile);
                     out.write(testCase + "\n");
                     out.flush();
                 } finally {
                     FileUtils.close(out);
                 }
             } catch (IOException e) {
                 // ignored.
             }
         }
     }
 
     /**
      * Modifies a TestListener when running JUnit 4: treats AssertionFailedError
      * as a failure not an error.
      *
      * @since Ant 1.7
      */
     private TestListener wrapListener(final TestListener testListener) {
         return new TestListener() {
             public void addError(Test test, Throwable t) {
                 if (junit4 && t instanceof AssertionFailedError) {
                     // JUnit 4 does not distinguish between errors and failures
                     // even in the JUnit 3 adapter.
                     // So we need to help it a bit to retain compatibility for JUnit 3 tests.
                     testListener.addFailure(test, (AssertionFailedError) t);
                 } else if (junit4 && t instanceof  AssertionError) {
                     // Not strictly necessary but probably desirable.
                     // JUnit 4-specific test GUIs will show just "failures".
                     // But Ant's output shows "failures" vs. "errors".
                     // We would prefer to show "failure" for things that logically are.
                     String msg = t.getMessage();
                     AssertionFailedError failure = msg != null
                         ? new AssertionFailedError(msg) : new AssertionFailedError();
                     failure.setStackTrace(t.getStackTrace());
                     testListener.addFailure(test, failure);
                 } else {
                     testListener.addError(test, t);
                 }
             }
             public void addFailure(Test test, AssertionFailedError t) {
                 testListener.addFailure(test, t);
             }
             public void addFailure(Test test, Throwable t) { // pre-3.4
                 if (t instanceof AssertionFailedError) {
                     testListener.addFailure(test, (AssertionFailedError) t);
                 } else {
                     testListener.addError(test, t);
                 }
             }
             public void endTest(Test test) {
                 testListener.endTest(test);
             }
             public void startTest(Test test) {
                 testListener.startTest(test);
             }
         };
     }
 
     /**
      * Use instead of TestResult.get{Failure,Error}Count on JUnit 4,
      * since the adapter claims that all failures are errors.
      * @since Ant 1.7
      */
     private int[] findJUnit4FailureErrorCount(TestResult result) {
         int failures = 0;
         int errors = 0;
         Enumeration e = result.failures();
         while (e.hasMoreElements()) {
             e.nextElement();
             failures++;
         }
         e = result.errors();
         while (e.hasMoreElements()) {
             Throwable t = ((TestFailure) e.nextElement()).thrownException();
             if (t instanceof AssertionFailedError
                 || t instanceof AssertionError) {
                 failures++;
             } else {
                 errors++;
             }
         }
         return new int[] {failures, errors};
     }
 
 } // JUnitTestRunner
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/net/FTP.java b/src/main/org/apache/tools/ant/taskdefs/optional/net/FTP.java
index 405bfa539..2f1b44dda 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/net/FTP.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/net/FTP.java
@@ -1,2719 +1,2722 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.net;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.text.SimpleDateFormat;
 import java.util.Collection;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.Vector;
 
 import org.apache.commons.net.ftp.FTPClient;
 import org.apache.commons.net.ftp.FTPClientConfig;
 import org.apache.commons.net.ftp.FTPFile;
 import org.apache.commons.net.ftp.FTPReply;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.taskdefs.Delete;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.selectors.SelectorUtils;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.RetryHandler;
 import org.apache.tools.ant.util.Retryable;
 import org.apache.tools.ant.util.VectorSet;
 
 /**
  * Basic FTP client. Performs the following actions:
  * <ul>
  *   <li> <strong>send</strong> - send files to a remote server. This is the
  *   default action.</li>
  *   <li> <strong>get</strong> - retrieve files from a remote server.</li>
  *   <li> <strong>del</strong> - delete files from a remote server.</li>
  *   <li> <strong>list</strong> - create a file listing.</li>
  *   <li> <strong>chmod</strong> - change unix file permissions.</li>
  *   <li> <strong>rmdir</strong> - remove directories, if empty, from a
  *   remote server.</li>
  * </ul>
  * <strong>Note:</strong> Some FTP servers - notably the Solaris server - seem
  * to hold data ports open after a "retr" operation, allowing them to timeout
  * instead of shutting them down cleanly. This happens in active or passive
  * mode, and the ports will remain open even after ending the FTP session. FTP
  * "send" operations seem to close ports immediately. This behavior may cause
  * problems on some systems when downloading large sets of files.
  *
  * @since Ant 1.3
  */
 public class FTP extends Task implements FTPTaskConfig {
     protected static final int SEND_FILES = 0;
     protected static final int GET_FILES = 1;
     protected static final int DEL_FILES = 2;
     protected static final int LIST_FILES = 3;
     protected static final int MK_DIR = 4;
     protected static final int CHMOD = 5;
     protected static final int RM_DIR = 6;
     protected static final int SITE_CMD = 7;
     /** return code of ftp - not implemented in commons-net version 1.0 */
     private static final int CODE_521 = 521;
 
     /** adjust uptodate calculations where server timestamps are HH:mm and client's
      * are HH:mm:ss */
     private static final long GRANULARITY_MINUTE = 60000L;
 
     /** Date formatter used in logging, note not thread safe! */
     private static final SimpleDateFormat TIMESTAMP_LOGGING_SDF =
         new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
 
     /** Default port for FTP */
     public static final int DEFAULT_FTP_PORT = 21;
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     private String remotedir;
     private String server;
     private String userid;
     private String password;
     private String account;
     private File listing;
     private boolean binary = true;
     private boolean passive = false;
     private boolean verbose = false;
     private boolean newerOnly = false;
     private long timeDiffMillis = 0;
     private long granularityMillis = 0L;
     private boolean timeDiffAuto = false;
     private int action = SEND_FILES;
     private Vector filesets = new Vector();
     private Set dirCache = new HashSet();
     private int transferred = 0;
     private String remoteFileSep = "/";
     private int port = DEFAULT_FTP_PORT;
     private boolean skipFailedTransfers = false;
     private int skipped = 0;
     private boolean ignoreNoncriticalErrors = false;
     private boolean preserveLastModified = false;
     private String chmod = null;
     private String umask = null;
     private FTPSystemType systemTypeKey = FTPSystemType.getDefault();
     private String defaultDateFormatConfig = null;
     private String recentDateFormatConfig = null;
     private LanguageCode serverLanguageCodeConfig = LanguageCode.getDefault();
     private String serverTimeZoneConfig = null;
     private String shortMonthNamesConfig = null;
     private Granularity timestampGranularity = Granularity.getDefault();
     private boolean isConfigurationSet = false;
     private int retriesAllowed = 0;
     private String siteCommand = null;
     private String initialSiteCommand = null;
     private boolean enableRemoteVerification = true;
 
     protected static final String[] ACTION_STRS = {
         "sending",
         "getting",
         "deleting",
         "listing",
         "making directory",
         "chmod",
         "removing",
         "site"
     };
 
     protected static final String[] COMPLETED_ACTION_STRS = {
         "sent",
         "retrieved",
         "deleted",
         "listed",
         "created directory",
         "mode changed",
         "removed",
         "site command executed"
     };
 
     protected static final String[] ACTION_TARGET_STRS = {
         "files",
         "files",
         "files",
         "files",
         "directory",
         "files",
         "directories",
         "site command"
     };
 
     /**
      * internal class providing a File-like interface to some of the information
      * available from the FTP server
      *
      */
     protected static class FTPFileProxy extends File {
 
         private final FTPFile file;
         private final String[] parts;
         private final String name;
 
         /**
          * creates a proxy to a FTP file
          * @param file
          */
         public FTPFileProxy(FTPFile file) {
             super(file.getName());
             name = file.getName();
             this.file = file;
             parts = FileUtils.getPathStack(name);
         }
 
         /**
          * creates a proxy to a FTP directory
          * @param completePath the remote directory.
          */
         public FTPFileProxy(String completePath) {
             super(completePath);
             file = null;
             name = completePath;
             parts = FileUtils.getPathStack(completePath);
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#exists()
          */
         public boolean exists() {
             return true;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getAbsolutePath()
          */
         public String getAbsolutePath() {
             return name;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getName()
          */
         public String getName() {
             return parts.length > 0 ? parts[parts.length - 1] : name;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getParent()
          */
         public String getParent() {
             String result = "";
             for(int i = 0; i < parts.length - 1; i++){
                 result += File.separatorChar + parts[i];
             }
             return result;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getPath()
          */
         public String getPath() {
             return name;
         }
 
 
         /**
          * FTP files are stored as absolute paths
          * @return true
          */
         public boolean isAbsolute() {
             return true;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#isDirectory()
          */
         public boolean isDirectory() {
             return file == null;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#isFile()
          */
         public boolean isFile() {
             return file != null;
         }
 
 
         /**
          * FTP files cannot be hidden
          *
          * @return  false
          */
         public boolean isHidden() {
             return false;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#lastModified()
          */
         public long lastModified() {
             if (file != null) {
                 return file.getTimestamp().getTimeInMillis();
             }
             return 0;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#length()
          */
         public long length() {
             if (file != null) {
                 return file.getSize();
             }
             return 0;
         }
     }
 
     /**
      * internal class allowing to read the contents of a remote file system
      * using the FTP protocol
      * used in particular for ftp get operations
      * differences with DirectoryScanner
      * "" (the root of the fileset) is never included in the included directories
      * followSymlinks defaults to false
      */
     protected class FTPDirectoryScanner extends DirectoryScanner {
         // CheckStyle:VisibilityModifier OFF - bc
         protected FTPClient ftp = null;
         // CheckStyle:VisibilityModifier ON
 
         private String rootPath = null;
 
         /**
          * since ant 1.6
          * this flag should be set to true on UNIX and can save scanning time
          */
         private boolean remoteSystemCaseSensitive = false;
         private boolean remoteSensitivityChecked = false;
 
         /**
          * constructor
          * @param ftp  ftpclient object
          */
         public FTPDirectoryScanner(FTPClient ftp) {
             super();
             this.ftp = ftp;
             this.setFollowSymlinks(false);
         }
 
 
         /**
          * scans the remote directory,
          * storing internally the included files, directories, ...
          */
         public void scan() {
             if (includes == null) {
                 // No includes supplied, so set it to 'matches all'
                 includes = new String[1];
                 includes[0] = "**";
             }
             if (excludes == null) {
                 excludes = new String[0];
             }
 
             filesIncluded = new VectorSet();
             filesNotIncluded = new Vector();
             filesExcluded = new VectorSet();
             dirsIncluded = new VectorSet();
             dirsNotIncluded = new Vector();
             dirsExcluded = new VectorSet();
 
             try {
                 String cwd = ftp.printWorkingDirectory();
                 // always start from the current ftp working dir
                 forceRemoteSensitivityCheck();
 
                 checkIncludePatterns();
                 clearCaches();
                 ftp.changeWorkingDirectory(cwd);
             } catch (IOException e) {
                 throw new BuildException("Unable to scan FTP server: ", e);
             }
         }
 
 
         /**
          * this routine is actually checking all the include patterns in
          * order to avoid scanning everything under base dir
          * @since ant1.6
          */
         private void checkIncludePatterns() {
 
             Hashtable newroots = new Hashtable();
             // put in the newroots vector the include patterns without
             // wildcard tokens
             for (int icounter = 0; icounter < includes.length; icounter++) {
                 String newpattern =
                     SelectorUtils.rtrimWildcardTokens(includes[icounter]);
                 newroots.put(newpattern, includes[icounter]);
             }
             if (remotedir == null) {
                 try {
                     remotedir = ftp.printWorkingDirectory();
                 } catch (IOException e) {
                     throw new BuildException("could not read current ftp directory",
                                              getLocation());
                 }
             }
             AntFTPFile baseFTPFile = new AntFTPRootFile(ftp, remotedir);
             rootPath = baseFTPFile.getAbsolutePath();
             // construct it
             if (newroots.containsKey("")) {
                 // we are going to scan everything anyway
                 scandir(rootPath, "", true);
             } else {
                 // only scan directories that can include matched files or
                 // directories
                 Enumeration enum2 = newroots.keys();
 
                 while (enum2.hasMoreElements()) {
                     String currentelement = (String) enum2.nextElement();
                     String originalpattern = (String) newroots.get(currentelement);
                     AntFTPFile myfile = new AntFTPFile(baseFTPFile, currentelement);
                     boolean isOK = true;
                     boolean traversesSymlinks = false;
                     String path = null;
 
                     if (myfile.exists()) {
                         forceRemoteSensitivityCheck();
                         if (remoteSensitivityChecked
                             && remoteSystemCaseSensitive && isFollowSymlinks()) {
                             // cool case,
                             //we do not need to scan all the subdirs in the relative path
                             path = myfile.getFastRelativePath();
                         } else {
                             // may be on a case insensitive file system.  We want
                             // the results to show what's really on the disk, so
                             // we need to double check.
                             try {
                                 path = myfile.getRelativePath();
                                 traversesSymlinks = myfile.isTraverseSymlinks();
                             }  catch (IOException be) {
                                 throw new BuildException(be, getLocation());
                             } catch (BuildException be) {
                                 isOK = false;
                             }
                         }
                     } else {
                         isOK = false;
                     }
                     if (isOK) {
                         currentelement = path.replace(remoteFileSep.charAt(0), File.separatorChar);
                         if (!isFollowSymlinks()
                             && traversesSymlinks) {
                             continue;
                         }
 
                         if (myfile.isDirectory()) {
                             if (isIncluded(currentelement)
                                 && currentelement.length() > 0) {
                                 accountForIncludedDir(currentelement, myfile, true);
                             }  else {
                                 if (currentelement.length() > 0) {
                                     if (currentelement.charAt(currentelement
                                                               .length() - 1)
                                         != File.separatorChar) {
                                         currentelement =
                                             currentelement + File.separatorChar;
                                     }
                                 }
                                 scandir(myfile.getAbsolutePath(), currentelement, true);
                             }
                         } else {
                             if (isCaseSensitive
                                 && originalpattern.equals(currentelement)) {
                                 accountForIncludedFile(currentelement);
                             } else if (!isCaseSensitive
                                        && originalpattern
                                        .equalsIgnoreCase(currentelement)) {
                                 accountForIncludedFile(currentelement);
                             }
                         }
                     }
                 }
             }
         }
         /**
          * scans a particular directory. populates the scannedDirs cache.
          *
          * @param dir directory to scan
          * @param vpath  relative path to the base directory of the remote fileset
          * always ended with a File.separator
          * @param fast seems to be always true in practice
          */
         protected void scandir(String dir, String vpath, boolean fast) {
             // avoid double scanning of directories, can only happen in fast mode
             if (fast && hasBeenScanned(vpath)) {
                 return;
             }
             try {
                 if (!ftp.changeWorkingDirectory(dir)) {
                     return;
                 }
                 String completePath = null;
                 if (!vpath.equals("")) {
                     completePath = rootPath + remoteFileSep
                         + vpath.replace(File.separatorChar, remoteFileSep.charAt(0));
                 } else {
                     completePath = rootPath;
                 }
                 FTPFile[] newfiles = listFiles(completePath, false);
 
                 if (newfiles == null) {
                     ftp.changeToParentDirectory();
                     return;
                 }
                 for (int i = 0; i < newfiles.length; i++) {
                     FTPFile file = newfiles[i];
                     if (file != null
                         && !file.getName().equals(".")
                         && !file.getName().equals("..")) {
                         String name = vpath + file.getName();
                         scannedDirs.put(name, new FTPFileProxy(file));
                         if (isFunctioningAsDirectory(ftp, dir, file)) {
                             boolean slowScanAllowed = true;
                             if (!isFollowSymlinks() && file.isSymbolicLink()) {
                                 dirsExcluded.addElement(name);
                                 slowScanAllowed = false;
                             } else if (isIncluded(name)) {
                                 accountForIncludedDir(name,
                                                       new AntFTPFile(ftp, file, completePath) , fast);
                             } else {
                                 dirsNotIncluded.addElement(name);
                                 if (fast && couldHoldIncluded(name)) {
                                     scandir(file.getName(),
                                             name + File.separator, fast);
                                 }
                             }
                             if (!fast && slowScanAllowed) {
                                 scandir(file.getName(),
                                         name + File.separator, fast);
                             }
                         } else {
                             if (!isFollowSymlinks() && file.isSymbolicLink()) {
                                 filesExcluded.addElement(name);
                             } else if (isFunctioningAsFile(ftp, dir, file)) {
                                 accountForIncludedFile(name);
                             }
                         }
                     }
                 }
                 ftp.changeToParentDirectory();
             } catch (IOException e) {
                 throw new BuildException("Error while communicating with FTP "
                                          + "server: ", e);
             }
         }
         /**
          * process included file
          * @param name  path of the file relative to the directory of the fileset
          */
         private void accountForIncludedFile(String name) {
             if (!filesIncluded.contains(name)
                 && !filesExcluded.contains(name)) {
 
                 if (isIncluded(name)) {
                     if (!isExcluded(name)
                         && isSelected(name, (File) scannedDirs.get(name))) {
                         filesIncluded.addElement(name);
                     } else {
                         filesExcluded.addElement(name);
                     }
                 } else {
                     filesNotIncluded.addElement(name);
                 }
             }
         }
 
         /**
          *
          * @param name path of the directory relative to the directory of
          * the fileset
          * @param file directory as file
          * @param fast
          */
         private void accountForIncludedDir(String name, AntFTPFile file, boolean fast) {
             if (!dirsIncluded.contains(name)
                 && !dirsExcluded.contains(name)) {
 
                 if (!isExcluded(name)) {
                     if (fast) {
                         if (file.isSymbolicLink()) {
                             try {
                                 file.getClient().changeWorkingDirectory(file.curpwd);
                             } catch (IOException ioe) {
                                 throw new BuildException("could not change directory to curpwd");
                             }
                             scandir(file.getLink(),
                                     name + File.separator, fast);
                         } else {
                             try {
                                 file.getClient().changeWorkingDirectory(file.curpwd);
                             } catch (IOException ioe) {
                                 throw new BuildException("could not change directory to curpwd");
                             }
                             scandir(file.getName(),
                                     name + File.separator, fast);
                         }
                     }
                     dirsIncluded.addElement(name);
                 } else {
                     dirsExcluded.addElement(name);
                     if (fast && couldHoldIncluded(name)) {
                         try {
                             file.getClient().changeWorkingDirectory(file.curpwd);
                         } catch (IOException ioe) {
                             throw new BuildException("could not change directory to curpwd");
                         }
                         scandir(file.getName(),
                                 name + File.separator, fast);
                     }
                 }
             }
         }
         /**
          * temporary table to speed up the various scanning methods below
          *
          * @since Ant 1.6
          */
         private Map fileListMap = new HashMap();
         /**
          * List of all scanned directories.
          *
          * @since Ant 1.6
          */
 
         private Map scannedDirs = new HashMap();
 
         /**
          * Has the directory with the given path relative to the base
          * directory already been scanned?
          *
          * @since Ant 1.6
          */
         private boolean hasBeenScanned(String vpath) {
             return scannedDirs.containsKey(vpath);
         }
 
         /**
          * Clear internal caches.
          *
          * @since Ant 1.6
          */
         private void clearCaches() {
             fileListMap.clear();
             scannedDirs.clear();
         }
         /**
          * list the files present in one directory.
          * @param directory full path on the remote side
          * @param changedir if true change to directory directory before listing
          * @return array of FTPFile
          */
         public FTPFile[] listFiles(String directory, boolean changedir) {
             //getProject().log("listing files in directory " + directory, Project.MSG_DEBUG);
             String currentPath = directory;
             if (changedir) {
                 try {
                     boolean result = ftp.changeWorkingDirectory(directory);
                     if (!result) {
                         return null;
                     }
                     currentPath = ftp.printWorkingDirectory();
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, getLocation());
                 }
             }
             if (fileListMap.containsKey(currentPath)) {
                 getProject().log("filelist map used in listing files", Project.MSG_DEBUG);
                 return ((FTPFile[]) fileListMap.get(currentPath));
             }
             FTPFile[] result = null;
             try {
                 result = ftp.listFiles();
             } catch (IOException ioe) {
                 throw new BuildException(ioe, getLocation());
             }
             fileListMap.put(currentPath, result);
             if (!remoteSensitivityChecked) {
                 checkRemoteSensitivity(result, directory);
             }
             return result;
         }
 
         private void forceRemoteSensitivityCheck() {
             if (!remoteSensitivityChecked) {
                 try {
                     checkRemoteSensitivity(ftp.listFiles(), ftp.printWorkingDirectory());
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, getLocation());
                 }
             }
         }
         /**
          * cd into one directory and
          * list the files present in one directory.
          * @param directory full path on the remote side
          * @return array of FTPFile
          */
         public FTPFile[] listFiles(String directory) {
             return listFiles(directory, true);
         }
         private void checkRemoteSensitivity(FTPFile[] array, String directory) {
             if (array == null) {
                 return;
             }
             boolean candidateFound = false;
             String target = null;
             for (int icounter = 0; icounter < array.length; icounter++) {
                 if (array[icounter] != null && array[icounter].isDirectory()) {
                     if (!array[icounter].getName().equals(".")
                         && !array[icounter].getName().equals("..")) {
                         candidateFound = true;
                         target = fiddleName(array[icounter].getName());
                         getProject().log("will try to cd to "
                                          + target + " where a directory called " + array[icounter].getName()
                                          + " exists", Project.MSG_DEBUG);
                         for (int pcounter = 0; pcounter < array.length; pcounter++) {
                             if (array[pcounter] != null
                                 && pcounter != icounter
                                 && target.equals(array[pcounter].getName())) {
                                 candidateFound = false;
                             }
                         }
                         if (candidateFound) {
                             break;
                         }
                     }
                 }
             }
             if (candidateFound) {
                 try {
                     getProject().log("testing case sensitivity, attempting to cd to "
                                      + target, Project.MSG_DEBUG);
                     remoteSystemCaseSensitive  = !ftp.changeWorkingDirectory(target);
                 } catch (IOException ioe) {
                     remoteSystemCaseSensitive = true;
                 } finally {
                     try {
                         ftp.changeWorkingDirectory(directory);
                     } catch (IOException ioe) {
                         throw new BuildException(ioe, getLocation());
                     }
                 }
                 getProject().log("remote system is case sensitive : " + remoteSystemCaseSensitive,
                                  Project.MSG_VERBOSE);
                 remoteSensitivityChecked = true;
             }
         }
         private String fiddleName(String origin) {
             StringBuffer result = new StringBuffer();
             for (int icounter = 0; icounter < origin.length(); icounter++) {
                 if (Character.isLowerCase(origin.charAt(icounter))) {
                     result.append(Character.toUpperCase(origin.charAt(icounter)));
                 } else if (Character.isUpperCase(origin.charAt(icounter))) {
                     result.append(Character.toLowerCase(origin.charAt(icounter)));
                 } else {
                     result.append(origin.charAt(icounter));
                 }
             }
             return result.toString();
         }
         /**
          * an AntFTPFile is a representation of a remote file
          * @since Ant 1.6
          */
         protected class AntFTPFile {
             /**
              * ftp client
              */
             private FTPClient client;
             /**
              * parent directory of the file
              */
             private String curpwd;
             /**
              * the file itself
              */
             private FTPFile ftpFile;
             /**
              *
              */
             private AntFTPFile parent = null;
             private boolean relativePathCalculated = false;
             private boolean traversesSymlinks = false;
             private String relativePath = "";
             /**
              * constructor
              * @param client ftp client variable
              * @param ftpFile the file
              * @param curpwd absolute remote path where the file is found
              */
             public AntFTPFile(FTPClient client, FTPFile ftpFile, String curpwd) {
                 this.client = client;
                 this.ftpFile = ftpFile;
                 this.curpwd = curpwd;
             }
             /**
              * other constructor
              * @param parent the parent file
              * @param path  a relative path to the parent file
              */
             public AntFTPFile(AntFTPFile parent, String path) {
                 this.parent = parent;
                 this.client = parent.client;
                 Vector pathElements = SelectorUtils.tokenizePath(path);
                 try {
                     boolean result = this.client.changeWorkingDirectory(parent.getAbsolutePath());
                     //this should not happen, except if parent has been deleted by another process
                     if (!result) {
                         return;
                     }
                     this.curpwd = parent.getAbsolutePath();
                 } catch (IOException ioe) {
                     throw new BuildException("could not change working dir to "
                                              + parent.curpwd);
                 }
-                for (int fcount = 0; fcount < pathElements.size() - 1; fcount++) {
+                final int size = pathElements.size();
+                for (int fcount = 0; fcount < size - 1; fcount++) {
                     String currentPathElement = (String) pathElements.elementAt(fcount);
                     try {
                         boolean result = this.client.changeWorkingDirectory(currentPathElement);
                         if (!result && !isCaseSensitive()
                             && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) {
                             currentPathElement = findPathElementCaseUnsensitive(this.curpwd,
                                                                                 currentPathElement);
                             if (currentPathElement == null) {
                                 return;
                             }
                         } else if (!result) {
                             return;
                         }
                         this.curpwd = getCurpwdPlusFileSep()
                             + currentPathElement;
                     } catch (IOException ioe) {
                         throw new BuildException("could not change working dir to "
                                                  + (String) pathElements.elementAt(fcount)
                                                  + " from " + this.curpwd);
                     }
 
                 }
-                String lastpathelement = (String) pathElements.elementAt(pathElements.size() - 1);
+                String lastpathelement = (String) pathElements.elementAt(size - 1);
                 FTPFile [] theFiles = listFiles(this.curpwd);
                 this.ftpFile = getFile(theFiles, lastpathelement);
             }
             /**
              * find a file in a directory in case unsensitive way
              * @param parentPath        where we are
              * @param soughtPathElement what is being sought
              * @return                  the first file found or null if not found
              */
             private String findPathElementCaseUnsensitive(String parentPath,
                                                           String soughtPathElement) {
                 // we are already in the right path, so the second parameter
                 // is false
                 FTPFile[] theFiles = listFiles(parentPath, false);
                 if (theFiles == null) {
                     return null;
                 }
                 for (int icounter = 0; icounter < theFiles.length; icounter++) {
                     if (theFiles[icounter] != null
                         && theFiles[icounter].getName().equalsIgnoreCase(soughtPathElement)) {
                         return theFiles[icounter].getName();
                     }
                 }
                 return null;
             }
             /**
              * find out if the file exists
              * @return  true if the file exists
              */
             public boolean exists() {
                 return (ftpFile != null);
             }
             /**
              * if the file is a symbolic link, find out to what it is pointing
              * @return the target of the symbolic link
              */
             public String getLink() {
                 return ftpFile.getLink();
             }
             /**
              * get the name of the file
              * @return the name of the file
              */
             public String getName() {
                 return ftpFile.getName();
             }
             /**
              * find out the absolute path of the file
              * @return absolute path as string
              */
             public String getAbsolutePath() {
                 return getCurpwdPlusFileSep() + ftpFile.getName();
             }
             /**
              * find out the relative path assuming that the path used to construct
              * this AntFTPFile was spelled properly with regards to case.
              * This is OK on a case sensitive system such as UNIX
              * @return relative path
              */
             public String getFastRelativePath() {
                 String absPath = getAbsolutePath();
                 if (absPath.indexOf(rootPath + remoteFileSep) == 0) {
                     return absPath.substring(rootPath.length() + remoteFileSep.length());
                 }
                 return null;
             }
             /**
              * find out the relative path to the rootPath of the enclosing scanner.
              * this relative path is spelled exactly like on disk,
              * for instance if the AntFTPFile has been instantiated as ALPHA,
              * but the file is really called alpha, this method will return alpha.
              * If a symbolic link is encountered, it is followed, but the name of the link
              * rather than the name of the target is returned.
              * (ie does not behave like File.getCanonicalPath())
              * @return                relative path, separated by remoteFileSep
              * @throws IOException    if a change directory fails, ...
              * @throws BuildException if one of the components of the relative path cannot
              * be found.
              */
             public String getRelativePath() throws IOException, BuildException {
                 if (!relativePathCalculated) {
                     if (parent != null) {
                         traversesSymlinks = parent.isTraverseSymlinks();
                         relativePath = getRelativePath(parent.getAbsolutePath(),
                                                        parent.getRelativePath());
                     } else {
                         relativePath = getRelativePath(rootPath, "");
                         relativePathCalculated = true;
                     }
                 }
                 return relativePath;
             }
             /**
              * get thge relative path of this file
              * @param currentPath          base path
              * @param currentRelativePath  relative path of the base path with regards to remote dir
              * @return relative path
              */
             private String getRelativePath(String currentPath, String currentRelativePath) {
                 Vector pathElements = SelectorUtils.tokenizePath(getAbsolutePath(), remoteFileSep);
                 Vector pathElements2 = SelectorUtils.tokenizePath(currentPath, remoteFileSep);
                 String relPath = currentRelativePath;
-                for (int pcount = pathElements2.size(); pcount < pathElements.size(); pcount++) {
+                final int size = pathElements.size();
+                for (int pcount = pathElements2.size(); pcount < size; pcount++) {
                     String currentElement = (String) pathElements.elementAt(pcount);
                     FTPFile[] theFiles = listFiles(currentPath);
                     FTPFile theFile = null;
                     if (theFiles != null) {
                         theFile = getFile(theFiles, currentElement);
                     }
                     if (!relPath.equals("")) {
                         relPath = relPath + remoteFileSep;
                     }
                     if (theFile == null) {
                         // hit a hidden file assume not a symlink
                         relPath = relPath + currentElement;
                         currentPath = currentPath + remoteFileSep + currentElement;
                         log("Hidden file " + relPath
                             + " assumed to not be a symlink.",
                             Project.MSG_VERBOSE);
                     } else {
                         traversesSymlinks = traversesSymlinks || theFile.isSymbolicLink();
                         relPath = relPath + theFile.getName();
                         currentPath = currentPath + remoteFileSep + theFile.getName();
                     }
                 }
                 return relPath;
             }
             /**
              * find a file matching a string in an array of FTPFile.
              * This method will find "alpha" when requested for "ALPHA"
              * if and only if the caseSensitive attribute is set to false.
              * When caseSensitive is set to true, only the exact match is returned.
              * @param theFiles  array of files
              * @param lastpathelement  the file name being sought
              * @return null if the file cannot be found, otherwise return the matching file.
              */
             public FTPFile getFile(FTPFile[] theFiles, String lastpathelement) {
                 if (theFiles == null) {
                     return null;
                 }
                 for (int fcount = 0; fcount < theFiles.length; fcount++) {
                     if (theFiles[fcount] != null) {
                         if (theFiles[fcount].getName().equals(lastpathelement)) {
                             return theFiles[fcount];
                         } else if (!isCaseSensitive()
                                    && theFiles[fcount].getName().equalsIgnoreCase(
                                                                                   lastpathelement)) {
                             return theFiles[fcount];
                         }
                     }
                 }
                 return null;
             }
             /**
              * tell if a file is a directory.
              * note that it will return false for symbolic links pointing to directories.
              * @return <code>true</code> for directories
              */
             public boolean isDirectory() {
                 return ftpFile.isDirectory();
             }
             /**
              * tell if a file is a symbolic link
              * @return <code>true</code> for symbolic links
              */
             public boolean isSymbolicLink() {
                 return ftpFile.isSymbolicLink();
             }
             /**
              * return the attached FTP client object.
              * Warning : this instance is really shared with the enclosing class.
              * @return  FTP client
              */
             protected FTPClient getClient() {
                 return client;
             }
 
             /**
              * sets the current path of an AntFTPFile
              * @param curpwd the current path one wants to set
              */
             protected void setCurpwd(String curpwd) {
                 this.curpwd = curpwd;
             }
             /**
              * returns the path of the directory containing the AntFTPFile.
              * of the full path of the file itself in case of AntFTPRootFile
              * @return parent directory of the AntFTPFile
              */
             public String getCurpwd() {
                 return curpwd;
             }
             /**
              * returns the path of the directory containing the AntFTPFile.
              * of the full path of the file itself in case of AntFTPRootFile
              * and appends the remote file separator if necessary.
              * @return parent directory of the AntFTPFile
              * @since Ant 1.8.2
              */
             public String getCurpwdPlusFileSep() {
                 return curpwd.endsWith(remoteFileSep) ? curpwd
                     : curpwd + remoteFileSep;
             }
             /**
              * find out if a symbolic link is encountered in the relative path of this file
              * from rootPath.
              * @return <code>true</code> if a symbolic link is encountered in the relative path.
              * @throws IOException if one of the change directory or directory listing operations
              * fails
              * @throws BuildException if a path component in the relative path cannot be found.
              */
             public boolean isTraverseSymlinks() throws IOException, BuildException {
                 if (!relativePathCalculated) {
                     // getRelativePath also finds about symlinks
                     getRelativePath();
                 }
                 return traversesSymlinks;
             }
 
             /**
              * Get a string rep of this object.
              * @return a string containing the pwd and the file.
              */
             public String toString() {
                 return "AntFtpFile: " + curpwd + "%" + ftpFile;
             }
         }
         /**
          * special class to represent the remote directory itself
          * @since Ant 1.6
          */
         protected class AntFTPRootFile extends AntFTPFile {
             private String remotedir;
             /**
              * constructor
              * @param aclient FTP client
              * @param remotedir remote directory
              */
             public AntFTPRootFile(FTPClient aclient, String remotedir) {
                 super(aclient, null, remotedir);
                 this.remotedir = remotedir;
                 try {
                     this.getClient().changeWorkingDirectory(this.remotedir);
                     this.setCurpwd(this.getClient().printWorkingDirectory());
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, getLocation());
                 }
             }
             /**
              * find the absolute path
              * @return absolute path
              */
             public String getAbsolutePath() {
                 return this.getCurpwd();
             }
             /**
              * find out the relative path to root
              * @return empty string
              * @throws BuildException actually never
              * @throws IOException  actually never
              */
             public String getRelativePath() throws BuildException, IOException {
                 return "";
             }
         }
     }
     /**
      * check FTPFiles to check whether they function as directories too
      * the FTPFile API seem to make directory and symbolic links incompatible
      * we want to find out if we can cd to a symbolic link
      * @param dir  the parent directory of the file to test
      * @param file the file to test
      * @return true if it is possible to cd to this directory
      * @since ant 1.6
      */
     private boolean isFunctioningAsDirectory(FTPClient ftp, String dir, FTPFile file) {
         boolean result = false;
         String currentWorkingDir = null;
         if (file.isDirectory()) {
             return true;
         } else if (file.isFile()) {
             return false;
         }
         try {
             currentWorkingDir = ftp.printWorkingDirectory();
         } catch (IOException ioe) {
             getProject().log("could not find current working directory " + dir
                              + " while checking a symlink",
                              Project.MSG_DEBUG);
         }
         if (currentWorkingDir != null) {
             try {
                 result = ftp.changeWorkingDirectory(file.getLink());
             } catch (IOException ioe) {
                 getProject().log("could not cd to " + file.getLink() + " while checking a symlink",
                                  Project.MSG_DEBUG);
             }
             if (result) {
                 boolean comeback = false;
                 try {
                     comeback = ftp.changeWorkingDirectory(currentWorkingDir);
                 } catch (IOException ioe) {
                     getProject().log("could not cd back to " + dir + " while checking a symlink",
                                      Project.MSG_ERR);
                 } finally {
                     if (!comeback) {
                         throw new BuildException("could not cd back to " + dir
                                                  + " while checking a symlink");
                     }
                 }
             }
         }
         return result;
     }
     /**
      * check FTPFiles to check whether they function as directories too
      * the FTPFile API seem to make directory and symbolic links incompatible
      * we want to find out if we can cd to a symbolic link
      * @param dir  the parent directory of the file to test
      * @param file the file to test
      * @return true if it is possible to cd to this directory
      * @since ant 1.6
      */
     private boolean isFunctioningAsFile(FTPClient ftp, String dir, FTPFile file) {
         if (file.isDirectory()) {
             return false;
         } else if (file.isFile()) {
             return true;
         }
         return !isFunctioningAsDirectory(ftp, dir, file);
     }
     /**
      * Sets the remote directory where files will be placed. This may be a
      * relative or absolute path, and must be in the path syntax expected by
      * the remote server. No correction of path syntax will be performed.
      *
      * @param dir the remote directory name.
      */
     public void setRemotedir(String dir) {
         this.remotedir = dir;
     }
 
 
     /**
      * Sets the FTP server to send files to.
      *
      * @param server the remote server name.
      */
     public void setServer(String server) {
         this.server = server;
     }
 
 
     /**
      * Sets the FTP port used by the remote server.
      *
      * @param port the port on which the remote server is listening.
      */
     public void setPort(int port) {
         this.port = port;
     }
 
 
     /**
      * Sets the login user id to use on the specified server.
      *
      * @param userid remote system userid.
      */
     public void setUserid(String userid) {
         this.userid = userid;
     }
 
 
     /**
      * Sets the login password for the given user id.
      *
      * @param password the password on the remote system.
      */
     public void setPassword(String password) {
         this.password = password;
     }
 
     /**
      * Sets the login account to use on the specified server.
      *
      * @param pAccount the account name on remote system
      * @since Ant 1.7
      */
     public void setAccount(String pAccount) {
         this.account = pAccount;
     }
 
 
     /**
      * If true, uses binary mode, otherwise text mode (default is binary).
      *
      * @param binary if true use binary mode in transfers.
      */
     public void setBinary(boolean binary) {
         this.binary = binary;
     }
 
 
     /**
      * Specifies whether to use passive mode. Set to true if you are behind a
      * firewall and cannot connect without it. Passive mode is disabled by
      * default.
      *
      * @param passive true is passive mode should be used.
      */
     public void setPassive(boolean passive) {
         this.passive = passive;
     }
 
 
     /**
      * Set to true to receive notification about each file as it is
      * transferred.
      *
      * @param verbose true if verbose notifications are required.
      */
     public void setVerbose(boolean verbose) {
         this.verbose = verbose;
     }
 
 
     /**
      * A synonym for <tt>depends</tt>. Set to true to transmit only new
      * or changed files.
      *
      * See the related attributes timediffmillis and timediffauto.
      *
      * @param newer if true only transfer newer files.
      */
     public void setNewer(boolean newer) {
         this.newerOnly = newer;
     }
 
     /**
      * number of milliseconds to add to the time on the remote machine
      * to get the time on the local machine.
      *
      * use in conjunction with <code>newer</code>
      *
      * @param timeDiffMillis number of milliseconds
      *
      * @since ant 1.6
      */
     public void setTimeDiffMillis(long timeDiffMillis) {
         this.timeDiffMillis = timeDiffMillis;
     }
 
     /**
      * &quot;true&quot; to find out automatically the time difference
      * between local and remote machine.
      *
      * This requires right to create
      * and delete a temporary file in the remote directory.
      *
      * @param timeDiffAuto true = find automatically the time diff
      *
      * @since ant 1.6
      */
     public void setTimeDiffAuto(boolean timeDiffAuto) {
         this.timeDiffAuto = timeDiffAuto;
     }
 
     /**
      * Set to true to preserve modification times for "gotten" files.
      *
      * @param preserveLastModified if true preserver modification times.
      */
     public void setPreserveLastModified(boolean preserveLastModified) {
         this.preserveLastModified = preserveLastModified;
     }
 
 
     /**
      * Set to true to transmit only files that are new or changed from their
      * remote counterparts. The default is to transmit all files.
      *
      * @param depends if true only transfer newer files.
      */
     public void setDepends(boolean depends) {
         this.newerOnly = depends;
     }
 
 
     /**
      * Sets the remote file separator character. This normally defaults to the
      * Unix standard forward slash, but can be manually overridden using this
      * call if the remote server requires some other separator. Only the first
      * character of the string is used.
      *
      * @param separator the file separator on the remote system.
      */
     public void setSeparator(String separator) {
         remoteFileSep = separator;
     }
 
 
     /**
      * Sets the file permission mode (Unix only) for files sent to the
      * server.
      *
      * @param theMode unix style file mode for the files sent to the remote
      *        system.
      */
     public void setChmod(String theMode) {
         this.chmod = theMode;
     }
 
 
     /**
      * Sets the default mask for file creation on a unix server.
      *
      * @param theUmask unix style umask for files created on the remote server.
      */
     public void setUmask(String theUmask) {
         this.umask = theUmask;
     }
 
 
     /**
      *  A set of files to upload or download
      *
      * @param set the set of files to be added to the list of files to be
      *        transferred.
      */
     public void addFileset(FileSet set) {
         filesets.addElement(set);
     }
 
 
     /**
      * Sets the FTP action to be taken. Currently accepts "put", "get", "del",
      * "mkdir", "chmod", "list", and "site".
      *
      * @deprecated since 1.5.x.
      *             setAction(String) is deprecated and is replaced with
      *      setAction(FTP.Action) to make Ant's Introspection mechanism do the
      *      work and also to encapsulate operations on the type in its own
      *      class.
      * @ant.attribute ignore="true"
      *
      * @param action the FTP action to be performed.
      *
      * @throws BuildException if the action is not a valid action.
      */
     public void setAction(String action) throws BuildException {
         log("DEPRECATED - The setAction(String) method has been deprecated."
             + " Use setAction(FTP.Action) instead.");
 
         Action a = new Action();
 
         a.setValue(action);
         this.action = a.getAction();
     }
 
 
     /**
      * Sets the FTP action to be taken. Currently accepts "put", "get", "del",
      * "mkdir", "chmod", "list", and "site".
      *
      * @param action the FTP action to be performed.
      *
      * @throws BuildException if the action is not a valid action.
      */
     public void setAction(Action action) throws BuildException {
         this.action = action.getAction();
     }
 
 
     /**
      * The output file for the "list" action. This attribute is ignored for
      * any other actions.
      *
      * @param listing file in which to store the listing.
      */
     public void setListing(File listing) {
         this.listing = listing;
     }
 
 
     /**
      * If true, enables unsuccessful file put, delete and get
      * operations to be skipped with a warning and the remainder
      * of the files still transferred.
      *
      * @param skipFailedTransfers true if failures in transfers are ignored.
      */
     public void setSkipFailedTransfers(boolean skipFailedTransfers) {
         this.skipFailedTransfers = skipFailedTransfers;
     }
 
 
     /**
      * set the flag to skip errors on directory creation.
      * (and maybe later other server specific errors)
      *
      * @param ignoreNoncriticalErrors true if non-critical errors should not
      *        cause a failure.
      */
     public void setIgnoreNoncriticalErrors(boolean ignoreNoncriticalErrors) {
         this.ignoreNoncriticalErrors = ignoreNoncriticalErrors;
     }
 
     private void configurationHasBeenSet() {
         this.isConfigurationSet = true;
     }
 
     /**
      * Sets the systemTypeKey attribute.
      * Method for setting <code>FTPClientConfig</code> remote system key.
      *
      * @param systemKey the key to be set - BUT if blank
      * the default value of null (which signifies "autodetect") will be kept.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setSystemTypeKey(FTPSystemType systemKey) {
         if (systemKey != null && !systemKey.getValue().equals("")) {
             this.systemTypeKey = systemKey;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the defaultDateFormatConfig attribute.
      * @param defaultDateFormat configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setDefaultDateFormatConfig(String defaultDateFormat) {
         if (defaultDateFormat != null && !defaultDateFormat.equals("")) {
             this.defaultDateFormatConfig = defaultDateFormat;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the recentDateFormatConfig attribute.
      * @param recentDateFormat configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setRecentDateFormatConfig(String recentDateFormat) {
         if (recentDateFormat != null && !recentDateFormat.equals("")) {
             this.recentDateFormatConfig = recentDateFormat;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the serverLanguageCode attribute.
      * @param serverLanguageCode configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setServerLanguageCodeConfig(LanguageCode serverLanguageCode) {
         if (serverLanguageCode != null && !"".equals(serverLanguageCode.getValue())) {
             this.serverLanguageCodeConfig = serverLanguageCode;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the serverTimeZoneConfig attribute.
      * @param serverTimeZoneId configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setServerTimeZoneConfig(String serverTimeZoneId) {
         if (serverTimeZoneId != null && !serverTimeZoneId.equals("")) {
             this.serverTimeZoneConfig = serverTimeZoneId;
             configurationHasBeenSet();
         }
     }
 
     /**
      * Sets the shortMonthNamesConfig attribute
      *
      * @param shortMonthNames configuration to be set, unless it is
      * null or empty string, in which case ignored.
      * @see org.apache.commons.net.ftp.FTPClientConfig
      */
     public void setShortMonthNamesConfig(String shortMonthNames) {
         if (shortMonthNames != null && !shortMonthNames.equals("")) {
             this.shortMonthNamesConfig = shortMonthNames;
             configurationHasBeenSet();
         }
     }
 
 
 
     /**
      * Defines how many times to retry executing FTP command before giving up.
      * Default is 0 - try once and if failure then give up.
      *
      * @param retriesAllowed number of retries to allow.  -1 means
      * keep trying forever. "forever" may also be specified as a
      * synonym for -1.
      */
     public void setRetriesAllowed(String retriesAllowed) {
         if ("FOREVER".equalsIgnoreCase(retriesAllowed)) {
             this.retriesAllowed = Retryable.RETRY_FOREVER;
         } else {
             try {
                 int retries = Integer.parseInt(retriesAllowed);
                 if (retries < Retryable.RETRY_FOREVER) {
                     throw new BuildException(
                                              "Invalid value for retriesAllowed attribute: "
                                              + retriesAllowed);
 
                 }
                 this.retriesAllowed = retries;
             } catch (NumberFormatException px) {
                 throw new BuildException(
                                          "Invalid value for retriesAllowed attribute: "
                                          + retriesAllowed);
 
             }
 
         }
     }
     /**
      * @return Returns the systemTypeKey.
      */
     public String getSystemTypeKey() {
         return systemTypeKey.getValue();
     }
     /**
      * @return Returns the defaultDateFormatConfig.
      */
     public String getDefaultDateFormatConfig() {
         return defaultDateFormatConfig;
     }
     /**
      * @return Returns the recentDateFormatConfig.
      */
     public String getRecentDateFormatConfig() {
         return recentDateFormatConfig;
     }
     /**
      * @return Returns the serverLanguageCodeConfig.
      */
     public String getServerLanguageCodeConfig() {
         return serverLanguageCodeConfig.getValue();
     }
     /**
      * @return Returns the serverTimeZoneConfig.
      */
     public String getServerTimeZoneConfig() {
         return serverTimeZoneConfig;
     }
     /**
      * @return Returns the shortMonthNamesConfig.
      */
     public String getShortMonthNamesConfig() {
         return shortMonthNamesConfig;
     }
     /**
      * @return Returns the timestampGranularity.
      */
     Granularity getTimestampGranularity() {
         return timestampGranularity;
     }
     /**
      * Sets the timestampGranularity attribute
      * @param timestampGranularity The timestampGranularity to set.
      */
     public void setTimestampGranularity(Granularity timestampGranularity) {
         if (null == timestampGranularity || "".equals(timestampGranularity.getValue())) {
             return;
         }
         this.timestampGranularity = timestampGranularity;
     }
     /**
      * Sets the siteCommand attribute.  This attribute
      * names the command that will be executed if the action
      * is "site".
      * @param siteCommand The siteCommand to set.
      */
     public void setSiteCommand(String siteCommand) {
         this.siteCommand = siteCommand;
     }
     /**
      * Sets the initialSiteCommand attribute.  This attribute
      * names a site command that will be executed immediately
      * after connection.
      * @param initialCommand The initialSiteCommand to set.
      */
     public void setInitialSiteCommand(String initialCommand) {
         this.initialSiteCommand = initialCommand;
     }
 
     /**
      * Whether to verify that data and control connections are
      * connected to the same remote host.
      *
      * @since Ant 1.8.0
      */
     public void setEnableRemoteVerification(boolean b) {
         enableRemoteVerification = b;
     }
 
     /**
      * Checks to see that all required parameters are set.
      *
      * @throws BuildException if the configuration is not valid.
      */
     protected void checkAttributes() throws BuildException {
         if (server == null) {
             throw new BuildException("server attribute must be set!");
         }
         if (userid == null) {
             throw new BuildException("userid attribute must be set!");
         }
         if (password == null) {
             throw new BuildException("password attribute must be set!");
         }
 
         if ((action == LIST_FILES) && (listing == null)) {
             throw new BuildException("listing attribute must be set for list "
                                      + "action!");
         }
 
         if (action == MK_DIR && remotedir == null) {
             throw new BuildException("remotedir attribute must be set for "
                                      + "mkdir action!");
         }
 
         if (action == CHMOD && chmod == null) {
             throw new BuildException("chmod attribute must be set for chmod "
                                      + "action!");
         }
         if (action == SITE_CMD && siteCommand == null) {
             throw new BuildException("sitecommand attribute must be set for site "
                                      + "action!");
         }
 
 
         if (this.isConfigurationSet) {
             try {
                 Class.forName("org.apache.commons.net.ftp.FTPClientConfig");
             } catch (ClassNotFoundException e) {
                 throw new BuildException(
                                          "commons-net.jar >= 1.4.0 is required for at least one"
                                          + " of the attributes specified.");
             }
         }
     }
 
     /**
      * Executable a retryable object.
      * @param h the retry hander.
      * @param r the object that should be retried until it succeeds
      *          or the number of retrys is reached.
      * @param descr a description of the command that is being run.
      * @throws IOException if there is a problem.
      */
     protected void executeRetryable(RetryHandler h, Retryable r, String descr)
         throws IOException {
         h.execute(r, descr);
     }
 
 
     /**
      * For each file in the fileset, do the appropriate action: send, get,
      * delete, or list.
      *
      * @param ftp the FTPClient instance used to perform FTP actions
      * @param fs the fileset on which the actions are performed.
      *
      * @return the number of files to be transferred.
      *
      * @throws IOException if there is a problem reading a file
      * @throws BuildException if there is a problem in the configuration.
      */
     protected int transferFiles(final FTPClient ftp, FileSet fs)
         throws IOException, BuildException {
         DirectoryScanner ds;
         if (action == SEND_FILES) {
             ds = fs.getDirectoryScanner(getProject());
         } else {
             ds = new FTPDirectoryScanner(ftp);
             fs.setupDirectoryScanner(ds, getProject());
             ds.setFollowSymlinks(fs.isFollowSymlinks());
             ds.scan();
         }
 
         String[] dsfiles = null;
         if (action == RM_DIR) {
             dsfiles = ds.getIncludedDirectories();
         } else {
             dsfiles = ds.getIncludedFiles();
         }
         String dir = null;
 
         if ((ds.getBasedir() == null)
             && ((action == SEND_FILES) || (action == GET_FILES))) {
             throw new BuildException("the dir attribute must be set for send "
                                      + "and get actions");
         } else {
             if ((action == SEND_FILES) || (action == GET_FILES)) {
                 dir = ds.getBasedir().getAbsolutePath();
             }
         }
 
         // If we are doing a listing, we need the output stream created now.
         BufferedWriter bw = null;
 
         try {
             if (action == LIST_FILES) {
                 File pd = listing.getParentFile();
 
                 if (!pd.exists()) {
                     pd.mkdirs();
                 }
                 bw = new BufferedWriter(new FileWriter(listing));
             }
             RetryHandler h = new RetryHandler(this.retriesAllowed, this);
             if (action == RM_DIR) {
                 // to remove directories, start by the end of the list
                 // the trunk does not let itself be removed before the leaves
                 for (int i = dsfiles.length - 1; i >= 0; i--) {
                     final String dsfile = dsfiles[i];
                     executeRetryable(h, new Retryable() {
                             public void execute() throws IOException {
                                 rmDir(ftp, dsfile);
                             }
                         }, dsfile);
                 }
             } else {
                 final BufferedWriter fbw = bw;
                 final String fdir = dir;
                 if (this.newerOnly) {
                     this.granularityMillis =
                         this.timestampGranularity.getMilliseconds(action);
                 }
                 for (int i = 0; i < dsfiles.length; i++) {
                     final String dsfile = dsfiles[i];
                     executeRetryable(h, new Retryable() {
                             public void execute() throws IOException {
                                 switch (action) {
                                 case SEND_FILES:
                                     sendFile(ftp, fdir, dsfile);
                                     break;
                                 case GET_FILES:
                                     getFile(ftp, fdir, dsfile);
                                     break;
                                 case DEL_FILES:
                                     delFile(ftp, dsfile);
                                     break;
                                 case LIST_FILES:
                                     listFile(ftp, fbw, dsfile);
                                     break;
                                 case CHMOD:
                                     doSiteCommand(ftp, "chmod " + chmod
                                                   + " " + resolveFile(dsfile));
                                     transferred++;
                                     break;
                                 default:
                                     throw new BuildException("unknown ftp action " + action);
                                 }
                             }
                         }, dsfile);
                 }
             }
         } finally {
             FileUtils.close(bw);
         }
 
         return dsfiles.length;
     }
 
 
     /**
      * Sends all files specified by the configured filesets to the remote
      * server.
      *
      * @param ftp the FTPClient instance used to perform FTP actions
      *
      * @throws IOException if there is a problem reading a file
      * @throws BuildException if there is a problem in the configuration.
      */
     protected void transferFiles(FTPClient ftp)
         throws IOException, BuildException {
         transferred = 0;
         skipped = 0;
 
         if (filesets.size() == 0) {
             throw new BuildException("at least one fileset must be specified.");
         } else {
             // get files from filesets
-            for (int i = 0; i < filesets.size(); i++) {
+            final int size = filesets.size();
+            for (int i = 0; i < size; i++) {
                 FileSet fs = (FileSet) filesets.elementAt(i);
 
                 if (fs != null) {
                     transferFiles(ftp, fs);
                 }
             }
         }
 
         log(transferred + " " + ACTION_TARGET_STRS[action] + " "
             + COMPLETED_ACTION_STRS[action]);
         if (skipped != 0) {
             log(skipped + " " + ACTION_TARGET_STRS[action]
                 + " were not successfully " + COMPLETED_ACTION_STRS[action]);
         }
     }
 
 
     /**
      * Correct a file path to correspond to the remote host requirements. This
      * implementation currently assumes that the remote end can handle
      * Unix-style paths with forward-slash separators. This can be overridden
      * with the <code>separator</code> task parameter. No attempt is made to
      * determine what syntax is appropriate for the remote host.
      *
      * @param file the remote file name to be resolved
      *
      * @return the filename as it will appear on the server.
      */
     protected String resolveFile(String file) {
         return file.replace(System.getProperty("file.separator").charAt(0),
                             remoteFileSep.charAt(0));
     }
 
 
     /**
      * Creates all parent directories specified in a complete relative
      * pathname. Attempts to create existing directories will not cause
      * errors.
      *
      * @param ftp the FTP client instance to use to execute FTP actions on
      *        the remote server.
      * @param filename the name of the file whose parents should be created.
      * @throws IOException under non documented circumstances
      * @throws BuildException if it is impossible to cd to a remote directory
      *
      */
     protected void createParents(FTPClient ftp, String filename)
         throws IOException, BuildException {
 
         File dir = new File(filename);
         if (dirCache.contains(dir)) {
             return;
         }
 
         Vector parents = new Vector();
         String dirname;
 
         while ((dirname = dir.getParent()) != null) {
             File checkDir = new File(dirname);
             if (dirCache.contains(checkDir)) {
                 break;
             }
             dir = checkDir;
             parents.addElement(dir);
         }
 
         // find first non cached dir
         int i = parents.size() - 1;
 
         if (i >= 0) {
             String cwd = ftp.printWorkingDirectory();
             String parent = dir.getParent();
             if (parent != null) {
                 if (!ftp.changeWorkingDirectory(resolveFile(parent))) {
                     throw new BuildException("could not change to "
                                              + "directory: " + ftp.getReplyString());
                 }
             }
 
             while (i >= 0) {
                 dir = (File) parents.elementAt(i--);
                 // check if dir exists by trying to change into it.
                 if (!ftp.changeWorkingDirectory(dir.getName())) {
                     // could not change to it - try to create it
                     log("creating remote directory "
                         + resolveFile(dir.getPath()), Project.MSG_VERBOSE);
                     if (!ftp.makeDirectory(dir.getName())) {
                         handleMkDirFailure(ftp);
                     }
                     if (!ftp.changeWorkingDirectory(dir.getName())) {
                         throw new BuildException("could not change to "
                                                  + "directory: " + ftp.getReplyString());
                     }
                 }
                 dirCache.add(dir);
             }
             ftp.changeWorkingDirectory(cwd);
         }
     }
     /**
      * auto find the time difference between local and remote
      * @param ftp handle to ftp client
      * @return number of millis to add to remote time to make it comparable to local time
      * @since ant 1.6
      */
     private long getTimeDiff(FTPClient ftp) {
         long returnValue = 0;
         File tempFile = findFileName(ftp);
         try {
             // create a local temporary file
             FILE_UTILS.createNewFile(tempFile);
             long localTimeStamp = tempFile.lastModified();
             BufferedInputStream instream = new BufferedInputStream(new FileInputStream(tempFile));
             ftp.storeFile(tempFile.getName(), instream);
             instream.close();
             boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
             if (success) {
                 FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName());
                 if (ftpFiles.length == 1) {
                     long remoteTimeStamp = ftpFiles[0].getTimestamp().getTime().getTime();
                     returnValue = localTimeStamp - remoteTimeStamp;
                 }
                 ftp.deleteFile(ftpFiles[0].getName());
             }
             // delegate the deletion of the local temp file to the delete task
             // because of race conditions occuring on Windows
             Delete mydelete = new Delete();
             mydelete.bindToOwner(this);
             mydelete.setFile(tempFile.getCanonicalFile());
             mydelete.execute();
         } catch (Exception e) {
             throw new BuildException(e, getLocation());
         }
         return returnValue;
     }
     /**
      *  find a suitable name for local and remote temporary file
      */
     private File findFileName(FTPClient ftp) {
         FTPFile [] theFiles = null;
         final int maxIterations = 1000;
         for (int counter = 1; counter < maxIterations; counter++) {
             File localFile = FILE_UTILS.createTempFile(
                                                        "ant" + Integer.toString(counter), ".tmp",
                                                        null, false, false);
             String fileName = localFile.getName();
             boolean found = false;
             try {
                 if (theFiles == null) {
                     theFiles = ftp.listFiles();
                 }
                 for (int counter2 = 0; counter2 < theFiles.length; counter2++) {
                     if (theFiles[counter2] != null
                         && theFiles[counter2].getName().equals(fileName)) {
                         found = true;
                         break;
                     }
                 }
             } catch (IOException ioe) {
                 throw new BuildException(ioe, getLocation());
             }
             if (!found) {
                 localFile.deleteOnExit();
                 return localFile;
             }
         }
         return null;
     }
 
     /**
      * Checks to see if the remote file is current as compared with the local
      * file. Returns true if the target file is up to date.
      * @param ftp ftpclient
      * @param localFile local file
      * @param remoteFile remote file
      * @return true if the target file is up to date
      * @throws IOException  in unknown circumstances
      * @throws BuildException if the date of the remote files cannot be found and the action is
      * GET_FILES
      */
     protected boolean isUpToDate(FTPClient ftp, File localFile,
                                  String remoteFile)
         throws IOException, BuildException {
         log("checking date for " + remoteFile, Project.MSG_VERBOSE);
 
         FTPFile[] files = ftp.listFiles(remoteFile);
 
         // For Microsoft's Ftp-Service an Array with length 0 is
         // returned if configured to return listings in "MS-DOS"-Format
         if (files == null || files.length == 0) {
             // If we are sending files, then assume out of date.
             // If we are getting files, then throw an error
 
             if (action == SEND_FILES) {
                 log("Could not date test remote file: " + remoteFile
                     + "assuming out of date.", Project.MSG_VERBOSE);
                 return false;
             } else {
                 throw new BuildException("could not date test remote file: "
                                          + ftp.getReplyString());
             }
         }
 
         long remoteTimestamp = files[0].getTimestamp().getTime().getTime();
         long localTimestamp = localFile.lastModified();
         long adjustedRemoteTimestamp =
             remoteTimestamp + this.timeDiffMillis + this.granularityMillis;
 
         StringBuffer msg;
         synchronized(TIMESTAMP_LOGGING_SDF) {
             msg = new StringBuffer("   [")
                 .append(TIMESTAMP_LOGGING_SDF.format(new Date(localTimestamp)))
                 .append("] local");
         }
         log(msg.toString(), Project.MSG_VERBOSE);
 
         synchronized(TIMESTAMP_LOGGING_SDF) {
             msg = new StringBuffer("   [")
                 .append(TIMESTAMP_LOGGING_SDF.format(new Date(adjustedRemoteTimestamp)))
                 .append("] remote");
         }
         if (remoteTimestamp != adjustedRemoteTimestamp) {
             synchronized(TIMESTAMP_LOGGING_SDF) {
                 msg.append(" - (raw: ")
                     .append(TIMESTAMP_LOGGING_SDF.format(new Date(remoteTimestamp)))
                     .append(")");
             }
         }
         log(msg.toString(), Project.MSG_VERBOSE);
 
 
 
         if (this.action == SEND_FILES) {
             return adjustedRemoteTimestamp >= localTimestamp;
         } else {
             return localTimestamp >= adjustedRemoteTimestamp;
         }
     }
 
 
     /**
      * Sends a site command to the ftp server
      * @param ftp ftp client
      * @param theCMD command to execute
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void doSiteCommand(FTPClient ftp, String theCMD)
         throws IOException, BuildException {
         boolean rc;
         String[] myReply = null;
 
         log("Doing Site Command: " + theCMD, Project.MSG_VERBOSE);
 
         rc = ftp.sendSiteCommand(theCMD);
 
         if (!rc) {
             log("Failed to issue Site Command: " + theCMD, Project.MSG_WARN);
         } else {
 
             myReply = ftp.getReplyStrings();
 
             for (int x = 0; x < myReply.length; x++) {
                 if (myReply[x] != null && myReply[x].indexOf("200") == -1) {
                     log(myReply[x], Project.MSG_WARN);
                 }
             }
         }
     }
 
 
     /**
      * Sends a single file to the remote host. <code>filename</code> may
      * contain a relative path specification. When this is the case, <code>sendFile</code>
      * will attempt to create any necessary parent directories before sending
      * the file. The file will then be sent using the entire relative path
      * spec - no attempt is made to change directories. It is anticipated that
      * this may eventually cause problems with some FTP servers, but it
      * simplifies the coding.
      * @param ftp ftp client
      * @param dir base directory of the file to be sent (local)
      * @param filename relative path of the file to be send
      *        locally relative to dir
      *        remotely relative to the remotedir attribute
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void sendFile(FTPClient ftp, String dir, String filename)
         throws IOException, BuildException {
         InputStream instream = null;
 
         try {
             // XXX - why not simply new File(dir, filename)?
             File file = getProject().resolveFile(new File(dir, filename).getPath());
 
             if (newerOnly && isUpToDate(ftp, file, resolveFile(filename))) {
                 return;
             }
 
             if (verbose) {
                 log("transferring " + file.getAbsolutePath());
             }
 
             instream = new BufferedInputStream(new FileInputStream(file));
 
             createParents(ftp, filename);
 
             ftp.storeFile(resolveFile(filename), instream);
 
             boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
 
             if (!success) {
                 String s = "could not put file: " + ftp.getReplyString();
 
                 if (skipFailedTransfers) {
                     log(s, Project.MSG_WARN);
                     skipped++;
                 } else {
                     throw new BuildException(s);
                 }
 
             } else {
                 // see if we should issue a chmod command
                 if (chmod != null) {
                     doSiteCommand(ftp, "chmod " + chmod + " " + resolveFile(filename));
                 }
                 log("File " + file.getAbsolutePath() + " copied to " + server,
                     Project.MSG_VERBOSE);
                 transferred++;
             }
         } finally {
             FileUtils.close(instream);
         }
     }
 
 
     /**
      * Delete a file from the remote host.
      * @param ftp ftp client
      * @param filename file to delete
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is set to false
      * and the deletion could not be done
      */
     protected void delFile(FTPClient ftp, String filename)
         throws IOException, BuildException {
         if (verbose) {
             log("deleting " + filename);
         }
 
         if (!ftp.deleteFile(resolveFile(filename))) {
             String s = "could not delete file: " + ftp.getReplyString();
 
             if (skipFailedTransfers) {
                 log(s, Project.MSG_WARN);
                 skipped++;
             } else {
                 throw new BuildException(s);
             }
         } else {
             log("File " + filename + " deleted from " + server,
                 Project.MSG_VERBOSE);
             transferred++;
         }
     }
 
     /**
      * Delete a directory, if empty, from the remote host.
      * @param ftp ftp client
      * @param dirname directory to delete
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is set to false
      * and the deletion could not be done
      */
     protected void rmDir(FTPClient ftp, String dirname)
         throws IOException, BuildException {
         if (verbose) {
             log("removing " + dirname);
         }
 
         if (!ftp.removeDirectory(resolveFile(dirname))) {
             String s = "could not remove directory: " + ftp.getReplyString();
 
             if (skipFailedTransfers) {
                 log(s, Project.MSG_WARN);
                 skipped++;
             } else {
                 throw new BuildException(s);
             }
         } else {
             log("Directory " + dirname + " removed from " + server,
                 Project.MSG_VERBOSE);
             transferred++;
         }
     }
 
 
     /**
      * Retrieve a single file from the remote host. <code>filename</code> may
      * contain a relative path specification. <p>
      *
      * The file will then be retreived using the entire relative path spec -
      * no attempt is made to change directories. It is anticipated that this
      * may eventually cause problems with some FTP servers, but it simplifies
      * the coding.</p>
      * @param ftp the ftp client
      * @param dir local base directory to which the file should go back
      * @param filename relative path of the file based upon the ftp remote directory
      *        and/or the local base directory (dir)
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is false
      * and the file cannot be retrieved.
      */
     protected void getFile(FTPClient ftp, String dir, String filename)
         throws IOException, BuildException {
         OutputStream outstream = null;
         try {
             File file = getProject().resolveFile(new File(dir, filename).getPath());
 
             if (newerOnly && isUpToDate(ftp, file, resolveFile(filename))) {
                 return;
             }
 
             if (verbose) {
                 log("transferring " + filename + " to "
                     + file.getAbsolutePath());
             }
 
             File pdir = file.getParentFile();
 
             if (!pdir.exists()) {
                 pdir.mkdirs();
             }
             outstream = new BufferedOutputStream(new FileOutputStream(file));
             ftp.retrieveFile(resolveFile(filename), outstream);
 
             if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                 String s = "could not get file: " + ftp.getReplyString();
 
                 if (skipFailedTransfers) {
                     log(s, Project.MSG_WARN);
                     skipped++;
                 } else {
                     throw new BuildException(s);
                 }
 
             } else {
                 log("File " + file.getAbsolutePath() + " copied from "
                     + server, Project.MSG_VERBOSE);
                 transferred++;
                 if (preserveLastModified) {
                     outstream.close();
                     outstream = null;
                     FTPFile[] remote = ftp.listFiles(resolveFile(filename));
                     if (remote.length > 0) {
                         FILE_UTILS.setFileLastModified(file,
                                                        remote[0].getTimestamp()
                                                        .getTime().getTime());
                     }
                 }
             }
         } finally {
             FileUtils.close(outstream);
         }
     }
 
 
     /**
      * List information about a single file from the remote host. <code>filename</code>
      * may contain a relative path specification. <p>
      *
      * The file listing will then be retrieved using the entire relative path
      * spec - no attempt is made to change directories. It is anticipated that
      * this may eventually cause problems with some FTP servers, but it
      * simplifies the coding.</p>
      * @param ftp ftp client
      * @param bw buffered writer
      * @param filename the directory one wants to list
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void listFile(FTPClient ftp, BufferedWriter bw, String filename)
         throws IOException, BuildException {
         if (verbose) {
             log("listing " + filename);
         }
         FTPFile[] ftpfiles = ftp.listFiles(resolveFile(filename));
 
         if (ftpfiles != null && ftpfiles.length > 0) {
             bw.write(ftpfiles[0].toString());
             bw.newLine();
             transferred++;
         }
     }
 
 
     /**
      * Create the specified directory on the remote host.
      *
      * @param ftp The FTP client connection
      * @param dir The directory to create (format must be correct for host
      *      type)
      * @throws IOException  in unknown circumstances
      * @throws BuildException if ignoreNoncriticalErrors has not been set to true
      *         and a directory could not be created, for instance because it was
      *         already existing. Precisely, the codes 521, 550 and 553 will trigger
      *         a BuildException
      */
     protected void makeRemoteDir(FTPClient ftp, String dir)
         throws IOException, BuildException {
         String workingDirectory = ftp.printWorkingDirectory();
         if (verbose) {
             if (dir.indexOf("/") == 0 || workingDirectory == null) {
                 log("Creating directory: " + dir + " in /");
             } else {
                 log("Creating directory: " + dir + " in " + workingDirectory);
             }
         }
         if (dir.indexOf("/") == 0) {
             ftp.changeWorkingDirectory("/");
         }
         String subdir = "";
         StringTokenizer st = new StringTokenizer(dir, "/");
         while (st.hasMoreTokens()) {
             subdir = st.nextToken();
             log("Checking " + subdir, Project.MSG_DEBUG);
             if (!ftp.changeWorkingDirectory(subdir)) {
                 if (!ftp.makeDirectory(subdir)) {
                     // codes 521, 550 and 553 can be produced by FTP Servers
                     //  to indicate that an attempt to create a directory has
                     //  failed because the directory already exists.
                     int rc = ftp.getReplyCode();
                     if (!(ignoreNoncriticalErrors
                           && (rc == FTPReply.CODE_550 || rc == FTPReply.CODE_553
                               || rc == CODE_521))) {
                         throw new BuildException("could not create directory: "
                                                  + ftp.getReplyString());
                     }
                     if (verbose) {
                         log("Directory already exists");
                     }
                 } else {
                     if (verbose) {
                         log("Directory created OK");
                     }
                     ftp.changeWorkingDirectory(subdir);
                 }
             }
         }
         if (workingDirectory != null) {
             ftp.changeWorkingDirectory(workingDirectory);
         }
     }
 
     /**
      * look at the response for a failed mkdir action, decide whether
      * it matters or not. If it does, we throw an exception
      * @param ftp current ftp connection
      * @throws BuildException if this is an error to signal
      */
     private void handleMkDirFailure(FTPClient ftp)
         throws BuildException {
         int rc = ftp.getReplyCode();
         if (!(ignoreNoncriticalErrors
               && (rc == FTPReply.CODE_550 || rc == FTPReply.CODE_553 || rc == CODE_521))) {
             throw new BuildException("could not create directory: "
                                      + ftp.getReplyString());
         }
     }
 
     /**
      * Runs the task.
      *
      * @throws BuildException if the task fails or is not configured
      *         correctly.
      */
     public void execute() throws BuildException {
         checkAttributes();
 
         FTPClient ftp = null;
 
         try {
             log("Opening FTP connection to " + server, Project.MSG_VERBOSE);
 
             ftp = new FTPClient();
             if (this.isConfigurationSet) {
                 ftp = FTPConfigurator.configure(ftp, this);
             }
 
             ftp.setRemoteVerificationEnabled(enableRemoteVerification);
             ftp.connect(server, port);
             if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                 throw new BuildException("FTP connection failed: "
                                          + ftp.getReplyString());
             }
 
             log("connected", Project.MSG_VERBOSE);
             log("logging in to FTP server", Project.MSG_VERBOSE);
 
             if ((this.account != null && !ftp.login(userid, password, account))
                 || (this.account == null && !ftp.login(userid, password))) {
                 throw new BuildException("Could not login to FTP server");
             }
 
             log("login succeeded", Project.MSG_VERBOSE);
 
             if (binary) {
                 ftp.setFileType(org.apache.commons.net.ftp.FTP.BINARY_FILE_TYPE);
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not set transfer type: "
                                              + ftp.getReplyString());
                 }
             } else {
                 ftp.setFileType(org.apache.commons.net.ftp.FTP.ASCII_FILE_TYPE);
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not set transfer type: "
                                              + ftp.getReplyString());
                 }
             }
 
             if (passive) {
                 log("entering passive mode", Project.MSG_VERBOSE);
                 ftp.enterLocalPassiveMode();
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not enter into passive "
                                              + "mode: " + ftp.getReplyString());
                 }
             }
 
             // If an initial command was configured then send it.
             // Some FTP servers offer different modes of operation,
             // E.G. switching between a UNIX file system mode and
             // a legacy file system.
             if (this.initialSiteCommand != null) {
                 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, FTP.this.initialSiteCommand);
                         }
                     }, "initial site command: " + this.initialSiteCommand);
             }
 
 
             // For a unix ftp server you can set the default mask for all files
             // created.
 
             if (umask != null) {
                 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, "umask " + umask);
                         }
                     }, "umask " + umask);
             }
 
             // If the action is MK_DIR, then the specified remote
             // directory is the directory to create.
 
             if (action == MK_DIR) {
                 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             makeRemoteDir(lftp, remotedir);
                         }
                     }, remotedir);
             } else if (action == SITE_CMD) {
                 RetryHandler h = new RetryHandler(this.retriesAllowed, this);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, FTP.this.siteCommand);
                         }
                     }, "Site Command: " + this.siteCommand);
             } else {
                 if (remotedir != null) {
                     log("changing the remote directory to " + remotedir,
                         Project.MSG_VERBOSE);
                     ftp.changeWorkingDirectory(remotedir);
                     if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                         throw new BuildException("could not change remote "
                                                  + "directory: " + ftp.getReplyString());
                     }
                 }
                 if (newerOnly && timeDiffAuto) {
                     // in this case we want to find how much time span there is between local
                     // and remote
                     timeDiffMillis = getTimeDiff(ftp);
                 }
                 log(ACTION_STRS[action] + " " + ACTION_TARGET_STRS[action]);
                 transferFiles(ftp);
             }
 
         } catch (IOException ex) {
             throw new BuildException("error during FTP transfer: " + ex, ex);
         } finally {
             if (ftp != null && ftp.isConnected()) {
                 try {
                     log("disconnecting", Project.MSG_VERBOSE);
                     ftp.logout();
                     ftp.disconnect();
                 } catch (IOException ex) {
                     // ignore it
                 }
             }
         }
     }
 
 
     /**
      * an action to perform, one of
      * "send", "put", "recv", "get", "del", "delete", "list", "mkdir", "chmod",
      * "rmdir"
      */
     public static class Action extends EnumeratedAttribute {
 
         private static final String[] VALID_ACTIONS = {
             "send", "put", "recv", "get", "del", "delete", "list", "mkdir",
             "chmod", "rmdir", "site"
         };
 
 
         /**
          * Get the valid values
          *
          * @return an array of the valid FTP actions.
          */
         public String[] getValues() {
             return VALID_ACTIONS;
         }
 
 
         /**
          * Get the symbolic equivalent of the action value.
          *
          * @return the SYMBOL representing the given action.
          */
         public int getAction() {
             String actionL = getValue().toLowerCase(Locale.ENGLISH);
             if (actionL.equals("send") || actionL.equals("put")) {
                 return SEND_FILES;
             } else if (actionL.equals("recv") || actionL.equals("get")) {
                 return GET_FILES;
             } else if (actionL.equals("del") || actionL.equals("delete")) {
                 return DEL_FILES;
             } else if (actionL.equals("list")) {
                 return LIST_FILES;
             } else if (actionL.equals("chmod")) {
                 return CHMOD;
             } else if (actionL.equals("mkdir")) {
                 return MK_DIR;
             } else if (actionL.equals("rmdir")) {
                 return RM_DIR;
             } else if (actionL.equals("site")) {
                 return SITE_CMD;
             }
             return SEND_FILES;
         }
     }
     /**
      * represents one of the valid timestamp adjustment values
      * recognized by the <code>timestampGranularity</code> attribute.<p>
 
      * A timestamp adjustment may be used in file transfers for checking
      * uptodateness. MINUTE means to add one minute to the server
      * timestamp.  This is done because FTP servers typically list
      * timestamps HH:mm and client FileSystems typically use HH:mm:ss.
      *
      * The default is to use MINUTE for PUT actions and NONE for GET
      * actions, since GETs have the <code>preserveLastModified</code>
      * option, which takes care of the problem in most use cases where
      * this level of granularity is an issue.
      *
      */
     public static class Granularity extends EnumeratedAttribute {
 
         private static final String[] VALID_GRANULARITIES = {
             "", "MINUTE", "NONE"
         };
 
         /**
          * Get the valid values.
          * @return the list of valid Granularity values
          */
         public String[] getValues() {
             return VALID_GRANULARITIES;
         }
         /**
          * returns the number of milliseconds associated with
          * the attribute, which can vary in some cases depending
          * on the value of the action parameter.
          * @param action SEND_FILES or GET_FILES
          * @return the number of milliseconds associated with
          * the attribute, in the context of the supplied action
          */
         public long getMilliseconds(int action) {
             String granularityU = getValue().toUpperCase(Locale.ENGLISH);
             if ("".equals(granularityU)) {
                 if (action == SEND_FILES) {
                     return GRANULARITY_MINUTE;
                 }
             } else if ("MINUTE".equals(granularityU)) {
                 return GRANULARITY_MINUTE;
             }
             return 0L;
         }
         static final Granularity getDefault() {
             Granularity g = new Granularity();
             g.setValue("");
             return g;
         }
 
     }
     /**
      * one of the valid system type keys recognized by the systemTypeKey
      * attribute.
      */
     public static class FTPSystemType extends EnumeratedAttribute {
 
         private static final String[] VALID_SYSTEM_TYPES = {
             "", "UNIX", "VMS", "WINDOWS", "OS/2", "OS/400",
             "MVS"
         };
 
 
         /**
          * Get the valid values.
          * @return the list of valid system types.
          */
         public String[] getValues() {
             return VALID_SYSTEM_TYPES;
         }
 
         static final FTPSystemType getDefault() {
             FTPSystemType ftpst = new FTPSystemType();
             ftpst.setValue("");
             return ftpst;
         }
     }
     /**
      * Enumerated class for languages.
      */
     public static class LanguageCode extends EnumeratedAttribute {
 
 
         private static final String[] VALID_LANGUAGE_CODES =
             getValidLanguageCodes();
 
         private static String[] getValidLanguageCodes() {
             Collection c = FTPClientConfig.getSupportedLanguageCodes();
             String[] ret = new String[c.size() + 1];
             int i = 0;
             ret[i++] = "";
             for (Iterator it = c.iterator(); it.hasNext(); i++) {
                 ret[i] = (String) it.next();
             }
             return ret;
         }
 
 
         /**
          * Return the value values.
          * @return the list of valid language types.
          */
         public String[] getValues() {
             return VALID_LANGUAGE_CODES;
         }
 
         static final LanguageCode getDefault() {
             LanguageCode lc = new LanguageCode();
             lc.setValue("");
             return lc;
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/net/FTPTaskMirrorImpl.java b/src/main/org/apache/tools/ant/taskdefs/optional/net/FTPTaskMirrorImpl.java
index 802c24290..3c250d26a 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/net/FTPTaskMirrorImpl.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/net/FTPTaskMirrorImpl.java
@@ -1,1943 +1,1946 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.net;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Hashtable;
 import java.util.Map;
 import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.Vector;
 
 import org.apache.commons.net.ftp.FTPClient;
 import org.apache.commons.net.ftp.FTPFile;
 import org.apache.commons.net.ftp.FTPReply;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.Delete;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.selectors.SelectorUtils;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.RetryHandler;
 import org.apache.tools.ant.util.Retryable;
 import org.apache.tools.ant.util.VectorSet;
 
 public class FTPTaskMirrorImpl implements FTPTaskMirror {
 
     /** return code of ftp - not implemented in commons-net version 1.0 */
     private static final int CODE_521 = 521;
 
     /** Date formatter used in logging, note not thread safe! */
     private static final SimpleDateFormat TIMESTAMP_LOGGING_SDF =
         new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     private final FTPTask task;
     private Set dirCache = new HashSet();
     private int transferred = 0;
     private int skipped = 0;
 
     /**
      * Constructor.
      * @param task the FTPTask that uses this mirror.
      */
     public FTPTaskMirrorImpl(FTPTask task) {
         this.task = task;
     }
 
     /**
      * internal class providing a File-like interface to some of the information
      * available from the FTP server
      *
      */
     protected static class FTPFileProxy extends File {
 
         private final FTPFile file;
         private final String[] parts;
         private final String name;
 
         /**
          * creates a proxy to a FTP file
          * @param file
          */
         public FTPFileProxy(FTPFile file) {
             super(file.getName());
             name = file.getName();
             this.file = file;
             parts = FileUtils.getPathStack(name);
         }
 
         /**
          * creates a proxy to a FTP directory
          * @param completePath the remote directory.
          */
         public FTPFileProxy(String completePath) {
             super(completePath);
             file = null;
             name = completePath;
             parts = FileUtils.getPathStack(completePath);
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#exists()
          */
         public boolean exists() {
             return true;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getAbsolutePath()
          */
         public String getAbsolutePath() {
             return name;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getName()
          */
         public String getName() {
             return parts.length > 0 ? parts[parts.length - 1] : name;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getParent()
          */
         public String getParent() {
             String result = "";
             for(int i = 0; i < parts.length - 1; i++){
                 result += File.separatorChar + parts[i];
             }
             return result;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#getPath()
          */
         public String getPath() {
             return name;
         }
 
 
         /**
          * FTP files are stored as absolute paths
          * @return true
          */
         public boolean isAbsolute() {
             return true;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#isDirectory()
          */
         public boolean isDirectory() {
             return file == null;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#isFile()
          */
         public boolean isFile() {
             return file != null;
         }
 
 
         /**
          * FTP files cannot be hidden
          *
          * @return  false
          */
         public boolean isHidden() {
             return false;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#lastModified()
          */
         public long lastModified() {
             if (file != null) {
                 return file.getTimestamp().getTimeInMillis();
             }
             return 0;
         }
 
 
         /* (non-Javadoc)
          * @see java.io.File#length()
          */
         public long length() {
             if (file != null) {
                 return file.getSize();
             }
             return 0;
         }
     }
 
     /**
      * internal class allowing to read the contents of a remote file system
      * using the FTP protocol
      * used in particular for ftp get operations
      * differences with DirectoryScanner
      * "" (the root of the fileset) is never included in the included directories
      * followSymlinks defaults to false
      */
     protected class FTPDirectoryScanner extends DirectoryScanner {
         // CheckStyle:VisibilityModifier OFF - bc
         protected FTPClient ftp = null;
         // CheckStyle:VisibilityModifier ON
 
         private String rootPath = null;
 
         /**
          * since ant 1.6
          * this flag should be set to true on UNIX and can save scanning time
          */
         private boolean remoteSystemCaseSensitive = false;
         private boolean remoteSensitivityChecked = false;
 
         /**
          * constructor
          * @param ftp  ftpclient object
          */
         public FTPDirectoryScanner(FTPClient ftp) {
             super();
             this.ftp = ftp;
             this.setFollowSymlinks(false);
         }
 
 
         /**
          * scans the remote directory,
          * storing internally the included files, directories, ...
          */
         public void scan() {
             if (includes == null) {
                 // No includes supplied, so set it to 'matches all'
                 includes = new String[1];
                 includes[0] = "**";
             }
             if (excludes == null) {
                 excludes = new String[0];
             }
 
             filesIncluded = new VectorSet();
             filesNotIncluded = new Vector();
             filesExcluded = new VectorSet();
             dirsIncluded = new VectorSet();
             dirsNotIncluded = new Vector();
             dirsExcluded = new VectorSet();
 
             try {
                 String cwd = ftp.printWorkingDirectory();
                 // always start from the current ftp working dir
                 forceRemoteSensitivityCheck();
 
                 checkIncludePatterns();
                 clearCaches();
                 ftp.changeWorkingDirectory(cwd);
             } catch (IOException e) {
                 throw new BuildException("Unable to scan FTP server: ", e);
             }
         }
 
 
         /**
          * this routine is actually checking all the include patterns in
          * order to avoid scanning everything under base dir
          * @since ant1.6
          */
         private void checkIncludePatterns() {
 
             Hashtable newroots = new Hashtable();
             // put in the newroots vector the include patterns without
             // wildcard tokens
             for (int icounter = 0; icounter < includes.length; icounter++) {
                 String newpattern =
                     SelectorUtils.rtrimWildcardTokens(includes[icounter]);
                 newroots.put(newpattern, includes[icounter]);
             }
             if (task.getRemotedir() == null) {
                 try {
                     task.setRemotedir(ftp.printWorkingDirectory());
                 } catch (IOException e) {
                     throw new BuildException("could not read current ftp directory",
                                              task.getLocation());
                 }
             }
             AntFTPFile baseFTPFile = new AntFTPRootFile(ftp, task.getRemotedir());
             rootPath = baseFTPFile.getAbsolutePath();
             // construct it
             if (newroots.containsKey("")) {
                 // we are going to scan everything anyway
                 scandir(rootPath, "", true);
             } else {
                 // only scan directories that can include matched files or
                 // directories
                 Enumeration enum2 = newroots.keys();
 
                 while (enum2.hasMoreElements()) {
                     String currentelement = (String) enum2.nextElement();
                     String originalpattern = (String) newroots.get(currentelement);
                     AntFTPFile myfile = new AntFTPFile(baseFTPFile, currentelement);
                     boolean isOK = true;
                     boolean traversesSymlinks = false;
                     String path = null;
 
                     if (myfile.exists()) {
                         forceRemoteSensitivityCheck();
                         if (remoteSensitivityChecked
                             && remoteSystemCaseSensitive && isFollowSymlinks()) {
                             // cool case,
                             //we do not need to scan all the subdirs in the relative path
                             path = myfile.getFastRelativePath();
                         } else {
                             // may be on a case insensitive file system.  We want
                             // the results to show what's really on the disk, so
                             // we need to double check.
                             try {
                                 path = myfile.getRelativePath();
                                 traversesSymlinks = myfile.isTraverseSymlinks();
                             }  catch (IOException be) {
                                 throw new BuildException(be, task.getLocation());
                             } catch (BuildException be) {
                                 isOK = false;
                             }
                         }
                     } else {
                         isOK = false;
                     }
                     if (isOK) {
                         currentelement = path.replace(task.getSeparator().charAt(0), File.separatorChar);
                         if (!isFollowSymlinks()
                             && traversesSymlinks) {
                             continue;
                         }
 
                         if (myfile.isDirectory()) {
                             if (isIncluded(currentelement)
                                 && currentelement.length() > 0) {
                                 accountForIncludedDir(currentelement, myfile, true);
                             }  else {
                                 if (currentelement.length() > 0) {
                                     if (currentelement.charAt(currentelement
                                                               .length() - 1)
                                         != File.separatorChar) {
                                         currentelement =
                                             currentelement + File.separatorChar;
                                     }
                                 }
                                 scandir(myfile.getAbsolutePath(), currentelement, true);
                             }
                         } else {
                             if (isCaseSensitive
                                 && originalpattern.equals(currentelement)) {
                                 accountForIncludedFile(currentelement);
                             } else if (!isCaseSensitive
                                        && originalpattern
                                        .equalsIgnoreCase(currentelement)) {
                                 accountForIncludedFile(currentelement);
                             }
                         }
                     }
                 }
             }
         }
         /**
          * scans a particular directory. populates the scannedDirs cache.
          *
          * @param dir directory to scan
          * @param vpath  relative path to the base directory of the remote fileset
          * always ended with a File.separator
          * @param fast seems to be always true in practice
          */
         protected void scandir(String dir, String vpath, boolean fast) {
             // avoid double scanning of directories, can only happen in fast mode
             if (fast && hasBeenScanned(vpath)) {
                 return;
             }
             try {
                 if (!ftp.changeWorkingDirectory(dir)) {
                     return;
                 }
                 String completePath = null;
                 if (!vpath.equals("")) {
                     completePath = rootPath + task.getSeparator()
                         + vpath.replace(File.separatorChar, task.getSeparator().charAt(0));
                 } else {
                     completePath = rootPath;
                 }
                 FTPFile[] newfiles = listFiles(completePath, false);
 
                 if (newfiles == null) {
                     ftp.changeToParentDirectory();
                     return;
                 }
                 for (int i = 0; i < newfiles.length; i++) {
                     FTPFile file = newfiles[i];
                     if (file != null
                         && !file.getName().equals(".")
                         && !file.getName().equals("..")) {
                         String name = vpath + file.getName();
                         scannedDirs.put(name, new FTPFileProxy(file));
                         if (isFunctioningAsDirectory(ftp, dir, file)) {
                             boolean slowScanAllowed = true;
                             if (!isFollowSymlinks() && file.isSymbolicLink()) {
                                 dirsExcluded.addElement(name);
                                 slowScanAllowed = false;
                             } else if (isIncluded(name)) {
                                 accountForIncludedDir(name,
                                                       new AntFTPFile(ftp, file, completePath) , fast);
                             } else {
                                 dirsNotIncluded.addElement(name);
                                 if (fast && couldHoldIncluded(name)) {
                                     scandir(file.getName(),
                                             name + File.separator, fast);
                                 }
                             }
                             if (!fast && slowScanAllowed) {
                                 scandir(file.getName(),
                                         name + File.separator, fast);
                             }
                         } else {
                             if (!isFollowSymlinks() && file.isSymbolicLink()) {
                                 filesExcluded.addElement(name);
                             } else if (isFunctioningAsFile(ftp, dir, file)) {
                                 accountForIncludedFile(name);
                             }
                         }
                     }
                 }
                 ftp.changeToParentDirectory();
             } catch (IOException e) {
                 throw new BuildException("Error while communicating with FTP "
                                          + "server: ", e);
             }
         }
         /**
          * process included file
          * @param name  path of the file relative to the directory of the fileset
          */
         private void accountForIncludedFile(String name) {
             if (!filesIncluded.contains(name)
                 && !filesExcluded.contains(name)) {
 
                 if (isIncluded(name)) {
                     if (!isExcluded(name)
                         && isSelected(name, (File) scannedDirs.get(name))) {
                         filesIncluded.addElement(name);
                     } else {
                         filesExcluded.addElement(name);
                     }
                 } else {
                     filesNotIncluded.addElement(name);
                 }
             }
         }
 
         /**
          *
          * @param name path of the directory relative to the directory of
          * the fileset
          * @param file directory as file
          * @param fast
          */
         private void accountForIncludedDir(String name, AntFTPFile file, boolean fast) {
             if (!dirsIncluded.contains(name)
                 && !dirsExcluded.contains(name)) {
 
                 if (!isExcluded(name)) {
                     if (fast) {
                         if (file.isSymbolicLink()) {
                             try {
                                 file.getClient().changeWorkingDirectory(file.curpwd);
                             } catch (IOException ioe) {
                                 throw new BuildException("could not change directory to curpwd");
                             }
                             scandir(file.getLink(),
                                     name + File.separator, fast);
                         } else {
                             try {
                                 file.getClient().changeWorkingDirectory(file.curpwd);
                             } catch (IOException ioe) {
                                 throw new BuildException("could not change directory to curpwd");
                             }
                             scandir(file.getName(),
                                     name + File.separator, fast);
                         }
                     }
                     dirsIncluded.addElement(name);
                 } else {
                     dirsExcluded.addElement(name);
                     if (fast && couldHoldIncluded(name)) {
                         try {
                             file.getClient().changeWorkingDirectory(file.curpwd);
                         } catch (IOException ioe) {
                             throw new BuildException("could not change directory to curpwd");
                         }
                         scandir(file.getName(),
                                 name + File.separator, fast);
                     }
                 }
             }
         }
         /**
          * temporary table to speed up the various scanning methods below
          *
          * @since Ant 1.6
          */
         private Map fileListMap = new HashMap();
         /**
          * List of all scanned directories.
          *
          * @since Ant 1.6
          */
 
         private Map scannedDirs = new HashMap();
 
         /**
          * Has the directory with the given path relative to the base
          * directory already been scanned?
          *
          * @since Ant 1.6
          */
         private boolean hasBeenScanned(String vpath) {
             return scannedDirs.containsKey(vpath);
         }
 
         /**
          * Clear internal caches.
          *
          * @since Ant 1.6
          */
         private void clearCaches() {
             fileListMap.clear();
             scannedDirs.clear();
         }
         /**
          * list the files present in one directory.
          * @param directory full path on the remote side
          * @param changedir if true change to directory directory before listing
          * @return array of FTPFile
          */
         public FTPFile[] listFiles(String directory, boolean changedir) {
             //task.log("listing files in directory " + directory, Project.MSG_DEBUG);
             String currentPath = directory;
             if (changedir) {
                 try {
                     boolean result = ftp.changeWorkingDirectory(directory);
                     if (!result) {
                         return null;
                     }
                     currentPath = ftp.printWorkingDirectory();
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, task.getLocation());
                 }
             }
             if (fileListMap.containsKey(currentPath)) {
                 task.log("filelist map used in listing files", Project.MSG_DEBUG);
                 return ((FTPFile[]) fileListMap.get(currentPath));
             }
             FTPFile[] result = null;
             try {
                 result = ftp.listFiles();
             } catch (IOException ioe) {
                 throw new BuildException(ioe, task.getLocation());
             }
             fileListMap.put(currentPath, result);
             if (!remoteSensitivityChecked) {
                 checkRemoteSensitivity(result, directory);
             }
             return result;
         }
 
         private void forceRemoteSensitivityCheck() {
             if (!remoteSensitivityChecked) {
                 try {
                     checkRemoteSensitivity(ftp.listFiles(), ftp.printWorkingDirectory());
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, task.getLocation());
                 }
             }
         }
         /**
          * cd into one directory and
          * list the files present in one directory.
          * @param directory full path on the remote side
          * @return array of FTPFile
          */
         public FTPFile[] listFiles(String directory) {
             return listFiles(directory, true);
         }
         private void checkRemoteSensitivity(FTPFile[] array, String directory) {
             if (array == null) {
                 return;
             }
             boolean candidateFound = false;
             String target = null;
             for (int icounter = 0; icounter < array.length; icounter++) {
                 if (array[icounter] != null && array[icounter].isDirectory()) {
                     if (!array[icounter].getName().equals(".")
                         && !array[icounter].getName().equals("..")) {
                         candidateFound = true;
                         target = fiddleName(array[icounter].getName());
                         task.log("will try to cd to "
                                          + target + " where a directory called " + array[icounter].getName()
                                          + " exists", Project.MSG_DEBUG);
                         for (int pcounter = 0; pcounter < array.length; pcounter++) {
                             if (array[pcounter] != null
                                 && pcounter != icounter
                                 && target.equals(array[pcounter].getName())) {
                                 candidateFound = false;
                             }
                         }
                         if (candidateFound) {
                             break;
                         }
                     }
                 }
             }
             if (candidateFound) {
                 try {
                     task.log("testing case sensitivity, attempting to cd to "
                                      + target, Project.MSG_DEBUG);
                     remoteSystemCaseSensitive  = !ftp.changeWorkingDirectory(target);
                 } catch (IOException ioe) {
                     remoteSystemCaseSensitive = true;
                 } finally {
                     try {
                         ftp.changeWorkingDirectory(directory);
                     } catch (IOException ioe) {
                         throw new BuildException(ioe, task.getLocation());
                     }
                 }
                 task.log("remote system is case sensitive : "
                                       + remoteSystemCaseSensitive,
                                       Project.MSG_VERBOSE);
                 remoteSensitivityChecked = true;
             }
         }
         private String fiddleName(String origin) {
             StringBuffer result = new StringBuffer();
             for (int icounter = 0; icounter < origin.length(); icounter++) {
                 if (Character.isLowerCase(origin.charAt(icounter))) {
                     result.append(Character.toUpperCase(origin.charAt(icounter)));
                 } else if (Character.isUpperCase(origin.charAt(icounter))) {
                     result.append(Character.toLowerCase(origin.charAt(icounter)));
                 } else {
                     result.append(origin.charAt(icounter));
                 }
             }
             return result.toString();
         }
         /**
          * an AntFTPFile is a representation of a remote file
          * @since Ant 1.6
          */
         protected class AntFTPFile {
             /**
              * ftp client
              */
             private FTPClient client;
             /**
              * parent directory of the file
              */
             private String curpwd;
             /**
              * the file itself
              */
             private FTPFile ftpFile;
             /**
              *
              */
             private AntFTPFile parent = null;
             private boolean relativePathCalculated = false;
             private boolean traversesSymlinks = false;
             private String relativePath = "";
             /**
              * constructor
              * @param client ftp client variable
              * @param ftpFile the file
              * @param curpwd absolute remote path where the file is found
              */
             public AntFTPFile(FTPClient client, FTPFile ftpFile, String curpwd) {
                 this.client = client;
                 this.ftpFile = ftpFile;
                 this.curpwd = curpwd;
             }
             /**
              * other constructor
              * @param parent the parent file
              * @param path  a relative path to the parent file
              */
             public AntFTPFile(AntFTPFile parent, String path) {
                 this.parent = parent;
                 this.client = parent.client;
                 Vector pathElements = SelectorUtils.tokenizePath(path);
                 try {
                     boolean result = this.client.changeWorkingDirectory(parent.getAbsolutePath());
                     //this should not happen, except if parent has been deleted by another process
                     if (!result) {
                         return;
                     }
                     this.curpwd = parent.getAbsolutePath();
                 } catch (IOException ioe) {
                     throw new BuildException("could not change working dir to "
                                              + parent.curpwd);
                 }
-                for (int fcount = 0; fcount < pathElements.size() - 1; fcount++) {
+                final int size = pathElements.size();
+                for (int fcount = 0; fcount < size - 1; fcount++) {
                     String currentPathElement = (String) pathElements.elementAt(fcount);
                     try {
                         boolean result = this.client.changeWorkingDirectory(currentPathElement);
                         if (!result && !isCaseSensitive()
                             && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) {
                             currentPathElement = findPathElementCaseUnsensitive(this.curpwd,
                                                                                 currentPathElement);
                             if (currentPathElement == null) {
                                 return;
                             }
                         } else if (!result) {
                             return;
                         }
                         this.curpwd = getCurpwdPlusFileSep()
                             + currentPathElement;
                     } catch (IOException ioe) {
                         throw new BuildException("could not change working dir to "
                                                  + (String) pathElements.elementAt(fcount)
                                                  + " from " + this.curpwd);
                     }
 
                 }
-                String lastpathelement = (String) pathElements.elementAt(pathElements.size() - 1);
+                String lastpathelement = (String) pathElements.elementAt(size - 1);
                 FTPFile [] theFiles = listFiles(this.curpwd);
                 this.ftpFile = getFile(theFiles, lastpathelement);
             }
             /**
              * find a file in a directory in case unsensitive way
              * @param parentPath        where we are
              * @param soughtPathElement what is being sought
              * @return                  the first file found or null if not found
              */
             private String findPathElementCaseUnsensitive(String parentPath,
                                                           String soughtPathElement) {
                 // we are already in the right path, so the second parameter
                 // is false
                 FTPFile[] theFiles = listFiles(parentPath, false);
                 if (theFiles == null) {
                     return null;
                 }
                 for (int icounter = 0; icounter < theFiles.length; icounter++) {
                     if (theFiles[icounter] != null
                         && theFiles[icounter].getName().equalsIgnoreCase(soughtPathElement)) {
                         return theFiles[icounter].getName();
                     }
                 }
                 return null;
             }
             /**
              * find out if the file exists
              * @return  true if the file exists
              */
             public boolean exists() {
                 return (ftpFile != null);
             }
             /**
              * if the file is a symbolic link, find out to what it is pointing
              * @return the target of the symbolic link
              */
             public String getLink() {
                 return ftpFile.getLink();
             }
             /**
              * get the name of the file
              * @return the name of the file
              */
             public String getName() {
                 return ftpFile.getName();
             }
             /**
              * find out the absolute path of the file
              * @return absolute path as string
              */
             public String getAbsolutePath() {
                 return getCurpwdPlusFileSep() + ftpFile.getName();
             }
             /**
              * find out the relative path assuming that the path used to construct
              * this AntFTPFile was spelled properly with regards to case.
              * This is OK on a case sensitive system such as UNIX
              * @return relative path
              */
             public String getFastRelativePath() {
                 String absPath = getAbsolutePath();
                 if (absPath.indexOf(rootPath + task.getSeparator()) == 0) {
                     return absPath.substring(rootPath.length()
                                              + task.getSeparator().length());
                 }
                 return null;
             }
             /**
              * find out the relative path to the rootPath of the enclosing scanner.
              * this relative path is spelled exactly like on disk,
              * for instance if the AntFTPFile has been instantiated as ALPHA,
              * but the file is really called alpha, this method will return alpha.
              * If a symbolic link is encountered, it is followed, but the name of the link
              * rather than the name of the target is returned.
              * (ie does not behave like File.getCanonicalPath())
              * @return                relative path, separated by remoteFileSep
              * @throws IOException    if a change directory fails, ...
              * @throws BuildException if one of the components of the relative path cannot
              * be found.
              */
             public String getRelativePath() throws IOException, BuildException {
                 if (!relativePathCalculated) {
                     if (parent != null) {
                         traversesSymlinks = parent.isTraverseSymlinks();
                         relativePath = getRelativePath(parent.getAbsolutePath(),
                                                        parent.getRelativePath());
                     } else {
                         relativePath = getRelativePath(rootPath, "");
                         relativePathCalculated = true;
                     }
                 }
                 return relativePath;
             }
             /**
              * get thge relative path of this file
              * @param currentPath          base path
              * @param currentRelativePath  relative path of the base path with regards to remote dir
              * @return relative path
              */
             private String getRelativePath(String currentPath, String currentRelativePath) {
                 Vector pathElements = SelectorUtils.tokenizePath(getAbsolutePath(), task.getSeparator());
                 Vector pathElements2 = SelectorUtils.tokenizePath(currentPath,
                                                                   task.getSeparator());
                 String relPath = currentRelativePath;
-                for (int pcount = pathElements2.size(); pcount < pathElements.size(); pcount++) {
+                final int size = pathElements.size();
+                for (int pcount = pathElements2.size(); pcount < size; pcount++) {
                     String currentElement = (String) pathElements.elementAt(pcount);
                     FTPFile[] theFiles = listFiles(currentPath);
                     FTPFile theFile = null;
                     if (theFiles != null) {
                         theFile = getFile(theFiles, currentElement);
                     }
                     if (!relPath.equals("")) {
                         relPath = relPath + task.getSeparator();
                     }
                     if (theFile == null) {
                         // hit a hidden file assume not a symlink
                         relPath = relPath + currentElement;
                         currentPath = currentPath + task.getSeparator()
                             + currentElement;
                         task.log("Hidden file " + relPath
                                  + " assumed to not be a symlink.",
                                  Project.MSG_VERBOSE);
                     } else {
                         traversesSymlinks = traversesSymlinks || theFile.isSymbolicLink();
                         relPath = relPath + theFile.getName();
                         currentPath = currentPath + task.getSeparator()
                             + theFile.getName();
                     }
                 }
                 return relPath;
             }
             /**
              * find a file matching a string in an array of FTPFile.
              * This method will find "alpha" when requested for "ALPHA"
              * if and only if the caseSensitive attribute is set to false.
              * When caseSensitive is set to true, only the exact match is returned.
              * @param theFiles  array of files
              * @param lastpathelement  the file name being sought
              * @return null if the file cannot be found, otherwise return the matching file.
              */
             public FTPFile getFile(FTPFile[] theFiles, String lastpathelement) {
                 if (theFiles == null) {
                     return null;
                 }
                 for (int fcount = 0; fcount < theFiles.length; fcount++) {
                     if (theFiles[fcount] != null) {
                         if (theFiles[fcount].getName().equals(lastpathelement)) {
                             return theFiles[fcount];
                         } else if (!isCaseSensitive()
                                    && theFiles[fcount].getName().equalsIgnoreCase(
                                                                                   lastpathelement)) {
                             return theFiles[fcount];
                         }
                     }
                 }
                 return null;
             }
             /**
              * tell if a file is a directory.
              * note that it will return false for symbolic links pointing to directories.
              * @return <code>true</code> for directories
              */
             public boolean isDirectory() {
                 return ftpFile.isDirectory();
             }
             /**
              * tell if a file is a symbolic link
              * @return <code>true</code> for symbolic links
              */
             public boolean isSymbolicLink() {
                 return ftpFile.isSymbolicLink();
             }
             /**
              * return the attached FTP client object.
              * Warning : this instance is really shared with the enclosing class.
              * @return  FTP client
              */
             protected FTPClient getClient() {
                 return client;
             }
 
             /**
              * sets the current path of an AntFTPFile
              * @param curpwd the current path one wants to set
              */
             protected void setCurpwd(String curpwd) {
                 this.curpwd = curpwd;
             }
             /**
              * returns the path of the directory containing the AntFTPFile.
              * of the full path of the file itself in case of AntFTPRootFile
              * @return parent directory of the AntFTPFile
              */
             public String getCurpwd() {
                 return curpwd;
             }
             /**
              * returns the path of the directory containing the AntFTPFile.
              * of the full path of the file itself in case of AntFTPRootFile
              * and appends the remote file separator if necessary.
              * @return parent directory of the AntFTPFile
              * @since Ant 1.8.2
              */
             public String getCurpwdPlusFileSep() {
                 String sep = task.getSeparator();
                 return curpwd.endsWith(sep) ? curpwd : curpwd + sep;
             }
             /**
              * find out if a symbolic link is encountered in the relative path of this file
              * from rootPath.
              * @return <code>true</code> if a symbolic link is encountered in the relative path.
              * @throws IOException if one of the change directory or directory listing operations
              * fails
              * @throws BuildException if a path component in the relative path cannot be found.
              */
             public boolean isTraverseSymlinks() throws IOException, BuildException {
                 if (!relativePathCalculated) {
                     // getRelativePath also finds about symlinks
                     getRelativePath();
                 }
                 return traversesSymlinks;
             }
 
             /**
              * Get a string rep of this object.
              * @return a string containing the pwd and the file.
              */
             public String toString() {
                 return "AntFtpFile: " + curpwd + "%" + ftpFile;
             }
         }
         /**
          * special class to represent the remote directory itself
          * @since Ant 1.6
          */
         protected class AntFTPRootFile extends AntFTPFile {
             private String remotedir;
             /**
              * constructor
              * @param aclient FTP client
              * @param remotedir remote directory
              */
             public AntFTPRootFile(FTPClient aclient, String remotedir) {
                 super(aclient, null, remotedir);
                 this.remotedir = remotedir;
                 try {
                     this.getClient().changeWorkingDirectory(this.remotedir);
                     this.setCurpwd(this.getClient().printWorkingDirectory());
                 } catch (IOException ioe) {
                     throw new BuildException(ioe, task.getLocation());
                 }
             }
             /**
              * find the absolute path
              * @return absolute path
              */
             public String getAbsolutePath() {
                 return this.getCurpwd();
             }
             /**
              * find out the relative path to root
              * @return empty string
              * @throws BuildException actually never
              * @throws IOException  actually never
              */
             public String getRelativePath() throws BuildException, IOException {
                 return "";
             }
         }
     }
     /**
      * check FTPFiles to check whether they function as directories too
      * the FTPFile API seem to make directory and symbolic links incompatible
      * we want to find out if we can cd to a symbolic link
      * @param dir  the parent directory of the file to test
      * @param file the file to test
      * @return true if it is possible to cd to this directory
      * @since ant 1.6
      */
     private boolean isFunctioningAsDirectory(FTPClient ftp, String dir, FTPFile file) {
         boolean result = false;
         String currentWorkingDir = null;
         if (file.isDirectory()) {
             return true;
         } else if (file.isFile()) {
             return false;
         }
         try {
             currentWorkingDir = ftp.printWorkingDirectory();
         } catch (IOException ioe) {
             task.log("could not find current working directory " + dir
                                   + " while checking a symlink", Project.MSG_DEBUG);
         }
         if (currentWorkingDir != null) {
             try {
                 result = ftp.changeWorkingDirectory(file.getLink());
             } catch (IOException ioe) {
                 task.log("could not cd to " + file.getLink()
                                       + " while checking a symlink",
                                       Project.MSG_DEBUG);
             }
             if (result) {
                 boolean comeback = false;
                 try {
                     comeback = ftp.changeWorkingDirectory(currentWorkingDir);
                 } catch (IOException ioe) {
                     task.log("could not cd back to " + dir + " while checking a symlink",
                                           Project.MSG_ERR);
                 } finally {
                     if (!comeback) {
                         throw new BuildException("could not cd back to " + dir
                                                  + " while checking a symlink");
                     }
                 }
             }
         }
         return result;
     }
     /**
      * check FTPFiles to check whether they function as directories too
      * the FTPFile API seem to make directory and symbolic links incompatible
      * we want to find out if we can cd to a symbolic link
      * @param dir  the parent directory of the file to test
      * @param file the file to test
      * @return true if it is possible to cd to this directory
      * @since ant 1.6
      */
     private boolean isFunctioningAsFile(FTPClient ftp, String dir, FTPFile file) {
         if (file.isDirectory()) {
             return false;
         } else if (file.isFile()) {
             return true;
         }
         return !isFunctioningAsDirectory(ftp, dir, file);
     }
 
     /**
      * Executable a retryable object.
      * @param h the retry hander.
      * @param r the object that should be retried until it succeeds
      *          or the number of retrys is reached.
      * @param descr a description of the command that is being run.
      * @throws IOException if there is a problem.
      */
     protected void executeRetryable(RetryHandler h, Retryable r, String descr)
         throws IOException {
         h.execute(r, descr);
     }
 
 
     /**
      * For each file in the fileset, do the appropriate action: send, get,
      * delete, or list.
      *
      * @param ftp the FTPClient instance used to perform FTP actions
      * @param fs the fileset on which the actions are performed.
      *
      * @return the number of files to be transferred.
      *
      * @throws IOException if there is a problem reading a file
      * @throws BuildException if there is a problem in the configuration.
      */
     protected int transferFiles(final FTPClient ftp, FileSet fs)
         throws IOException, BuildException {
         DirectoryScanner ds;
         if (task.getAction() == FTPTask.SEND_FILES) {
             ds = fs.getDirectoryScanner(task.getProject());
         } else {
             ds = new FTPDirectoryScanner(ftp);
             fs.setupDirectoryScanner(ds, task.getProject());
             ds.setFollowSymlinks(fs.isFollowSymlinks());
             ds.scan();
         }
 
         String[] dsfiles = null;
         if (task.getAction() == FTPTask.RM_DIR) {
             dsfiles = ds.getIncludedDirectories();
         } else {
             dsfiles = ds.getIncludedFiles();
         }
         String dir = null;
 
         if ((ds.getBasedir() == null)
             && ((task.getAction() == FTPTask.SEND_FILES) || (task.getAction() == FTPTask.GET_FILES))) {
             throw new BuildException("the dir attribute must be set for send "
                                      + "and get actions");
         } else {
             if ((task.getAction() == FTPTask.SEND_FILES) || (task.getAction() == FTPTask.GET_FILES)) {
                 dir = ds.getBasedir().getAbsolutePath();
             }
         }
 
         // If we are doing a listing, we need the output stream created now.
         BufferedWriter bw = null;
 
         try {
             if (task.getAction() == FTPTask.LIST_FILES) {
                 File pd = task.getListing().getParentFile();
 
                 if (!pd.exists()) {
                     pd.mkdirs();
                 }
                 bw = new BufferedWriter(new FileWriter(task.getListing()));
             }
             RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
             if (task.getAction() == FTPTask.RM_DIR) {
                 // to remove directories, start by the end of the list
                 // the trunk does not let itself be removed before the leaves
                 for (int i = dsfiles.length - 1; i >= 0; i--) {
                     final String dsfile = dsfiles[i];
                     executeRetryable(h, new Retryable() {
                             public void execute() throws IOException {
                                 rmDir(ftp, dsfile);
                             }
                         }, dsfile);
                 }
             } else {
                 final BufferedWriter fbw = bw;
                 final String fdir = dir;
                 if (task.isNewer()) {
                     task.setGranularityMillis(task.getTimestampGranularity()
                                               .getMilliseconds(task.getAction()));
                 }
                 for (int i = 0; i < dsfiles.length; i++) {
                     final String dsfile = dsfiles[i];
                     executeRetryable(h, new Retryable() {
                             public void execute() throws IOException {
                                 switch (task.getAction()) {
                                 case FTPTask.SEND_FILES:
                                     sendFile(ftp, fdir, dsfile);
                                     break;
                                 case FTPTask.GET_FILES:
                                     getFile(ftp, fdir, dsfile);
                                     break;
                                 case FTPTask.DEL_FILES:
                                     delFile(ftp, dsfile);
                                     break;
                                 case FTPTask.LIST_FILES:
                                     listFile(ftp, fbw, dsfile);
                                     break;
                                 case FTPTask.CHMOD:
                                     doSiteCommand(ftp, "chmod " + task.getChmod() + " "
                                                   + resolveFile(dsfile));
                                     transferred++;
                                     break;
                                 default:
                                     throw new BuildException("unknown ftp action "
                                                              + task.getAction());
                                 }
                             }
                         }, dsfile);
                 }
             }
         } finally {
             if (bw != null) {
                 bw.close();
             }
         }
 
         return dsfiles.length;
     }
 
 
     /**
      * Sends all files specified by the configured filesets to the remote
      * server.
      *
      * @param ftp the FTPClient instance used to perform FTP actions
      *
      * @throws IOException if there is a problem reading a file
      * @throws BuildException if there is a problem in the configuration.
      */
     protected void transferFiles(FTPClient ftp)
         throws IOException, BuildException {
         transferred = 0;
         skipped = 0;
 
         if (task.getFilesets().size() == 0) {
             throw new BuildException("at least one fileset must be specified.");
         } else {
             // get files from filesets
-            for (int i = 0; i < task.getFilesets().size(); i++) {
+            final int size = task.getFilesets().size();
+            for (int i = 0; i < size; i++) {
                 FileSet fs = (FileSet) task.getFilesets().elementAt(i);
 
                 if (fs != null) {
                     transferFiles(ftp, fs);
                 }
             }
         }
 
         task.log(transferred + " " + FTPTask.ACTION_TARGET_STRS[task.getAction()] + " "
                  + FTPTask.COMPLETED_ACTION_STRS[task.getAction()]);
         if (skipped != 0) {
             task.log(skipped + " " + FTPTask.ACTION_TARGET_STRS[task.getAction()]
                      + " were not successfully " + FTPTask.COMPLETED_ACTION_STRS[task.getAction()]);
         }
     }
 
 
     /**
      * Correct a file path to correspond to the remote host requirements. This
      * implementation currently assumes that the remote end can handle
      * Unix-style paths with forward-slash separators. This can be overridden
      * with the <code>separator</code> task parameter. No attempt is made to
      * determine what syntax is appropriate for the remote host.
      *
      * @param file the remote file name to be resolved
      *
      * @return the filename as it will appear on the server.
      */
     protected String resolveFile(String file) {
         return file.replace(System.getProperty("file.separator").charAt(0),
                             task.getSeparator().charAt(0));
     }
 
 
     /**
      * Creates all parent directories specified in a complete relative
      * pathname. Attempts to create existing directories will not cause
      * errors.
      *
      * @param ftp the FTP client instance to use to execute FTP actions on
      *        the remote server.
      * @param filename the name of the file whose parents should be created.
      * @throws IOException under non documented circumstances
      * @throws BuildException if it is impossible to cd to a remote directory
      *
      */
     protected void createParents(FTPClient ftp, String filename)
         throws IOException, BuildException {
 
         File dir = new File(filename);
         if (dirCache.contains(dir)) {
             return;
         }
 
         Vector parents = new Vector();
         String dirname;
 
         while ((dirname = dir.getParent()) != null) {
             File checkDir = new File(dirname);
             if (dirCache.contains(checkDir)) {
                 break;
             }
             dir = checkDir;
             parents.addElement(dir);
         }
 
         // find first non cached dir
         int i = parents.size() - 1;
 
         if (i >= 0) {
             String cwd = ftp.printWorkingDirectory();
             String parent = dir.getParent();
             if (parent != null) {
                 if (!ftp.changeWorkingDirectory(resolveFile(parent))) {
                     throw new BuildException("could not change to "
                                              + "directory: " + ftp.getReplyString());
                 }
             }
 
             while (i >= 0) {
                 dir = (File) parents.elementAt(i--);
                 // check if dir exists by trying to change into it.
                 if (!ftp.changeWorkingDirectory(dir.getName())) {
                     // could not change to it - try to create it
                     task.log("creating remote directory "
                              + resolveFile(dir.getPath()), Project.MSG_VERBOSE);
                     if (!ftp.makeDirectory(dir.getName())) {
                         handleMkDirFailure(ftp);
                     }
                     if (!ftp.changeWorkingDirectory(dir.getName())) {
                         throw new BuildException("could not change to "
                                                  + "directory: " + ftp.getReplyString());
                     }
                 }
                 dirCache.add(dir);
             }
             ftp.changeWorkingDirectory(cwd);
         }
     }
     /**
      * auto find the time difference between local and remote
      * @param ftp handle to ftp client
      * @return number of millis to add to remote time to make it comparable to local time
      * @since ant 1.6
      */
     private long getTimeDiff(FTPClient ftp) {
         long returnValue = 0;
         File tempFile = findFileName(ftp);
         try {
             // create a local temporary file
             FILE_UTILS.createNewFile(tempFile);
             long localTimeStamp = tempFile.lastModified();
             BufferedInputStream instream = new BufferedInputStream(new FileInputStream(tempFile));
             ftp.storeFile(tempFile.getName(), instream);
             instream.close();
             boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
             if (success) {
                 FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName());
                 if (ftpFiles.length == 1) {
                     long remoteTimeStamp = ftpFiles[0].getTimestamp().getTime().getTime();
                     returnValue = localTimeStamp - remoteTimeStamp;
                 }
                 ftp.deleteFile(ftpFiles[0].getName());
             }
             // delegate the deletion of the local temp file to the delete task
             // because of race conditions occuring on Windows
             Delete mydelete = new Delete();
             mydelete.bindToOwner(task);
             mydelete.setFile(tempFile.getCanonicalFile());
             mydelete.execute();
         } catch (Exception e) {
             throw new BuildException(e, task.getLocation());
         }
         return returnValue;
     }
     /**
      *  find a suitable name for local and remote temporary file
      */
     private File findFileName(FTPClient ftp) {
         FTPFile [] theFiles = null;
         final int maxIterations = 1000;
         for (int counter = 1; counter < maxIterations; counter++) {
             File localFile = FILE_UTILS.createTempFile(
                                                        "ant" + Integer.toString(counter), ".tmp",
                                                        null, false, false);
             String fileName = localFile.getName();
             boolean found = false;
             try {
                 if (theFiles == null) {
                     theFiles = ftp.listFiles();
                 }
                 for (int counter2 = 0; counter2 < theFiles.length; counter2++) {
                     if (theFiles[counter2] != null
                         && theFiles[counter2].getName().equals(fileName)) {
                         found = true;
                         break;
                     }
                 }
             } catch (IOException ioe) {
                 throw new BuildException(ioe, task.getLocation());
             }
             if (!found) {
                 localFile.deleteOnExit();
                 return localFile;
             }
         }
         return null;
     }
 
     /**
      * Checks to see if the remote file is current as compared with the local
      * file. Returns true if the target file is up to date.
      * @param ftp ftpclient
      * @param localFile local file
      * @param remoteFile remote file
      * @return true if the target file is up to date
      * @throws IOException  in unknown circumstances
      * @throws BuildException if the date of the remote files cannot be found and the action is
      * GET_FILES
      */
     protected boolean isUpToDate(FTPClient ftp, File localFile,
                                  String remoteFile)
         throws IOException, BuildException {
         task.log("checking date for " + remoteFile, Project.MSG_VERBOSE);
 
         FTPFile[] files = ftp.listFiles(remoteFile);
 
         // For Microsoft's Ftp-Service an Array with length 0 is
         // returned if configured to return listings in "MS-DOS"-Format
         if (files == null || files.length == 0) {
             // If we are sending files, then assume out of date.
             // If we are getting files, then throw an error
 
             if (task.getAction() == FTPTask.SEND_FILES) {
                 task.log("Could not date test remote file: " + remoteFile
                          + "assuming out of date.", Project.MSG_VERBOSE);
                 return false;
             } else {
                 throw new BuildException("could not date test remote file: "
                                          + ftp.getReplyString());
             }
         }
 
         long remoteTimestamp = files[0].getTimestamp().getTime().getTime();
         long localTimestamp = localFile.lastModified();
         long adjustedRemoteTimestamp = remoteTimestamp + task.getTimeDiffMillis()
             + task.getGranularityMillis();
 
         StringBuffer msg;
         synchronized(TIMESTAMP_LOGGING_SDF) {
             msg = new StringBuffer("   [")
                 .append(TIMESTAMP_LOGGING_SDF.format(new Date(localTimestamp)))
                 .append("] local");
         }
         task.log(msg.toString(), Project.MSG_VERBOSE);
 
         synchronized(TIMESTAMP_LOGGING_SDF) {
             msg = new StringBuffer("   [")
                 .append(TIMESTAMP_LOGGING_SDF.format(new Date(adjustedRemoteTimestamp)))
                 .append("] remote");
         }
         if (remoteTimestamp != adjustedRemoteTimestamp) {
             synchronized(TIMESTAMP_LOGGING_SDF) {
                 msg.append(" - (raw: ")
                     .append(TIMESTAMP_LOGGING_SDF.format(new Date(remoteTimestamp)))
                     .append(")");
             }
         }
         task.log(msg.toString(), Project.MSG_VERBOSE);
 
         if (task.getAction() == FTPTask.SEND_FILES) {
             return adjustedRemoteTimestamp >= localTimestamp;
         } else {
             return localTimestamp >= adjustedRemoteTimestamp;
         }
     }
 
 
     /**
      * Sends a site command to the ftp server
      * @param ftp ftp client
      * @param theCMD command to execute
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void doSiteCommand(FTPClient ftp, String theCMD)
         throws IOException, BuildException {
         boolean rc;
         String[] myReply = null;
 
         task.log("Doing Site Command: " + theCMD, Project.MSG_VERBOSE);
 
         rc = ftp.sendSiteCommand(theCMD);
 
         if (!rc) {
             task.log("Failed to issue Site Command: " + theCMD, Project.MSG_WARN);
         } else {
 
             myReply = ftp.getReplyStrings();
 
             for (int x = 0; x < myReply.length; x++) {
                 if (myReply[x].indexOf("200") == -1) {
                     task.log(myReply[x], Project.MSG_WARN);
                 }
             }
         }
     }
 
 
     /**
      * Sends a single file to the remote host. <code>filename</code> may
      * contain a relative path specification. When this is the case, <code>sendFile</code>
      * will attempt to create any necessary parent directories before sending
      * the file. The file will then be sent using the entire relative path
      * spec - no attempt is made to change directories. It is anticipated that
      * this may eventually cause problems with some FTP servers, but it
      * simplifies the coding.
      * @param ftp ftp client
      * @param dir base directory of the file to be sent (local)
      * @param filename relative path of the file to be send
      *        locally relative to dir
      *        remotely relative to the remotedir attribute
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void sendFile(FTPClient ftp, String dir, String filename)
         throws IOException, BuildException {
         InputStream instream = null;
 
         try {
             // XXX - why not simply new File(dir, filename)?
             File file = task.getProject().resolveFile(new File(dir, filename).getPath());
 
             if (task.isNewer() && isUpToDate(ftp, file, resolveFile(filename))) {
                 return;
             }
 
             if (task.isVerbose()) {
                 task.log("transferring " + file.getAbsolutePath());
             }
 
             instream = new BufferedInputStream(new FileInputStream(file));
 
             createParents(ftp, filename);
 
             ftp.storeFile(resolveFile(filename), instream);
 
             boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
 
             if (!success) {
                 String s = "could not put file: " + ftp.getReplyString();
 
                 if (task.isSkipFailedTransfers()) {
                     task.log(s, Project.MSG_WARN);
                     skipped++;
                 } else {
                     throw new BuildException(s);
                 }
 
             } else {
                 // see if we should issue a chmod command
                 if (task.getChmod() != null) {
                     doSiteCommand(ftp, "chmod " + task.getChmod() + " "
                                   + resolveFile(filename));
                 }
                 task.log("File " + file.getAbsolutePath() + " copied to " + task.getServer(),
                          Project.MSG_VERBOSE);
                 transferred++;
             }
         } finally {
             if (instream != null) {
                 try {
                     instream.close();
                 } catch (IOException ex) {
                     // ignore it
                 }
             }
         }
     }
 
 
     /**
      * Delete a file from the remote host.
      * @param ftp ftp client
      * @param filename file to delete
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is set to false
      * and the deletion could not be done
      */
     protected void delFile(FTPClient ftp, String filename)
         throws IOException, BuildException {
         if (task.isVerbose()) {
             task.log("deleting " + filename);
         }
 
         if (!ftp.deleteFile(resolveFile(filename))) {
             String s = "could not delete file: " + ftp.getReplyString();
 
             if (task.isSkipFailedTransfers()) {
                 task.log(s, Project.MSG_WARN);
                 skipped++;
             } else {
                 throw new BuildException(s);
             }
         } else {
             task.log("File " + filename + " deleted from " + task.getServer(),
                      Project.MSG_VERBOSE);
             transferred++;
         }
     }
 
     /**
      * Delete a directory, if empty, from the remote host.
      * @param ftp ftp client
      * @param dirname directory to delete
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is set to false
      * and the deletion could not be done
      */
     protected void rmDir(FTPClient ftp, String dirname)
         throws IOException, BuildException {
         if (task.isVerbose()) {
             task.log("removing " + dirname);
         }
 
         if (!ftp.removeDirectory(resolveFile(dirname))) {
             String s = "could not remove directory: " + ftp.getReplyString();
 
             if (task.isSkipFailedTransfers()) {
                 task.log(s, Project.MSG_WARN);
                 skipped++;
             } else {
                 throw new BuildException(s);
             }
         } else {
             task.log("Directory " + dirname + " removed from " + task.getServer(),
                      Project.MSG_VERBOSE);
             transferred++;
         }
     }
 
 
     /**
      * Retrieve a single file from the remote host. <code>filename</code> may
      * contain a relative path specification. <p>
      *
      * The file will then be retreived using the entire relative path spec -
      * no attempt is made to change directories. It is anticipated that this
      * may eventually cause problems with some FTP servers, but it simplifies
      * the coding.</p>
      * @param ftp the ftp client
      * @param dir local base directory to which the file should go back
      * @param filename relative path of the file based upon the ftp remote directory
      *        and/or the local base directory (dir)
      * @throws IOException  in unknown circumstances
      * @throws BuildException if skipFailedTransfers is false
      * and the file cannot be retrieved.
      */
     protected void getFile(FTPClient ftp, String dir, String filename)
         throws IOException, BuildException {
         OutputStream outstream = null;
         try {
             File file = task.getProject().resolveFile(new File(dir, filename).getPath());
 
             if (task.isNewer() && isUpToDate(ftp, file, resolveFile(filename))) {
                 return;
             }
 
             if (task.isVerbose()) {
                 task.log("transferring " + filename + " to "
                          + file.getAbsolutePath());
             }
 
             File pdir = file.getParentFile();
 
             if (!pdir.exists()) {
                 pdir.mkdirs();
             }
             outstream = new BufferedOutputStream(new FileOutputStream(file));
             ftp.retrieveFile(resolveFile(filename), outstream);
 
             if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                 String s = "could not get file: " + ftp.getReplyString();
 
                 if (task.isSkipFailedTransfers()) {
                     task.log(s, Project.MSG_WARN);
                     skipped++;
                 } else {
                     throw new BuildException(s);
                 }
 
             } else {
                 task.log(
                          "File " + file.getAbsolutePath() + " copied from "
                          + task.getServer(), Project.MSG_VERBOSE);
                 transferred++;
                 if (task.isPreserveLastModified()) {
                     outstream.close();
                     outstream = null;
                     FTPFile[] remote = ftp.listFiles(resolveFile(filename));
                     if (remote.length > 0) {
                         FILE_UTILS.setFileLastModified(file,
                                                        remote[0].getTimestamp()
                                                        .getTime().getTime());
                     }
                 }
             }
         } finally {
             if (outstream != null) {
                 try {
                     outstream.close();
                 } catch (IOException ex) {
                     // ignore it
                 }
             }
         }
     }
 
 
     /**
      * List information about a single file from the remote host. <code>filename</code>
      * may contain a relative path specification. <p>
      *
      * The file listing will then be retrieved using the entire relative path
      * spec - no attempt is made to change directories. It is anticipated that
      * this may eventually cause problems with some FTP servers, but it
      * simplifies the coding.</p>
      * @param ftp ftp client
      * @param bw buffered writer
      * @param filename the directory one wants to list
      * @throws IOException  in unknown circumstances
      * @throws BuildException in unknown circumstances
      */
     protected void listFile(FTPClient ftp, BufferedWriter bw, String filename)
         throws IOException, BuildException {
         if (task.isVerbose()) {
             task.log("listing " + filename);
         }
         FTPFile[] ftpfiles = ftp.listFiles(resolveFile(filename));
 
         if (ftpfiles != null && ftpfiles.length > 0) {
             bw.write(ftpfiles[0].toString());
             bw.newLine();
             transferred++;
         }
     }
 
 
     /**
      * Create the specified directory on the remote host.
      *
      * @param ftp The FTP client connection
      * @param dir The directory to create (format must be correct for host
      *      type)
      * @throws IOException  in unknown circumstances
      * @throws BuildException if ignoreNoncriticalErrors has not been set to true
      *         and a directory could not be created, for instance because it was
      *         already existing. Precisely, the codes 521, 550 and 553 will trigger
      *         a BuildException
      */
     protected void makeRemoteDir(FTPClient ftp, String dir)
         throws IOException, BuildException {
         String workingDirectory = ftp.printWorkingDirectory();
         if (task.isVerbose()) {
             if (dir.indexOf("/") == 0 || workingDirectory == null) {
                 task.log("Creating directory: " + dir + " in /");
             } else {
                 task.log("Creating directory: " + dir + " in " + workingDirectory);
             }
         }
         if (dir.indexOf("/") == 0) {
             ftp.changeWorkingDirectory("/");
         }
         String subdir = "";
         StringTokenizer st = new StringTokenizer(dir, "/");
         while (st.hasMoreTokens()) {
             subdir = st.nextToken();
             task.log("Checking " + subdir, Project.MSG_DEBUG);
             if (!ftp.changeWorkingDirectory(subdir)) {
                 if (!ftp.makeDirectory(subdir)) {
                     // codes 521, 550 and 553 can be produced by FTP Servers
                     //  to indicate that an attempt to create a directory has
                     //  failed because the directory already exists.
                     int rc = ftp.getReplyCode();
                     if (!(task.isIgnoreNoncriticalErrors() && (rc == FTPReply.CODE_550
                                                                || rc == FTPReply.CODE_553 || rc == CODE_521))) {
                         throw new BuildException("could not create directory: "
                                                  + ftp.getReplyString());
                     }
                     if (task.isVerbose()) {
                         task.log("Directory already exists");
                     }
                 } else {
                     if (task.isVerbose()) {
                         task.log("Directory created OK");
                     }
                     ftp.changeWorkingDirectory(subdir);
                 }
             }
         }
         if (workingDirectory != null) {
             ftp.changeWorkingDirectory(workingDirectory);
         }
     }
 
     /**
      * look at the response for a failed mkdir action, decide whether
      * it matters or not. If it does, we throw an exception
      * @param ftp current ftp connection
      * @throws BuildException if this is an error to signal
      */
     private void handleMkDirFailure(FTPClient ftp)
         throws BuildException {
         int rc = ftp.getReplyCode();
         if (!(task.isIgnoreNoncriticalErrors() && (rc == FTPReply.CODE_550
                                                    || rc == FTPReply.CODE_553 || rc == CODE_521))) {
             throw new BuildException("could not create directory: "
                                      + ftp.getReplyString());
         }
     }
 
     public void doFTP() throws BuildException {
         FTPClient ftp = null;
 
         try {
             task.log("Opening FTP connection to " + task.getServer(), Project.MSG_VERBOSE);
 
             ftp = new FTPClient();
             if (task.isConfigurationSet()) {
                 ftp = FTPConfigurator.configure(ftp, task);
             }
 
             ftp.setRemoteVerificationEnabled(task.getEnableRemoteVerification());
             ftp.connect(task.getServer(), task.getPort());
             if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                 throw new BuildException("FTP connection failed: "
                                          + ftp.getReplyString());
             }
 
             task.log("connected", Project.MSG_VERBOSE);
             task.log("logging in to FTP server", Project.MSG_VERBOSE);
 
             if ((task.getAccount() != null && !ftp.login(task.getUserid(), task.getPassword(), task.getAccount()))
                 || (task.getAccount() == null && !ftp.login(task.getUserid(), task.getPassword()))) {
                 throw new BuildException("Could not login to FTP server");
             }
 
             task.log("login succeeded", Project.MSG_VERBOSE);
 
             if (task.isBinary()) {
                 ftp.setFileType(org.apache.commons.net.ftp.FTP.BINARY_FILE_TYPE);
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not set transfer type: "
                                              + ftp.getReplyString());
                 }
             } else {
                 ftp.setFileType(org.apache.commons.net.ftp.FTP.ASCII_FILE_TYPE);
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not set transfer type: "
                                              + ftp.getReplyString());
                 }
             }
 
             if (task.isPassive()) {
                 task.log("entering passive mode", Project.MSG_VERBOSE);
                 ftp.enterLocalPassiveMode();
                 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                     throw new BuildException("could not enter into passive "
                                              + "mode: " + ftp.getReplyString());
                 }
             }
 
             // If an initial command was configured then send it.
             // Some FTP servers offer different modes of operation,
             // E.G. switching between a UNIX file system mode and
             // a legacy file system.
             if (task.getInitialSiteCommand() != null) {
                 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, task.getInitialSiteCommand());
                         }
                     }, "initial site command: " + task.getInitialSiteCommand());
             }
 
 
             // For a unix ftp server you can set the default mask for all files
             // created.
 
             if (task.getUmask() != null) {
                 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, "umask " + task.getUmask());
                         }
                     }, "umask " + task.getUmask());
             }
 
             // If the action is MK_DIR, then the specified remote
             // directory is the directory to create.
 
             if (task.getAction() == FTPTask.MK_DIR) {
                 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             makeRemoteDir(lftp, task.getRemotedir());
                         }
                     }, task.getRemotedir());
             } else if (task.getAction() == FTPTask.SITE_CMD) {
                 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
                 final FTPClient lftp = ftp;
                 executeRetryable(h, new Retryable() {
                         public void execute() throws IOException {
                             doSiteCommand(lftp, task.getSiteCommand());
                         }
                     }, "Site Command: " + task.getSiteCommand());
             } else {
                 if (task.getRemotedir() != null) {
                     task.log("changing the remote directory", Project.MSG_VERBOSE);
                     ftp.changeWorkingDirectory(task.getRemotedir());
                     if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
                         throw new BuildException("could not change remote "
                                                  + "directory: " + ftp.getReplyString());
                     }
                 }
                 if (task.isNewer() && task.isTimeDiffAuto()) {
                     // in this case we want to find how much time span there is between local
                     // and remote
                     task.setTimeDiffMillis(getTimeDiff(ftp));
                 }
                 task.log(FTPTask.ACTION_STRS[task.getAction()] + " " + FTPTask.ACTION_TARGET_STRS[task.getAction()]);
                 transferFiles(ftp);
             }
 
         } catch (IOException ex) {
             throw new BuildException("error during FTP transfer: " + ex, ex);
         } finally {
             if (ftp != null && ftp.isConnected()) {
                 try {
                     task.log("disconnecting", Project.MSG_VERBOSE);
                     ftp.logout();
                     ftp.disconnect();
                 } catch (IOException ex) {
                     // ignore it
                 }
             }
         }
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Add.java b/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Add.java
index 3b2de82d6..24a458c9e 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Add.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Add.java
@@ -1,142 +1,143 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 /*
  * Portions of this software are based upon public domain software
  * originally written at the National Center for Supercomputing Applications,
  * University of Illinois, Urbana-Champaign.
  */
 
 package org.apache.tools.ant.taskdefs.optional.perforce;
 
 import java.io.File;
 import java.util.Vector;
 
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.types.FileSet;
 
 /**
  * Adds specified files to Perforce.
  *
  * <b>Example Usage:</b>
  * <table border="1">
  * <th>Function</th><th>Command</th>
  * <tr><td>Add files using P4USER, P4PORT and P4CLIENT settings specified</td>
  * <td>&lt;P4add <br>P4view="//projects/foo/main/source/..." <br>P4User="fbloggs"
  * <br>P4Port="km01:1666"
  * <br>P4Client="fbloggsclient"&gt;<br>&lt;fileset basedir="dir" includes="**&#47;*.java"&gt;<br>
  * &lt;/p4add&gt;</td></tr>
  * <tr><td>Add files using P4USER, P4PORT and P4CLIENT settings defined in environment</td><td>
  * &lt;P4add P4view="//projects/foo/main/source/..." /&gt;<br>&lt;fileset basedir="dir"
  * includes="**&#47;*.java"&gt;<br>&lt;/p4add&gt;</td></tr>
  * <tr><td>Specify the length of command line arguments to pass to each invocation of p4</td>
  * <td>&lt;p4add Commandlength="450"&gt;</td></tr>
  * </table>
  *
  * @ant.task category="scm"
  */
 public class P4Add extends P4Base {
     private static final int DEFAULT_CMD_LENGTH = 450;
     private int changelist;
     private String addCmd = "";
     private Vector filesets = new Vector();
     private int cmdLength = DEFAULT_CMD_LENGTH;
 
     /**
      *   Set the maximum length
      *   of the commandline when calling Perforce to add the files.
      *   Defaults to 450, higher values mean faster execution,
      *   but also possible failures.
      *   @param len maximum length of command line default is 450.
      *   @throws BuildException if trying to set the command line length to 0 or less.
      */
 
     public void setCommandlength(int len) throws BuildException {
         if (len <= 0) {
             throw new BuildException("P4Add: Commandlength should be a positive number");
         }
         this.cmdLength = len;
     }
 
     /**
      * If specified the open files are associated with the
      * specified pending changelist number; otherwise the open files are
      * associated with the default changelist.
      *
      * @param changelist the change list number.
      *
      * @throws BuildException if trying to set a change list number &lt;=0.
      */
     public void setChangelist(int changelist) throws BuildException {
         if (changelist <= 0) {
             throw new BuildException("P4Add: Changelist# should be a positive number");
         }
         this.changelist = changelist;
     }
 
     /**
      * Add a fileset whose files will be added to Perforce.
      *
      * @param set the FileSet that one wants to add to Perforce Source Control.
      */
     public void addFileset(FileSet set) {
         filesets.addElement(set);
     }
 
     /**
      * Run the task.
      *
      * @throws BuildException if the execution of the Perforce command fails.
      */
     public void execute() throws BuildException {
         if (P4View != null) {
             addCmd = P4View;
         }
         P4CmdOpts = (changelist > 0) ? ("-c " + changelist) : "";
 
         StringBuffer filelist = new StringBuffer();
 
-        for (int i = 0; i < filesets.size(); i++) {
+        final int size = filesets.size();
+        for (int i = 0; i < size; i++) {
             FileSet fs = (FileSet) filesets.elementAt(i);
             DirectoryScanner ds = fs.getDirectoryScanner(getProject());
 
             String[] srcFiles = ds.getIncludedFiles();
             if (srcFiles != null) {
                 for (int j = 0; j < srcFiles.length; j++) {
                     File f = new File(ds.getBasedir(), srcFiles[j]);
                     filelist.append(" ").append('"').append(f.getAbsolutePath()).append('"');
                     if (filelist.length() > cmdLength) {
                         execP4Add(filelist);
                         filelist = new StringBuffer();
                     }
                 }
                 if (filelist.length() > 0) {
                     execP4Add(filelist);
                 }
             } else {
                 log("No files specified to add!", Project.MSG_WARN);
             }
         }
     }
 
     private void execP4Add(StringBuffer list) {
         log("Execing add " + P4CmdOpts + " " + addCmd + list, Project.MSG_INFO);
         execP4Command("-s add " + P4CmdOpts + " " + addCmd + list, new SimpleP4OutputHandler(this));
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Fstat.java b/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Fstat.java
index e7fd0580f..7ef4d48d1 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Fstat.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Fstat.java
@@ -1,198 +1,200 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 /*
  * Portions of this software are based upon public domain software
  * originally written at the National Center for Supercomputing Applications,
  * University of Illinois, Urbana-Champaign.
  */
 
 package org.apache.tools.ant.taskdefs.optional.perforce;
 
 
 import java.io.File;
 import java.util.Vector;
 import java.util.ArrayList;
 
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.types.FileSet;
 
 /**
  * P4Fstat--find out which files are under Perforce control and which are not.
  *
  * <br><b>Example Usage:</b><br>
  * <pre>
  * &lt;project name=&quot;p4fstat&quot; default=&quot;p4fstat&quot;
  * basedir=&quot;C:\dev\gnu&quot;&gt;
  *     &lt;target name=&quot;p4fstat&quot; &gt;
  *         &lt;p4fstat showfilter=&quot;all&quot;&gt;
  *             &lt;fileset dir=&quot;depot&quot; includes=&quot;**\/*&quot;/&gt;
  *         &lt;/p4fstat&gt;
  *     &lt;/target&gt;
  * &lt;/project&gt;
  * </pre>
  *
  * @ant.task category="scm"
  */
 public class P4Fstat extends P4Base {
 
     private int changelist;
     private String addCmd = "";
     private Vector filesets = new Vector();
     private static final int DEFAULT_CMD_LENGTH = 300;
     private int cmdLength = DEFAULT_CMD_LENGTH;
     private static final int SHOW_ALL = 0;
     private static final int SHOW_EXISTING = 1;
     private static final int SHOW_NON_EXISTING = 2;
     private int show = SHOW_NON_EXISTING;
     private FStatP4OutputHandler handler;
     private StringBuffer filelist;
     private int fileNum = 0;
     private int doneFileNum = 0;
     private boolean debug = false;
 
     private static final String EXISTING_HEADER
         = "Following files exist in perforce";
     private static final String NONEXISTING_HEADER
         = "Following files do not exist in perforce";
 
     /**
      * Sets the filter that one wants applied.
      * <table>
      * <tr><th>Option</th><th>Meaning</th></tr>
      * <tr><td>all</td><td>all files under Perforce control or not</td></tr>
      * <tr><td>existing</td><td>only files under Perforce control</td></tr>
      * <tr><td>non-existing</td><td>only files not under Perforce control or not</td></tr>
      * </table>
      * @param filter should be one of all|existing|non-existing.
      */
     public void setShowFilter(String filter) {
         if (filter.equalsIgnoreCase("all")) {
             show = SHOW_ALL;
         } else if (filter.equalsIgnoreCase("existing")) {
             show = SHOW_EXISTING;
         } else if (filter.equalsIgnoreCase("non-existing")) {
             show = SHOW_NON_EXISTING;
         } else {
             throw new BuildException("P4Fstat: ShowFilter should be one of: "
                 + "all, existing, non-existing");
         }
     }
 
     /**
      * Sets optionally a change list number.
      * @param changelist change list that one wants information about.
      * @throws BuildException if the change list number is negative.
      */
     public void setChangelist(int changelist) throws BuildException {
         if (changelist <= 0) {
             throw new BuildException("P4FStat: Changelist# should be a "
                 + "positive number");
         }
         this.changelist = changelist;
     }
 
     /**
      * Adds a fileset to be examined by p4fstat.
      * @param set the fileset to add.
      */
     public void addFileset(FileSet set) {
         filesets.addElement(set);
     }
 
     /**
      * Executes the p4fstat task.
      * @throws BuildException if no files are specified.
      */
     public void execute() throws BuildException {
         handler = new FStatP4OutputHandler(this);
         if (P4View != null) {
             addCmd = P4View;
         }
         P4CmdOpts = (changelist > 0) ? ("-c " + changelist) : "";
 
         filelist = new StringBuffer();
 
-        for (int i = 0; i < filesets.size(); i++) {
+        final int size = filesets.size();
+        for (int i = 0; i < size; i++) {
             FileSet fs = (FileSet) filesets.elementAt(i);
             DirectoryScanner ds = fs.getDirectoryScanner(getProject());
 
             String[] srcFiles = ds.getIncludedFiles();
 
             if (srcFiles != null) {
                 fileNum = srcFiles.length;
                 for (int j = 0; j < srcFiles.length; j++) {
                     File f = new File(ds.getBasedir(), srcFiles[j]);
                     filelist.append(" ").append('"').append(f.getAbsolutePath()).append('"');
                     doneFileNum++;
                     if (filelist.length() > cmdLength) {
 
                         execP4Fstat(filelist);
                         filelist = new StringBuffer();
                     }
                 }
                 if (filelist.length() > 0) {
                     execP4Fstat(filelist);
                 }
             } else {
                 log("No files specified to query status on!", Project.MSG_WARN);
             }
         }
         if (show == SHOW_ALL || show == SHOW_EXISTING) {
             printRes(handler.getExisting(), EXISTING_HEADER);
         }
         if (show == SHOW_ALL || show == SHOW_NON_EXISTING) {
             printRes(handler.getNonExisting(), NONEXISTING_HEADER);
         }
     }
 
     /**
      * Return the number of files seen.
      * @return the number of files seen.
      */
     public int getLengthOfTask() {
         return fileNum;
     }
 
     /**
      * Return the number of passes to make.
      * IS THIS BEING USED?
      * @return number of passes (how many filesets).
      */
     int getPasses() {
         return filesets.size();
     }
 
     private void printRes(ArrayList ar, String header) {
         log(header, Project.MSG_INFO);
-        for (int i = 0; i < ar.size(); i++) {
+        final int size = ar.size();
+        for (int i = 0; i < size; i++) {
             log((String) ar.get(i), Project.MSG_INFO);
         }
     }
 
     private void execP4Fstat(StringBuffer list) {
         String l = list.substring(0);
         if (debug) {
             log("Executing fstat " + P4CmdOpts + " " + addCmd + l + "\n",
                 Project.MSG_INFO);
         }
         execP4Command("fstat " + P4CmdOpts + " " + addCmd + l, handler);
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Submit.java b/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Submit.java
index 763883c50..9409b19be 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Submit.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/perforce/P4Submit.java
@@ -1,154 +1,155 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 /*
  * Portions of this software are based upon public domain software
  * originally written at the National Center for Supercomputing Applications,
  * University of Illinois, Urbana-Champaign.
  */
 
 package org.apache.tools.ant.taskdefs.optional.perforce;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import java.util.Vector;
 
 /** Submits a numbered changelist to Perforce.
  *
  * <B>Note:</B> P4Submit cannot (yet) submit the default changelist.
  * This shouldn't be a problem with the ANT task as the usual flow is
  * P4Change to create a new numbered change followed by P4Edit then P4Submit.
  *
  * Example Usage:-<br>
  * &lt;p4submit change="${p4.change}" /&gt;
  *
  * @ant.task category="scm"
  */
 public class P4Submit extends P4Base {
 
     // CheckStyle:VisibilityModifier OFF - bc
     //ToDo: If dealing with default cl need to parse out <enter description here>
     /**
      * change list number
      */
     public String change;
     // CheckStyle:VisibilityModifier ON
     /**
      * change property
      */
     private String changeProperty;
     /**
      * needsresolveproperty
      */
     private String needsResolveProperty;
     /**
      * set the change list number to submit
      * @param change The changelist number to submit; required.
      */
     public void setChange(String change) {
         this.change = change;
     }
     /**
      * property defining the change number if the change number gets renumbered
      * @param changeProperty name of a new property to which the change number
      * will be assigned if it changes
      * @since ant 1.6.1
      */
     public void setChangeProperty(String changeProperty) {
         this.changeProperty = changeProperty;
     }
     /**
      * property defining the need to resolve the change list
      * @param needsResolveProperty a property which will be set if the change needs resolve
      * @since ant 1.6.1
      */
     public void setNeedsResolveProperty(String needsResolveProperty) {
         this.needsResolveProperty = needsResolveProperty;
     }
 
     /**
      * do the work
      * @throws BuildException if no change list specified
      */
     public void execute() throws BuildException {
         if (change != null) {
             execP4Command("submit -c " + change, (P4HandlerAdapter) new P4SubmitAdapter(this));
         } else {
             //here we'd parse the output from change -o into submit -i
             //in order to support default change.
             throw new BuildException("No change specified (no support for default change yet....");
         }
     }
 
     /**
      * internal class used to process the output of p4 submit
      */
     public class P4SubmitAdapter extends SimpleP4OutputHandler {
         /**
          * Constructor.
          * @param parent a P4Base instance.
          */
         public P4SubmitAdapter(P4Base parent) {
             super(parent);
         }
         /**
          * process a line of stdout/stderr coming from Perforce
          * @param line line of stdout or stderr coming from Perforce
          */
         public void process(String line) {
             super.process(line);
             getProject().setProperty("p4.needsresolve", "0");
             // this type of output might happen
             // Change 18 renamed change 20 and submitted.
             if (util.match("/renamed/", line)) {
                 try {
                     Vector myarray = new Vector();
                     util.split(myarray, line);
                     boolean found = false;
-                    for (int counter = 0; counter < myarray.size(); counter++) {
+                    final int size = myarray.size();
+                    for (int counter = 0; counter < size; counter++) {
                         if (found) {
                             String chnum = (String) myarray.elementAt(counter + 1);
                             int changenumber = Integer.parseInt(chnum);
                             log("Perforce change renamed " + changenumber, Project.MSG_INFO);
                             getProject().setProperty("p4.change", "" + changenumber);
                             if (changeProperty != null) {
                                 getProject().setNewProperty(changeProperty, chnum);
                             }
                             found = false;
                         }
                         if (((myarray.elementAt(counter))).equals("renamed")) {
                             found = true;
                         }
                     }
                 // NumberFormatException or ArrayOutOfBondsException could happen here
                 } catch (Exception e) {
                     String msg = "Failed to parse " + line  + "\n"
                             + " due to " + e.getMessage();
                     throw new BuildException(msg, e, getLocation());
                 }
             }
             if (util.match("/p4 submit -c/", line)) {
                 getProject().setProperty("p4.needsresolve", "1");
                 if (needsResolveProperty != null) {
                     getProject().setNewProperty(needsResolveProperty, "true");
                 }
             }
 
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/ssh/ScpFromMessageBySftp.java b/src/main/org/apache/tools/ant/taskdefs/optional/ssh/ScpFromMessageBySftp.java
index c30696c76..cd733d13d 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/ssh/ScpFromMessageBySftp.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/ssh/ScpFromMessageBySftp.java
@@ -1,204 +1,205 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional.ssh;
 
 import java.io.File;
 import java.io.IOException;
 
 import com.jcraft.jsch.JSchException;
 import com.jcraft.jsch.Session;
 import com.jcraft.jsch.ChannelSftp;
 import com.jcraft.jsch.SftpException;
 import com.jcraft.jsch.SftpATTRS;
 import com.jcraft.jsch.SftpProgressMonitor;
 
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * A helper object representing an scp download.
  */
 public class ScpFromMessageBySftp extends ScpFromMessage {
 
     private static final int HUNDRED_KILOBYTES = 102400;
 
     private String remoteFile;
     private File localFile;
     private boolean isRecursive = false;
     private boolean verbose = false;
 
     /**
      * Constructor for ScpFromMessageBySftp.
      * @param verbose if true log extra information
      * @param session the Scp session to use
      * @param aRemoteFile the remote file name
      * @param aLocalFile  the local file
      * @param recursive   if true use recursion
      * @since Ant 1.7
      */
     public ScpFromMessageBySftp(boolean verbose,
                                 Session session,
                                 String aRemoteFile,
                                 File aLocalFile,
                                 boolean recursive) {
         this(verbose, session, aRemoteFile, aLocalFile, recursive, false);
     }
 
     /**
      * Constructor for ScpFromMessageBySftp.
      * @param session the Scp session to use
      * @param aRemoteFile the remote file name
      * @param aLocalFile  the local file
      * @param recursive   if true use recursion
      */
     public ScpFromMessageBySftp(Session session,
                                 String aRemoteFile,
                                 File aLocalFile,
                                 boolean recursive) {
         this(false, session, aRemoteFile, aLocalFile, recursive);
     }
 
     /**
      * Constructor for ScpFromMessageBySftp.
      * @param verbose if true log extra information
      * @param session the Scp session to use
      * @param aRemoteFile the remote file name
      * @param aLocalFile  the local file
      * @param recursive   if true use recursion
      * @param preserveLastModified whether to preserve file
      * modification times
      * @since Ant 1.8.0
      */
     public ScpFromMessageBySftp(boolean verbose,
                                 Session session,
                                 String aRemoteFile,
                                 File aLocalFile,
                                 boolean recursive,
                                 boolean preserveLastModified) {
         super(verbose, session, aRemoteFile, aLocalFile, recursive,
               preserveLastModified);
         this.verbose = verbose;
         this.remoteFile = aRemoteFile;
         this.localFile = aLocalFile;
         this.isRecursive = recursive;
     }
 
     /**
      * Carry out the transfer.
      * @throws IOException on i/o errors
      * @throws JSchException on errors detected by scp
      */
     public void execute() throws IOException, JSchException {
         ChannelSftp channel = openSftpChannel();
         try {
             channel.connect();
             try {
                 SftpATTRS attrs = channel.stat(remoteFile);
                 if (attrs.isDir() && !remoteFile.endsWith("/")) {
                     remoteFile = remoteFile + "/";
                 }
             } catch (SftpException ee) {
                 // Ignored
             }
             getDir(channel, remoteFile, localFile);
         } catch (SftpException e) {
             JSchException schException = new JSchException("Could not get '"+ remoteFile
                     +"' to '"+localFile+"' - "
                     +e.toString());
             schException.initCause(e);
             throw schException;
         } finally {
             if (channel != null) {
                 channel.disconnect();
             }
         }
         log("done\n");
     }
 
     private void getDir(ChannelSftp channel,
                         String remoteFile,
                         File localFile) throws IOException, SftpException {
         String pwd = remoteFile;
         if (remoteFile.lastIndexOf('/') != -1) {
             if (remoteFile.length() > 1) {
                 pwd = remoteFile.substring(0, remoteFile.lastIndexOf('/'));
             }
         }
         channel.cd(pwd);
         if (!localFile.exists()) {
             localFile.mkdirs();
         }
         java.util.Vector files = channel.ls(remoteFile);
-        for (int i = 0; i < files.size(); i++) {
+        final int size = files.size();
+        for (int i = 0; i < size; i++) {
             ChannelSftp.LsEntry le = (ChannelSftp.LsEntry) files.elementAt(i);
             String name = le.getFilename();
             if (le.getAttrs().isDir()) {
                 if (name.equals(".") || name.equals("..")) {
                     continue;
                 }
                 getDir(channel,
                        channel.pwd() + "/" + name + "/",
                        new File(localFile, le.getFilename()));
             } else {
                 getFile(channel, le, localFile);
             }
         }
         channel.cd("..");
     }
 
     private void getFile(ChannelSftp channel,
                          ChannelSftp.LsEntry le,
                          File localFile) throws IOException, SftpException {
         String remoteFile = le.getFilename();
         if (!localFile.exists()) {
             String path = localFile.getAbsolutePath();
             int i = path.lastIndexOf(File.pathSeparator);
             if (i != -1) {
                 if (path.length() > File.pathSeparator.length()) {
                     new File(path.substring(0, i)).mkdirs();
                 }
             }
         }
 
         if (localFile.isDirectory()) {
             localFile = new File(localFile, remoteFile);
         }
 
         long startTime = System.currentTimeMillis();
         long totalLength = le.getAttrs().getSize();
 
         SftpProgressMonitor monitor = null;
         boolean trackProgress = getVerbose() && totalLength > HUNDRED_KILOBYTES;
         if (trackProgress) {
             monitor = getProgressMonitor();
         }
         try {
             log("Receiving: " + remoteFile + " : " + le.getAttrs().getSize());
             channel.get(remoteFile, localFile.getAbsolutePath(), monitor);
         } finally {
             long endTime = System.currentTimeMillis();
             logStats(startTime, endTime, (int) totalLength);
         }
         if (getPreserveLastModified()) {
             FileUtils.getFileUtils().setFileLastModified(localFile,
                                                          ((long) le.getAttrs()
                                                           .getMTime())
                                                          * 1000);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/unix/Symlink.java b/src/main/org/apache/tools/ant/taskdefs/optional/unix/Symlink.java
index 181cfbd5d..3b6fcd3b1 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/unix/Symlink.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/unix/Symlink.java
@@ -1,594 +1,596 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 /*
  * Since the initial version of this file was developed on the clock on
  * an NSF grant I should say the following boilerplate:
  *
  * This material is based upon work supported by the National Science
  * Foundaton under Grant No. EIA-0196404. Any opinions, findings, and
  * conclusions or recommendations expressed in this material are those
  * of the author and do not necessarily reflect the views of the
  * National Science Foundation.
  */
 
 package org.apache.tools.ant.taskdefs.optional.unix;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintStream;
 
 import java.util.HashSet;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Properties;
 import java.util.Vector;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.dispatch.DispatchTask;
 import org.apache.tools.ant.dispatch.DispatchUtils;
 import org.apache.tools.ant.taskdefs.Execute;
 import org.apache.tools.ant.taskdefs.LogOutputStream;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.SymbolicLinkUtils;
 
 /**
  * Creates, Deletes, Records and Restores Symlinks.
  *
  * <p> This task performs several related operations. In the most trivial
  * and default usage, it creates a link specified in the link attribute to
  * a resource specified in the resource attribute. The second usage of this
  * task is to traverse a directory structure specified by a fileset,
  * and write a properties file in each included directory describing the
  * links found in that directory. The third usage is to traverse a
  * directory structure specified by a fileset, looking for properties files
  * (also specified as included in the fileset) and recreate the links
  * that have been previously recorded for each directory. Finally, it can be
  * used to remove a symlink without deleting the associated resource.
  *
  * <p> Usage examples:
  *
  * <p> Make a link named &quot;foo&quot; to a resource named
  * &quot;bar.foo&quot; in subdir:
  * <pre>
  * &lt;symlink link=&quot;${dir.top}/foo&quot; resource=&quot;${dir.top}/subdir/bar.foo&quot;/&gt;
  * </pre>
  *
  * <p> Record all links in subdir and its descendants in files named
  * &quot;dir.links&quot;:
  * <pre>
  * &lt;symlink action=&quot;record&quot; linkfilename=&quot;dir.links&quot;&gt;
  *    &lt;fileset dir=&quot;${dir.top}&quot; includes=&quot;subdir&#47;**&quot; /&gt;
  * &lt;/symlink&gt;
  * </pre>
  *
  * <p> Recreate the links recorded in the previous example:
  * <pre>
  * &lt;symlink action=&quot;recreate&quot;&gt;
  *    &lt;fileset dir=&quot;${dir.top}&quot; includes=&quot;subdir&#47;**&#47;dir.links&quot; /&gt;
  * &lt;/symlink&gt;
  * </pre>
  *
  * <p> Delete a link named &quot;foo&quot; to a resource named
  * &quot;bar.foo&quot; in subdir:
  * <pre>
  * &lt;symlink action=&quot;delete&quot; link=&quot;${dir.top}/foo&quot;/&gt;
  * </pre>
  *
  * <p><strong>LIMITATIONS:</strong> Because Java has no direct support for
  * handling symlinks this task divines them by comparing canonical and
  * absolute paths. On non-unix systems this may cause false positives.
  * Furthermore, any operating system on which the command
  * <code>ln -s link resource</code> is not a valid command on the command line
  * will not be able to use action=&quot;delete&quot;, action=&quot;single&quot;
  * or action=&quot;recreate&quot;, but action=&quot;record&quot; should still
  * work. Finally, the lack of support for symlinks in Java means that all links
  * are recorded as links to the <strong>canonical</strong> resource name.
  * Therefore the link: <code>link --> subdir/dir/../foo.bar</code> will be
  * recorded as <code>link=subdir/foo.bar</code> and restored as
  * <code>link --> subdir/foo.bar</code>.
  *
  */
 public class Symlink extends DispatchTask {
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
     private static final SymbolicLinkUtils SYMLINK_UTILS =
         SymbolicLinkUtils.getSymbolicLinkUtils();
 
     private String resource;
     private String link;
     private Vector fileSets = new Vector();
     private String linkFileName;
     private boolean overwrite;
     private boolean failonerror;
     private boolean executing = false;
 
     /**
      * Initialize the task.
      * @throws BuildException on error.
      */
     public void init() throws BuildException {
         super.init();
         setDefaults();
     }
 
     /**
      * The standard method for executing any task.
      * @throws BuildException on error.
      */
     public synchronized void execute() throws BuildException {
         if (executing) {
             throw new BuildException(
                 "Infinite recursion detected in Symlink.execute()");
         }
         try {
             executing = true;
             DispatchUtils.execute(this);
         } finally {
             executing = false;
         }
     }
 
     /**
      * Create a symlink.
      * @throws BuildException on error.
      * @since Ant 1.7
      */
     public void single() throws BuildException {
         try {
             if (resource == null) {
                 handleError("Must define the resource to symlink to!");
                 return;
             }
             if (link == null) {
                 handleError("Must define the link name for symlink!");
                 return;
             }
             doLink(resource, link);
         } finally {
             setDefaults();
         }
     }
 
     /**
      * Delete a symlink.
      * @throws BuildException on error.
      * @since Ant 1.7
      */
     public void delete() throws BuildException {
         try {
             if (link == null) {
                 handleError("Must define the link name for symlink!");
                 return;
             }
             log("Removing symlink: " + link);
             SYMLINK_UTILS.deleteSymbolicLink(FILE_UTILS
                                              .resolveFile(new File("."), link),
                                              this);
         } catch (FileNotFoundException fnfe) {
             handleError(fnfe.toString());
         } catch (IOException ioe) {
             handleError(ioe.toString());
         } finally {
             setDefaults();
         }
     }
 
     /**
      * Restore symlinks.
      * @throws BuildException on error.
      * @since Ant 1.7
      */
     public void recreate() throws BuildException {
         try {
             if (fileSets.isEmpty()) {
                 handleError("File set identifying link file(s) "
                             + "required for action recreate");
                 return;
             }
             Properties links = loadLinks(fileSets);
 
             for (Iterator kitr = links.keySet().iterator(); kitr.hasNext();) {
                 String lnk = (String) kitr.next();
                 String res = links.getProperty(lnk);
                 // handle the case where lnk points to a directory (bug 25181)
                 try {
                     File test = new File(lnk);
                     if (!SYMLINK_UTILS.isSymbolicLink(lnk)) {
                         doLink(res, lnk);
                     } else if (!test.getCanonicalPath().equals(
                         new File(res).getCanonicalPath())) {
                         SYMLINK_UTILS.deleteSymbolicLink(test, this);
                         doLink(res, lnk);
                     } // else lnk exists, do nothing
                 } catch (IOException ioe) {
                     handleError("IO exception while creating link");
                 }
             }
         } finally {
             setDefaults();
         }
     }
 
     /**
      * Record symlinks.
      * @throws BuildException on error.
      * @since Ant 1.7
      */
     public void record() throws BuildException {
         try {
             if (fileSets.isEmpty()) {
                 handleError("Fileset identifying links to record required");
                 return;
             }
             if (linkFileName == null) {
                 handleError("Name of file to record links in required");
                 return;
             }
             // create a hashtable to group them by parent directory:
             Hashtable byDir = new Hashtable();
 
             // get an Iterator of file objects representing links (canonical):
             for (Iterator litr = findLinks(fileSets).iterator();
                 litr.hasNext();) {
                 File thisLink = (File) litr.next();
                 File parent = thisLink.getParentFile();
                 Vector v = (Vector) byDir.get(parent);
                 if (v == null) {
                     v = new Vector();
                     byDir.put(parent, v);
                 }
                 v.addElement(thisLink);
             }
             // write a Properties file in each directory:
             for (Iterator dirs = byDir.keySet().iterator(); dirs.hasNext();) {
                 File dir = (File) dirs.next();
                 Vector linksInDir = (Vector) byDir.get(dir);
                 Properties linksToStore = new Properties();
 
                 // fill up a Properties object with link and resource names:
                 for (Iterator dlnk = linksInDir.iterator(); dlnk.hasNext();) {
                     File lnk = (File) dlnk.next();
                     try {
                         linksToStore.put(lnk.getName(), lnk.getCanonicalPath());
                     } catch (IOException ioe) {
                         handleError("Couldn't get canonical name of parent link");
                     }
                 }
                 writePropertyFile(linksToStore, dir);
             }
         } finally {
             setDefaults();
         }
     }
 
     /**
      * Return all variables to their default state for the next invocation.
      * @since Ant 1.7
      */
     private void setDefaults() {
         resource = null;
         link = null;
         linkFileName = null;
         failonerror = true;   // default behavior is to fail on an error
         overwrite = false;    // default behavior is to not overwrite
         setAction("single");      // default behavior is make a single link
         fileSets.clear();
     }
 
     /**
      * Set overwrite mode. If set to false (default)
      * the task will not overwrite existing links, and may stop the build
      * if a link already exists depending on the setting of failonerror.
      *
      * @param owrite If true overwrite existing links.
      */
     public void setOverwrite(boolean owrite) {
         this.overwrite = owrite;
     }
 
     /**
      * Set failonerror mode. If set to true (default) the entire build fails
      * upon error; otherwise the error is logged and the build will continue.
      *
      * @param foe    If true throw BuildException on error, else log it.
      */
     public void setFailOnError(boolean foe) {
         this.failonerror = foe;
     }
 
     /**
      * Set the action to be performed.  May be &quot;single&quot;,
      * &quot;delete&quot;, &quot;recreate&quot; or &quot;record&quot;.
      *
      * @param action    The action to perform.
      */
     public void setAction(String action) {
         super.setAction(action);
     }
 
     /**
      * Set the name of the link. Used when action = &quot;single&quot;.
      *
      * @param lnk     The name for the link.
      */
     public void setLink(String lnk) {
         this.link = lnk;
     }
 
     /**
      * Set the name of the resource to which a link should be created.
      * Used when action = &quot;single&quot;.
      *
      * @param src      The resource to be linked.
      */
     public void setResource(String src) {
         this.resource = src;
     }
 
     /**
      * Set the name of the file to which links will be written.
      * Used when action = &quot;record&quot;.
      *
      * @param lf      The name of the file to write links to.
      */
     public void setLinkfilename(String lf) {
         this.linkFileName = lf;
     }
 
     /**
      * Add a fileset to this task.
      *
      * @param set      The fileset to add.
      */
     public void addFileset(FileSet set) {
         fileSets.addElement(set);
     }
 
     /**
      * Delete a symlink (without deleting the associated resource).
      *
      * <p>This is a convenience method that simply invokes
      * <code>deleteSymlink(java.io.File)</code>.
      *
      * @param path    A string containing the path of the symlink to delete.
      *
      * @throws FileNotFoundException   When the path results in a
      *                                   <code>File</code> that doesn't exist.
      * @throws IOException             If calls to <code>File.rename</code>
      *                                   or <code>File.delete</code> fail.
      * @deprecated use
      * org.apache.tools.ant.util.SymbolicLinkUtils#deleteSymbolicLink
      * instead
      */
     public static void deleteSymlink(String path)
         throws IOException, FileNotFoundException {
         SYMLINK_UTILS.deleteSymbolicLink(new File(path), null);
     }
 
     /**
      * Delete a symlink (without deleting the associated resource).
      *
      * <p>This is a utility method that removes a unix symlink without removing
      * the resource that the symlink points to. If it is accidentally invoked
      * on a real file, the real file will not be harmed.</p>
      *
      * <p>This method works by
      * getting the canonical path of the link, using the canonical path to
      * rename the resource (breaking the link) and then deleting the link.
      * The resource is then returned to its original name inside a finally
      * block to ensure that the resource is unharmed even in the event of
      * an exception.</p>
      *
      * <p>Since Ant 1.8.0 this method will try to delete the File object if
      * it reports it wouldn't exist (as symlinks pointing nowhere usually do). 
      * Prior version would throw a FileNotFoundException in that case.</p>
      *
      * @param linkfil    A <code>File</code> object of the symlink to delete.
      *
      * @throws IOException             If calls to <code>File.rename</code>,
      *                                   <code>File.delete</code> or
      *                                   <code>File.getCanonicalPath</code>
      *                                   fail.
      * @deprecated use
      * org.apache.tools.ant.util.SymbolicLinkUtils#deleteSymbolicLink
      * instead
      */
     public static void deleteSymlink(File linkfil)
         throws IOException {
         SYMLINK_UTILS.deleteSymbolicLink(linkfil, null);
     }
 
     /**
      * Write a properties file. This method uses <code>Properties.store</code>
      * and thus may throw exceptions that occur while writing the file.
      *
      * @param properties     The properties object to be written.
      * @param dir            The directory for which we are writing the links.
      * @throws BuildException if the property file could not be written
      */
     private void writePropertyFile(Properties properties, File dir)
         throws BuildException {
         BufferedOutputStream bos = null;
         try {
             bos = new BufferedOutputStream(
                 new FileOutputStream(new File(dir, linkFileName)));
             properties.store(bos, "Symlinks from " + dir);
         } catch (IOException ioe) {
             throw new BuildException(ioe, getLocation());
         } finally {
             FileUtils.close(bos);
         }
     }
 
     /**
      * Handle errors based on the setting of failonerror.
      *
      * @param msg    The message to log, or include in the
      *                  <code>BuildException</code>.
      * @throws BuildException with the message if failonerror=true
      */
     private void handleError(String msg) {
         if (failonerror) {
             throw new BuildException(msg);
         }
         log(msg);
     }
 
     /**
      * Conduct the actual construction of a link.
      *
      * <p> The link is constructed by calling <code>Execute.runCommand</code>.
      *
      * @param res   The path of the resource we are linking to.
      * @param lnk       The name of the link we wish to make.
      * @throws BuildException when things go wrong
      */
     private void doLink(String res, String lnk) throws BuildException {
         File linkfil = new File(lnk);
         String options = "-s";
         if (overwrite) {
             options += "f";
             if (linkfil.exists()) {
                 try {
                     SYMLINK_UTILS.deleteSymbolicLink(linkfil, this);
                 } catch (FileNotFoundException fnfe) {
                     log("Symlink disappeared before it was deleted: " + lnk);
                 } catch (IOException ioe) {
                     log("Unable to overwrite preexisting link or file: " + lnk,
                         ioe, Project.MSG_INFO);
                 }
             }
         }
         String[] cmd = new String[] {"ln", options, res, lnk};
         try {
             Execute.runCommand(this, cmd);
         } catch (BuildException failedToExecute) {
             if (failonerror) {
                 throw failedToExecute;
             } else {
                 //log at the info level, and keep going.
                 log(failedToExecute.getMessage(), failedToExecute, Project.MSG_INFO);
             }
         }
     }
 
     /**
      * Find all the links in all supplied filesets.
      *
      * <p> This method is invoked when the action attribute is
      * &quot;record&quot;. This means that filesets are interpreted
      * as the directories in which links may be found.
      *
      * @param v   The filesets specified by the user.
      * @return A HashSet of <code>File</code> objects containing the
      *         links (with canonical parent directories).
      */
     private HashSet findLinks(Vector v) {
         HashSet result = new HashSet();
-        for (int i = 0; i < v.size(); i++) {
+        final int size = v.size();
+        for (int i = 0; i < size; i++) {
             FileSet fs = (FileSet) v.get(i);
             DirectoryScanner ds = fs.getDirectoryScanner(getProject());
             String[][] fnd = new String[][]
                 {ds.getIncludedFiles(), ds.getIncludedDirectories()};
             File dir = fs.getDir(getProject());
             for (int j = 0; j < fnd.length; j++) {
                 for (int k = 0; k < fnd[j].length; k++) {
                     try {
                         File f = new File(dir, fnd[j][k]);
                         File pf = f.getParentFile();
                         String name = f.getName();
                         if (SYMLINK_UTILS.isSymbolicLink(pf, name)) {
                             result.add(new File(pf.getCanonicalFile(), name));
                         }
                     } catch (IOException e) {
                         handleError("IOException: " + fnd[j][k] + " omitted");
                     }
                 }
             }
         }
         return result;
     }
 
     /**
      * Load links from properties files included in one or more FileSets.
      *
      * <p> This method is only invoked when the action attribute is set to
      * &quot;recreate&quot;. The filesets passed in are assumed to specify the
      * names of the property files with the link information and the
      * subdirectories in which to look for them.
      *
      * @param v    The <code>FileSet</code>s for this task.
      * @return            The links to be made.
      */
     private Properties loadLinks(Vector v) {
         Properties finalList = new Properties();
         // loop through the supplied file sets:
-        for (int i = 0; i < v.size(); i++) {
+        final int size = v.size();
+        for (int i = 0; i < size; i++) {
             FileSet fs = (FileSet) v.elementAt(i);
             DirectoryScanner ds = new DirectoryScanner();
             fs.setupDirectoryScanner(ds, getProject());
             ds.setFollowSymlinks(false);
             ds.scan();
             String[] incs = ds.getIncludedFiles();
             File dir = fs.getDir(getProject());
 
             // load included files as properties files:
             for (int j = 0; j < incs.length; j++) {
                 File inc = new File(dir, incs[j]);
                 File pf = inc.getParentFile();
                 Properties lnks = new Properties();
                 InputStream is = null;
                 try {
                     is = new BufferedInputStream(new FileInputStream(inc));
                     lnks.load(is);
                     pf = pf.getCanonicalFile();
                 } catch (FileNotFoundException fnfe) {
                     handleError("Unable to find " + incs[j] + "; skipping it.");
                     continue;
                 } catch (IOException ioe) {
                     handleError("Unable to open " + incs[j]
                                 + " or its parent dir; skipping it.");
                     continue;
                 } finally {
                     FileUtils.close(is);
                 }
                 lnks.list(new PrintStream(
                     new LogOutputStream(this, Project.MSG_INFO)));
                 // Write the contents to our master list of links
                 // This method assumes that all links are defined in
                 // terms of absolute paths, or paths relative to the
                 // working directory:
                 for (Iterator kitr = lnks.keySet().iterator(); kitr.hasNext();) {
                     String key = (String) kitr.next();
                     finalList.put(new File(pf, key).getAbsolutePath(),
                         lnks.getProperty(key));
                 }
             }
         }
         return finalList;
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/Commandline.java b/src/main/org/apache/tools/ant/types/Commandline.java
index 0a800ae30..ad68f1c57 100644
--- a/src/main/org/apache/tools/ant/types/Commandline.java
+++ b/src/main/org/apache/tools/ant/types/Commandline.java
@@ -1,694 +1,695 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types;
 
 import java.io.File;
 import java.util.StringTokenizer;
 import java.util.Vector;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.LinkedList;
 import java.util.Iterator;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.ProjectComponent;
 import org.apache.tools.ant.util.StringUtils;
 import org.apache.tools.ant.taskdefs.condition.Os;
 
 /**
  * Commandline objects help handling command lines specifying processes to
  * execute.
  *
  * The class can be used to define a command line as nested elements or as a
  * helper to define a command line by an application.
  * <p>
  * <code>
  * &lt;someelement&gt;<br>
  * &nbsp;&nbsp;&lt;acommandline executable="/executable/to/run"&gt;<br>
  * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value="argument 1" /&gt;<br>
  * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument line="argument_1 argument_2 argument_3" /&gt;<br>
  * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value="argument 4" /&gt;<br>
  * &nbsp;&nbsp;&lt;/acommandline&gt;<br>
  * &lt;/someelement&gt;<br>
  * </code>
  * The element <code>someelement</code> must provide a method
  * <code>createAcommandline</code> which returns an instance of this class.
  *
  */
 public class Commandline implements Cloneable {
     /** win9x uses a (shudder) bat file (antRun.bat) for executing commands */
     private static final boolean IS_WIN_9X = Os.isFamily("win9x");
 
     /**
      * The arguments of the command
      */
     private Vector arguments = new Vector();
 
     /**
      * the program to execute
      */
     private String executable = null;
 
     protected static final String DISCLAIMER =
         StringUtils.LINE_SEP
         + "The \' characters around the executable and arguments are"
         + StringUtils.LINE_SEP
         + "not part of the command."
         + StringUtils.LINE_SEP;
 
     /**
      * Create a command line from a string.
      * @param toProcess the line: the first element becomes the executable, the rest
      * the arguments.
      */
     public Commandline(String toProcess) {
         super();
         String[] tmp = translateCommandline(toProcess);
         if (tmp != null && tmp.length > 0) {
             setExecutable(tmp[0]);
             for (int i = 1; i < tmp.length; i++) {
                 createArgument().setValue(tmp[i]);
             }
         }
     }
 
     /**
      *  Create an empty command line.
      */
     public Commandline() {
         super();
     }
 
     /**
      * Used for nested xml command line definitions.
      */
     public static class Argument extends ProjectComponent {
 
         private String[] parts;
 
         private String prefix = "";
         private String suffix = "";
 
         /**
          * Set a single commandline argument.
          *
          * @param value a single commandline argument.
          */
         public void setValue(String value) {
             parts = new String[] {value};
         }
 
         /**
          * Set the line to split into several commandline arguments.
          *
          * @param line line to split into several commandline arguments.
          */
         public void setLine(String line) {
             if (line == null) {
                 return;
             }
             parts = translateCommandline(line);
         }
 
         /**
          * Set a single commandline argument and treats it like a
          * PATH--ensuring the right separator for the local platform
          * is used.
          *
          * @param value a single commandline argument.
          */
         public void setPath(Path value) {
             parts = new String[] {value.toString()};
         }
 
         /**
          * Set a single commandline argument from a reference to a
          * path--ensuring the right separator for the local platform
          * is used.
          *
          * @param value a single commandline argument.
          */
         public void setPathref(Reference value) {
             Path p = new Path(getProject());
             p.setRefid(value);
             parts = new String[] {p.toString()};
         }
 
         /**
          * Set a single commandline argument to the absolute filename
          * of the given file.
          *
          * @param value a single commandline argument.
          */
         public void setFile(File value) {
             parts = new String[] {value.getAbsolutePath()};
         }
 
         /**
          * Set the prefix to be placed in front of every part of the
          * argument.
          *
          * @param prefix fixed prefix string.
          * @since Ant 1.8.0
          */
         public void setPrefix(String prefix) {
             this.prefix = prefix != null ? prefix : "";
         }
 
         /**
          * Set the suffix to be placed at the end of every part of the
          * argument.
          *
          * @param suffix fixed suffix string.
          * @since Ant 1.8.0
          */
         public void setSuffix(String suffix) {
             this.suffix = suffix != null ? suffix : "";
         }
 
         /**
          * Return the constituent parts of this Argument.
          * @return an array of strings.
          */
         public String[] getParts() {
             if (parts == null || parts.length == 0
                 || (prefix.length() == 0 && suffix.length() == 0)) {
                 return parts;
             }
             String[] fullParts = new String[parts.length];
             for (int i = 0; i < fullParts.length; ++i) {
                 fullParts[i] = prefix + parts[i] + suffix;
             }
             return fullParts;
         }
     }
 
     /**
      * Class to keep track of the position of an Argument.
      *
      * <p>This class is there to support the srcfile and targetfile
      * elements of &lt;apply&gt;.</p>
      */
     public class Marker {
 
         private int position;
         private int realPos = -1;
         private String prefix = "";
         private String suffix = "";
 
         /**
          * Construct a marker for the specified position.
          * @param position the position to mark.
          */
         Marker(int position) {
             this.position = position;
         }
 
         /**
          * Return the number of arguments that preceded this marker.
          *
          * <p>The name of the executable -- if set -- is counted as the
          * first argument.</p>
          * @return the position of this marker.
          */
         public int getPosition() {
             if (realPos == -1) {
                 realPos = (executable == null ? 0 : 1);
                 for (int i = 0; i < position; i++) {
                     Argument arg = (Argument) arguments.elementAt(i);
                     realPos += arg.getParts().length;
                 }
             }
             return realPos;
         }
 
         /**
          * Set the prefix to be placed in front of the inserted argument.
          *
          * @param prefix fixed prefix string.
          * @since Ant 1.8.0
          */
         public void setPrefix(String prefix) {
             this.prefix = prefix != null ? prefix : "";
         }
 
         /**
          * Get the prefix to be placed in front of the inserted argument.
          *
          * @since Ant 1.8.0
          */
         public String getPrefix() {
             return prefix;
         }
 
         /**
          * Set the suffix to be placed at the end of the inserted argument.
          *
          * @param suffix fixed suffix string.
          * @since Ant 1.8.0
          */
         public void setSuffix(String suffix) {
             this.suffix = suffix != null ? suffix : "";
         }
 
         /**
          * Get the suffix to be placed at the end of the inserted argument.
          *
          * @since Ant 1.8.0
          */
         public String getSuffix() {
             return suffix;
         }
 
     }
 
     /**
      * Create an argument object.
      *
      * <p>Each commandline object has at most one instance of the
      * argument class.  This method calls
      * <code>this.createArgument(false)</code>.</p>
      *
      * @see #createArgument(boolean)
      * @return the argument object.
      */
     public Argument createArgument() {
         return this.createArgument(false);
     }
 
     /**
      * Create an argument object and add it to our list of args.
      *
      * <p>Each commandline object has at most one instance of the
      * argument class.</p>
      *
      * @param insertAtStart if true, the argument is inserted at the
      * beginning of the list of args, otherwise it is appended.
      * @return an argument to be configured
      */
     public Argument createArgument(boolean insertAtStart) {
         Argument argument = new Argument();
         if (insertAtStart) {
             arguments.insertElementAt(argument, 0);
         } else {
             arguments.addElement(argument);
         }
         return argument;
     }
 
     /**
      * Set the executable to run. All file separators in the string
      * are converted to the platform specific value.
      * @param executable the String executable name.
      */
     public void setExecutable(String executable) {
         if (executable == null || executable.length() == 0) {
             return;
         }
         this.executable = executable.replace('/', File.separatorChar)
             .replace('\\', File.separatorChar);
     }
 
     /**
      * Get the executable.
      * @return the program to run--null if not yet set.
      */
     public String getExecutable() {
         return executable;
     }
 
     /**
      * Append the arguments to the existing command.
      * @param line an array of arguments to append.
      */
     public void addArguments(String[] line) {
         for (int i = 0; i < line.length; i++) {
             createArgument().setValue(line[i]);
         }
     }
 
     /**
      * Return the executable and all defined arguments.
      * @return the commandline as an array of strings.
      */
     public String[] getCommandline() {
         List commands = new LinkedList();
         ListIterator list = commands.listIterator();
         addCommandToList(list);
         final String[] result = new String[commands.size()];
         return (String[]) commands.toArray(result);
     }
 
     /**
      * Add the entire command, including (optional) executable to a list.
      * @param list the list to add to.
      * @since Ant 1.6
      */
     public void addCommandToList(ListIterator list) {
         if (executable != null) {
             list.add(executable);
         }
         addArgumentsToList(list);
     }
 
     /**
      * Returns all arguments defined by <code>addLine</code>,
      * <code>addValue</code> or the argument object.
      * @return the arguments as an array of strings.
      */
     public String[] getArguments() {
         List result = new ArrayList(arguments.size() * 2);
         addArgumentsToList(result.listIterator());
         String [] res = new String[result.size()];
         return (String[]) result.toArray(res);
     }
 
     /**
      * Append all the arguments to the tail of a supplied list.
      * @param list the list of arguments.
      * @since Ant 1.6
      */
     public void addArgumentsToList(ListIterator list) {
-        for (int i = 0; i < arguments.size(); i++) {
+        final int size = arguments.size();
+        for (int i = 0; i < size; i++) {
             Argument arg = (Argument) arguments.elementAt(i);
             String[] s = arg.getParts();
             if (s != null) {
                 for (int j = 0; j < s.length; j++) {
                     list.add(s[j]);
                 }
             }
         }
     }
 
     /**
      * Return the command line as a string.
      * @return the command line.
      */
     public String toString() {
         return toString(getCommandline());
     }
 
     /**
      * Put quotes around the given String if necessary.
      *
      * <p>If the argument doesn't include spaces or quotes, return it
      * as is. If it contains double quotes, use single quotes - else
      * surround the argument by double quotes.</p>
      * @param argument the argument to quote if necessary.
      * @return the quoted argument.
      * @exception BuildException if the argument contains both, single
      *                           and double quotes.
      */
     public static String quoteArgument(String argument) {
         if (argument.indexOf("\"") > -1) {
             if (argument.indexOf("\'") > -1) {
                 throw new BuildException("Can\'t handle single and double"
                         + " quotes in same argument");
             } else {
                 return '\'' + argument + '\'';
             }
         } else if (argument.indexOf("\'") > -1
                    || argument.indexOf(" ") > -1
                    // WIN9x uses a bat file for executing commands
                    || (IS_WIN_9X && argument.indexOf(';') != -1)) {
             return '\"' + argument + '\"';
         } else {
             return argument;
         }
     }
 
     /**
      * Quote the parts of the given array in way that makes them
      * usable as command line arguments.
      * @param line the list of arguments to quote.
      * @return empty string for null or no command, else every argument split
      * by spaces and quoted by quoting rules.
      */
     public static String toString(String[] line) {
         // empty path return empty string
         if (line == null || line.length == 0) {
             return "";
         }
         // path containing one or more elements
         final StringBuffer result = new StringBuffer();
         for (int i = 0; i < line.length; i++) {
             if (i > 0) {
                 result.append(' ');
             }
             result.append(quoteArgument(line[i]));
         }
         return result.toString();
     }
 
     /**
      * Crack a command line.
      * @param toProcess the command line to process.
      * @return the command line broken into strings.
      * An empty or null toProcess parameter results in a zero sized array.
      */
     public static String[] translateCommandline(String toProcess) {
         if (toProcess == null || toProcess.length() == 0) {
             //no command? no string
             return new String[0];
         }
         // parse with a simple finite state machine
 
         final int normal = 0;
         final int inQuote = 1;
         final int inDoubleQuote = 2;
         int state = normal;
         StringTokenizer tok = new StringTokenizer(toProcess, "\"\' ", true);
         Vector v = new Vector();
         StringBuffer current = new StringBuffer();
         boolean lastTokenHasBeenQuoted = false;
 
         while (tok.hasMoreTokens()) {
             String nextTok = tok.nextToken();
             switch (state) {
             case inQuote:
                 if ("\'".equals(nextTok)) {
                     lastTokenHasBeenQuoted = true;
                     state = normal;
                 } else {
                     current.append(nextTok);
                 }
                 break;
             case inDoubleQuote:
                 if ("\"".equals(nextTok)) {
                     lastTokenHasBeenQuoted = true;
                     state = normal;
                 } else {
                     current.append(nextTok);
                 }
                 break;
             default:
                 if ("\'".equals(nextTok)) {
                     state = inQuote;
                 } else if ("\"".equals(nextTok)) {
                     state = inDoubleQuote;
                 } else if (" ".equals(nextTok)) {
                     if (lastTokenHasBeenQuoted || current.length() != 0) {
                         v.addElement(current.toString());
                         current = new StringBuffer();
                     }
                 } else {
                     current.append(nextTok);
                 }
                 lastTokenHasBeenQuoted = false;
                 break;
             }
         }
         if (lastTokenHasBeenQuoted || current.length() != 0) {
             v.addElement(current.toString());
         }
         if (state == inQuote || state == inDoubleQuote) {
             throw new BuildException("unbalanced quotes in " + toProcess);
         }
         String[] args = new String[v.size()];
         v.copyInto(args);
         return args;
     }
 
     /**
      * Size operator. This actually creates the command line, so it is not
      * a zero cost operation.
      * @return number of elements in the command, including the executable.
      */
     public int size() {
         return getCommandline().length;
     }
 
     /**
      * Generate a deep clone of the contained object.
      * @return a clone of the contained object
      */
     public Object clone() {
         try {
             Commandline c = (Commandline) super.clone();
             c.arguments = (Vector) arguments.clone();
             return c;
         } catch (CloneNotSupportedException e) {
             throw new BuildException(e);
         }
     }
 
     /**
      * Clear out the whole command line.
      */
     public void clear() {
         executable = null;
         arguments.removeAllElements();
     }
 
     /**
      * Clear out the arguments but leave the executable in place for
      * another operation.
      */
     public void clearArgs() {
         arguments.removeAllElements();
     }
 
     /**
      * Return a marker.
      *
      * <p>This marker can be used to locate a position on the
      * commandline--to insert something for example--when all
      * parameters have been set.</p>
      * @return a marker
      */
     public Marker createMarker() {
         return new Marker(arguments.size());
     }
 
     /**
      * Return a String that describes the command and arguments suitable for
      * verbose output before a call to <code>Runtime.exec(String[])<code>.
      * @return a string that describes the command and arguments.
      * @since Ant 1.5
      */
     public String describeCommand() {
         return describeCommand(this);
     }
 
     /**
      * Return a String that describes the arguments suitable for
      * verbose output before a call to <code>Runtime.exec(String[])<code>.
      * @return a string that describes the arguments.
      * @since Ant 1.5
      */
     public String describeArguments() {
         return describeArguments(this);
     }
 
     /**
      * Return a String that describes the command and arguments suitable for
      * verbose output before a call to <code>Runtime.exec(String[])<code>.
      * @param line the Commandline to describe.
      * @return a string that describes the command and arguments.
      * @since Ant 1.5
      */
     public static String describeCommand(Commandline line) {
         return describeCommand(line.getCommandline());
     }
 
     /**
      * Return a String that describes the arguments suitable for
      * verbose output before a call to <code>Runtime.exec(String[])<code>.
      * @param line the Commandline whose arguments to describe.
      * @return a string that describes the arguments.
      * @since Ant 1.5
      */
     public static String describeArguments(Commandline line) {
         return describeArguments(line.getArguments());
     }
 
     /**
      * Return a String that describes the command and arguments suitable for
      * verbose output before a call to <code>Runtime.exec(String[])<code>.
      *
      * <p>This method assumes that the first entry in the array is the
      * executable to run.</p>
      * @param args the command line to describe as an array of strings
      * @return a string that describes the command and arguments.
      * @since Ant 1.5
      */
     public static String describeCommand(String[] args) {
         if (args == null || args.length == 0) {
             return "";
         }
         StringBuffer buf = new StringBuffer("Executing \'");
         buf.append(args[0]);
         buf.append("\'");
         if (args.length > 1) {
             buf.append(" with ");
             buf.append(describeArguments(args, 1));
         } else {
             buf.append(DISCLAIMER);
         }
         return buf.toString();
     }
 
     /**
      * Return a String that describes the arguments suitable for
      * verbose output before a call to <code>Runtime.exec(String[])<code>.
      * @param args the command line to describe as an array of strings.
      * @return a string that describes the arguments.
      * @since Ant 1.5
      */
     public static String describeArguments(String[] args) {
         return describeArguments(args, 0);
     }
 
     /**
      * Return a String that describes the arguments suitable for
      * verbose output before a call to <code>Runtime.exec(String[])<code>.
      *
      * @param args the command line to describe as an array of strings.
      * @param offset ignore entries before this index.
      * @return a string that describes the arguments
      *
      * @since Ant 1.5
      */
     protected static String describeArguments(String[] args, int offset) {
         if (args == null || args.length <= offset) {
             return "";
         }
         StringBuffer buf = new StringBuffer("argument");
         if (args.length > offset) {
             buf.append("s");
         }
         buf.append(":").append(StringUtils.LINE_SEP);
         for (int i = offset; i < args.length; i++) {
             buf.append("\'").append(args[i]).append("\'")
                 .append(StringUtils.LINE_SEP);
         }
         buf.append(DISCLAIMER);
         return buf.toString();
     }
 
     /**
      * Get an iterator to the arguments list.
      * @since Ant 1.7
      * @return an Iterator.
      */
     public Iterator iterator() {
         return arguments.iterator();
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/Description.java b/src/main/org/apache/tools/ant/types/Description.java
index cb0004ff8..6f8fb4891 100644
--- a/src/main/org/apache/tools/ant/types/Description.java
+++ b/src/main/org/apache/tools/ant/types/Description.java
@@ -1,122 +1,124 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types;
 
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.ProjectHelper;
 import org.apache.tools.ant.helper.ProjectHelper2;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.UnknownElement;
 import org.apache.tools.ant.Target;
 import org.apache.tools.ant.helper.ProjectHelperImpl;
 
 import java.util.Vector;
 
 
 /**
  * Description is used to provide a project-wide description element
  * (that is, a description that applies to a buildfile as a whole).
  * If present, the &lt;description&gt; element is printed out before the
  * target descriptions.
  *
  * Description has no attributes, only text.  There can only be one
  * project description per project.  A second description element will
  * overwrite the first.
  *
  *
  * @ant.datatype ignore="true"
  */
 public class Description extends DataType {
 
     /**
      * Adds descriptive text to the project.
      *
      * @param text the descriptive text
      */
     public void addText(String text) {
 
         ProjectHelper ph = (ProjectHelper) getProject().getReference(ProjectHelper.PROJECTHELPER_REFERENCE);
         if (!(ph instanceof ProjectHelperImpl)) {
             // New behavior for delayed task creation. Description
             // will be evaluated in Project.getDescription()
             return;
         }
         String currentDescription = getProject().getDescription();
         if (currentDescription == null) {
             getProject().setDescription(text);
         } else {
             getProject().setDescription(currentDescription + text);
         }
     }
 
     /**
      * Return the descriptions from all the targets of
      * a project.
      *
      * @param project the project to get the descriptions for.
      * @return a string containing the concatenated descriptions of
      *         the targets.
      */
     public static String getDescription(Project project) {
         Vector targets = (Vector) project.getReference(ProjectHelper2.REFID_TARGETS);
         if (targets == null) {
             return null;
         }
         StringBuffer description = new StringBuffer();
-        for (int i = 0; i < targets.size(); i++) {
+        final int size = targets.size();
+        for (int i = 0; i < size; i++) {
             Target t = (Target) targets.elementAt(i);
             concatDescriptions(project, t, description);
         }
         return description.toString();
     }
 
     private static void concatDescriptions(Project project, Target t,
                                            StringBuffer description) {
         if (t == null) {
             return;
         }
         Vector tasks = findElementInTarget(project, t, "description");
         if (tasks == null) {
             return;
         }
-        for (int i = 0; i < tasks.size(); i++) {
+        final int size = tasks.size();
+        for (int i = 0; i < size; i++) {
             Task task = (Task) tasks.elementAt(i);
             if (!(task instanceof UnknownElement)) {
                 continue;
             }
             UnknownElement ue = ((UnknownElement) task);
             String descComp = ue.getWrapper().getText().toString();
             if (descComp != null) {
                 description.append(project.replaceProperties(descComp));
             }
         }
     }
 
     private static Vector findElementInTarget(Project project,
                                               Target t, String name) {
         Task[] tasks = t.getTasks();
         Vector elems = new Vector();
         for (int i = 0; i < tasks.length; i++) {
             if (name.equals(tasks[i].getTaskName())) {
                 elems.addElement(tasks[i]);
             }
         }
         return elems;
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/types/FilterSet.java b/src/main/org/apache/tools/ant/types/FilterSet.java
index f4886584a..a0786a4a7 100644
--- a/src/main/org/apache/tools/ant/types/FilterSet.java
+++ b/src/main/org/apache/tools/ant/types/FilterSet.java
@@ -1,628 +1,629 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Properties;
 import java.util.Vector;
 
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.VectorSet;
 
 /**
  * A set of filters to be applied to something.
  *
  * A filter set may have begintoken and endtokens defined.
  *
  */
 public class FilterSet extends DataType implements Cloneable {
 
     /**
      * Individual filter component of filterset.
      *
      */
     public static class Filter {
         // CheckStyle:VisibilityModifier OFF - bc
         /** Token which will be replaced in the filter operation. */
         String token;
 
         /** The value which will replace the token in the filtering operation. */
         String value;
         // CheckStyle:VisibilityModifier ON
 
         /**
          * Constructor for the Filter object.
          *
          * @param token  The token which will be replaced when filtering.
          * @param value  The value which will replace the token when filtering.
          */
         public Filter(String token, String value) {
            setToken(token);
            setValue(value);
         }
 
         /**
          * No-argument conmstructor.
          */
         public Filter() {
         }
 
         /**
          * Sets the Token attribute of the Filter object.
          *
          * @param token  The new Token value.
          */
         public void setToken(String token) {
            this.token = token;
         }
 
         /**
          * Sets the Value attribute of the Filter object.
          *
          * @param value  The new Value value.
          */
         public void setValue(String value) {
            this.value = value;
         }
 
         /**
          * Gets the Token attribute of the Filter object.
          *
          * @return   The Token value.
          */
         public String getToken() {
            return token;
         }
 
         /**
          * Gets the Value attribute of the Filter object.
          *
          * @return   The Value value.
          */
         public String getValue() {
            return value;
         }
      }
 
     /**
      * The filtersfile nested element.
      *
      */
     public class FiltersFile {
 
         /**
          * Constructor for the FiltersFile object.
          */
         public FiltersFile() {
         }
 
         /**
          * Sets the file from which filters will be read.
          *
          * @param file the file from which filters will be read.
          */
         public void setFile(File file) {
            filtersFiles.add(file);
         }
     }
 
     /**
      * EnumeratedAttribute to set behavior WRT missing filtersfiles:
      * "fail" (default), "warn", "ignore".
      * @since Ant 1.7
      */
     public static class OnMissing extends EnumeratedAttribute {
         private static final String[] VALUES
             = new String[] {"fail", "warn", "ignore"};
 
         /** Fail value */
         public static final OnMissing FAIL = new OnMissing("fail");
         /** Warn value */
         public static final OnMissing WARN = new OnMissing("warn");
         /** Ignore value */
         public static final OnMissing IGNORE = new OnMissing("ignore");
 
         private static final int FAIL_INDEX = 0;
         private static final int WARN_INDEX = 1;
         private static final int IGNORE_INDEX = 2;
 
         /**
          * Default constructor.
          */
         public OnMissing() {
         }
 
         /**
          * Convenience constructor.
          * @param value the value to set.
          */
         public OnMissing(String value) {
             setValue(value);
         }
 
         //inherit doc
         /** {@inheritDoc}. */
         public String[] getValues() {
             return VALUES;
         }
     }
 
     /** The default token start string */
     public static final String DEFAULT_TOKEN_START = "@";
 
     /** The default token end string */
     public static final String DEFAULT_TOKEN_END = "@";
 
     private String startOfToken = DEFAULT_TOKEN_START;
     private String endOfToken = DEFAULT_TOKEN_END;
 
     /** Contains a list of parsed tokens */
     private Vector passedTokens;
     /** if a duplicate token is found, this is set to true */
     private boolean duplicateToken = false;
 
     private boolean recurse = true;
     private Hashtable filterHash = null;
     private Vector filtersFiles = new Vector();
     private OnMissing onMissingFiltersFile = OnMissing.FAIL;
     private boolean readingFiles = false;
 
     private int recurseDepth = 0;
 
     /**
      * List of ordered filters and filter files.
      */
     private Vector filters = new Vector();
 
     /**
      * Default constructor.
      */
     public FilterSet() {
     }
 
     /**
      * Create a Filterset from another filterset.
      *
      * @param filterset the filterset upon which this filterset will be based.
      */
     protected FilterSet(FilterSet filterset) {
         super();
         this.filters = (Vector) filterset.getFilters().clone();
     }
 
     /**
      * Get the filters in the filter set.
      *
      * @return a Vector of Filter instances.
      */
     protected synchronized Vector getFilters() {
         if (isReference()) {
             return getRef().getFilters();
         }
         dieOnCircularReference();
         //silly hack to avoid stack overflow...
         if (!readingFiles) {
             readingFiles = true;
-            for (int i = 0, sz = filtersFiles.size(); i < sz; i++) {
+            final int size = filtersFiles.size();
+            for (int i = 0, sz = size; i < sz; i++) {
                 readFiltersFromFile((File) filtersFiles.get(i));
             }
             filtersFiles.clear();
             readingFiles = false;
         }
         return filters;
     }
 
     /**
      * Get the referenced filter set.
      *
      * @return the filterset from the reference.
      */
     protected FilterSet getRef() {
         return (FilterSet) getCheckedRef(FilterSet.class, "filterset");
     }
 
     /**
      * Gets the filter hash of the FilterSet.
      *
      * @return   The hash of the tokens and values for quick lookup.
      */
     public synchronized Hashtable getFilterHash() {
         if (isReference()) {
             return getRef().getFilterHash();
         }
         dieOnCircularReference();
         if (filterHash == null) {
             filterHash = new Hashtable(getFilters().size());
             for (Enumeration e = getFilters().elements(); e.hasMoreElements();) {
                Filter filter = (Filter) e.nextElement();
                filterHash.put(filter.getToken(), filter.getValue());
             }
         }
         return filterHash;
     }
 
     /**
      * Set the file containing the filters for this filterset.
      *
      * @param filtersFile sets the filter file from which to read filters
      *        for this filter set.
      * @throws BuildException if there is an error.
      */
     public void setFiltersfile(File filtersFile) throws BuildException {
         if (isReference()) {
             throw tooManyAttributes();
         }
         filtersFiles.add(filtersFile);
     }
 
     /**
      * Set the string used to id the beginning of a token.
      *
      * @param startOfToken  The new Begintoken value.
      */
     public void setBeginToken(String startOfToken) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         if (startOfToken == null || "".equals(startOfToken)) {
             throw new BuildException("beginToken must not be empty");
         }
         this.startOfToken = startOfToken;
     }
 
     /**
      * Get the begin token for this filterset.
      *
      * @return the filter set's begin token for filtering.
      */
     public String getBeginToken() {
         if (isReference()) {
             return getRef().getBeginToken();
         }
         return startOfToken;
     }
 
     /**
      * Set the string used to id the end of a token.
      *
      * @param endOfToken  The new Endtoken value.
      */
     public void setEndToken(String endOfToken) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         if (endOfToken == null || "".equals(endOfToken)) {
             throw new BuildException("endToken must not be empty");
         }
         this.endOfToken = endOfToken;
     }
 
     /**
      * Get the end token for this filterset.
      *
      * @return the filter set's end token for replacement delimiting.
      */
     public String getEndToken() {
         if (isReference()) {
             return getRef().getEndToken();
         }
         return endOfToken;
     }
 
     /**
      * Set whether recursive token expansion is enabled.
      * @param recurse <code>boolean</code> whether to recurse.
      */
     public void setRecurse(boolean recurse) {
         this.recurse = recurse;
     }
 
     /**
      * Get whether recursive token expansion is enabled.
      * @return <code>boolean</code> whether enabled.
      */
     public boolean isRecurse() {
         return recurse;
     }
 
     /**
      * Read the filters from the given file.
      *
      * @param filtersFile        the file from which filters are read.
      * @exception BuildException when the file cannot be read.
      */
     public synchronized void readFiltersFromFile(File filtersFile) throws BuildException {
         if (isReference()) {
             throw tooManyAttributes();
         }
         if (!filtersFile.exists()) {
            handleMissingFile("Could not read filters from file "
                                      + filtersFile + " as it doesn't exist.");
         }
         if (filtersFile.isFile()) {
            log("Reading filters from " + filtersFile, Project.MSG_VERBOSE);
            FileInputStream in = null;
            try {
               Properties props = new Properties();
               in = new FileInputStream(filtersFile);
               props.load(in);
 
               Enumeration e = props.propertyNames();
               Vector filts = getFilters();
               while (e.hasMoreElements()) {
                  String strPropName = (String) e.nextElement();
                  String strValue = props.getProperty(strPropName);
                  filts.addElement(new Filter(strPropName, strValue));
               }
            } catch (Exception ex) {
               throw new BuildException("Could not read filters from file: "
                   + filtersFile, ex);
            } finally {
               FileUtils.close(in);
            }
         } else {
            handleMissingFile(
                "Must specify a file rather than a directory in "
                + "the filtersfile attribute:" + filtersFile);
         }
         filterHash = null;
     }
 
     /**
      * Does replacement on the given string with token matching.
      * This uses the defined begintoken and endtoken values which default
      * to @ for both.
      * This resets the passedTokens and calls iReplaceTokens to
      * do the actual replacements.
      *
      * @param line  The line in which to process embedded tokens.
      * @return      The input string after token replacement.
      */
     public synchronized String replaceTokens(String line) {
         return iReplaceTokens(line);
     }
 
     /**
      * Add a new filter.
      *
      * @param filter the filter to be added.
      */
     public synchronized void addFilter(Filter filter) {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         filters.addElement(filter);
         filterHash = null;
     }
 
     /**
      * Create a new FiltersFile.
      *
      * @return The filtersfile that was created.
      */
     public FiltersFile createFiltersfile() {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         return new FiltersFile();
     }
 
     /**
      * Add a new filter made from the given token and value.
      *
      * @param token The token for the new filter.
      * @param value The value for the new filter.
      */
     public synchronized void addFilter(String token, String value) {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         addFilter(new Filter(token, value));
     }
 
     /**
      * Add a Filterset to this filter set.
      *
      * @param filterSet the filterset to be added to this filterset
      */
     public synchronized void addConfiguredFilterSet(FilterSet filterSet) {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         for (Enumeration e = filterSet.getFilters().elements(); e.hasMoreElements();) {
             addFilter((Filter) e.nextElement());
         }
     }
 
     /**
     * Test to see if this filter set has filters.
     *
     * @return Return true if there are filters in this set.
     */
     public synchronized boolean hasFilters() {
         return getFilters().size() > 0;
     }
 
     /**
      * Clone the filterset.
      *
      * @return a deep clone of this filterset.
      *
      * @throws BuildException if the clone cannot be performed.
      */
     public synchronized Object clone() throws BuildException {
         if (isReference()) {
             return ((FilterSet) getRef()).clone();
         }
         try {
             FilterSet fs = (FilterSet) super.clone();
             fs.filters = (Vector) getFilters().clone();
             fs.setProject(getProject());
             return fs;
         } catch (CloneNotSupportedException e) {
             throw new BuildException(e);
         }
     }
 
     /**
      * Set the behavior WRT missing filtersfiles.
      * @param onMissingFiltersFile the OnMissing describing the behavior.
      */
     public void setOnMissingFiltersFile(OnMissing onMissingFiltersFile) {
         this.onMissingFiltersFile = onMissingFiltersFile;
     }
 
     /**
      * Get the onMissingFiltersFile setting.
      * @return the OnMissing instance.
      */
     public OnMissing getOnMissingFiltersFile() {
         return onMissingFiltersFile;
     }
 
     /**
      * Does replacement on the given string with token matching.
      * This uses the defined begintoken and endtoken values which default
      * to @ for both.
      *
      * @param line  The line to process the tokens in.
      * @return      The string with the tokens replaced.
      */
     private synchronized String iReplaceTokens(String line) {
         String beginToken = getBeginToken();
         String endToken = getEndToken();
         int index = line.indexOf(beginToken);
 
         if (index > -1) {
             Hashtable tokens = getFilterHash();
             try {
                 StringBuffer b = new StringBuffer();
                 int i = 0;
                 String token = null;
                 String value = null;
 
                 while (index > -1) {
                     //can't have zero-length token
                     int endIndex = line.indexOf(endToken,
                         index + beginToken.length() + 1);
                     if (endIndex == -1) {
                         break;
                     }
                     token
                         = line.substring(index + beginToken.length(), endIndex);
                     b.append(line.substring(i, index));
                     if (tokens.containsKey(token)) {
                         value = (String) tokens.get(token);
                         if (recurse && !value.equals(token)) {
                             // we have another token, let's parse it.
                             value = replaceTokens(value, token);
                         }
                         log("Replacing: " + beginToken + token + endToken
                             + " -> " + value, Project.MSG_VERBOSE);
                         b.append(value);
                         i = index + beginToken.length() + token.length()
                             + endToken.length();
                     } else {
                         // just append first character of beginToken
                         // and search further
                         // we can't skip the complete beginToken since
                         // it may contain the start of another
                         // candidate begin token (Bugzilla 45094)
                         b.append(beginToken.charAt(0));
                         i = index + 1;
                     }
                     index = line.indexOf(beginToken, i);
                 }
 
                 b.append(line.substring(i));
                 return b.toString();
             } catch (StringIndexOutOfBoundsException e) {
                 return line;
             }
         } else {
            return line;
         }
     }
 
     /**
      * This parses tokens which point to tokens.
      * It also maintains a list of currently used tokens, so we cannot
      * get into an infinite loop.
      * @param line the value / token to parse.
      * @param parent the parent token (= the token it was parsed from).
      */
     private synchronized String replaceTokens(String line, String parent)
         throws BuildException {
         String beginToken = getBeginToken();
         String endToken = getEndToken();
         if (recurseDepth == 0) {
             passedTokens = new VectorSet();
         }
         recurseDepth++;
         if (passedTokens.contains(parent) && !duplicateToken) {
             duplicateToken = true;
             System.out.println(
                 "Infinite loop in tokens. Currently known tokens : "
                 + passedTokens.toString() + "\nProblem token : " + beginToken
                 + parent + endToken + " called from " + beginToken
                 + passedTokens.lastElement().toString() + endToken);
             recurseDepth--;
             return parent;
         }
         passedTokens.addElement(parent);
         String value = iReplaceTokens(line);
         if (value.indexOf(beginToken) == -1 && !duplicateToken
                 && recurseDepth == 1) {
             passedTokens = null;
         } else if (duplicateToken) {
             // should always be the case...
             if (passedTokens.size() > 0) {
                 value = (String) passedTokens.remove(passedTokens.size() - 1);
                 if (passedTokens.size() == 0) {
                     value = beginToken + value + endToken;
                     duplicateToken = false;
                 }
             }
         } else if (passedTokens.size() > 0) {
             // remove last seen token when crawling out of recursion 
             passedTokens.remove(passedTokens.size() - 1);
         }
         recurseDepth--;
         return value;
     }
 
     private void handleMissingFile(String message) {
         switch (onMissingFiltersFile.getIndex()) {
         case OnMissing.IGNORE_INDEX:
             return;
         case OnMissing.FAIL_INDEX:
             throw new BuildException(message);
         case OnMissing.WARN_INDEX:
             log(message, Project.MSG_WARN);
             return;
         default:
             throw new BuildException("Invalid value for onMissingFiltersFile");
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/types/optional/image/Arc.java b/src/main/org/apache/tools/ant/types/optional/image/Arc.java
index 4ed375189..fcbb325aa 100644
--- a/src/main/org/apache/tools/ant/types/optional/image/Arc.java
+++ b/src/main/org/apache/tools/ant/types/optional/image/Arc.java
@@ -1,121 +1,122 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types.optional.image;
 
 import javax.media.jai.PlanarImage;
 import java.awt.BasicStroke;
 import java.awt.Graphics2D;
 import java.awt.geom.Arc2D;
 import java.awt.image.BufferedImage;
 
 /**
  * Draw an arc.
  */
 public class Arc extends BasicShape implements DrawOperation {
     // CheckStyle:VisibilityModifier OFF - bc
     protected int width = 0;
     protected int height = 0;
     protected int start = 0;
     protected int stop = 0;
     protected int type = Arc2D.OPEN;
     // CheckStyle:VisibilityModifier ON
 
     /**
      * Set the width.
      * @param width the width of the arc.
      */
     public void setWidth(int width) {
         this.width = width;
     }
 
     /**
      * Set the height.
      * @param height the height of the arc.
      */
     public void setHeight(int height) {
         this.height = height;
     }
 
     /**
      * Set the start of the arc.
      * @param start the start of the arc.
      */
     public void setStart(int start) {
         this.start = start;
     }
 
     /**
      * Set the stop of the arc.
      * @param stop the stop of the arc.
      */
     public void setStop(int stop) {
         this.stop = stop;
     }
 
     /**
      * Set the type of arc.
      * @param strType the type to use - open, pie or chord.
      * @todo refactor using an EnumeratedAttribute
      */
     public void setType(String strType) {
         if (strType.equalsIgnoreCase("open")) {
             type = Arc2D.OPEN;
         } else if (strType.equalsIgnoreCase("pie")) {
             type = Arc2D.PIE;
         } else if (strType.equalsIgnoreCase("chord")) {
             type = Arc2D.CHORD;
         }
     }
 
     /** {@inheritDoc}. */
     public PlanarImage executeDrawOperation() {
         BufferedImage bi = new BufferedImage(width + (stroke_width * 2),
             height + (stroke_width * 2), BufferedImage.TYPE_4BYTE_ABGR_PRE);
 
         Graphics2D graphics = (Graphics2D) bi.getGraphics();
 
         if (!stroke.equals("transparent")) {
             BasicStroke bStroke = new BasicStroke(stroke_width);
             graphics.setColor(ColorMapper.getColorByName(stroke));
             graphics.setStroke(bStroke);
             graphics.draw(new Arc2D.Double(stroke_width, stroke_width, width,
                 height, start, stop, type));
         }
 
         if (!fill.equals("transparent")) {
             graphics.setColor(ColorMapper.getColorByName(fill));
             graphics.fill(new Arc2D.Double(stroke_width, stroke_width,
                 width, height, start, stop, type));
         }
 
 
-        for (int i = 0; i < instructions.size(); i++) {
+        final int size = instructions.size();
+        for (int i = 0; i < size; i++) {
             ImageOperation instr = ((ImageOperation) instructions.elementAt(i));
             if (instr instanceof DrawOperation) {
                 PlanarImage img = ((DrawOperation) instr).executeDrawOperation();
                 graphics.drawImage(img.getAsBufferedImage(), null, 0, 0);
             } else if (instr instanceof TransformOperation) {
                 graphics = (Graphics2D) bi.getGraphics();
                 PlanarImage image = ((TransformOperation) instr)
                     .executeTransformOperation(PlanarImage.wrapRenderedImage(bi));
                 bi = image.getAsBufferedImage();
             }
         }
         return PlanarImage.wrapRenderedImage(bi);
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/optional/image/Draw.java b/src/main/org/apache/tools/ant/types/optional/image/Draw.java
index b46ae41dd..ab7533bc4 100644
--- a/src/main/org/apache/tools/ant/types/optional/image/Draw.java
+++ b/src/main/org/apache/tools/ant/types/optional/image/Draw.java
@@ -1,100 +1,101 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types.optional.image;
 
 import javax.media.jai.PlanarImage;
 import java.awt.Graphics2D;
 import java.awt.image.BufferedImage;
 
 /**
  *
  * @see org.apache.tools.ant.taskdefs.optional.image.Image
  */
 public class Draw extends TransformOperation {
     // CheckStyle:VisibilityModifier OFF - bc
     protected int xloc = 0;
     protected int yloc = 0;
     // CheckStyle:VisibilityModifier ON
 
     /**
      * Set the X location.
      * @param x the value to use.
      */
     public void setXloc(int x) {
         xloc = x;
     }
 
     /**
      * Set the Y location.
      * @param y the value to use.
      */
     public void setYloc(int y) {
         yloc = y;
     }
 
     /** {@inheritDoc}. */
     public void addRectangle(Rectangle rect) {
         instructions.add(rect);
     }
 
     /** {@inheritDoc}. */
     public void addText(Text text) {
         instructions.add(text);
     }
 
     /**
      * Add an ellipse.
      * @param elip the ellipse to add.
      */
     public void addEllipse(Ellipse elip) {
         instructions.add(elip);
     }
 
     /**
      * Add an arc.
      * @param arc the arc to add.
      */
     public void addArc(Arc arc) {
         instructions.add(arc);
     }
 
     /** {@inheritDoc}. */
     public PlanarImage executeTransformOperation(PlanarImage image) {
         BufferedImage bi = image.getAsBufferedImage();
         Graphics2D graphics = (Graphics2D) bi.getGraphics();
 
-        for (int i = 0; i < instructions.size(); i++) {
+        final int size = instructions.size();
+        for (int i = 0; i < size; i++) {
             ImageOperation instr = ((ImageOperation) instructions.elementAt(i));
             if (instr instanceof DrawOperation) {
                 PlanarImage op = ((DrawOperation) instr).executeDrawOperation();
                 log("\tDrawing to x=" + xloc + " y=" + yloc);
                 graphics.drawImage(op.getAsBufferedImage(), null, xloc, yloc);
             } else if (instr instanceof TransformOperation) {
                 PlanarImage op
                     = ((TransformOperation) instr).executeTransformOperation(null);
                 BufferedImage child = op.getAsBufferedImage();
                 log("\tDrawing to x=" + xloc + " y=" + yloc);
                 graphics.drawImage(child, null, xloc, yloc);
                 PlanarImage.wrapRenderedImage(bi);
             }
         }
         image = PlanarImage.wrapRenderedImage(bi);
 
         return image;
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/optional/image/Ellipse.java b/src/main/org/apache/tools/ant/types/optional/image/Ellipse.java
index f4701e1f3..9fc5e29f9 100644
--- a/src/main/org/apache/tools/ant/types/optional/image/Ellipse.java
+++ b/src/main/org/apache/tools/ant/types/optional/image/Ellipse.java
@@ -1,85 +1,86 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types.optional.image;
 
 import javax.media.jai.PlanarImage;
 import java.awt.BasicStroke;
 import java.awt.Graphics2D;
 import java.awt.geom.Ellipse2D;
 import java.awt.image.BufferedImage;
 
 /**
  * Draw an ellipse.
  * @see org.apache.tools.ant.taskdefs.optional.image.Image
  */
 public class Ellipse extends BasicShape implements DrawOperation {
     // CheckStyle:VisibilityModifier OFF - bc
     protected int width = 0;
     protected int height = 0;
     // CheckStyle:VisibilityModifier ON
 
     /**
      * Set the width.
      * @param width the width of the elipse.
      */
     public void setWidth(int width) {
         this.width = width;
     }
 
     /**
      * Set the height.
      * @param height the height of the elipse.
      */
     public void setHeight(int height) {
         this.height = height;
     }
 
     /** {@inheritDoc}. */
     public PlanarImage executeDrawOperation() {
         BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR_PRE);
 
         Graphics2D graphics = (Graphics2D) bi.getGraphics();
 
         if (!stroke.equals("transparent")) {
             BasicStroke bStroke = new BasicStroke(stroke_width);
             graphics.setColor(ColorMapper.getColorByName(stroke));
             graphics.setStroke(bStroke);
             graphics.draw(new Ellipse2D.Double(0, 0, width, height));
         }
 
         if (!fill.equals("transparent")) {
             graphics.setColor(ColorMapper.getColorByName(fill));
             graphics.fill(new Ellipse2D.Double(0, 0, width, height));
         }
 
 
-        for (int i = 0; i < instructions.size(); i++) {
+        final int size = instructions.size();
+        for (int i = 0; i < size; i++) {
             ImageOperation instr = ((ImageOperation) instructions.elementAt(i));
             if (instr instanceof DrawOperation) {
                 PlanarImage img = ((DrawOperation) instr).executeDrawOperation();
                 graphics.drawImage(img.getAsBufferedImage(), null, 0, 0);
             } else if (instr instanceof TransformOperation) {
                 graphics = (Graphics2D) bi.getGraphics();
                 PlanarImage image = ((TransformOperation) instr)
                     .executeTransformOperation(PlanarImage.wrapRenderedImage(bi));
                 bi = image.getAsBufferedImage();
             }
         }
         return PlanarImage.wrapRenderedImage(bi);
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/optional/image/Rectangle.java b/src/main/org/apache/tools/ant/types/optional/image/Rectangle.java
index f3204e760..aa03be6b3 100644
--- a/src/main/org/apache/tools/ant/types/optional/image/Rectangle.java
+++ b/src/main/org/apache/tools/ant/types/optional/image/Rectangle.java
@@ -1,117 +1,118 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types.optional.image;
 
 import javax.media.jai.PlanarImage;
 import java.awt.BasicStroke;
 import java.awt.Graphics2D;
 import java.awt.image.BufferedImage;
 
 /**
  *
  * @see org.apache.tools.ant.taskdefs.optional.image.Image
  */
 public class Rectangle extends BasicShape implements DrawOperation {
     // CheckStyle:VisibilityModifier OFF - bc
     protected int width = 0;
     protected int height = 0;
     protected int arcwidth = 0;
     protected int archeight = 0;
     // CheckStyle:VisibilityModifier ON
 
     /**
      * Set the width.
      * @param w the value to use.
      */
     public void setWidth(int w) {
         width = w;
     }
 
     /**
      * Set the height.
      * @param h the value to use.
      */
     public void setHeight(int h) {
         height = h;
     }
 
     /**
      * Set the arc width.
      * @param w the value to use.
      */
     public void setArcwidth(int w) {
         arcwidth = w;
     }
 
     /**
      * Set the arc height.
      * @param h the value to use.
      */
     public void setArcheight(int h) {
         archeight = h;
     }
 
     /** {@inheritDoc}. */
     public PlanarImage executeDrawOperation() {
         log("\tCreating Rectangle w=" + width + " h=" + height + " arcw="
             + arcwidth + " arch=" + archeight);
         BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR_PRE);
 
         Graphics2D graphics = (Graphics2D) bi.getGraphics();
 
         if (!stroke.equals("transparent")) {
             BasicStroke bStroke = new BasicStroke(stroke_width);
             graphics.setColor(ColorMapper.getColorByName(stroke));
             graphics.setStroke(bStroke);
 
             if ((arcwidth != 0) || (archeight != 0)) {
                 graphics.drawRoundRect(0, 0, width, height, arcwidth, archeight);
             } else {
                 graphics.drawRect(0, 0, width, height);
             }
         }
 
         if (!fill.equals("transparent")) {
             graphics.setColor(ColorMapper.getColorByName(fill));
             if ((arcwidth != 0) || (archeight != 0)) {
                 graphics.fillRoundRect(stroke_width, stroke_width,
                     width - (stroke_width * 2), height - (stroke_width * 2),
                     arcwidth, archeight);
             } else {
                 graphics.fillRect(stroke_width, stroke_width,
                     width - (stroke_width * 2), height - (stroke_width * 2));
             }
         }
 
 
-        for (int i = 0; i < instructions.size(); i++) {
+        final int size = instructions.size();
+        for (int i = 0; i < size; i++) {
             ImageOperation instr = ((ImageOperation) instructions.elementAt(i));
             if (instr instanceof DrawOperation) {
                 PlanarImage img = ((DrawOperation) instr).executeDrawOperation();
                 graphics.drawImage(img.getAsBufferedImage(), null, 0, 0);
             } else if (instr instanceof TransformOperation) {
                 graphics = (Graphics2D) bi.getGraphics();
                 PlanarImage image
                     = ((TransformOperation) instr)
                     .executeTransformOperation(PlanarImage.wrapRenderedImage(bi));
                 bi = image.getAsBufferedImage();
             }
         }
         return PlanarImage.wrapRenderedImage(bi);
     }
 }
diff --git a/src/main/org/apache/tools/ant/types/optional/image/Rotate.java b/src/main/org/apache/tools/ant/types/optional/image/Rotate.java
index e20ded1af..f925ec759 100644
--- a/src/main/org/apache/tools/ant/types/optional/image/Rotate.java
+++ b/src/main/org/apache/tools/ant/types/optional/image/Rotate.java
@@ -1,118 +1,120 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types.optional.image;
 
 import javax.media.jai.PlanarImage;
 import javax.media.jai.InterpolationNearest;
 import javax.media.jai.JAI;
 import java.awt.image.renderable.ParameterBlock;
 import java.awt.image.BufferedImage;
 import java.awt.Graphics2D;
 
 /**
  * ImageOperation to rotate an image by a certain degree
  *
  * @see org.apache.tools.ant.taskdefs.optional.image.Image
  */
 public class Rotate extends TransformOperation implements DrawOperation {
     private static final float HALF_CIRCLE = 180.0F;
 
     // CheckStyle:VisibilityModifier OFF - bc
     protected float angle = 0.0F;
     // CheckStyle:VisibilityModifier ON
 
     /**
      * Sets the angle of rotation in degrees.
      * @param ang The angle at which to rotate the image
      */
     public void setAngle(String ang) {
         angle = Float.parseFloat(ang);
     }
 
 
     /**
      * Rotate an image.
      * @param image the image to rotate.
      * @return the rotated image.
      */
     public PlanarImage performRotate(PlanarImage image) {
         float tAngle = (float) (angle * (Math.PI / HALF_CIRCLE));
         ParameterBlock pb = new ParameterBlock();
         pb.addSource(image);
         pb.add(0.0F);
         pb.add(0.0F);
         pb.add(tAngle);
         pb.add(new InterpolationNearest());
         return JAI.create("Rotate", pb, null);
     }
 
 
     /**
      * Performs the image rotation when being handled as a TransformOperation.
      * @param image The image to perform the transformation on.
      * @return the transformed image.
      */
     public PlanarImage executeTransformOperation(PlanarImage image) {
         BufferedImage bi = null;
         Graphics2D graphics = null;
-        for (int i = 0; i < instructions.size(); i++) {
+        final int size = instructions.size();
+        for (int i = 0; i < size; i++) {
             ImageOperation instr = ((ImageOperation) instructions.elementAt(i));
             if (instr instanceof DrawOperation) {
                 // If this TransformOperation has DrawOperation children
                 // then Rotate the first child and return.
                 System.out.println("Execing Draws");
                 PlanarImage op = ((DrawOperation) instr).executeDrawOperation();
                 image = performRotate(op);
                 return image;
             } else if (instr instanceof TransformOperation) {
                 bi = image.getAsBufferedImage();
                 graphics = (Graphics2D) bi.getGraphics();
                 System.out.println("Execing Transforms");
                 image = ((TransformOperation) instr)
                     .executeTransformOperation(PlanarImage.wrapRenderedImage(bi));
                 bi = image.getAsBufferedImage();
             }
         }
         System.out.println("Execing as TransformOperation");
         image = performRotate(image);
         System.out.println(image);
         return image;
     }
 
     /**
      *  Performs the image rotation when being handled as a DrawOperation.
      *  It absolutely requires that there be a DrawOperation nested beneath it,
      *  but only the FIRST DrawOperation will be handled since it can only return
      *  ONE image.
      * @return the image.
      */
     public PlanarImage executeDrawOperation() {
-        for (int i = 0; i < instructions.size(); i++) {
+        final int size = instructions.size();
+        for (int i = 0; i < size; i++) {
             ImageOperation instr = ((ImageOperation) instructions.elementAt(i));
             if (instr instanceof DrawOperation) {
                 // If this TransformOperation has DrawOperation children
                 // then Rotate the first child and return.
                 PlanarImage op = ((DrawOperation) instr).executeDrawOperation();
                 op = performRotate(op);
                 return op;
             }
         }
         return null;
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/types/optional/image/Scale.java b/src/main/org/apache/tools/ant/types/optional/image/Scale.java
index 0b279e2cd..ea588970d 100644
--- a/src/main/org/apache/tools/ant/types/optional/image/Scale.java
+++ b/src/main/org/apache/tools/ant/types/optional/image/Scale.java
@@ -1,178 +1,180 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.types.optional.image;
 
 import org.apache.tools.ant.types.EnumeratedAttribute;
 
 import javax.media.jai.JAI;
 import javax.media.jai.PlanarImage;
 import java.awt.image.BufferedImage;
 import java.awt.image.renderable.ParameterBlock;
 
 /**
  *
  * @see org.apache.tools.ant.taskdefs.optional.image.Image
  */
 public class Scale extends TransformOperation implements DrawOperation {
     private static final int HUNDRED = 100;
 
     private String widthStr = "100%";
     private String heightStr = "100%";
     private boolean xPercent = true;
     private boolean yPercent = true;
     private String proportions = "ignore";
 
     /** Enumerated class for proportions attribute. */
     public static class ProportionsAttribute extends EnumeratedAttribute {
         /** {@inheritDoc}. */
         public String[] getValues() {
             return new String[] {"ignore", "width", "height", "cover", "fit"};
         }
     }
 
     /**
      *  Sets the behaviour regarding the image proportions.
      * @param pa the enumerated value.
      */
     public void setProportions(ProportionsAttribute pa) {
         proportions = pa.getValue();
     }
 
     /**
      * Sets the width of the image, either as an integer or a %.
      * Defaults to 100%.
      * @param width the value to use.
      */
     public void setWidth(String width) {
         widthStr = width;
     }
 
     /**
      *  Sets the height of the image, either as an integer or a %.  Defaults to 100%.
      * @param height the value to use.
      */
     public void setHeight(String height) {
         heightStr = height;
     }
 
     /**
      * Get the width.
      * @return the value converted from the width string.
      */
     public float getWidth() {
         float width = 0.0F;
         int percIndex = widthStr.indexOf('%');
         if (percIndex > 0) {
             width = Float.parseFloat(widthStr.substring(0, percIndex));
             xPercent = true;
             return width / HUNDRED;
         } else {
             xPercent = false;
             return Float.parseFloat(widthStr);
         }
     }
 
     /**
      * Get the height.
      * @return the value converted from the height string.
      */
     public float getHeight() {
         int percIndex = heightStr.indexOf('%');
         if (percIndex > 0) {
             float height = Float.parseFloat(heightStr.substring(0, percIndex));
             yPercent = true;
             return height / HUNDRED;
         } else {
             yPercent = false;
             return Float.parseFloat(heightStr);
         }
     }
 
     /**
      * Scale an image.
      * @param image the image to scale.
      * @return the scaled image.
      */
     public PlanarImage performScale(PlanarImage image) {
         ParameterBlock pb = new ParameterBlock();
         pb.addSource(image);
         float xFl = getWidth();
         float yFl = getHeight();
 
         if (!xPercent) {
             xFl = (xFl / image.getWidth());
         }
         if (!yPercent) {
             yFl = (yFl / image.getHeight());
         }
 
         if ("width".equals(proportions)) {
             yFl = xFl;
         } else if ("height".equals(proportions)) {
             xFl = yFl;
         } else if ("fit".equals(proportions)) {
             yFl = Math.min(xFl, yFl);
             xFl = yFl;
         } else if ("cover".equals(proportions)) {
             yFl = Math.max(xFl, yFl);
             xFl = yFl;
         }
 
         pb.add(new Float(xFl));
         pb.add(new Float(yFl));
 
         log("\tScaling to " + (xFl * HUNDRED) + "% x "
             + (yFl * HUNDRED) + "%");
 
         return JAI.create("scale", pb);
     }
 
 
     /** {@inheritDoc}. */
     public PlanarImage executeTransformOperation(PlanarImage image) {
         BufferedImage bi = null;
-        for (int i = 0; i < instructions.size(); i++) {
+        final int size = instructions.size();
+        for (int i = 0; i < size; i++) {
             ImageOperation instr = ((ImageOperation) instructions.elementAt(i));
             if (instr instanceof DrawOperation) {
                 return performScale(image);
             } else if (instr instanceof TransformOperation) {
                 bi = image.getAsBufferedImage();
                 image = ((TransformOperation) instr)
                     .executeTransformOperation(PlanarImage.wrapRenderedImage(bi));
                 bi = image.getAsBufferedImage();
             }
         }
         return performScale(image);
     }
 
 
     /** {@inheritDoc}. */
     public PlanarImage executeDrawOperation() {
-        for (int i = 0; i < instructions.size(); i++) {
+        final int size = instructions.size();
+        for (int i = 0; i < size; i++) {
             ImageOperation instr = ((ImageOperation) instructions.elementAt(i));
             if (instr instanceof DrawOperation) {
                 PlanarImage image = null;
                 // If this TransformOperation has DrawOperation children
                 // then Rotate the first child and return.
                 performScale(image);
                 return image;
             }
         }
         return null;
     }
 }
diff --git a/src/main/org/apache/tools/ant/util/FileUtils.java b/src/main/org/apache/tools/ant/util/FileUtils.java
index 9472a5bf9..a65875d46 100644
--- a/src/main/org/apache/tools/ant/util/FileUtils.java
+++ b/src/main/org/apache/tools/ant/util/FileUtils.java
@@ -1,1710 +1,1711 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 import java.io.File;
 import java.io.FilenameFilter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.Reader;
 import java.io.Writer;
 import java.net.MalformedURLException;
 import java.net.HttpURLConnection;
 import java.net.JarURLConnection;
 import java.net.URL;
 import java.net.URLConnection;
 import java.nio.channels.Channel;
 import java.text.DecimalFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
 import java.util.Stack;
 import java.util.StringTokenizer;
 import java.util.Vector;
 import java.util.jar.JarFile;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.PathTokenizer;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.launch.Locator;
 import org.apache.tools.ant.taskdefs.condition.Os;
 import org.apache.tools.ant.types.FilterSetCollection;
 import org.apache.tools.ant.types.resources.FileResource;
 
 /**
  * This class also encapsulates methods which allow Files to be
  * referred to using abstract path names which are translated to native
  * system file paths at runtime as well as copying files or setting
  * their last modification time.
  *
  */
 public class FileUtils {
     private static final int DELETE_RETRY_SLEEP_MILLIS = 10;
     private static final int EXPAND_SPACE = 50;
     private static final FileUtils PRIMARY_INSTANCE = new FileUtils();
 
     //get some non-crypto-grade randomness from various places.
     private static Random rand = new Random(System.currentTimeMillis()
             + Runtime.getRuntime().freeMemory());
 
     private static final boolean ON_NETWARE = Os.isFamily("netware");
     private static final boolean ON_DOS = Os.isFamily("dos");
     private static final boolean ON_WIN9X = Os.isFamily("win9x");
     private static final boolean ON_WINDOWS = Os.isFamily("windows");
 
     static final int BUF_SIZE = 8192;
 
 
     /**
      * The granularity of timestamps under FAT.
      */
     public static final long FAT_FILE_TIMESTAMP_GRANULARITY = 2000;
 
     /**
      * The granularity of timestamps under Unix.
      */
     public static final long UNIX_FILE_TIMESTAMP_GRANULARITY = 1000;
 
     /**
      * The granularity of timestamps under the NT File System.
      * NTFS has a granularity of 100 nanoseconds, which is less
      * than 1 millisecond, so we round this up to 1 millisecond.
      */
     public static final long NTFS_FILE_TIMESTAMP_GRANULARITY = 1;
 
     /**
      * A one item cache for fromUri.
      * fromUri is called for each element when parseing ant build
      * files. It is a costly operation. This just caches the result
      * of the last call.
      */
     private Object cacheFromUriLock = new Object();
     private String cacheFromUriRequest = null;
     private String cacheFromUriResponse = null;
 
     /**
      * Factory method.
      *
      * @return a new instance of FileUtils.
      * @deprecated since 1.7.
      *             Use getFileUtils instead,
      * FileUtils do not have state.
      */
     public static FileUtils newFileUtils() {
         return new FileUtils();
     }
 
     /**
      * Method to retrieve The FileUtils, which is shared by all users of this
      * method.
      * @return an instance of FileUtils.
      * @since Ant 1.6.3
      */
     public static FileUtils getFileUtils() {
         return PRIMARY_INSTANCE;
     }
 
     /**
      * Empty constructor.
      */
     protected FileUtils() {
     }
 
     /**
      * Get the URL for a file taking into account # characters.
      *
      * @param file the file whose URL representation is required.
      * @return The FileURL value.
      * @throws MalformedURLException if the URL representation cannot be
      *      formed.
      */
     public URL getFileURL(File file) throws MalformedURLException {
         return new URL(toURI(file.getAbsolutePath()));
     }
 
     /**
      * Convenience method to copy a file from a source to a destination.
      * No filtering is performed.
      *
      * @param sourceFile Name of file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile Name of file to copy to.
      *                 Must not be <code>null</code>.
      *
      * @throws IOException if the copying fails.
      */
     public void copyFile(String sourceFile, String destFile) throws IOException {
         copyFile(new File(sourceFile), new File(destFile), null, false, false);
     }
 
     /**
      * Convenience method to copy a file from a source to a destination
      * specifying if token filtering must be used.
      *
      * @param sourceFile Name of file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile Name of file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      *
      * @throws IOException if the copying fails.
      */
     public void copyFile(String sourceFile, String destFile, FilterSetCollection filters)
             throws IOException {
         copyFile(new File(sourceFile), new File(destFile), filters, false, false);
     }
 
     /**
      * Convenience method to copy a file from a source to a destination specifying if token
      * filtering must be used and if source files may overwrite newer destination files.
      *
      * @param sourceFile Name of file to copy from. Must not be <code>null</code>.
      * @param destFile Name of file to copy to. Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param overwrite Whether or not the destination file should be overwritten if it already
      *            exists.
      *
      * @throws IOException if the copying fails.
      */
     public void copyFile(String sourceFile, String destFile, FilterSetCollection filters,
                          boolean overwrite) throws IOException {
         copyFile(new File(sourceFile), new File(destFile), filters, overwrite, false);
     }
 
     /**
      * Convenience method to copy a file from a source to a destination
      * specifying if token
      * filtering must be used, if source files may overwrite newer destination
      * files and the last
      * modified time of <code>destFile</code> file should be made equal to
      * the last modified time
      * of <code>sourceFile</code>.
      *
      * @param sourceFile Name of file to copy from. Must not be <code>null</code>.
      * @param destFile Name of file to copy to. Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param overwrite Whether or not the destination file should be
      *            overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *            the resulting file
      *            should be set to that of the source file.
      *
      * @throws IOException if the copying fails.
      */
     public void copyFile(String sourceFile, String destFile,
                          FilterSetCollection filters,
                          boolean overwrite, boolean preserveLastModified)
         throws IOException {
         copyFile(new File(sourceFile), new File(destFile), filters, overwrite,
                  preserveLastModified);
     }
 
     /**
      * Convenience method to copy a file from a source to a destination specifying if token
      * filtering must be used, if source files may overwrite newer destination files and the last
      * modified time of <code>destFile</code> file should be made equal to the last modified time
      * of <code>sourceFile</code>.
      *
      * @param sourceFile Name of file to copy from. Must not be <code>null</code>.
      * @param destFile Name of file to copy to. Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param overwrite Whether or not the destination file should be overwritten if it already
      *            exists.
      * @param preserveLastModified Whether or not the last modified time of the resulting file
      *            should be set to that of the source file.
      * @param encoding the encoding used to read and write the files.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.5
      */
     public void copyFile(String sourceFile, String destFile,
                          FilterSetCollection filters, boolean overwrite,
                          boolean preserveLastModified, String encoding) throws IOException {
         copyFile(new File(sourceFile), new File(destFile), filters,
                  overwrite, preserveLastModified, encoding);
     }
 
     // CheckStyle:ParameterNumberCheck OFF - bc
     /**
      * Convenience method to copy a file from a source to a
      * destination specifying if token filtering must be used, if
      * filter chains must be used, if source files may overwrite
      * newer destination files and the last modified time of
      * <code>destFile</code> file should be made equal
      * to the last modified time of <code>sourceFile</code>.
      *
      * @param sourceFile Name of file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile Name of file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination file should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the resulting file should be set to that
      *                             of the source file.
      * @param encoding the encoding used to read and write the files.
      * @param project the project instance.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.5
      */
     public void copyFile(String sourceFile, String destFile,
                          FilterSetCollection filters, Vector filterChains,
                          boolean overwrite, boolean preserveLastModified,
                          String encoding, Project project) throws IOException {
         copyFile(new File(sourceFile), new File(destFile), filters, filterChains, overwrite,
                 preserveLastModified, encoding, project);
     }
 
     /**
      * Convenience method to copy a file from a source to a destination specifying if token
      * filtering must be used, if filter chains must be used, if source files may overwrite newer
      * destination files and the last modified time of <code>destFile</code> file should be made
      * equal to the last modified time of <code>sourceFile</code>.
      *
      * @param sourceFile Name of file to copy from. Must not be <code>null</code>.
      * @param destFile Name of file to copy to. Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination file should be overwritten if it already
      *            exists.
      * @param preserveLastModified Whether or not the last modified time of the resulting file
      *            should be set to that of the source file.
      * @param inputEncoding the encoding used to read the files.
      * @param outputEncoding the encoding used to write the files.
      * @param project the project instance.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.6
      */
     public void copyFile(String sourceFile, String destFile,
                          FilterSetCollection filters, Vector filterChains,
                          boolean overwrite, boolean preserveLastModified,
                          String inputEncoding, String outputEncoding,
                          Project project) throws IOException {
         copyFile(new File(sourceFile), new File(destFile), filters, filterChains, overwrite,
                 preserveLastModified, inputEncoding, outputEncoding, project);
     }
 
     /**
      * Convenience method to copy a file from a source to a destination. No filtering is performed.
      *
      * @param sourceFile the file to copy from. Must not be <code>null</code>.
      * @param destFile the file to copy to. Must not be <code>null</code>.
      *
      * @throws IOException if the copying fails.
      */
     public void copyFile(File sourceFile, File destFile) throws IOException {
         copyFile(sourceFile, destFile, null, false, false);
     }
 
     /**
      * Convenience method to copy a file from a source to a destination
      * specifying if token filtering must be used.
      *
      * @param sourceFile the file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile the file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      *
      * @throws IOException if the copying fails.
      */
     public void copyFile(File sourceFile, File destFile, FilterSetCollection filters)
             throws IOException {
         copyFile(sourceFile, destFile, filters, false, false);
     }
 
     /**
      * Convenience method to copy a file from a source to a
      * destination specifying if token filtering must be used and if
      * source files may overwrite newer destination files.
      *
      * @param sourceFile the file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile the file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param overwrite Whether or not the destination file should be
      *                  overwritten if it already exists.
      *
      * @throws IOException if the copying fails.
      */
     public void copyFile(File sourceFile, File destFile, FilterSetCollection filters,
                          boolean overwrite) throws IOException {
         copyFile(sourceFile, destFile, filters, overwrite, false);
     }
 
     /**
      * Convenience method to copy a file from a source to a
      * destination specifying if token filtering must be used, if
      * source files may overwrite newer destination files and the
      * last modified time of <code>destFile</code> file should be made equal
      * to the last modified time of <code>sourceFile</code>.
      *
      * @param sourceFile the file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile the file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param overwrite Whether or not the destination file should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the resulting file should be set to that
      *                             of the source file.
      *
      * @throws IOException if the copying fails.
      */
     public void copyFile(File sourceFile, File destFile, FilterSetCollection filters,
                          boolean overwrite, boolean preserveLastModified) throws IOException {
         copyFile(sourceFile, destFile, filters, overwrite, preserveLastModified, null);
     }
 
     /**
      * Convenience method to copy a file from a source to a destination specifying if token
      * filtering must be used, if source files may overwrite newer destination files, the last
      * modified time of <code>destFile</code> file should be made equal to the last modified time
      * of <code>sourceFile</code> and which character encoding to assume.
      *
      * @param sourceFile the file to copy from. Must not be <code>null</code>.
      * @param destFile the file to copy to. Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param overwrite Whether or not the destination file should be overwritten if it already
      *            exists.
      * @param preserveLastModified Whether or not the last modified time of the resulting file
      *            should be set to that of the source file.
      * @param encoding the encoding used to read and write the files.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.5
      */
     public void copyFile(File sourceFile, File destFile,
                          FilterSetCollection filters, boolean overwrite,
                          boolean preserveLastModified, String encoding) throws IOException {
         copyFile(sourceFile, destFile, filters, null, overwrite,
                  preserveLastModified, encoding, null);
     }
 
     /**
      * Convenience method to copy a file from a source to a
      * destination specifying if token filtering must be used, if
      * filter chains must be used, if source files may overwrite
      * newer destination files and the last modified time of
      * <code>destFile</code> file should be made equal
      * to the last modified time of <code>sourceFile</code>.
      *
      * @param sourceFile the file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile the file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination file should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the resulting file should be set to that
      *                             of the source file.
      * @param encoding the encoding used to read and write the files.
      * @param project the project instance.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.5
      */
     public void copyFile(File sourceFile, File destFile,
                          FilterSetCollection filters, Vector filterChains,
                          boolean overwrite, boolean preserveLastModified,
                          String encoding, Project project) throws IOException {
         copyFile(sourceFile, destFile, filters, filterChains,
                  overwrite, preserveLastModified, encoding, encoding, project);
     }
 
     /**
      * Convenience method to copy a file from a source to a
      * destination specifying if token filtering must be used, if
      * filter chains must be used, if source files may overwrite
      * newer destination files and the last modified time of
      * <code>destFile</code> file should be made equal
      * to the last modified time of <code>sourceFile</code>.
      *
      * @param sourceFile the file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile the file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination file should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the resulting file should be set to that
      *                             of the source file.
      * @param inputEncoding the encoding used to read the files.
      * @param outputEncoding the encoding used to write the files.
      * @param project the project instance.
      *
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.6
      */
     public void copyFile(File sourceFile, File destFile,
             FilterSetCollection filters, Vector filterChains,
             boolean overwrite, boolean preserveLastModified,
             String inputEncoding, String outputEncoding,
             Project project) throws IOException {
         copyFile(sourceFile, destFile, filters, filterChains, overwrite, preserveLastModified,
                 false, inputEncoding, outputEncoding, project);
     }
 
     /**
      * Convenience method to copy a file from a source to a
      * destination specifying if token filtering must be used, if
      * filter chains must be used, if source files may overwrite
      * newer destination files and the last modified time of
      * <code>destFile</code> file should be made equal
      * to the last modified time of <code>sourceFile</code>.
      *
      * @param sourceFile the file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile the file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination file should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the resulting file should be set to that
      *                             of the source file.
      * @param append whether to append to the destination file.
      * @param inputEncoding the encoding used to read the files.
      * @param outputEncoding the encoding used to write the files.
      * @param project the project instance.
      *
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.8
      */
     public void copyFile(File sourceFile, File destFile,
                          FilterSetCollection filters, Vector filterChains,
                          boolean overwrite, boolean preserveLastModified,
                          boolean append,
                          String inputEncoding, String outputEncoding,
                          Project project) throws IOException {
         copyFile(sourceFile, destFile, filters, filterChains, overwrite,
                  preserveLastModified, append, inputEncoding, outputEncoding,
                  project, /* force: */ false);
     }
 
     /**
      * Convenience method to copy a file from a source to a
      * destination specifying if token filtering must be used, if
      * filter chains must be used, if source files may overwrite
      * newer destination files and the last modified time of
      * <code>destFile</code> file should be made equal
      * to the last modified time of <code>sourceFile</code>.
      *
      * @param sourceFile the file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile the file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination file should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the resulting file should be set to that
      *                             of the source file.
      * @param append whether to append to the destination file.
      * @param inputEncoding the encoding used to read the files.
      * @param outputEncoding the encoding used to write the files.
      * @param project the project instance.
      * @param force whether to overwrite read-only destination files.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.8.2
      */
     public void copyFile(File sourceFile, File destFile,
                          FilterSetCollection filters, Vector filterChains,
                          boolean overwrite, boolean preserveLastModified,
                          boolean append,
                          String inputEncoding, String outputEncoding,
                          Project project, boolean force) throws IOException {
         ResourceUtils.copyResource(new FileResource(sourceFile),
                                    new FileResource(destFile),
                                    filters, filterChains, overwrite,
                                    preserveLastModified, append, inputEncoding,
                                    outputEncoding, project, force);
     }
 
     // CheckStyle:ParameterNumberCheck ON
 
     /**
      * Calls File.setLastModified(long time). Originally written to
      * to dynamically bind to that call on Java1.2+.
      *
      * @param file the file whose modified time is to be set
      * @param time the time to which the last modified time is to be set.
      *             if this is -1, the current time is used.
      */
     public void setFileLastModified(File file, long time) {
         ResourceUtils.setLastModified(new FileResource(file), time);
     }
 
     /**
      * Interpret the filename as a file relative to the given file
      * unless the filename already represents an absolute filename.
      * Differs from <code>new File(file, filename)</code> in that
      * the resulting File's path will always be a normalized,
      * absolute pathname.  Also, if it is determined that
      * <code>filename</code> is context-relative, <code>file</code>
      * will be discarded and the reference will be resolved using
      * available context/state information about the filesystem.
      *
      * @param file the "reference" file for relative paths. This
      * instance must be an absolute file and must not contain
      * &quot;./&quot; or &quot;../&quot; sequences (same for \ instead
      * of /).  If it is null, this call is equivalent to
      * <code>new java.io.File(filename).getAbsoluteFile()</code>.
      *
      * @param filename a file name.
      *
      * @return an absolute file.
      * @throws java.lang.NullPointerException if filename is null.
      */
     public File resolveFile(File file, String filename) {
         if (!isAbsolutePath(filename)) {
             char sep = File.separatorChar;
             filename = filename.replace('/', sep).replace('\\', sep);
             if (isContextRelativePath(filename)) {
                 file = null;
                 // on cygwin, our current directory can be a UNC;
                 // assume user.dir is absolute or all hell breaks loose...
                 String udir = System.getProperty("user.dir");
                 if (filename.charAt(0) == sep && udir.charAt(0) == sep) {
                     filename = dissect(udir)[0] + filename.substring(1);
                 }
             }
             filename = new File(file, filename).getAbsolutePath();
         }
         return normalize(filename);
     }
 
     /**
      * On DOS and NetWare, the evaluation of certain file
      * specifications is context-dependent.  These are filenames
      * beginning with a single separator (relative to current root directory)
      * and filenames with a drive specification and no intervening separator
      * (relative to current directory of the specified root).
      * @param filename the filename to evaluate.
      * @return true if the filename is relative to system context.
      * @throws java.lang.NullPointerException if filename is null.
      * @since Ant 1.7
      */
     public static boolean isContextRelativePath(String filename) {
         if (!(ON_DOS || ON_NETWARE) || filename.length() == 0) {
             return false;
         }
         char sep = File.separatorChar;
         filename = filename.replace('/', sep).replace('\\', sep);
         char c = filename.charAt(0);
         int len = filename.length();
         return (c == sep && (len == 1 || filename.charAt(1) != sep))
                 || (Character.isLetter(c) && len > 1
                 && filename.indexOf(':') == 1
                 && (len == 2 || filename.charAt(2) != sep));
     }
 
     /**
      * Verifies that the specified filename represents an absolute path.
      * Differs from new java.io.File("filename").isAbsolute() in that a path
      * beginning with a double file separator--signifying a Windows UNC--must
      * at minimum match "\\a\b" to be considered an absolute path.
      * @param filename the filename to be checked.
      * @return true if the filename represents an absolute path.
      * @throws java.lang.NullPointerException if filename is null.
      * @since Ant 1.6.3
      */
     public static boolean isAbsolutePath(String filename) {
         int len = filename.length();
         if (len == 0) {
             return false;
         }
         char sep = File.separatorChar;
         filename = filename.replace('/', sep).replace('\\', sep);
         char c = filename.charAt(0);
         if (!(ON_DOS || ON_NETWARE)) {
             return (c == sep);
         }
         if (c == sep) {
             // CheckStyle:MagicNumber OFF
             if (!(ON_DOS && len > 4 && filename.charAt(1) == sep)) {
                 return false;
             }
             // CheckStyle:MagicNumber ON
             int nextsep = filename.indexOf(sep, 2);
             return nextsep > 2 && nextsep + 1 < len;
         }
         int colon = filename.indexOf(':');
         return (Character.isLetter(c) && colon == 1
                 && filename.length() > 2 && filename.charAt(2) == sep)
                 || (ON_NETWARE && colon > 0);
     }
 
     /**
      * Translate a path into its native (platform specific) format.
      * <p>
      * This method uses PathTokenizer to separate the input path
      * into its components. This handles DOS style paths in a relatively
      * sensible way. The file separators are then converted to their platform
      * specific versions.
      *
      * @param toProcess The path to be translated.
      *                  May be <code>null</code>.
      *
      * @return the native version of the specified path or
      *         an empty string if the path is <code>null</code> or empty.
      *
      * @since ant 1.7
      * @see PathTokenizer
      */
     public static String translatePath(String toProcess) {
         if (toProcess == null || toProcess.length() == 0) {
             return "";
         }
         StringBuffer path = new StringBuffer(toProcess.length() + EXPAND_SPACE);
         PathTokenizer tokenizer = new PathTokenizer(toProcess);
         while (tokenizer.hasMoreTokens()) {
             String pathComponent = tokenizer.nextToken();
             pathComponent = pathComponent.replace('/', File.separatorChar);
             pathComponent = pathComponent.replace('\\', File.separatorChar);
             if (path.length() != 0) {
                 path.append(File.pathSeparatorChar);
             }
             path.append(pathComponent);
         }
         return path.toString();
     }
 
     /**
      * &quot;Normalize&quot; the given absolute path.
      *
      * <p>This includes:
      * <ul>
      *   <li>Uppercase the drive letter if there is one.</li>
      *   <li>Remove redundant slashes after the drive spec.</li>
      *   <li>Resolve all ./, .\, ../ and ..\ sequences.</li>
      *   <li>DOS style paths that start with a drive letter will have
      *     \ as the separator.</li>
      * </ul>
      * Unlike {@link File#getCanonicalPath()} this method
      * specifically does not resolve symbolic links.
      *
      * @param path the path to be normalized.
      * @return the normalized version of the path.
      *
      * @throws java.lang.NullPointerException if path is null.
      */
     public File normalize(final String path) {
         Stack s = new Stack();
         String[] dissect = dissect(path);
         s.push(dissect[0]);
 
         StringTokenizer tok = new StringTokenizer(dissect[1], File.separator);
         while (tok.hasMoreTokens()) {
             String thisToken = tok.nextToken();
             if (".".equals(thisToken)) {
                 continue;
             }
             if ("..".equals(thisToken)) {
                 if (s.size() < 2) {
                     // Cannot resolve it, so skip it.
                     return new File(path);
                 }
                 s.pop();
             } else { // plain component
                 s.push(thisToken);
             }
         }
         StringBuffer sb = new StringBuffer();
-        for (int i = 0; i < s.size(); i++) {
+        final int size = s.size();
+        for (int i = 0; i < size; i++) {
             if (i > 1) {
                 // not before the filesystem root and not after it, since root
                 // already contains one
                 sb.append(File.separatorChar);
             }
             sb.append(s.elementAt(i));
         }
         return new File(sb.toString());
     }
 
     /**
      * Dissect the specified absolute path.
      * @param path the path to dissect.
      * @return String[] {root, remaining path}.
      * @throws java.lang.NullPointerException if path is null.
      * @since Ant 1.7
      */
     public String[] dissect(String path) {
         char sep = File.separatorChar;
         path = path.replace('/', sep).replace('\\', sep);
 
         // make sure we are dealing with an absolute path
         if (!isAbsolutePath(path)) {
             throw new BuildException(path + " is not an absolute path");
         }
         String root = null;
         int colon = path.indexOf(':');
         if (colon > 0 && (ON_DOS || ON_NETWARE)) {
 
             int next = colon + 1;
             root = path.substring(0, next);
             char[] ca = path.toCharArray();
             root += sep;
             //remove the initial separator; the root has it.
             next = (ca[next] == sep) ? next + 1 : next;
 
             StringBuffer sbPath = new StringBuffer();
             // Eliminate consecutive slashes after the drive spec:
             for (int i = next; i < ca.length; i++) {
                 if (ca[i] != sep || ca[i - 1] != sep) {
                     sbPath.append(ca[i]);
                 }
             }
             path = sbPath.toString();
         } else if (path.length() > 1 && path.charAt(1) == sep) {
             // UNC drive
             int nextsep = path.indexOf(sep, 2);
             nextsep = path.indexOf(sep, nextsep + 1);
             root = (nextsep > 2) ? path.substring(0, nextsep + 1) : path;
             path = path.substring(root.length());
         } else {
             root = File.separator;
             path = path.substring(1);
         }
         return new String[] {root, path};
     }
 
     /**
      * Returns a VMS String representation of a <code>File</code> object.
      * This is useful since the JVM by default internally converts VMS paths
      * to Unix style.
      * The returned String is always an absolute path.
      *
      * @param f The <code>File</code> to get the VMS path for.
      * @return The absolute VMS path to <code>f</code>.
      */
     public String toVMSPath(File f) {
         // format: "DEVICE:[DIR.SUBDIR]FILE"
         String osPath;
         String path = normalize(f.getAbsolutePath()).getPath();
         String name = f.getName();
         boolean isAbsolute = path.charAt(0) == File.separatorChar;
         // treat directories specified using .DIR syntax as files
         // CheckStyle:MagicNumber OFF
         boolean isDirectory = f.isDirectory()
                 && !name.regionMatches(true, name.length() - 4, ".DIR", 0, 4);
         // CheckStyle:MagicNumber ON
         String device = null;
         StringBuffer directory = null;
         String file = null;
 
         int index = 0;
 
         if (isAbsolute) {
             index = path.indexOf(File.separatorChar, 1);
             if (index == -1) {
                 return path.substring(1) + ":[000000]";
             }
             device = path.substring(1, index++);
         }
         if (isDirectory) {
             directory = new StringBuffer(path.substring(index).replace(File.separatorChar, '.'));
         } else {
             int dirEnd = path.lastIndexOf(File.separatorChar, path.length());
             if (dirEnd == -1 || dirEnd < index) {
                 file = path.substring(index);
             } else {
                 directory = new StringBuffer(path.substring(index, dirEnd).
                                              replace(File.separatorChar, '.'));
                 index = dirEnd + 1;
                 if (path.length() > index) {
                     file = path.substring(index);
                 }
             }
         }
         if (!isAbsolute && directory != null) {
             directory.insert(0, '.');
         }
         osPath = ((device != null) ? device + ":" : "")
                 + ((directory != null) ? "[" + directory + "]" : "")
                 + ((file != null) ? file : "");
         return osPath;
     }
 
     /**
      * Create a File object for a temporary file in a given directory. Without
      * actually creating the file.
      *
      * <p>
      * The file denoted by the returned abstract pathname did not exist before
      * this method was invoked, any subsequent invocation of this method will
      * yield a different file name.
      * </p>
      * <p>
      * The filename is prefixNNNNNsuffix where NNNN is a random number.
      * </p>
      *
      * @param prefix
      *            prefix before the random number.
      * @param suffix
      *            file extension; include the '.'.
      * @param parentDir
      *            Directory to create the temporary file in; java.io.tmpdir used
      *            if not specified.
      *
      * @deprecated since ant 1.7.1 use createTempFile(String, String, File,
      * boolean, boolean) instead.
      * @return a File reference to the new, nonexistent temporary file.
      */
     public File createTempFile(String prefix, String suffix, File parentDir) {
         return createTempFile(prefix, suffix, parentDir, false, false);
     }
 
     private static final String NULL_PLACEHOLDER = "null";
 
     /**
      * Create a temporary file in a given directory.
      *
      * <p>The file denoted by the returned abstract pathname did not
      * exist before this method was invoked, any subsequent invocation
      * of this method will yield a different file name.</p>
      *
      * @param prefix prefix before the random number.
      * @param suffix file extension; include the '.'.
      * @param parentDir Directory to create the temporary file in;
      * java.io.tmpdir used if not specified.
      * @param deleteOnExit whether to set the tempfile for deletion on
      *        normal VM exit.
      * @param createFile true if the file must actually be created. If false
      * chances exist that a file with the same name is created in the time
      * between invoking this method and the moment the file is actually created.
      * If possible set to true.
      *
      * @return a File reference to the new temporary file.
      * @since Ant 1.7.1
      */
     public File createTempFile(String prefix, String suffix, File parentDir,
             boolean deleteOnExit, boolean createFile) {
         File result = null;
         String parent = (parentDir == null)
                 ? System.getProperty("java.io.tmpdir")
                 : parentDir.getPath();
         if (prefix == null) {
             prefix = NULL_PLACEHOLDER;
         }
         if (suffix == null) {
             suffix = NULL_PLACEHOLDER;
         }
 
         if (createFile) {
             try {
                 result = File.createTempFile(prefix, suffix, new File(parent));
             } catch (IOException e) {
                 throw new BuildException("Could not create tempfile in "
                         + parent, e);
             }
         } else {
             DecimalFormat fmt = new DecimalFormat("#####");
             synchronized (rand) {
                 do {
                     result = new File(parent, prefix
                             + fmt.format(rand.nextInt(Integer.MAX_VALUE)) + suffix);
                 } while (result.exists());
             }
         }
 
         if (deleteOnExit) {
             result.deleteOnExit();
         }
         return result;
     }
 
     /**
      * Create a File object for a temporary file in a given directory. Without
      * actually creating the file.
      *
      * <p>
      * The file denoted by the returned abstract pathname did not exist before
      * this method was invoked, any subsequent invocation of this method will
      * yield a different file name.
      * </p>
      * <p>
      * The filename is prefixNNNNNsuffix where NNNN is a random number.
      * </p>
      *
      * @param prefix
      *            prefix before the random number.
      * @param suffix
      *            file extension; include the '.'.
      * @param parentDir
      *            Directory to create the temporary file in; java.io.tmpdir used
      *            if not specified.
      * @param deleteOnExit
      *            whether to set the tempfile for deletion on normal VM exit.
      *
      * @deprecated since ant 1.7.1 use createTempFile(String, String, File,
      * boolean, boolean) instead.
      * @return a File reference to the new, nonexistent temporary file.
      */
     public File createTempFile(String prefix, String suffix,
             File parentDir, boolean deleteOnExit) {
         return createTempFile(prefix, suffix, parentDir, deleteOnExit, false);
     }
 
     /**
      * Compares the contents of two files.
      *
      * @param f1 the file whose content is to be compared.
      * @param f2 the other file whose content is to be compared.
      *
      * @return true if the content of the files is the same.
      *
      * @throws IOException if the files cannot be read.
      */
     public boolean contentEquals(File f1, File f2) throws IOException {
         return contentEquals(f1, f2, false);
     }
 
     /**
      * Compares the contents of two files.
      *
      * @param f1 the file whose content is to be compared.
      * @param f2 the other file whose content is to be compared.
      * @param textfile true if the file is to be treated as a text file and
      *        differences in kind of line break are to be ignored.
      *
      * @return true if the content of the files is the same.
      *
      * @throws IOException if the files cannot be read.
      * @since Ant 1.6.3
      */
     public boolean contentEquals(File f1, File f2, boolean textfile) throws IOException {
         return ResourceUtils.contentEquals(new FileResource(f1), new FileResource(f2), textfile);
     }
 
     /**
      * This was originally an emulation of {@link File#getParentFile} for JDK 1.1, but it is now
      * implemented using that method (Ant 1.6.3 onwards).
      *
      * @param f the file whose parent is required.
      * @return the given file's parent, or null if the file does not have a parent.
      * @since 1.10
      * @deprecated since 1.7. Just use {@link File#getParentFile} directly.
      */
     public File getParentFile(File f) {
         return (f == null) ? null : f.getParentFile();
     }
 
     /**
      * Read from reader till EOF.
      * @param rdr the reader from which to read.
      * @return the contents read out of the given reader.
      *
      * @throws IOException if the contents could not be read out from the
      *         reader.
      */
     public static String readFully(Reader rdr) throws IOException {
         return readFully(rdr, BUF_SIZE);
     }
 
     /**
      * Read from reader till EOF.
      *
      * @param rdr the reader from which to read.
      * @param bufferSize the buffer size to use when reading.
      *
      * @return the contents read out of the given reader.
      *
      * @throws IOException if the contents could not be read out from the
      *         reader.
      */
     public static String readFully(Reader rdr, int bufferSize)
         throws IOException {
         if (bufferSize <= 0) {
             throw new IllegalArgumentException("Buffer size must be greater "
                                                + "than 0");
         }
         final char[] buffer = new char[bufferSize];
         int bufferLength = 0;
         StringBuffer textBuffer = null;
         while (bufferLength != -1) {
             bufferLength = rdr.read(buffer);
             if (bufferLength > 0) {
                 textBuffer = (textBuffer == null) ? new StringBuffer() : textBuffer;
                 textBuffer.append(new String(buffer, 0, bufferLength));
             }
         }
         return (textBuffer == null) ? null : textBuffer.toString();
     }
 
     /**
      * Safe read fully - do not return a null for an empty reader.
      * @param reader the input to read from.
      * @return the string.
      * @throws IOException if unable to read from reader.
      * @since Ant 1.7.1
      */
     public static String safeReadFully(Reader reader) throws IOException {
         String ret = readFully(reader);
         return ret == null ? "" : ret;
     }
 
     /**
      * This was originally an emulation of File.createNewFile for JDK 1.1,
      * but it is now implemented using that method (Ant 1.6.3 onwards).
      *
      * <p>This method has historically <strong>not</strong> guaranteed that the
      * operation was atomic. In its current implementation it is.
      *
      * @param f the file to be created.
      * @return true if the file did not exist already.
      * @throws IOException on error.
      * @since Ant 1.5
      */
     public boolean createNewFile(File f) throws IOException {
         return f.createNewFile();
     }
 
     /**
      * Create a new file, optionally creating parent directories.
      *
      * @param f the file to be created.
      * @param mkdirs <code>boolean</code> whether to create parent directories.
      * @return true if the file did not exist already.
      * @throws IOException on error.
      * @since Ant 1.6.3
      */
     public boolean createNewFile(File f, boolean mkdirs) throws IOException {
         File parent = f.getParentFile();
         if (mkdirs && !(parent.exists())) {
             parent.mkdirs();
         }
         return f.createNewFile();
     }
 
     /**
      * Checks whether a given file is a symbolic link.
      *
      * <p>It doesn't really test for symbolic links but whether the
      * canonical and absolute paths of the file are identical--this
      * may lead to false positives on some platforms.</p>
      *
      * @param parent the parent directory of the file to test
      * @param name the name of the file to test.
      *
      * @return true if the file is a symbolic link.
      * @throws IOException on error.
      * @since Ant 1.5
      * @deprecated use SymbolicLinkUtils instead
      */
     public boolean isSymbolicLink(File parent, String name)
         throws IOException {
         SymbolicLinkUtils u = SymbolicLinkUtils.getSymbolicLinkUtils();
         if (parent == null) {
             return u.isSymbolicLink(name);
         }
         return u.isSymbolicLink(parent, name);
     }
 
     /**
      * Removes a leading path from a second path.
      *
      * @param leading The leading path, must not be null, must be absolute.
      * @param path The path to remove from, must not be null, must be absolute.
      *
      * @return path's normalized absolute if it doesn't start with
      * leading; path's path with leading's path removed otherwise.
      *
      * @since Ant 1.5
      */
     public String removeLeadingPath(File leading, File path) {
         String l = normalize(leading.getAbsolutePath()).getAbsolutePath();
         String p = normalize(path.getAbsolutePath()).getAbsolutePath();
         if (l.equals(p)) {
             return "";
         }
         // ensure that l ends with a /
         // so we never think /foo was a parent directory of /foobar
         if (!l.endsWith(File.separator)) {
             l += File.separator;
         }
         return (p.startsWith(l)) ? p.substring(l.length()) : p;
     }
 
     /**
      * Learn whether one path "leads" another.
      * @param leading The leading path, must not be null, must be absolute.
      * @param path The path to remove from, must not be null, must be absolute.
      * @return true if path starts with leading; false otherwise.
      * @since Ant 1.7
      */
     public boolean isLeadingPath(File leading, File path) {
         String l = normalize(leading.getAbsolutePath()).getAbsolutePath();
         String p = normalize(path.getAbsolutePath()).getAbsolutePath();
         if (l.equals(p)) {
             return true;
         }
         // ensure that l ends with a /
         // so we never think /foo was a parent directory of /foobar
         if (!l.endsWith(File.separator)) {
             l += File.separator;
         }
         return p.startsWith(l);
     }
 
     /**
      * Constructs a <code>file:</code> URI that represents the
      * external form of the given pathname.
      *
      * <p>Will be an absolute URI if the given path is absolute.</p>
      *
      * <p>This code encodes non ASCII characters too.</p>
      *
      * <p>The coding of the output is the same as what File.toURI().toASCIIString() produces</p>
      *
      * See <a href="http://www.w3.org/TR/xml11/#dt-sysid">dt-sysid</a>
      * which makes some mention of how
      * characters not supported by URI Reference syntax should be escaped.
      *
      * @param path the path in the local file system.
      * @return the URI version of the local path.
      * @since Ant 1.6
      */
     public String toURI(String path) {
         return new File(path).getAbsoluteFile().toURI().toASCIIString();
     }
 
     /**
      * Constructs a file path from a <code>file:</code> URI.
      *
      * <p>Will be an absolute path if the given URI is absolute.</p>
      *
      * <p>Swallows '%' that are not followed by two characters,
      * doesn't deal with non-ASCII characters.</p>
      *
      * @param uri the URI designating a file in the local filesystem.
      * @return the local file system path for the file.
      * @since Ant 1.6
      */
     public String fromURI(String uri) {
         synchronized (cacheFromUriLock) {
             if (uri.equals(cacheFromUriRequest)) {
                 return cacheFromUriResponse;
             }
             String path = Locator.fromURI(uri);
             String ret = isAbsolutePath(path) ? normalize(path).getAbsolutePath() : path;
             cacheFromUriRequest = uri;
             cacheFromUriResponse = ret;
             return ret;
         }
     }
 
     /**
      * Compares two filenames.
      *
      * <p>Unlike java.io.File#equals this method will try to compare
      * the absolute paths and &quot;normalize&quot; the filenames
      * before comparing them.</p>
      *
      * @param f1 the file whose name is to be compared.
      * @param f2 the other file whose name is to be compared.
      *
      * @return true if the file are for the same file.
      *
      * @since Ant 1.5.3
      */
     public boolean fileNameEquals(File f1, File f2) {
         return normalize(f1.getAbsolutePath()).getAbsolutePath().equals(
                 normalize(f2.getAbsolutePath()).getAbsolutePath());
     }
 
     /**
      * Are the two File instances pointing to the same object on the
      * file system?
      * @since Ant 1.8.2
      */
     public boolean areSame(File f1, File f2) throws IOException {
         if (f1 == null && f2 == null) {
             return true;
         }
         if (f1 == null || f2 == null) {
             return false;
         }
         File f1Normalized = normalize(f1.getAbsolutePath());
         File f2Normalized = normalize(f2.getAbsolutePath());
         return f1Normalized.equals(f2Normalized)
             || f1Normalized.getCanonicalFile().equals(f2Normalized
                                                       .getCanonicalFile());
     }
 
     /**
      * Renames a file, even if that involves crossing file system boundaries.
      *
      * <p>This will remove <code>to</code> (if it exists), ensure that
      * <code>to</code>'s parent directory exists and move
      * <code>from</code>, which involves deleting <code>from</code> as
      * well.</p>
      *
      * @param from the file to move.
      * @param to the new file name.
      *
      * @throws IOException if anything bad happens during this
      * process.  Note that <code>to</code> may have been deleted
      * already when this happens.
      *
      * @since Ant 1.6
      */
     public void rename(File from, File to) throws IOException {
         // identical logic lives in Move.renameFile():
         from = normalize(from.getAbsolutePath()).getCanonicalFile();
         to = normalize(to.getAbsolutePath());
         if (!from.exists()) {
             System.err.println("Cannot rename nonexistent file " + from);
             return;
         }
         if (from.getAbsolutePath().equals(to.getAbsolutePath())) {
             System.err.println("Rename of " + from + " to " + to + " is a no-op.");
             return;
         }
         if (to.exists() && !(areSame(from, to) || tryHardToDelete(to))) {
             throw new IOException("Failed to delete " + to + " while trying to rename " + from);
         }
         File parent = to.getParentFile();
         if (parent != null && !parent.exists() && !parent.mkdirs()) {
             throw new IOException("Failed to create directory " + parent
                                   + " while trying to rename " + from);
         }
         if (!from.renameTo(to)) {
             copyFile(from, to);
             if (!tryHardToDelete(from)) {
                 throw new IOException("Failed to delete " + from + " while trying to rename it.");
             }
         }
     }
 
     /**
      * Get the granularity of file timestamps. The choice is made based on OS, which is
      * incorrect--it should really be by filesystem. We do not have an easy way to probe for file
      * systems, however, so this heuristic gives us a decent default.
      *
      * @return the difference, in milliseconds, which two file timestamps must have in order for the
      *         two files to be considered to have different timestamps.
      */
     public long getFileTimestampGranularity() {
         if (ON_WIN9X) {
             return FAT_FILE_TIMESTAMP_GRANULARITY;
         }
         if (ON_WINDOWS) {
             return NTFS_FILE_TIMESTAMP_GRANULARITY;
         }
         if (ON_DOS) {
             return FAT_FILE_TIMESTAMP_GRANULARITY;
         }
         return UNIX_FILE_TIMESTAMP_GRANULARITY;
     }
 
     /**
      * test whether a file or directory exists, with an error in the
      * upper/lower case spelling of the name.
      * Using this method is only interesting on case insensitive file systems
      * (Windows).<br/>
      * It will return true only if 3 conditions are met :
      * <br/>
      * <ul>
      *   <li>operating system is case insensitive</li>
      *   <li>file exists</li>
      *   <li>actual name from directory reading is different from the
      *       supplied argument</li>
      * </ul>
      *  <br/>
      * the purpose is to identify files or directories on case-insensitive
      * filesystems whose case is not what is expected.<br/>
      * Possibly to rename them afterwards to the desired upper/lowercase
      * combination.
      * <br/>
      * @param localFile file to test
      * @return true if the file exists and the case of the actual file
      *              is not the case of the parameter
      * @since Ant 1.7.1
      */
     public boolean hasErrorInCase(File localFile) {
         localFile = normalize(localFile.getAbsolutePath());
         if (!localFile.exists()) {
             return false;
         }
         final String localFileName = localFile.getName();
         FilenameFilter ff = new FilenameFilter () {
             public boolean accept(File dir, String name) {
                 return name.equalsIgnoreCase(localFileName) && (!name.equals(localFileName));
             }
         };
         String[] names = localFile.getParentFile().list(ff);
         return names != null && names.length == 1;
     }
 
     /**
      * Returns true if the source is older than the dest.
      * If the dest file does not exist, then the test returns false; it is
      * implicitly not up do date.
      * @param source source file (should be the older).
      * @param dest dest file (should be the newer).
      * @param granularity an offset added to the source time.
      * @return true if the source is older than the dest after accounting
      *              for granularity.
      * @since Ant 1.6.3
      */
     public boolean isUpToDate(File source, File dest, long granularity) {
         //do a check for the destination file existing
         if (!dest.exists()) {
             //if it does not, then the file is not up to date.
             return false;
         }
         long sourceTime = source.lastModified();
         long destTime = dest.lastModified();
         return isUpToDate(sourceTime, destTime, granularity);
     }
 
     /**
      * Returns true if the source is older than the dest.
      * @param source source file (should be the older).
      * @param dest dest file (should be the newer).
      * @return true if the source is older than the dest, taking the granularity into account.
      * @since Ant 1.6.3
      */
     public boolean isUpToDate(File source, File dest) {
         return isUpToDate(source, dest, getFileTimestampGranularity());
     }
 
     /**
      * Compare two timestamps for being up to date using
      * the specified granularity.
      *
      * @param sourceTime timestamp of source file.
      * @param destTime timestamp of dest file.
      * @param granularity os/filesys granularity.
      * @return true if the dest file is considered up to date.
      */
     public boolean isUpToDate(long sourceTime, long destTime, long granularity) {
         return destTime != -1 && destTime >= sourceTime + granularity;
     }
 
     /**
      * Compare two timestamps for being up to date using the
      * current granularity.
      *
      * @param sourceTime  timestamp of source file.
      * @param destTime    timestamp of dest file.
      * @return true if the dest file is considered up to date.
      */
     public boolean isUpToDate(long sourceTime, long destTime) {
         return isUpToDate(sourceTime, destTime, getFileTimestampGranularity());
     }
 
     /**
      * Close a Writer without throwing any exception if something went wrong.
      * Do not attempt to close it if the argument is null.
      * @param device output writer, can be null.
      */
     public static void close(Writer device) {
         if (null != device) {
             try {
                 device.close();
             } catch (IOException e) {
                 //ignore
             }
         }
     }
 
     /**
      * Close a Reader without throwing any exception if something went wrong.
      * Do not attempt to close it if the argument is null.
      *
      * @param device Reader, can be null.
      */
     public static void close(Reader device) {
         if (null != device) {
             try {
                 device.close();
             } catch (IOException e) {
                 //ignore
             }
         }
     }
 
     /**
      * Close a stream without throwing any exception if something went wrong.
      * Do not attempt to close it if the argument is null.
      *
      * @param device stream, can be null.
      */
     public static void close(OutputStream device) {
         if (null != device) {
             try {
                 device.close();
             } catch (IOException e) {
                 //ignore
             }
         }
     }
 
     /**
      * Close a stream without throwing any exception if something went wrong.
      * Do not attempt to close it if the argument is null.
      *
      * @param device stream, can be null.
      */
     public static void close(InputStream device) {
         if (null != device) {
             try {
                 device.close();
             } catch (IOException e) {
                 //ignore
             }
         }
     }
 
     /**
      * Close a Channel without throwing any exception if something went wrong.
      * Do not attempt to close it if the argument is null.
      *
      * @param device channel, can be null.
      * @since Ant 1.8.0
      */
     public static void close(Channel device) {
         if (null != device) {
             try {
                 device.close();
             } catch (IOException e) {
                 //ignore
             }
         }
     }
 
     /**
      * Closes an URLConnection if its concrete implementation provides
      * a way to close it that Ant knows of.
      *
      * @param conn connection, can be null
      * @since Ant 1.8.0
      */
     public static void close(URLConnection conn) {
         if (conn != null) {
             try {
                 if (conn instanceof JarURLConnection) {
                     JarURLConnection juc = (JarURLConnection) conn;
                     JarFile jf = juc.getJarFile();
                     jf.close();
                     jf = null;
                 } else if (conn instanceof HttpURLConnection) {
                     ((HttpURLConnection) conn).disconnect();
                 }
             } catch (IOException exc) {
                 //ignore
             }
         }
     }
 
     /**
      * Delete the file with {@link File#delete()} if the argument is not null.
      * Do nothing on a null argument.
      * @param file file to delete.
      */
     public static void delete(File file) {
         if (file != null) {
             file.delete();
         }
     }
 
     /**
      * Accommodate Windows bug encountered in both Sun and IBM JDKs.
      * Others possible. If the delete does not work, call System.gc(),
      * wait a little and try again.
      *
      * @return whether deletion was successful
      * @since Ant 1.8.0
      */
     public boolean tryHardToDelete(File f) {
         if (!f.delete()) {
             if (ON_WINDOWS) {
                 System.gc();
             }
             try {
                 Thread.sleep(DELETE_RETRY_SLEEP_MILLIS);
             } catch (InterruptedException ex) {
                 // Ignore Exception
             }
             return f.delete();
         }
         return true;
     }
 
 
     /**
      * Calculates the relative path between two files.
      * <p>
      * Implementation note:<br/> This function may throw an IOException if an I/O error occurs
      * because its use of the canonical pathname may require filesystem queries.
      * </p>
      *
      * @param fromFile the <code>File</code> to calculate the path from
      * @param toFile the <code>File</code> to calculate the path to
      * @return the relative path between the files
      * @throws Exception for undocumented reasons
      * @see File#getCanonicalPath()
      *
      * @since Ant 1.7
      */
     public static String getRelativePath(File fromFile, File toFile) throws Exception {
         String fromPath = fromFile.getCanonicalPath();
         String toPath = toFile.getCanonicalPath();
 
         // build the path stack info to compare
         String[] fromPathStack = getPathStack(fromPath);
         String[] toPathStack = getPathStack(toPath);
 
         if (0 < toPathStack.length && 0 < fromPathStack.length) {
             if (!fromPathStack[0].equals(toPathStack[0])) {
                 // not the same device (would be "" on Linux/Unix)
 
                 return getPath(Arrays.asList(toPathStack));
             }
         } else {
             // no comparison possible
             return getPath(Arrays.asList(toPathStack));
         }
 
         int minLength = Math.min(fromPathStack.length, toPathStack.length);
         int same = 1; // Used outside the for loop
 
         // get index of parts which are equal
         for (;
              same < minLength && fromPathStack[same].equals(toPathStack[same]);
              same++) {
             // Do nothing
         }
 
         List relativePathStack = new ArrayList();
 
         // if "from" part is longer, fill it up with ".."
         // to reach path which is equal to both paths
         for (int i = same; i < fromPathStack.length; i++) {
             relativePathStack.add("..");
         }
 
         // fill it up path with parts which were not equal
         for (int i = same; i < toPathStack.length; i++) {
             relativePathStack.add(toPathStack[i]);
         }
 
         return getPath(relativePathStack);
     }
 
     /**
      * Gets all names of the path as an array of <code>String</code>s.
      *
      * @param path to get names from
      * @return <code>String</code>s, never <code>null</code>
      *
      * @since Ant 1.7
      */
     public static String[] getPathStack(String path) {
         String normalizedPath = path.replace(File.separatorChar, '/');
 
         return normalizedPath.split("/");
     }
 
     /**
      * Gets path from a <code>List</code> of <code>String</code>s.
      *
      * @param pathStack <code>List</code> of <code>String</code>s to be concatenated as a path.
      * @return <code>String</code>, never <code>null</code>
      *
      * @since Ant 1.7
      */
     public static String getPath(List pathStack) {
         // can safely use '/' because Windows understands '/' as separator
         return getPath(pathStack, '/');
     }
 
     /**
      * Gets path from a <code>List</code> of <code>String</code>s.
      *
      * @param pathStack <code>List</code> of <code>String</code>s to be concated as a path.
      * @param separatorChar <code>char</code> to be used as separator between names in path
      * @return <code>String</code>, never <code>null</code>
      *
      * @since Ant 1.7
      */
     public static String getPath(final List pathStack, final char separatorChar) {
         final StringBuffer buffer = new StringBuffer();
 
         final Iterator iter = pathStack.iterator();
         if (iter.hasNext()) {
             buffer.append(iter.next());
         }
         while (iter.hasNext()) {
             buffer.append(separatorChar);
             buffer.append(iter.next());
         }
         return buffer.toString();
     }
 
     /**
      * Get the default encoding.
      * This is done by opening an InputStreamReader on
      * a dummy InputStream and getting the encoding.
      * Could use System.getProperty("file.encoding"), but cannot
      * see where this is documented.
      * @return the default file encoding.
      */
     public String getDefaultEncoding() {
         InputStreamReader is = new InputStreamReader(
             new InputStream() {
                 public int read() {
                     return -1;
                 }
             });
         try {
             return is.getEncoding();
         } finally {
             close(is);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/util/IdentityStack.java b/src/main/org/apache/tools/ant/util/IdentityStack.java
index 2f95cf586..4fe7829aa 100644
--- a/src/main/org/apache/tools/ant/util/IdentityStack.java
+++ b/src/main/org/apache/tools/ant/util/IdentityStack.java
@@ -1,104 +1,105 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 import java.util.Stack;
 
 /**
  * Identity Stack.
  * @since Ant 1.7
  */
 public class IdentityStack extends Stack {
 
     private static final long serialVersionUID = -5555522620060077046L;
 
     /**
      * Get an IdentityStack containing the contents of the specified Stack.
      * @param s the Stack to copy; ignored if null.
      * @return an IdentityStack instance.
      */
     public static IdentityStack getInstance(Stack s) {
         if (s instanceof IdentityStack) {
             return (IdentityStack) s;
         }
         IdentityStack result = new IdentityStack();
         if (s != null) {
             result.addAll(s);
         }
         return result;
     }
 
     /**
      * Default constructor.
      */
     public IdentityStack() {
     }
 
     /**
      * Construct a new IdentityStack with the specified Object
      * as the bottom element.
      * @param o the bottom element.
      */
     public IdentityStack(Object o) {
         super();
         push(o);
     }
 
     /**
      * Override methods that use <code>.equals()</code> comparisons on elements.
      * @param o the Object to search for.
      * @return true if the stack contains the object.
      * @see java.util.Vector#contains(Object)
      */
     public synchronized boolean contains(Object o) {
         return indexOf(o) >= 0;
     }
 
     /**
      * Override methods that use <code>.equals()</code> comparisons on elements.
      * @param o   the Object to search for.
      * @param pos the position from which to search.
      * @return the position of the object, -1 if not found.
      * @see java.util.Vector#indexOf(Object, int)
      */
     public synchronized int indexOf(Object o, int pos) {
-        for (int i = pos; i < size(); i++) {
+        final int size = size();
+        for (int i = pos; i < size; i++) {
             if (get(i) == o) {
                 return i;
             }
         }
         return -1;
     }
 
     /**
      * Override methods that use <code>.equals()</code> comparisons on elements.
      * @param o   the Object to search for.
      * @param pos the position from which to search (backward).
      * @return the position of the object, -1 if not found.
      * @see java.util.Vector#indexOf(Object, int)
      */
     public synchronized int lastIndexOf(Object o, int pos) {
         for (int i = pos; i >= 0; i--) {
             if (get(i) == o) {
                 return i;
             }
         }
         return -1;
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/util/LayoutPreservingProperties.java b/src/main/org/apache/tools/ant/util/LayoutPreservingProperties.java
index ecab3407a..b85a03c87 100644
--- a/src/main/org/apache/tools/ant/util/LayoutPreservingProperties.java
+++ b/src/main/org/apache/tools/ant/util/LayoutPreservingProperties.java
@@ -1,772 +1,773 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.PrintStream;
 import java.io.PushbackReader;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Properties;
 
 /**
  * <p>A Properties collection which preserves comments and whitespace
  * present in the input stream from which it was loaded.</p>
  * <p>The class defers the usual work of the <a href="http://java.sun.com/j2se/1.3/docs/api/java/util/Properties.html">java.util.Properties</a>
  * class to there, but it also keeps track of the contents of the
  * input stream from which it was loaded (if applicable), so that it can
  * write out the properties in as close a form as possible to the input.</p>
  * If no changes occur to property values, the output should be the same
  * as the input, except for the leading date stamp, as normal for a
  * properties file. Properties added are appended to the file. Properties
  * whose values are changed are changed in place. Properties that are
  * removed are excised. If the <code>removeComments</code> flag is set,
  * then the comments immediately preceding the property are also removed.</p>
  * <p>If a second set of properties is loaded into an existing set, the
  * lines of the second set are added to the end. Note however, that if a
  * property already stored is present in a stream subsequently loaded, then
  * that property is removed before the new value is set. For example,
  * consider the file</p>
  * <pre> # the first line
  * alpha=one
  *
  * # the second line
  * beta=two</pre>
  * <p>This file is loaded, and then the following is also loaded into the
  * same <code>LayoutPreservingProperties</code> object</p>
  * <pre> # association
  * beta=band
  *
  * # and finally
  * gamma=rays</pre>
  * </p>The resulting collection sequence of logical lines depends on whether
  * or not <code>removeComments</code> was set at the time the second stream
  * is loaded. If it is set, then the resulting list of lines is</p>
  * <pre> # the first line
  * alpha=one
  *
  * # association
  * beta=band
  *
  * # and finally
  * gamma=rays</pre>
  * <p>If the flag is not set, then the comment "the second line" is retained,
  * although the key-value pair <code>beta=two</code> is removed.</p>
  */
 public class LayoutPreservingProperties extends Properties {
     private String LS = StringUtils.LINE_SEP;
 
     /**
      * Logical lines have escaping and line continuation taken care
      * of. Comments and blank lines are logical lines; they are not
      * removed.
      */
     private ArrayList logicalLines = new ArrayList();
 
     /**
      * Position in the <code>logicalLines</code> list, keyed by property name.
      */
     private HashMap keyedPairLines = new HashMap();
 
     /**
      * Flag to indicate that, when we remove a property from the file, we
      * also want to remove the comments that precede it.
      */
     private boolean removeComments;
 
     /**
      * Create a new, empty, Properties collection, with no defaults.
      */
     public LayoutPreservingProperties() {
         super();
     }
 
     /**
      * Create a new, empty, Properties collection, with the specified defaults.
      * @param defaults the default property values
      */
     public LayoutPreservingProperties(Properties defaults) {
         super(defaults);
     }
 
     /**
      * Returns <code>true</code> if comments are removed along with
      * properties, or <code>false</code> otherwise. If
      * <code>true</code>, then when a property is removed, the comment
      * preceding it in the original file is removed also.
      * @return <code>true</code> if leading comments are removed when
      * a property is removed; <code>false</code> otherwise
      */
     public boolean isRemoveComments() {
         return removeComments;
     }
 
     /**
      * Sets the behaviour for comments accompanying properties that
      * are being removed. If <code>true</code>, then when a property
      * is removed, the comment preceding it in the original file is
      * removed also.
      * @param val <code>true</code> if leading comments are to be
      * removed when a property is removed; <code>false</code>
      * otherwise
      */
     public void setRemoveComments(boolean val) {
         removeComments = val;
     }
 
     public void load(InputStream inStream) throws IOException {
         String s = readLines(inStream);
         byte[] ba = s.getBytes(ResourceUtils.ISO_8859_1);
         ByteArrayInputStream bais = new ByteArrayInputStream(ba);
         super.load(bais);
     }
 
     public Object put(Object key, Object value) throws NullPointerException {
         Object obj = super.put(key, value);
         // the above call will have failed if key or value are null
         innerSetProperty(key.toString(), value.toString());
         return obj;
     }
 
     public Object setProperty(String key, String value)
         throws NullPointerException {
         Object obj = super.setProperty(key, value);
         // the above call will have failed if key or value are null
         innerSetProperty(key, value);
         return obj;
     }
 
     /**
      * Store a new key-value pair, or add a new one. The normal
      * functionality is taken care of by the superclass in the call to
      * {@link #setProperty}; this method takes care of this classes
      * extensions.
      * @param key the key of the property to be stored
      * @param value the value to be stored
      */
     private void innerSetProperty(String key, String value) {
         value = escapeValue(value);
 
         if (keyedPairLines.containsKey(key)) {
             Integer i = (Integer) keyedPairLines.get(key);
             Pair p = (Pair) logicalLines.get(i.intValue());
             p.setValue(value);
         } else {
             key = escapeName(key);
             Pair p = new Pair(key, value);
             p.setNew(true);
             keyedPairLines.put(key, new Integer(logicalLines.size()));
             logicalLines.add(p);
         }
     }
 
     public void clear() {
         super.clear();
         keyedPairLines.clear();
         logicalLines.clear();
     }
 
     public Object remove(Object key) {
         Object obj = super.remove(key);
         Integer i = (Integer) keyedPairLines.remove(key);
         if (null != i) {
             if (removeComments) {
                 removeCommentsEndingAt(i.intValue());
             }
             logicalLines.set(i.intValue(), null);
         }
         return obj;
     }
 
     public Object clone() {
         LayoutPreservingProperties dolly =
             (LayoutPreservingProperties) super.clone();
         dolly.keyedPairLines = (HashMap) this.keyedPairLines.clone();
         dolly.logicalLines = (ArrayList) this.logicalLines.clone();
-        for (int j = 0; j < dolly.logicalLines.size(); j++) {
+        final int size = dolly.logicalLines.size();
+        for (int j = 0; j < size; j++) {
             LogicalLine line = (LogicalLine) dolly.logicalLines.get(j);
             if (line instanceof Pair) {
                 Pair p = (Pair) line;
                 dolly.logicalLines.set(j, p.clone());
             }
             // no reason to clone other lines are they are immutable
         }
         return dolly;
     }
 
     /**
      * Echo the lines of the properties (including blanks and comments) to the
      * stream.
      * @param out the stream to write to
      */
     public void listLines(PrintStream out) {
         out.println("-- logical lines --");
         Iterator i = logicalLines.iterator();
         while (i.hasNext()) {
             LogicalLine line = (LogicalLine) i.next();
             if (line instanceof Blank) {
                 out.println("blank:   \"" + line + "\"");
             }
             else if (line instanceof Comment) {
                 out.println("comment: \"" + line + "\"");
             }
             else if (line instanceof Pair) {
                 out.println("pair:    \"" + line + "\"");
             }
         }
     }
 
     /**
      * Save the properties to a file.
      * @param dest the file to write to
      */
     public void saveAs(File dest) throws IOException {
         FileOutputStream fos = new FileOutputStream(dest);
         store(fos, null);
         fos.close();
     }
 
     public void store(OutputStream out, String header) throws IOException {
         OutputStreamWriter osw = new OutputStreamWriter(out, ResourceUtils.ISO_8859_1);
 
         int skipLines = 0;
         int totalLines = logicalLines.size();
 
         if (header != null) {
             osw.write("#" + header + LS);
             if (totalLines > 0
                 && logicalLines.get(0) instanceof Comment
                 && header.equals(logicalLines.get(0).toString().substring(1))) {
                 skipLines = 1;
             }
         }
 
         // we may be updatiung a file written by this class, replace
         // the date comment instead of adding a new one and preserving
         // the one written last time
         if (totalLines > skipLines
             && logicalLines.get(skipLines) instanceof Comment) {
             try {
                 DateUtils.parseDateFromHeader(logicalLines
                                               .get(skipLines)
                                               .toString().substring(1));
                 skipLines++;
             } catch (java.text.ParseException pe) {
                 // not an existing date comment
             }
         }
         osw.write("#" + DateUtils.getDateForHeader() + LS);
 
         boolean writtenSep = false;
         for (Iterator i = logicalLines.subList(skipLines, totalLines).iterator();
              i.hasNext(); ) {
             LogicalLine line = (LogicalLine) i.next();
             if (line instanceof Pair) {
                 if (((Pair)line).isNew()) {
                     if (!writtenSep) {
                         osw.write(LS);
                         writtenSep = true;
                     }
                 }
                 osw.write(line.toString() + LS);
             }
             else if (line != null) {
                 osw.write(line.toString() + LS);
             }
         }
         osw.close();
     }
 
     /**
      * Reads a properties file into an internally maintained
      * collection of logical lines (possibly spanning physcial lines),
      * which make up the comments, blank lines and properties of the
      * file.
      * @param is the stream from which to read the data
      */
     private String readLines(InputStream is) throws IOException {
         InputStreamReader isr = new InputStreamReader(is, ResourceUtils.ISO_8859_1);
         PushbackReader pbr = new PushbackReader(isr, 1);
 
         if (logicalLines.size() > 0) {
             // we add a blank line for spacing
             logicalLines.add(new Blank());
         }
 
         String s = readFirstLine(pbr);
         BufferedReader br = new BufferedReader(pbr);
 
         boolean continuation = false;
         boolean comment = false;
         StringBuffer fileBuffer = new StringBuffer();
         StringBuffer logicalLineBuffer = new StringBuffer();
         while (s != null) {
             fileBuffer.append(s).append(LS);
 
             if (continuation) {
                 // put in the line feed that was removed
                 s = "\n" + s;
             } else {
                 // could be a comment, if first non-whitespace is a # or !
                 comment = s.matches("^( |\t|\f)*(#|!).*");
             }
 
             // continuation if not a comment and the line ends is an
             // odd number of backslashes
             if (!comment) {
                 continuation = requiresContinuation(s);
             }
 
             logicalLineBuffer.append(s);
 
             if (!continuation) {
                 LogicalLine line = null;
                 if (comment) {
                     line = new Comment(logicalLineBuffer.toString());
                 } else if (logicalLineBuffer.toString().trim().length() == 0) {
                     line = new Blank();
                 } else {
                     line = new Pair(logicalLineBuffer.toString());
                     String key = unescape(((Pair)line).getName());
                     if (keyedPairLines.containsKey(key)) {
                         // this key is already present, so we remove it and add
                         // the new one
                         remove(key);
                     }
                     keyedPairLines.put(key, new Integer(logicalLines.size()));
                 }
                 logicalLines.add(line);
                 logicalLineBuffer.setLength(0);
             }
             s = br.readLine();
         }
         return fileBuffer.toString();
     }
 
     /**
      * Reads the first line and determines the EOL-style of the file
      * (relies on the style to be consistent, of course).
      *
      * <p>Sets LS as a side-effect.</p>
      *
      * @return the first line without any line separator, leaves the
      * reader positioned after the first line separator
      *
      * @since Ant 1.8.2
      */
     private String readFirstLine(PushbackReader r) throws IOException {
         StringBuffer sb = new StringBuffer(80);
         int ch = r.read();
         boolean hasCR = false;
         // when reaching EOF before the first EOL, assume native line
         // feeds
         LS = StringUtils.LINE_SEP;
 
         while (ch >= 0) {
             if (hasCR && ch != '\n') {
                 // line feed is sole CR
                 r.unread(ch);
                 break;
             }
 
             if (ch == '\r') {
                 LS = "\r";
                 hasCR = true;
             } else if (ch == '\n') {
                 LS = hasCR ? "\r\n" : "\n";
                 break;
             } else {
                 sb.append((char) ch);
             }
             ch = r.read();
         }
         return sb.toString();
     }
 
     /**
      * Returns <code>true</code> if the line represented by
      * <code>s</code> is to be continued on the next line of the file,
      * or <code>false</code> otherwise.
      * @param s the contents of the line to examine
      * @return <code>true</code> if the line is to be continued,
      * <code>false</code> otherwise
      */
     private boolean requiresContinuation(String s) {
         char[] ca = s.toCharArray();
         int i = ca.length - 1;
         while (i > 0 && ca[i] == '\\') {
             i--;
         }
         // trailing backslashes
         int tb = ca.length - i - 1;
         return tb % 2 == 1;
     }
 
     /**
      * Unescape the string according to the rules for a Properites
      * file, as laid out in the docs for <a
      * href="http://java.sun.com/j2se/1.3/docs/api/java/util/Properties.html">java.util.Properties</a>.
      * @param s the string to unescape (coming from the source file)
      * @return the unescaped string
      */
     private String unescape(String s) {
         /*
          * The following combinations are converted:
          * \n  newline
          * \r  carraige return
          * \f  form feed
          * \t  tab
          * \\  backslash
          * \u0000  unicode character
          * Any other slash is ignored, so
          * \b  becomes 'b'.
          */
 
         char[] ch = new char[s.length() + 1];
         s.getChars(0, s.length(), ch, 0);
         ch[s.length()] = '\n';
         StringBuffer buffy = new StringBuffer(s.length());
         for (int i = 0; i < ch.length; i++) {
             char c = ch[i];
             if (c == '\n') {
                 // we have hit out end-of-string marker
                 break;
             }
             else if (c == '\\') {
                 // possibly an escape sequence
                 c = ch[++i];
                 if (c == 'n')
                     buffy.append('\n');
                 else if (c == 'r')
                     buffy.append('\r');
                 else if (c == 'f')
                     buffy.append('\f');
                 else if (c == 't')
                     buffy.append('\t');
                 else if (c == 'u') {
                     // handle unicode escapes
                     c = unescapeUnicode(ch, i+1);
                     i += 4;
                     buffy.append(c);
                 }
                 else
                     buffy.append(c);
             }
             else {
                 buffy.append(c);
             }
         }
         return buffy.toString();
     }
 
     /**
      * Retrieve the unicode character whose code is listed at position
      * <code>i</code> in the character array <code>ch</code>.
      * @param ch the character array containing the unicode character code
      * @return the character extracted
      */
     private char unescapeUnicode(char[] ch, int i) {
         String s = new String(ch, i, 4);
         return (char) Integer.parseInt(s, 16);
     }
 
     /**
      * Escape the string <code>s</code> according to the rules in the
      * docs for <a
      * href="http://java.sun.com/j2se/1.3/docs/api/java/util/Properties.html">java.util.Properties</a>.
      * @param s the string to escape
      * @return the escaped string
      */
     private String escapeValue(String s) {
         return escape(s, false);
     }
 
     /**
      * Escape the string <code>s</code> according to the rules in the
      * docs for <a
      * href="http://java.sun.com/j2se/1.3/docs/api/java/util/Properties.html">java.util.Properties</a>.
      * This method escapes all the whitespace, not just the stuff at
      * the beginning.
      * @param s the string to escape
      * @return the escaped string
      */
     private String escapeName(String s) {
         return escape(s, true);
     }
 
     /**
      * Escape the string <code>s</code> according to the rules in the
      * docs for <a
      * href="http://java.sun.com/j2se/1.3/docs/api/java/util/Properties.html">java.util.Properties</a>.
      * @param s the string to escape
      * @param escapeAllSpaces if <code>true</code> the method escapes
      * all the spaces, if <code>false</code>, it escapes only the
      * leading whitespace
      * @return the escaped string
      */
     private String escape(String s, boolean escapeAllSpaces) {
         if (s == null) {
             return null;
         }
 
         char[] ch = new char[s.length()];
         s.getChars(0, s.length(), ch, 0);
         String forEscaping = "\t\f\r\n\\:=#!";
         String escaped = "tfrn\\:=#!";
         StringBuffer buffy = new StringBuffer(s.length());
         boolean leadingSpace = true;
         for (int i = 0; i < ch.length; i++) {
             char c = ch[i];
             if (c == ' ') {
                 if (escapeAllSpaces || leadingSpace) {
                     buffy.append("\\");
                 }
             } else {
                 leadingSpace = false;
             }
             int p = forEscaping.indexOf(c);
             if (p != -1) {
                 buffy.append("\\").append(escaped.substring(p,p+1));
             } else if (c < 0x0020 || c > 0x007e) {
                 buffy.append(escapeUnicode(c));
             } else {
                 buffy.append(c);
             }
         }
         return buffy.toString();
     }
 
     /**
      * Return the unicode escape sequence for a character, in the form
      * \u005CuNNNN.
      * @param ch the character to encode
      * @return the unicode escape sequence
      */
     private String escapeUnicode(char ch) {
         return "\\" + UnicodeUtil.EscapeUnicode(ch);
         }
 
     /**
      * Remove the comments in the leading up the {@link logicalLines}
      * list leading up to line <code>pos</code>.
      * @param pos the line number to which the comments lead
      */
     private void removeCommentsEndingAt(int pos) {
         /* We want to remove comments preceding this position. Step
          * back counting blank lines (call this range B1) until we hit
          * something non-blank. If what we hit is not a comment, then
          * exit. If what we hit is a comment, then step back counting
          * comment lines (call this range C1). Nullify lines in C1 and
          * B1.
          */
 
         int end = pos - 1;
 
         // step pos back until it hits something non-blank
         for (pos = end; pos > 0; pos--) {
             if (!(logicalLines.get(pos) instanceof Blank)) {
                 break;
             }
         }
 
         // if the thing it hits is not a comment, then we have nothing
         // to remove
         if (!(logicalLines.get(pos) instanceof Comment)) {
             return;
         }
 
         // step back until we hit the start of the comment
         for (; pos >= 0; pos--) {
             if (!(logicalLines.get(pos) instanceof Comment)) {
                 break;
             }
         }
 
         // now we want to delete from pos+1 to end
         for (pos++ ;pos <= end; pos++) {
             logicalLines.set(pos, null);
         }
     }
 
     /**
      * A logical line of the properties input stream.
      */
     private static abstract class LogicalLine {
         private String text;
 
         public LogicalLine(String text) {
             this.text = text;
         }
 
         public void setText(String text) {
             this.text = text;
         }
 
         public String toString() {
             return text;
         }
     }
 
     /**
      * A blank line of the input stream.
      */
     private static class Blank extends LogicalLine {
         public Blank() {
             super("");
         }
     }
 
     /**
      * A comment line of the input stream.
      */
     private class Comment extends LogicalLine {
         public Comment(String text) {
             super(text);
         }
     }
 
     /**
      * A key-value pair from the input stream. This may span more than
      * one physical line, but it is constitutes as a single logical
      * line.
      */
     private static class Pair extends LogicalLine implements Cloneable {
         private String name;
         private String value;
         private boolean added;
 
         public Pair(String text) {
             super(text);
             parsePair(text);
         }
 
         public Pair(String name, String value) {
             this(name + "=" + value);
         }
 
         public String getName() {
             return name;
         }
 
         public String getValue() {
             return value;
         }
 
         public void setValue(String value) {
             this.value = value;
             setText(name + "=" + value);
         }
 
         public boolean isNew() {
             return added;
         }
 
         public void setNew(boolean val) {
             added = val;
         }
 
         public Object clone() {
             Object dolly = null;
             try {
                 dolly = super.clone();
             }
             catch (CloneNotSupportedException e) {
                 // should be fine
                 e.printStackTrace();
             }
             return dolly;
         }
 
         private void parsePair(String text) {
             // need to find first non-escaped '=', ':', '\t' or ' '.
             int pos = findFirstSeparator(text);
             if (pos == -1) {
                 // trim leading whitespace only
                 name = text;
                 value = null;
             }
             else {
                 name = text.substring(0, pos);
                 value = text.substring(pos+1, text.length());
             }
             // trim leading whitespace only
             name = stripStart(name, " \t\f");
         }
 
         private String stripStart(String s, String chars) {
             if (s == null) {
                 return null;
             }
 
             int i = 0;
             for (;i < s.length(); i++) {
                 if (chars.indexOf(s.charAt(i)) == -1) {
                     break;
                 }
             }
             if (i == s.length()) {
                 return "";
             }
             return s.substring(i);
         }
 
         private int findFirstSeparator(String s) {
             // Replace double backslashes with underscores so that they don't
             // confuse us looking for '\t' or '\=', for example, but they also
             // don't change the position of other characters
             s = s.replaceAll("\\\\\\\\", "__");
 
             // Replace single backslashes followed by separators, so we don't
             // pick them up
             s = s.replaceAll("\\\\=", "__");
             s = s.replaceAll("\\\\:", "__");
             s = s.replaceAll("\\\\ ", "__");
             s = s.replaceAll("\\\\t", "__");
 
             // Now only the unescaped separators are left
             return indexOfAny(s, " :=\t");
         }
 
         private int indexOfAny(String s, String chars) {
             if (s == null || chars == null) {
                 return -1;
             }
 
             int p = s.length() + 1;
             for (int i = 0; i < chars.length(); i++) {
                 int x = s.indexOf(chars.charAt(i));
                 if (x != -1 && x < p) {
                     p = x;
                 }
             }
             if (p == s.length() + 1) {
                 return -1;
             }
             return p;
         }
     }
 }
diff --git a/src/main/org/apache/tools/mail/MailMessage.java b/src/main/org/apache/tools/mail/MailMessage.java
index ea64f36b0..882ca4779 100644
--- a/src/main/org/apache/tools/mail/MailMessage.java
+++ b/src/main/org/apache/tools/mail/MailMessage.java
@@ -1,525 +1,526 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 /*
  * The original version of this class was donated by Jason Hunter,
  * who wrote the class as part of the com.oreilly.servlet
  * package for his book "Java Servlet Programming" (O'Reilly).
  * See http://www.servlets.com.
  *
  */
 
 package org.apache.tools.mail;
 
 import java.io.IOException;
 import java.io.PrintStream;
 import java.io.BufferedOutputStream;
 import java.io.OutputStream;
 import java.net.Socket;
 import java.net.InetAddress;
 import java.util.Vector;
 import java.util.Enumeration;
 
 /**
  * A class to help send SMTP email.
  * This class is an improvement on the sun.net.smtp.SmtpClient class
  * found in the JDK.  This version has extra functionality, and can be used
  * with JVMs that did not extend from the JDK.  It's not as robust as
  * the JavaMail Standard Extension classes, but it's easier to use and
  * easier to install, and has an Open Source license.
  * <p>
  * It can be used like this:
  * <blockquote><pre>
  * String mailhost = "localhost";  // or another mail host
  * String from = "Mail Message Servlet &lt;MailMessage@server.com&gt;";
  * String to = "to@you.com";
  * String cc1 = "cc1@you.com";
  * String cc2 = "cc2@you.com";
  * String bcc = "bcc@you.com";
  * &nbsp;
  * MailMessage msg = new MailMessage(mailhost);
  * msg.setPort(25);
  * msg.from(from);
  * msg.to(to);
  * msg.cc(cc1);
  * msg.cc(cc2);
  * msg.bcc(bcc);
  * msg.setSubject("Test subject");
  * PrintStream out = msg.getPrintStream();
  * &nbsp;
  * Enumeration enum = req.getParameterNames();
  * while (enum.hasMoreElements()) {
  *   String name = (String)enum.nextElement();
  *   String value = req.getParameter(name);
  *   out.println(name + " = " + value);
  * }
  * &nbsp;
  * msg.sendAndClose();
  * </pre></blockquote>
  * <p>
  * Be sure to set the from address, then set the recepient
  * addresses, then set the subject and other headers, then get the
  * PrintStream, then write the message, and finally send and close.
  * The class does minimal error checking internally; it counts on the mail
  * host to complain if there's any malformatted input or out of order
  * execution.
  * <p>
  * An attachment mechanism based on RFC 1521 could be implemented on top of
  * this class.  In the meanwhile, JavaMail is the best solution for sending
  * email with attachments.
  * <p>
  * Still to do:
  * <ul>
  * <li>Figure out how to close the connection in case of error
  * </ul>
  *
  * @version 1.1, 2000/03/19, added angle brackets to address, helps some servers
  * version 1.0, 1999/12/29
  */
 public class MailMessage {
 
     /** default mailhost */
     public static final String DEFAULT_HOST = "localhost";
 
     /** default port for SMTP: 25 */
     public static final int DEFAULT_PORT = 25;
 
     /** host name for the mail server */
     private String host;
 
     /** host port for the mail server */
     private int port = DEFAULT_PORT;
 
     /** sender email address */
     private String from;
 
     /** list of email addresses to reply to */
     private Vector replyto;
 
     /** list of email addresses to send to */
     private Vector to;
 
     /** list of email addresses to cc to */
     private Vector cc;
 
     /** headers to send in the mail */
     private Vector headersKeys;
     private Vector headersValues;
 
     private MailPrintStream out;
 
     private SmtpResponseReader in;
 
     private Socket socket;
     private static final int OK_READY = 220;
     private static final int OK_HELO = 250;
     private static final int OK_FROM = 250;
     private static final int OK_RCPT_1 = 250;
     private static final int OK_RCPT_2 = 251;
     private static final int OK_DATA = 354;
     private static final int OK_DOT = 250;
     private static final int OK_QUIT = 221;
 
   /**
    * Constructs a new MailMessage to send an email.
    * Use localhost as the mail server with port 25.
    *
    * @exception IOException if there's any problem contacting the mail server
    */
   public MailMessage() throws IOException {
     this(DEFAULT_HOST, DEFAULT_PORT);
   }
 
   /**
    * Constructs a new MailMessage to send an email.
    * Use the given host as the mail server with port 25.
    *
    * @param host the mail server to use
    * @exception IOException if there's any problem contacting the mail server
    */
   public MailMessage(String host) throws IOException {
     this(host, DEFAULT_PORT);
   }
 
   /**
    * Constructs a new MailMessage to send an email.
    * Use the given host and port as the mail server.
    *
    * @param host the mail server to use
    * @param port the port to connect to
    * @exception IOException if there's any problem contacting the mail server
    */
   public MailMessage(String host, int port) throws IOException {
     this.port = port;
     this.host = host;
     replyto = new Vector();
     to = new Vector();
     cc = new Vector();
     headersKeys = new Vector();
     headersValues = new Vector();
     connect();
     sendHelo();
   }
 
     /**
      * Set the port to connect to the SMTP host.
      * @param port the port to use for connection.
      * @see #DEFAULT_PORT
      */
     public void setPort(int port) {
         this.port = port;
     }
 
     /**
      * Sets the from address.  Also sets the "From" header.  This method should
      * be called only once.
      * @param from the from address
      * @exception IOException if there's any problem reported by the mail server
      */
     public void from(String from) throws IOException {
         sendFrom(from);
         this.from = from;
     }
 
     /**
      * Sets the replyto address
      * This method may be
      * called multiple times.
      * @param rto the replyto address
      *
      */
     public void replyto(String rto) {
       this.replyto.addElement(rto);
     }
 
   /**
    * Sets the to address.  Also sets the "To" header.  This method may be
    * called multiple times.
    *
    * @param to the to address
    * @exception IOException if there's any problem reported by the mail server
    */
   public void to(String to) throws IOException {
     sendRcpt(to);
     this.to.addElement(to);
   }
 
   /**
    * Sets the cc address.  Also sets the "Cc" header.  This method may be
    * called multiple times.
    *
    * @param cc the cc address
    * @exception IOException if there's any problem reported by the mail server
    */
   public void cc(String cc) throws IOException {
     sendRcpt(cc);
     this.cc.addElement(cc);
   }
 
   /**
    * Sets the bcc address.  Does NOT set any header since it's a *blind* copy.
    * This method may be called multiple times.
    *
    * @param bcc the bcc address
    * @exception IOException if there's any problem reported by the mail server
    */
   public void bcc(String bcc) throws IOException {
     sendRcpt(bcc);
     // No need to keep track of Bcc'd addresses
   }
 
   /**
    * Sets the subject of the mail message.  Actually sets the "Subject"
    * header.
    * @param subj the subject of the mail message
    */
   public void setSubject(String subj) {
     setHeader("Subject", subj);
   }
 
   /**
    * Sets the named header to the given value.  RFC 822 provides the rules for
    * what text may constitute a header name and value.
    * @param name name of the header
    * @param value contents of the header
    */
   public void setHeader(String name, String value) {
     // Blindly trust the user doesn't set any invalid headers
     headersKeys.add(name);
     headersValues.add(value);
   }
 
   /**
    * Returns a PrintStream that can be used to write the body of the message.
    * A stream is used since email bodies are byte-oriented.  A writer can
    * be wrapped on top if necessary for internationalization.
    * This is actually done in Message.java
    *
    * @return a printstream containing the data and the headers of the email
    * @exception IOException if there's any problem reported by the mail server
    * @see org.apache.tools.ant.taskdefs.email.Message
    */
   public PrintStream getPrintStream() throws IOException {
     setFromHeader();
     setReplyToHeader();
     setToHeader();
     setCcHeader();
     setHeader("X-Mailer", "org.apache.tools.mail.MailMessage (ant.apache.org)");
     sendData();
     flushHeaders();
     return out;
   }
 
 
   // RFC 822 s4.1: "From:" header must be sent
   // We rely on error checking by the MTA
   void setFromHeader() {
     setHeader("From", from);
   }
 
   // RFC 822 s4.1: "Reply-To:" header is optional
   void setReplyToHeader() {
     if (!replyto.isEmpty()) {
       setHeader("Reply-To", vectorToList(replyto));
     }
   }
 
   void setToHeader() {
     if (!to.isEmpty()) {
       setHeader("To", vectorToList(to));
     }
   }
 
   void setCcHeader() {
     if (!cc.isEmpty()) {
       setHeader("Cc", vectorToList(cc));
     }
   }
 
   String vectorToList(Vector v) {
     StringBuffer buf = new StringBuffer();
     Enumeration e = v.elements();
     while (e.hasMoreElements()) {
       buf.append(e.nextElement());
       if (e.hasMoreElements()) {
         buf.append(", ");
       }
     }
     return buf.toString();
   }
 
   void flushHeaders() throws IOException {
     // RFC 822 s4.1:
     //   "Header fields are NOT required to occur in any particular order,
     //    except that the message body MUST occur AFTER the headers"
     // (the same section specifies a reccommended order, which we ignore)
-   for (int i = 0; i < headersKeys.size(); i++) {
+   final int size = headersKeys.size();
+   for (int i = 0; i < size; i++) {
       String name = (String) headersKeys.elementAt(i);
       String value = (String) headersValues.elementAt(i);
       out.println(name + ": " + value);
     }
     out.println();
     out.flush();
   }
 
   /**
    * Sends the message and closes the connection to the server.
    * The MailMessage object cannot be reused.
    *
    * @exception IOException if there's any problem reported by the mail server
    */
   public void sendAndClose() throws IOException {
       try {
           sendDot();
           sendQuit();
       } finally {
           disconnect();
       }
   }
 
   // Make a limited attempt to extract a sanitized email address
   // Prefer text in <brackets>, ignore anything in (parentheses)
   static String sanitizeAddress(String s) {
     int paramDepth = 0;
     int start = 0;
     int end = 0;
     int len = s.length();
 
     for (int i = 0; i < len; i++) {
       char c = s.charAt(i);
       if (c == '(') {
         paramDepth++;
         if (start == 0) {
           end = i;  // support "address (name)"
         }
       } else if (c == ')') {
         paramDepth--;
         if (end == 0) {
           start = i + 1;  // support "(name) address"
         }
       } else if (paramDepth == 0 && c == '<') {
         start = i + 1;
       } else if (paramDepth == 0 && c == '>') {
         end = i;
       }
     }
 
     if (end == 0) {
       end = len;
     }
 
     return s.substring(start, end);
   }
 
   // * * * * * Raw protocol methods below here * * * * *
 
   void connect() throws IOException {
     socket = new Socket(host, port);
     out = new MailPrintStream(
           new BufferedOutputStream(
           socket.getOutputStream()));
     in = new SmtpResponseReader(socket.getInputStream());
     getReady();
   }
 
   void getReady() throws IOException {
     String response = in.getResponse();
     int[] ok = {OK_READY};
     if (!isResponseOK(response, ok)) {
       throw new IOException(
         "Didn't get introduction from server: " + response);
     }
   }
   void sendHelo() throws IOException {
     String local = InetAddress.getLocalHost().getHostName();
     int[] ok = {OK_HELO};
     send("HELO " + local, ok);
   }
   void sendFrom(String from) throws IOException {
     int[] ok = {OK_FROM};
     send("MAIL FROM: " + "<" + sanitizeAddress(from) + ">", ok);
   }
   void sendRcpt(String rcpt) throws IOException {
     int[] ok = {OK_RCPT_1, OK_RCPT_2};
     send("RCPT TO: " + "<" + sanitizeAddress(rcpt) + ">", ok);
   }
 
   void sendData() throws IOException {
     int[] ok = {OK_DATA};
     send("DATA", ok);
   }
 
   void sendDot() throws IOException {
     int[] ok = {OK_DOT};
     send("\r\n.", ok);  // make sure dot is on new line
   }
 
     void sendQuit() throws IOException {
         int[] ok = {OK_QUIT};
         try {
             send("QUIT", ok);
         } catch (IOException e) {
             throw new ErrorInQuitException(e);
         }
     }
 
     void send(String msg, int[] ok) throws IOException {
         out.rawPrint(msg + "\r\n");  // raw supports <CRLF>.<CRLF>
         String response = in.getResponse();
         if (!isResponseOK(response, ok)) {
             throw new IOException("Unexpected reply to command: "
                                   + msg + ": " + response);
         }
     }
 
   boolean isResponseOK(String response, int[] ok) {
     // Check that the response is one of the valid codes
     for (int i = 0; i < ok.length; i++) {
       if (response.startsWith("" + ok[i])) {
         return true;
       }
     }
     return false;
   }
 
     void disconnect() throws IOException {
         if (out != null) {
             out.close();
         }
         if (in != null) {
             try {
                 in.close();
             } catch (IOException e) {
                 // ignore
             }
         }
         if (socket != null) {
             try {
                 socket.close();
             } catch (IOException e) {
                 // ignore
             }
         }
     }
 }
 
 /**
  * This PrintStream subclass makes sure that <CRLF>. becomes <CRLF>..
  *  per RFC 821.  It also ensures that new lines are always \r\n.
 */
 class MailPrintStream extends PrintStream {
 
   private int lastChar;
 
   public MailPrintStream(OutputStream out) {
     super(out, true);  // deprecated, but email is byte-oriented
   }
 
   // Mac does \n\r, but that's tough to distinguish from Windows \r\n\r\n.
   // Don't tackle that problem right now.
   public void write(int b) {
     if (b == '\n' && lastChar != '\r') {
       rawWrite('\r');  // ensure always \r\n
       rawWrite(b);
     } else if (b == '.' && lastChar == '\n') {
       rawWrite('.');  // add extra dot
       rawWrite(b);
     } else {
       rawWrite(b);
     }
     lastChar = b;
   }
 
   public void write(byte[] buf, int off, int len) {
     for (int i = 0; i < len; i++) {
       write(buf[off + i]);
     }
   }
 
   void rawWrite(int b) {
     super.write(b);
   }
 
   void rawPrint(String s) {
     int len = s.length();
     for (int i = 0; i < len; i++) {
       rawWrite(s.charAt(i));
     }
   }
 }
 
