diff --git a/hibernate-core/src/main/java/org/hibernate/SessionFactory.java b/hibernate-core/src/main/java/org/hibernate/SessionFactory.java
index c9eef9b1b1..8bc6690ea9 100644
--- a/hibernate-core/src/main/java/org/hibernate/SessionFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/SessionFactory.java
@@ -1,392 +1,393 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
 package org.hibernate;
+
+import javax.naming.Referenceable;
 import java.io.Serializable;
 import java.sql.Connection;
 import java.util.Map;
 import java.util.Set;
-import javax.naming.Referenceable;
+
 import org.hibernate.engine.FilterDefinition;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.metadata.CollectionMetadata;
 import org.hibernate.stat.Statistics;
 
 /**
  * The main contract here is the creation of {@link Session} instances.  Usually
  * an application has a single {@link SessionFactory} instance and threads
  * servicing client requests obtain {@link Session} instances from this factory.
  * <p/>
  * The internal state of a {@link SessionFactory} is immutable.  Once it is created
  * this internal state is set.  This internal state includes all of the metadata
  * about Object/Relational Mapping.
  * <p/>
  * Implementors <strong>must</strong> be threadsafe.
  *
  * @see org.hibernate.cfg.Configuration
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public interface SessionFactory extends Referenceable, Serializable {
 	/**
 	 * Open a {@link Session}.
 	 * <p/>
 	 * JDBC {@link Connection connection(s} will be obtained from the
 	 * configured {@link org.hibernate.service.jdbc.connections.spi.ConnectionProvider} as needed
 	 * to perform requested work.
 	 *
 	 * @return The created session.
 	 *
 	 * @throws HibernateException Indicates a peroblem opening the session; pretty rare here.
 	 */
-	public org.hibernate.classic.Session openSession() throws HibernateException;
+	public Session openSession() throws HibernateException;
 
 	/**
 	 * Open a {@link Session}, utilizing the specified {@link Interceptor}.
 	 * <p/>
 	 * JDBC {@link Connection connection(s} will be obtained from the
 	 * configured {@link org.hibernate.service.jdbc.connections.spi.ConnectionProvider} as needed
 	 * to perform requested work.
 	 *
 	 * @param interceptor a session-scoped interceptor
 	 *
 	 * @return The created session.
 	 *
 	 * @throws HibernateException Indicates a peroblem opening the session; pretty rare here.
 	 */
-	public org.hibernate.classic.Session openSession(Interceptor interceptor) throws HibernateException;
+	public Session openSession(Interceptor interceptor) throws HibernateException;
 
 	/**
 	 * Open a {@link Session}, utilizing the specfied JDBC {@link Connection}.
 	 * <p>
 	 * Note that the second-level cache will be disabled if you supply a JDBC
 	 * connection. Hibernate will not be able to track any statements you might
 	 * have executed in the same transaction.  Consider implementing your own
 	 * {@link org.hibernate.service.jdbc.connections.spi.ConnectionProvider} instead as a highly
 	 * recommended alternative.
 	 *
 	 * @param connection a connection provided by the application.
 	 *
 	 * @return The created session.
 	 */
-	public org.hibernate.classic.Session openSession(Connection connection);
+	public Session openSession(Connection connection);
 
 	/**
 	 * Open a {@link Session}, utilizing the specfied JDBC {@link Connection} and
 	 * specified {@link Interceptor}.
 	 * <p>
 	 * Note that the second-level cache will be disabled if you supply a JDBC
 	 * connection. Hibernate will not be able to track any statements you might
 	 * have executed in the same transaction.  Consider implementing your own
 	 * {@link org.hibernate.service.jdbc.connections.spi.ConnectionProvider} instead as a highly
 	 * recommended alternative.
 	 *
 	 * @param connection a connection provided by the application.
 	 * @param interceptor a session-scoped interceptor
 	 *
 	 * @return The created session.
 	 */
-	public org.hibernate.classic.Session openSession(Connection connection, Interceptor interceptor);
+	public Session openSession(Connection connection, Interceptor interceptor);
 
 	/**
 	 * Obtains the current session.  The definition of what exactly "current"
 	 * means controlled by the {@link org.hibernate.context.CurrentSessionContext} impl configured
 	 * for use.
 	 * <p/>
 	 * Note that for backwards compatibility, if a {@link org.hibernate.context.CurrentSessionContext}
 	 * is not configured but JTA is configured this will default to the {@link org.hibernate.context.JTASessionContext}
 	 * impl.
 	 *
 	 * @return The current session.
 	 *
 	 * @throws HibernateException Indicates an issue locating a suitable current session.
 	 */
-	public org.hibernate.classic.Session getCurrentSession() throws HibernateException;
+	public Session getCurrentSession() throws HibernateException;
 
 	/**
 	 * Open a new stateless session.
 	 *
 	 * @return The created stateless session.
 	 */
 	public StatelessSession openStatelessSession();
 
 	/**
 	 * Open a new stateless session, utilizing the specified JDBC
 	 * {@link Connection}.
 	 *
 	 * @param connection Connection provided by the application.
 	 *
 	 * @return The created stateless session.
 	 */
 	public StatelessSession openStatelessSession(Connection connection);
 
 	/**
 	 * Retrieve the {@link ClassMetadata} associated with the given entity class.
 	 *
 	 * @param entityClass The entity class
 	 *
 	 * @return The metadata associated with the given entity; may be null if no such
 	 * entity was mapped.
 	 *
 	 * @throws HibernateException Generally null is returned instead of throwing.
 	 */
 	public ClassMetadata getClassMetadata(Class entityClass);
 
 	/**
 	 * Retrieve the {@link ClassMetadata} associated with the given entity class.
 	 *
 	 * @param entityName The entity class
 	 *
 	 * @return The metadata associated with the given entity; may be null if no such
 	 * entity was mapped.
 	 *
 	 * @throws HibernateException Generally null is returned instead of throwing.
 	 * @since 3.0
 	 */
 	public ClassMetadata getClassMetadata(String entityName);
 
 	/**
 	 * Get the {@link CollectionMetadata} associated with the named collection role.
 	 *
 	 * @param roleName The collection role (in form [owning-entity-name].[collection-property-name]).
 	 *
 	 * @return The metadata associated with the given collection; may be null if no such
 	 * collection was mapped.
 	 *
 	 * @throws HibernateException Generally null is returned instead of throwing.
 	 */
 	public CollectionMetadata getCollectionMetadata(String roleName);
 
 	/**
 	 * Retrieve the {@link ClassMetadata} for all mapped entities.
 	 *
 	 * @return A map containing all {@link ClassMetadata} keyed by the
 	 * corresponding {@link String} entity-name.
 	 *
 	 * @throws HibernateException Generally empty map is returned instead of throwing.
 	 *
 	 * @since 3.0 changed key from {@link Class} to {@link String}.
 	 */
 	public Map<String,ClassMetadata> getAllClassMetadata();
 
 	/**
 	 * Get the {@link CollectionMetadata} for all mapped collections
 	 *
 	 * @return a map from <tt>String</tt> to <tt>CollectionMetadata</tt>
 	 *
 	 * @throws HibernateException Generally empty map is returned instead of throwing.
 	 */
 	public Map getAllCollectionMetadata();
 
 	/**
 	 * Retrieve the statistics fopr this factory.
 	 *
 	 * @return The statistics.
 	 */
 	public Statistics getStatistics();
 
 	/**
 	 * Destroy this <tt>SessionFactory</tt> and release all resources (caches,
 	 * connection pools, etc).
 	 * <p/>
 	 * It is the responsibility of the application to ensure that there are no
 	 * open {@link Session sessions} before calling this method as the impact
 	 * on those {@link Session sessions} is indeterminate.
 	 * <p/>
 	 * No-ops if already {@link #isClosed closed}.
 	 *
 	 * @throws HibernateException Indicates an issue closing the factory.
 	 */
 	public void close() throws HibernateException;
 
 	/**
 	 * Is this factory already closed?
 	 *
 	 * @return True if this factory is already closed; false otherwise.
 	 */
 	public boolean isClosed();
 
 	/**
 	 * Obtain direct access to the underlying cache regions.
 	 *
 	 * @return The direct cache access API.
 	 */
 	public Cache getCache();
 
 	/**
 	 * Evict all entries from the second-level cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param persistentClass The entity class for which to evict data.
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'persisttentClass' did not name a mapped entity or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evict(Class persistentClass) throws HibernateException;
 
 	/**
 	 * Evict an entry from the second-level  cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param persistentClass The entity class for which to evict data.
 	 * @param id The entity id
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'persisttentClass' did not name a mapped entity or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#containsEntity(Class, Serializable)} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evict(Class persistentClass, Serializable id) throws HibernateException;
 
 	/**
 	 * Evict all entries from the second-level cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param entityName The entity name for which to evict data.
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'persisttentClass' did not name a mapped entity or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evictEntity(String entityName) throws HibernateException;
 
 	/**
 	 * Evict an entry from the second-level  cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param entityName The entity name for which to evict data.
 	 * @param id The entity id
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'persisttentClass' did not name a mapped entity or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evictEntity(String entityName, Serializable id) throws HibernateException;
 
 	/**
 	 * Evict all entries from the second-level cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param roleName The name of the collection role whose regions should be evicted
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'roleName' did not name a mapped collection or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evictCollection(String roleName) throws HibernateException;
 
 	/**
 	 * Evict an entry from the second-level cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param roleName The name of the collection role
 	 * @param id The id of the collection owner
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'roleName' did not name a mapped collection or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evictCollection(String roleName, Serializable id) throws HibernateException;
 
 	/**
 	 * Evict any query result sets cached in the named query cache region.
 	 *
 	 * @param cacheRegion The named query cache region from which to evict.
 	 *
 	 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,
 	 * this should indicate a problem communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evictQueries(String cacheRegion) throws HibernateException;
 
 	/**
 	 * Evict any query result sets cached in the default query cache region.
 	 *
 	 * @throws HibernateException Indicate a problem communicating with
 	 * underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictQueryRegions} accessed through
 	 * {@link #getCache()} instead.
 	 */
 	public void evictQueries() throws HibernateException;
 
 	/**
 	 * Obtain a set of the names of all filters defined on this SessionFactory.
 	 *
 	 * @return The set of filter names.
 	 */
 	public Set getDefinedFilterNames();
 
 	/**
 	 * Obtain the definition of a filter by name.
 	 *
 	 * @param filterName The name of the filter for which to obtain the definition.
 	 * @return The filter definition.
 	 * @throws HibernateException If no filter defined with the given name.
 	 */
 	public FilterDefinition getFilterDefinition(String filterName) throws HibernateException;
 
 	/**
 	 * Determine if this session factory contains a fetch profile definition
 	 * registered under the given name.
 	 *
 	 * @param name The name to check
 	 * @return True if there is such a fetch profile; false otherwise.
 	 */
 	public boolean containsFetchProfileDefinition(String name);
 
 	/**
 	 * Retrieve this factory's {@link TypeHelper}
 	 *
 	 * @return The factory's {@link TypeHelper}
 	 */
 	public TypeHelper getTypeHelper();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/classic/Session.java b/hibernate-core/src/main/java/org/hibernate/classic/Session.java
deleted file mode 100755
index 77a1613126..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/classic/Session.java
+++ /dev/null
@@ -1,383 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.classic;
-import java.io.Serializable;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import org.hibernate.HibernateException;
-import org.hibernate.Query;
-import org.hibernate.type.Type;
-
-/**
- * An extension of the <tt>Session</tt> API, including all
- * deprecated methods from Hibernate2. This interface is
- * provided to allow easier migration of existing applications.
- * New code should use <tt>org.hibernate.Session</tt>.
- * @author Gavin King
- */
-public interface Session extends org.hibernate.Session {
-
-	/**
-	 * Copy the state of the given object onto the persistent object with the same
-	 * identifier. If there is no persistent instance currently associated with
-	 * the session, it will be loaded. Return the persistent instance. If the
-	 * given instance is unsaved or does not exist in the database, save it and
-	 * return it as a newly persistent instance. Otherwise, the given instance
-	 * does not become associated with the session.
-	 *
-	 * @deprecated use {@link org.hibernate.Session#merge(Object)}
-	 *
-	 * @param object a transient instance with state to be copied
-	 * @return an updated persistent instance
-	 */
-	public Object saveOrUpdateCopy(Object object) throws HibernateException;
-
-	/**
-	 * Copy the state of the given object onto the persistent object with the
-	 * given identifier. If there is no persistent instance currently associated
-	 * with the session, it will be loaded. Return the persistent instance. If
-	 * there is no database row with the given identifier, save the given instance
-	 * and return it as a newly persistent instance. Otherwise, the given instance
-	 * does not become associated with the session.
-	 *
-	 * @deprecated with no replacement
-	 *
-	 * @param object a persistent or transient instance with state to be copied
-	 * @param id the identifier of the instance to copy to
-	 * @return an updated persistent instance
-	 */
-	public Object saveOrUpdateCopy(Object object, Serializable id) throws HibernateException;
-
-	/**
-	 * Copy the state of the given object onto the persistent object with the same
-	 * identifier. If there is no persistent instance currently associated with
-	 * the session, it will be loaded. Return the persistent instance. If the
-	 * given instance is unsaved or does not exist in the database, save it and
-	 * return it as a newly persistent instance. Otherwise, the given instance
-	 * does not become associated with the session.
-	 *
-	 * @deprecated use {@link org.hibernate.Session#merge(String, Object)}
-	 *
-	 * @param object a transient instance with state to be copied
-	 * @return an updated persistent instance
-	 */
-	public Object saveOrUpdateCopy(String entityName, Object object) throws HibernateException;
-
-	/**
-	 * Copy the state of the given object onto the persistent object with the
-	 * given identifier. If there is no persistent instance currently associated
-	 * with the session, it will be loaded. Return the persistent instance. If
-	 * there is no database row with the given identifier, save the given instance
-	 * and return it as a newly persistent instance. Otherwise, the given instance
-	 * does not become associated with the session.
-	 *
-	 * @deprecated with no replacement
-	 *
-	 * @param object a persistent or transient instance with state to be copied
-	 * @param id the identifier of the instance to copy to
-	 * @return an updated persistent instance
-	 */
-	public Object saveOrUpdateCopy(String entityName, Object object, Serializable id) throws HibernateException;
-
-	/**
-	 * Execute a query.
-	 *
-	 * @deprecated use {@link #createQuery}.{@link Query#list()}
-	 *
-	 * @param query a query expressed in Hibernate's query language
-	 * @return a distinct list of instances (or arrays of instances)
-	 * @throws HibernateException
-	 */
-	public List find(String query) throws HibernateException;
-			
-	/**
-	 * Execute a query with bind parameters, binding a value to a "?" parameter
-	 * in the query string.
-	 *
-	 * @deprecated use {@link #createQuery}.setXYZ.{@link Query#list()}
-	 *
-	 * @param query the query string
-	 * @param value a value to be bound to a "?" placeholder (JDBC IN parameter).
-	 * @param type the Hibernate type of the value
-	 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
-	 * @return a distinct list of instances (or arrays of instances)
-	 * @throws HibernateException
-	 */
-	public List find(String query, Object value, Type type) throws HibernateException;
-	
-	/**
-	 * Execute a query with bind parameters, binding an array of values to "?"
-	 * parameters in the query string.
-	 *
-	 * @deprecated use {@link #createQuery}.setXYZ.{@link Query#list()}
-	 *
-	 * @param query the query string
-	 * @param values an array of values to be bound to the "?" placeholders (JDBC IN parameters).
-	 * @param types an array of Hibernate types of the values
-	 * @see org.hibernate.Hibernate for access to <tt>Type</tt> instances
-	 * @return a distinct list of instances
-	 * @throws HibernateException
-	 */
-	public List find(String query, Object[] values, Type[] types) throws HibernateException;
-	
-	/**
-	 * Execute a query and return the results in an iterator. If the query has multiple
-	 * return values, values will be returned in an array of type <tt>Object[].</tt><br>
-	 * <br>
-	 * Entities returned as results are initialized on demand. The first SQL query returns
-	 * identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve
-	 * objects than <tt>find()</tt>.
-	 * 
-	 * @deprecated use {@link #createQuery}.{@link Query#iterate}
-	 *
-	 * @param query the query string
-	 * @return an iterator
-	 * @throws HibernateException
-	 */
-	public Iterator iterate(String query) throws HibernateException;
-	
-	/**
-	 * Execute a query and return the results in an iterator. Write the given value to "?"
-	 * in the query string. If the query has multiple return values, values will be returned
-	 * in an array of type <tt>Object[]</tt>.<br>
-	 * <br>
-	 * Entities returned as results are initialized on demand. The first SQL query returns
-	 * identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve
-	 * objects than <tt>find()</tt>.
-	 *
-	 * @deprecated use {@link #createQuery}.setXYZ.{@link Query#iterate}
-	 *
-	 * @param query the query string
-	 * @param value a value to be witten to a "?" placeholder in the query string
-	 * @param type the hibernate type of value
-	 * @return an iterator
-	 * @throws HibernateException
-	 */
-	public Iterator iterate(String query, Object value, Type type) throws HibernateException;
-	
-	/**
-	 * Execute a query and return the results in an iterator. Write the given values to "?"
-	 * in the query string. If the query has multiple return values, values will be returned
-	 * in an array of type <tt>Object[]</tt>.<br>
-	 * <br>
-	 * Entities returned as results are initialized on demand. The first SQL query returns
-	 * identifiers only. So <tt>iterate()</tt> is usually a less efficient way to retrieve
-	 * objects than <tt>find()</tt>.
-	 *
-	 * @deprecated use {@link #createQuery}.setXYZ.{@link Query#iterate}
-	 *
-	 * @param query the query string
-	 * @param values a list of values to be written to "?" placeholders in the query
-	 * @param types a list of Hibernate types of the values
-	 * @return an iterator
-	 * @throws HibernateException
-	 */
-	public Iterator iterate(String query, Object[] values, Type[] types) throws HibernateException;
-	
-	/**
-	 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to
-	 * <tt>this</tt>, the collection element. Filters allow efficient access to very large lazy
-	 * collections. (Executing the filter does not initialize the collection.)
-	 * 
-	 * @deprecated use {@link #createFilter(Object, String)}.{@link Query#list}
-	 *
-	 * @param collection a persistent collection to filter
-	 * @param filter a filter query string
-	 * @return Collection the resulting collection
-	 * @throws HibernateException
-	 */
-	public Collection filter(Object collection, String filter) throws HibernateException;
-	
-	/**
-	 * Apply a filter to a persistent collection. A filter is a Hibernate query that may refer to
-	 * <tt>this</tt>, the collection element.
-	 *
-	 * @deprecated use {@link #createFilter(Object, String)}.setXYZ.{@link Query#list}
-	 *
-	 * @param collection a persistent collection to filter
-	 * @param filter a filter query string
-	 * @param value a value to be witten to a "?" placeholder in the query string
-	 * @param type the hibernate type of value
-	 * @return Collection
-	 * @throws HibernateException
-	 */
-	public Collection filter(Object collection, String filter, Object value, Type type) throws HibernateException;
-	
-	/**
-	 * Apply a filter to a persistent collection.
-	 *
-	 * Bind the given parameters to "?" placeholders. A filter is a Hibernate query that
-	 * may refer to <tt>this</tt>, the collection element.
-	 *
-	 * @deprecated use {@link #createFilter(Object, String)}.setXYZ.{@link Query#list}
-	 *
-	 * @param collection a persistent collection to filter
-	 * @param filter a filter query string
-	 * @param values a list of values to be written to "?" placeholders in the query
-	 * @param types a list of Hibernate types of the values
-	 * @return Collection
-	 * @throws HibernateException
-	 */
-	public Collection filter(Object collection, String filter, Object[] values, Type[] types) throws HibernateException;
-	
-	/**
-	 * Delete all objects returned by the query. Return the number of objects deleted.
-	 * <p/>
-	 * Note that this is very different from the delete-statement support added in HQL
-	 * since 3.1.  The functionality here is to actually peform the query and then iterate
-	 * the results calling {@link #delete(Object)} individually.
-	 * 
-	 * @deprecated consider using HQL delete statements
-	 *
-	 * @param query the query string
-	 * @return the number of instances deleted
-	 * @throws HibernateException
-	 */
-	public int delete(String query) throws HibernateException;
-	
-	/**
-	 * Delete all objects returned by the query. Return the number of objects deleted.
-	 * <p/>
-	 * Note that this is very different from the delete-statement support added in HQL
-	 * since 3.1.  The functionality here is to actually peform the query and then iterate
-	 * the results calling {@link #delete(Object)} individually.
-	 *
-	 * @deprecated consider using HQL delete statements
-	 *
-	 * @param query the query string
-	 * @param value a value to be witten to a "?" placeholder in the query string.
-	 * @param type the hibernate type of value.
-	 * @return the number of instances deleted
-	 * @throws HibernateException
-	 */
-	public int delete(String query, Object value, Type type) throws HibernateException;
-	
-	/**
-	 * Delete all objects returned by the query. Return the number of objects deleted.
-	 * <p/>
-	 * Note that this is very different from the delete-statement support added in HQL
-	 * since 3.1.  The functionality here is to actually peform the query and then iterate
-	 * the results calling {@link #delete(Object)} individually.
-	 *
-	 * @deprecated consider using HQL delete statements
-	 *
-	 * @param query the query string
-	 * @param values a list of values to be written to "?" placeholders in the query.
-	 * @param types a list of Hibernate types of the values
-	 * @return the number of instances deleted
-	 * @throws HibernateException
-	 */
-	public int delete(String query, Object[] values, Type[] types) throws HibernateException;
-
-
-	/**
-	 * Create a new instance of <tt>Query</tt> for the given SQL string.
-	 * <p/>
-	 * Returned instances should all be {@link org.hibernate.SQLQuery}.
-	 *
-	 * @param sql a query expressed in SQL
-	 * @param returnAlias a table alias that appears inside <tt>{}</tt> in the SQL string
-	 * @param returnClass the returned persistent class
-	 *
-	 * @deprecated use {@link org.hibernate.SQLQuery#addRoot} or {@link org.hibernate.SQLQuery#addEntity} variants
-	 * instead to define the alias/class
-	 */
-	@Deprecated
-	@SuppressWarnings({ "JavaDoc" })
-	public Query createSQLQuery(String sql, String returnAlias, Class returnClass);
-	
-	/**
-	 * Create a new instance of <tt>Query</tt> for the given SQL string.
-	 * <p/>
-	 * Returned instances should all be {@link org.hibernate.SQLQuery}.
-	 *
-	 * @param sql a query expressed in SQL
-	 * @param returnAliases an array of table aliases that appear inside <tt>{}</tt> in the SQL string
-	 * @param returnClasses the returned persistent classes
-	 *
-	 * @deprecated use {@link org.hibernate.SQLQuery#addRoot} or {@link org.hibernate.SQLQuery#addEntity} variants
-	 * instead to define the aliases/classes
-	 */
-	@Deprecated
-	@SuppressWarnings({ "JavaDoc" })
-	public Query createSQLQuery(String sql, String[] returnAliases, Class[] returnClasses);
-	
-	
-	/**
-	 * Persist the given transient instance, using the given identifier.  This operation 
-	 * cascades to associated instances if the association is mapped with 
-	 * <tt>cascade="save-update"</tt>.
-	 *
-	 * @deprecated declare identifier properties for all classes
-	 *
-	 * @param object a transient instance of a persistent class
-	 * @param id an unused valid identifier
-	 * @throws HibernateException
-	 */
-	public void save(Object object, Serializable id) throws HibernateException;
-
-	/**
-	 * Persist the given transient instance, using the given identifier. This operation 
-	 * cascades to associated instances if the association is mapped with 
-	 * <tt>cascade="save-update"</tt>.
-	 *
-	 * @deprecated declare identifier properties for all classes
-	 *
-	 * @param object a transient instance of a persistent class
-	 * @param id an unused valid identifier
-	 * @throws HibernateException
-	 */
-	public void save(String entityName, Object object, Serializable id) throws HibernateException;
-
-	/**
-	 * Update the persistent state associated with the given identifier. An exception
-	 * is thrown if there is a persistent instance with the same identifier in the
-	 * current session. This operation cascades to associated instances 
-	 * if the association is mapped with <tt>cascade="save-update"</tt>.
-	 *
-	 * @deprecated declare identifier properties for all classes
-	 *
-	 * @param object a detached instance containing updated state
-	 * @param id identifier of persistent instance
-	 * @throws HibernateException
-	 */
-	public void update(Object object, Serializable id) throws HibernateException;
-
-	/**
-	 * Update the persistent state associated with the given identifier. An exception
-	 * is thrown if there is a persistent instance with the same identifier in the
-	 * current session. This operation cascades to associated instances 
-	 * if the association is mapped with <tt>cascade="save-update"</tt>.
-	 * 
-	 * @deprecated declare identifier properties for all classes
-	 *
-	 * @param object a detached instance containing updated state
-	 * @param id identifier of persistent instance
-	 * @throws HibernateException
-	 */
-	public void update(String entityName, Object object, Serializable id) throws HibernateException;
-	
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/classic/Validatable.java b/hibernate-core/src/main/java/org/hibernate/classic/Validatable.java
deleted file mode 100644
index d5cd43bdcc..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/classic/Validatable.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.classic;
-
-
-/**
- * Implemented by persistent classes with invariants that must
- * be checked before inserting into or updating the database.
- *
- * @author Gavin King
- */
-public interface Validatable {
-	/**
-	 * Validate the state of the object before persisting it.
-	 * If a violation occurs, throw a <tt>ValidationFailure</tt>.
-	 * This method must not change the state of the object by
-	 * side-effect.
-	 * @throws ValidationFailure if an invariant is violated
-	 */
-	public void validate() throws ValidationFailure;
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/classic/ValidationFailure.java b/hibernate-core/src/main/java/org/hibernate/classic/ValidationFailure.java
deleted file mode 100644
index b9d156abf5..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/classic/ValidationFailure.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.classic;
-import org.hibernate.HibernateException;
-
-/**
- * Thrown from <tt>Validatable.validate()</tt> when an invariant
- * was violated. Some applications might subclass this exception
- * in order to provide more information about the violation.
- *
- * @author Gavin King
- */
-public class ValidationFailure extends HibernateException {
-
-	public ValidationFailure(String message) {
-		super(message);
-	}
-
-	public ValidationFailure(String message, Exception e) {
-		super(message, e);
-	}
-
-	public ValidationFailure(Exception e) {
-		super("A validation failure occurred", e);
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/context/CurrentSessionContext.java b/hibernate-core/src/main/java/org/hibernate/context/CurrentSessionContext.java
index 230b5f13bd..7022763d2f 100644
--- a/hibernate-core/src/main/java/org/hibernate/context/CurrentSessionContext.java
+++ b/hibernate-core/src/main/java/org/hibernate/context/CurrentSessionContext.java
@@ -1,59 +1,61 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
 package org.hibernate.context;
+
 import java.io.Serializable;
+
 import org.hibernate.HibernateException;
+import org.hibernate.Session;
 
 /**
  * Defines the contract for implementations which know how to scope the notion
  * of a {@link org.hibernate.SessionFactory#getCurrentSession() current session}.
  * <p/>
  * Implementations should adhere to the following:
  * <ul>
  * <li>contain a constructor accepting a single argument of type
  * {@link org.hibernate.engine.SessionFactoryImplementor}
  * <li>should be thread safe
  * <li>should be fully serializable
  * </ul>
  * <p/>
  * Implementors should be aware that they are also fully responsible for
  * cleanup of any generated current-sessions.
  * <p/>
  * Note that there will be exactly one instance of the configured
  * CurrentSessionContext implementation per {@link org.hibernate.SessionFactory}.
  *
  * @author Steve Ebersole
  */
 public interface CurrentSessionContext extends Serializable {
 	/**
 	 * Retrieve the current session according to the scoping defined
 	 * by this implementation.
 	 *
 	 * @return The current session.
 	 * @throws HibernateException Typically indicates an issue
 	 * locating or creating the current session.
 	 */
-	public org.hibernate.classic.Session currentSession() throws HibernateException;
+	public Session currentSession() throws HibernateException;
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/context/JTASessionContext.java b/hibernate-core/src/main/java/org/hibernate/context/JTASessionContext.java
index 514acdf29b..21dc457dbb 100644
--- a/hibernate-core/src/main/java/org/hibernate/context/JTASessionContext.java
+++ b/hibernate-core/src/main/java/org/hibernate/context/JTASessionContext.java
@@ -1,211 +1,209 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
 package org.hibernate.context;
 
-import java.util.Hashtable;
-import java.util.Map;
 import javax.transaction.Synchronization;
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
+import java.util.Hashtable;
+import java.util.Map;
+
+import org.jboss.logging.Logger;
+
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.HibernateException;
 import org.hibernate.HibernateLogger;
-import org.hibernate.classic.Session;
+import org.hibernate.Session;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
 import org.hibernate.service.jta.platform.spi.JtaPlatform;
-import org.jboss.logging.Logger;
 
 /**
  * An implementation of {@link CurrentSessionContext} which scopes the notion
  * of a current session to a JTA transaction.  Because JTA gives us a nice
  * tie-in to clean up after ourselves, this implementation will generate
  * Sessions as needed provided a JTA transaction is in effect.  If a session
  * is not already associated with the current JTA transaction at the time
  * {@link #currentSession()} is called, a new session will be opened and it
  * will be associated with that JTA transaction.
  * <p/>
  * Note that the sessions returned from this method are automatically configured with
  * both the {@link org.hibernate.cfg.Environment#FLUSH_BEFORE_COMPLETION auto-flush} and
  * {@link org.hibernate.cfg.Environment#AUTO_CLOSE_SESSION auto-close} attributes set to
  * true, meaning that the Session will be automatically flushed and closed
  * as part of the lifecycle for the JTA transaction to which it is associated.
  * Additionally, it will also be configured to aggressively release JDBC
  * connections after each statement is executed.  These settings are governed
  * by the {@link #isAutoFlushEnabled()}, {@link #isAutoCloseEnabled()}, and
  * {@link #getConnectionReleaseMode()} methods; these are provided (along with
  * the {@link #buildOrObtainSession()} method) for easier subclassing for custom
  * JTA-based session tracking logic (like maybe long-session semantics).
  *
  * @author Steve Ebersole
  */
 public class JTASessionContext implements CurrentSessionContext {
-
     private static final HibernateLogger LOG = Logger.getMessageLogger(HibernateLogger.class, JTASessionContext.class.getName());
 
 	protected final SessionFactoryImplementor factory;
 	private transient Map currentSessionMap = new Hashtable();
 
 	public JTASessionContext(SessionFactoryImplementor factory) {
 		this.factory = factory;
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public Session currentSession() throws HibernateException {
 		final JtaPlatform jtaPlatform = factory.getServiceRegistry().getService( JtaPlatform.class );
 		final TransactionManager transactionManager = jtaPlatform.retrieveTransactionManager();
 		if ( transactionManager == null ) {
 			throw new HibernateException( "No TransactionManagerLookup specified" );
 		}
 
 		Transaction txn;
 		try {
 			txn = transactionManager.getTransaction();
 			if ( txn == null ) {
 				throw new HibernateException( "Unable to locate current JTA transaction" );
 			}
 			if ( !JtaStatusHelper.isActive( txn.getStatus() ) ) {
 				// We could register the session against the transaction even though it is
 				// not started, but we'd have no guarantee of ever getting the map
 				// entries cleaned up (aside from spawning threads).
 				throw new HibernateException( "Current transaction is not in progress" );
 			}
 		}
 		catch ( HibernateException e ) {
 			throw e;
 		}
 		catch ( Throwable t ) {
 			throw new HibernateException( "Problem locating/validating JTA transaction", t );
 		}
 
 		final Object txnIdentifier = jtaPlatform.getTransactionIdentifier( txn );
 
 		Session currentSession = ( Session ) currentSessionMap.get( txnIdentifier );
 
 		if ( currentSession == null ) {
 			currentSession = buildOrObtainSession();
 
 			try {
 				txn.registerSynchronization( buildCleanupSynch( txnIdentifier ) );
 			}
 			catch ( Throwable t ) {
 				try {
 					currentSession.close();
 				}
 				catch ( Throwable ignore ) {
                     LOG.debug("Unable to release generated current-session on failed synch registration", ignore);
 				}
 				throw new HibernateException( "Unable to register cleanup Synchronization with TransactionManager" );
 			}
 
 			currentSessionMap.put( txnIdentifier, currentSession );
 		}
 
 		return currentSession;
 	}
 
 	/**
 	 * Builds a {@link CleanupSynch} capable of cleaning up the the current session map as an after transaction
 	 * callback.
 	 *
 	 * @param transactionIdentifier The transaction identifier under which the current session is registered.
 	 * @return The cleanup synch.
 	 */
 	private CleanupSynch buildCleanupSynch(Object transactionIdentifier) {
 		return new CleanupSynch( transactionIdentifier, this );
 	}
 
 	/**
 	 * Strictly provided for subclassing purposes; specifically to allow long-session
 	 * support.
 	 * <p/>
 	 * This implementation always just opens a new session.
 	 *
 	 * @return the built or (re)obtained session.
 	 */
 	protected Session buildOrObtainSession() {
 		return factory.openSession(
 				null,
 		        isAutoFlushEnabled(),
 		        isAutoCloseEnabled(),
 		        getConnectionReleaseMode()
 			);
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns true.
 	 *
 	 * @return Whether or not the the session should be closed by transaction completion.
 	 */
 	protected boolean isAutoCloseEnabled() {
 		return true;
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns true.
 	 *
 	 * @return Whether or not the the session should be flushed prior transaction completion.
 	 */
 	protected boolean isAutoFlushEnabled() {
 		return true;
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns after_statement.
 	 *
 	 * @return The connection release mode for any built sessions.
 	 */
 	protected ConnectionReleaseMode getConnectionReleaseMode() {
 		return ConnectionReleaseMode.AFTER_STATEMENT;
 	}
 
 	/**
 	 * JTA transaction synch used for cleanup of the internal session map.
 	 */
 	protected static class CleanupSynch implements Synchronization {
 		private Object transactionIdentifier;
 		private JTASessionContext context;
 
 		public CleanupSynch(Object transactionIdentifier, JTASessionContext context) {
 			this.transactionIdentifier = transactionIdentifier;
 			this.context = context;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public void beforeCompletion() {
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public void afterCompletion(int i) {
 			context.currentSessionMap.remove( transactionIdentifier );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/context/ManagedSessionContext.java b/hibernate-core/src/main/java/org/hibernate/context/ManagedSessionContext.java
index efaa2357aa..5565cffb39 100644
--- a/hibernate-core/src/main/java/org/hibernate/context/ManagedSessionContext.java
+++ b/hibernate-core/src/main/java/org/hibernate/context/ManagedSessionContext.java
@@ -1,147 +1,146 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
 package org.hibernate.context;
+
 import java.util.HashMap;
 import java.util.Map;
+
 import org.hibernate.HibernateException;
+import org.hibernate.Session;
 import org.hibernate.SessionFactory;
-import org.hibernate.classic.Session;
 import org.hibernate.engine.SessionFactoryImplementor;
 
 /**
  * Represents a {@link CurrentSessionContext} the notion of a contextual session
  * is managed by some external entity (generally some form of interceptor, etc).
  * This external manager is responsible for scoping these contextual sessions
  * appropriately binding/unbinding them here for exposure to the application
  * through {@link SessionFactory#getCurrentSession} calls.
  * <p/>
  *  Basically exposes two interfaces.  <ul>
  * <li>First is the implementation of CurrentSessionContext which is then used
  * by the {@link SessionFactory#getCurrentSession()} calls.  This
  * portion is instance-based specific to the session factory owning the given
  * instance of this impl (there will be one instance of this per each session
  * factory using this strategy).
  * <li>Second is the externally facing methods {@link #hasBind}, {@link #bind},
  * and {@link #unbind} used by the external thing to manage exposure of the
  * current session it is scoping.  This portion is static to allow easy
  * reference from that external thing.
  * </ul>
  * The underlying storage of the current sessions here is a static
  * {@link ThreadLocal}-based map where the sessions are keyed by the
  * the owning session factory.
  *
  * @author Steve Ebersole
  */
 public class ManagedSessionContext implements CurrentSessionContext {
 
-	private static final ThreadLocal context = new ThreadLocal();
+	private static final ThreadLocal<Map<SessionFactory,Session>> context = new ThreadLocal<Map<SessionFactory,Session>>();
 	private final SessionFactoryImplementor factory;
 
 	public ManagedSessionContext(SessionFactoryImplementor factory) {
 		this.factory = factory;
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public Session currentSession() {
 		Session current = existingSession( factory );
 		if ( current == null ) {
 			throw new HibernateException( "No session currently bound to execution context" );
 		}
 		return current;
 	}
 
 	/**
 	 * Check to see if there is already a session associated with the current
 	 * thread for the given session factory.
 	 *
 	 * @param factory The factory against which to check for a given session
 	 * within the current thread.
 	 * @return True if there is currently a session bound.
 	 */
 	public static boolean hasBind(SessionFactory factory) {
 		return existingSession( factory ) != null;
 	}
 
 	/**
 	 * Binds the given session to the current context for its session factory.
 	 *
 	 * @param session The session to be bound.
 	 * @return Any previously bound session (should be null in most cases).
 	 */
 	public static Session bind(Session session) {
-		return ( Session ) sessionMap( true ).put( session.getSessionFactory(), session );
+		return sessionMap( true ).put( session.getSessionFactory(), session );
 	}
 
 	/**
 	 * Unbinds the session (if one) current associated with the context for the
 	 * given session.
 	 *
 	 * @param factory The factory for which to unbind the current session.
 	 * @return The bound session if one, else null.
 	 */
 	public static Session unbind(SessionFactory factory) {
 		Session existing = null;
-		Map sessionMap = sessionMap();
+		Map<SessionFactory,Session> sessionMap = sessionMap();
 		if ( sessionMap != null ) {
-			existing = ( Session ) sessionMap.remove( factory );
+			existing = sessionMap.remove( factory );
 			doCleanup();
 		}
 		return existing;
 	}
 
 	private static Session existingSession(SessionFactory factory) {
 		Map sessionMap = sessionMap();
 		if ( sessionMap == null ) {
 			return null;
 		}
 		else {
 			return ( Session ) sessionMap.get( factory );
 		}
 	}
 
-	protected static Map sessionMap() {
+	protected static Map<SessionFactory,Session> sessionMap() {
 		return sessionMap( false );
 	}
 
-	private static synchronized Map sessionMap(boolean createMap) {
-		Map sessionMap = ( Map ) context.get();
+	private static synchronized Map<SessionFactory,Session> sessionMap(boolean createMap) {
+		Map<SessionFactory,Session> sessionMap = context.get();
 		if ( sessionMap == null && createMap ) {
-			sessionMap = new HashMap();
+			sessionMap = new HashMap<SessionFactory,Session>();
 			context.set( sessionMap );
 		}
 		return sessionMap;
 	}
 
 	private static synchronized void doCleanup() {
-		Map sessionMap = sessionMap( false );
+		Map<SessionFactory,Session> sessionMap = sessionMap( false );
 		if ( sessionMap != null ) {
 			if ( sessionMap.isEmpty() ) {
 				context.set( null );
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/context/ThreadLocalSessionContext.java b/hibernate-core/src/main/java/org/hibernate/context/ThreadLocalSessionContext.java
index 918e5349dd..5da139cfb9 100644
--- a/hibernate-core/src/main/java/org/hibernate/context/ThreadLocalSessionContext.java
+++ b/hibernate-core/src/main/java/org/hibernate/context/ThreadLocalSessionContext.java
@@ -1,386 +1,387 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
 package org.hibernate.context;
 
+import javax.transaction.Synchronization;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.HashMap;
 import java.util.Map;
-import javax.transaction.Synchronization;
+
+import org.jboss.logging.Logger;
+
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.HibernateException;
 import org.hibernate.HibernateLogger;
+import org.hibernate.Session;
 import org.hibernate.SessionFactory;
-import org.hibernate.classic.Session;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.jdbc.LobCreationContext;
 import org.hibernate.engine.transaction.spi.TransactionContext;
 import org.hibernate.event.EventSource;
-import org.jboss.logging.Logger;
 
 /**
  * A {@link CurrentSessionContext} impl which scopes the notion of current
  * session by the current thread of execution.  Unlike the JTA counterpart,
  * threads do not give us a nice hook to perform any type of cleanup making
  * it questionable for this impl to actually generate Session instances.  In
  * the interest of usability, it was decided to have this default impl
  * actually generate a session upon first request and then clean it up
  * after the {@link org.hibernate.Transaction} associated with that session
  * is committed/rolled-back.  In order for ensuring that happens, the sessions
  * generated here are unusable until after {@link Session#beginTransaction()}
  * has been called. If <tt>close()</tt> is called on a session managed by
  * this class, it will be automatically unbound.
  * <p/>
  * Additionally, the static {@link #bind} and {@link #unbind} methods are
  * provided to allow application code to explicitly control opening and
  * closing of these sessions.  This, with some from of interception,
  * is the preferred approach.  It also allows easy framework integration
  * and one possible approach for implementing long-sessions.
  * <p/>
  * The {@link #buildOrObtainSession}, {@link #isAutoCloseEnabled},
  * {@link #isAutoFlushEnabled}, {@link #getConnectionReleaseMode}, and
  * {@link #buildCleanupSynch} methods are all provided to allow easy
  * subclassing (for long-running session scenarios, for example).
  *
  * @author Steve Ebersole
  */
 public class ThreadLocalSessionContext implements CurrentSessionContext {
 
     private static final HibernateLogger LOG = Logger.getMessageLogger(HibernateLogger.class,
                                                                        ThreadLocalSessionContext.class.getName());
 	private static final Class[] SESSION_PROXY_INTERFACES = new Class[] {
 			Session.class,
 	        SessionImplementor.class,
 	        EventSource.class,
 			TransactionContext.class,
 			LobCreationContext.class
 	};
 
 	/**
 	 * A ThreadLocal maintaining current sessions for the given execution thread.
 	 * The actual ThreadLocal variable is a java.util.Map to account for
 	 * the possibility for multiple SessionFactorys being used during execution
 	 * of the given thread.
 	 */
 	private static final ThreadLocal<Map> context = new ThreadLocal<Map>();
 
 	protected final SessionFactoryImplementor factory;
 
 	public ThreadLocalSessionContext(SessionFactoryImplementor factory) {
 		this.factory = factory;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public final Session currentSession() throws HibernateException {
 		Session current = existingSession( factory );
 		if (current == null) {
 			current = buildOrObtainSession();
 			// register a cleanup sync
 			current.getTransaction().registerSynchronization( buildCleanupSynch() );
 			// wrap the session in the transaction-protection proxy
 			if ( needsWrapping( current ) ) {
 				current = wrap( current );
 			}
 			// then bind it
 			doBind( current, factory );
 		}
 		return current;
 	}
 
 	private boolean needsWrapping(Session session) {
 		// try to make sure we don't wrap and already wrapped session
 		return session != null
 		       && ! Proxy.isProxyClass( session.getClass() )
 		       || ( Proxy.getInvocationHandler( session ) != null
 		       && ! ( Proxy.getInvocationHandler( session ) instanceof TransactionProtectionWrapper ) );
 	}
 
 	/**
 	 * Getter for property 'factory'.
 	 *
 	 * @return Value for property 'factory'.
 	 */
 	protected SessionFactoryImplementor getFactory() {
 		return factory;
 	}
 
 	/**
 	 * Strictly provided for subclassing purposes; specifically to allow long-session
 	 * support.
 	 * <p/>
 	 * This implementation always just opens a new session.
 	 *
 	 * @return the built or (re)obtained session.
 	 */
 	protected Session buildOrObtainSession() {
 		return factory.openSession(
 				null,
 		        isAutoFlushEnabled(),
 		        isAutoCloseEnabled(),
 		        getConnectionReleaseMode()
 			);
 	}
 
 	protected CleanupSynch buildCleanupSynch() {
 		return new CleanupSynch( factory );
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns true.
 	 *
 	 * @return Whether or not the the session should be closed by transaction completion.
 	 */
 	protected boolean isAutoCloseEnabled() {
 		return true;
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns true.
 	 *
 	 * @return Whether or not the the session should be flushed prior transaction completion.
 	 */
 	protected boolean isAutoFlushEnabled() {
 		return true;
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns after_transaction.
 	 *
 	 * @return The connection release mode for any built sessions.
 	 */
 	protected ConnectionReleaseMode getConnectionReleaseMode() {
 		return factory.getSettings().getConnectionReleaseMode();
 	}
 
 	protected Session wrap(Session session) {
 		TransactionProtectionWrapper wrapper = new TransactionProtectionWrapper( session );
 		Session wrapped = ( Session ) Proxy.newProxyInstance(
 				Session.class.getClassLoader(),
 				SESSION_PROXY_INTERFACES,
 		        wrapper
 			);
 		// yick!  need this for proper serialization/deserialization handling...
 		wrapper.setWrapped( wrapped );
 		return wrapped;
 	}
 
 	/**
 	 * Associates the given session with the current thread of execution.
 	 *
 	 * @param session The session to bind.
 	 */
 	public static void bind(org.hibernate.Session session) {
 		SessionFactory factory = session.getSessionFactory();
 		cleanupAnyOrphanedSession( factory );
 		doBind( session, factory );
 	}
 
 	private static void cleanupAnyOrphanedSession(SessionFactory factory) {
 		Session orphan = doUnbind( factory, false );
 		if ( orphan != null ) {
             LOG.alreadySessionBound();
 			try {
 				if ( orphan.getTransaction() != null && orphan.getTransaction().isActive() ) {
 					try {
 						orphan.getTransaction().rollback();
 					}
 					catch( Throwable t ) {
                         LOG.debug("Unable to rollback transaction for orphaned session", t);
 					}
 				}
 				orphan.close();
 			}
 			catch( Throwable t ) {
                 LOG.debug("Unable to close orphaned session", t);
 			}
 		}
 	}
 
 	/**
 	 * Disassociates a previously bound session from the current thread of execution.
 	 *
 	 * @param factory The factory for which the session should be unbound.
 	 * @return The session which was unbound.
 	 */
 	public static Session unbind(SessionFactory factory) {
 		return doUnbind( factory, true );
 	}
 
 	private static Session existingSession(SessionFactory factory) {
 		Map sessionMap = sessionMap();
         if (sessionMap == null) return null;
         return (Session)sessionMap.get(factory);
 	}
 
 	protected static Map sessionMap() {
 		return context.get();
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private static void doBind(org.hibernate.Session session, SessionFactory factory) {
 		Map sessionMap = sessionMap();
 		if ( sessionMap == null ) {
 			sessionMap = new HashMap();
 			context.set( sessionMap );
 		}
 		sessionMap.put( factory, session );
 	}
 
 	private static Session doUnbind(SessionFactory factory, boolean releaseMapIfEmpty) {
 		Map sessionMap = sessionMap();
 		Session session = null;
 		if ( sessionMap != null ) {
 			session = ( Session ) sessionMap.remove( factory );
 			if ( releaseMapIfEmpty && sessionMap.isEmpty() ) {
 				context.set( null );
 			}
 		}
 		return session;
 	}
 
 	/**
 	 * JTA transaction synch used for cleanup of the internal session map.
 	 */
 	protected static class CleanupSynch implements Synchronization, Serializable {
 		protected final SessionFactory factory;
 
 		public CleanupSynch(SessionFactory factory) {
 			this.factory = factory;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public void beforeCompletion() {
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public void afterCompletion(int i) {
 			unbind( factory );
 		}
 	}
 
 	private class TransactionProtectionWrapper implements InvocationHandler, Serializable {
 		private final Session realSession;
 		private Session wrappedSession;
 
 		public TransactionProtectionWrapper(Session realSession) {
 			this.realSession = realSession;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 			try {
 				// If close() is called, guarantee unbind()
 				if ( "close".equals( method.getName()) ) {
 					unbind( realSession.getSessionFactory() );
 				}
 				else if ( "toString".equals( method.getName() )
 					     || "equals".equals( method.getName() )
 					     || "hashCode".equals( method.getName() )
 				         || "getStatistics".equals( method.getName() )
 					     || "isOpen".equals( method.getName() )
 						 || "getListeners".equals( method.getName() ) //useful for HSearch in particular
 						) {
 					// allow these to go through the the real session no matter what
 				}
 				else if ( !realSession.isOpen() ) {
 					// essentially, if the real session is closed allow any
 					// method call to pass through since the real session
 					// will complain by throwing an appropriate exception;
 					// NOTE that allowing close() above has the same basic effect,
 					//   but we capture that there simply to doAfterTransactionCompletion the unbind...
 				}
 				else if ( !realSession.getTransaction().isActive() ) {
 					// limit the methods available if no transaction is active
 					if ( "beginTransaction".equals( method.getName() )
 					     || "getTransaction".equals( method.getName() )
 					     || "isTransactionInProgress".equals( method.getName() )
 					     || "setFlushMode".equals( method.getName() )
 					     || "getSessionFactory".equals( method.getName() ) ) {
                         LOG.trace("Allowing method [" + method.getName() + "] in non-transacted context");
 					}
 					else if ( "reconnect".equals( method.getName() )
 					          || "disconnect".equals( method.getName() ) ) {
 						// allow these (deprecated) methods to pass through
 					}
 					else {
 						throw new HibernateException( method.getName() + " is not valid without active transaction" );
 					}
 				}
                 LOG.trace("Allowing proxied method [" + method.getName() + "] to proceed to real session");
 				return method.invoke( realSession, args );
 			}
 			catch ( InvocationTargetException e ) {
                 if (e.getTargetException() instanceof RuntimeException) throw (RuntimeException)e.getTargetException();
                 throw e;
 			}
 		}
 
 		/**
 		 * Setter for property 'wrapped'.
 		 *
 		 * @param wrapped Value to set for property 'wrapped'.
 		 */
 		public void setWrapped(Session wrapped) {
 			this.wrappedSession = wrapped;
 		}
 
 
 		// serialization ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		private void writeObject(ObjectOutputStream oos) throws IOException {
 			// if a ThreadLocalSessionContext-bound session happens to get
 			// serialized, to be completely correct, we need to make sure
 			// that unbinding of that session occurs.
 			oos.defaultWriteObject();
 			if ( existingSession( factory ) == wrappedSession ) {
 				unbind( factory );
 			}
 		}
 
 		private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
 			// on the inverse, it makes sense that if a ThreadLocalSessionContext-
 			// bound session then gets deserialized to go ahead and re-bind it to
 			// the ThreadLocalSessionContext session map.
 			ois.defaultReadObject();
 			realSession.getTransaction().registerSynchronization( buildCleanupSynch() );
 			doBind( wrappedSession, factory );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/CascadeStyle.java b/hibernate-core/src/main/java/org/hibernate/engine/CascadeStyle.java
index 4fecaeba9f..9f367d83d9 100755
--- a/hibernate-core/src/main/java/org/hibernate/engine/CascadeStyle.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/CascadeStyle.java
@@ -1,296 +1,296 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.engine;
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Map;
 import org.hibernate.MappingException;
 import org.hibernate.internal.util.collections.ArrayHelper;
 
 /**
  * A contract for defining the aspects of cascading various persistence actions.
  *
  * @see CascadingAction
  *
  * @author Gavin King
  */
 public abstract class CascadeStyle implements Serializable {
 
 	/**
 	 * For this style, should the given action be cascaded?
 	 *
 	 * @param action The action to be checked for cascade-ability.
 	 * @return True if the action should be cascaded under this style; false otherwise.
 	 */
 	public abstract boolean doCascade(CascadingAction action);
 
 	/**
 	 * Probably more aptly named something like doCascadeToCollectionElements(); it is
 	 * however used from both the collection and to-one logic branches...
 	 * <p/>
 	 * For this style, should the given action really be cascaded?  The default
 	 * implementation is simply to return {@link #doCascade}; for certain
 	 * styles (currently only delete-orphan), however, we need to be able to
 	 * control this seperately.
 	 *
 	 * @param action The action to be checked for cascade-ability.
 	 * @return True if the action should be really cascaded under this style;
 	 * false otherwise.
 	 */
 	public boolean reallyDoCascade(CascadingAction action) {
 		return doCascade(action);
 	}
 
 	/**
 	 * Do we need to delete orphaned collection elements?
 	 *
 	 * @return True if this style need to account for orphan delete
 	 * operations; false othwerwise.
 	 */
 	public boolean hasOrphanDelete() {
 		return false;
 	}
 
 	public static final class MultipleCascadeStyle extends CascadeStyle {
 		private final CascadeStyle[] styles;
 		public MultipleCascadeStyle(CascadeStyle[] styles) {
 			this.styles = styles;
 		}
 		public boolean doCascade(CascadingAction action) {
 			for (int i=0; i<styles.length; i++) {
 				if ( styles[i].doCascade(action) ) return true;
 			}
 			return false;
 		}
 		public boolean reallyDoCascade(CascadingAction action) {
 			for (int i=0; i<styles.length; i++) {
 				if ( styles[i].reallyDoCascade(action) ) return true;
 			}
 			return false;
 		}
 		public boolean hasOrphanDelete() {
 			for (int i=0; i<styles.length; i++) {
 				if ( styles[i].hasOrphanDelete() ) return true;
 			}
 			return false;
 		}
 		public String toString() {
 			return ArrayHelper.toString( styles );
 		}
 	}
 
 	/**
 	 * save / delete / update / evict / lock / replicate / merge / persist + delete orphans
 	 */
 	public static final CascadeStyle ALL_DELETE_ORPHAN = new CascadeStyle() {
 		public boolean doCascade(CascadingAction action) {
 			return true;
 		}
 		public boolean hasOrphanDelete() {
 			return true;
 		}
 		public String toString() {
 			return "STYLE_ALL_DELETE_ORPHAN";
 		}
 	};
 
 	/**
 	 * save / delete / update / evict / lock / replicate / merge / persist
 	 */
 	public static final CascadeStyle ALL = new CascadeStyle() {
 		public boolean doCascade(CascadingAction action) {
 			return true;
 		}
 		public String toString() {
 			return "STYLE_ALL";
 		}
 	};
 
 	/**
 	 * save / update
 	 */
 	public static final CascadeStyle UPDATE = new CascadeStyle() {
 		public boolean doCascade(CascadingAction action) {
-			return action==CascadingAction.SAVE_UPDATE || action==CascadingAction.SAVE_UPDATE_COPY;
+			return action==CascadingAction.SAVE_UPDATE;
 		}
 		public String toString() {
 			return "STYLE_SAVE_UPDATE";
 		}
 	};
 
 	/**
 	 * lock
 	 */
 	public static final CascadeStyle LOCK = new CascadeStyle() {
 		public boolean doCascade(CascadingAction action) {
 			return action==CascadingAction.LOCK;
 		}
 		public String toString() {
 			return "STYLE_LOCK";
 		}
 	};
 
 	/**
 	 * refresh
 	 */
 	public static final CascadeStyle REFRESH = new CascadeStyle() {
 		public boolean doCascade(CascadingAction action) {
 			return action==CascadingAction.REFRESH;
 		}
 		public String toString() {
 			return "STYLE_REFRESH";
 		}
 	};
 
 	/**
 	 * evict
 	 */
 	public static final CascadeStyle EVICT = new CascadeStyle() {
 		public boolean doCascade(CascadingAction action) {
 			return action==CascadingAction.EVICT;
 		}
 		public String toString() {
 			return "STYLE_EVICT";
 		}
 	};
 
 	/**
 	 * replicate
 	 */
 	public static final CascadeStyle REPLICATE = new CascadeStyle() {
 		public boolean doCascade(CascadingAction action) {
 			return action==CascadingAction.REPLICATE;
 		}
 		public String toString() {
 			return "STYLE_REPLICATE";
 		}
 	};
 	/**
 	 * merge
 	 */
 	public static final CascadeStyle MERGE = new CascadeStyle() {
 		public boolean doCascade(CascadingAction action) {
 			return action==CascadingAction.MERGE;
 		}
 		public String toString() {
 			return "STYLE_MERGE";
 		}
 	};
 
 	/**
 	 * create
 	 */
 	public static final CascadeStyle PERSIST = new CascadeStyle() {
 		public boolean doCascade(CascadingAction action) {
 			return action==CascadingAction.PERSIST
 				|| action==CascadingAction.PERSIST_ON_FLUSH;
 		}
 		public String toString() {
 			return "STYLE_PERSIST";
 		}
 	};
 
 	/**
 	 * delete
 	 */
 	public static final CascadeStyle DELETE = new CascadeStyle() {
 		public boolean doCascade(CascadingAction action) {
 			return action==CascadingAction.DELETE;
 		}
 		public String toString() {
 			return "STYLE_DELETE";
 		}
 	};
 
 	/**
 	 * delete + delete orphans
 	 */
 	public static final CascadeStyle DELETE_ORPHAN = new CascadeStyle() {
 		public boolean doCascade(CascadingAction action) {
 			return action==CascadingAction.DELETE || action==CascadingAction.SAVE_UPDATE;
 		}
 		public boolean reallyDoCascade(CascadingAction action) {
 			return action==CascadingAction.DELETE;
 		}
 		public boolean hasOrphanDelete() {
 			return true;
 		}
 		public String toString() {
 			return "STYLE_DELETE_ORPHAN";
 		}
 	};
 
 	/**
 	 * no cascades
 	 */
 	public static final CascadeStyle NONE = new CascadeStyle() {
 		public boolean doCascade(CascadingAction action) {
 			return false;
 		}
 		public String toString() {
 			return "STYLE_NONE";
 		}
 	};
 
 	/**
 	 * package-protected constructor
 	 */
 	CascadeStyle() {
 	}
 
 	static final Map STYLES = new HashMap();
 
 	static {
 		STYLES.put( "all", ALL );
 		STYLES.put( "all-delete-orphan", ALL_DELETE_ORPHAN );
 		STYLES.put( "save-update", UPDATE );
 		STYLES.put( "persist", PERSIST );
 		STYLES.put( "merge", MERGE );
 		STYLES.put( "lock", LOCK );
 		STYLES.put( "refresh", REFRESH );
 		STYLES.put( "replicate", REPLICATE );
 		STYLES.put( "evict", EVICT );
 		STYLES.put( "delete", DELETE );
 		STYLES.put( "remove", DELETE ); // adds remove as a sort-of alias for delete...
 		STYLES.put( "delete-orphan", DELETE_ORPHAN );
 		STYLES.put( "none", NONE );
 	}
 
 	/**
 	 * Factory method for obtaining named cascade styles
 	 *
 	 * @param cascade The named cascade style name.
 	 * @return The appropriate CascadeStyle
 	 */
 	public static CascadeStyle getCascadeStyle(String cascade) {
 		CascadeStyle style = (CascadeStyle) STYLES.get(cascade);
 		if (style==null) {
 			throw new MappingException("Unsupported cascade style: " + cascade);
 		}
 		else {
 			return style;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/CascadingAction.java b/hibernate-core/src/main/java/org/hibernate/engine/CascadingAction.java
index 0962b32165..2fd0994f97 100755
--- a/hibernate-core/src/main/java/org/hibernate/engine/CascadingAction.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/CascadingAction.java
@@ -1,495 +1,468 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.engine;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 import org.hibernate.HibernateException;
 import org.hibernate.HibernateLogger;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.ReplicationMode;
 import org.hibernate.TransientObjectException;
 import org.hibernate.collection.PersistentCollection;
 import org.hibernate.event.EventSource;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 
 /**
  * A session action that may be cascaded from parent entity to its children
  *
  * @author Gavin King
  */
 public abstract class CascadingAction {
 
     private static final HibernateLogger LOG = Logger.getMessageLogger(HibernateLogger.class, CascadingAction.class.getName());
 
 
 	// the CascadingAction contract ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * protected constructor
 	 */
 	CascadingAction() {
 	}
 
 	/**
 	 * Cascade the action to the child object.
 	 *
 	 * @param session The session within which the cascade is occuring.
 	 * @param child The child to which cascading should be performed.
 	 * @param entityName The child's entity name
 	 * @param anything Anything ;)  Typically some form of cascade-local cache
 	 * which is specific to each CascadingAction type
 	 * @param isCascadeDeleteEnabled Are cascading deletes enabled.
 	 * @throws HibernateException
 	 */
 	public abstract void cascade(
 			EventSource session,
 			Object child,
 			String entityName,
 			Object anything,
 			boolean isCascadeDeleteEnabled) throws HibernateException;
 
 	/**
 	 * Given a collection, get an iterator of the children upon which the
 	 * current cascading action should be visited.
 	 *
 	 * @param session The session within which the cascade is occuring.
 	 * @param collectionType The mapping type of the collection.
 	 * @param collection The collection instance.
 	 * @return The children iterator.
 	 */
 	public abstract Iterator getCascadableChildrenIterator(
 			EventSource session,
 			CollectionType collectionType,
 			Object collection);
 
 	/**
 	 * Does this action potentially extrapolate to orphan deletes?
 	 *
 	 * @return True if this action can lead to deletions of orphans.
 	 */
 	public abstract boolean deleteOrphans();
 
 
 	/**
 	 * Does the specified cascading action require verification of no cascade validity?
 	 *
 	 * @return True if this action requires no-cascade verification; false otherwise.
 	 */
 	public boolean requiresNoCascadeChecking() {
 		return false;
 	}
 
 	/**
 	 * Called (in the case of {@link #requiresNoCascadeChecking} returning true) to validate
 	 * that no cascade on the given property is considered a valid semantic.
 	 *
 	 * @param session The session witin which the cascade is occurring.
 	 * @param child The property value
 	 * @param parent The property value owner
 	 * @param persister The entity persister for the owner
 	 * @param propertyIndex The index of the property within the owner.
 	 */
 	public void noCascade(EventSource session, Object child, Object parent, EntityPersister persister, int propertyIndex) {
 	}
 
 	/**
 	 * Should this action be performed (or noCascade consulted) in the case of lazy properties.
 	 */
 	public boolean performOnLazyProperty() {
 		return true;
 	}
 
 
 	// the CascadingAction implementations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * @see org.hibernate.Session#delete(Object)
 	 */
 	public static final CascadingAction DELETE = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to delete: " + entityName);
 			session.delete( entityName, child, isCascadeDeleteEnabled, ( Set ) anything );
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// delete does cascade to uninitialized collections
 			return CascadingAction.getAllElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			// orphans should be deleted during delete
 			return true;
 		}
 		@Override
         public String toString() {
 			return "ACTION_DELETE";
 		}
 	};
 
 	/**
 	 * @see org.hibernate.Session#lock(Object, LockMode)
 	 */
 	public static final CascadingAction LOCK = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to lock: " + entityName);
 			LockMode lockMode = LockMode.NONE;
 			LockOptions lr = new LockOptions();
 			if ( anything instanceof LockOptions) {
 				LockOptions lockOptions = (LockOptions)anything;
 				lr.setTimeOut(lockOptions.getTimeOut());
 				lr.setScope( lockOptions.getScope());
 				if ( lockOptions.getScope() == true )	// cascade specified lockMode
 					lockMode = lockOptions.getLockMode();
 			}
 			lr.setLockMode(lockMode);
 			session.buildLockRequest(lr).lock(entityName, child);
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// lock doesn't cascade to uninitialized collections
 			return getLoadedElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			//TODO: should orphans really be deleted during lock???
 			return false;
 		}
 		@Override
         public String toString() {
 			return "ACTION_LOCK";
 		}
 	};
 
 	/**
 	 * @see org.hibernate.Session#refresh(Object)
 	 */
 	public static final CascadingAction REFRESH = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to refresh: " + entityName);
 			session.refresh( child, (Map) anything );
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// refresh doesn't cascade to uninitialized collections
 			return getLoadedElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			return false;
 		}
 		@Override
         public String toString() {
 			return "ACTION_REFRESH";
 		}
 	};
 
 	/**
 	 * @see org.hibernate.Session#evict(Object)
 	 */
 	public static final CascadingAction EVICT = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to evict: " + entityName);
 			session.evict(child);
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// evicts don't cascade to uninitialized collections
 			return getLoadedElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			return false;
 		}
 		@Override
         public boolean performOnLazyProperty() {
 			return false;
 		}
 		@Override
         public String toString() {
 			return "ACTION_EVICT";
 		}
 	};
 
 	/**
 	 * @see org.hibernate.Session#saveOrUpdate(Object)
 	 */
 	public static final CascadingAction SAVE_UPDATE = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to save or update: " + entityName);
 			session.saveOrUpdate(entityName, child);
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// saves / updates don't cascade to uninitialized collections
 			return getLoadedElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			// orphans should be deleted during save/update
 			return true;
 		}
 		@Override
         public boolean performOnLazyProperty() {
 			return false;
 		}
 		@Override
         public String toString() {
 			return "ACTION_SAVE_UPDATE";
 		}
 	};
 
 	/**
 	 * @see org.hibernate.Session#merge(Object)
 	 */
 	public static final CascadingAction MERGE = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to merge: " + entityName);
 			session.merge( entityName, child, (Map) anything );
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// merges don't cascade to uninitialized collections
 //			//TODO: perhaps this does need to cascade after all....
 			return getLoadedElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			// orphans should not be deleted during merge??
 			return false;
 		}
 		@Override
         public String toString() {
 			return "ACTION_MERGE";
 		}
 	};
 
 	/**
-	 * @see org.hibernate.classic.Session#saveOrUpdateCopy(Object)
-	 */
-	public static final CascadingAction SAVE_UPDATE_COPY = new CascadingAction() {
-		// for deprecated saveOrUpdateCopy()
-		@Override
-        public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
-		throws HibernateException {
-            LOG.trace("Cascading to save or update copy: " + entityName);
-			session.saveOrUpdateCopy( entityName, child, (Map) anything );
-		}
-		@Override
-        public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
-			// saves / updates don't cascade to uninitialized collections
-			return getLoadedElementsIterator(session, collectionType, collection);
-		}
-		@Override
-        public boolean deleteOrphans() {
-			// orphans should not be deleted during copy??
-			return false;
-		}
-		@Override
-        public String toString() {
-			return "ACTION_SAVE_UPDATE_COPY";
-		}
-	};
-
-	/**
 	 * @see org.hibernate.Session#persist(Object)
 	 */
 	public static final CascadingAction PERSIST = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to persist: " + entityName);
 			session.persist( entityName, child, (Map) anything );
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// persists don't cascade to uninitialized collections
 			return CascadingAction.getAllElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			return false;
 		}
 		@Override
         public boolean performOnLazyProperty() {
 			return false;
 		}
 		@Override
         public String toString() {
 			return "ACTION_PERSIST";
 		}
 	};
 
 	/**
 	 * Execute persist during flush time
 	 *
 	 * @see org.hibernate.Session#persist(Object)
 	 */
 	public static final CascadingAction PERSIST_ON_FLUSH = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to persist on flush: " + entityName);
 			session.persistOnFlush( entityName, child, (Map) anything );
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// persists don't cascade to uninitialized collections
 			return CascadingAction.getLoadedElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			return true;
 		}
 		@Override
         public boolean requiresNoCascadeChecking() {
 			return true;
 		}
 		@Override
         public void noCascade(
 				EventSource session,
 				Object child,
 				Object parent,
 				EntityPersister persister,
 				int propertyIndex) {
 			if ( child == null ) {
 				return;
 			}
 			Type type = persister.getPropertyTypes()[propertyIndex];
 			if ( type.isEntityType() ) {
 				String childEntityName = ( ( EntityType ) type ).getAssociatedEntityName( session.getFactory() );
 
 				if ( ! isInManagedState( child, session )
 						&& ! ( child instanceof HibernateProxy ) //a proxy cannot be transient and it breaks ForeignKeys.isTransient
 						&& ForeignKeys.isTransient( childEntityName, child, null, session ) ) {
 					String parentEntiytName = persister.getEntityName();
 					String propertyName = persister.getPropertyNames()[propertyIndex];
 					throw new TransientObjectException(
 							"object references an unsaved transient instance - " +
 							"save the transient instance before flushing: " +
 							parentEntiytName + "." + propertyName + " -> " + childEntityName
 					);
 
 				}
 			}
 		}
 		@Override
         public boolean performOnLazyProperty() {
 			return false;
 		}
 
 		private boolean isInManagedState(Object child, EventSource session) {
 			EntityEntry entry = session.getPersistenceContext().getEntry( child );
 			return entry != null && (entry.getStatus() == Status.MANAGED || entry.getStatus() == Status.READ_ONLY);
 		}
 
 		@Override
         public String toString() {
 			return "ACTION_PERSIST_ON_FLUSH";
 		}
 	};
 
 	/**
 	 * @see org.hibernate.Session#replicate(Object, org.hibernate.ReplicationMode)
 	 */
 	public static final CascadingAction REPLICATE = new CascadingAction() {
 		@Override
         public void cascade(EventSource session, Object child, String entityName, Object anything, boolean isCascadeDeleteEnabled)
 		throws HibernateException {
             LOG.trace("Cascading to replicate: " + entityName);
 			session.replicate( entityName, child, (ReplicationMode) anything );
 		}
 		@Override
         public Iterator getCascadableChildrenIterator(EventSource session, CollectionType collectionType, Object collection) {
 			// replicate does cascade to uninitialized collections
 			return getLoadedElementsIterator(session, collectionType, collection);
 		}
 		@Override
         public boolean deleteOrphans() {
 			return false; //I suppose?
 		}
 		@Override
         public String toString() {
 			return "ACTION_REPLICATE";
 		}
 	};
 
 
 	// static helper methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Given a collection, get an iterator of all its children, loading them
 	 * from the database if necessary.
 	 *
 	 * @param session The session within which the cascade is occuring.
 	 * @param collectionType The mapping type of the collection.
 	 * @param collection The collection instance.
 	 * @return The children iterator.
 	 */
 	private static Iterator getAllElementsIterator(
 			EventSource session,
 			CollectionType collectionType,
 			Object collection) {
 		return collectionType.getElementsIterator( collection, session );
 	}
 
 	/**
 	 * Iterate just the elements of the collection that are already there. Don't load
 	 * any new elements from the database.
 	 */
 	public static Iterator getLoadedElementsIterator(SessionImplementor session, CollectionType collectionType, Object collection) {
 		if ( collectionIsInitialized(collection) ) {
 			// handles arrays and newly instantiated collections
 			return collectionType.getElementsIterator(collection, session);
 		}
 		else {
 			// does not handle arrays (thats ok, cos they can't be lazy)
 			// or newly instantiated collections, so we can do the cast
 			return ( (PersistentCollection) collection ).queuedAdditionIterator();
 		}
 	}
 
 	private static boolean collectionIsInitialized(Object collection) {
 		return !(collection instanceof PersistentCollection) || ( (PersistentCollection) collection ).wasInitialized();
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/SessionFactoryImplementor.java b/hibernate-core/src/main/java/org/hibernate/engine/SessionFactoryImplementor.java
index 7e22bca770..735f5c8b8b 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/SessionFactoryImplementor.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/SessionFactoryImplementor.java
@@ -1,257 +1,258 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.engine;
 
 import java.sql.Connection;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.MappingException;
+import org.hibernate.Session;
 import org.hibernate.SessionFactory;
 import org.hibernate.cache.QueryCache;
 import org.hibernate.cache.Region;
 import org.hibernate.cache.UpdateTimestampsCache;
 import org.hibernate.cfg.Settings;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.function.SQLFunctionRegistry;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.profile.FetchProfile;
 import org.hibernate.engine.query.QueryPlanCache;
 import org.hibernate.exception.SQLExceptionConverter;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.spi.ServiceRegistry;
 import org.hibernate.stat.StatisticsImplementor;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeResolver;
 
 /**
  * Defines the internal contract between the <tt>SessionFactory</tt> and other parts of
  * Hibernate such as implementors of <tt>Type</tt>.
  *
  * @see org.hibernate.SessionFactory
  * @see org.hibernate.impl.SessionFactoryImpl
  * @author Gavin King
  */
 public interface SessionFactoryImplementor extends Mapping, SessionFactory {
 	/**
 	 * Retrieve the {@link Type} resolver associated with this factory.
 	 *
 	 * @return The type resolver
 	 */
 	public TypeResolver getTypeResolver();
 
 	/**
 	 * Get a copy of the Properties used to configure this session factory.
 	 *
 	 * @return The properties.
 	 */
 	public Properties getProperties();
 
 	/**
 	 * Get the persister for the named entity
 	 *
 	 * @param entityName The name of the entity for which to retrieve the persister.
 	 * @return The persister
 	 * @throws MappingException Indicates persister could not be found with that name.
 	 */
 	public EntityPersister getEntityPersister(String entityName) throws MappingException;
 
 	/**
 	 * Get the persister object for a collection role.
 	 *
 	 * @param role The role (name) of the collection for which to retrieve the
 	 * persister.
 	 * @return The persister
 	 * @throws MappingException Indicates persister could not be found with that role.
 	 */
 	public CollectionPersister getCollectionPersister(String role) throws MappingException;
 
 	/**
 	 * Get the JdbcServices.
 	 * @return the JdbcServices
 	 */
 	public JdbcServices getJdbcServices();
 
 	/**
 	 * Get the SQL dialect.
 	 * <p/>
 	 * Shorthand for {@link #getJdbcServices().getDialect()}.{@link JdbcServices#getDialect()}
 	 *
 	 * @return The dialect
 	 */
 	public Dialect getDialect();
 
 	/**
 	 * Get the factory scoped interceptor for this factory.
 	 *
 	 * @return The factory scope interceptor, or null if none.
 	 */
 	public Interceptor getInterceptor();
 
 	public QueryPlanCache getQueryPlanCache();
 
 	/**
 	 * Get the return types of a query
 	 */
 	public Type[] getReturnTypes(String queryString) throws HibernateException;
 
 	/**
 	 * Get the return aliases of a query
 	 */
 	public String[] getReturnAliases(String queryString) throws HibernateException;
 
 	/**
 	 * Get the connection provider
 	 */
 	public ConnectionProvider getConnectionProvider();
 	/**
 	 * Get the names of all persistent classes that implement/extend the given interface/class
 	 */
 	public String[] getImplementors(String className) throws MappingException;
 	/**
 	 * Get a class name, using query language imports
 	 */
 	public String getImportedClassName(String name);
 
 	/**
 	 * Get the default query cache
 	 */
 	public QueryCache getQueryCache();
 	/**
 	 * Get a particular named query cache, or the default cache
 	 * @param regionName the name of the cache region, or null for the default query cache
 	 * @return the existing cache, or a newly created cache if none by that region name
 	 */
 	public QueryCache getQueryCache(String regionName) throws HibernateException;
 
 	/**
 	 * Get the cache of table update timestamps
 	 */
 	public UpdateTimestampsCache getUpdateTimestampsCache();
 	/**
 	 * Statistics SPI
 	 */
 	public StatisticsImplementor getStatisticsImplementor();
 
 	public NamedQueryDefinition getNamedQuery(String queryName);
 	public NamedSQLQueryDefinition getNamedSQLQuery(String queryName);
 	public ResultSetMappingDefinition getResultSetMapping(String name);
 
 	/**
 	 * Get the identifier generator for the hierarchy
 	 */
 	public IdentifierGenerator getIdentifierGenerator(String rootEntityName);
 
 	/**
 	 * Get a named second-level cache region
 	 *
 	 * @param regionName The name of the region to retrieve.
 	 * @return The region
 	 */
 	public Region getSecondLevelCacheRegion(String regionName);
 
 	/**
 	 * Get a map of all the second level cache regions currently maintained in
 	 * this session factory.  The map is structured with the region name as the
 	 * key and the {@link Region} instances as the values.
 	 *
 	 * @return The map of regions
 	 */
 	public Map getAllSecondLevelCacheRegions();
 
 	/**
 	 * Retrieves the SQLExceptionConverter in effect for this SessionFactory.
 	 *
 	 * @return The SQLExceptionConverter for this SessionFactory.
 	 *
 	 */
 	public SQLExceptionConverter getSQLExceptionConverter();
 	   // TODO: deprecate???
 
 	/**
 	 * Retrieves the SqlExceptionHelper in effect for this SessionFactory.
 	 *
 	 * @return The SqlExceptionHelper for this SessionFactory.
 	 *
 	 */
     public SqlExceptionHelper getSQLExceptionHelper();
 
 	public Settings getSettings();
 
 	/**
 	 * Get a nontransactional "current" session for Hibernate EntityManager
 	 */
-	public org.hibernate.classic.Session openTemporarySession() throws HibernateException;
+	public Session openTemporarySession() throws HibernateException;
 
 	/**
 	 * Open a session conforming to the given parameters.  Used mainly by
 	 * {@link org.hibernate.context.JTASessionContext} for current session processing.
 	 *
 	 * @param connection The external jdbc connection to use, if one (i.e., optional).
 	 * @param flushBeforeCompletionEnabled Should the session be auto-flushed
 	 * prior to transaction completion?
 	 * @param autoCloseSessionEnabled Should the session be auto-closed after
 	 * transaction completion?
 	 * @param connectionReleaseMode The release mode for managed jdbc connections.
 	 * @return An appropriate session.
 	 * @throws HibernateException
 	 */
-	public org.hibernate.classic.Session openSession(
+	public Session openSession(
 			final Connection connection,
 			final boolean flushBeforeCompletionEnabled,
 			final boolean autoCloseSessionEnabled,
 			final ConnectionReleaseMode connectionReleaseMode) throws HibernateException;
 
 	/**
 	 * Retrieves a set of all the collection roles in which the given entity
 	 * is a participant, as either an index or an element.
 	 *
 	 * @param entityName The entity name for which to get the collection roles.
 	 * @return set of all the collection roles in which the given entityName participates.
 	 */
 	public Set<String> getCollectionRolesByEntityParticipant(String entityName);
 
 	public EntityNotFoundDelegate getEntityNotFoundDelegate();
 
 	public SQLFunctionRegistry getSqlFunctionRegistry();
 
 	/**
 	 * Retrieve fetch profile by name.
 	 *
 	 * @param name The name of the profile to retrieve.
 	 * @return The profile definition
 	 */
 	public FetchProfile getFetchProfile(String name);
 
 	public ServiceRegistry getServiceRegistry();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/EventListeners.java b/hibernate-core/src/main/java/org/hibernate/event/EventListeners.java
index ee970c9e73..d202233d3a 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/EventListeners.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/EventListeners.java
@@ -1,512 +1,502 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.event;
 
 import java.io.Serializable;
 import java.lang.reflect.Field;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.event.def.DefaultAutoFlushEventListener;
 import org.hibernate.event.def.DefaultDeleteEventListener;
 import org.hibernate.event.def.DefaultDirtyCheckEventListener;
 import org.hibernate.event.def.DefaultEvictEventListener;
 import org.hibernate.event.def.DefaultFlushEntityEventListener;
 import org.hibernate.event.def.DefaultFlushEventListener;
 import org.hibernate.event.def.DefaultInitializeCollectionEventListener;
 import org.hibernate.event.def.DefaultLoadEventListener;
 import org.hibernate.event.def.DefaultLockEventListener;
 import org.hibernate.event.def.DefaultMergeEventListener;
 import org.hibernate.event.def.DefaultPersistEventListener;
 import org.hibernate.event.def.DefaultPersistOnFlushEventListener;
 import org.hibernate.event.def.DefaultPostLoadEventListener;
 import org.hibernate.event.def.DefaultPreLoadEventListener;
 import org.hibernate.event.def.DefaultRefreshEventListener;
 import org.hibernate.event.def.DefaultReplicateEventListener;
 import org.hibernate.event.def.DefaultSaveEventListener;
-import org.hibernate.event.def.DefaultSaveOrUpdateCopyEventListener;
 import org.hibernate.event.def.DefaultSaveOrUpdateEventListener;
 import org.hibernate.event.def.DefaultUpdateEventListener;
 import org.hibernate.internal.util.Cloneable;
 
 /**
  * A convience holder for all defined session event listeners.
  *
  * @author Steve Ebersole
  */
 public class EventListeners extends Cloneable implements Serializable {
 
 	private LoadEventListener[] loadEventListeners = { new DefaultLoadEventListener() };
 	private SaveOrUpdateEventListener[] saveOrUpdateEventListeners = { new DefaultSaveOrUpdateEventListener() };
 	private MergeEventListener[] mergeEventListeners = { new DefaultMergeEventListener() };
 	private PersistEventListener[] persistEventListeners = { new DefaultPersistEventListener() };
 	private PersistEventListener[] persistOnFlushEventListeners = { new DefaultPersistOnFlushEventListener() };
 	private ReplicateEventListener[] replicateEventListeners = { new DefaultReplicateEventListener() };
 	private DeleteEventListener[] deleteEventListeners = { new DefaultDeleteEventListener() };
 	private AutoFlushEventListener[] autoFlushEventListeners = { new DefaultAutoFlushEventListener() };
 	private DirtyCheckEventListener[] dirtyCheckEventListeners = { new DefaultDirtyCheckEventListener() };
 	private FlushEventListener[] flushEventListeners = { new DefaultFlushEventListener() };
 	private EvictEventListener[] evictEventListeners = { new DefaultEvictEventListener() };
 	private LockEventListener[] lockEventListeners = { new DefaultLockEventListener() };
 	private RefreshEventListener[] refreshEventListeners = { new DefaultRefreshEventListener() };
 	private FlushEntityEventListener[] flushEntityEventListeners = { new DefaultFlushEntityEventListener() };
 	private InitializeCollectionEventListener[] initializeCollectionEventListeners =
 			{ new DefaultInitializeCollectionEventListener() };
 
 	private PostLoadEventListener[] postLoadEventListeners = { new DefaultPostLoadEventListener() };
 	private PreLoadEventListener[] preLoadEventListeners = { new DefaultPreLoadEventListener() };
 
 	private PreDeleteEventListener[] preDeleteEventListeners = {};
 	private PreUpdateEventListener[] preUpdateEventListeners = {};
 	private PreInsertEventListener[] preInsertEventListeners = {};
 	private PostDeleteEventListener[] postDeleteEventListeners = {};
 	private PostUpdateEventListener[] postUpdateEventListeners = {};
 	private PostInsertEventListener[] postInsertEventListeners = {};
 	private PostDeleteEventListener[] postCommitDeleteEventListeners = {};
 	private PostUpdateEventListener[] postCommitUpdateEventListeners = {};
 	private PostInsertEventListener[] postCommitInsertEventListeners = {};
 
 	private PreCollectionRecreateEventListener[] preCollectionRecreateEventListeners = {};
 	private PostCollectionRecreateEventListener[] postCollectionRecreateEventListeners = {};
 	private PreCollectionRemoveEventListener[] preCollectionRemoveEventListeners = {};
 	private PostCollectionRemoveEventListener[] postCollectionRemoveEventListeners = {};
 	private PreCollectionUpdateEventListener[] preCollectionUpdateEventListeners = {};
 	private PostCollectionUpdateEventListener[] postCollectionUpdateEventListeners = {};
 
 	private SaveOrUpdateEventListener[] saveEventListeners = { new DefaultSaveEventListener() };
 	private SaveOrUpdateEventListener[] updateEventListeners = { new DefaultUpdateEventListener() };
-	private MergeEventListener[] saveOrUpdateCopyEventListeners = { new DefaultSaveOrUpdateCopyEventListener() };//saveOrUpdateCopy() is deprecated!
 
 	private static Map eventInterfaceFromType;
 
 	static {
 		eventInterfaceFromType = new HashMap();
 
 		eventInterfaceFromType.put("auto-flush", AutoFlushEventListener.class);
 		eventInterfaceFromType.put("merge", MergeEventListener.class);
 		eventInterfaceFromType.put("create", PersistEventListener.class);
 		eventInterfaceFromType.put("create-onflush", PersistEventListener.class);
 		eventInterfaceFromType.put("delete", DeleteEventListener.class);
 		eventInterfaceFromType.put("dirty-check", DirtyCheckEventListener.class);
 		eventInterfaceFromType.put("evict", EvictEventListener.class);
 		eventInterfaceFromType.put("flush", FlushEventListener.class);
 		eventInterfaceFromType.put("flush-entity", FlushEntityEventListener.class);
 		eventInterfaceFromType.put("load", LoadEventListener.class);
 		eventInterfaceFromType.put("load-collection", InitializeCollectionEventListener.class);
 		eventInterfaceFromType.put("lock", LockEventListener.class);
 		eventInterfaceFromType.put("refresh", RefreshEventListener.class);
 		eventInterfaceFromType.put("replicate", ReplicateEventListener.class);
 		eventInterfaceFromType.put("save-update", SaveOrUpdateEventListener.class);
 		eventInterfaceFromType.put("save", SaveOrUpdateEventListener.class);
 		eventInterfaceFromType.put("update", SaveOrUpdateEventListener.class);
 		eventInterfaceFromType.put("pre-load", PreLoadEventListener.class);
 		eventInterfaceFromType.put("pre-update", PreUpdateEventListener.class);
 		eventInterfaceFromType.put("pre-delete", PreDeleteEventListener.class);
 		eventInterfaceFromType.put("pre-insert", PreInsertEventListener.class);
 		eventInterfaceFromType.put("pre-collection-recreate", PreCollectionRecreateEventListener.class);
 		eventInterfaceFromType.put("pre-collection-remove", PreCollectionRemoveEventListener.class);
 		eventInterfaceFromType.put("pre-collection-update", PreCollectionUpdateEventListener.class);
 		eventInterfaceFromType.put("post-load", PostLoadEventListener.class);
 		eventInterfaceFromType.put("post-update", PostUpdateEventListener.class);
 		eventInterfaceFromType.put("post-delete", PostDeleteEventListener.class);
 		eventInterfaceFromType.put("post-insert", PostInsertEventListener.class);
 		eventInterfaceFromType.put("post-commit-update", PostUpdateEventListener.class);
 		eventInterfaceFromType.put("post-commit-delete", PostDeleteEventListener.class);
 		eventInterfaceFromType.put("post-commit-insert", PostInsertEventListener.class);
 		eventInterfaceFromType.put("post-collection-recreate", PostCollectionRecreateEventListener.class);
 		eventInterfaceFromType.put("post-collection-remove", PostCollectionRemoveEventListener.class);
 		eventInterfaceFromType.put("post-collection-update", PostCollectionUpdateEventListener.class);
 		eventInterfaceFromType = Collections.unmodifiableMap( eventInterfaceFromType );
 	}
 
 	public Class getListenerClassFor(String type) {
 		Class clazz = (Class) eventInterfaceFromType.get(type);
 
 		if (clazz == null) {
 			throw new MappingException("Unrecognized listener type [" + type + "]");
 		}
 
 		return clazz;
 	}
 
 	private static interface ListenerProcesser {
 		public void processListener(Object listener);
 	}
 
 	private void processListeners(ListenerProcesser processer) {
 		Field[] fields = getClass().getDeclaredFields();
 		for ( int i = 0; i < fields.length; i++ ) {
 			final Object[] listeners;
 			try {
 				Object fieldValue = fields[i].get(this);
 				if ( fieldValue instanceof Object[] ) {
 					listeners = ( Object[] ) fieldValue;
 				}
 				else {
 					continue;
 				}
 			}
 			catch ( Throwable t ) {
 				throw new HibernateException( "could not init listeners", t );
 			}
 
 			int length = listeners.length;
 			for ( int index = 0 ; index < length ; index++ ) {
 				processer.processListener( listeners[index ] );
 			}
 		}
 	}
 
 	/**
 	 * Call {@link Initializable#initialize} on any listeners that implement the
 	 * {@link Initializable} interface.
 	 *
 	 * @param cfg The configuration.
 	 */
 	public void initializeListeners(final Configuration cfg) {
 		try {
 			processListeners(
 					new ListenerProcesser() {
 						public void processListener(Object listener) {
 							if ( listener instanceof Initializable ) {
 								( ( Initializable ) listener ).initialize( cfg );
 							}
 						}
 					}
 			);
 		}
 		catch ( Exception e ) {
 			throw new HibernateException("could not init listeners", e);
 		}
 	}
 
 	/**
 	 * Call {@link Destructible#cleanup} on any listeners that implement the
 	 * {@link Destructible} interface.
 	 */
 	public void destroyListeners() {
 		try {
 			processListeners(
 					new ListenerProcesser() {
 						public void processListener(Object listener) {
 							if ( listener instanceof Destructible ) {
 								( ( Destructible ) listener ).cleanup();
 							}
 						}
 					}
 			);
 		}
 		catch ( Exception e ) {
 			throw new HibernateException("could not destruct listeners", e);
 		}
 	}
 
 	public LoadEventListener[] getLoadEventListeners() {
         return loadEventListeners;
     }
 
     public void setLoadEventListeners(LoadEventListener[] loadEventListener) {
         this.loadEventListeners = loadEventListener;
     }
 
 	public ReplicateEventListener[] getReplicateEventListeners() {
 		return replicateEventListeners;
 	}
 
 	public void setReplicateEventListeners(ReplicateEventListener[] replicateEventListener) {
 		this.replicateEventListeners = replicateEventListener;
 	}
 
 	public DeleteEventListener[] getDeleteEventListeners() {
 		return deleteEventListeners;
 	}
 
 	public void setDeleteEventListeners(DeleteEventListener[] deleteEventListener) {
 		this.deleteEventListeners = deleteEventListener;
 	}
 
 	public AutoFlushEventListener[] getAutoFlushEventListeners() {
 		return autoFlushEventListeners;
 	}
 
 	public void setAutoFlushEventListeners(AutoFlushEventListener[] autoFlushEventListener) {
 		this.autoFlushEventListeners = autoFlushEventListener;
 	}
 
 	public DirtyCheckEventListener[] getDirtyCheckEventListeners() {
 		return dirtyCheckEventListeners;
 	}
 
 	public void setDirtyCheckEventListeners(DirtyCheckEventListener[] dirtyCheckEventListener) {
 		this.dirtyCheckEventListeners = dirtyCheckEventListener;
 	}
 
 	public FlushEventListener[] getFlushEventListeners() {
 		return flushEventListeners;
 	}
 
 	public void setFlushEventListeners(FlushEventListener[] flushEventListener) {
 		this.flushEventListeners = flushEventListener;
 	}
 
 	public EvictEventListener[] getEvictEventListeners() {
 		return evictEventListeners;
 	}
 
 	public void setEvictEventListeners(EvictEventListener[] evictEventListener) {
 		this.evictEventListeners = evictEventListener;
 	}
 
 	public LockEventListener[] getLockEventListeners() {
 		return lockEventListeners;
 	}
 
 	public void setLockEventListeners(LockEventListener[] lockEventListener) {
 		this.lockEventListeners = lockEventListener;
 	}
 
 	public RefreshEventListener[] getRefreshEventListeners() {
 		return refreshEventListeners;
 	}
 
 	public void setRefreshEventListeners(RefreshEventListener[] refreshEventListener) {
 		this.refreshEventListeners = refreshEventListener;
 	}
 
 	public InitializeCollectionEventListener[] getInitializeCollectionEventListeners() {
 		return initializeCollectionEventListeners;
 	}
 
 	public void setInitializeCollectionEventListeners(InitializeCollectionEventListener[] initializeCollectionEventListener) {
 		this.initializeCollectionEventListeners = initializeCollectionEventListener;
 	}
 
 	public FlushEntityEventListener[] getFlushEntityEventListeners() {
 		return flushEntityEventListeners;
 	}
 
 	public void setFlushEntityEventListeners(FlushEntityEventListener[] flushEntityEventListener) {
 		this.flushEntityEventListeners = flushEntityEventListener;
 	}
 
 	public SaveOrUpdateEventListener[] getSaveOrUpdateEventListeners() {
 		return saveOrUpdateEventListeners;
 	}
 
 	public void setSaveOrUpdateEventListeners(SaveOrUpdateEventListener[] saveOrUpdateEventListener) {
 		this.saveOrUpdateEventListeners = saveOrUpdateEventListener;
 	}
 
 	public MergeEventListener[] getMergeEventListeners() {
 		return mergeEventListeners;
 	}
 
 	public void setMergeEventListeners(MergeEventListener[] mergeEventListener) {
 		this.mergeEventListeners = mergeEventListener;
 	}
 
 	public PersistEventListener[] getPersistEventListeners() {
 		return persistEventListeners;
 	}
 
 	public void setPersistEventListeners(PersistEventListener[] createEventListener) {
 		this.persistEventListeners = createEventListener;
 	}
 
 	public PersistEventListener[] getPersistOnFlushEventListeners() {
 		return persistOnFlushEventListeners;
 	}
 
 	public void setPersistOnFlushEventListeners(PersistEventListener[] createEventListener) {
 		this.persistOnFlushEventListeners = createEventListener;
 	}
 
-	public MergeEventListener[] getSaveOrUpdateCopyEventListeners() {
-		return saveOrUpdateCopyEventListeners;
-	}
-
-	public void setSaveOrUpdateCopyEventListeners(MergeEventListener[] saveOrUpdateCopyEventListener) {
-		this.saveOrUpdateCopyEventListeners = saveOrUpdateCopyEventListener;
-	}
-
 	public SaveOrUpdateEventListener[] getSaveEventListeners() {
 		return saveEventListeners;
 	}
 
 	public void setSaveEventListeners(SaveOrUpdateEventListener[] saveEventListener) {
 		this.saveEventListeners = saveEventListener;
 	}
 
 	public SaveOrUpdateEventListener[] getUpdateEventListeners() {
 		return updateEventListeners;
 	}
 
 	public void setUpdateEventListeners(SaveOrUpdateEventListener[] updateEventListener) {
 		this.updateEventListeners = updateEventListener;
 	}
 
 	public PostLoadEventListener[] getPostLoadEventListeners() {
 		return postLoadEventListeners;
 	}
 
 	public void setPostLoadEventListeners(PostLoadEventListener[] postLoadEventListener) {
 		this.postLoadEventListeners = postLoadEventListener;
 	}
 
 	public PreLoadEventListener[] getPreLoadEventListeners() {
 		return preLoadEventListeners;
 	}
 
 	public void setPreLoadEventListeners(PreLoadEventListener[] preLoadEventListener) {
 		this.preLoadEventListeners = preLoadEventListener;
 	}
 
 	public PreCollectionRecreateEventListener[] getPreCollectionRecreateEventListeners() {
 		return preCollectionRecreateEventListeners;
 	}
 
 	public void setPreCollectionRecreateEventListeners(PreCollectionRecreateEventListener[] preCollectionRecreateEventListener) {
 		this.preCollectionRecreateEventListeners = preCollectionRecreateEventListener;
 	}
 
 	public PreCollectionRemoveEventListener[] getPreCollectionRemoveEventListeners() {
 		return preCollectionRemoveEventListeners;
 	}
 
 	public void setPreCollectionRemoveEventListeners(PreCollectionRemoveEventListener[] preCollectionRemoveEventListener) {
 		this.preCollectionRemoveEventListeners = preCollectionRemoveEventListener;
 	}
 
 	public PreCollectionUpdateEventListener[] getPreCollectionUpdateEventListeners() {
 		return preCollectionUpdateEventListeners;
 	}
 
 	public void setPreCollectionUpdateEventListeners(PreCollectionUpdateEventListener[] preCollectionUpdateEventListeners) {
 		this.preCollectionUpdateEventListeners = preCollectionUpdateEventListeners;
 	}
 
 	public PostDeleteEventListener[] getPostDeleteEventListeners() {
 		return postDeleteEventListeners;
 	}
 
 	public PostInsertEventListener[] getPostInsertEventListeners() {
 		return postInsertEventListeners;
 	}
 
 	public PostUpdateEventListener[] getPostUpdateEventListeners() {
 		return postUpdateEventListeners;
 	}
 
 	public void setPostDeleteEventListeners(PostDeleteEventListener[] postDeleteEventListener) {
 		this.postDeleteEventListeners = postDeleteEventListener;
 	}
 
 	public void setPostInsertEventListeners(PostInsertEventListener[] postInsertEventListener) {
 		this.postInsertEventListeners = postInsertEventListener;
 	}
 
 	public void setPostUpdateEventListeners(PostUpdateEventListener[] postUpdateEventListener) {
 		this.postUpdateEventListeners = postUpdateEventListener;
 	}
 
 	public PostCollectionRecreateEventListener[] getPostCollectionRecreateEventListeners() {
 		return postCollectionRecreateEventListeners;
 	}
 
 	public void setPostCollectionRecreateEventListeners(PostCollectionRecreateEventListener[] postCollectionRecreateEventListener) {
 		this.postCollectionRecreateEventListeners = postCollectionRecreateEventListener;
 	}
 
 	public PostCollectionRemoveEventListener[] getPostCollectionRemoveEventListeners() {
 		return postCollectionRemoveEventListeners;
 	}
 
 	public void setPostCollectionRemoveEventListeners(PostCollectionRemoveEventListener[] postCollectionRemoveEventListener) {
 		this.postCollectionRemoveEventListeners = postCollectionRemoveEventListener;
 	}
 
 	public PostCollectionUpdateEventListener[] getPostCollectionUpdateEventListeners() {
 		return postCollectionUpdateEventListeners;
 	}
 
 	public void setPostCollectionUpdateEventListeners(PostCollectionUpdateEventListener[] postCollectionUpdateEventListeners) {
 		this.postCollectionUpdateEventListeners = postCollectionUpdateEventListeners;
 	}
 
 	public PreDeleteEventListener[] getPreDeleteEventListeners() {
 		return preDeleteEventListeners;
 	}
 
 	public void setPreDeleteEventListeners(PreDeleteEventListener[] preDeleteEventListener) {
 		this.preDeleteEventListeners = preDeleteEventListener;
 	}
 
 	public PreInsertEventListener[] getPreInsertEventListeners() {
 		return preInsertEventListeners;
 	}
 
 	public void setPreInsertEventListeners(PreInsertEventListener[] preInsertEventListener) {
 		this.preInsertEventListeners = preInsertEventListener;
 	}
 
 	public PreUpdateEventListener[] getPreUpdateEventListeners() {
 		return preUpdateEventListeners;
 	}
 
 	public void setPreUpdateEventListeners(PreUpdateEventListener[] preUpdateEventListener) {
 		this.preUpdateEventListeners = preUpdateEventListener;
 	}
 
 	public PostDeleteEventListener[] getPostCommitDeleteEventListeners() {
 		return postCommitDeleteEventListeners;
 	}
 
 	public void setPostCommitDeleteEventListeners(
 			PostDeleteEventListener[] postCommitDeleteEventListeners) {
 		this.postCommitDeleteEventListeners = postCommitDeleteEventListeners;
 	}
 
 	public PostInsertEventListener[] getPostCommitInsertEventListeners() {
 		return postCommitInsertEventListeners;
 	}
 
 	public void setPostCommitInsertEventListeners(
 			PostInsertEventListener[] postCommitInsertEventListeners) {
 		this.postCommitInsertEventListeners = postCommitInsertEventListeners;
 	}
 
 	public PostUpdateEventListener[] getPostCommitUpdateEventListeners() {
 		return postCommitUpdateEventListeners;
 	}
 
 	public void setPostCommitUpdateEventListeners(
 			PostUpdateEventListener[] postCommitUpdateEventListeners) {
 		this.postCommitUpdateEventListeners = postCommitUpdateEventListeners;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/EventSource.java b/hibernate-core/src/main/java/org/hibernate/event/EventSource.java
index 2e1341474d..127d67e2f4 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/EventSource.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/EventSource.java
@@ -1,84 +1,79 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.event;
 import java.io.Serializable;
 import java.util.Map;
 import java.util.Set;
 import org.hibernate.HibernateException;
 import org.hibernate.Session;
 import org.hibernate.engine.ActionQueue;
 import org.hibernate.engine.EntityEntry;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * @author Gavin King
  */
 public interface EventSource extends SessionImplementor, Session {
 	
 	/**
 	 * Get the ActionQueue for this session
 	 */
 	public ActionQueue getActionQueue();
 
 	/**
 	 * Instantiate an entity instance, using either an interceptor,
 	 * or the given persister
 	 */
 	public Object instantiate(EntityPersister persister, Serializable id) throws HibernateException;
 
 	/**
 	 * Force an immediate flush
 	 */
 	public void forceFlush(EntityEntry e) throws HibernateException;
 
 	/**
 	 * Cascade merge an entity instance
 	 */
 	public void merge(String entityName, Object object, Map copiedAlready) throws HibernateException;
 	/**
 	 * Cascade persist an entity instance
 	 */
 	public void persist(String entityName, Object object, Map createdAlready) throws HibernateException;
 
 	/**
 	 * Cascade persist an entity instance during the flush process
 	 */
 	public void persistOnFlush(String entityName, Object object, Map copiedAlready);
 	/**
 	 * Cascade refesh an entity instance
 	 */
 	public void refresh(Object object, Map refreshedAlready) throws HibernateException;
 	/**
-	 * Cascade copy an entity instance
-	 */
-	public void saveOrUpdateCopy(String entityName, Object object, Map copiedAlready) throws HibernateException;
-	
-	/**
 	 * Cascade delete an entity instance
 	 */
 	public void delete(String entityName, Object child, boolean isCascadeDeleteEnabled, Set transientEntities);
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractSaveEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/def/AbstractSaveEventListener.java
index 13893d05fd..3b06992e53 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/def/AbstractSaveEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/def/AbstractSaveEventListener.java
@@ -1,521 +1,515 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.event.def;
+
 import java.io.Serializable;
 import java.util.Map;
+
+import org.jboss.logging.Logger;
+
 import org.hibernate.HibernateLogger;
 import org.hibernate.LockMode;
 import org.hibernate.NonUniqueObjectException;
 import org.hibernate.action.internal.EntityIdentityInsertAction;
 import org.hibernate.action.internal.EntityInsertAction;
 import org.hibernate.bytecode.instrumentation.internal.FieldInterceptionHelper;
+import org.hibernate.bytecode.instrumentation.spi.FieldInterceptor;
 import org.hibernate.classic.Lifecycle;
-import org.hibernate.classic.Validatable;
 import org.hibernate.engine.Cascade;
 import org.hibernate.engine.CascadingAction;
 import org.hibernate.engine.EntityEntry;
 import org.hibernate.engine.EntityKey;
 import org.hibernate.engine.ForeignKeys;
 import org.hibernate.engine.Nullability;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.Status;
 import org.hibernate.engine.Versioning;
 import org.hibernate.event.EventSource;
 import org.hibernate.id.IdentifierGenerationException;
 import org.hibernate.id.IdentifierGeneratorHelper;
-import org.hibernate.bytecode.instrumentation.spi.FieldInterceptor;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeHelper;
-import org.jboss.logging.Logger;
 
 /**
  * A convenience bas class for listeners responding to save events.
  *
  * @author Steve Ebersole.
  */
 public abstract class AbstractSaveEventListener extends AbstractReassociateEventListener {
 
 	protected static final int PERSISTENT = 0;
 	protected static final int TRANSIENT = 1;
 	protected static final int DETACHED = 2;
 	protected static final int DELETED = 3;
 
     private static final HibernateLogger LOG = Logger.getMessageLogger(HibernateLogger.class,
                                                                        AbstractSaveEventListener.class.getName());
 
 	/**
 	 * Prepares the save call using the given requested id.
 	 *
 	 * @param entity The entity to be saved.
 	 * @param requestedId The id to which to associate the entity.
 	 * @param entityName The name of the entity being saved.
 	 * @param anything Generally cascade-specific information.
 	 * @param source The session which is the source of this save event.
 	 *
 	 * @return The id used to save the entity.
 	 */
 	protected Serializable saveWithRequestedId(
 			Object entity,
 			Serializable requestedId,
 			String entityName,
 			Object anything,
 			EventSource source) {
 		return performSave(
 				entity,
 				requestedId,
 				source.getEntityPersister( entityName, entity ),
 				false,
 				anything,
 				source,
 				true
 		);
 	}
 
 	/**
 	 * Prepares the save call using a newly generated id.
 	 *
 	 * @param entity The entity to be saved
 	 * @param entityName The entity-name for the entity to be saved
 	 * @param anything Generally cascade-specific information.
 	 * @param source The session which is the source of this save event.
 	 * @param requiresImmediateIdAccess does the event context require
 	 * access to the identifier immediately after execution of this method (if
 	 * not, post-insert style id generators may be postponed if we are outside
 	 * a transaction).
 	 *
 	 * @return The id used to save the entity; may be null depending on the
 	 *         type of id generator used and the requiresImmediateIdAccess value
 	 */
 	protected Serializable saveWithGeneratedId(
 			Object entity,
 			String entityName,
 			Object anything,
 			EventSource source,
 			boolean requiresImmediateIdAccess) {
 		EntityPersister persister = source.getEntityPersister( entityName, entity );
 		Serializable generatedId = persister.getIdentifierGenerator().generate( source, entity );
 		if ( generatedId == null ) {
 			throw new IdentifierGenerationException( "null id generated for:" + entity.getClass() );
 		}
 		else if ( generatedId == IdentifierGeneratorHelper.SHORT_CIRCUIT_INDICATOR ) {
 			return source.getIdentifier( entity );
 		}
 		else if ( generatedId == IdentifierGeneratorHelper.POST_INSERT_INDICATOR ) {
 			return performSave( entity, null, persister, true, anything, source, requiresImmediateIdAccess );
 		}
 		else {
             // TODO: define toString()s for generators
             if (LOG.isDebugEnabled()) LOG.debugf("Generated identifier: %s, using strategy: %s",
                                                  persister.getIdentifierType().toLoggableString(generatedId, source.getFactory()),
                                                  persister.getIdentifierGenerator().getClass().getName());
 
 			return performSave( entity, generatedId, persister, false, anything, source, true );
 		}
 	}
 
 	/**
 	 * Ppepares the save call by checking the session caches for a pre-existing
 	 * entity and performing any lifecycle callbacks.
 	 *
 	 * @param entity The entity to be saved.
 	 * @param id The id by which to save the entity.
 	 * @param persister The entity's persister instance.
 	 * @param useIdentityColumn Is an identity column being used?
 	 * @param anything Generally cascade-specific information.
 	 * @param source The session from which the event originated.
 	 * @param requiresImmediateIdAccess does the event context require
 	 * access to the identifier immediately after execution of this method (if
 	 * not, post-insert style id generators may be postponed if we are outside
 	 * a transaction).
 	 *
 	 * @return The id used to save the entity; may be null depending on the
 	 *         type of id generator used and the requiresImmediateIdAccess value
 	 */
 	protected Serializable performSave(
 			Object entity,
 			Serializable id,
 			EntityPersister persister,
 			boolean useIdentityColumn,
 			Object anything,
 			EventSource source,
 			boolean requiresImmediateIdAccess) {
 
         if (LOG.isTraceEnabled()) LOG.trace("Saving " + MessageHelper.infoString(persister, id, source.getFactory()));
 
 		EntityKey key;
 		if ( !useIdentityColumn ) {
 			key = new EntityKey( id, persister, source.getEntityMode() );
 			Object old = source.getPersistenceContext().getEntity( key );
 			if ( old != null ) {
 				if ( source.getPersistenceContext().getEntry( old ).getStatus() == Status.DELETED ) {
 					source.forceFlush( source.getPersistenceContext().getEntry( old ) );
 				}
 				else {
 					throw new NonUniqueObjectException( id, persister.getEntityName() );
 				}
 			}
 			persister.setIdentifier( entity, id, source );
 		}
 		else {
 			key = null;
 		}
 
 		if ( invokeSaveLifecycle( entity, persister, source ) ) {
 			return id; //EARLY EXIT
 		}
 
 		return performSaveOrReplicate(
 				entity,
 				key,
 				persister,
 				useIdentityColumn,
 				anything,
 				source,
 				requiresImmediateIdAccess
 		);
 	}
 
 	protected boolean invokeSaveLifecycle(Object entity, EntityPersister persister, EventSource source) {
 		// Sub-insertions should occur before containing insertion so
 		// Try to do the callback now
 		if ( persister.implementsLifecycle( source.getEntityMode() ) ) {
             LOG.debugf("Calling onSave()");
 			if ( ( ( Lifecycle ) entity ).onSave( source ) ) {
                 LOG.debugf("Insertion vetoed by onSave()");
 				return true;
 			}
 		}
 		return false;
 	}
 
-	protected void validate(Object entity, EntityPersister persister, EventSource source) {
-		if ( persister.implementsValidatable( source.getEntityMode() ) ) {
-			( ( Validatable ) entity ).validate();
-		}
-	}
-
 	/**
 	 * Performs all the actual work needed to save an entity (well to get the save moved to
 	 * the execution queue).
 	 *
 	 * @param entity The entity to be saved
 	 * @param key The id to be used for saving the entity (or null, in the case of identity columns)
 	 * @param persister The entity's persister instance.
 	 * @param useIdentityColumn Should an identity column be used for id generation?
 	 * @param anything Generally cascade-specific information.
 	 * @param source The session which is the source of the current event.
 	 * @param requiresImmediateIdAccess Is access to the identifier required immediately
 	 * after the completion of the save?  persist(), for example, does not require this...
 	 *
 	 * @return The id used to save the entity; may be null depending on the
 	 *         type of id generator used and the requiresImmediateIdAccess value
 	 */
 	protected Serializable performSaveOrReplicate(
 			Object entity,
 			EntityKey key,
 			EntityPersister persister,
 			boolean useIdentityColumn,
 			Object anything,
 			EventSource source,
 			boolean requiresImmediateIdAccess) {
 
-		validate( entity, persister, source );
-
 		Serializable id = key == null ? null : key.getIdentifier();
 
 		boolean inTxn = source.getTransactionCoordinator().isTransactionInProgress();
 		boolean shouldDelayIdentityInserts = !inTxn && !requiresImmediateIdAccess;
 
 		// Put a placeholder in entries, so we don't recurse back and try to save() the
 		// same object again. QUESTION: should this be done before onSave() is called?
 		// likewise, should it be done before onUpdate()?
 		source.getPersistenceContext().addEntry(
 				entity,
 				Status.SAVING,
 				null,
 				null,
 				id,
 				null,
 				LockMode.WRITE,
 				useIdentityColumn,
 				persister,
 				false,
 				false
 		);
 
 		cascadeBeforeSave( source, persister, entity, anything );
 
 		if ( useIdentityColumn && !shouldDelayIdentityInserts ) {
             LOG.trace("Executing insertions");
 			source.getActionQueue().executeInserts();
 		}
 
 		Object[] values = persister.getPropertyValuesToInsert( entity, getMergeMap( anything ), source );
 		Type[] types = persister.getPropertyTypes();
 
 		boolean substitute = substituteValuesIfNecessary( entity, id, values, persister, source );
 
 		if ( persister.hasCollections() ) {
 			substitute = substitute || visitCollectionsBeforeSave( entity, id, values, types, source );
 		}
 
 		if ( substitute ) {
 			persister.setPropertyValues( entity, values, source.getEntityMode() );
 		}
 
 		TypeHelper.deepCopy(
 				values,
 				types,
 				persister.getPropertyUpdateability(),
 				values,
 				source
 		);
 
 		new ForeignKeys.Nullifier( entity, false, useIdentityColumn, source )
 				.nullifyTransientReferences( values, types );
 		new Nullability( source ).checkNullability( values, persister, false );
 
 		if ( useIdentityColumn ) {
 			EntityIdentityInsertAction insert = new EntityIdentityInsertAction(
 					values, entity, persister, source, shouldDelayIdentityInserts
 			);
 			if ( !shouldDelayIdentityInserts ) {
                 LOG.debugf("Executing identity-insert immediately");
 				source.getActionQueue().execute( insert );
 				id = insert.getGeneratedId();
 				key = new EntityKey( id, persister, source.getEntityMode() );
 				source.getPersistenceContext().checkUniqueness( key, entity );
 			}
 			else {
                 LOG.debugf("Delaying identity-insert due to no transaction in progress");
 				source.getActionQueue().addAction( insert );
 				key = insert.getDelayedEntityKey();
 			}
 		}
 
 		Object version = Versioning.getVersion( values, persister );
 		source.getPersistenceContext().addEntity(
 				entity,
 				( persister.isMutable() ? Status.MANAGED : Status.READ_ONLY ),
 				values,
 				key,
 				version,
 				LockMode.WRITE,
 				useIdentityColumn,
 				persister,
 				isVersionIncrementDisabled(),
 				false
 		);
 		//source.getPersistenceContext().removeNonExist( new EntityKey( id, persister, source.getEntityMode() ) );
 
 		if ( !useIdentityColumn ) {
 			source.getActionQueue().addAction(
 					new EntityInsertAction( id, values, entity, version, persister, source )
 			);
 		}
 
 		cascadeAfterSave( source, persister, entity, anything );
 
 		markInterceptorDirty( entity, persister, source );
 
 		return id;
 	}
 
 	private void markInterceptorDirty(Object entity, EntityPersister persister, EventSource source) {
 		if ( FieldInterceptionHelper.isInstrumented( entity ) ) {
 			FieldInterceptor interceptor = FieldInterceptionHelper.injectFieldInterceptor(
 					entity,
 					persister.getEntityName(),
 					null,
 					source
 			);
 			interceptor.dirty();
 		}
 	}
 
 	protected Map getMergeMap(Object anything) {
 		return null;
 	}
 
 	/**
 	 * After the save, will te version number be incremented
 	 * if the instance is modified?
 	 *
 	 * @return True if the version will be incremented on an entity change after save;
 	 *         false otherwise.
 	 */
 	protected boolean isVersionIncrementDisabled() {
 		return false;
 	}
 
 	protected boolean visitCollectionsBeforeSave(Object entity, Serializable id, Object[] values, Type[] types, EventSource source) {
 		WrapVisitor visitor = new WrapVisitor( source );
 		// substitutes into values by side-effect
 		visitor.processEntityPropertyValues( values, types );
 		return visitor.isSubstitutionRequired();
 	}
 
 	/**
 	 * Perform any property value substitution that is necessary
 	 * (interceptor callback, version initialization...)
 	 *
 	 * @param entity The entity
 	 * @param id The entity identifier
 	 * @param values The snapshot entity state
 	 * @param persister The entity persister
 	 * @param source The originating session
 	 *
 	 * @return True if the snapshot state changed such that
 	 * reinjection of the values into the entity is required.
 	 */
 	protected boolean substituteValuesIfNecessary(
 			Object entity,
 			Serializable id,
 			Object[] values,
 			EntityPersister persister,
 			SessionImplementor source) {
 		boolean substitute = source.getInterceptor().onSave(
 				entity,
 				id,
 				values,
 				persister.getPropertyNames(),
 				persister.getPropertyTypes()
 		);
 
 		//keep the existing version number in the case of replicate!
 		if ( persister.isVersioned() ) {
 			substitute = Versioning.seedVersion(
 					values,
 					persister.getVersionProperty(),
 					persister.getVersionType(),
 					source
 			) || substitute;
 		}
 		return substitute;
 	}
 
 	/**
 	 * Handles the calls needed to perform pre-save cascades for the given entity.
 	 *
 	 * @param source The session from whcih the save event originated.
 	 * @param persister The entity's persister instance.
 	 * @param entity The entity to be saved.
 	 * @param anything Generally cascade-specific data
 	 */
 	protected void cascadeBeforeSave(
 			EventSource source,
 			EntityPersister persister,
 			Object entity,
 			Object anything) {
 
 		// cascade-save to many-to-one BEFORE the parent is saved
 		source.getPersistenceContext().incrementCascadeLevel();
 		try {
 			new Cascade( getCascadeAction(), Cascade.BEFORE_INSERT_AFTER_DELETE, source )
 					.cascade( persister, entity, anything );
 		}
 		finally {
 			source.getPersistenceContext().decrementCascadeLevel();
 		}
 	}
 
 	/**
 	 * Handles to calls needed to perform post-save cascades.
 	 *
 	 * @param source The session from which the event originated.
 	 * @param persister The entity's persister instance.
 	 * @param entity The entity beng saved.
 	 * @param anything Generally cascade-specific data
 	 */
 	protected void cascadeAfterSave(
 			EventSource source,
 			EntityPersister persister,
 			Object entity,
 			Object anything) {
 
 		// cascade-save to collections AFTER the collection owner was saved
 		source.getPersistenceContext().incrementCascadeLevel();
 		try {
 			new Cascade( getCascadeAction(), Cascade.AFTER_INSERT_BEFORE_DELETE, source )
 					.cascade( persister, entity, anything );
 		}
 		finally {
 			source.getPersistenceContext().decrementCascadeLevel();
 		}
 	}
 
 	protected abstract CascadingAction getCascadeAction();
 
 	/**
 	 * Determine whether the entity is persistent, detached, or transient
 	 *
 	 * @param entity The entity to check
 	 * @param entityName The name of the entity
 	 * @param entry The entity's entry in the persistence context
 	 * @param source The originating session.
 	 *
 	 * @return The state.
 	 */
 	protected int getEntityState(
 			Object entity,
 			String entityName,
 			EntityEntry entry, //pass this as an argument only to avoid double looking
 			SessionImplementor source) {
 
 		if ( entry != null ) { // the object is persistent
 
 			//the entity is associated with the session, so check its status
 			if ( entry.getStatus() != Status.DELETED ) {
 				// do nothing for persistent instances
                 if (LOG.isTraceEnabled()) LOG.trace("Persistent instance of: " + getLoggableName(entityName, entity));
 				return PERSISTENT;
 			}
             // ie. e.status==DELETED
             if (LOG.isTraceEnabled()) LOG.trace("Deleted instance of: " + getLoggableName(entityName, entity));
             return DELETED;
 
 		}
         // the object is transient or detached
 
 		// the entity is not associated with the session, so
         // try interceptor and unsaved-value
 
 		if (ForeignKeys.isTransient(entityName, entity, getAssumedUnsaved(), source)) {
             if (LOG.isTraceEnabled()) LOG.trace("Transient instance of: " + getLoggableName(entityName, entity));
             return TRANSIENT;
 		}
         if (LOG.isTraceEnabled()) LOG.trace("Detached instance of: " + getLoggableName(entityName, entity));
         return DETACHED;
 	}
 
 	protected String getLoggableName(String entityName, Object entity) {
 		return entityName == null ? entity.getClass().getName() : entityName;
 	}
 
 	protected Boolean getAssumedUnsaved() {
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultFlushEntityEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/def/DefaultFlushEntityEventListener.java
index 74b475c7a5..2d96162a21 100755
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultFlushEntityEventListener.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/def/DefaultFlushEntityEventListener.java
@@ -1,581 +1,564 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
+ * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
- *
  */
 package org.hibernate.event.def;
 
 import java.io.Serializable;
+
+import org.jboss.logging.Logger;
+
 import org.hibernate.AssertionFailure;
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.HibernateLogger;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.action.internal.DelayedPostInsertIdentifier;
 import org.hibernate.action.internal.EntityUpdateAction;
-import org.hibernate.classic.Validatable;
+import org.hibernate.bytecode.instrumentation.internal.FieldInterceptionHelper;
 import org.hibernate.engine.EntityEntry;
 import org.hibernate.engine.EntityKey;
 import org.hibernate.engine.Nullability;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.Status;
 import org.hibernate.engine.Versioning;
 import org.hibernate.event.EventSource;
 import org.hibernate.event.FlushEntityEvent;
 import org.hibernate.event.FlushEntityEventListener;
-import org.hibernate.bytecode.instrumentation.internal.FieldInterceptionHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.type.Type;
-import org.jboss.logging.Logger;
 
 /**
  * An event that occurs for each entity instance at flush time
  *
  * @author Gavin King
  */
 public class DefaultFlushEntityEventListener implements FlushEntityEventListener {
 
     private static final HibernateLogger LOG = Logger.getMessageLogger(HibernateLogger.class,
                                                                        DefaultFlushEntityEventListener.class.getName());
 
 	/**
 	 * make sure user didn't mangle the id
 	 */
 	public void checkId(
 			Object object,
 			EntityPersister persister,
 			Serializable id,
 			EntityMode entityMode,
 			SessionImplementor session) throws HibernateException {
 
 		if ( id != null && id instanceof DelayedPostInsertIdentifier ) {
 			// this is a situation where the entity id is assigned by a post-insert generator
 			// and was saved outside the transaction forcing it to be delayed
 			return;
 		}
 
 		if ( persister.canExtractIdOutOfEntity() ) {
 
 			Serializable oid = persister.getIdentifier( object, session );
 			if (id==null) {
 				throw new AssertionFailure("null id in " + persister.getEntityName() + " entry (don't flush the Session after an exception occurs)");
 			}
 			if ( !persister.getIdentifierType().isEqual( id, oid, entityMode, session.getFactory() ) ) {
 				throw new HibernateException(
 						"identifier of an instance of " +
 						persister.getEntityName() +
 						" was altered from " + id +
 						" to " + oid
 					);
 			}
 		}
 
 	}
 
 	private void checkNaturalId(
 			EntityPersister persister,
 	        EntityEntry entry,
 	        Object[] current,
 	        Object[] loaded,
 	        EntityMode entityMode,
 	        SessionImplementor session) {
 		if ( persister.hasNaturalIdentifier() && entry.getStatus() != Status.READ_ONLY ) {
  			Object[] snapshot = null;
 			Type[] types = persister.getPropertyTypes();
 			int[] props = persister.getNaturalIdentifierProperties();
 			boolean[] updateable = persister.getPropertyUpdateability();
 			for ( int i=0; i<props.length; i++ ) {
 				int prop = props[i];
 				if ( !updateable[prop] ) {
  					Object loadedVal;
  					if ( loaded == null ) {
  						if ( snapshot == null) {
  							snapshot = session.getPersistenceContext().getNaturalIdSnapshot( entry.getId(), persister );
  						}
  						loadedVal = snapshot[i];
  					} else {
  						loadedVal = loaded[prop];
  					}
  					if ( !types[prop].isEqual( current[prop], loadedVal, entityMode ) ) {
 						throw new HibernateException(
 								"immutable natural identifier of an instance of " +
 								persister.getEntityName() +
 								" was altered"
 							);
 					}
 				}
 			}
 		}
 	}
 
 	/**
 	 * Flushes a single entity's state to the database, by scheduling
 	 * an update action, if necessary
 	 */
 	public void onFlushEntity(FlushEntityEvent event) throws HibernateException {
 		final Object entity = event.getEntity();
 		final EntityEntry entry = event.getEntityEntry();
 		final EventSource session = event.getSession();
 		final EntityPersister persister = entry.getPersister();
 		final Status status = entry.getStatus();
 		final EntityMode entityMode = session.getEntityMode();
 		final Type[] types = persister.getPropertyTypes();
 
 		final boolean mightBeDirty = entry.requiresDirtyCheck(entity);
 
 		final Object[] values = getValues( entity, entry, entityMode, mightBeDirty, session );
 
 		event.setPropertyValues(values);
 
 		//TODO: avoid this for non-new instances where mightBeDirty==false
 		boolean substitute = wrapCollections( session, persister, types, values);
 
 		if ( isUpdateNecessary( event, mightBeDirty ) ) {
 			substitute = scheduleUpdate( event ) || substitute;
 		}
 
 		if ( status != Status.DELETED ) {
 			// now update the object .. has to be outside the main if block above (because of collections)
 			if (substitute) persister.setPropertyValues( entity, values, entityMode );
 
 			// Search for collections by reachability, updating their role.
 			// We don't want to touch collections reachable from a deleted object
 			if ( persister.hasCollections() ) {
 				new FlushVisitor(session, entity).processEntityPropertyValues(values, types);
 			}
 		}
 
 	}
 
 	private Object[] getValues(
 			Object entity,
 			EntityEntry entry,
 			EntityMode entityMode,
 			boolean mightBeDirty,
 	        SessionImplementor session) {
 		final Object[] loadedState = entry.getLoadedState();
 		final Status status = entry.getStatus();
 		final EntityPersister persister = entry.getPersister();
 
 		final Object[] values;
 		if ( status == Status.DELETED ) {
 			//grab its state saved at deletion
 			values = entry.getDeletedState();
 		}
 		else if ( !mightBeDirty && loadedState!=null ) {
 			values = loadedState;
 		}
 		else {
 			checkId( entity, persister, entry.getId(), entityMode, session );
 
 			// grab its current state
 			values = persister.getPropertyValues( entity, entityMode );
 
 			checkNaturalId( persister, entry, values, loadedState, entityMode, session );
 		}
 		return values;
 	}
 
 	private boolean wrapCollections(
 			EventSource session,
 			EntityPersister persister,
 			Type[] types,
 			Object[] values
 	) {
 		if ( persister.hasCollections() ) {
 
 			// wrap up any new collections directly referenced by the object
 			// or its components
 
 			// NOTE: we need to do the wrap here even if its not "dirty",
 			// because collections need wrapping but changes to _them_
 			// don't dirty the container. Also, for versioned data, we
 			// need to wrap before calling searchForDirtyCollections
 
 			WrapVisitor visitor = new WrapVisitor(session);
 			// substitutes into values by side-effect
 			visitor.processEntityPropertyValues(values, types);
 			return visitor.isSubstitutionRequired();
 		}
 		else {
 			return false;
 		}
 	}
 
 	private boolean isUpdateNecessary(final FlushEntityEvent event, final boolean mightBeDirty) {
 		final Status status = event.getEntityEntry().getStatus();
 		if ( mightBeDirty || status==Status.DELETED ) {
 			// compare to cached state (ignoring collections unless versioned)
 			dirtyCheck(event);
 			if ( isUpdateNecessary(event) ) {
 				return true;
 			}
 			else {
 				FieldInterceptionHelper.clearDirty( event.getEntity() );
 				return false;
 			}
 		}
 		else {
 			return hasDirtyCollections( event, event.getEntityEntry().getPersister(), status );
 		}
 	}
 
 	private boolean scheduleUpdate(final FlushEntityEvent event) {
 
 		final EntityEntry entry = event.getEntityEntry();
 		final EventSource session = event.getSession();
 		final Object entity = event.getEntity();
 		final Status status = entry.getStatus();
 		final EntityMode entityMode = session.getEntityMode();
 		final EntityPersister persister = entry.getPersister();
 		final Object[] values = event.getPropertyValues();
 
         if (LOG.isTraceEnabled()) {
 			if ( status == Status.DELETED ) {
                 if (!persister.isMutable()) LOG.trace("Updating immutable, deleted entity: "
                                                       + MessageHelper.infoString(persister, entry.getId(), session.getFactory()));
                 else if (!entry.isModifiableEntity()) LOG.trace("Updating non-modifiable, deleted entity: "
                                                                 + MessageHelper.infoString(persister,
                                                                                            entry.getId(),
                                                                                            session.getFactory()));
                 else LOG.trace("Updating deleted entity: "
                                + MessageHelper.infoString(persister, entry.getId(), session.getFactory()));
             } else LOG.trace("Updating entity: " + MessageHelper.infoString(persister, entry.getId(), session.getFactory()));
 		}
 
-		final boolean intercepted;
-		if ( !entry.isBeingReplicated() ) {
-			// give the Interceptor a chance to process property values, if the properties
-			// were modified by the Interceptor, we need to set them back to the object
-			intercepted = handleInterception( event );
-		}
-		else {
-			intercepted = false;
-		}
-
-		validate( entity, persister, status, entityMode );
+		final boolean intercepted = !entry.isBeingReplicated() && handleInterception( event );
 
 		// increment the version number (if necessary)
 		final Object nextVersion = getNextVersion(event);
 
 		// if it was dirtied by a collection only
 		int[] dirtyProperties = event.getDirtyProperties();
 		if ( event.isDirtyCheckPossible() && dirtyProperties == null ) {
 			if ( ! intercepted && !event.hasDirtyCollection() ) {
 				throw new AssertionFailure( "dirty, but no dirty properties" );
 			}
 			dirtyProperties = ArrayHelper.EMPTY_INT_ARRAY;
 		}
 
 		// check nullability but do not doAfterTransactionCompletion command execute
 		// we'll use scheduled updates for that.
 		new Nullability(session).checkNullability( values, persister, true );
 
 		// schedule the update
 		// note that we intentionally do _not_ pass in currentPersistentState!
 		session.getActionQueue().addAction(
 				new EntityUpdateAction(
 						entry.getId(),
 						values,
 						dirtyProperties,
 						event.hasDirtyCollection(),
 						( status == Status.DELETED && ! entry.isModifiableEntity() ?
 								persister.getPropertyValues( entity, entityMode ) :
 								entry.getLoadedState() ),
 						entry.getVersion(),
 						nextVersion,
 						entity,
 						entry.getRowId(),
 						persister,
 						session
 					)
 			);
 
 		return intercepted;
 	}
 
-	protected void validate(Object entity, EntityPersister persister, Status status, EntityMode entityMode) {
-		// validate() instances of Validatable
-		if ( status == Status.MANAGED && persister.implementsValidatable( entityMode ) ) {
-			( (Validatable) entity ).validate();
-		}
-	}
-
 	protected boolean handleInterception(FlushEntityEvent event) {
 		SessionImplementor session = event.getSession();
 		EntityEntry entry = event.getEntityEntry();
 		EntityPersister persister = entry.getPersister();
 		Object entity = event.getEntity();
 
 		//give the Interceptor a chance to modify property values
 		final Object[] values = event.getPropertyValues();
 		final boolean intercepted = invokeInterceptor( session, entity, entry, values, persister );
 
 		//now we might need to recalculate the dirtyProperties array
 		if ( intercepted && event.isDirtyCheckPossible() && !event.isDirtyCheckHandledByInterceptor() ) {
 			int[] dirtyProperties;
 			if ( event.hasDatabaseSnapshot() ) {
 				dirtyProperties = persister.findModified( event.getDatabaseSnapshot(), values, entity, session );
 			}
 			else {
 				dirtyProperties = persister.findDirty( values, entry.getLoadedState(), entity, session );
 			}
 			event.setDirtyProperties(dirtyProperties);
 		}
 
 		return intercepted;
 	}
 
 	protected boolean invokeInterceptor(
 			SessionImplementor session,
 			Object entity,
 			EntityEntry entry,
 			final Object[] values,
 			EntityPersister persister) {
 		return session.getInterceptor().onFlushDirty(
 				entity,
 				entry.getId(),
 				values,
 				entry.getLoadedState(),
 				persister.getPropertyNames(),
 				persister.getPropertyTypes()
 		);
 	}
 
 	/**
 	 * Convience method to retreive an entities next version value
 	 */
 	private Object getNextVersion(FlushEntityEvent event) throws HibernateException {
 
 		EntityEntry entry = event.getEntityEntry();
 		EntityPersister persister = entry.getPersister();
 		if ( persister.isVersioned() ) {
 
 			Object[] values = event.getPropertyValues();
 
 			if ( entry.isBeingReplicated() ) {
 				return Versioning.getVersion(values, persister);
 			}
 			else {
 				int[] dirtyProperties = event.getDirtyProperties();
 
 				final boolean isVersionIncrementRequired = isVersionIncrementRequired(
 						event,
 						entry,
 						persister,
 						dirtyProperties
 					);
 
 				final Object nextVersion = isVersionIncrementRequired ?
 						Versioning.increment( entry.getVersion(), persister.getVersionType(), event.getSession() ) :
 						entry.getVersion(); //use the current version
 
 				Versioning.setVersion(values, nextVersion, persister);
 
 				return nextVersion;
 			}
 		}
 		else {
 			return null;
 		}
 
 	}
 
 	private boolean isVersionIncrementRequired(
 			FlushEntityEvent event,
 			EntityEntry entry,
 			EntityPersister persister,
 			int[] dirtyProperties
 	) {
 		final boolean isVersionIncrementRequired = entry.getStatus()!=Status.DELETED && (
 				dirtyProperties==null ||
 				Versioning.isVersionIncrementRequired(
 						dirtyProperties,
 						event.hasDirtyCollection(),
 						persister.getPropertyVersionability()
 					)
 			);
 		return isVersionIncrementRequired;
 	}
 
 	/**
 	 * Performs all necessary checking to determine if an entity needs an SQL update
 	 * to synchronize its state to the database. Modifies the event by side-effect!
 	 * Note: this method is quite slow, avoid calling if possible!
 	 */
 	protected final boolean isUpdateNecessary(FlushEntityEvent event) throws HibernateException {
 
 		EntityPersister persister = event.getEntityEntry().getPersister();
 		Status status = event.getEntityEntry().getStatus();
 
 		if ( !event.isDirtyCheckPossible() ) {
 			return true;
 		}
 		else {
 
 			int[] dirtyProperties = event.getDirtyProperties();
 			if ( dirtyProperties!=null && dirtyProperties.length!=0 ) {
 				return true; //TODO: suck into event class
 			}
 			else {
 				return hasDirtyCollections( event, persister, status );
 			}
 
 		}
 	}
 
 	private boolean hasDirtyCollections(FlushEntityEvent event, EntityPersister persister, Status status) {
 		if ( isCollectionDirtyCheckNecessary(persister, status ) ) {
 			DirtyCollectionSearchVisitor visitor = new DirtyCollectionSearchVisitor(
 					event.getSession(),
 					persister.getPropertyVersionability()
 				);
 			visitor.processEntityPropertyValues( event.getPropertyValues(), persister.getPropertyTypes() );
 			boolean hasDirtyCollections = visitor.wasDirtyCollectionFound();
 			event.setHasDirtyCollection(hasDirtyCollections);
 			return hasDirtyCollections;
 		}
 		else {
 			return false;
 		}
 	}
 
 	private boolean isCollectionDirtyCheckNecessary(EntityPersister persister, Status status) {
 		return ( status == Status.MANAGED || status == Status.READ_ONLY ) &&
 				persister.isVersioned() &&
 				persister.hasCollections();
 	}
 
 	/**
 	 * Perform a dirty check, and attach the results to the event
 	 */
 	protected void dirtyCheck(FlushEntityEvent event) throws HibernateException {
 
 		final Object entity = event.getEntity();
 		final Object[] values = event.getPropertyValues();
 		final SessionImplementor session = event.getSession();
 		final EntityEntry entry = event.getEntityEntry();
 		final EntityPersister persister = entry.getPersister();
 		final Serializable id = entry.getId();
 		final Object[] loadedState = entry.getLoadedState();
 
 		int[] dirtyProperties = session.getInterceptor().findDirty(
 				entity,
 				id,
 				values,
 				loadedState,
 				persister.getPropertyNames(),
 				persister.getPropertyTypes()
 			);
 
 		event.setDatabaseSnapshot(null);
 
 		final boolean interceptorHandledDirtyCheck;
 		boolean cannotDirtyCheck;
 
 		if ( dirtyProperties==null ) {
 			// Interceptor returned null, so do the dirtycheck ourself, if possible
 			interceptorHandledDirtyCheck = false;
 
 			cannotDirtyCheck = loadedState==null; // object loaded by update()
 			if ( !cannotDirtyCheck ) {
 				// dirty check against the usual snapshot of the entity
 				dirtyProperties = persister.findDirty( values, loadedState, entity, session );
 			}
 			else if ( entry.getStatus() == Status.DELETED && ! event.getEntityEntry().isModifiableEntity() ) {
 				// A non-modifiable (e.g., read-only or immutable) entity needs to be have
 				// references to transient entities set to null before being deleted. No other
 				// fields should be updated.
 				if ( values != entry.getDeletedState() ) {
 					throw new IllegalStateException(
 							"Entity has status Status.DELETED but values != entry.getDeletedState"
 					);
 				}
 				// Even if loadedState == null, we can dirty-check by comparing currentState and
 				// entry.getDeletedState() because the only fields to be updated are those that
 				// refer to transient entities that are being set to null.
 				// - currentState contains the entity's current property values.
 				// - entry.getDeletedState() contains the entity's current property values with
 				//   references to transient entities set to null.
 				// - dirtyProperties will only contain properties that refer to transient entities
 				final Object[] currentState =
 						persister.getPropertyValues( event.getEntity(), event.getSession().getEntityMode() );
 				dirtyProperties = persister.findDirty( entry.getDeletedState(), currentState, entity, session );
 				cannotDirtyCheck = false;
 			}
 			else {
 				// dirty check against the database snapshot, if possible/necessary
 				final Object[] databaseSnapshot = getDatabaseSnapshot(session, persister, id);
 				if ( databaseSnapshot != null ) {
 					dirtyProperties = persister.findModified(databaseSnapshot, values, entity, session);
 					cannotDirtyCheck = false;
 					event.setDatabaseSnapshot(databaseSnapshot);
 				}
 			}
 		}
 		else {
 			// the Interceptor handled the dirty checking
 			cannotDirtyCheck = false;
 			interceptorHandledDirtyCheck = true;
 		}
 
 		logDirtyProperties( id, dirtyProperties, persister );
 
 		event.setDirtyProperties(dirtyProperties);
 		event.setDirtyCheckHandledByInterceptor(interceptorHandledDirtyCheck);
 		event.setDirtyCheckPossible(!cannotDirtyCheck);
 
 	}
 
 	private void logDirtyProperties(Serializable id, int[] dirtyProperties, EntityPersister persister) {
         if (LOG.isTraceEnabled() && dirtyProperties != null && dirtyProperties.length > 0) {
 			final String[] allPropertyNames = persister.getPropertyNames();
 			final String[] dirtyPropertyNames = new String[ dirtyProperties.length ];
 			for ( int i = 0; i < dirtyProperties.length; i++ ) {
 				dirtyPropertyNames[i] = allPropertyNames[ dirtyProperties[i]];
 			}
             LOG.trace("Found dirty properties [" + MessageHelper.infoString(persister.getEntityName(), id) + "] : "
                       + dirtyPropertyNames);
 		}
 	}
 
 	private Object[] getDatabaseSnapshot(SessionImplementor session, EntityPersister persister, Serializable id) {
 		if ( persister.isSelectBeforeUpdateRequired() ) {
 			Object[] snapshot = session.getPersistenceContext()
 					.getDatabaseSnapshot(id, persister);
 			if (snapshot==null) {
 				//do we even really need this? the update will fail anyway....
 				if ( session.getFactory().getStatistics().isStatisticsEnabled() ) {
 					session.getFactory().getStatisticsImplementor()
 							.optimisticFailure( persister.getEntityName() );
 				}
 				throw new StaleObjectStateException( persister.getEntityName(), id );
 			}
             return snapshot;
 		}
         // TODO: optimize away this lookup for entities w/o unsaved-value="undefined"
         EntityKey entityKey = new EntityKey(id, persister, session.getEntityMode());
         return session.getPersistenceContext().getCachedDatabaseSnapshot(entityKey);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultSaveOrUpdateCopyEventListener.java b/hibernate-core/src/main/java/org/hibernate/event/def/DefaultSaveOrUpdateCopyEventListener.java
deleted file mode 100755
index 2556fffb84..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/event/def/DefaultSaveOrUpdateCopyEventListener.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.event.def;
-import org.hibernate.engine.CascadingAction;
-
-public class DefaultSaveOrUpdateCopyEventListener extends DefaultMergeEventListener {
-
-	protected CascadingAction getCascadeAction() {
-		return CascadingAction.SAVE_UPDATE_COPY;
-	}
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/impl/SessionFactoryImpl.java b/hibernate-core/src/main/java/org/hibernate/impl/SessionFactoryImpl.java
index 0313c6a7eb..e7e34f97c7 100644
--- a/hibernate-core/src/main/java/org/hibernate/impl/SessionFactoryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/impl/SessionFactoryImpl.java
@@ -1,1311 +1,1311 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.impl;
 
 import java.io.IOException;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.ObjectStreamException;
 import java.io.Serializable;
 import java.sql.Connection;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import javax.naming.NamingException;
 import javax.naming.Reference;
 import javax.naming.StringRefAddr;
 import org.hibernate.AssertionFailure;
 import org.hibernate.Cache;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.EntityMode;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.HibernateException;
 import org.hibernate.HibernateLogger;
 import org.hibernate.Interceptor;
 import org.hibernate.MappingException;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.QueryException;
+import org.hibernate.Session;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.StatelessSession;
 import org.hibernate.TypeHelper;
 import org.hibernate.cache.CacheKey;
 import org.hibernate.cache.CollectionRegion;
 import org.hibernate.cache.EntityRegion;
 import org.hibernate.cache.QueryCache;
 import org.hibernate.cache.Region;
 import org.hibernate.cache.UpdateTimestampsCache;
 import org.hibernate.cache.access.AccessType;
 import org.hibernate.cache.access.CollectionRegionAccessStrategy;
 import org.hibernate.cache.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.impl.CacheDataDescriptionImpl;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.Settings;
 import org.hibernate.context.CurrentSessionContext;
 import org.hibernate.context.JTASessionContext;
 import org.hibernate.context.ManagedSessionContext;
 import org.hibernate.context.ThreadLocalSessionContext;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.function.SQLFunctionRegistry;
 import org.hibernate.engine.FilterDefinition;
 import org.hibernate.engine.Mapping;
 import org.hibernate.engine.NamedQueryDefinition;
 import org.hibernate.engine.NamedSQLQueryDefinition;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.profile.Association;
 import org.hibernate.engine.profile.Fetch;
 import org.hibernate.engine.profile.FetchProfile;
 import org.hibernate.engine.query.QueryPlanCache;
 import org.hibernate.engine.query.sql.NativeSQLQuerySpecification;
 import org.hibernate.engine.transaction.spi.TransactionEnvironment;
 import org.hibernate.event.EventListeners;
 import org.hibernate.exception.SQLExceptionConverter;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.UUIDGenerator;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.internal.util.collections.EmptyIterator;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.metadata.CollectionMetadata;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.persister.spi.PersisterFactory;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.jta.platform.spi.JtaPlatform;
 import org.hibernate.service.spi.ServiceRegistry;
 import org.hibernate.stat.ConcurrentStatisticsImpl;
 import org.hibernate.stat.Statistics;
 import org.hibernate.stat.StatisticsImplementor;
 import org.hibernate.tool.hbm2ddl.SchemaExport;
 import org.hibernate.tool.hbm2ddl.SchemaUpdate;
 import org.hibernate.tool.hbm2ddl.SchemaValidator;
 import org.hibernate.tuple.entity.EntityTuplizer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeResolver;
 import org.jboss.logging.Logger;
 
 
 /**
  * Concrete implementation of the <tt>SessionFactory</tt> interface. Has the following
  * responsibilities
  * <ul>
  * <li>caches configuration settings (immutably)
  * <li>caches "compiled" mappings ie. <tt>EntityPersister</tt>s and
  *     <tt>CollectionPersister</tt>s (immutable)
  * <li>caches "compiled" queries (memory sensitive cache)
  * <li>manages <tt>PreparedStatement</tt>s
  * <li> delegates JDBC <tt>Connection</tt> management to the <tt>ConnectionProvider</tt>
  * <li>factory for instances of <tt>SessionImpl</tt>
  * </ul>
  * This class must appear immutable to clients, even if it does all kinds of caching
  * and pooling under the covers. It is crucial that the class is not only thread
  * safe, but also highly concurrent. Synchronization must be used extremely sparingly.
  *
  * @see org.hibernate.service.jdbc.connections.spi.ConnectionProvider
- * @see org.hibernate.classic.Session
+ * @see org.hibernate.Session
  * @see org.hibernate.hql.QueryTranslator
  * @see org.hibernate.persister.entity.EntityPersister
  * @see org.hibernate.persister.collection.CollectionPersister
  * @author Gavin King
  */
 public final class SessionFactoryImpl
 		implements SessionFactory, SessionFactoryImplementor {
 
     private static final HibernateLogger LOG = Logger.getMessageLogger(HibernateLogger.class, SessionFactoryImpl.class.getName());
 	private static final IdentifierGenerator UUID_GENERATOR = UUIDGenerator.buildSessionFactoryUniqueIdentifierGenerator();
 
 	private final String name;
 	private final String uuid;
 
 	private final transient Map entityPersisters;
 	private final transient Map<String,ClassMetadata> classMetadata;
 	private final transient Map collectionPersisters;
 	private final transient Map collectionMetadata;
 	private final transient Map<String,Set<String>> collectionRolesByEntityParticipant;
 	private final transient Map identifierGenerators;
 	private final transient Map namedQueries;
 	private final transient Map namedSqlQueries;
 	private final transient Map sqlResultSetMappings;
 	private final transient Map filters;
 	private final transient Map fetchProfiles;
 	private final transient Map imports;
 	private final transient Interceptor interceptor;
 	private final transient ServiceRegistry serviceRegistry;
 	private final transient Settings settings;
 	private final transient Properties properties;
 	private transient SchemaExport schemaExport;
 	private final transient QueryCache queryCache;
 	private final transient UpdateTimestampsCache updateTimestampsCache;
 	private final transient Map<String,QueryCache> queryCaches;
 	private final transient ConcurrentMap<String,Region> allCacheRegions = new ConcurrentHashMap<String, Region>();
 	private final transient Statistics statistics;
 	private final transient EventListeners eventListeners;
 	private final transient CurrentSessionContext currentSessionContext;
 	private final transient EntityNotFoundDelegate entityNotFoundDelegate;
 	private final transient SQLFunctionRegistry sqlFunctionRegistry;
 	private final transient SessionFactoryObserver observer;
 	private final transient HashMap entityNameResolvers = new HashMap();
 	private final transient QueryPlanCache queryPlanCache;
 	private final transient Cache cacheAccess = new CacheImpl();
 	private transient boolean isClosed = false;
 	private final transient TypeResolver typeResolver;
 	private final transient TypeHelper typeHelper;
 	private final transient TransactionEnvironment transactionEnvironment;
 
 	public SessionFactoryImpl(
 			Configuration cfg,
 	        Mapping mapping,
 			ServiceRegistry serviceRegistry,
 	        Settings settings,
 	        EventListeners listeners,
 			SessionFactoryObserver observer) throws HibernateException {
         LOG.buildingSessionFactory();
 
 		this.statistics = new ConcurrentStatisticsImpl( this );
 		getStatistics().setStatisticsEnabled( settings.isStatisticsEnabled() );
         LOG.debugf("Statistics initialized [enabled=%s]", settings.isStatisticsEnabled());
 
 		this.properties = new Properties();
 		this.properties.putAll( cfg.getProperties() );
 		this.interceptor = cfg.getInterceptor();
 		this.serviceRegistry = serviceRegistry;
 		this.settings = settings;
 		this.sqlFunctionRegistry = new SQLFunctionRegistry( getDialect(), cfg.getSqlFunctions() );
         this.eventListeners = listeners;
 		this.observer = observer != null ? observer : new SessionFactoryObserver() {
 			public void sessionFactoryCreated(SessionFactory factory) {
 			}
 			public void sessionFactoryClosed(SessionFactory factory) {
 			}
 		};
 
 		this.typeResolver = cfg.getTypeResolver().scope( this );
 		this.typeHelper = new TypeLocatorImpl( typeResolver );
 
 		this.filters = new HashMap();
 		this.filters.putAll( cfg.getFilterDefinitions() );
 
         LOG.debugf("Session factory constructed with filter configurations : %s", filters);
         LOG.debugf("Instantiating session factory with properties: %s", properties);
 
 		// Caches
 		settings.getRegionFactory().start( settings, properties );
 		this.queryPlanCache = new QueryPlanCache( this );
 
 		//Generators:
 
 		identifierGenerators = new HashMap();
 		Iterator classes = cfg.getClassMappings();
 		while ( classes.hasNext() ) {
 			PersistentClass model = (PersistentClass) classes.next();
 			if ( !model.isInherited() ) {
 				IdentifierGenerator generator = model.getIdentifier().createIdentifierGenerator(
 						cfg.getIdentifierGeneratorFactory(),
 						getDialect(),
 				        settings.getDefaultCatalogName(),
 				        settings.getDefaultSchemaName(),
 				        (RootClass) model
 				);
 				identifierGenerators.put( model.getEntityName(), generator );
 			}
 		}
 
 
 		///////////////////////////////////////////////////////////////////////
 		// Prepare persisters and link them up with their cache
 		// region/access-strategy
 
 		final String cacheRegionPrefix = settings.getCacheRegionPrefix() == null ? "" : settings.getCacheRegionPrefix() + ".";
 
 		entityPersisters = new HashMap();
 		Map entityAccessStrategies = new HashMap();
 		Map<String,ClassMetadata> classMeta = new HashMap<String,ClassMetadata>();
 		classes = cfg.getClassMappings();
 		while ( classes.hasNext() ) {
 			final PersistentClass model = (PersistentClass) classes.next();
 			model.prepareTemporaryTables( mapping, getDialect() );
 			final String cacheRegionName = cacheRegionPrefix + model.getRootClass().getCacheRegionName();
 			// cache region is defined by the root-class in the hierarchy...
 			EntityRegionAccessStrategy accessStrategy = ( EntityRegionAccessStrategy ) entityAccessStrategies.get( cacheRegionName );
 			if ( accessStrategy == null && settings.isSecondLevelCacheEnabled() ) {
 				final AccessType accessType = AccessType.parse( model.getCacheConcurrencyStrategy() );
 				if ( accessType != null ) {
                     LOG.trace("Building cache for entity data [" + model.getEntityName() + "]");
 					EntityRegion entityRegion = settings.getRegionFactory().buildEntityRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
 					accessStrategy = entityRegion.buildAccessStrategy( accessType );
 					entityAccessStrategies.put( cacheRegionName, accessStrategy );
 					allCacheRegions.put( cacheRegionName, entityRegion );
 				}
 			}
 			EntityPersister cp = serviceRegistry.getService( PersisterFactory.class ).createEntityPersister(
 					model,
 					accessStrategy,
 					this,
 					mapping
 			);
 			entityPersisters.put( model.getEntityName(), cp );
 			classMeta.put( model.getEntityName(), cp.getClassMetadata() );
 		}
 		this.classMetadata = Collections.unmodifiableMap(classMeta);
 
 		Map<String,Set<String>> tmpEntityToCollectionRoleMap = new HashMap<String,Set<String>>();
 		collectionPersisters = new HashMap();
 		Iterator collections = cfg.getCollectionMappings();
 		while ( collections.hasNext() ) {
 			Collection model = (Collection) collections.next();
 			final String cacheRegionName = cacheRegionPrefix + model.getCacheRegionName();
 			final AccessType accessType = AccessType.parse( model.getCacheConcurrencyStrategy() );
 			CollectionRegionAccessStrategy accessStrategy = null;
 			if ( accessType != null && settings.isSecondLevelCacheEnabled() ) {
                 LOG.trace("Building cache for collection data [" + model.getRole() + "]");
 				CollectionRegion collectionRegion = settings.getRegionFactory().buildCollectionRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
 				accessStrategy = collectionRegion.buildAccessStrategy( accessType );
 				entityAccessStrategies.put( cacheRegionName, accessStrategy );
 				allCacheRegions.put( cacheRegionName, collectionRegion );
 			}
 			CollectionPersister persister = serviceRegistry.getService( PersisterFactory.class ).createCollectionPersister(
 					cfg,
 					model,
 					accessStrategy,
 					this
 			) ;
 			collectionPersisters.put( model.getRole(), persister.getCollectionMetadata() );
 			Type indexType = persister.getIndexType();
 			if ( indexType != null && indexType.isAssociationType() && !indexType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) indexType ).getAssociatedEntityName( this );
 				Set roles = tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 			Type elementType = persister.getElementType();
 			if ( elementType.isAssociationType() && !elementType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) elementType ).getAssociatedEntityName( this );
 				Set roles = tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 		}
 		collectionMetadata = Collections.unmodifiableMap(collectionPersisters);
 		Iterator itr = tmpEntityToCollectionRoleMap.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			entry.setValue( Collections.unmodifiableSet( ( Set ) entry.getValue() ) );
 		}
 		collectionRolesByEntityParticipant = Collections.unmodifiableMap( tmpEntityToCollectionRoleMap );
 
 		//Named Queries:
 		namedQueries = new HashMap( cfg.getNamedQueries() );
 		namedSqlQueries = new HashMap( cfg.getNamedSQLQueries() );
 		sqlResultSetMappings = new HashMap( cfg.getSqlResultSetMappings() );
 		imports = new HashMap( cfg.getImports() );
 
 		// after *all* persisters and named queries are registered
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			final EntityPersister persister = ( ( EntityPersister ) iter.next() );
 			persister.postInstantiate();
 			registerEntityNameResolvers( persister );
 
 		}
 		iter = collectionPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			final CollectionPersister persister = ( ( CollectionPersister ) iter.next() );
 			persister.postInstantiate();
 		}
 
 		//JNDI + Serialization:
 
 		name = settings.getSessionFactoryName();
 		try {
 			uuid = (String) UUID_GENERATOR.generate(null, null);
 		}
 		catch (Exception e) {
 			throw new AssertionFailure("Could not generate UUID");
 		}
 		SessionFactoryObjectFactory.addInstance(uuid, name, this, properties);
 
         LOG.debugf("Instantiated session factory");
 
 		if ( settings.isAutoCreateSchema() ) {
 			new SchemaExport( getJdbcServices(), cfg ).create( false, true );
 		}
 		if ( settings.isAutoUpdateSchema() ) {
 			new SchemaUpdate( getJdbcServices(), cfg ).execute( false, true );
 		}
 		if ( settings.isAutoValidateSchema() ) {
 			new SchemaValidator( getJdbcServices(), cfg ).validate();
 		}
 		if ( settings.isAutoDropSchema() ) {
 			schemaExport = new SchemaExport( getJdbcServices(), cfg );
 		}
 
 		currentSessionContext = buildCurrentSessionContext();
 
 		if ( settings.isQueryCacheEnabled() ) {
 			updateTimestampsCache = new UpdateTimestampsCache(settings, properties);
 			queryCache = settings.getQueryCacheFactory()
 			        .getQueryCache(null, updateTimestampsCache, settings, properties);
 			queryCaches = new HashMap<String,QueryCache>();
 			allCacheRegions.put( updateTimestampsCache.getRegion().getName(), updateTimestampsCache.getRegion() );
 			allCacheRegions.put( queryCache.getRegion().getName(), queryCache.getRegion() );
 		}
 		else {
 			updateTimestampsCache = null;
 			queryCache = null;
 			queryCaches = null;
 		}
 
 		//checking for named queries
 		if ( settings.isNamedQueryStartupCheckingEnabled() ) {
 			Map errors = checkNamedQueries();
 			if ( !errors.isEmpty() ) {
 				Set keys = errors.keySet();
 				StringBuffer failingQueries = new StringBuffer( "Errors in named queries: " );
 				for ( Iterator iterator = keys.iterator() ; iterator.hasNext() ; ) {
 					String queryName = ( String ) iterator.next();
 					HibernateException e = ( HibernateException ) errors.get( queryName );
 					failingQueries.append( queryName );
                     if (iterator.hasNext()) failingQueries.append(", ");
                     LOG.namedQueryError(queryName, e);
 				}
 				throw new HibernateException( failingQueries.toString() );
 			}
 		}
 
 		// EntityNotFoundDelegate
 		EntityNotFoundDelegate entityNotFoundDelegate = cfg.getEntityNotFoundDelegate();
 		if ( entityNotFoundDelegate == null ) {
 			entityNotFoundDelegate = new EntityNotFoundDelegate() {
 				public void handleEntityNotFound(String entityName, Serializable id) {
 					throw new ObjectNotFoundException( id, entityName );
 				}
 			};
 		}
 		this.entityNotFoundDelegate = entityNotFoundDelegate;
 
 		// this needs to happen after persisters are all ready to go...
 		this.fetchProfiles = new HashMap();
 		itr = cfg.iterateFetchProfiles();
 		while ( itr.hasNext() ) {
 			final org.hibernate.mapping.FetchProfile mappingProfile =
 					( org.hibernate.mapping.FetchProfile ) itr.next();
 			final FetchProfile fetchProfile = new FetchProfile( mappingProfile.getName() );
 			Iterator fetches = mappingProfile.getFetches().iterator();
 			while ( fetches.hasNext() ) {
 				final org.hibernate.mapping.FetchProfile.Fetch mappingFetch =
 						( org.hibernate.mapping.FetchProfile.Fetch ) fetches.next();
 				// resolve the persister owning the fetch
 				final String entityName = getImportedClassName( mappingFetch.getEntity() );
 				final EntityPersister owner = ( EntityPersister ) ( entityName == null ? null : entityPersisters.get( entityName ) );
 				if ( owner == null ) {
 					throw new HibernateException(
 							"Unable to resolve entity reference [" + mappingFetch.getEntity()
 									+ "] in fetch profile [" + fetchProfile.getName() + "]"
 					);
 				}
 
 				// validate the specified association fetch
 				Type associationType = owner.getPropertyType( mappingFetch.getAssociation() );
 				if ( associationType == null || !associationType.isAssociationType() ) {
 					throw new HibernateException( "Fetch profile [" + fetchProfile.getName() + "] specified an invalid association" );
 				}
 
 				// resolve the style
 				final Fetch.Style fetchStyle = Fetch.Style.parse( mappingFetch.getStyle() );
 
 				// then construct the fetch instance...
 				fetchProfile.addFetch( new Association( owner, mappingFetch.getAssociation() ), fetchStyle );
 				( ( Loadable ) owner ).registerAffectingFetchProfile( fetchProfile.getName() );
 			}
 			fetchProfiles.put( fetchProfile.getName(), fetchProfile );
 		}
 
 		this.transactionEnvironment = new TransactionEnvironmentImpl( this );
 		this.observer.sessionFactoryCreated( this );
 	}
 
 	public TransactionEnvironment getTransactionEnvironment() {
 		return transactionEnvironment;
 	}
 
 	public Properties getProperties() {
 		return properties;
 	}
 
 	public IdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 		return null;
 	}
 
 	public TypeResolver getTypeResolver() {
 		return typeResolver;
 	}
 
 	private void registerEntityNameResolvers(EntityPersister persister) {
 		if ( persister.getEntityMetamodel() == null || persister.getEntityMetamodel().getTuplizerMapping() == null ) {
 			return;
 		}
 		Iterator itr = persister.getEntityMetamodel().getTuplizerMapping().iterateTuplizers();
 		while ( itr.hasNext() ) {
 			final EntityTuplizer tuplizer = ( EntityTuplizer ) itr.next();
 			registerEntityNameResolvers( tuplizer );
 		}
 	}
 
 	private void registerEntityNameResolvers(EntityTuplizer tuplizer) {
 		EntityNameResolver[] resolvers = tuplizer.getEntityNameResolvers();
 		if ( resolvers == null ) {
 			return;
 		}
 
 		for ( int i = 0; i < resolvers.length; i++ ) {
 			registerEntityNameResolver( resolvers[i], tuplizer.getEntityMode() );
 		}
 	}
 
 	public void registerEntityNameResolver(EntityNameResolver resolver, EntityMode entityMode) {
 		LinkedHashSet resolversForMode = ( LinkedHashSet ) entityNameResolvers.get( entityMode );
 		if ( resolversForMode == null ) {
 			resolversForMode = new LinkedHashSet();
 			entityNameResolvers.put( entityMode, resolversForMode );
 		}
 		resolversForMode.add( resolver );
 	}
 
 	public Iterator iterateEntityNameResolvers(EntityMode entityMode) {
 		Set actualEntityNameResolvers = ( Set ) entityNameResolvers.get( entityMode );
 		return actualEntityNameResolvers == null
 				? EmptyIterator.INSTANCE
 				: actualEntityNameResolvers.iterator();
 	}
 
 	public QueryPlanCache getQueryPlanCache() {
 		return queryPlanCache;
 	}
 
 	private Map checkNamedQueries() throws HibernateException {
 		Map errors = new HashMap();
 
 		// Check named HQL queries
         LOG.debugf("Checking %s named HQL queries", namedQueries.size());
 		Iterator itr = namedQueries.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			final String queryName = ( String ) entry.getKey();
 			final NamedQueryDefinition qd = ( NamedQueryDefinition ) entry.getValue();
 			// this will throw an error if there's something wrong.
 			try {
                 LOG.debugf("Checking named query: %s", queryName);
 				//TODO: BUG! this currently fails for named queries for non-POJO entities
 				queryPlanCache.getHQLQueryPlan( qd.getQueryString(), false, CollectionHelper.EMPTY_MAP );
 			}
 			catch ( QueryException e ) {
 				errors.put( queryName, e );
 			}
 			catch ( MappingException e ) {
 				errors.put( queryName, e );
 			}
 		}
 
         LOG.debugf("Checking %s named SQL queries", namedSqlQueries.size());
 		itr = namedSqlQueries.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			final String queryName = ( String ) entry.getKey();
 			final NamedSQLQueryDefinition qd = ( NamedSQLQueryDefinition ) entry.getValue();
 			// this will throw an error if there's something wrong.
 			try {
                 LOG.debugf("Checking named SQL query: %s", queryName);
 				// TODO : would be really nice to cache the spec on the query-def so as to not have to re-calc the hash;
 				// currently not doable though because of the resultset-ref stuff...
 				NativeSQLQuerySpecification spec;
 				if ( qd.getResultSetRef() != null ) {
 					ResultSetMappingDefinition definition = ( ResultSetMappingDefinition ) sqlResultSetMappings.get( qd.getResultSetRef() );
 					if ( definition == null ) {
 						throw new MappingException( "Unable to find resultset-ref definition: " + qd.getResultSetRef() );
 					}
 					spec = new NativeSQLQuerySpecification(
 							qd.getQueryString(),
 					        definition.getQueryReturns(),
 					        qd.getQuerySpaces()
 					);
 				}
 				else {
 					spec =  new NativeSQLQuerySpecification(
 							qd.getQueryString(),
 					        qd.getQueryReturns(),
 					        qd.getQuerySpaces()
 					);
 				}
 				queryPlanCache.getNativeSQLQueryPlan( spec );
 			}
 			catch ( QueryException e ) {
 				errors.put( queryName, e );
 			}
 			catch ( MappingException e ) {
 				errors.put( queryName, e );
 			}
 		}
 
 		return errors;
 	}
 
 	public StatelessSession openStatelessSession() {
 		return new StatelessSessionImpl( null, this );
 	}
 
 	public StatelessSession openStatelessSession(Connection connection) {
 		return new StatelessSessionImpl( connection, this );
 	}
 
 	private SessionImpl openSession(
 		Connection connection,
 	    boolean autoClose,
 	    long timestamp,
 	    Interceptor sessionLocalInterceptor
 	) {
 		return new SessionImpl(
 		        connection,
 		        this,
 		        autoClose,
 		        timestamp,
 		        sessionLocalInterceptor == null ? interceptor : sessionLocalInterceptor,
 		        settings.getDefaultEntityMode(),
 		        settings.isFlushBeforeCompletionEnabled(),
 		        settings.isAutoCloseSessionEnabled(),
 		        settings.getConnectionReleaseMode()
 			);
 	}
 
-	public org.hibernate.classic.Session openSession(Connection connection, Interceptor sessionLocalInterceptor) {
+	public Session openSession(Connection connection, Interceptor sessionLocalInterceptor) {
 		return openSession(connection, false, Long.MIN_VALUE, sessionLocalInterceptor);
 	}
 
-	public org.hibernate.classic.Session openSession(Interceptor sessionLocalInterceptor)
-	throws HibernateException {
+	public Session openSession(Interceptor sessionLocalInterceptor) throws HibernateException {
 		// note that this timestamp is not correct if the connection provider
 		// returns an older JDBC connection that was associated with a
 		// transaction that was already begun before openSession() was called
 		// (don't know any possible solution to this!)
 		long timestamp = settings.getRegionFactory().nextTimestamp();
 		return openSession( null, true, timestamp, sessionLocalInterceptor );
 	}
 
-	public org.hibernate.classic.Session openSession(Connection connection) {
+	public Session openSession(Connection connection) {
 		return openSession(connection, interceptor); //prevents this session from adding things to cache
 	}
 
-	public org.hibernate.classic.Session openSession() throws HibernateException {
+	public Session openSession() throws HibernateException {
 		return openSession(interceptor);
 	}
 
-	public org.hibernate.classic.Session openTemporarySession() throws HibernateException {
+	public Session openTemporarySession() throws HibernateException {
 		return new SessionImpl(
 				null,
 		        this,
 		        true,
 		        settings.getRegionFactory().nextTimestamp(),
 		        interceptor,
 		        settings.getDefaultEntityMode(),
 		        false,
 		        false,
 		        ConnectionReleaseMode.AFTER_STATEMENT
 			);
 	}
 
-	public org.hibernate.classic.Session openSession(
+	public Session openSession(
 			final Connection connection,
 	        final boolean flushBeforeCompletionEnabled,
 	        final boolean autoCloseSessionEnabled,
 	        final ConnectionReleaseMode connectionReleaseMode) throws HibernateException {
 		return new SessionImpl(
 				connection,
 		        this,
 		        true,
 		        settings.getRegionFactory().nextTimestamp(),
 		        interceptor,
 		        settings.getDefaultEntityMode(),
 		        flushBeforeCompletionEnabled,
 		        autoCloseSessionEnabled,
 		        connectionReleaseMode
 			);
 	}
 
-	public org.hibernate.classic.Session getCurrentSession() throws HibernateException {
+	public Session getCurrentSession() throws HibernateException {
 		if ( currentSessionContext == null ) {
 			throw new HibernateException( "No CurrentSessionContext configured!" );
 		}
 		return currentSessionContext.currentSession();
 	}
 
 	public EntityPersister getEntityPersister(String entityName) throws MappingException {
 		EntityPersister result = (EntityPersister) entityPersisters.get(entityName);
 		if (result==null) {
 			throw new MappingException( "Unknown entity: " + entityName );
 		}
 		return result;
 	}
 
 	public CollectionPersister getCollectionPersister(String role) throws MappingException {
 		CollectionPersister result = (CollectionPersister) collectionPersisters.get(role);
 		if (result==null) {
 			throw new MappingException( "Unknown collection role: " + role );
 		}
 		return result;
 	}
 
 	public Settings getSettings() {
 		return settings;
 	}
 
 	public JdbcServices getJdbcServices() {
 		return serviceRegistry.getService( JdbcServices.class );
 	}
 
 	public Dialect getDialect() {
 		if ( serviceRegistry == null ) {
 			throw new IllegalStateException( "Cannot determine dialect because serviceRegistry is null." );
 		}
 		return getJdbcServices().getDialect();
 	}
 
 	public Interceptor getInterceptor()
 	{
 		return interceptor;
 	}
 
 	public SQLExceptionConverter getSQLExceptionConverter() {
 		return getSQLExceptionHelper().getSqlExceptionConverter();
 	}
 
 	public SqlExceptionHelper getSQLExceptionHelper() {
 		return getJdbcServices().getSqlExceptionHelper();
 	}
 
 	public Set<String> getCollectionRolesByEntityParticipant(String entityName) {
 		return collectionRolesByEntityParticipant.get( entityName );
 	}
 
 	// from javax.naming.Referenceable
 	public Reference getReference() throws NamingException {
         LOG.debugf("Returning a Reference to the SessionFactory");
 		return new Reference(
 			SessionFactoryImpl.class.getName(),
 		    new StringRefAddr("uuid", uuid),
 		    SessionFactoryObjectFactory.class.getName(),
 		    null
 		);
 	}
 
 	private Object readResolve() throws ObjectStreamException {
         LOG.trace("Resolving serialized SessionFactory");
 		// look for the instance by uuid
 		Object result = SessionFactoryObjectFactory.getInstance(uuid);
 		if (result==null) {
 			// in case we were deserialized in a different JVM, look for an instance with the same name
 			// (alternatively we could do an actual JNDI lookup here....)
 			result = SessionFactoryObjectFactory.getNamedInstance(name);
             if (result == null) throw new InvalidObjectException("Could not find a SessionFactory named: " + name);
             LOG.debugf("Resolved SessionFactory by name");
         } else LOG.debugf("Resolved SessionFactory by UID");
 		return result;
 	}
 
 	public NamedQueryDefinition getNamedQuery(String queryName) {
 		return (NamedQueryDefinition) namedQueries.get(queryName);
 	}
 
 	public NamedSQLQueryDefinition getNamedSQLQuery(String queryName) {
 		return (NamedSQLQueryDefinition) namedSqlQueries.get(queryName);
 	}
 
 	public ResultSetMappingDefinition getResultSetMapping(String resultSetName) {
 		return (ResultSetMappingDefinition) sqlResultSetMappings.get(resultSetName);
 	}
 
 	public Type getIdentifierType(String className) throws MappingException {
 		return getEntityPersister(className).getIdentifierType();
 	}
 	public String getIdentifierPropertyName(String className) throws MappingException {
 		return getEntityPersister(className).getIdentifierPropertyName();
 	}
 
 	private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
         LOG.trace("Deserializing");
 		in.defaultReadObject();
         LOG.debugf("Deserialized: %s", uuid);
 	}
 
 	private void writeObject(ObjectOutputStream out) throws IOException {
         LOG.debugf("Serializing: %s", uuid);
 		out.defaultWriteObject();
         LOG.trace("Serialized");
 	}
 
 	public Type[] getReturnTypes(String queryString) throws HibernateException {
 		return queryPlanCache.getHQLQueryPlan( queryString, false, CollectionHelper.EMPTY_MAP ).getReturnMetadata().getReturnTypes();
 	}
 
 	public String[] getReturnAliases(String queryString) throws HibernateException {
 		return queryPlanCache.getHQLQueryPlan( queryString, false, CollectionHelper.EMPTY_MAP ).getReturnMetadata().getReturnAliases();
 	}
 
 	public ClassMetadata getClassMetadata(Class persistentClass) throws HibernateException {
 		return getClassMetadata( persistentClass.getName() );
 	}
 
 	public CollectionMetadata getCollectionMetadata(String roleName) throws HibernateException {
 		return (CollectionMetadata) collectionMetadata.get(roleName);
 	}
 
 	public ClassMetadata getClassMetadata(String entityName) throws HibernateException {
 		return classMetadata.get(entityName);
 	}
 
 	/**
 	 * Return the names of all persistent (mapped) classes that extend or implement the
 	 * given class or interface, accounting for implicit/explicit polymorphism settings
 	 * and excluding mapped subclasses/joined-subclasses of other classes in the result.
 	 */
 	public String[] getImplementors(String className) throws MappingException {
 
 		final Class clazz;
 		try {
 			clazz = ReflectHelper.classForName(className);
 		}
 		catch (ClassNotFoundException cnfe) {
 			return new String[] { className }; //for a dynamic-class
 		}
 
 		ArrayList results = new ArrayList();
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			//test this entity to see if we must query it
 			EntityPersister testPersister = (EntityPersister) iter.next();
 			if ( testPersister instanceof Queryable ) {
 				Queryable testQueryable = (Queryable) testPersister;
 				String testClassName = testQueryable.getEntityName();
 				boolean isMappedClass = className.equals(testClassName);
 				if ( testQueryable.isExplicitPolymorphism() ) {
 					if ( isMappedClass ) {
 						return new String[] {className}; //NOTE EARLY EXIT
 					}
 				}
 				else {
 					if (isMappedClass) {
 						results.add(testClassName);
 					}
 					else {
 						final Class mappedClass = testQueryable.getMappedClass( EntityMode.POJO );
 						if ( mappedClass!=null && clazz.isAssignableFrom( mappedClass ) ) {
 							final boolean assignableSuperclass;
 							if ( testQueryable.isInherited() ) {
 								Class mappedSuperclass = getEntityPersister( testQueryable.getMappedSuperclass() ).getMappedClass( EntityMode.POJO);
 								assignableSuperclass = clazz.isAssignableFrom(mappedSuperclass);
 							}
 							else {
 								assignableSuperclass = false;
 							}
 							if ( !assignableSuperclass ) {
 								results.add( testClassName );
 							}
 						}
 					}
 				}
 			}
 		}
 		return (String[]) results.toArray( new String[ results.size() ] );
 	}
 
 	public String getImportedClassName(String className) {
 		String result = (String) imports.get(className);
 		if (result==null) {
 			try {
 				ReflectHelper.classForName( className );
 				return className;
 			}
 			catch (ClassNotFoundException cnfe) {
 				return null;
 			}
 		}
 		else {
 			return result;
 		}
 	}
 
 	public Map<String,ClassMetadata> getAllClassMetadata() throws HibernateException {
 		return classMetadata;
 	}
 
 	public Map getAllCollectionMetadata() throws HibernateException {
 		return collectionMetadata;
 	}
 
 	public Type getReferencedPropertyType(String className, String propertyName)
 		throws MappingException {
 		return getEntityPersister(className).getPropertyType(propertyName);
 	}
 
 	public ConnectionProvider getConnectionProvider() {
 		return serviceRegistry.getService( JdbcServices.class ).getConnectionProvider();
 	}
 
 	/**
 	 * Closes the session factory, releasing all held resources.
 	 *
 	 * <ol>
 	 * <li>cleans up used cache regions and "stops" the cache provider.
 	 * <li>close the JDBC connection
 	 * <li>remove the JNDI binding
 	 * </ol>
 	 *
 	 * Note: Be aware that the sessionFactory instance still can
 	 * be a "heavy" object memory wise after close() has been called.  Thus
 	 * it is important to not keep referencing the instance to let the garbage
 	 * collector release the memory.
 	 */
 	public void close() throws HibernateException {
 
 		if ( isClosed ) {
             LOG.trace("Already closed");
 			return;
 		}
 
         LOG.closing();
 
 		isClosed = true;
 
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			EntityPersister p = (EntityPersister) iter.next();
 			if ( p.hasCache() ) {
 				p.getCacheAccessStrategy().getRegion().destroy();
 			}
 		}
 
 		iter = collectionPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			CollectionPersister p = (CollectionPersister) iter.next();
 			if ( p.hasCache() ) {
 				p.getCacheAccessStrategy().getRegion().destroy();
 			}
 		}
 
 		if ( settings.isQueryCacheEnabled() )  {
 			queryCache.destroy();
 
 			iter = queryCaches.values().iterator();
 			while ( iter.hasNext() ) {
 				QueryCache cache = (QueryCache) iter.next();
 				cache.destroy();
 			}
 			updateTimestampsCache.destroy();
 		}
 
 		settings.getRegionFactory().stop();
 
 		if ( settings.isAutoDropSchema() ) {
 			schemaExport.drop( false, true );
 		}
 
 		SessionFactoryObjectFactory.removeInstance(uuid, name, properties);
 
 		observer.sessionFactoryClosed( this );
 		eventListeners.destroyListeners();
 	}
 
 	private class CacheImpl implements Cache {
 		public boolean containsEntity(Class entityClass, Serializable identifier) {
 			return containsEntity( entityClass.getName(), identifier );
 		}
 
 		public boolean containsEntity(String entityName, Serializable identifier) {
 			EntityPersister p = getEntityPersister( entityName );
 			return p.hasCache() &&
 					p.getCacheAccessStrategy().getRegion().contains( buildCacheKey( identifier, p ) );
 		}
 
 		public void evictEntity(Class entityClass, Serializable identifier) {
 			evictEntity( entityClass.getName(), identifier );
 		}
 
 		public void evictEntity(String entityName, Serializable identifier) {
 			EntityPersister p = getEntityPersister( entityName );
 			if ( p.hasCache() ) {
                 if (LOG.isDebugEnabled()) LOG.debugf("Evicting second-level cache: %s",
                                                      MessageHelper.infoString(p, identifier, SessionFactoryImpl.this));
 				p.getCacheAccessStrategy().evict( buildCacheKey( identifier, p ) );
 			}
 		}
 
 		private CacheKey buildCacheKey(Serializable identifier, EntityPersister p) {
 			return new CacheKey(
 					identifier,
 					p.getIdentifierType(),
 					p.getRootEntityName(),
 					EntityMode.POJO,
 					SessionFactoryImpl.this
 			);
 		}
 
 		public void evictEntityRegion(Class entityClass) {
 			evictEntityRegion( entityClass.getName() );
 		}
 
 		public void evictEntityRegion(String entityName) {
 			EntityPersister p = getEntityPersister( entityName );
 			if ( p.hasCache() ) {
                 LOG.debugf("Evicting second-level cache: %s", p.getEntityName());
 				p.getCacheAccessStrategy().evictAll();
 			}
 		}
 
 		public void evictEntityRegions() {
 			Iterator entityNames = entityPersisters.keySet().iterator();
 			while ( entityNames.hasNext() ) {
 				evictEntityRegion( ( String ) entityNames.next() );
 			}
 		}
 
 		public boolean containsCollection(String role, Serializable ownerIdentifier) {
 			CollectionPersister p = getCollectionPersister( role );
 			return p.hasCache() &&
 					p.getCacheAccessStrategy().getRegion().contains( buildCacheKey( ownerIdentifier, p ) );
 		}
 
 		public void evictCollection(String role, Serializable ownerIdentifier) {
 			CollectionPersister p = getCollectionPersister( role );
 			if ( p.hasCache() ) {
                 if (LOG.isDebugEnabled()) LOG.debugf("Evicting second-level cache: %s",
                                                      MessageHelper.collectionInfoString(p, ownerIdentifier, SessionFactoryImpl.this));
 				CacheKey cacheKey = buildCacheKey( ownerIdentifier, p );
 				p.getCacheAccessStrategy().evict( cacheKey );
 			}
 		}
 
 		private CacheKey buildCacheKey(Serializable ownerIdentifier, CollectionPersister p) {
 			return new CacheKey(
 					ownerIdentifier,
 					p.getKeyType(),
 					p.getRole(),
 					EntityMode.POJO,
 					SessionFactoryImpl.this
 			);
 		}
 
 		public void evictCollectionRegion(String role) {
 			CollectionPersister p = getCollectionPersister( role );
 			if ( p.hasCache() ) {
                 LOG.debugf("Evicting second-level cache: %s", p.getRole());
 				p.getCacheAccessStrategy().evictAll();
 			}
 		}
 
 		public void evictCollectionRegions() {
 			Iterator collectionRoles = collectionPersisters.keySet().iterator();
 			while ( collectionRoles.hasNext() ) {
 				evictCollectionRegion( ( String ) collectionRoles.next() );
 			}
 		}
 
 		public boolean containsQuery(String regionName) {
 			return queryCaches.get( regionName ) != null;
 		}
 
 		public void evictDefaultQueryRegion() {
 			if ( settings.isQueryCacheEnabled() ) {
 				queryCache.clear();
 			}
 		}
 
 		public void evictQueryRegion(String regionName) {
             if (regionName == null) throw new NullPointerException(
                                                                    "Region-name cannot be null (use Cache#evictDefaultQueryRegion to evict the default query cache)");
             if (settings.isQueryCacheEnabled()) {
                 QueryCache namedQueryCache = queryCaches.get(regionName);
                 // TODO : cleanup entries in queryCaches + allCacheRegions ?
                 if (namedQueryCache != null) namedQueryCache.clear();
 			}
 		}
 
 		public void evictQueryRegions() {
 			if ( queryCaches != null ) {
 				for ( QueryCache queryCache : queryCaches.values() ) {
 					queryCache.clear();
 					// TODO : cleanup entries in queryCaches + allCacheRegions ?
 				}
 			}
 		}
 	}
 
 	public Cache getCache() {
 		return cacheAccess;
 	}
 
 	public void evictEntity(String entityName, Serializable id) throws HibernateException {
 		getCache().evictEntity( entityName, id );
 	}
 
 	public void evictEntity(String entityName) throws HibernateException {
 		getCache().evictEntityRegion( entityName );
 	}
 
 	public void evict(Class persistentClass, Serializable id) throws HibernateException {
 		getCache().evictEntity( persistentClass, id );
 	}
 
 	public void evict(Class persistentClass) throws HibernateException {
 		getCache().evictEntityRegion( persistentClass );
 	}
 
 	public void evictCollection(String roleName, Serializable id) throws HibernateException {
 		getCache().evictCollection( roleName, id );
 	}
 
 	public void evictCollection(String roleName) throws HibernateException {
 		getCache().evictCollectionRegion( roleName );
 	}
 
 	public void evictQueries() throws HibernateException {
 		if ( settings.isQueryCacheEnabled() ) {
 			queryCache.clear();
 		}
 	}
 
 	public void evictQueries(String regionName) throws HibernateException {
 		getCache().evictQueryRegion( regionName );
 	}
 
 	public UpdateTimestampsCache getUpdateTimestampsCache() {
 		return updateTimestampsCache;
 	}
 
 	public QueryCache getQueryCache() {
 		return queryCache;
 	}
 
 	public QueryCache getQueryCache(String regionName) throws HibernateException {
 		if ( regionName == null ) {
 			return getQueryCache();
 		}
 
 		if ( !settings.isQueryCacheEnabled() ) {
 			return null;
 		}
 
 		QueryCache currentQueryCache = queryCaches.get( regionName );
 		if ( currentQueryCache == null ) {
 			currentQueryCache = settings.getQueryCacheFactory().getQueryCache( regionName, updateTimestampsCache, settings, properties );
 			queryCaches.put( regionName, currentQueryCache );
 			allCacheRegions.put( currentQueryCache.getRegion().getName(), currentQueryCache.getRegion() );
 		}
 
 		return currentQueryCache;
 	}
 
 	public Region getSecondLevelCacheRegion(String regionName) {
 		return allCacheRegions.get( regionName );
 	}
 
 	public Map getAllSecondLevelCacheRegions() {
 		return new HashMap( allCacheRegions );
 	}
 
 	public boolean isClosed() {
 		return isClosed;
 	}
 
 	public Statistics getStatistics() {
 		return statistics;
 	}
 
 	public StatisticsImplementor getStatisticsImplementor() {
 		return (StatisticsImplementor) statistics;
 	}
 
 	public FilterDefinition getFilterDefinition(String filterName) throws HibernateException {
 		FilterDefinition def = ( FilterDefinition ) filters.get( filterName );
 		if ( def == null ) {
 			throw new HibernateException( "No such filter configured [" + filterName + "]" );
 		}
 		return def;
 	}
 
 	public boolean containsFetchProfileDefinition(String name) {
 		return fetchProfiles.containsKey( name );
 	}
 
 	public Set getDefinedFilterNames() {
 		return filters.keySet();
 	}
 
 	public IdentifierGenerator getIdentifierGenerator(String rootEntityName) {
 		return (IdentifierGenerator) identifierGenerators.get(rootEntityName);
 	}
 
 	private org.hibernate.engine.transaction.spi.TransactionFactory transactionFactory() {
 		return serviceRegistry.getService( org.hibernate.engine.transaction.spi.TransactionFactory.class );
 	}
 
 	private boolean canAccessTransactionManager() {
 		try {
 			return serviceRegistry.getService( JtaPlatform.class ).retrieveTransactionManager() != null;
 		}
 		catch (Exception e) {
 			return false;
 		}
 	}
 
 	private CurrentSessionContext buildCurrentSessionContext() {
 		String impl = properties.getProperty( Environment.CURRENT_SESSION_CONTEXT_CLASS );
 		// for backward-compatibility
 		if ( impl == null ) {
 			if ( canAccessTransactionManager() ) {
 				impl = "jta";
 			}
 			else {
 				return null;
 			}
 		}
 
 		if ( "jta".equals( impl ) ) {
 			if ( ! transactionFactory().compatibleWithJtaSynchronization() ) {
                 LOG.autoFlushWillNotWork();
 			}
 			return new JTASessionContext( this );
 		}
 		else if ( "thread".equals( impl ) ) {
 			return new ThreadLocalSessionContext( this );
 		}
 		else if ( "managed".equals( impl ) ) {
 			return new ManagedSessionContext( this );
 		}
 		else {
 			try {
 				Class implClass = ReflectHelper.classForName( impl );
 				return ( CurrentSessionContext ) implClass
 						.getConstructor( new Class[] { SessionFactoryImplementor.class } )
 						.newInstance( this );
 			}
 			catch( Throwable t ) {
                 LOG.unableToConstructCurrentSessionContext(impl, t);
 				return null;
 			}
 		}
 	}
 
 	public EventListeners getEventListeners() {
 		return eventListeners;
 	}
 
 	@Override
 	public ServiceRegistry getServiceRegistry() {
 		return serviceRegistry;
 	}
 
 	public EntityNotFoundDelegate getEntityNotFoundDelegate() {
 		return entityNotFoundDelegate;
 	}
 
 	public SQLFunctionRegistry getSqlFunctionRegistry() {
 		return sqlFunctionRegistry;
 	}
 
 	public FetchProfile getFetchProfile(String name) {
 		return ( FetchProfile ) fetchProfiles.get( name );
 	}
 
 	public TypeHelper getTypeHelper() {
 		return typeHelper;
 	}
 
 	/**
 	 * Custom serialization hook used during Session serialization.
 	 *
 	 * @param oos The stream to which to write the factory
 	 * @throws IOException Indicates problems writing out the serial data stream
 	 */
 	void serialize(ObjectOutputStream oos) throws IOException {
 		oos.writeUTF( uuid );
 		oos.writeBoolean( name != null );
 		if ( name != null ) {
 			oos.writeUTF( name );
 		}
 	}
 
 	/**
 	 * Custom deserialization hook used during Session deserialization.
 	 *
 	 * @param ois The stream from which to "read" the factory
 	 * @return The deserialized factory
 	 * @throws IOException indicates problems reading back serial data stream
 	 * @throws ClassNotFoundException indicates problems reading back serial data stream
 	 */
 	static SessionFactoryImpl deserialize(ObjectInputStream ois) throws IOException, ClassNotFoundException {
 		String uuid = ois.readUTF();
 		boolean isNamed = ois.readBoolean();
 		String name = null;
 		if ( isNamed ) {
 			name = ois.readUTF();
 		}
 		Object result = SessionFactoryObjectFactory.getInstance( uuid );
 		if ( result == null ) {
             LOG.trace("Could not locate session factory by uuid [" + uuid + "] during session deserialization; trying name");
 			if ( isNamed ) {
 				result = SessionFactoryObjectFactory.getNamedInstance( name );
 			}
 			if ( result == null ) {
 				throw new InvalidObjectException( "could not resolve session factory during session deserialization [uuid=" + uuid + ", name=" + name + "]" );
 			}
 		}
 		return ( SessionFactoryImpl ) result;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/impl/SessionImpl.java b/hibernate-core/src/main/java/org/hibernate/impl/SessionImpl.java
index 4f9f196b3b..cd09279ecb 100644
--- a/hibernate-core/src/main/java/org/hibernate/impl/SessionImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/impl/SessionImpl.java
@@ -1,2374 +1,2214 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2005-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.impl;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Reader;
 import java.io.Serializable;
 import java.sql.Blob;
 import java.sql.Clob;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import org.hibernate.CacheMode;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.Criteria;
 import org.hibernate.EntityMode;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.Filter;
 import org.hibernate.FlushMode;
 import org.hibernate.HibernateException;
 import org.hibernate.HibernateLogger;
 import org.hibernate.Interceptor;
 import org.hibernate.LobHelper;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.ObjectDeletedException;
 import org.hibernate.Query;
 import org.hibernate.QueryException;
 import org.hibernate.ReplicationMode;
 import org.hibernate.SQLQuery;
 import org.hibernate.ScrollMode;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.SessionException;
 import org.hibernate.Transaction;
 import org.hibernate.TransientObjectException;
 import org.hibernate.TypeHelper;
 import org.hibernate.UnknownProfileException;
 import org.hibernate.UnresolvableObjectException;
 import org.hibernate.collection.PersistentCollection;
 import org.hibernate.engine.ActionQueue;
 import org.hibernate.engine.CollectionEntry;
 import org.hibernate.engine.EntityEntry;
 import org.hibernate.engine.EntityKey;
 import org.hibernate.engine.LoadQueryInfluencers;
 import org.hibernate.engine.NonFlushedChanges;
 import org.hibernate.engine.PersistenceContext;
 import org.hibernate.engine.QueryParameters;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.StatefulPersistenceContext;
 import org.hibernate.engine.Status;
 import org.hibernate.engine.jdbc.LobCreationContext;
 import org.hibernate.engine.jdbc.LobCreator;
 import org.hibernate.engine.query.FilterQueryPlan;
 import org.hibernate.engine.query.HQLQueryPlan;
 import org.hibernate.engine.query.NativeSQLQueryPlan;
 import org.hibernate.engine.query.sql.NativeSQLQuerySpecification;
 import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
 import org.hibernate.engine.transaction.spi.TransactionContext;
 import org.hibernate.engine.transaction.spi.TransactionCoordinator;
 import org.hibernate.engine.transaction.spi.TransactionImplementor;
 import org.hibernate.event.AutoFlushEvent;
 import org.hibernate.event.AutoFlushEventListener;
 import org.hibernate.event.DeleteEvent;
 import org.hibernate.event.DeleteEventListener;
 import org.hibernate.event.DirtyCheckEvent;
 import org.hibernate.event.DirtyCheckEventListener;
 import org.hibernate.event.EventListeners;
 import org.hibernate.event.EventSource;
 import org.hibernate.event.EvictEvent;
 import org.hibernate.event.EvictEventListener;
 import org.hibernate.event.FlushEvent;
 import org.hibernate.event.FlushEventListener;
 import org.hibernate.event.InitializeCollectionEvent;
 import org.hibernate.event.InitializeCollectionEventListener;
 import org.hibernate.event.LoadEvent;
 import org.hibernate.event.LoadEventListener;
 import org.hibernate.event.LoadEventListener.LoadType;
 import org.hibernate.event.LockEvent;
 import org.hibernate.event.LockEventListener;
 import org.hibernate.event.MergeEvent;
 import org.hibernate.event.MergeEventListener;
 import org.hibernate.event.PersistEvent;
 import org.hibernate.event.PersistEventListener;
 import org.hibernate.event.RefreshEvent;
 import org.hibernate.event.RefreshEventListener;
 import org.hibernate.event.ReplicateEvent;
 import org.hibernate.event.ReplicateEventListener;
 import org.hibernate.event.SaveOrUpdateEvent;
 import org.hibernate.event.SaveOrUpdateEventListener;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.jdbc.WorkExecutorVisitable;
 import org.hibernate.jdbc.ReturningWork;
 import org.hibernate.jdbc.Work;
 import org.hibernate.jdbc.WorkExecutor;
 import org.hibernate.loader.criteria.CriteriaLoader;
 import org.hibernate.loader.custom.CustomLoader;
 import org.hibernate.loader.custom.CustomQuery;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.OuterJoinLoadable;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.LazyInitializer;
 import org.hibernate.stat.SessionStatistics;
 import org.hibernate.stat.SessionStatisticsImpl;
 import org.hibernate.type.SerializationException;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 
 /**
  * Concrete implementation of a Session.
  *
  * Exposes two interfaces:<ul>
  *     <li>{@link Session} to the application</li>
  *     <li>{@link org.hibernate.engine.SessionImplementor} to other Hibernate components (SPI)</li>
  * </ul>
  *
  * This class is not thread-safe.
  *
  * @author Gavin King
  */
 public final class SessionImpl
 		extends AbstractSessionImpl
 		implements EventSource,
-				   org.hibernate.classic.Session,
+				   org.hibernate.Session,
 				   TransactionContext,
 				   LobCreationContext {
 
 	// todo : need to find a clean way to handle the "event source" role
 	// a separate class responsible for generating/dispatching events just duplicates most of the Session methods...
 	// passing around separate interceptor, factory, actionQueue, and persistentContext is not manageable...
 
     private static final HibernateLogger LOG = Logger.getMessageLogger(HibernateLogger.class, SessionImpl.class.getName());
 
 	private transient long timestamp;
 
 	private transient ActionQueue actionQueue;
 	private transient StatefulPersistenceContext persistenceContext;
 	private transient TransactionCoordinatorImpl transactionCoordinator;
 	private transient EventListeners listeners;
 	private transient Interceptor interceptor;
 	private transient EntityNameResolver entityNameResolver = new CoordinatingEntityNameResolver();
 
 	private transient ConnectionReleaseMode connectionReleaseMode;
 	private transient FlushMode flushMode = FlushMode.AUTO;
 	private transient CacheMode cacheMode = CacheMode.NORMAL;
 	private transient EntityMode entityMode = EntityMode.POJO;
 	private transient boolean autoClear; //for EJB3
 	private transient boolean autoJoinTransactions = true;
 
 	private transient int dontFlushFromFind = 0;
 	private transient boolean flushBeforeCompletionEnabled;
 	private transient boolean autoCloseSessionEnabled;
 
 	private transient LoadQueryInfluencers loadQueryInfluencers;
 
 	private transient Session rootSession;
 	private transient Map childSessionsByEntityMode;
 
 	/**
 	 * Constructor used in building "child sessions".
 	 *
 	 * @param parent The parent session
 	 * @param entityMode
 	 */
 	private SessionImpl(SessionImpl parent, EntityMode entityMode) {
 		super( parent.factory );
 		this.rootSession = parent;
 		this.timestamp = parent.timestamp;
 		this.transactionCoordinator = parent.transactionCoordinator;
 		this.interceptor = parent.interceptor;
 		this.listeners = parent.listeners;
 		this.actionQueue = new ActionQueue( this );
 		this.entityMode = entityMode;
 		this.persistenceContext = new StatefulPersistenceContext( this );
 		this.flushBeforeCompletionEnabled = false;
 		this.autoCloseSessionEnabled = false;
 		this.connectionReleaseMode = null;
 
 		loadQueryInfluencers = new LoadQueryInfluencers( factory );
 
         if (factory.getStatistics().isStatisticsEnabled()) factory.getStatisticsImplementor().openSession();
 
         LOG.debugf("Opened session [%s]", entityMode);
 	}
 
 	/**
 	 * Constructor used for openSession(...) processing, as well as construction
 	 * of sessions for getCurrentSession().
 	 *
 	 * @param connection The user-supplied connection to use for this session.
 	 * @param factory The factory from which this session was obtained
 	 * @param autoclose NOT USED
 	 * @param timestamp The timestamp for this session
 	 * @param interceptor The interceptor to be applied to this session
 	 * @param entityMode The entity-mode for this session
 	 * @param flushBeforeCompletionEnabled Should we auto flush before completion of transaction
 	 * @param autoCloseSessionEnabled Should we auto close after completion of transaction
 	 * @param connectionReleaseMode The mode by which we should release JDBC connections.
 	 */
 	SessionImpl(
 			final Connection connection,
 			final SessionFactoryImpl factory,
 			final boolean autoclose,
 			final long timestamp,
 			final Interceptor interceptor,
 			final EntityMode entityMode,
 			final boolean flushBeforeCompletionEnabled,
 			final boolean autoCloseSessionEnabled,
 			final ConnectionReleaseMode connectionReleaseMode) {
 		super( factory );
 		this.rootSession = null;
 		this.timestamp = timestamp;
 		this.entityMode = entityMode;
 		this.interceptor = interceptor;
 		this.listeners = factory.getEventListeners();
 		this.actionQueue = new ActionQueue( this );
 		this.persistenceContext = new StatefulPersistenceContext( this );
 		this.flushBeforeCompletionEnabled = flushBeforeCompletionEnabled;
 		this.autoCloseSessionEnabled = autoCloseSessionEnabled;
 		this.connectionReleaseMode = connectionReleaseMode;
 
 		this.transactionCoordinator = new TransactionCoordinatorImpl( connection, this );
 		this.transactionCoordinator.getJdbcCoordinator().getLogicalConnection().addObserver(
 				new ConnectionObserverStatsBridge( factory )
 		);
 
 		loadQueryInfluencers = new LoadQueryInfluencers( factory );
 
         if (factory.getStatistics().isStatisticsEnabled()) factory.getStatisticsImplementor().openSession();
 
         LOG.debugf("Opened session at timestamp: %s", timestamp);
 	}
 
 	public Session getSession(EntityMode entityMode) {
 		if ( this.entityMode == entityMode ) {
 			return this;
 		}
 
 		if ( rootSession != null ) {
 			return rootSession.getSession( entityMode );
 		}
 
 		errorIfClosed();
 		checkTransactionSynchStatus();
 
 		SessionImpl rtn = null;
 		if ( childSessionsByEntityMode == null ) {
 			childSessionsByEntityMode = new HashMap();
 		}
 		else {
 			rtn = (SessionImpl) childSessionsByEntityMode.get( entityMode );
 		}
 
 		if ( rtn == null ) {
 			rtn = new SessionImpl( this, entityMode );
 			childSessionsByEntityMode.put( entityMode, rtn );
 		}
 
 		return rtn;
 	}
 
 	public void clear() {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		persistenceContext.clear();
 		actionQueue.clear();
 	}
 
 	public long getTimestamp() {
 		checkTransactionSynchStatus();
 		return timestamp;
 	}
 
 	public Connection close() throws HibernateException {
         LOG.trace("Closing session");
 		if ( isClosed() ) {
 			throw new SessionException( "Session was already closed" );
 		}
 
 
 		if ( factory.getStatistics().isStatisticsEnabled() ) {
 			factory.getStatisticsImplementor().closeSession();
 		}
 
 		try {
 			try {
 				if ( childSessionsByEntityMode != null ) {
 					Iterator childSessions = childSessionsByEntityMode.values().iterator();
 					while ( childSessions.hasNext() ) {
 						final SessionImpl child = ( SessionImpl ) childSessions.next();
 						child.close();
 					}
 				}
 			}
 			catch( Throwable t ) {
 				// just ignore
 			}
 
 			if ( rootSession == null ) {
 				return transactionCoordinator.close();
 			}
 			else {
 				return null;
 			}
 		}
 		finally {
 			setClosed();
 			cleanup();
 		}
 	}
 
 	public ConnectionReleaseMode getConnectionReleaseMode() {
 		return connectionReleaseMode;
 	}
 
 	@Override
 	public boolean shouldAutoJoinTransaction() {
 		return autoJoinTransactions;
 	}
 
 	public boolean isAutoCloseSessionEnabled() {
 		return autoCloseSessionEnabled;
 	}
 
 	public boolean isOpen() {
 		checkTransactionSynchStatus();
 		return !isClosed();
 	}
 
 	public boolean isFlushModeNever() {
 		return FlushMode.isManualFlushMode( getFlushMode() );
 	}
 
 	public boolean isFlushBeforeCompletionEnabled() {
 		return flushBeforeCompletionEnabled;
 	}
 
 	public void managedFlush() {
 		if ( isClosed() ) {
             LOG.trace("Skipping auto-flush due to session closed");
 			return;
 		}
         LOG.trace( "Automatically flushing session" );
 		flush();
 
 		if ( childSessionsByEntityMode != null ) {
 			Iterator iter = childSessionsByEntityMode.values().iterator();
 			while ( iter.hasNext() ) {
 				( (Session) iter.next() ).flush();
 			}
 		}
 	}
 
 	/**
 	 * Return changes to this session and its child sessions that have not been flushed yet.
 	 * <p/>
 	 * @return The non-flushed changes.
 	 */
 	public NonFlushedChanges getNonFlushedChanges() throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		NonFlushedChanges nonFlushedChanges = new NonFlushedChangesImpl( this );
 		if ( childSessionsByEntityMode != null ) {
 			Iterator it = childSessionsByEntityMode.values().iterator();
 			while ( it.hasNext() ) {
 				nonFlushedChanges.extractFromSession( ( EventSource ) it.next() );
 			}
 		}
 		return nonFlushedChanges;
 	}
 
 	/**
 	 * Apply non-flushed changes from a different session to this session. It is assumed
 	 * that this SessionImpl is "clean" (e.g., has no non-flushed changes, no cached entities,
 	 * no cached collections, no queued actions). The specified NonFlushedChanges object cannot
 	 * be bound to any session.
 	 * <p/>
 	 * @param nonFlushedChanges the non-flushed changes
 	 */
 	public void applyNonFlushedChanges(NonFlushedChanges nonFlushedChanges) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		replacePersistenceContext( ( ( NonFlushedChangesImpl ) nonFlushedChanges ).getPersistenceContext( entityMode) );
 		replaceActionQueue( ( ( NonFlushedChangesImpl ) nonFlushedChanges ).getActionQueue( entityMode ) );
 		if ( childSessionsByEntityMode != null ) {
 			for ( Iterator it = childSessionsByEntityMode.values().iterator(); it.hasNext(); ) {
 				( ( SessionImpl ) it.next() ).applyNonFlushedChanges( nonFlushedChanges );
 			}
 		}
 	}
 
 	private void replacePersistenceContext(StatefulPersistenceContext persistenceContextNew) {
 		if ( persistenceContextNew.getSession() != null ) {
 			throw new IllegalStateException( "new persistence context is already connected to a session " );
 		}
 		persistenceContext.clear();
 		ObjectInputStream ois = null;
 		try {
 			ois = new ObjectInputStream( new ByteArrayInputStream( serializePersistenceContext( persistenceContextNew ) ) );
 			this.persistenceContext = StatefulPersistenceContext.deserialize( ois, this );
 		}
 		catch (IOException ex) {
 			throw new SerializationException( "could not deserialize the persistence context",  ex );
 		}
 		catch (ClassNotFoundException ex) {
 			throw new SerializationException( "could not deserialize the persistence context", ex );
 		}
 		finally {
 			try {
 				if (ois != null) ois.close();
 			}
 			catch (IOException ex) {}
 		}
 	}
 
 	private static byte[] serializePersistenceContext(StatefulPersistenceContext pc) {
 		ByteArrayOutputStream baos = new ByteArrayOutputStream( 512 );
 		ObjectOutputStream oos = null;
 		try {
 			oos = new ObjectOutputStream( baos );
 			( pc ).serialize( oos );
 		}
 		catch (IOException ex) {
 			throw new SerializationException( "could not serialize persistence context", ex );
 		}
 		finally {
 			if ( oos != null ) {
 				try {
 					oos.close();
 				}
 				catch( IOException ex ) {
 					//ignore
 				}
 			}
 		}
 		return baos.toByteArray();
 	}
 
 	private void replaceActionQueue(ActionQueue actionQueueNew) {
 		if ( actionQueue.hasAnyQueuedActions() ) {
 			throw new IllegalStateException( "cannot replace an ActionQueue with queued actions " );
 		}
 		actionQueue.clear();
 		ObjectInputStream ois = null;
 		try {
 			ois = new ObjectInputStream( new ByteArrayInputStream( serializeActionQueue( actionQueueNew ) ) );
 			actionQueue = ActionQueue.deserialize( ois, this );
 		}
 		catch (IOException ex) {
 			throw new SerializationException( "could not deserialize the action queue",  ex );
 		}
 		catch (ClassNotFoundException ex) {
 			throw new SerializationException( "could not deserialize the action queue", ex );
 		}
 		finally {
 			try {
 				if (ois != null) ois.close();
 			}
 			catch (IOException ex) {}
 		}
 	}
 
 	private static byte[] serializeActionQueue(ActionQueue actionQueue) {
 		ByteArrayOutputStream baos = new ByteArrayOutputStream( 512 );
 		ObjectOutputStream oos = null;
 		try {
 			oos = new ObjectOutputStream( baos );
 			actionQueue.serialize( oos );
 		}
 		catch (IOException ex) {
 			throw new SerializationException( "could not serialize action queue", ex );
 		}
 		finally {
 			if ( oos != null ) {
 				try {
 					oos.close();
 				}
 				catch( IOException ex ) {
 					//ignore
 				}
 			}
 		}
 		return baos.toByteArray();
 	}
 
 	public boolean shouldAutoClose() {
 		return isAutoCloseSessionEnabled() && !isClosed();
 	}
 
 	public void managedClose() {
         LOG.trace( "Automatically closing session" );
 		close();
 	}
 
 	public Connection connection() throws HibernateException {
 		errorIfClosed();
 		return transactionCoordinator.getJdbcCoordinator().getLogicalConnection().getDistinctConnectionProxy();
 	}
 
 	public boolean isConnected() {
 		checkTransactionSynchStatus();
 		return !isClosed() && transactionCoordinator.getJdbcCoordinator().getLogicalConnection().isOpen();
 	}
 
 	public boolean isTransactionInProgress() {
 		checkTransactionSynchStatus();
 		return !isClosed() && transactionCoordinator.isTransactionInProgress();
 	}
 
 	@Override
 	public Connection disconnect() throws HibernateException {
 		errorIfClosed();
         LOG.debugf("Disconnecting session");
 		return transactionCoordinator.getJdbcCoordinator().getLogicalConnection().manualDisconnect();
 	}
 
 	@Override
 	public void reconnect(Connection conn) throws HibernateException {
 		errorIfClosed();
         LOG.debugf("Reconnecting session");
 		checkTransactionSynchStatus();
 		transactionCoordinator.getJdbcCoordinator().getLogicalConnection().manualReconnect( conn );
 	}
 
 	public void setAutoClear(boolean enabled) {
 		errorIfClosed();
 		autoClear = enabled;
 	}
 
 	@Override
 	public void disableTransactionAutoJoin() {
 		errorIfClosed();
 		autoJoinTransactions = false;
 	}
 
 	/**
 	 * Check if there is a Hibernate or JTA transaction in progress and,
 	 * if there is not, flush if necessary, make sure the connection has
 	 * been committed (if it is not in autocommit mode) and run the after
 	 * completion processing
 	 */
 	public void afterOperation(boolean success) {
 		if ( ! transactionCoordinator.isTransactionInProgress() ) {
 			transactionCoordinator.afterNonTransactionalQuery( success );
 		}
 	}
 
 	@Override
 	public void afterTransactionBegin(TransactionImplementor hibernateTransaction) {
 		errorIfClosed();
 		interceptor.afterTransactionBegin( hibernateTransaction );
 	}
 
 	@Override
 	public void beforeTransactionCompletion(TransactionImplementor hibernateTransaction) {
 		LOG.trace( "before transaction completion" );
 		actionQueue.beforeTransactionCompletion();
 		if ( rootSession == null ) {
 			try {
 				interceptor.beforeTransactionCompletion( hibernateTransaction );
 			}
 			catch (Throwable t) {
                 LOG.exceptionInBeforeTransactionCompletionInterceptor(t);
 			}
 		}
 	}
 
 	@Override
 	public void afterTransactionCompletion(TransactionImplementor hibernateTransaction, boolean successful) {
 		LOG.trace( "after transaction completion" );
 		persistenceContext.afterTransactionCompletion();
 		actionQueue.afterTransactionCompletion( successful );
 		if ( rootSession == null && hibernateTransaction != null ) {
 			try {
 				interceptor.afterTransactionCompletion( hibernateTransaction );
 			}
 			catch (Throwable t) {
                 LOG.exceptionInAfterTransactionCompletionInterceptor(t);
 			}
 		}
 		if ( autoClear ) {
 			clear();
 		}
 	}
 
 	/**
 	 * clear all the internal collections, just
 	 * to help the garbage collector, does not
 	 * clear anything that is needed during the
 	 * afterTransactionCompletion() phase
 	 */
 	private void cleanup() {
 		persistenceContext.clear();
 	}
 
 	public LockMode getCurrentLockMode(Object object) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		if ( object == null ) {
 			throw new NullPointerException( "null object passed to getCurrentLockMode()" );
 		}
 		if ( object instanceof HibernateProxy ) {
 			object = ( (HibernateProxy) object ).getHibernateLazyInitializer().getImplementation(this);
 			if ( object == null ) {
 				return LockMode.NONE;
 			}
 		}
 		EntityEntry e = persistenceContext.getEntry(object);
 		if ( e == null ) {
 			throw new TransientObjectException( "Given object not associated with the session" );
 		}
 		if ( e.getStatus() != Status.MANAGED ) {
 			throw new ObjectDeletedException(
 					"The given object was deleted",
 					e.getId(),
 					e.getPersister().getEntityName()
 				);
 		}
 		return e.getLockMode();
 	}
 
 	public Object getEntityUsingInterceptor(EntityKey key) throws HibernateException {
 		errorIfClosed();
 		// todo : should this get moved to PersistentContext?
 		// logically, is PersistentContext the "thing" to which an interceptor gets attached?
 		final Object result = persistenceContext.getEntity(key);
 		if ( result == null ) {
 			final Object newObject = interceptor.getEntity( key.getEntityName(), key.getIdentifier() );
 			if ( newObject != null ) {
 				lock( newObject, LockMode.NONE );
 			}
 			return newObject;
 		}
 		else {
 			return result;
 		}
 	}
 
 
 	// saveOrUpdate() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void saveOrUpdate(Object object) throws HibernateException {
 		saveOrUpdate( null, object );
 	}
 
 	public void saveOrUpdate(String entityName, Object obj) throws HibernateException {
 		fireSaveOrUpdate( new SaveOrUpdateEvent( entityName, obj, this ) );
 	}
 
 	private void fireSaveOrUpdate(SaveOrUpdateEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		SaveOrUpdateEventListener[] saveOrUpdateEventListener = listeners.getSaveOrUpdateEventListeners();
 		for ( int i = 0; i < saveOrUpdateEventListener.length; i++ ) {
 			saveOrUpdateEventListener[i].onSaveOrUpdate(event);
 		}
 	}
 
 
 	// save() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-	public void save(Object obj, Serializable id) throws HibernateException {
-		save(null, obj, id);
-	}
-
 	public Serializable save(Object obj) throws HibernateException {
 		return save( null, obj );
 	}
 
 	public Serializable save(String entityName, Object object) throws HibernateException {
 		return fireSave( new SaveOrUpdateEvent( entityName, object, this ) );
 	}
 
-	public void save(String entityName, Object object, Serializable id) throws HibernateException {
-		fireSave( new SaveOrUpdateEvent( entityName, object, id, this ) );
-	}
-
 	private Serializable fireSave(SaveOrUpdateEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		SaveOrUpdateEventListener[] saveEventListener = listeners.getSaveEventListeners();
 		for ( int i = 0; i < saveEventListener.length; i++ ) {
 			saveEventListener[i].onSaveOrUpdate(event);
 		}
 		return event.getResultId();
 	}
 
 
 	// update() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void update(Object obj) throws HibernateException {
 		update(null, obj);
 	}
 
-	public void update(Object obj, Serializable id) throws HibernateException {
-		update( null, obj, id );
-	}
-
 	public void update(String entityName, Object object) throws HibernateException {
 		fireUpdate( new SaveOrUpdateEvent( entityName, object, this ) );
 	}
 
-	public void update(String entityName, Object object, Serializable id) throws HibernateException {
-		fireUpdate( new SaveOrUpdateEvent( entityName, object, id, this ) );
-	}
-
 	private void fireUpdate(SaveOrUpdateEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		SaveOrUpdateEventListener[] updateEventListener = listeners.getUpdateEventListeners();
 		for ( int i = 0; i < updateEventListener.length; i++ ) {
 			updateEventListener[i].onSaveOrUpdate(event);
 		}
 	}
 
 
 	// lock() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void lock(String entityName, Object object, LockMode lockMode) throws HibernateException {
 		fireLock( new LockEvent(entityName, object, lockMode, this) );
 	}
 
 	public LockRequest buildLockRequest(LockOptions lockOptions) {
 		return new LockRequestImpl(lockOptions);
 	}
 
 	public void lock(Object object, LockMode lockMode) throws HibernateException {
 		fireLock( new LockEvent(object, lockMode, this) );
 	}
 
 	private void fireLock(String entityName, Object object, LockOptions options) {
 		fireLock( new LockEvent( entityName, object, options, this) );
 	}
 
 	private void fireLock( Object object, LockOptions options) {
 		fireLock( new LockEvent( object, options, this ) );
 	}
 
 	private void fireLock(LockEvent lockEvent) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		LockEventListener[] lockEventListener = listeners.getLockEventListeners();
 		for ( int i = 0; i < lockEventListener.length; i++ ) {
 			lockEventListener[i].onLock( lockEvent );
 		}
 	}
 
 
 	// persist() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void persist(String entityName, Object object) throws HibernateException {
 		firePersist( new PersistEvent( entityName, object, this ) );
 	}
 
 	public void persist(Object object) throws HibernateException {
 		persist( null, object );
 	}
 
 	public void persist(String entityName, Object object, Map copiedAlready)
 	throws HibernateException {
 		firePersist( copiedAlready, new PersistEvent( entityName, object, this ) );
 	}
 
 	private void firePersist(Map copiedAlready, PersistEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		PersistEventListener[] persistEventListener = listeners.getPersistEventListeners();
 		for ( int i = 0; i < persistEventListener.length; i++ ) {
 			persistEventListener[i].onPersist(event, copiedAlready);
 		}
 	}
 
 	private void firePersist(PersistEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		PersistEventListener[] createEventListener = listeners.getPersistEventListeners();
 		for ( int i = 0; i < createEventListener.length; i++ ) {
 			createEventListener[i].onPersist(event);
 		}
 	}
 
 
 	// persistOnFlush() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void persistOnFlush(String entityName, Object object)
 			throws HibernateException {
 		firePersistOnFlush( new PersistEvent( entityName, object, this ) );
 	}
 
 	public void persistOnFlush(Object object) throws HibernateException {
 		persist( null, object );
 	}
 
 	public void persistOnFlush(String entityName, Object object, Map copiedAlready)
 			throws HibernateException {
 		firePersistOnFlush( copiedAlready, new PersistEvent( entityName, object, this ) );
 	}
 
 	private void firePersistOnFlush(Map copiedAlready, PersistEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		PersistEventListener[] persistEventListener = listeners.getPersistOnFlushEventListeners();
 		for ( int i = 0; i < persistEventListener.length; i++ ) {
 			persistEventListener[i].onPersist(event, copiedAlready);
 		}
 	}
 
 	private void firePersistOnFlush(PersistEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		PersistEventListener[] createEventListener = listeners.getPersistOnFlushEventListeners();
 		for ( int i = 0; i < createEventListener.length; i++ ) {
 			createEventListener[i].onPersist(event);
 		}
 	}
 
 
 	// merge() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public Object merge(String entityName, Object object) throws HibernateException {
 		return fireMerge( new MergeEvent( entityName, object, this ) );
 	}
 
 	public Object merge(Object object) throws HibernateException {
 		return merge( null, object );
 	}
 
 	public void merge(String entityName, Object object, Map copiedAlready) throws HibernateException {
 		fireMerge( copiedAlready, new MergeEvent( entityName, object, this ) );
 	}
 
 	private Object fireMerge(MergeEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		MergeEventListener[] mergeEventListener = listeners.getMergeEventListeners();
 		for ( int i = 0; i < mergeEventListener.length; i++ ) {
 			mergeEventListener[i].onMerge(event);
 		}
 		return event.getResult();
 	}
 
 	private void fireMerge(Map copiedAlready, MergeEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		MergeEventListener[] mergeEventListener = listeners.getMergeEventListeners();
 		for ( int i = 0; i < mergeEventListener.length; i++ ) {
 			mergeEventListener[i].onMerge(event, copiedAlready);
 		}
 	}
 
 
-	// saveOrUpdateCopy() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-	public Object saveOrUpdateCopy(String entityName, Object object)
-			throws HibernateException {
-		return fireSaveOrUpdateCopy( new MergeEvent( entityName, object, this ) );
-	}
-
-	public Object saveOrUpdateCopy(Object object) throws HibernateException {
-		return saveOrUpdateCopy( null, object );
-	}
-
-	public Object saveOrUpdateCopy(String entityName, Object object, Serializable id)
-			throws HibernateException {
-		return fireSaveOrUpdateCopy( new MergeEvent( entityName, object, id, this ) );
-	}
-
-	public Object saveOrUpdateCopy(Object object, Serializable id)
-			throws HibernateException {
-		return saveOrUpdateCopy( null, object, id );
-	}
-
-	public void saveOrUpdateCopy(String entityName, Object object, Map copiedAlready)
-			throws HibernateException {
-		fireSaveOrUpdateCopy( copiedAlready, new MergeEvent( entityName, object, this ) );
-	}
-
-	private void fireSaveOrUpdateCopy(Map copiedAlready, MergeEvent event) {
-		errorIfClosed();
-		checkTransactionSynchStatus();
-		MergeEventListener[] saveOrUpdateCopyEventListener = listeners.getSaveOrUpdateCopyEventListeners();
-		for ( int i = 0; i < saveOrUpdateCopyEventListener.length; i++ ) {
-			saveOrUpdateCopyEventListener[i].onMerge(event, copiedAlready);
-		}
-	}
-
-	private Object fireSaveOrUpdateCopy(MergeEvent event) {
-		errorIfClosed();
-		checkTransactionSynchStatus();
-		MergeEventListener[] saveOrUpdateCopyEventListener = listeners.getSaveOrUpdateCopyEventListeners();
-		for ( int i = 0; i < saveOrUpdateCopyEventListener.length; i++ ) {
-			saveOrUpdateCopyEventListener[i].onMerge(event);
-		}
-		return event.getResult();
-	}
-
-
 	// delete() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Delete a persistent object
 	 */
 	public void delete(Object object) throws HibernateException {
 		fireDelete( new DeleteEvent(object, this) );
 	}
 
 	/**
 	 * Delete a persistent object (by explicit entity name)
 	 */
 	public void delete(String entityName, Object object) throws HibernateException {
 		fireDelete( new DeleteEvent( entityName, object, this ) );
 	}
 
 	/**
 	 * Delete a persistent object
 	 */
 	public void delete(String entityName, Object object, boolean isCascadeDeleteEnabled, Set transientEntities) throws HibernateException {
 		fireDelete( new DeleteEvent( entityName, object, isCascadeDeleteEnabled, this ), transientEntities );
 	}
 
 	private void fireDelete(DeleteEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		DeleteEventListener[] deleteEventListener = listeners.getDeleteEventListeners();
 		for ( int i = 0; i < deleteEventListener.length; i++ ) {
 			deleteEventListener[i].onDelete( event );
 		}
 	}
 
 	private void fireDelete(DeleteEvent event, Set transientEntities) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		DeleteEventListener[] deleteEventListener = listeners.getDeleteEventListeners();
 		for ( int i = 0; i < deleteEventListener.length; i++ ) {
 			deleteEventListener[i].onDelete( event, transientEntities );
 		}
 	}
 
 
 	// load()/get() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void load(Object object, Serializable id) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, object, this);
 		fireLoad( event, LoadEventListener.RELOAD );
 	}
 
 	public Object load(Class entityClass, Serializable id) throws HibernateException {
 		return load( entityClass.getName(), id );
 	}
 
 	public Object load(String entityName, Serializable id) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, false, this);
 		boolean success = false;
 		try {
 			fireLoad( event, LoadEventListener.LOAD );
 			if ( event.getResult() == null ) {
 				getFactory().getEntityNotFoundDelegate().handleEntityNotFound( entityName, id );
 			}
 			success = true;
 			return event.getResult();
 		}
 		finally {
 			afterOperation(success);
 		}
 	}
 
 	public Object get(Class entityClass, Serializable id) throws HibernateException {
 		return get( entityClass.getName(), id );
 	}
 
 	public Object get(String entityName, Serializable id) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, false, this);
 		boolean success = false;
 		try {
 			fireLoad(event, LoadEventListener.GET);
 			success = true;
 			return event.getResult();
 		}
 		finally {
 			afterOperation(success);
 		}
 	}
 
 	/**
 	 * Load the data for the object with the specified id into a newly created object.
 	 * This is only called when lazily initializing a proxy.
 	 * Do NOT return a proxy.
 	 */
 	public Object immediateLoad(String entityName, Serializable id) throws HibernateException {
         if (LOG.isDebugEnabled()) {
 			EntityPersister persister = getFactory().getEntityPersister(entityName);
             LOG.debugf("Initializing proxy: %s", MessageHelper.infoString(persister, id, getFactory()));
 		}
 
 		LoadEvent event = new LoadEvent(id, entityName, true, this);
 		fireLoad(event, LoadEventListener.IMMEDIATE_LOAD);
 		return event.getResult();
 	}
 
 	public Object internalLoad(String entityName, Serializable id, boolean eager, boolean nullable) throws HibernateException {
 		// todo : remove
 		LoadEventListener.LoadType type = nullable
 				? LoadEventListener.INTERNAL_LOAD_NULLABLE
 				: eager
 						? LoadEventListener.INTERNAL_LOAD_EAGER
 						: LoadEventListener.INTERNAL_LOAD_LAZY;
 		LoadEvent event = new LoadEvent(id, entityName, true, this);
 		fireLoad(event, type);
 		if ( !nullable ) {
 			UnresolvableObjectException.throwIfNull( event.getResult(), id, entityName );
 		}
 		return event.getResult();
 	}
 
 	public Object load(Class entityClass, Serializable id, LockMode lockMode) throws HibernateException {
 		return load( entityClass.getName(), id, lockMode );
 	}
 
 	public Object load(Class entityClass, Serializable id, LockOptions lockOptions) throws HibernateException {
 		return load( entityClass.getName(), id, lockOptions );
 	}
 
 	public Object load(String entityName, Serializable id, LockMode lockMode) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, lockMode, this);
 		fireLoad( event, LoadEventListener.LOAD );
 		return event.getResult();
 	}
 
 	public Object load(String entityName, Serializable id, LockOptions lockOptions) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, lockOptions, this);
 		fireLoad( event, LoadEventListener.LOAD );
 		return event.getResult();
 	}
 
 	public Object get(Class entityClass, Serializable id, LockMode lockMode) throws HibernateException {
 		return get( entityClass.getName(), id, lockMode );
 	}
 
 	public Object get(Class entityClass, Serializable id, LockOptions lockOptions) throws HibernateException {
 		return get( entityClass.getName(), id, lockOptions );
 	}
 
 	public Object get(String entityName, Serializable id, LockMode lockMode) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, lockMode, this);
 	   	fireLoad(event, LoadEventListener.GET);
 		return event.getResult();
 	}
 
 	public Object get(String entityName, Serializable id, LockOptions lockOptions) throws HibernateException {
 		LoadEvent event = new LoadEvent(id, entityName, lockOptions, this);
 	   	fireLoad( event, LoadEventListener.GET );
 		return event.getResult();
 	}
 
 	private void fireLoad(LoadEvent event, LoadType loadType) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		LoadEventListener[] loadEventListener = listeners.getLoadEventListeners();
 		for ( int i = 0; i < loadEventListener.length; i++ ) {
 			loadEventListener[i].onLoad(event, loadType);
 		}
 	}
 
 
 	// refresh() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void refresh(Object object) throws HibernateException {
 		fireRefresh( new RefreshEvent(object, this) );
 	}
 
 	public void refresh(Object object, LockMode lockMode) throws HibernateException {
 		fireRefresh( new RefreshEvent(object, lockMode, this) );
 	}
 
 	public void refresh(Object object, LockOptions lockOptions) throws HibernateException {
 		fireRefresh( new RefreshEvent(object, lockOptions, this) );
 	}
 
 	public void refresh(Object object, Map refreshedAlready) throws HibernateException {
 		fireRefresh( refreshedAlready, new RefreshEvent( object, this ) );
 	}
 
 	private void fireRefresh(RefreshEvent refreshEvent) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		RefreshEventListener[] refreshEventListener = listeners.getRefreshEventListeners();
 		for ( int i = 0; i < refreshEventListener.length; i++ ) {
 			refreshEventListener[i].onRefresh( refreshEvent );
 		}
 	}
 
 	private void fireRefresh(Map refreshedAlready, RefreshEvent refreshEvent) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		RefreshEventListener[] refreshEventListener = listeners.getRefreshEventListeners();
 		for ( int i = 0; i < refreshEventListener.length; i++ ) {
 			refreshEventListener[i].onRefresh( refreshEvent, refreshedAlready );
 		}
 	}
 
 
 	// replicate() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void replicate(Object obj, ReplicationMode replicationMode) throws HibernateException {
 		fireReplicate( new ReplicateEvent(obj, replicationMode, this) );
 	}
 
 	public void replicate(String entityName, Object obj, ReplicationMode replicationMode)
 	throws HibernateException {
 		fireReplicate( new ReplicateEvent( entityName, obj, replicationMode, this ) );
 	}
 
 	private void fireReplicate(ReplicateEvent event) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		ReplicateEventListener[] replicateEventListener = listeners.getReplicateEventListeners();
 		for ( int i = 0; i < replicateEventListener.length; i++ ) {
 			replicateEventListener[i].onReplicate(event);
 		}
 	}
 
 
 	// evict() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * remove any hard references to the entity that are held by the infrastructure
 	 * (references held by application or other persistant instances are okay)
 	 */
 	public void evict(Object object) throws HibernateException {
 		fireEvict( new EvictEvent( object, this ) );
 	}
 
 	private void fireEvict(EvictEvent evictEvent) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		EvictEventListener[] evictEventListener = listeners.getEvictEventListeners();
 		for ( int i = 0; i < evictEventListener.length; i++ ) {
 			evictEventListener[i].onEvict( evictEvent );
 		}
 	}
 
 	/**
 	 * detect in-memory changes, determine if the changes are to tables
 	 * named in the query and, if so, complete execution the flush
 	 */
 	protected boolean autoFlushIfRequired(Set querySpaces) throws HibernateException {
 		errorIfClosed();
 		if ( ! isTransactionInProgress() ) {
 			// do not auto-flush while outside a transaction
 			return false;
 		}
 		AutoFlushEvent event = new AutoFlushEvent(querySpaces, this);
 		AutoFlushEventListener[] autoFlushEventListener = listeners.getAutoFlushEventListeners();
 		for ( int i = 0; i < autoFlushEventListener.length; i++ ) {
 			autoFlushEventListener[i].onAutoFlush(event);
 		}
 		return event.isFlushRequired();
 	}
 
 	public boolean isDirty() throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
         LOG.debugf("Checking session dirtiness");
 		if ( actionQueue.areInsertionsOrDeletionsQueued() ) {
             LOG.debugf("Session dirty (scheduled updates and insertions)");
 			return true;
 		}
         DirtyCheckEvent event = new DirtyCheckEvent(this);
         DirtyCheckEventListener[] dirtyCheckEventListener = listeners.getDirtyCheckEventListeners();
         for (int i = 0; i < dirtyCheckEventListener.length; i++) {
             dirtyCheckEventListener[i].onDirtyCheck(event);
 		}
         return event.isDirty();
 	}
 
 	public void flush() throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		if ( persistenceContext.getCascadeLevel() > 0 ) {
 			throw new HibernateException("Flush during cascade is dangerous");
 		}
 		FlushEventListener[] flushEventListener = listeners.getFlushEventListeners();
 		for ( int i = 0; i < flushEventListener.length; i++ ) {
 			flushEventListener[i].onFlush( new FlushEvent(this) );
 		}
 	}
 
 	public void forceFlush(EntityEntry entityEntry) throws HibernateException {
 		errorIfClosed();
         if (LOG.isDebugEnabled()) LOG.debugf("Flushing to force deletion of re-saved object: %s",
                                              MessageHelper.infoString(entityEntry.getPersister(), entityEntry.getId(), getFactory()));
 
 		if ( persistenceContext.getCascadeLevel() > 0 ) {
 			throw new ObjectDeletedException(
 				"deleted object would be re-saved by cascade (remove deleted object from associations)",
 				entityEntry.getId(),
 				entityEntry.getPersister().getEntityName()
 			);
 		}
 
 		flush();
 	}
 
-
-	/**
-	 * Retrieve a list of persistent objects using a hibernate query
-	 */
-	public List find(String query) throws HibernateException {
-		return list( query, new QueryParameters() );
-	}
-
-	public List find(String query, Object value, Type type) throws HibernateException {
-		return list( query, new QueryParameters(type, value) );
-	}
-
-	public List find(String query, Object[] values, Type[] types) throws HibernateException {
-		return list( query, new QueryParameters(types, values) );
-	}
-
 	public List list(String query, QueryParameters queryParameters) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		queryParameters.validateParameters();
 		HQLQueryPlan plan = getHQLQueryPlan( query, false );
 		autoFlushIfRequired( plan.getQuerySpaces() );
 
 		List results = CollectionHelper.EMPTY_LIST;
 		boolean success = false;
 
 		dontFlushFromFind++;   //stops flush being called multiple times if this method is recursively called
 		try {
 			results = plan.performList( queryParameters, this );
 			success = true;
 		}
 		finally {
 			dontFlushFromFind--;
 			afterOperation(success);
 		}
 		return results;
 	}
 
 	public int executeUpdate(String query, QueryParameters queryParameters) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		queryParameters.validateParameters();
 		HQLQueryPlan plan = getHQLQueryPlan( query, false );
 		autoFlushIfRequired( plan.getQuerySpaces() );
 
 		boolean success = false;
 		int result = 0;
 		try {
 			result = plan.performExecuteUpdate( queryParameters, this );
 			success = true;
 		}
 		finally {
 			afterOperation(success);
 		}
 		return result;
 	}
 
     public int executeNativeUpdate(NativeSQLQuerySpecification nativeQuerySpecification,
             QueryParameters queryParameters) throws HibernateException {
         errorIfClosed();
         checkTransactionSynchStatus();
         queryParameters.validateParameters();
         NativeSQLQueryPlan plan = getNativeSQLQueryPlan( nativeQuerySpecification );
 
 
         autoFlushIfRequired( plan.getCustomQuery().getQuerySpaces() );
 
         boolean success = false;
         int result = 0;
         try {
             result = plan.performExecuteUpdate(queryParameters, this);
             success = true;
         } finally {
             afterOperation(success);
         }
         return result;
     }
 
-	public Iterator iterate(String query) throws HibernateException {
-		return iterate( query, new QueryParameters() );
-	}
-
-	public Iterator iterate(String query, Object value, Type type) throws HibernateException {
-		return iterate( query, new QueryParameters(type, value) );
-	}
-
-	public Iterator iterate(String query, Object[] values, Type[] types) throws HibernateException {
-		return iterate( query, new QueryParameters(types, values) );
-	}
-
 	public Iterator iterate(String query, QueryParameters queryParameters) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		queryParameters.validateParameters();
 		HQLQueryPlan plan = getHQLQueryPlan( query, true );
 		autoFlushIfRequired( plan.getQuerySpaces() );
 
 		dontFlushFromFind++; //stops flush being called multiple times if this method is recursively called
 		try {
 			return plan.performIterate( queryParameters, this );
 		}
 		finally {
 			dontFlushFromFind--;
 		}
 	}
 
 	public ScrollableResults scroll(String query, QueryParameters queryParameters) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		HQLQueryPlan plan = getHQLQueryPlan( query, false );
 		autoFlushIfRequired( plan.getQuerySpaces() );
 		dontFlushFromFind++;
 		try {
 			return plan.performScroll( queryParameters, this );
 		}
 		finally {
 			dontFlushFromFind--;
 		}
 	}
 
-	public int delete(String query) throws HibernateException {
-		return delete( query, ArrayHelper.EMPTY_OBJECT_ARRAY, ArrayHelper.EMPTY_TYPE_ARRAY );
-	}
-
-	public int delete(String query, Object value, Type type) throws HibernateException {
-		return delete( query, new Object[]{value}, new Type[]{type} );
-	}
-
-	public int delete(String query, Object[] values, Type[] types) throws HibernateException {
-		errorIfClosed();
-		checkTransactionSynchStatus();
-		if ( query == null ) {
-			throw new IllegalArgumentException("attempt to doAfterTransactionCompletion delete-by-query with null query");
-		}
-
-        if (LOG.isTraceEnabled()) {
-            LOG.trace("delete: " + query);
-            if (values.length != 0) LOG.trace("Parameters: " + StringHelper.toString(values));
-		}
-
-		List list = find( query, values, types );
-		int deletionCount = list.size();
-		for ( int i = 0; i < deletionCount; i++ ) {
-			delete( list.get( i ) );
-		}
-
-		return deletionCount;
-	}
-
 	public Query createFilter(Object collection, String queryString) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		CollectionFilterImpl filter = new CollectionFilterImpl(
 				queryString,
 		        collection,
 		        this,
 		        getFilterQueryPlan( collection, queryString, null, false ).getParameterMetadata()
 		);
 		filter.setComment( queryString );
 		return filter;
 	}
 
 	public Query getNamedQuery(String queryName) throws MappingException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return super.getNamedQuery( queryName );
 	}
 
 	public Object instantiate(String entityName, Serializable id) throws HibernateException {
 		return instantiate( factory.getEntityPersister( entityName ), id );
 	}
 
 	/**
 	 * give the interceptor an opportunity to override the default instantiation
 	 */
 	public Object instantiate(EntityPersister persister, Serializable id) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		Object result = interceptor.instantiate( persister.getEntityName(), entityMode, id );
 		if ( result == null ) {
 			result = persister.instantiate( id, this );
 		}
 		return result;
 	}
 
 	public EntityMode getEntityMode() {
 		checkTransactionSynchStatus();
 		return entityMode;
 	}
 
 	public void setFlushMode(FlushMode flushMode) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
         LOG.trace("Setting flush mode to: " + flushMode);
 		this.flushMode = flushMode;
 	}
 
 	public FlushMode getFlushMode() {
 		checkTransactionSynchStatus();
 		return flushMode;
 	}
 
 	public CacheMode getCacheMode() {
 		checkTransactionSynchStatus();
 		return cacheMode;
 	}
 
 	public void setCacheMode(CacheMode cacheMode) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
         LOG.trace("Setting cache mode to: " + cacheMode);
 		this.cacheMode= cacheMode;
 	}
 
 	public Transaction getTransaction() throws HibernateException {
 		errorIfClosed();
 		return transactionCoordinator.getTransaction();
 	}
 
 	public Transaction beginTransaction() throws HibernateException {
 		errorIfClosed();
         // todo : should seriously consider not allowing a txn to begin from a child session
         // can always route the request to the root session...
         if (rootSession != null) LOG.transactionStartedOnNonRootSession();
 
 		Transaction result = getTransaction();
 		result.begin();
 		return result;
 	}
 
 	public EntityPersister getEntityPersister(final String entityName, final Object object) {
 		errorIfClosed();
 		if (entityName==null) {
 			return factory.getEntityPersister( guessEntityName( object ) );
 		}
 		else {
 			// try block is a hack around fact that currently tuplizers are not
 			// given the opportunity to resolve a subclass entity name.  this
 			// allows the (we assume custom) interceptor the ability to
 			// influence this decision if we were not able to based on the
 			// given entityName
 			try {
 				return factory.getEntityPersister( entityName )
 						.getSubclassEntityPersister( object, getFactory(), entityMode );
 			}
 			catch( HibernateException e ) {
 				try {
 					return getEntityPersister( null, object );
 				}
 				catch( HibernateException e2 ) {
 					throw e;
 				}
 			}
 		}
 	}
 
 	// not for internal use:
 	public Serializable getIdentifier(Object object) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		if ( object instanceof HibernateProxy ) {
 			LazyInitializer li = ( (HibernateProxy) object ).getHibernateLazyInitializer();
 			if ( li.getSession() != this ) {
 				throw new TransientObjectException( "The proxy was not associated with this session" );
 			}
 			return li.getIdentifier();
 		}
 		else {
 			EntityEntry entry = persistenceContext.getEntry(object);
 			if ( entry == null ) {
 				throw new TransientObjectException( "The instance was not associated with this session" );
 			}
 			return entry.getId();
 		}
 	}
 
 	/**
 	 * Get the id value for an object that is actually associated with the session. This
 	 * is a bit stricter than getEntityIdentifierIfNotUnsaved().
 	 */
 	public Serializable getContextEntityIdentifier(Object object) {
 		errorIfClosed();
 		if ( object instanceof HibernateProxy ) {
 			return getProxyIdentifier( object );
 		}
 		else {
 			EntityEntry entry = persistenceContext.getEntry(object);
 			return entry != null ? entry.getId() : null;
 		}
 	}
 
 	private Serializable getProxyIdentifier(Object proxy) {
 		return ( (HibernateProxy) proxy ).getHibernateLazyInitializer().getIdentifier();
 	}
 
-	public Collection filter(Object collection, String filter) throws HibernateException {
-		return listFilter( collection, filter, new QueryParameters( new Type[1], new Object[1] ) );
-	}
-
-	public Collection filter(Object collection, String filter, Object value, Type type) throws HibernateException {
-		return listFilter( collection, filter, new QueryParameters( new Type[]{null, type}, new Object[]{null, value} ) );
-	}
-
-	public Collection filter(Object collection, String filter, Object[] values, Type[] types)
-	throws HibernateException {
-		Object[] vals = new Object[values.length + 1];
-		Type[] typs = new Type[types.length + 1];
-		System.arraycopy( values, 0, vals, 1, values.length );
-		System.arraycopy( types, 0, typs, 1, types.length );
-		return listFilter( collection, filter, new QueryParameters( typs, vals ) );
-	}
-
 	private FilterQueryPlan getFilterQueryPlan(
 			Object collection,
 			String filter,
 			QueryParameters parameters,
 			boolean shallow) throws HibernateException {
 		if ( collection == null ) {
 			throw new NullPointerException( "null collection passed to filter" );
 		}
 
 		CollectionEntry entry = persistenceContext.getCollectionEntryOrNull( collection );
 		final CollectionPersister roleBeforeFlush = (entry == null) ? null : entry.getLoadedPersister();
 
 		FilterQueryPlan plan = null;
 		if ( roleBeforeFlush == null ) {
 			// if it was previously unreferenced, we need to flush in order to
 			// get its state into the database in order to execute query
 			flush();
 			entry = persistenceContext.getCollectionEntryOrNull( collection );
 			CollectionPersister roleAfterFlush = (entry == null) ? null : entry.getLoadedPersister();
 			if ( roleAfterFlush == null ) {
 				throw new QueryException( "The collection was unreferenced" );
 			}
 			plan = factory.getQueryPlanCache().getFilterQueryPlan( filter, roleAfterFlush.getRole(), shallow, getEnabledFilters() );
 		}
 		else {
 			// otherwise, we only need to flush if there are in-memory changes
 			// to the queried tables
 			plan = factory.getQueryPlanCache().getFilterQueryPlan( filter, roleBeforeFlush.getRole(), shallow, getEnabledFilters() );
 			if ( autoFlushIfRequired( plan.getQuerySpaces() ) ) {
 				// might need to run a different filter entirely after the flush
 				// because the collection role may have changed
 				entry = persistenceContext.getCollectionEntryOrNull( collection );
 				CollectionPersister roleAfterFlush = (entry == null) ? null : entry.getLoadedPersister();
 				if ( roleBeforeFlush != roleAfterFlush ) {
 					if ( roleAfterFlush == null ) {
 						throw new QueryException( "The collection was dereferenced" );
 					}
 					plan = factory.getQueryPlanCache().getFilterQueryPlan( filter, roleAfterFlush.getRole(), shallow, getEnabledFilters() );
 				}
 			}
 		}
 
 		if ( parameters != null ) {
 			parameters.getPositionalParameterValues()[0] = entry.getLoadedKey();
 			parameters.getPositionalParameterTypes()[0] = entry.getLoadedPersister().getKeyType();
 		}
 
 		return plan;
 	}
 
 	public List listFilter(Object collection, String filter, QueryParameters queryParameters)
 	throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		FilterQueryPlan plan = getFilterQueryPlan( collection, filter, queryParameters, false );
 		List results = CollectionHelper.EMPTY_LIST;
 
 		boolean success = false;
 		dontFlushFromFind++;   //stops flush being called multiple times if this method is recursively called
 		try {
 			results = plan.performList( queryParameters, this );
 			success = true;
 		}
 		finally {
 			dontFlushFromFind--;
 			afterOperation(success);
 		}
 		return results;
 	}
 
 	public Iterator iterateFilter(Object collection, String filter, QueryParameters queryParameters)
 	throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		FilterQueryPlan plan = getFilterQueryPlan( collection, filter, queryParameters, true );
 		return plan.performIterate( queryParameters, this );
 	}
 
 	public Criteria createCriteria(Class persistentClass, String alias) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return new CriteriaImpl( persistentClass.getName(), alias, this );
 	}
 
 	public Criteria createCriteria(String entityName, String alias) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return new CriteriaImpl(entityName, alias, this);
 	}
 
 	public Criteria createCriteria(Class persistentClass) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return new CriteriaImpl( persistentClass.getName(), this );
 	}
 
 	public Criteria createCriteria(String entityName) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return new CriteriaImpl(entityName, this);
 	}
 
 	public ScrollableResults scroll(CriteriaImpl criteria, ScrollMode scrollMode) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		String entityName = criteria.getEntityOrClassName();
 		CriteriaLoader loader = new CriteriaLoader(
 				getOuterJoinLoadable(entityName),
 				factory,
 				criteria,
 				entityName,
 				getLoadQueryInfluencers()
 		);
 		autoFlushIfRequired( loader.getQuerySpaces() );
 		dontFlushFromFind++;
 		try {
 			return loader.scroll(this, scrollMode);
 		}
 		finally {
 			dontFlushFromFind--;
 		}
 	}
 
 	public List list(CriteriaImpl criteria) throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		String[] implementors = factory.getImplementors( criteria.getEntityOrClassName() );
 		int size = implementors.length;
 
 		CriteriaLoader[] loaders = new CriteriaLoader[size];
 		Set spaces = new HashSet();
 		for( int i=0; i <size; i++ ) {
 
 			loaders[i] = new CriteriaLoader(
 					getOuterJoinLoadable( implementors[i] ),
 					factory,
 					criteria,
 					implementors[i],
 					getLoadQueryInfluencers()
 				);
 
 			spaces.addAll( loaders[i].getQuerySpaces() );
 
 		}
 
 		autoFlushIfRequired(spaces);
 
 		List results = Collections.EMPTY_LIST;
 		dontFlushFromFind++;
 		boolean success = false;
 		try {
 			for( int i=0; i<size; i++ ) {
 				final List currentResults = loaders[i].list(this);
 				currentResults.addAll(results);
 				results = currentResults;
 			}
 			success = true;
 		}
 		finally {
 			dontFlushFromFind--;
 			afterOperation(success);
 		}
 
 		return results;
 	}
 
 	private OuterJoinLoadable getOuterJoinLoadable(String entityName) throws MappingException {
 		EntityPersister persister = factory.getEntityPersister(entityName);
 		if ( !(persister instanceof OuterJoinLoadable) ) {
 			throw new MappingException( "class persister is not OuterJoinLoadable: " + entityName );
 		}
 		return ( OuterJoinLoadable ) persister;
 	}
 
 	public boolean contains(Object object) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		if ( object instanceof HibernateProxy ) {
 			//do not use proxiesByKey, since not all
 			//proxies that point to this session's
 			//instances are in that collection!
 			LazyInitializer li = ( (HibernateProxy) object ).getHibernateLazyInitializer();
 			if ( li.isUninitialized() ) {
 				//if it is an uninitialized proxy, pointing
 				//with this session, then when it is accessed,
 				//the underlying instance will be "contained"
 				return li.getSession()==this;
 			}
 			else {
 				//if it is initialized, see if the underlying
 				//instance is contained, since we need to
 				//account for the fact that it might have been
 				//evicted
 				object = li.getImplementation();
 			}
 		}
 		// A session is considered to contain an entity only if the entity has
 		// an entry in the session's persistence context and the entry reports
 		// that the entity has not been removed
 		EntityEntry entry = persistenceContext.getEntry( object );
 		return entry != null && entry.getStatus() != Status.DELETED && entry.getStatus() != Status.GONE;
 	}
 
 	public Query createQuery(String queryString) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return super.createQuery( queryString );
 	}
 
 	public SQLQuery createSQLQuery(String sql) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return super.createSQLQuery( sql );
 	}
 
-	public Query createSQLQuery(String sql, String returnAlias, Class returnClass) {
-		errorIfClosed();
-		checkTransactionSynchStatus();
-		return new SQLQueryImpl(
-				sql,
-		        new String[] { returnAlias },
-		        new Class[] { returnClass },
-		        this,
-		        factory.getQueryPlanCache().getSQLParameterMetadata( sql )
-		);
-	}
-
-	public Query createSQLQuery(String sql, String returnAliases[], Class returnClasses[]) {
-		errorIfClosed();
-		checkTransactionSynchStatus();
-		return new SQLQueryImpl(
-				sql,
-		        returnAliases,
-		        returnClasses,
-		        this,
-		        factory.getQueryPlanCache().getSQLParameterMetadata( sql )
-		);
-	}
-
 	public ScrollableResults scrollCustomQuery(CustomQuery customQuery, QueryParameters queryParameters)
 	throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 
         LOG.trace("Scroll SQL query: " + customQuery.getSQL());
 
 		CustomLoader loader = new CustomLoader( customQuery, getFactory() );
 
 		autoFlushIfRequired( loader.getQuerySpaces() );
 
 		dontFlushFromFind++; //stops flush being called multiple times if this method is recursively called
 		try {
 			return loader.scroll(queryParameters, this);
 		}
 		finally {
 			dontFlushFromFind--;
 		}
 	}
 
 	// basically just an adapted copy of find(CriteriaImpl)
 	public List listCustomQuery(CustomQuery customQuery, QueryParameters queryParameters)
 	throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 
         LOG.trace("SQL query: " + customQuery.getSQL());
 
 		CustomLoader loader = new CustomLoader( customQuery, getFactory() );
 
 		autoFlushIfRequired( loader.getQuerySpaces() );
 
 		dontFlushFromFind++;
 		boolean success = false;
 		try {
 			List results = loader.list(this, queryParameters);
 			success = true;
 			return results;
 		}
 		finally {
 			dontFlushFromFind--;
 			afterOperation(success);
 		}
 	}
 
 	public SessionFactoryImplementor getSessionFactory() {
 		checkTransactionSynchStatus();
 		return factory;
 	}
 
 	public void initializeCollection(PersistentCollection collection, boolean writing)
 	throws HibernateException {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		InitializeCollectionEventListener[] listener = listeners.getInitializeCollectionEventListeners();
 		for ( int i = 0; i < listener.length; i++ ) {
 			listener[i].onInitializeCollection( new InitializeCollectionEvent(collection, this) );
 		}
 	}
 
 	public String bestGuessEntityName(Object object) {
 		if (object instanceof HibernateProxy) {
 			LazyInitializer initializer = ( ( HibernateProxy ) object ).getHibernateLazyInitializer();
 			// it is possible for this method to be called during flush processing,
 			// so make certain that we do not accidentally initialize an uninitialized proxy
 			if ( initializer.isUninitialized() ) {
 				return initializer.getEntityName();
 			}
 			object = initializer.getImplementation();
 		}
 		EntityEntry entry = persistenceContext.getEntry(object);
 		if (entry==null) {
 			return guessEntityName(object);
 		}
 		else {
 			return entry.getPersister().getEntityName();
 		}
 	}
 
 	public String getEntityName(Object object) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		if (object instanceof HibernateProxy) {
 			if ( !persistenceContext.containsProxy( object ) ) {
 				throw new TransientObjectException("proxy was not associated with the session");
 			}
 			object = ( (HibernateProxy) object ).getHibernateLazyInitializer().getImplementation();
 		}
 
 		EntityEntry entry = persistenceContext.getEntry(object);
 		if ( entry == null ) {
 			throwTransientObjectException( object );
 		}
 		return entry.getPersister().getEntityName();
 	}
 
 	private void throwTransientObjectException(Object object) throws HibernateException {
 		throw new TransientObjectException(
 				"object references an unsaved transient instance - save the transient instance before flushing: " +
 				guessEntityName(object)
 			);
 	}
 
 	public String guessEntityName(Object object) throws HibernateException {
 		errorIfClosed();
 		return entityNameResolver.resolveEntityName( object );
 	}
 
 	public void cancelQuery() throws HibernateException {
 		errorIfClosed();
 		getTransactionCoordinator().getJdbcCoordinator().cancelLastQuery();
 	}
 
 	public Interceptor getInterceptor() {
 		checkTransactionSynchStatus();
 		return interceptor;
 	}
 
 	public int getDontFlushFromFind() {
 		return dontFlushFromFind;
 	}
 
 	public String toString() {
 		StringBuffer buf = new StringBuffer(500)
 			.append( "SessionImpl(" );
 		if ( !isClosed() ) {
 			buf.append(persistenceContext)
 				.append(";")
 				.append(actionQueue);
 		}
 		else {
 			buf.append("<closed>");
 		}
 		return buf.append(')').toString();
 	}
 
 	public EventListeners getListeners() {
 		return listeners;
 	}
 
 	public ActionQueue getActionQueue() {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return actionQueue;
 	}
 
 	public PersistenceContext getPersistenceContext() {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return persistenceContext;
 	}
 
 	public SessionStatistics getStatistics() {
 		checkTransactionSynchStatus();
 		return new SessionStatisticsImpl(this);
 	}
 
 	public boolean isEventSource() {
 		checkTransactionSynchStatus();
 		return true;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public boolean isDefaultReadOnly() {
 		return persistenceContext.isDefaultReadOnly();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void setDefaultReadOnly(boolean defaultReadOnly) {
 		persistenceContext.setDefaultReadOnly( defaultReadOnly );
 	}
 
 	public boolean isReadOnly(Object entityOrProxy) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return persistenceContext.isReadOnly( entityOrProxy );
 	}
 
 	public void setReadOnly(Object entity, boolean readOnly) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		persistenceContext.setReadOnly(entity, readOnly);
 	}
 
 	public void doWork(final Work work) throws HibernateException {
 		WorkExecutorVisitable<Void> realWork = new WorkExecutorVisitable<Void>() {
 			@Override
 			public Void accept(WorkExecutor<Void> workExecutor, Connection connection) throws SQLException {
 				workExecutor.executeWork( work, connection );
 				return null;
 			}
 		};
 		doWork( realWork );
 	}
 
 	public <T> T doReturningWork(final ReturningWork<T> work) throws HibernateException {
 		WorkExecutorVisitable<T> realWork = new WorkExecutorVisitable<T>() {
 			@Override
 			public T accept(WorkExecutor<T> workExecutor, Connection connection) throws SQLException {
 				return workExecutor.executeReturningWork( work, connection );
 			}
 		};
 		return doWork( realWork );
 	}
 
 	private <T> T doWork(WorkExecutorVisitable<T> work) throws HibernateException {
 		return transactionCoordinator.getJdbcCoordinator().coordinateWork( work );
 	}
 
 	public void afterScrollOperation() {
 		// nothing to do in a stateful session
 	}
 
 	@Override
 	public TransactionCoordinator getTransactionCoordinator() {
 		errorIfClosed();
 		return transactionCoordinator;
 	}
 
 	public LoadQueryInfluencers getLoadQueryInfluencers() {
 		return loadQueryInfluencers;
 	}
 
 	// filter support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Filter getEnabledFilter(String filterName) {
 		checkTransactionSynchStatus();
 		return loadQueryInfluencers.getEnabledFilter( filterName );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Filter enableFilter(String filterName) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return loadQueryInfluencers.enableFilter( filterName );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void disableFilter(String filterName) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		loadQueryInfluencers.disableFilter( filterName );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Object getFilterParameterValue(String filterParameterName) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return loadQueryInfluencers.getFilterParameterValue( filterParameterName );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Type getFilterParameterType(String filterParameterName) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return loadQueryInfluencers.getFilterParameterType( filterParameterName );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Map getEnabledFilters() {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		return loadQueryInfluencers.getEnabledFilters();
 	}
 
 
 	// internal fetch profile support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public String getFetchProfile() {
 		checkTransactionSynchStatus();
 		return loadQueryInfluencers.getInternalFetchProfile();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void setFetchProfile(String fetchProfile) {
 		errorIfClosed();
 		checkTransactionSynchStatus();
 		loadQueryInfluencers.setInternalFetchProfile( fetchProfile );
 	}
 
 
 	// fetch profile support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public boolean isFetchProfileEnabled(String name) throws UnknownProfileException {
 		return loadQueryInfluencers.isFetchProfileEnabled( name );
 	}
 
 	public void enableFetchProfile(String name) throws UnknownProfileException {
 		loadQueryInfluencers.enableFetchProfile( name );
 	}
 
 	public void disableFetchProfile(String name) throws UnknownProfileException {
 		loadQueryInfluencers.disableFetchProfile( name );
 	}
 
 
 	private void checkTransactionSynchStatus() {
 		if ( !isClosed() ) {
 			transactionCoordinator.pulse();
 		}
 	}
 
 	/**
 	 * Used by JDK serialization...
 	 *
 	 * @param ois The input stream from which we are being read...
 	 * @throws IOException Indicates a general IO stream exception
 	 * @throws ClassNotFoundException Indicates a class resolution issue
 	 */
 	private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
         LOG.trace("Deserializing session");
 
 		ois.defaultReadObject();
 
 		entityNameResolver = new CoordinatingEntityNameResolver();
 
 		boolean isRootSession = ois.readBoolean();
 		connectionReleaseMode = ConnectionReleaseMode.parse( ( String ) ois.readObject() );
 		entityMode = EntityMode.parse( ( String ) ois.readObject() );
 		autoClear = ois.readBoolean();
 		autoJoinTransactions = ois.readBoolean();
 		flushMode = FlushMode.parse( ( String ) ois.readObject() );
 		cacheMode = CacheMode.parse( ( String ) ois.readObject() );
 		flushBeforeCompletionEnabled = ois.readBoolean();
 		autoCloseSessionEnabled = ois.readBoolean();
 		interceptor = ( Interceptor ) ois.readObject();
 
 		factory = SessionFactoryImpl.deserialize( ois );
 		listeners = factory.getEventListeners();
 
 		if ( isRootSession ) {
 			transactionCoordinator = TransactionCoordinatorImpl.deserialize( ois, this );
 		}
 
 		persistenceContext = StatefulPersistenceContext.deserialize( ois, this );
 		actionQueue = ActionQueue.deserialize( ois, this );
 
 		loadQueryInfluencers = ( LoadQueryInfluencers ) ois.readObject();
 
 		childSessionsByEntityMode = ( Map ) ois.readObject();
 
 		// LoadQueryInfluencers.getEnabledFilters() tries to validate each enabled
 		// filter, which will fail when called before FilterImpl.afterDeserialize( factory );
 		// Instead lookup the filter by name and then call FilterImpl.afterDeserialize( factory ).
 		Iterator iter = loadQueryInfluencers.getEnabledFilterNames().iterator();
 		while ( iter.hasNext() ) {
 			String filterName = ( String ) iter.next();
 			 ( ( FilterImpl ) loadQueryInfluencers.getEnabledFilter( filterName )  )
 					.afterDeserialize( factory );
 		}
 
 		if ( isRootSession && childSessionsByEntityMode != null ) {
 			iter = childSessionsByEntityMode.values().iterator();
 			while ( iter.hasNext() ) {
 				final SessionImpl child = ( ( SessionImpl ) iter.next() );
 				child.rootSession = this;
 				child.transactionCoordinator = this.transactionCoordinator;
 			}
 		}
 	}
 
 	/**
 	 * Used by JDK serialization...
 	 *
 	 * @param oos The output stream to which we are being written...
 	 * @throws IOException Indicates a general IO stream exception
 	 */
 	private void writeObject(ObjectOutputStream oos) throws IOException {
 		if ( ! transactionCoordinator.getJdbcCoordinator().getLogicalConnection().isReadyForSerialization() ) {
 			throw new IllegalStateException( "Cannot serialize a session while connected" );
 		}
 
         LOG.trace("Serializing session");
 
 		oos.defaultWriteObject();
 
 		oos.writeBoolean( rootSession == null );
 		oos.writeObject( connectionReleaseMode.toString() );
 		oos.writeObject( entityMode.toString() );
 		oos.writeBoolean( autoClear );
 		oos.writeBoolean( autoJoinTransactions );
 		oos.writeObject( flushMode.toString() );
 		oos.writeObject( cacheMode.toString() );
 		oos.writeBoolean( flushBeforeCompletionEnabled );
 		oos.writeBoolean( autoCloseSessionEnabled );
 		// we need to writeObject() on this since interceptor is user defined
 		oos.writeObject( interceptor );
 
 		factory.serialize( oos );
 
 		if ( rootSession == null ) {
 			transactionCoordinator.serialize( oos );
 		}
 
 		persistenceContext.serialize( oos );
 		actionQueue.serialize( oos );
 
 		// todo : look at optimizing these...
 		oos.writeObject( loadQueryInfluencers );
 		oos.writeObject( childSessionsByEntityMode );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Object execute(LobCreationContext.Callback callback) {
 		Connection connection = transactionCoordinator.getJdbcCoordinator().getLogicalConnection().getConnection();
 		try {
 			return callback.executeOnConnection( connection );
 		}
 		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					"Error creating contextual LOB : " + e.getMessage()
 			);
 		}
 		finally {
 			transactionCoordinator.getJdbcCoordinator().getLogicalConnection().afterStatementExecution();
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public TypeHelper getTypeHelper() {
 		return getSessionFactory().getTypeHelper();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public LobHelper getLobHelper() {
 		if ( lobHelper == null ) {
 			lobHelper = new LobHelperImpl( this );
 		}
 		return lobHelper;
 	}
 
 	private transient LobHelperImpl lobHelper;
 
 	private static class LobHelperImpl implements LobHelper {
 		private final SessionImpl session;
 
 		private LobHelperImpl(SessionImpl session) {
 			this.session = session;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Blob createBlob(byte[] bytes) {
 			return lobCreator().createBlob( bytes );
 		}
 
 		private LobCreator lobCreator() {
 			return session.getFactory().getJdbcServices().getLobCreator( session );
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Blob createBlob(InputStream stream, long length) {
 			return lobCreator().createBlob( stream, length );
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Clob createClob(String string) {
 			return lobCreator().createClob( string );
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Clob createClob(Reader reader, long length) {
 			return lobCreator().createClob( reader, length );
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Clob createNClob(String string) {
 			return lobCreator().createNClob( string );
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Clob createNClob(Reader reader, long length) {
 			return lobCreator().createNClob( reader, length );
 		}
 	}
 
 	private class CoordinatingEntityNameResolver implements EntityNameResolver {
 		public String resolveEntityName(Object entity) {
 			String entityName = interceptor.getEntityName( entity );
 			if ( entityName != null ) {
 				return entityName;
 			}
 
 			Iterator itr = factory.iterateEntityNameResolvers( entityMode );
 			while ( itr.hasNext() ) {
 				final EntityNameResolver resolver = ( EntityNameResolver ) itr.next();
 				entityName = resolver.resolveEntityName( entity );
 				if ( entityName != null ) {
 					break;
 				}
 			}
 			if ( entityName != null ) {
 				return entityName;
 			}
 
 			// the old-time stand-by...
 			return entity.getClass().getName();
 		}
 	}
 
 	private class LockRequestImpl implements LockRequest {
 		private final LockOptions lockOptions;
 		private LockRequestImpl(LockOptions lo) {
 			lockOptions = new LockOptions();
 			LockOptions.copy(lo, lockOptions);
 		}
 
 		public LockMode getLockMode() {
 			return lockOptions.getLockMode();
 		}
 
 		public LockRequest setLockMode(LockMode lockMode) {
 			lockOptions.setLockMode(lockMode);
 			return this;
 		}
 
 		public int getTimeOut() {
 			return lockOptions.getTimeOut();
 		}
 
 		public LockRequest setTimeOut(int timeout) {
 			lockOptions.setTimeOut(timeout);
 			return this;
 		}
 
 		public boolean getScope() {
 			return lockOptions.getScope();
 		}
 
 		public LockRequest setScope(boolean scope) {
 			lockOptions.setScope(scope);
 			return this;
 		}
 
 		public void lock(String entityName, Object object) throws HibernateException {
 			fireLock( entityName, object, lockOptions );
 		}
 		public void lock(Object object) throws HibernateException {
 			fireLock( object, lockOptions );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/jmx/SessionFactoryStub.java b/hibernate-core/src/main/java/org/hibernate/jmx/SessionFactoryStub.java
index 1c80031c4d..f9ac129b82 100644
--- a/hibernate-core/src/main/java/org/hibernate/jmx/SessionFactoryStub.java
+++ b/hibernate-core/src/main/java/org/hibernate/jmx/SessionFactoryStub.java
@@ -1,226 +1,227 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jmx;
 import java.io.InvalidObjectException;
 import java.io.ObjectStreamException;
 import java.io.Serializable;
 import java.sql.Connection;
 import java.util.Map;
 import java.util.Set;
 import javax.naming.NamingException;
 import javax.naming.Reference;
 import javax.naming.StringRefAddr;
 import org.hibernate.AssertionFailure;
 import org.hibernate.Cache;
 import org.hibernate.HibernateException;
 import org.hibernate.HibernateLogger;
 import org.hibernate.Interceptor;
+import org.hibernate.Session;
 import org.hibernate.SessionFactory;
 import org.hibernate.StatelessSession;
 import org.hibernate.TypeHelper;
 import org.hibernate.engine.FilterDefinition;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.UUIDGenerator;
 import org.hibernate.impl.SessionFactoryObjectFactory;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.metadata.CollectionMetadata;
 import org.hibernate.stat.Statistics;
 import org.jboss.logging.Logger;
 
 /**
  * A flyweight for <tt>SessionFactory</tt>. If the MBean itself does not
  * have classpath to the persistent classes, then a stub will be registered
  * with JNDI and the actual <tt>SessionFactoryImpl</tt> built upon first
  * access.
  * @author Gavin King
  */
 public class SessionFactoryStub implements SessionFactory {
 	private static final IdentifierGenerator UUID_GENERATOR = UUIDGenerator.buildSessionFactoryUniqueIdentifierGenerator();
 
     private static final HibernateLogger LOG = Logger.getMessageLogger(HibernateLogger.class, SessionFactoryStub.class.getName());
 
 	private transient SessionFactory impl;
 	private transient HibernateService service;
 	private String uuid;
 	private String name;
 
 	SessionFactoryStub(HibernateService service) {
 		this.service = service;
 		this.name = service.getJndiName();
 		try {
 			uuid = (String) UUID_GENERATOR.generate(null, null);
 		}
 		catch (Exception e) {
 			throw new AssertionFailure("Could not generate UUID");
 		}
 
 		SessionFactoryObjectFactory.addInstance( uuid, name, this, service.getProperties() );
 	}
 
-	public org.hibernate.classic.Session openSession(Connection connection, Interceptor interceptor) {
+	public Session openSession(Connection connection, Interceptor interceptor) {
 		return getImpl().openSession(connection, interceptor);
 	}
 
-	public org.hibernate.classic.Session openSession(Interceptor interceptor) throws HibernateException {
+	public Session openSession(Interceptor interceptor) throws HibernateException {
 		return getImpl().openSession(interceptor);
 	}
 
-	public org.hibernate.classic.Session openSession() throws HibernateException {
+	public Session openSession() throws HibernateException {
 		return getImpl().openSession();
 	}
 
-	public org.hibernate.classic.Session openSession(Connection conn) {
+	public Session openSession(Connection conn) {
 		return getImpl().openSession(conn);
 	}
 
-	public org.hibernate.classic.Session getCurrentSession() {
+	public Session getCurrentSession() {
 		return getImpl().getCurrentSession();
 	}
 
 	private synchronized SessionFactory getImpl() {
 		if (impl==null) impl = service.buildSessionFactory();
 		return impl;
 	}
 
 	//readResolveObject
 	private Object readResolve() throws ObjectStreamException {
 		// look for the instance by uuid
 		Object result = SessionFactoryObjectFactory.getInstance(uuid);
 		if (result==null) {
             // in case we were deserialized in a different JVM, look for an instance with the same name
 			// (alternatively we could do an actual JNDI lookup here....)
 			result = SessionFactoryObjectFactory.getNamedInstance(name);
             if (result == null) throw new InvalidObjectException("Could not find a stub SessionFactory named: " + name);
             LOG.debugf("Resolved stub SessionFactory by name");
         } else LOG.debugf("Resolved stub SessionFactory by uid");
 		return result;
 	}
 
 	/**
 	 * @see javax.naming.Referenceable#getReference()
 	 */
 	public Reference getReference() throws NamingException {
 		return new Reference(
 			SessionFactoryStub.class.getName(),
 			new StringRefAddr("uuid", uuid),
 			SessionFactoryObjectFactory.class.getName(),
 			null
 		);
 	}
 
 	public ClassMetadata getClassMetadata(Class persistentClass) throws HibernateException {
 		return getImpl().getClassMetadata(persistentClass);
 	}
 
 	public ClassMetadata getClassMetadata(String entityName)
 	throws HibernateException {
 		return getImpl().getClassMetadata(entityName);
 	}
 
 	public CollectionMetadata getCollectionMetadata(String roleName) throws HibernateException {
 		return getImpl().getCollectionMetadata(roleName);
 	}
 
 	public Map<String,ClassMetadata> getAllClassMetadata() throws HibernateException {
 		return getImpl().getAllClassMetadata();
 	}
 
 	public Map getAllCollectionMetadata() throws HibernateException {
 		return getImpl().getAllCollectionMetadata();
 	}
 
 	public void close() throws HibernateException {
 	}
 
 	public boolean isClosed() {
 		return false;
 	}
 
 	public Cache getCache() {
 		return getImpl().getCache();
 	}
 
 	public void evict(Class persistentClass, Serializable id)
 		throws HibernateException {
 		getImpl().evict(persistentClass, id);
 	}
 
 	public void evict(Class persistentClass) throws HibernateException {
 		getImpl().evict(persistentClass);
 	}
 
 	public void evictEntity(String entityName, Serializable id)
 	throws HibernateException {
 		getImpl().evictEntity(entityName, id);
 	}
 
 	public void evictEntity(String entityName) throws HibernateException {
 		getImpl().evictEntity(entityName);
 	}
 
 	public void evictCollection(String roleName, Serializable id)
 		throws HibernateException {
 		getImpl().evictCollection(roleName, id);
 	}
 
 	public void evictCollection(String roleName) throws HibernateException {
 		getImpl().evictCollection(roleName);
 	}
 
 	public void evictQueries() throws HibernateException {
 		getImpl().evictQueries();
 	}
 
 	public void evictQueries(String cacheRegion) throws HibernateException {
 		getImpl().evictQueries(cacheRegion);
 	}
 
 	public Statistics getStatistics() {
 		return getImpl().getStatistics();
 	}
 
 	public StatelessSession openStatelessSession() {
 		return getImpl().openStatelessSession();
 	}
 
 	public StatelessSession openStatelessSession(Connection conn) {
 		return getImpl().openStatelessSession(conn);
 	}
 
 	public Set getDefinedFilterNames() {
 		return getImpl().getDefinedFilterNames();
 	}
 
 	public FilterDefinition getFilterDefinition(String filterName) throws HibernateException {
 		return getImpl().getFilterDefinition( filterName );
 	}
 
 	public boolean containsFetchProfileDefinition(String name) {
 		return getImpl().containsFetchProfileDefinition( name );
 	}
 
 	public TypeHelper getTypeHelper() {
 		return getImpl().getTypeHelper();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metadata/ClassMetadata.java b/hibernate-core/src/main/java/org/hibernate/metadata/ClassMetadata.java
index 1c91eaa027..f046f152ae 100644
--- a/hibernate-core/src/main/java/org/hibernate/metadata/ClassMetadata.java
+++ b/hibernate-core/src/main/java/org/hibernate/metadata/ClassMetadata.java
@@ -1,251 +1,246 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.metadata;
 import java.io.Serializable;
 import java.util.Map;
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.type.Type;
 
 /**
  * Exposes entity class metadata to the application
  *
  * @see org.hibernate.SessionFactory#getClassMetadata(Class)
  * @author Gavin King
  */
 public interface ClassMetadata {
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     // stuff that is persister-centric and/or EntityInfo-centric ~~~~~~~~~~~~~~
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * The name of the entity
 	 */
 	public String getEntityName();
 
 	/**
 	 * Get the name of the identifier property (or return null)
 	 */
 	public String getIdentifierPropertyName();
 
 	/**
 	 * Get the names of the class' persistent properties
 	 */
 	public String[] getPropertyNames();
 
 	/**
 	 * Get the identifier Hibernate type
 	 */
 	public Type getIdentifierType();
 
 	/**
 	 * Get the Hibernate types of the class properties
 	 */
 	public Type[] getPropertyTypes();
 
 	/**
 	 * Get the type of a particular (named) property
 	 */
 	public Type getPropertyType(String propertyName) throws HibernateException;
 
 	/**
 	 * Does this class support dynamic proxies?
 	 */
 	public boolean hasProxy();
 
 	/**
 	 * Are instances of this class mutable?
 	 */
 	public boolean isMutable();
 
 	/**
 	 * Are instances of this class versioned by a timestamp or version number column?
 	 */
 	public boolean isVersioned();
 
 	/**
 	 * Get the index of the version property
 	 */
 	public int getVersionProperty();
 
 	/**
 	 * Get the nullability of the class' persistent properties
 	 */
 	public boolean[] getPropertyNullability();
 
 
 	/**
 	 * Get the "laziness" of the properties of this class
 	 */
 	public boolean[] getPropertyLaziness();
 
 	/**
 	 * Does this class have an identifier property?
 	 */
 	public boolean hasIdentifierProperty();
 
 	/**
 	 * Does this entity declare a natural id?
 	 */
 	public boolean hasNaturalIdentifier();
 
 	/**
 	 * Which properties hold the natural id?
 	 */
 	public int[] getNaturalIdentifierProperties();
 	
 	/**
 	 * Does this entity have mapped subclasses?
 	 */
 	public boolean hasSubclasses();
 	
 	/**
 	 * Does this entity extend a mapped superclass?
 	 */
 	public boolean isInherited();
 	
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// stuff that is tuplizer-centric, but is passed a session ~~~~~~~~~~~~~~~~
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Return the values of the mapped properties of the object
 	 */
 	public Object[] getPropertyValuesToInsert(Object entity, Map mergeMap, SessionImplementor session) 
 	throws HibernateException;
 
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// stuff that is Tuplizer-centric ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * The persistent class, or null
 	 */
 	public Class getMappedClass(EntityMode entityMode);
 
 	/**
 	 * Create a class instance initialized with the given identifier
 	 *
 	 * @deprecated Use {@link #instantiate(Serializable, SessionImplementor)} instead
 	 * @noinspection JavaDoc
 	 */
 	public Object instantiate(Serializable id, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Create a class instance initialized with the given identifier
 	 *
 	 * @param id The identifier value to use (may be null to represent no value)
 	 * @param session The session from which the request originated.
 	 *
 	 * @return The instantiated entity.
 	 */
 	public Object instantiate(Serializable id, SessionImplementor session);
 
 	/**
 	 * Get the value of a particular (named) property
 	 */
 	public Object getPropertyValue(Object object, String propertyName, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Extract the property values from the given entity.
 	 *
 	 * @param entity The entity from which to extract the property values.
 	 * @param entityMode The entity-mode of the given entity
 	 * @return The property values.
 	 * @throws HibernateException
 	 */
 	public Object[] getPropertyValues(Object entity, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Set the value of a particular (named) property
 	 */
 	public void setPropertyValue(Object object, String propertyName, Object value, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Set the given values to the mapped properties of the given object
 	 */
 	public void setPropertyValues(Object object, Object[] values, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Get the identifier of an instance (throw an exception if no identifier property)
 	 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 	 * @noinspection JavaDoc
 	 */
 	public Serializable getIdentifier(Object object, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Get the identifier of an instance (throw an exception if no identifier property)
 	 *
 	 * @param entity The entity for which to get the identifier
 	 * @param session The session from which the request originated
 	 *
 	 * @return The identifier
 	 */
 	public Serializable getIdentifier(Object entity, SessionImplementor session);
 
 	/**
 	 * Inject the identifier value into the given entity.
 	 * </p>
 	 * Has no effect if the entity does not define an identifier property
 	 *
 	 * @param entity The entity to inject with the identifier value.
 	 * @param id The value to be injected as the identifier.
 	 * @param entityMode The entity mode
 	 *
 	 * @deprecated Use {@link #setIdentifier(Object, Serializable, SessionImplementor)} instead.
 	 * @noinspection JavaDoc
 	 */
 	public void setIdentifier(Object entity, Serializable id, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Inject the identifier value into the given entity.
 	 *
 	 * @param entity The entity to inject with the identifier value.
 	 * @param id The value to be injected as the identifier.
 	 * @param session The session from which is requests originates
 	 */
 	public void setIdentifier(Object entity, Serializable id, SessionImplementor session);
 
 
 	/**
 	 * Does the class implement the <tt>Lifecycle</tt> interface?
 	 */
 	public boolean implementsLifecycle(EntityMode entityMode);
 
 	/**
-	 * Does the class implement the <tt>Validatable</tt> interface?
-	 */
-	public boolean implementsValidatable(EntityMode entityMode);
-
-	/**
 	 * Get the version number (or timestamp) from the object's version property
 	 * (or return null if not versioned)
 	 */
 	public Object getVersion(Object object, EntityMode entityMode) throws HibernateException;
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java b/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
index ae47877f7f..3a160a3472 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
@@ -2797,1320 +2797,1316 @@ public abstract class AbstractEntityPersister
 		for ( int j = 0; j < span; j++ ) {
 			// Now update only the tables with dirty properties (and the table with the version number)
 			if ( tableUpdateNeeded[j] ) {
 				updateOrInsert(
 						id,
 						fields,
 						oldFields,
 						j == 0 ? rowId : null,
 						propsToUpdate,
 						j,
 						oldVersion,
 						object,
 						updateStrings[j],
 						session
 					);
 			}
 		}
 	}
 
 	public Serializable insert(Object[] fields, Object object, SessionImplementor session)
 			throws HibernateException {
 
 		final int span = getTableSpan();
 		final Serializable id;
 		if ( entityMetamodel.isDynamicInsert() ) {
 			// For the case of dynamic-insert="true", we need to generate the INSERT SQL
 			boolean[] notNull = getPropertiesToInsert( fields );
 			id = insert( fields, notNull, generateInsertString( true, notNull ), object, session );
 			for ( int j = 1; j < span; j++ ) {
 				insert( id, fields, notNull, j, generateInsertString( notNull, j ), object, session );
 			}
 		}
 		else {
 			// For the case of dynamic-insert="false", use the static SQL
 			id = insert( fields, getPropertyInsertability(), getSQLIdentityInsertString(), object, session );
 			for ( int j = 1; j < span; j++ ) {
 				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
 			}
 		}
 		return id;
 	}
 
 	public void insert(Serializable id, Object[] fields, Object object, SessionImplementor session)
 			throws HibernateException {
 
 		final int span = getTableSpan();
 		if ( entityMetamodel.isDynamicInsert() ) {
 			// For the case of dynamic-insert="true", we need to generate the INSERT SQL
 			boolean[] notNull = getPropertiesToInsert( fields );
 			for ( int j = 0; j < span; j++ ) {
 				insert( id, fields, notNull, j, generateInsertString( notNull, j ), object, session );
 			}
 		}
 		else {
 			// For the case of dynamic-insert="false", use the static SQL
 			for ( int j = 0; j < span; j++ ) {
 				insert( id, fields, getPropertyInsertability(), j, getSQLInsertStrings()[j], object, session );
 			}
 		}
 	}
 
 	/**
 	 * Delete an object
 	 */
 	public void delete(Serializable id, Object version, Object object, SessionImplementor session)
 			throws HibernateException {
 		final int span = getTableSpan();
 		boolean isImpliedOptimisticLocking = !entityMetamodel.isVersioned() && entityMetamodel.getOptimisticLockMode() > Versioning.OPTIMISTIC_LOCK_VERSION;
 		Object[] loadedState = null;
 		if ( isImpliedOptimisticLocking ) {
 			// need to treat this as if it where optimistic-lock="all" (dirty does *not* make sense);
 			// first we need to locate the "loaded" state
 			//
 			// Note, it potentially could be a proxy, so doAfterTransactionCompletion the location the safe way...
 			EntityKey key = new EntityKey( id, this, session.getEntityMode() );
 			Object entity = session.getPersistenceContext().getEntity( key );
 			if ( entity != null ) {
 				EntityEntry entry = session.getPersistenceContext().getEntry( entity );
 				loadedState = entry.getLoadedState();
 			}
 		}
 
 		final String[] deleteStrings;
 		if ( isImpliedOptimisticLocking && loadedState != null ) {
 			// we need to utilize dynamic delete statements
 			deleteStrings = generateSQLDeletStrings( loadedState );
 		}
 		else {
 			// otherwise, utilize the static delete statements
 			deleteStrings = getSQLDeleteStrings();
 		}
 
 		for ( int j = span - 1; j >= 0; j-- ) {
 			delete( id, version, j, object, deleteStrings[j], session, loadedState );
 		}
 
 	}
 
 	private String[] generateSQLDeletStrings(Object[] loadedState) {
 		int span = getTableSpan();
 		String[] deleteStrings = new String[span];
 		for ( int j = span - 1; j >= 0; j-- ) {
 			Delete delete = new Delete()
 					.setTableName( getTableName( j ) )
 					.addPrimaryKeyColumns( getKeyColumns( j ) );
 			if ( getFactory().getSettings().isCommentsEnabled() ) {
 				delete.setComment( "delete " + getEntityName() + " [" + j + "]" );
 			}
 
 			boolean[] versionability = getPropertyVersionability();
 			Type[] types = getPropertyTypes();
 			for ( int i = 0; i < entityMetamodel.getPropertySpan(); i++ ) {
 				if ( isPropertyOfTable( i, j ) && versionability[i] ) {
 					// this property belongs to the table and it is not specifically
 					// excluded from optimistic locking by optimistic-lock="false"
 					String[] propertyColumnNames = getPropertyColumnNames( i );
 					boolean[] propertyNullness = types[i].toColumnNullness( loadedState[i], getFactory() );
 					for ( int k = 0; k < propertyNullness.length; k++ ) {
 						if ( propertyNullness[k] ) {
 							delete.addWhereFragment( propertyColumnNames[k] + " = ?" );
 						}
 						else {
 							delete.addWhereFragment( propertyColumnNames[k] + " is null" );
 						}
 					}
 				}
 			}
 			deleteStrings[j] = delete.toStatementString();
 		}
 		return deleteStrings;
 	}
 
 	protected void logStaticSQL() {
         if (LOG.isDebugEnabled()) {
             LOG.debugf("Static SQL for entity: %s", getEntityName());
             if (sqlLazySelectString != null) LOG.debugf(" Lazy select: %s", sqlLazySelectString);
             if (sqlVersionSelectString != null) LOG.debugf(" Version select: %s", sqlVersionSelectString);
             if (sqlSnapshotSelectString != null) LOG.debugf(" Snapshot select: %s", sqlSnapshotSelectString);
 			for ( int j = 0; j < getTableSpan(); j++ ) {
                 LOG.debugf(" Insert %s: %s", j, getSQLInsertStrings()[j]);
                 LOG.debugf(" Update %s: %s", j, getSQLUpdateStrings()[j]);
                 LOG.debugf(" Delete %s: %s", j, getSQLDeleteStrings()[j]);
 			}
             if (sqlIdentityInsertString != null) LOG.debugf(" Identity insert: %s", sqlIdentityInsertString);
             if (sqlUpdateByRowIdString != null) LOG.debugf(" Update by row id (all fields): %s", sqlUpdateByRowIdString);
             if (sqlLazyUpdateByRowIdString != null) LOG.debugf(" Update by row id (non-lazy fields): %s",
                                                                sqlLazyUpdateByRowIdString);
             if (sqlInsertGeneratedValuesSelectString != null) LOG.debugf("Insert-generated property select: %s",
                                                                          sqlInsertGeneratedValuesSelectString);
             if (sqlUpdateGeneratedValuesSelectString != null) LOG.debugf("Update-generated property select: %s",
                                                                          sqlUpdateGeneratedValuesSelectString);
 		}
 	}
 
 	public String filterFragment(String alias, Map enabledFilters) throws MappingException {
 		final StringBuffer sessionFilterFragment = new StringBuffer();
 		filterHelper.render( sessionFilterFragment, generateFilterConditionAlias( alias ), enabledFilters );
 
 		return sessionFilterFragment.append( filterFragment( alias ) ).toString();
 	}
 
 	public String generateFilterConditionAlias(String rootAlias) {
 		return rootAlias;
 	}
 
 	public String oneToManyFilterFragment(String alias) throws MappingException {
 		return "";
 	}
 
 	public String fromJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
 		return getSubclassTableSpan() == 1 ?
 				"" : //just a performance opt!
 				createJoin( alias, innerJoin, includeSubclasses ).toFromFragmentString();
 	}
 
 	public String whereJoinFragment(String alias, boolean innerJoin, boolean includeSubclasses) {
 		return getSubclassTableSpan() == 1 ?
 				"" : //just a performance opt!
 				createJoin( alias, innerJoin, includeSubclasses ).toWhereFragmentString();
 	}
 
 	protected boolean isSubclassTableLazy(int j) {
 		return false;
 	}
 
 	protected JoinFragment createJoin(String name, boolean innerJoin, boolean includeSubclasses) {
 		final String[] idCols = StringHelper.qualify( name, getIdentifierColumnNames() ); //all joins join to the pk of the driving table
 		final JoinFragment join = getFactory().getDialect().createOuterJoinFragment();
 		final int tableSpan = getSubclassTableSpan();
 		for ( int j = 1; j < tableSpan; j++ ) { //notice that we skip the first table; it is the driving table!
 			final boolean joinIsIncluded = isClassOrSuperclassTable( j ) ||
 					( includeSubclasses && !isSubclassTableSequentialSelect( j ) && !isSubclassTableLazy( j ) );
 			if ( joinIsIncluded ) {
 				join.addJoin( getSubclassTableName( j ),
 						generateTableAlias( name, j ),
 						idCols,
 						getSubclassTableKeyColumns( j ),
 						innerJoin && isClassOrSuperclassTable( j ) && !isInverseTable( j ) && !isNullableTable( j ) ?
 						JoinFragment.INNER_JOIN : //we can inner join to superclass tables (the row MUST be there)
 						JoinFragment.LEFT_OUTER_JOIN //we can never inner join to subclass tables
 					);
 			}
 		}
 		return join;
 	}
 
 	protected JoinFragment createJoin(int[] tableNumbers, String drivingAlias) {
 		final String[] keyCols = StringHelper.qualify( drivingAlias, getSubclassTableKeyColumns( tableNumbers[0] ) );
 		final JoinFragment jf = getFactory().getDialect().createOuterJoinFragment();
 		for ( int i = 1; i < tableNumbers.length; i++ ) { //skip the driving table
 			final int j = tableNumbers[i];
 			jf.addJoin( getSubclassTableName( j ),
 					generateTableAlias( getRootAlias(), j ),
 					keyCols,
 					getSubclassTableKeyColumns( j ),
 					isInverseSubclassTable( j ) || isNullableSubclassTable( j ) ?
 					JoinFragment.LEFT_OUTER_JOIN :
 					JoinFragment.INNER_JOIN );
 		}
 		return jf;
 	}
 
 	protected SelectFragment createSelect(final int[] subclassColumnNumbers,
 										  final int[] subclassFormulaNumbers) {
 
 		SelectFragment selectFragment = new SelectFragment();
 
 		int[] columnTableNumbers = getSubclassColumnTableNumberClosure();
 		String[] columnAliases = getSubclassColumnAliasClosure();
 		String[] columnReaderTemplates = getSubclassColumnReaderTemplateClosure();
 		for ( int i = 0; i < subclassColumnNumbers.length; i++ ) {
 			int columnNumber = subclassColumnNumbers[i];
 			if ( subclassColumnSelectableClosure[columnNumber] ) {
 				final String subalias = generateTableAlias( getRootAlias(), columnTableNumbers[columnNumber] );
 				selectFragment.addColumnTemplate( subalias, columnReaderTemplates[columnNumber], columnAliases[columnNumber] );
 			}
 		}
 
 		int[] formulaTableNumbers = getSubclassFormulaTableNumberClosure();
 		String[] formulaTemplates = getSubclassFormulaTemplateClosure();
 		String[] formulaAliases = getSubclassFormulaAliasClosure();
 		for ( int i = 0; i < subclassFormulaNumbers.length; i++ ) {
 			int formulaNumber = subclassFormulaNumbers[i];
 			final String subalias = generateTableAlias( getRootAlias(), formulaTableNumbers[formulaNumber] );
 			selectFragment.addFormula( subalias, formulaTemplates[formulaNumber], formulaAliases[formulaNumber] );
 		}
 
 		return selectFragment;
 	}
 
 	protected String createFrom(int tableNumber, String alias) {
 		return getSubclassTableName( tableNumber ) + ' ' + alias;
 	}
 
 	protected String createWhereByKey(int tableNumber, String alias) {
 		//TODO: move to .sql package, and refactor with similar things!
 		return StringHelper.join( "=? and ",
 				StringHelper.qualify( alias, getSubclassTableKeyColumns( tableNumber ) ) ) + "=?";
 	}
 
 	protected String renderSelect(
 			final int[] tableNumbers,
 	        final int[] columnNumbers,
 	        final int[] formulaNumbers) {
 
 		Arrays.sort( tableNumbers ); //get 'em in the right order (not that it really matters)
 
 		//render the where and from parts
 		int drivingTable = tableNumbers[0];
 		final String drivingAlias = generateTableAlias( getRootAlias(), drivingTable ); //we *could* regerate this inside each called method!
 		final String where = createWhereByKey( drivingTable, drivingAlias );
 		final String from = createFrom( drivingTable, drivingAlias );
 
 		//now render the joins
 		JoinFragment jf = createJoin( tableNumbers, drivingAlias );
 
 		//now render the select clause
 		SelectFragment selectFragment = createSelect( columnNumbers, formulaNumbers );
 
 		//now tie it all together
 		Select select = new Select( getFactory().getDialect() );
 		select.setSelectClause( selectFragment.toFragmentString().substring( 2 ) );
 		select.setFromClause( from );
 		select.setWhereClause( where );
 		select.setOuterJoins( jf.toFromFragmentString(), jf.toWhereFragmentString() );
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "sequential select " + getEntityName() );
 		}
 		return select.toStatementString();
 	}
 
 	private String getRootAlias() {
 		return StringHelper.generateAlias( getEntityName() );
 	}
 
 	protected void postConstruct(Mapping mapping) throws MappingException {
 		initPropertyPaths(mapping);
 
 		//insert/update/delete SQL
 		final int joinSpan = getTableSpan();
 		sqlDeleteStrings = new String[joinSpan];
 		sqlInsertStrings = new String[joinSpan];
 		sqlUpdateStrings = new String[joinSpan];
 		sqlLazyUpdateStrings = new String[joinSpan];
 
 		sqlUpdateByRowIdString = rowIdName == null ?
 				null :
 				generateUpdateString( getPropertyUpdateability(), 0, true );
 		sqlLazyUpdateByRowIdString = rowIdName == null ?
 				null :
 				generateUpdateString( getNonLazyPropertyUpdateability(), 0, true );
 
 		for ( int j = 0; j < joinSpan; j++ ) {
 			sqlInsertStrings[j] = customSQLInsert[j] == null ?
 					generateInsertString( getPropertyInsertability(), j ) :
 					customSQLInsert[j];
 			sqlUpdateStrings[j] = customSQLUpdate[j] == null ?
 					generateUpdateString( getPropertyUpdateability(), j, false ) :
 					customSQLUpdate[j];
 			sqlLazyUpdateStrings[j] = customSQLUpdate[j] == null ?
 					generateUpdateString( getNonLazyPropertyUpdateability(), j, false ) :
 					customSQLUpdate[j];
 			sqlDeleteStrings[j] = customSQLDelete[j] == null ?
 					generateDeleteString( j ) :
 					customSQLDelete[j];
 		}
 
 		tableHasColumns = new boolean[joinSpan];
 		for ( int j = 0; j < joinSpan; j++ ) {
 			tableHasColumns[j] = sqlUpdateStrings[j] != null;
 		}
 
 		//select SQL
 		sqlSnapshotSelectString = generateSnapshotSelectString();
 		sqlLazySelectString = generateLazySelectString();
 		sqlVersionSelectString = generateSelectVersionString();
 		if ( hasInsertGeneratedProperties() ) {
 			sqlInsertGeneratedValuesSelectString = generateInsertGeneratedValuesSelectString();
 		}
 		if ( hasUpdateGeneratedProperties() ) {
 			sqlUpdateGeneratedValuesSelectString = generateUpdateGeneratedValuesSelectString();
 		}
 		if ( isIdentifierAssignedByInsert() ) {
 			identityDelegate = ( ( PostInsertIdentifierGenerator ) getIdentifierGenerator() )
 					.getInsertGeneratedIdentifierDelegate( this, getFactory().getDialect(), useGetGeneratedKeys() );
 			sqlIdentityInsertString = customSQLInsert[0] == null
 					? generateIdentityInsertString( getPropertyInsertability() )
 					: customSQLInsert[0];
 		}
 		else {
 			sqlIdentityInsertString = null;
 		}
 
 		logStaticSQL();
 
 	}
 
 	public void postInstantiate() throws MappingException {
 
 		createLoaders();
 		createUniqueKeyLoaders();
 		createQueryLoader();
 
 	}
 
 	//needed by subclasses to override the createLoader strategy
 	protected Map getLoaders() {
 		return loaders;
 	}
 
 	//Relational based Persisters should be content with this implementation
 	protected void createLoaders() {
 		final Map loaders = getLoaders();
 		loaders.put( LockMode.NONE, createEntityLoader( LockMode.NONE ) );
 
 		UniqueEntityLoader readLoader = createEntityLoader( LockMode.READ );
 		loaders.put( LockMode.READ, readLoader );
 
 		//TODO: inexact, what we really need to know is: are any outer joins used?
 		boolean disableForUpdate = getSubclassTableSpan() > 1 &&
 				hasSubclasses() &&
 				!getFactory().getDialect().supportsOuterJoinForUpdate();
 
 		loaders.put(
 				LockMode.UPGRADE,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.UPGRADE )
 			);
 		loaders.put(
 				LockMode.UPGRADE_NOWAIT,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.UPGRADE_NOWAIT )
 			);
 		loaders.put(
 				LockMode.FORCE,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.FORCE )
 			);
 		loaders.put(
 				LockMode.PESSIMISTIC_READ,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.PESSIMISTIC_READ )
 			);
 		loaders.put(
 				LockMode.PESSIMISTIC_WRITE,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.PESSIMISTIC_WRITE )
 			);
 		loaders.put(
 				LockMode.PESSIMISTIC_FORCE_INCREMENT,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.PESSIMISTIC_FORCE_INCREMENT )
 			);
 		loaders.put( LockMode.OPTIMISTIC, createEntityLoader( LockMode.OPTIMISTIC) );
 		loaders.put( LockMode.OPTIMISTIC_FORCE_INCREMENT, createEntityLoader(LockMode.OPTIMISTIC_FORCE_INCREMENT) );
 
 		loaders.put(
 				"merge",
 				new CascadeEntityLoader( this, CascadingAction.MERGE, getFactory() )
 			);
 		loaders.put(
 				"refresh",
 				new CascadeEntityLoader( this, CascadingAction.REFRESH, getFactory() )
 			);
 	}
 
 	protected void createQueryLoader() {
 		if ( loaderName != null ) {
 			queryLoader = new NamedQueryLoader( loaderName, this );
 		}
 	}
 
 	/**
 	 * Load an instance using either the <tt>forUpdateLoader</tt> or the outer joining <tt>loader</tt>,
 	 * depending upon the value of the <tt>lock</tt> parameter
 	 */
 	public Object load(Serializable id, Object optionalObject, LockMode lockMode, SessionImplementor session) {
 		return load( id, optionalObject, new LockOptions().setLockMode(lockMode), session );
 	}
 
 	/**
 	 * Load an instance using either the <tt>forUpdateLoader</tt> or the outer joining <tt>loader</tt>,
 	 * depending upon the value of the <tt>lock</tt> parameter
 	 */
 	public Object load(Serializable id, Object optionalObject, LockOptions lockOptions, SessionImplementor session)
 			throws HibernateException {
 
         if (LOG.isTraceEnabled()) LOG.trace("Fetching entity: " + MessageHelper.infoString(this, id, getFactory()));
 
 		final UniqueEntityLoader loader = getAppropriateLoader(lockOptions, session );
 		return loader.load( id, optionalObject, session, lockOptions );
 	}
 
 	public void registerAffectingFetchProfile(String fetchProfileName) {
 		affectingFetchProfileNames.add( fetchProfileName );
 	}
 
 	private boolean isAffectedByEnabledFetchProfiles(SessionImplementor session) {
 		Iterator itr = session.getLoadQueryInfluencers().getEnabledFetchProfileNames().iterator();
 		while ( itr.hasNext() ) {
 			if ( affectingFetchProfileNames.contains( itr.next() ) ) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	private boolean isAffectedByEnabledFilters(SessionImplementor session) {
 		return session.getLoadQueryInfluencers().hasEnabledFilters()
 				&& filterHelper.isAffectedBy( session.getLoadQueryInfluencers().getEnabledFilters() );
 	}
 
 	private UniqueEntityLoader getAppropriateLoader(LockOptions lockOptions, SessionImplementor session) {
 		if ( queryLoader != null ) {
 			// if the user specified a custom query loader we need to that
 			// regardless of any other consideration
 			return queryLoader;
 		}
 		else if ( isAffectedByEnabledFilters( session ) ) {
 			// because filters affect the rows returned (because they add
 			// restirctions) these need to be next in precendence
 			return createEntityLoader(lockOptions, session.getLoadQueryInfluencers() );
 		}
 		else if ( session.getLoadQueryInfluencers().getInternalFetchProfile() != null && LockMode.UPGRADE.greaterThan( lockOptions.getLockMode() ) ) {
 			// Next, we consider whether an 'internal' fetch profile has been set.
 			// This indicates a special fetch profile Hibernate needs applied
 			// (for its merge loading process e.g.).
 			return ( UniqueEntityLoader ) getLoaders().get( session.getLoadQueryInfluencers().getInternalFetchProfile() );
 		}
 		else if ( isAffectedByEnabledFetchProfiles( session ) ) {
 			// If the session has associated influencers we need to adjust the
 			// SQL query used for loading based on those influencers
 			return createEntityLoader(lockOptions, session.getLoadQueryInfluencers() );
 		}
 		else if ( lockOptions.getTimeOut() != LockOptions.WAIT_FOREVER ) {
 			return createEntityLoader( lockOptions, session.getLoadQueryInfluencers() );
 		}
 		else {
 			return ( UniqueEntityLoader ) getLoaders().get( lockOptions.getLockMode() );
 		}
 	}
 
 	private boolean isAllNull(Object[] array, int tableNumber) {
 		for ( int i = 0; i < array.length; i++ ) {
 			if ( isPropertyOfTable( i, tableNumber ) && array[i] != null ) {
 				return false;
 			}
 		}
 		return true;
 	}
 
 	public boolean isSubclassPropertyNullable(int i) {
 		return subclassPropertyNullabilityClosure[i];
 	}
 
 	/**
 	 * Transform the array of property indexes to an array of booleans,
 	 * true when the property is dirty
 	 */
 	protected final boolean[] getPropertiesToUpdate(final int[] dirtyProperties, final boolean hasDirtyCollection) {
 		final boolean[] propsToUpdate = new boolean[ entityMetamodel.getPropertySpan() ];
 		final boolean[] updateability = getPropertyUpdateability(); //no need to check laziness, dirty checking handles that
 		for ( int j = 0; j < dirtyProperties.length; j++ ) {
 			int property = dirtyProperties[j];
 			if ( updateability[property] ) {
 				propsToUpdate[property] = true;
 			}
 		}
 		if ( isVersioned() && updateability[getVersionProperty() ]) {
 			propsToUpdate[ getVersionProperty() ] =
 				Versioning.isVersionIncrementRequired( dirtyProperties, hasDirtyCollection, getPropertyVersionability() );
 		}
 		return propsToUpdate;
 	}
 
 	/**
 	 * Transform the array of property indexes to an array of booleans,
 	 * true when the property is insertable and non-null
 	 */
 	protected boolean[] getPropertiesToInsert(Object[] fields) {
 		boolean[] notNull = new boolean[fields.length];
 		boolean[] insertable = getPropertyInsertability();
 		for ( int i = 0; i < fields.length; i++ ) {
 			notNull[i] = insertable[i] && fields[i] != null;
 		}
 		return notNull;
 	}
 
 	/**
 	 * Locate the property-indices of all properties considered to be dirty.
 	 *
 	 * @param currentState The current state of the entity (the state to be checked).
 	 * @param previousState The previous state of the entity (the state to be checked against).
 	 * @param entity The entity for which we are checking state dirtiness.
 	 * @param session The session in which the check is ccurring.
 	 * @return <tt>null</tt> or the indices of the dirty properties
 	 * @throws HibernateException
 	 */
 	public int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SessionImplementor session)
 	throws HibernateException {
 		int[] props = TypeHelper.findDirty(
 				entityMetamodel.getProperties(),
 				currentState,
 				previousState,
 				propertyColumnUpdateable,
 				hasUninitializedLazyProperties( entity, session.getEntityMode() ),
 				session
 			);
 		if ( props == null ) {
 			return null;
 		}
 		else {
 			logDirtyProperties( props );
 			return props;
 		}
 	}
 
 	/**
 	 * Locate the property-indices of all properties considered to be dirty.
 	 *
 	 * @param old The old state of the entity.
 	 * @param current The current state of the entity.
 	 * @param entity The entity for which we are checking state modification.
 	 * @param session The session in which the check is ccurring.
 	 * @return <tt>null</tt> or the indices of the modified properties
 	 * @throws HibernateException
 	 */
 	public int[] findModified(Object[] old, Object[] current, Object entity, SessionImplementor session)
 	throws HibernateException {
 		int[] props = TypeHelper.findModified(
 				entityMetamodel.getProperties(),
 				current,
 				old,
 				propertyColumnUpdateable,
 				hasUninitializedLazyProperties( entity, session.getEntityMode() ),
 				session
 			);
 		if ( props == null ) {
 			return null;
 		}
 		else {
 			logDirtyProperties( props );
 			return props;
 		}
 	}
 
 	/**
 	 * Which properties appear in the SQL update?
 	 * (Initialized, updateable ones!)
 	 */
 	protected boolean[] getPropertyUpdateability(Object entity, EntityMode entityMode) {
 		return hasUninitializedLazyProperties( entity, entityMode ) ?
 				getNonLazyPropertyUpdateability() :
 				getPropertyUpdateability();
 	}
 
 	private void logDirtyProperties(int[] props) {
         if (LOG.isTraceEnabled()) {
 			for ( int i = 0; i < props.length; i++ ) {
 				String propertyName = entityMetamodel.getProperties()[ props[i] ].getName();
                 LOG.trace(StringHelper.qualify(getEntityName(), propertyName) + " is dirty");
 			}
 		}
 	}
 
 	protected EntityTuplizer getTuplizer(SessionImplementor session) {
 		return getTuplizer( session.getEntityMode() );
 	}
 
 	protected EntityTuplizer getTuplizer(EntityMode entityMode) {
 		return entityMetamodel.getTuplizer( entityMode );
 	}
 
 	public SessionFactoryImplementor getFactory() {
 		return factory;
 	}
 
 	public EntityMetamodel getEntityMetamodel() {
 		return entityMetamodel;
 	}
 
 	public boolean hasCache() {
 		return cacheAccessStrategy != null;
 	}
 
 	public EntityRegionAccessStrategy getCacheAccessStrategy() {
 		return cacheAccessStrategy;
 	}
 
 	public CacheEntryStructure getCacheEntryStructure() {
 		return cacheEntryStructure;
 	}
 
 	public Comparator getVersionComparator() {
 		return isVersioned() ? getVersionType().getComparator() : null;
 	}
 
 	// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	public final String getEntityName() {
 		return entityMetamodel.getName();
 	}
 
 	public EntityType getEntityType() {
 		return entityMetamodel.getEntityType();
 	}
 
 	public boolean isPolymorphic() {
 		return entityMetamodel.isPolymorphic();
 	}
 
 	public boolean isInherited() {
 		return entityMetamodel.isInherited();
 	}
 
 	public boolean hasCascades() {
 		return entityMetamodel.hasCascades();
 	}
 
 	public boolean hasIdentifierProperty() {
 		return !entityMetamodel.getIdentifierProperty().isVirtual();
 	}
 
 	public VersionType getVersionType() {
 		return ( VersionType ) locateVersionType();
 	}
 
 	private Type locateVersionType() {
 		return entityMetamodel.getVersionProperty() == null ?
 				null :
 				entityMetamodel.getVersionProperty().getType();
 	}
 
 	public int getVersionProperty() {
 		return entityMetamodel.getVersionPropertyIndex();
 	}
 
 	public boolean isVersioned() {
 		return entityMetamodel.isVersioned();
 	}
 
 	public boolean isIdentifierAssignedByInsert() {
 		return entityMetamodel.getIdentifierProperty().isIdentifierAssignedByInsert();
 	}
 
 	public boolean hasLazyProperties() {
 		return entityMetamodel.hasLazyProperties();
 	}
 
 //	public boolean hasUninitializedLazyProperties(Object entity) {
 //		if ( hasLazyProperties() ) {
 //			InterceptFieldCallback callback = ( ( InterceptFieldEnabled ) entity ).getInterceptFieldCallback();
 //			return callback != null && !( ( FieldInterceptor ) callback ).isInitialized();
 //		}
 //		else {
 //			return false;
 //		}
 //	}
 
 	public void afterReassociate(Object entity, SessionImplementor session) {
 		//if ( hasLazyProperties() ) {
 		if ( FieldInterceptionHelper.isInstrumented( entity ) ) {
 			FieldInterceptor interceptor = FieldInterceptionHelper.extractFieldInterceptor( entity );
 			if ( interceptor != null ) {
 				interceptor.setSession( session );
 			}
 			else {
 				FieldInterceptor fieldInterceptor = FieldInterceptionHelper.injectFieldInterceptor(
 						entity,
 						getEntityName(),
 						null,
 						session
 				);
 				fieldInterceptor.dirty();
 			}
 		}
 	}
 
 	public Boolean isTransient(Object entity, SessionImplementor session) throws HibernateException {
 		final Serializable id;
 		if ( canExtractIdOutOfEntity() ) {
 			id = getIdentifier( entity, session );
 		}
 		else {
 			id = null;
 		}
 		// we *always* assume an instance with a null
 		// identifier or no identifier property is unsaved!
 		if ( id == null ) {
 			return Boolean.TRUE;
 		}
 
 		// check the version unsaved-value, if appropriate
 		final Object version = getVersion( entity, session.getEntityMode() );
 		if ( isVersioned() ) {
 			// let this take precedence if defined, since it works for
 			// assigned identifiers
 			Boolean result = entityMetamodel.getVersionProperty()
 					.getUnsavedValue().isUnsaved( version );
 			if ( result != null ) {
 				return result;
 			}
 		}
 
 		// check the id unsaved-value
 		Boolean result = entityMetamodel.getIdentifierProperty()
 				.getUnsavedValue().isUnsaved( id );
 		if ( result != null ) {
 			return result;
 		}
 
 		// check to see if it is in the second-level cache
 		if ( hasCache() ) {
 			CacheKey ck = new CacheKey(
 					id,
 					getIdentifierType(),
 					getRootEntityName(),
 					session.getEntityMode(),
 					session.getFactory()
 				);
 			if ( getCacheAccessStrategy().get( ck, session.getTimestamp() ) != null ) {
 				return Boolean.FALSE;
 			}
 		}
 
 		return null;
 	}
 
 	public boolean hasCollections() {
 		return entityMetamodel.hasCollections();
 	}
 
 	public boolean hasMutableProperties() {
 		return entityMetamodel.hasMutableProperties();
 	}
 
 	public boolean isMutable() {
 		return entityMetamodel.isMutable();
 	}
 
 	private boolean isModifiableEntity(EntityEntry entry) {
 
 		return ( entry == null ? isMutable() : entry.isModifiableEntity() );
 	}
 
 	public boolean isAbstract() {
 		return entityMetamodel.isAbstract();
 	}
 
 	public boolean hasSubclasses() {
 		return entityMetamodel.hasSubclasses();
 	}
 
 	public boolean hasProxy() {
 		return entityMetamodel.isLazy();
 	}
 
 	public IdentifierGenerator getIdentifierGenerator() throws HibernateException {
 		return entityMetamodel.getIdentifierProperty().getIdentifierGenerator();
 	}
 
 	public String getRootEntityName() {
 		return entityMetamodel.getRootName();
 	}
 
 	public ClassMetadata getClassMetadata() {
 		return this;
 	}
 
 	public String getMappedSuperclass() {
 		return entityMetamodel.getSuperclass();
 	}
 
 	public boolean isExplicitPolymorphism() {
 		return entityMetamodel.isExplicitPolymorphism();
 	}
 
 	protected boolean useDynamicUpdate() {
 		return entityMetamodel.isDynamicUpdate();
 	}
 
 	protected boolean useDynamicInsert() {
 		return entityMetamodel.isDynamicInsert();
 	}
 
 	protected boolean hasEmbeddedCompositeIdentifier() {
 		return entityMetamodel.getIdentifierProperty().isEmbedded();
 	}
 
 	public boolean canExtractIdOutOfEntity() {
 		return hasIdentifierProperty() || hasEmbeddedCompositeIdentifier() || hasIdentifierMapper();
 	}
 
 	private boolean hasIdentifierMapper() {
 		return entityMetamodel.getIdentifierProperty().hasIdentifierMapper();
 	}
 
 	public String[] getKeyColumnNames() {
 		return getIdentifierColumnNames();
 	}
 
 	public String getName() {
 		return getEntityName();
 	}
 
 	public boolean isCollection() {
 		return false;
 	}
 
 	public boolean consumesEntityAlias() {
 		return true;
 	}
 
 	public boolean consumesCollectionAlias() {
 		return false;
 	}
 
 	public Type getPropertyType(String propertyName) throws MappingException {
 		return propertyMapping.toType(propertyName);
 	}
 
 	public Type getType() {
 		return entityMetamodel.getEntityType();
 	}
 
 	public boolean isSelectBeforeUpdateRequired() {
 		return entityMetamodel.isSelectBeforeUpdate();
 	}
 
 	protected final int optimisticLockMode() {
 		return entityMetamodel.getOptimisticLockMode();
 	}
 
 	public Object createProxy(Serializable id, SessionImplementor session) throws HibernateException {
 		return entityMetamodel.getTuplizer( session.getEntityMode() )
 				.createProxy( id, session );
 	}
 
 	public String toString() {
 		return StringHelper.unqualify( getClass().getName() ) +
 				'(' + entityMetamodel.getName() + ')';
 	}
 
 	public final String selectFragment(
 			Joinable rhs,
 			String rhsAlias,
 			String lhsAlias,
 			String entitySuffix,
 			String collectionSuffix,
 			boolean includeCollectionColumns) {
 		return selectFragment( lhsAlias, entitySuffix );
 	}
 
 	public boolean isInstrumented(EntityMode entityMode) {
 		EntityTuplizer tuplizer = entityMetamodel.getTuplizerOrNull(entityMode);
 		return tuplizer!=null && tuplizer.isInstrumented();
 	}
 
 	public boolean hasInsertGeneratedProperties() {
 		return entityMetamodel.hasInsertGeneratedValues();
 	}
 
 	public boolean hasUpdateGeneratedProperties() {
 		return entityMetamodel.hasUpdateGeneratedValues();
 	}
 
 	public boolean isVersionPropertyGenerated() {
 		return isVersioned() && ( getPropertyUpdateGenerationInclusions() [ getVersionProperty() ] != ValueInclusion.NONE );
 	}
 
 	public boolean isVersionPropertyInsertable() {
 		return isVersioned() && getPropertyInsertability() [ getVersionProperty() ];
 	}
 
 	public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session) {
 		getTuplizer( session ).afterInitialize( entity, lazyPropertiesAreUnfetched, session );
 	}
 
 	public String[] getPropertyNames() {
 		return entityMetamodel.getPropertyNames();
 	}
 
 	public Type[] getPropertyTypes() {
 		return entityMetamodel.getPropertyTypes();
 	}
 
 	public boolean[] getPropertyLaziness() {
 		return entityMetamodel.getPropertyLaziness();
 	}
 
 	public boolean[] getPropertyUpdateability() {
 		return entityMetamodel.getPropertyUpdateability();
 	}
 
 	public boolean[] getPropertyCheckability() {
 		return entityMetamodel.getPropertyCheckability();
 	}
 
 	public boolean[] getNonLazyPropertyUpdateability() {
 		return entityMetamodel.getNonlazyPropertyUpdateability();
 	}
 
 	public boolean[] getPropertyInsertability() {
 		return entityMetamodel.getPropertyInsertability();
 	}
 
 	public ValueInclusion[] getPropertyInsertGenerationInclusions() {
 		return entityMetamodel.getPropertyInsertGenerationInclusions();
 	}
 
 	public ValueInclusion[] getPropertyUpdateGenerationInclusions() {
 		return entityMetamodel.getPropertyUpdateGenerationInclusions();
 	}
 
 	public boolean[] getPropertyNullability() {
 		return entityMetamodel.getPropertyNullability();
 	}
 
 	public boolean[] getPropertyVersionability() {
 		return entityMetamodel.getPropertyVersionability();
 	}
 
 	public CascadeStyle[] getPropertyCascadeStyles() {
 		return entityMetamodel.getCascadeStyles();
 	}
 
 	public final Class getMappedClass(EntityMode entityMode) {
 		Tuplizer tup = entityMetamodel.getTuplizerOrNull(entityMode);
 		return tup==null ? null : tup.getMappedClass();
 	}
 
 	public boolean implementsLifecycle(EntityMode entityMode) {
 		return getTuplizer( entityMode ).isLifecycleImplementor();
 	}
 
-	public boolean implementsValidatable(EntityMode entityMode) {
-		return getTuplizer( entityMode ).isValidatableImplementor();
-	}
-
 	public Class getConcreteProxyClass(EntityMode entityMode) {
 		return getTuplizer( entityMode ).getConcreteProxyClass();
 	}
 
 	public void setPropertyValues(Object object, Object[] values, EntityMode entityMode)
 			throws HibernateException {
 		getTuplizer( entityMode ).setPropertyValues( object, values );
 	}
 
 	public void setPropertyValue(Object object, int i, Object value, EntityMode entityMode)
 			throws HibernateException {
 		getTuplizer( entityMode ).setPropertyValue( object, i, value );
 	}
 
 	public Object[] getPropertyValues(Object object, EntityMode entityMode)
 			throws HibernateException {
 		return getTuplizer( entityMode ).getPropertyValues( object );
 	}
 
 	public Object getPropertyValue(Object object, int i, EntityMode entityMode)
 			throws HibernateException {
 		return getTuplizer( entityMode ).getPropertyValue( object , i );
 	}
 
 	public Object getPropertyValue(Object object, String propertyName, EntityMode entityMode)
 			throws HibernateException {
 		return getTuplizer( entityMode ).getPropertyValue( object, propertyName );
 	}
 
 	public Serializable getIdentifier(Object object, EntityMode entityMode) throws HibernateException {
 		return getTuplizer( entityMode ).getIdentifier( object, null );
 	}
 
 	public Serializable getIdentifier(Object entity, SessionImplementor session) {
 		return getTuplizer( session.getEntityMode() ).getIdentifier( entity, session );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void setIdentifier(Object entity, Serializable id, EntityMode entityMode)
 			throws HibernateException {
 		getTuplizer( entityMode ).setIdentifier( entity, id, null );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void setIdentifier(Object entity, Serializable id, SessionImplementor session) {
 		getTuplizer( session ).setIdentifier( entity, id, session );
 	}
 
 	public Object getVersion(Object object, EntityMode entityMode)
 			throws HibernateException {
 		return getTuplizer( entityMode ).getVersion( object );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Object instantiate(Serializable id, EntityMode entityMode)
 			throws HibernateException {
 		return getTuplizer( entityMode ).instantiate( id, null );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Object instantiate(Serializable id, SessionImplementor session)
 			throws HibernateException {
 		return getTuplizer( session ).instantiate( id, session );
 	}
 
 	public boolean isInstance(Object object, EntityMode entityMode) {
 		return getTuplizer( entityMode ).isInstance( object );
 	}
 
 	public boolean hasUninitializedLazyProperties(Object object, EntityMode entityMode) {
 		return getTuplizer( entityMode ).hasUninitializedLazyProperties( object );
 	}
 
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, EntityMode entityMode) {
 		getTuplizer( entityMode ).resetIdentifier( entity, currentId, currentVersion, null );
 	}
 
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, SessionImplementor session) {
 		getTuplizer( session ).resetIdentifier( entity, currentId, currentVersion, session );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public EntityPersister getSubclassEntityPersister(
 			Object instance,
 			SessionFactoryImplementor factory,
 			EntityMode entityMode) {
 		if ( !hasSubclasses() ) {
 			return this;
 		}
 		else {
 			final String concreteEntityName = getTuplizer( entityMode )
 					.determineConcreteSubclassEntityName( instance, factory );
 			if ( concreteEntityName == null || getEntityName().equals( concreteEntityName ) ) {
 				// the contract of EntityTuplizer.determineConcreteSubclassEntityName says that returning null
 				// is an indication that the specified entity-name (this.getEntityName) should be used.
 				return this;
 			}
 			else {
 				return factory.getEntityPersister( concreteEntityName );
 			}
 		}
 	}
 
 	public EntityMode guessEntityMode(Object object) {
 		return entityMetamodel.guessEntityMode(object);
 	}
 
 	public boolean isMultiTable() {
 		return false;
 	}
 
 	public String getTemporaryIdTableName() {
 		return temporaryIdTableName;
 	}
 
 	public String getTemporaryIdTableDDL() {
 		return temporaryIdTableDDL;
 	}
 
 	protected int getPropertySpan() {
 		return entityMetamodel.getPropertySpan();
 	}
 
 	public Object[] getPropertyValuesToInsert(Object object, Map mergeMap, SessionImplementor session) throws HibernateException {
 		return getTuplizer( session.getEntityMode() ).getPropertyValuesToInsert( object, mergeMap, session );
 	}
 
 	public void processInsertGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session) {
 		if ( !hasInsertGeneratedProperties() ) {
 			throw new AssertionFailure("no insert-generated properties");
 		}
 		processGeneratedProperties( id, entity, state, session, sqlInsertGeneratedValuesSelectString, getPropertyInsertGenerationInclusions() );
 	}
 
 	public void processUpdateGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session) {
 		if ( !hasUpdateGeneratedProperties() ) {
 			throw new AssertionFailure("no update-generated properties");
 		}
 		processGeneratedProperties( id, entity, state, session, sqlUpdateGeneratedValuesSelectString, getPropertyUpdateGenerationInclusions() );
 	}
 
 	private void processGeneratedProperties(
 			Serializable id,
 	        Object entity,
 	        Object[] state,
 	        SessionImplementor session,
 	        String selectionSQL,
 	        ValueInclusion[] includeds) {
 		// force immediate execution of the insert batch (if one)
 		session.getTransactionCoordinator().getJdbcCoordinator().executeBatch();
 
 		try {
 			PreparedStatement ps = session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getStatementPreparer()
 					.prepareStatement( selectionSQL );
 			try {
 				getIdentifierType().nullSafeSet( ps, id, 1, session );
 				ResultSet rs = ps.executeQuery();
 				try {
 					if ( !rs.next() ) {
 						throw new HibernateException(
 								"Unable to locate row for retrieval of generated properties: " +
 								MessageHelper.infoString( this, id, getFactory() )
 							);
 					}
 					for ( int i = 0; i < getPropertySpan(); i++ ) {
 						if ( includeds[i] != ValueInclusion.NONE ) {
 							Object hydratedState = getPropertyTypes()[i].hydrate( rs, getPropertyAliases( "", i ), session, entity );
 							state[i] = getPropertyTypes()[i].resolve( hydratedState, session, entity );
 							setPropertyValue( entity, i, state[i], session.getEntityMode() );
 						}
 					}
 				}
 				finally {
 					if ( rs != null ) {
 						rs.close();
 					}
 				}
 			}
 			finally {
 				ps.close();
 			}
 		}
 		catch( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					"unable to select generated column values",
 					selectionSQL
 			);
 		}
 
 	}
 
 	public String getIdentifierPropertyName() {
 		return entityMetamodel.getIdentifierProperty().getName();
 	}
 
 	public Type getIdentifierType() {
 		return entityMetamodel.getIdentifierProperty().getType();
 	}
 
 	public boolean hasSubselectLoadableCollections() {
 		return hasSubselectLoadableCollections;
 	}
 
 	public int[] getNaturalIdentifierProperties() {
 		return entityMetamodel.getNaturalIdentifierProperties();
 	}
 
 	public Object[] getNaturalIdentifierSnapshot(Serializable id, SessionImplementor session) throws HibernateException {
 		if ( !hasNaturalIdentifier() ) {
 			throw new MappingException( "persistent class did not define a natural-id : " + MessageHelper.infoString( this ) );
 		}
         if (LOG.isTraceEnabled()) LOG.trace("Getting current natural-id snapshot state for: "
                                             + MessageHelper.infoString(this, id, getFactory()));
 
 		int[] naturalIdPropertyIndexes = getNaturalIdentifierProperties();
 		int naturalIdPropertyCount = naturalIdPropertyIndexes.length;
 		boolean[] naturalIdMarkers = new boolean[ getPropertySpan() ];
 		Type[] extractionTypes = new Type[ naturalIdPropertyCount ];
 		for ( int i = 0; i < naturalIdPropertyCount; i++ ) {
 			extractionTypes[i] = getPropertyTypes()[ naturalIdPropertyIndexes[i] ];
 			naturalIdMarkers[ naturalIdPropertyIndexes[i] ] = true;
 		}
 
 		///////////////////////////////////////////////////////////////////////
 		// TODO : look at perhaps caching this...
 		Select select = new Select( getFactory().getDialect() );
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "get current natural-id state " + getEntityName() );
 		}
 		select.setSelectClause( concretePropertySelectFragmentSansLeadingComma( getRootAlias(), naturalIdMarkers ) );
 		select.setFromClause( fromTableFragment( getRootAlias() ) + fromJoinFragment( getRootAlias(), true, false ) );
 
 		String[] aliasedIdColumns = StringHelper.qualify( getRootAlias(), getIdentifierColumnNames() );
 		String whereClause = new StringBuffer()
 			.append( StringHelper.join( "=? and ",
 					aliasedIdColumns ) )
 			.append( "=?" )
 			.append( whereJoinFragment( getRootAlias(), true, false ) )
 			.toString();
 
 		String sql = select.setOuterJoins( "", "" )
 				.setWhereClause( whereClause )
 				.toStatementString();
 		///////////////////////////////////////////////////////////////////////
 
 		Object[] snapshot = new Object[ naturalIdPropertyCount ];
 		try {
 			PreparedStatement ps = session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getStatementPreparer()
 					.prepareStatement( sql );
 			try {
 				getIdentifierType().nullSafeSet( ps, id, 1, session );
 				ResultSet rs = ps.executeQuery();
 				try {
 					//if there is no resulting row, return null
 					if ( !rs.next() ) {
 						return null;
 					}
 					final EntityKey key = new EntityKey( id, this, session.getEntityMode() );
 					Object owner = session.getPersistenceContext().getEntity( key );
 					for ( int i = 0; i < naturalIdPropertyCount; i++ ) {
 						snapshot[i] = extractionTypes[i].hydrate( rs, getPropertyAliases( "", naturalIdPropertyIndexes[i] ), session, null );
 						if (extractionTypes[i].isEntityType()) {
 							snapshot[i] = extractionTypes[i].resolve(snapshot[i], session, owner);
 						}
 					}
 					return snapshot;
 				}
 				finally {
 					rs.close();
 				}
 			}
 			finally {
 				ps.close();
 			}
 		}
 		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					"could not retrieve snapshot: " + MessageHelper.infoString( this, id, getFactory() ),
 			        sql
 			);
 		}
 	}
 
 	protected String concretePropertySelectFragmentSansLeadingComma(String alias, boolean[] include) {
 		String concretePropertySelectFragment = concretePropertySelectFragment( alias, include );
 		int firstComma = concretePropertySelectFragment.indexOf( ", " );
 		if ( firstComma == 0 ) {
 			concretePropertySelectFragment = concretePropertySelectFragment.substring( 2 );
 		}
 		return concretePropertySelectFragment;
 	}
 	public boolean hasNaturalIdentifier() {
 		return entityMetamodel.hasNaturalIdentifier();
 	}
 
 	public void setPropertyValue(Object object, String propertyName, Object value, EntityMode entityMode)
 			throws HibernateException {
 		getTuplizer( entityMode ).setPropertyValue( object, propertyName, value );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/entity/EntityPersister.java b/hibernate-core/src/main/java/org/hibernate/persister/entity/EntityPersister.java
index d1857a6837..7216062c19 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/entity/EntityPersister.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/entity/EntityPersister.java
@@ -1,768 +1,764 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.persister.entity;
 import java.io.Serializable;
 import java.util.Map;
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.cache.OptimisticCacheSource;
 import org.hibernate.cache.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.entry.CacheEntryStructure;
 import org.hibernate.engine.CascadeStyle;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.engine.ValueInclusion;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.tuple.entity.EntityMetamodel;
 import org.hibernate.type.Type;
 import org.hibernate.type.VersionType;
 
 /**
  * Implementors define mapping and persistence logic for a particular
  * strategy of entity mapping.  An instance of entity persisters corresponds
  * to a given mapped entity.
  * <p/>
  * Implementors must be threadsafe (preferrably immutable) and must provide a constructor
  * matching the signature of: {@link org.hibernate.mapping.PersistentClass}, {@link org.hibernate.engine.SessionFactoryImplementor}
  *
  * @author Gavin King
  */
 public interface EntityPersister extends OptimisticCacheSource {
 
 	/**
 	 * The property name of the "special" identifier property in HQL
 	 */
 	public static final String ENTITY_ID = "id";
 
 	/**
 	 * Finish the initialization of this object.
 	 * <p/>
 	 * Called only once per {@link org.hibernate.SessionFactory} lifecycle,
 	 * after all entity persisters have been instantiated.
 	 *
 	 * @throws org.hibernate.MappingException Indicates an issue in the metadata.
 	 */
 	public void postInstantiate() throws MappingException;
 
 	/**
 	 * Return the SessionFactory to which this persister "belongs".
 	 *
 	 * @return The owning SessionFactory.
 	 */
 	public SessionFactoryImplementor getFactory();
 
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     // stuff that is persister-centric and/or EntityInfo-centric ~~~~~~~~~~~~~~
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Returns an object that identifies the space in which identifiers of
 	 * this entity hierarchy are unique.  Might be a table name, a JNDI URL, etc.
 	 *
 	 * @return The root entity name.
 	 */
 	public String getRootEntityName();
 
 	/**
 	 * The entity name which this persister maps.
 	 *
 	 * @return The name of the entity which this persister maps.
 	 */
 	public String getEntityName();
 
 	/**
 	 * Retrieve the underlying entity metamodel instance...
 	 *
 	 *@return The metamodel
 	 */
 	public EntityMetamodel getEntityMetamodel();
 
 	/**
 	 * Determine whether the given name represents a subclass entity
 	 * (or this entity itself) of the entity mapped by this persister.
 	 *
 	 * @param entityName The entity name to be checked.
 	 * @return True if the given entity name represents either the entity
 	 * mapped by this persister or one of its subclass entities; false
 	 * otherwise.
 	 */
 	public boolean isSubclassEntityName(String entityName);
 
 	/**
 	 * Returns an array of objects that identify spaces in which properties of
 	 * this entity are persisted, for instances of this class only.
 	 * <p/>
 	 * For most implementations, this returns the complete set of table names
 	 * to which instances of the mapped entity are persisted (not accounting
 	 * for superclass entity mappings).
 	 *
 	 * @return The property spaces.
 	 */
 	public Serializable[] getPropertySpaces();
 
 	/**
 	 * Returns an array of objects that identify spaces in which properties of
 	 * this entity are persisted, for instances of this class and its subclasses.
 	 * <p/>
 	 * Much like {@link #getPropertySpaces()}, except that here we include subclass
 	 * entity spaces.
 	 *
 	 * @return The query spaces.
 	 */
 	public Serializable[] getQuerySpaces();
 
 	/**
 	 * Determine whether this entity supports dynamic proxies.
 	 *
 	 * @return True if the entity has dynamic proxy support; false otherwise.
 	 */
 	public boolean hasProxy();
 
 	/**
 	 * Determine whether this entity contains references to persistent collections.
 	 *
 	 * @return True if the entity does contain persistent collections; false otherwise.
 	 */
 	public boolean hasCollections();
 
 	/**
 	 * Determine whether any properties of this entity are considered mutable.
 	 *
 	 * @return True if any properties of the entity are mutable; false otherwise (meaning none are).
 	 */
 	public boolean hasMutableProperties();
 
 	/**
 	 * Determine whether this entity contains references to persistent collections
 	 * which are fetchable by subselect?
 	 *
 	 * @return True if the entity contains collections fetchable by subselect; false otherwise.
 	 */
 	public boolean hasSubselectLoadableCollections();
 
 	/**
 	 * Determine whether this entity has any non-none cascading.
 	 *
 	 * @return True if the entity has any properties with a cascade other than NONE;
 	 * false otherwise (aka, no cascading).
 	 */
 	public boolean hasCascades();
 
 	/**
 	 * Determine whether instances of this entity are considered mutable.
 	 *
 	 * @return True if the entity is considered mutable; false otherwise.
 	 */
 	public boolean isMutable();
 
 	/**
 	 * Determine whether the entity is inherited one or more other entities.
 	 * In other words, is this entity a subclass of other entities.
 	 *
 	 * @return True if other entities extend this entity; false otherwise.
 	 */
 	public boolean isInherited();
 
 	/**
 	 * Are identifiers of this entity assigned known before the insert execution?
 	 * Or, are they generated (in the database) by the insert execution.
 	 *
 	 * @return True if identifiers for this entity are generated by the insert
 	 * execution.
 	 */
 	public boolean isIdentifierAssignedByInsert();
 
 	/**
 	 * Get the type of a particular property by name.
 	 *
 	 * @param propertyName The name of the property for which to retrieve
 	 * the type.
 	 * @return The type.
 	 * @throws org.hibernate.MappingException Typically indicates an unknown
 	 * property name.
 	 */
 	public Type getPropertyType(String propertyName) throws MappingException;
 
 	/**
 	 * Compare the two snapshots to determine if they represent dirty state.
 	 *
 	 * @param currentState The current snapshot
 	 * @param previousState The baseline snapshot
 	 * @param owner The entity containing the state
 	 * @param session The originating session
 	 * @return The indices of all dirty properties, or null if no properties
 	 * were dirty.
 	 */
 	public int[] findDirty(Object[] currentState, Object[] previousState, Object owner, SessionImplementor session);
 
 	/**
 	 * Compare the two snapshots to determine if they represent modified state.
 	 *
 	 * @param old The baseline snapshot
 	 * @param current The current snapshot
 	 * @param object The entity containing the state
 	 * @param session The originating session
 	 * @return The indices of all modified properties, or null if no properties
 	 * were modified.
 	 */
 	public int[] findModified(Object[] old, Object[] current, Object object, SessionImplementor session);
 
 	/**
 	 * Determine whether the entity has a particular property holding
 	 * the identifier value.
 	 *
 	 * @return True if the entity has a specific property holding identifier value.
 	 */
 	public boolean hasIdentifierProperty();
 
 	/**
 	 * Determine whether detached instances of this entity carry their own
 	 * identifier value.
 	 * <p/>
 	 * The other option is the deprecated feature where users could supply
 	 * the id during session calls.
 	 *
 	 * @return True if either (1) {@link #hasIdentifierProperty()} or
 	 * (2) the identifier is an embedded composite identifier; false otherwise.
 	 */
 	public boolean canExtractIdOutOfEntity();
 
 	/**
 	 * Determine whether optimistic locking by column is enabled for this
 	 * entity.
 	 *
 	 * @return True if optimistic locking by column (i.e., <version/> or
 	 * <timestamp/>) is enabled; false otherwise.
 	 */
 	public boolean isVersioned();
 
 	/**
 	 * If {@link #isVersioned()}, then what is the type of the property
 	 * holding the locking value.
 	 *
 	 * @return The type of the version property; or null, if not versioned.
 	 */
 	public VersionType getVersionType();
 
 	/**
 	 * If {@link #isVersioned()}, then what is the index of the property
 	 * holding the locking value.
 	 *
 	 * @return The type of the version property; or -66, if not versioned.
 	 */
 	public int getVersionProperty();
 
 	/**
 	 * Determine whether this entity defines a natural identifier.
 	 *
 	 * @return True if the entity defines a natural id; false otherwise.
 	 */
 	public boolean hasNaturalIdentifier();
 
 	/**
 	 * If the entity defines a natural id ({@link #hasNaturalIdentifier()}), which
 	 * properties make up the natural id.
 	 *
 	 * @return The indices of the properties making of the natural id; or
 	 * null, if no natural id is defined.
 	 */
 	public int[] getNaturalIdentifierProperties();
 
 	/**
 	 * Retrieve the current state of the natural-id properties from the database.
 	 *
 	 * @param id The identifier of the entity for which to retrieve the natural-id values.
 	 * @param session The session from which the request originated.
 	 * @return The natural-id snapshot.
 	 */
 	public Object[] getNaturalIdentifierSnapshot(Serializable id, SessionImplementor session);
 
 	/**
 	 * Determine which identifier generation strategy is used for this entity.
 	 *
 	 * @return The identifier generation strategy.
 	 */
 	public IdentifierGenerator getIdentifierGenerator();
 
 	/**
 	 * Determine whether this entity defines any lazy properties (ala
 	 * bytecode instrumentation).
 	 *
 	 * @return True if the entity has properties mapped as lazy; false otherwise.
 	 */
 	public boolean hasLazyProperties();
 
 	/**
 	 * Load an instance of the persistent class.
 	 */
 	public Object load(Serializable id, Object optionalObject, LockMode lockMode, SessionImplementor session)
 	throws HibernateException;
 
 	/**
 	 * Load an instance of the persistent class.
 	 */
 	public Object load(Serializable id, Object optionalObject, LockOptions lockOptions, SessionImplementor session)
 	throws HibernateException;
 
 	/**
 	 * Do a version check (optional operation)
 	 */
 	public void lock(Serializable id, Object version, Object object, LockMode lockMode, SessionImplementor session)
 	throws HibernateException;
 
 	/**
 	 * Do a version check (optional operation)
 	 */
 	public void lock(Serializable id, Object version, Object object, LockOptions lockOptions, SessionImplementor session)
 	throws HibernateException;
 
 	/**
 	 * Persist an instance
 	 */
 	public void insert(Serializable id, Object[] fields, Object object, SessionImplementor session)
 	throws HibernateException;
 
 	/**
 	 * Persist an instance, using a natively generated identifier (optional operation)
 	 */
 	public Serializable insert(Object[] fields, Object object, SessionImplementor session)
 	throws HibernateException;
 
 	/**
 	 * Delete a persistent instance
 	 */
 	public void delete(Serializable id, Object version, Object object, SessionImplementor session)
 	throws HibernateException;
 
 	/**
 	 * Update a persistent instance
 	 */
 	public void update(
 		Serializable id,
 		Object[] fields,
 		int[] dirtyFields,
 		boolean hasDirtyCollection,
 		Object[] oldFields,
 		Object oldVersion,
 		Object object,
 		Object rowId,
 		SessionImplementor session
 	) throws HibernateException;
 
 	/**
 	 * Get the Hibernate types of the class properties
 	 */
 	public Type[] getPropertyTypes();
 
 	/**
 	 * Get the names of the class properties - doesn't have to be the names of the
 	 * actual Java properties (used for XML generation only)
 	 */
 	public String[] getPropertyNames();
 
 	/**
 	 * Get the "insertability" of the properties of this class
 	 * (does the property appear in an SQL INSERT)
 	 */
 	public boolean[] getPropertyInsertability();
 
 	/**
 	 * Which of the properties of this class are database generated values on insert?
 	 */
 	public ValueInclusion[] getPropertyInsertGenerationInclusions();
 
 	/**
 	 * Which of the properties of this class are database generated values on update?
 	 */
 	public ValueInclusion[] getPropertyUpdateGenerationInclusions();
 
 	/**
 	 * Get the "updateability" of the properties of this class
 	 * (does the property appear in an SQL UPDATE)
 	 */
 	public boolean[] getPropertyUpdateability();
 
 	/**
 	 * Get the "checkability" of the properties of this class
 	 * (is the property dirty checked, does the cache need
 	 * to be updated)
 	 */
 	public boolean[] getPropertyCheckability();
 
 	/**
 	 * Get the nullability of the properties of this class
 	 */
 	public boolean[] getPropertyNullability();
 
 	/**
 	 * Get the "versionability" of the properties of this class
 	 * (is the property optimistic-locked)
 	 */
 	public boolean[] getPropertyVersionability();
 	public boolean[] getPropertyLaziness();
 	/**
 	 * Get the cascade styles of the properties (optional operation)
 	 */
 	public CascadeStyle[] getPropertyCascadeStyles();
 
 	/**
 	 * Get the identifier type
 	 */
 	public Type getIdentifierType();
 
 	/**
 	 * Get the name of the identifier property (or return null) - need not return the
 	 * name of an actual Java property
 	 */
 	public String getIdentifierPropertyName();
 
 	/**
 	 * Should we always invalidate the cache instead of
 	 * recaching updated state
 	 */
 	public boolean isCacheInvalidationRequired();
 	/**
 	 * Should lazy properties of this entity be cached?
 	 */
 	public boolean isLazyPropertiesCacheable();
 	/**
 	 * Does this class have a cache.
 	 */
 	public boolean hasCache();
 	/**
 	 * Get the cache (optional operation)
 	 */
 	public EntityRegionAccessStrategy getCacheAccessStrategy();
 	/**
 	 * Get the cache structure
 	 */
 	public CacheEntryStructure getCacheEntryStructure();
 
 	/**
 	 * Get the user-visible metadata for the class (optional operation)
 	 */
 	public ClassMetadata getClassMetadata();
 
 	/**
 	 * Is batch loading enabled?
 	 */
 	public boolean isBatchLoadable();
 
 	/**
 	 * Is select snapshot before update enabled?
 	 */
 	public boolean isSelectBeforeUpdateRequired();
 
 	/**
 	 * Get the current database state of the object, in a "hydrated" form, without
 	 * resolving identifiers
 	 * @return null if there is no row in the database
 	 */
 	public Object[] getDatabaseSnapshot(Serializable id, SessionImplementor session)
 	throws HibernateException;
 
 	/**
 	 * Get the current version of the object, or return null if there is no row for
 	 * the given identifier. In the case of unversioned data, return any object
 	 * if the row exists.
 	 */
 	public Object getCurrentVersion(Serializable id, SessionImplementor session)
 	throws HibernateException;
 
 	public Object forceVersionIncrement(Serializable id, Object currentVersion, SessionImplementor session)
 	throws HibernateException;
 
 	/**
 	 * Try to discover the entity mode from the entity instance
 	 */
 	public EntityMode guessEntityMode(Object object);
 
 	/**
 	 * Has the class actually been bytecode instrumented?
 	 */
 	public boolean isInstrumented(EntityMode entityMode);
 
 	/**
 	 * Does this entity define any properties as being database generated on insert?
 	 *
 	 * @return True if this entity contains at least one property defined
 	 * as generated (including version property, but not identifier).
 	 */
 	public boolean hasInsertGeneratedProperties();
 
 	/**
 	 * Does this entity define any properties as being database generated on update?
 	 *
 	 * @return True if this entity contains at least one property defined
 	 * as generated (including version property, but not identifier).
 	 */
 	public boolean hasUpdateGeneratedProperties();
 
 	/**
 	 * Does this entity contain a version property that is defined
 	 * to be database generated?
 	 *
 	 * @return true if this entity contains a version property and that
 	 * property has been marked as generated.
 	 */
 	public boolean isVersionPropertyGenerated();
 
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// stuff that is tuplizer-centric, but is passed a session ~~~~~~~~~~~~~~~~
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Called just after the entities properties have been initialized
 	 */
 	public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session);
 
 	/**
 	 * Called just after the entity has been reassociated with the session
 	 */
 	public void afterReassociate(Object entity, SessionImplementor session);
 
 	/**
 	 * Create a new proxy instance
 	 */
 	public Object createProxy(Serializable id, SessionImplementor session)
 	throws HibernateException;
 
 	/**
 	 * Is this a new transient instance?
 	 */
 	public Boolean isTransient(Object object, SessionImplementor session) throws HibernateException;
 
 	/**
 	 * Return the values of the insertable properties of the object (including backrefs)
 	 */
 	public Object[] getPropertyValuesToInsert(Object object, Map mergeMap, SessionImplementor session) throws HibernateException;
 
 	/**
 	 * Perform a select to retrieve the values of any generated properties
 	 * back from the database, injecting these generated values into the
 	 * given entity as well as writing this state to the
 	 * {@link org.hibernate.engine.PersistenceContext}.
 	 * <p/>
 	 * Note, that because we update the PersistenceContext here, callers
 	 * need to take care that they have already written the initial snapshot
 	 * to the PersistenceContext before calling this method.
 	 *
 	 * @param id The entity's id value.
 	 * @param entity The entity for which to get the state.
 	 * @param state
 	 * @param session The session
 	 */
 	public void processInsertGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session);
 	/**
 	 * Perform a select to retrieve the values of any generated properties
 	 * back from the database, injecting these generated values into the
 	 * given entity as well as writing this state to the
 	 * {@link org.hibernate.engine.PersistenceContext}.
 	 * <p/>
 	 * Note, that because we update the PersistenceContext here, callers
 	 * need to take care that they have already written the initial snapshot
 	 * to the PersistenceContext before calling this method.
 	 *
 	 * @param id The entity's id value.
 	 * @param entity The entity for which to get the state.
 	 * @param state
 	 * @param session The session
 	 */
 	public void processUpdateGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session);
 
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// stuff that is Tuplizer-centric ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * The persistent class, or null
 	 */
 	public Class getMappedClass(EntityMode entityMode);
 
 	/**
 	 * Does the class implement the <tt>Lifecycle</tt> interface.
 	 */
 	public boolean implementsLifecycle(EntityMode entityMode);
 
 	/**
-	 * Does the class implement the <tt>Validatable</tt> interface.
-	 */
-	public boolean implementsValidatable(EntityMode entityMode);
-	/**
 	 * Get the proxy interface that instances of <em>this</em> concrete class will be
 	 * cast to (optional operation).
 	 */
 	public Class getConcreteProxyClass(EntityMode entityMode);
 
 	/**
 	 * Set the given values to the mapped properties of the given object
 	 */
 	public void setPropertyValues(Object object, Object[] values, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Set the value of a particular property
 	 */
 	public void setPropertyValue(Object object, int i, Object value, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Return the (loaded) values of the mapped properties of the object (not including backrefs)
 	 */
 	public Object[] getPropertyValues(Object object, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Get the value of a particular property
 	 */
 	public Object getPropertyValue(Object object, int i, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Get the value of a particular property
 	 */
 	public Object getPropertyValue(Object object, String propertyName, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Get the identifier of an instance (throw an exception if no identifier property)
 	 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead
 	 * @noinspection JavaDoc
 	 */
 	public Serializable getIdentifier(Object object, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Get the identifier of an instance (throw an exception if no identifier property)
 	 *
 	 * @param entity The entity for which to get the identifier
 	 * @param session The session from which the request originated
 	 *
 	 * @return The identifier
 	 */
 	public Serializable getIdentifier(Object entity, SessionImplementor session);
 
     /**
      * Inject the identifier value into the given entity.
      * </p>
      * Has no effect if the entity does not define an identifier property
      *
      * @param entity The entity to inject with the identifier value.
      * @param id The value to be injected as the identifier.
 	 * @param entityMode The entity mode
 	 *
 	 * @deprecated Use {@link #setIdentifier(Object, Serializable, SessionImplementor)} instead.
 	 * @noinspection JavaDoc
      */
 	public void setIdentifier(Object entity, Serializable id, EntityMode entityMode) throws HibernateException;
 
     /**
      * Inject the identifier value into the given entity.
      *
      * @param entity The entity to inject with the identifier value.
      * @param id The value to be injected as the identifier.
 	 * @param session The session from which is requests originates
      */
 	public void setIdentifier(Object entity, Serializable id, SessionImplementor session);
 
 	/**
 	 * Get the version number (or timestamp) from the object's version property (or return null if not versioned)
 	 */
 	public Object getVersion(Object object, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Create a class instance initialized with the given identifier
 	 *
 	 * @deprecated Use {@link #instantiate(Serializable, SessionImplementor)} instead
 	 * @noinspection JavaDoc
 	 */
 	public Object instantiate(Serializable id, EntityMode entityMode) throws HibernateException;
 
 	/**
 	 * Create a class instance initialized with the given identifier
 	 *
 	 * @param id The identifier value to use (may be null to represent no value)
 	 * @param session The session from which the request originated.
 	 *
 	 * @return The instantiated entity.
 	 */
 	public Object instantiate(Serializable id, SessionImplementor session);
 
 	/**
 	 * Is the given object an instance of this entity?
 	 */
 	public boolean isInstance(Object object, EntityMode entityMode);
 
 	/**
 	 * Does the given instance have any uninitialized lazy properties?
 	 */
 	public boolean hasUninitializedLazyProperties(Object object, EntityMode entityMode);
 
 	/**
 	 * Set the identifier and version of the given instance back to its "unsaved" value.
 	 *
 	 * @param entity The entity instance
 	 * @param currentId The currently assigned identifier value.
 	 * @param currentVersion The currently assigned version value.
 	 * @param entityMode The entity mode represented by the entity instance.
 	 *
 	 * @deprecated Use {@link #resetIdentifier(Object, Serializable, Object, SessionImplementor)} instead
 	 */
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, EntityMode entityMode);
 
 	/**
 	 * Set the identifier and version of the given instance back to its "unsaved" value.
 	 *
 	 * @param entity The entity instance
 	 * @param currentId The currently assigned identifier value.
 	 * @param currentVersion The currently assigned version value.
 	 * @param session The session from which the request originated.
 	 */
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, SessionImplementor session);
 
 	/**
 	 * A request has already identified the entity-name of this persister as the mapping for the given instance.
 	 * However, we still need to account for possible subclassing and potentially re-route to the more appropriate
 	 * persister.
 	 * <p/>
 	 * For example, a request names <tt>Animal</tt> as the entity-name which gets resolved to this persister.  But the
 	 * actual instance is really an instance of <tt>Cat</tt> which is a subclass of <tt>Animal</tt>.  So, here the
 	 * <tt>Animal</tt> persister is being asked to return the persister specific to <tt>Cat</tt>.
 	 * <p/>
 	 * It is also possible that the instance is actually an <tt>Animal</tt> instance in the above example in which
 	 * case we would return <tt>this</tt> from this method.
 	 *
 	 * @param instance The entity instance
 	 * @param factory Reference to the SessionFactory
 	 * @param entityMode The entity mode represented by the entity instance.
 	 *
 	 * @return The appropriate persister
 	 *
 	 * @throws HibernateException Indicates that instance was deemed to not be a subclass of the entity mapped by
 	 * this persister.
 	 */
 	public EntityPersister getSubclassEntityPersister(Object instance, SessionFactoryImplementor factory, EntityMode entityMode);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java
index 882483f0a1..d0ee858115 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/AbstractEntityTuplizer.java
@@ -1,675 +1,671 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tuple.entity;
 import java.io.Serializable;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.HibernateLogger;
 import org.hibernate.MappingException;
 import org.hibernate.bytecode.instrumentation.spi.LazyPropertyInitializer;
 import org.hibernate.engine.EntityEntry;
 import org.hibernate.engine.EntityKey;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.event.EventSource;
 import org.hibernate.event.PersistEvent;
 import org.hibernate.id.Assigned;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.property.Getter;
 import org.hibernate.property.Setter;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.tuple.Instantiator;
 import org.hibernate.tuple.StandardProperty;
 import org.hibernate.tuple.VersionProperty;
 import org.hibernate.type.ComponentType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 
 
 /**
  * Support for tuplizers relating to entities.
  *
  * @author Steve Ebersole
  * @author Gavin King
  */
 public abstract class AbstractEntityTuplizer implements EntityTuplizer {
 
     private static final HibernateLogger LOG = Logger.getMessageLogger(HibernateLogger.class,
                                                                        AbstractEntityTuplizer.class.getName());
 
 	//TODO: currently keeps Getters and Setters (instead of PropertyAccessors) because of the way getGetter() and getSetter() are implemented currently; yuck!
 
 	private final EntityMetamodel entityMetamodel;
 
 	private final Getter idGetter;
 	private final Setter idSetter;
 
 	protected final Getter[] getters;
 	protected final Setter[] setters;
 	protected final int propertySpan;
 	protected final boolean hasCustomAccessors;
 	private final Instantiator instantiator;
 	private final ProxyFactory proxyFactory;
 	private final CompositeType identifierMapperType;
 
 	public Type getIdentifierMapperType() {
 		return identifierMapperType;
 	}
 
 	/**
 	 * Build an appropriate Getter for the given property.
 	 *
 	 * @param mappedProperty The property to be accessed via the built Getter.
 	 * @param mappedEntity The entity information regarding the mapped entity owning this property.
 	 * @return An appropriate Getter instance.
 	 */
 	protected abstract Getter buildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity);
 
 	/**
 	 * Build an appropriate Setter for the given property.
 	 *
 	 * @param mappedProperty The property to be accessed via the built Setter.
 	 * @param mappedEntity The entity information regarding the mapped entity owning this property.
 	 * @return An appropriate Setter instance.
 	 */
 	protected abstract Setter buildPropertySetter(Property mappedProperty, PersistentClass mappedEntity);
 
 	/**
 	 * Build an appropriate Instantiator for the given mapped entity.
 	 *
 	 * @param mappingInfo The mapping information regarding the mapped entity.
 	 * @return An appropriate Instantiator instance.
 	 */
 	protected abstract Instantiator buildInstantiator(PersistentClass mappingInfo);
 
 	/**
 	 * Build an appropriate ProxyFactory for the given mapped entity.
 	 *
 	 * @param mappingInfo The mapping information regarding the mapped entity.
 	 * @param idGetter The constructed Getter relating to the entity's id property.
 	 * @param idSetter The constructed Setter relating to the entity's id property.
 	 * @return An appropriate ProxyFactory instance.
 	 */
 	protected abstract ProxyFactory buildProxyFactory(PersistentClass mappingInfo, Getter idGetter, Setter idSetter);
 
 	/**
 	 * Constructs a new AbstractEntityTuplizer instance.
 	 *
 	 * @param entityMetamodel The "interpreted" information relating to the mapped entity.
 	 * @param mappingInfo The parsed "raw" mapping data relating to the given entity.
 	 */
 	public AbstractEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappingInfo) {
 		this.entityMetamodel = entityMetamodel;
 
 		if ( !entityMetamodel.getIdentifierProperty().isVirtual() ) {
 			idGetter = buildPropertyGetter( mappingInfo.getIdentifierProperty(), mappingInfo );
 			idSetter = buildPropertySetter( mappingInfo.getIdentifierProperty(), mappingInfo );
 		}
 		else {
 			idGetter = null;
 			idSetter = null;
 		}
 
 		propertySpan = entityMetamodel.getPropertySpan();
 
         getters = new Getter[propertySpan];
 		setters = new Setter[propertySpan];
 
 		Iterator itr = mappingInfo.getPropertyClosureIterator();
 		boolean foundCustomAccessor=false;
 		int i=0;
 		while ( itr.hasNext() ) {
 			//TODO: redesign how PropertyAccessors are acquired...
 			Property property = (Property) itr.next();
 			getters[i] = buildPropertyGetter(property, mappingInfo);
 			setters[i] = buildPropertySetter(property, mappingInfo);
 			if ( !property.isBasicPropertyAccessor() ) {
 				foundCustomAccessor = true;
 			}
 			i++;
 		}
 		hasCustomAccessors = foundCustomAccessor;
 
         instantiator = buildInstantiator( mappingInfo );
 
 		if ( entityMetamodel.isLazy() ) {
 			proxyFactory = buildProxyFactory( mappingInfo, idGetter, idSetter );
 			if (proxyFactory == null) {
 				entityMetamodel.setLazy( false );
 			}
 		}
 		else {
 			proxyFactory = null;
 		}
 
 		Component mapper = mappingInfo.getIdentifierMapper();
 		if ( mapper == null ) {
 			identifierMapperType = null;
 			mappedIdentifierValueMarshaller = null;
 		}
 		else {
 			identifierMapperType = (CompositeType) mapper.getType();
 			mappedIdentifierValueMarshaller = buildMappedIdentifierValueMarshaller(
 					(ComponentType) entityMetamodel.getIdentifierProperty().getType(),
 					(ComponentType) identifierMapperType
 			);
 		}
 	}
 
 	/** Retreives the defined entity-name for the tuplized entity.
 	 *
 	 * @return The entity-name.
 	 */
 	protected String getEntityName() {
 		return entityMetamodel.getName();
 	}
 
 	/**
 	 * Retrieves the defined entity-names for any subclasses defined for this
 	 * entity.
 	 *
 	 * @return Any subclass entity-names.
 	 */
 	protected Set getSubclassEntityNames() {
 		return entityMetamodel.getSubclassEntityNames();
 	}
 
 	public Serializable getIdentifier(Object entity) throws HibernateException {
 		return getIdentifier( entity, null );
 	}
 
 	public Serializable getIdentifier(Object entity, SessionImplementor session) {
 		final Object id;
 		if ( entityMetamodel.getIdentifierProperty().isEmbedded() ) {
 			id = entity;
 		}
 		else {
 			if ( idGetter == null ) {
 				if (identifierMapperType==null) {
 					throw new HibernateException( "The class has no identifier property: " + getEntityName() );
 				}
 				else {
 					id = mappedIdentifierValueMarshaller.getIdentifier( entity, getEntityMode(), session );
 				}
 			}
 			else {
                 id = idGetter.get( entity );
             }
         }
 
 		try {
 			return (Serializable) id;
 		}
 		catch ( ClassCastException cce ) {
 			StringBuffer msg = new StringBuffer( "Identifier classes must be serializable. " );
 			if ( id != null ) {
 				msg.append( id.getClass().getName() ).append( " is not serializable. " );
 			}
 			if ( cce.getMessage() != null ) {
 				msg.append( cce.getMessage() );
 			}
 			throw new ClassCastException( msg.toString() );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void setIdentifier(Object entity, Serializable id) throws HibernateException {
 		// 99% of the time the session is not needed.  Its only needed for certain brain-dead
 		// interpretations of JPA 2 "derived identity" support
 		setIdentifier( entity, id, null );
 	}
 
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void setIdentifier(Object entity, Serializable id, SessionImplementor session) {
 		if ( entityMetamodel.getIdentifierProperty().isEmbedded() ) {
 			if ( entity != id ) {
 				CompositeType copier = (CompositeType) entityMetamodel.getIdentifierProperty().getType();
 				copier.setPropertyValues( entity, copier.getPropertyValues( id, getEntityMode() ), getEntityMode() );
 			}
 		}
 		else if ( idSetter != null ) {
 			idSetter.set( entity, id, getFactory() );
 		}
 		else if ( identifierMapperType != null ) {
 			mappedIdentifierValueMarshaller.setIdentifier( entity, id, getEntityMode(), session );
 		}
 	}
 
 	private static interface MappedIdentifierValueMarshaller {
 		public Object getIdentifier(Object entity, EntityMode entityMode, SessionImplementor session);
 		public void setIdentifier(Object entity, Serializable id, EntityMode entityMode, SessionImplementor session);
 	}
 
 	private final MappedIdentifierValueMarshaller mappedIdentifierValueMarshaller;
 
 	private static MappedIdentifierValueMarshaller buildMappedIdentifierValueMarshaller(
 			ComponentType mappedIdClassComponentType,
 			ComponentType virtualIdComponent) {
 		// so basically at this point we know we have a "mapped" composite identifier
 		// which is an awful way to say that the identifier is represented differently
 		// in the entity and in the identifier value.  The incoming value should
 		// be an instance of the mapped identifier class (@IdClass) while the incoming entity
 		// should be an instance of the entity class as defined by metamodel.
 		//
 		// However, even within that we have 2 potential scenarios:
 		//		1) @IdClass types and entity @Id property types match
 		//			- return a NormalMappedIdentifierValueMarshaller
 		//		2) They do not match
 		//			- return a IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller
 		boolean wereAllEquivalent = true;
 		// the sizes being off is a much bigger problem that should have been caught already...
 		for ( int i = 0; i < virtualIdComponent.getSubtypes().length; i++ ) {
 			if ( virtualIdComponent.getSubtypes()[i].isEntityType()
 					&& ! mappedIdClassComponentType.getSubtypes()[i].isEntityType() ) {
 				wereAllEquivalent = false;
 				break;
 			}
 		}
 
 		return wereAllEquivalent
 				? (MappedIdentifierValueMarshaller) new NormalMappedIdentifierValueMarshaller( virtualIdComponent, mappedIdClassComponentType )
 				: (MappedIdentifierValueMarshaller) new IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller( virtualIdComponent, mappedIdClassComponentType );
 	}
 
 	private static class NormalMappedIdentifierValueMarshaller implements MappedIdentifierValueMarshaller {
 		private final ComponentType virtualIdComponent;
 		private final ComponentType mappedIdentifierType;
 
 		private NormalMappedIdentifierValueMarshaller(ComponentType virtualIdComponent, ComponentType mappedIdentifierType) {
 			this.virtualIdComponent = virtualIdComponent;
 			this.mappedIdentifierType = mappedIdentifierType;
 		}
 
 		public Object getIdentifier(Object entity, EntityMode entityMode, SessionImplementor session) {
 			Object id = mappedIdentifierType.instantiate( entityMode );
 			final Object[] propertyValues = virtualIdComponent.getPropertyValues( entity, entityMode );
 			mappedIdentifierType.setPropertyValues( id, propertyValues, entityMode );
 			return id;
 		}
 
 		public void setIdentifier(Object entity, Serializable id, EntityMode entityMode, SessionImplementor session) {
 			virtualIdComponent.setPropertyValues(
 					entity,
 					mappedIdentifierType.getPropertyValues( id, session ),
 					entityMode
 			);
 		}
 	}
 
 	private static class IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller implements MappedIdentifierValueMarshaller {
 		private final ComponentType virtualIdComponent;
 		private final ComponentType mappedIdentifierType;
 
 		private IncrediblySillyJpaMapsIdMappedIdentifierValueMarshaller(ComponentType virtualIdComponent, ComponentType mappedIdentifierType) {
 			this.virtualIdComponent = virtualIdComponent;
 			this.mappedIdentifierType = mappedIdentifierType;
 		}
 
 		public Object getIdentifier(Object entity, EntityMode entityMode, SessionImplementor session) {
 			final Object id = mappedIdentifierType.instantiate( entityMode );
 			final Object[] propertyValues = virtualIdComponent.getPropertyValues( entity, entityMode );
 			final Type[] subTypes = virtualIdComponent.getSubtypes();
 			final Type[] copierSubTypes = mappedIdentifierType.getSubtypes();
 			final int length = subTypes.length;
 			for ( int i = 0 ; i < length; i++ ) {
 				if ( propertyValues[i] == null ) {
 					throw new HibernateException( "No part of a composite identifier may be null" );
 				}
 				//JPA 2 @MapsId + @IdClass points to the pk of the entity
 				if ( subTypes[i].isAssociationType() && ! copierSubTypes[i].isAssociationType() ) {
 					// we need a session to handle this use case
 					if ( session == null ) {
 						throw new AssertionError(
 								"Deprecated version of getIdentifier (no session) was used but session was required"
 						);
 					}
 					final Object subId;
 					if ( HibernateProxy.class.isInstance( propertyValues[i] ) ) {
 						subId = ( (HibernateProxy) propertyValues[i] ).getHibernateLazyInitializer().getIdentifier();
 					}
 					else {
 						EntityEntry pcEntry = session.getPersistenceContext().getEntry( propertyValues[i] );
 						if ( pcEntry != null ) {
 							subId = pcEntry.getId();
 						}
 						else {
                             LOG.debugf("Performing implicit derived identity cascade");
 							final PersistEvent event = new PersistEvent( null, propertyValues[i], (EventSource) session );
 							for ( int x = 0; x < session.getListeners().getPersistEventListeners().length; x++ ) {
 								session.getListeners().getPersistEventListeners()[x].onPersist( event );
 
 							}
 							pcEntry = session.getPersistenceContext().getEntry( propertyValues[i] );
 							if ( pcEntry == null || pcEntry.getId() == null ) {
 								throw new HibernateException( "Unable to process implicit derived identity cascade" );
 							}
 							else {
 								subId = pcEntry.getId();
 							}
 						}
 					}
 					propertyValues[i] = subId;
 				}
 			}
 			mappedIdentifierType.setPropertyValues( id, propertyValues, entityMode );
 			return id;
 		}
 
 		public void setIdentifier(Object entity, Serializable id, EntityMode entityMode, SessionImplementor session) {
 			final Object[] extractedValues = mappedIdentifierType.getPropertyValues( id, entityMode );
 			final Object[] injectionValues = new Object[ extractedValues.length ];
 			for ( int i = 0; i < virtualIdComponent.getSubtypes().length; i++ ) {
 				final Type virtualPropertyType = virtualIdComponent.getSubtypes()[i];
 				final Type idClassPropertyType = mappedIdentifierType.getSubtypes()[i];
 				if ( virtualPropertyType.isEntityType() && ! idClassPropertyType.isEntityType() ) {
 					if ( session == null ) {
 						throw new AssertionError(
 								"Deprecated version of getIdentifier (no session) was used but session was required"
 						);
 					}
 					final String associatedEntityName = ( (EntityType) virtualPropertyType ).getAssociatedEntityName();
 					final EntityKey entityKey = new EntityKey(
 							(Serializable) extractedValues[i],
 							session.getFactory().getEntityPersister( associatedEntityName ),
 							entityMode
 					);
 					// it is conceivable there is a proxy, so check that first
 					Object association = session.getPersistenceContext().getProxy( entityKey );
 					if ( association == null ) {
 						// otherwise look for an initialized version
 						association = session.getPersistenceContext().getEntity( entityKey );
 					}
 					injectionValues[i] = association;
 				}
 				else {
 					injectionValues[i] = extractedValues[i];
 				}
 			}
 			virtualIdComponent.setPropertyValues( entity, injectionValues, session.getEntityMode() );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion) {
 		// 99% of the time the session is not needed.  Its only needed for certain brain-dead
 		// interpretations of JPA 2 "derived identity" support
 		resetIdentifier( entity, currentId, currentVersion, null );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void resetIdentifier(
 			Object entity,
 			Serializable currentId,
 			Object currentVersion,
 			SessionImplementor session) {
 		if ( entityMetamodel.getIdentifierProperty().getIdentifierGenerator() instanceof Assigned ) {
 		}
 		else {
 			//reset the id
 			Serializable result = entityMetamodel.getIdentifierProperty()
 					.getUnsavedValue()
 					.getDefaultValue( currentId );
 			setIdentifier( entity, result, session );
 			//reset the version
 			VersionProperty versionProperty = entityMetamodel.getVersionProperty();
 			if ( entityMetamodel.isVersioned() ) {
 				setPropertyValue(
 				        entity,
 				        entityMetamodel.getVersionPropertyIndex(),
 						versionProperty.getUnsavedValue().getDefaultValue( currentVersion )
 				);
 			}
 		}
 	}
 
 	public Object getVersion(Object entity) throws HibernateException {
 		if ( !entityMetamodel.isVersioned() ) return null;
 		return getters[ entityMetamodel.getVersionPropertyIndex() ].get( entity );
 	}
 
 	protected boolean shouldGetAllProperties(Object entity) {
 		return !hasUninitializedLazyProperties( entity );
 	}
 
 	public Object[] getPropertyValues(Object entity) throws HibernateException {
 		boolean getAll = shouldGetAllProperties( entity );
 		final int span = entityMetamodel.getPropertySpan();
 		final Object[] result = new Object[span];
 
 		for ( int j = 0; j < span; j++ ) {
 			StandardProperty property = entityMetamodel.getProperties()[j];
 			if ( getAll || !property.isLazy() ) {
 				result[j] = getters[j].get( entity );
 			}
 			else {
 				result[j] = LazyPropertyInitializer.UNFETCHED_PROPERTY;
 			}
 		}
 		return result;
 	}
 
 	public Object[] getPropertyValuesToInsert(Object entity, Map mergeMap, SessionImplementor session)
 	throws HibernateException {
 		final int span = entityMetamodel.getPropertySpan();
 		final Object[] result = new Object[span];
 
 		for ( int j = 0; j < span; j++ ) {
 			result[j] = getters[j].getForInsert( entity, mergeMap, session );
 		}
 		return result;
 	}
 
 	public Object getPropertyValue(Object entity, int i) throws HibernateException {
 		return getters[i].get( entity );
 	}
 
 	public Object getPropertyValue(Object entity, String propertyPath) throws HibernateException {
 		int loc = propertyPath.indexOf('.');
 		String basePropertyName = loc > 0
 				? propertyPath.substring( 0, loc )
 				: propertyPath;
 		//final int index = entityMetamodel.getPropertyIndexOrNull( basePropertyName );
 		Integer index = entityMetamodel.getPropertyIndexOrNull( basePropertyName );
 		if (index == null) {
 			propertyPath = "_identifierMapper." + propertyPath;
 			loc = propertyPath.indexOf('.');
 			basePropertyName = loc > 0
 				? propertyPath.substring( 0, loc )
 				: propertyPath;
 		}
 		index = entityMetamodel.getPropertyIndexOrNull( basePropertyName );
 		final Object baseValue = getPropertyValue( entity, index.intValue() );
 		if ( loc > 0 ) {
 			if ( baseValue == null ) {
 				return null;
 			}
 			return getComponentValue(
 					(ComponentType) entityMetamodel.getPropertyTypes()[index.intValue()],
 					baseValue,
 					propertyPath.substring(loc+1)
 			);
 		}
 		else {
 			return baseValue;
 		}
 	}
 
 	/**
 	 * Extract a component property value.
 	 *
 	 * @param type The component property types.
 	 * @param component The component instance itself.
 	 * @param propertyPath The property path for the property to be extracted.
 	 * @return The property value extracted.
 	 */
 	protected Object getComponentValue(ComponentType type, Object component, String propertyPath) {
 		final int loc = propertyPath.indexOf( '.' );
 		final String basePropertyName = loc > 0
 				? propertyPath.substring( 0, loc )
 				: propertyPath;
 		final int index = findSubPropertyIndex( type, basePropertyName );
 		final Object baseValue = type.getPropertyValue( component, index, getEntityMode() );
 		if ( loc > 0 ) {
 			if ( baseValue == null ) {
 				return null;
 			}
 			return getComponentValue(
 					(ComponentType) type.getSubtypes()[index],
 					baseValue,
 					propertyPath.substring(loc+1)
 			);
 		}
 		else {
 			return baseValue;
 		}
 
 	}
 
 	private int findSubPropertyIndex(ComponentType type, String subPropertyName) {
 		final String[] propertyNames = type.getPropertyNames();
 		for ( int index = 0; index<propertyNames.length; index++ ) {
 			if ( subPropertyName.equals( propertyNames[index] ) ) {
 				return index;
 			}
 		}
 		throw new MappingException( "component property not found: " + subPropertyName );
 	}
 
 	public void setPropertyValues(Object entity, Object[] values) throws HibernateException {
 		boolean setAll = !entityMetamodel.hasLazyProperties();
 
 		for ( int j = 0; j < entityMetamodel.getPropertySpan(); j++ ) {
 			if ( setAll || values[j] != LazyPropertyInitializer.UNFETCHED_PROPERTY ) {
 				setters[j].set( entity, values[j], getFactory() );
 			}
 		}
 	}
 
 	public void setPropertyValue(Object entity, int i, Object value) throws HibernateException {
 		setters[i].set( entity, value, getFactory() );
 	}
 
 	public void setPropertyValue(Object entity, String propertyName, Object value) throws HibernateException {
 		setters[ entityMetamodel.getPropertyIndex( propertyName ) ].set( entity, value, getFactory() );
 	}
 
 	public final Object instantiate(Serializable id) throws HibernateException {
 		// 99% of the time the session is not needed.  Its only needed for certain brain-dead
 		// interpretations of JPA 2 "derived identity" support
 		return instantiate( id, null );
 	}
 
 	public final Object instantiate(Serializable id, SessionImplementor session) {
 		Object result = getInstantiator().instantiate( id );
 		if ( id != null ) {
 			setIdentifier( result, id, session );
 		}
 		return result;
 	}
 
 	public final Object instantiate() throws HibernateException {
 		return instantiate( null, null );
 	}
 
 	public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session) {}
 
 	public boolean hasUninitializedLazyProperties(Object entity) {
 		// the default is to simply not lazy fetch properties for now...
 		return false;
 	}
 
 	public final boolean isInstance(Object object) {
         return getInstantiator().isInstance( object );
 	}
 
 	public boolean hasProxy() {
 		return entityMetamodel.isLazy();
 	}
 
 	public final Object createProxy(Serializable id, SessionImplementor session)
 	throws HibernateException {
 		return getProxyFactory().getProxy( id, session );
 	}
 
 	public boolean isLifecycleImplementor() {
 		return false;
 	}
 
-	public boolean isValidatableImplementor() {
-		return false;
-	}
-
 	protected final EntityMetamodel getEntityMetamodel() {
 		return entityMetamodel;
 	}
 
 	protected final SessionFactoryImplementor getFactory() {
 		return entityMetamodel.getSessionFactory();
 	}
 
 	protected final Instantiator getInstantiator() {
 		return instantiator;
 	}
 
 	protected final ProxyFactory getProxyFactory() {
 		return proxyFactory;
 	}
 
 	@Override
     public String toString() {
 		return getClass().getName() + '(' + getEntityMetamodel().getName() + ')';
 	}
 
 	public Getter getIdentifierGetter() {
 		return idGetter;
 	}
 
 	public Getter getVersionGetter() {
 		if ( getEntityMetamodel().isVersioned() ) {
 			return getGetter( getEntityMetamodel().getVersionPropertyIndex() );
 		}
 		return null;
 	}
 
 	public Getter getGetter(int i) {
 		return getters[i];
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizer.java
index ef732c3638..6b6290d32c 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizer.java
@@ -1,308 +1,300 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Middleware LLC.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ *
+ */
 package org.hibernate.tuple.entity;
-import java.io.Serializable;
-import java.util.Map;
-import org.hibernate.EntityMode;
-import org.hibernate.EntityNameResolver;
-import org.hibernate.HibernateException;
-import org.hibernate.engine.SessionFactoryImplementor;
-import org.hibernate.engine.SessionImplementor;
-import org.hibernate.property.Getter;
-import org.hibernate.tuple.Tuplizer;
-
-/**
- * Defines further responsibilities reagarding tuplization based on
- * a mapped entity.
- * <p/>
- * EntityTuplizer implementations should have the following constructor signature:
- *      (org.hibernate.tuple.entity.EntityMetamodel, org.hibernate.mapping.PersistentClass)
- *
- * @author Gavin King
- * @author Steve Ebersole
- */
-public interface EntityTuplizer extends Tuplizer {
-	/**
-	 * Return the entity-mode handled by this tuplizer instance.
-	 *
-	 * @return The entity-mode
-	 */
-	public EntityMode getEntityMode();
-
-    /**
-     * Create an entity instance initialized with the given identifier.
-     *
-     * @param id The identifier value for the entity to be instantiated.
-     * @return The instantiated entity.
-     * @throws HibernateException
-	 *
-	 * @deprecated Use {@link #instantiate(Serializable, SessionImplementor)} instead.
-	 * @noinspection JavaDoc
-     */
-	public Object instantiate(Serializable id) throws HibernateException;
-
-    /**
-     * Create an entity instance initialized with the given identifier.
-     *
-     * @param id The identifier value for the entity to be instantiated.
-	 * @param session The session from which is requests originates
-	 *
-     * @return The instantiated entity.
-     */
-	public Object instantiate(Serializable id, SessionImplementor session);
-
-    /**
-     * Extract the identifier value from the given entity.
-     *
-     * @param entity The entity from which to extract the identifier value.
-	 *
-     * @return The identifier value.
-	 *
-     * @throws HibernateException If the entity does not define an identifier property, or an
-     * error occurs accessing its value.
-	 *
-	 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
-     */
-	public Serializable getIdentifier(Object entity) throws HibernateException;
-
-    /**
-     * Extract the identifier value from the given entity.
-     *
-     * @param entity The entity from which to extract the identifier value.
-	 * @param session The session from which is requests originates
-	 *
-     * @return The identifier value.
-     */
-	public Serializable getIdentifier(Object entity, SessionImplementor session);
-
-    /**
-     * Inject the identifier value into the given entity.
-     * </p>
-     * Has no effect if the entity does not define an identifier property
-     *
-     * @param entity The entity to inject with the identifier value.
-     * @param id The value to be injected as the identifier.
-	 *
-	 * @deprecated Use {@link #setIdentifier(Object, Serializable, SessionImplementor)} instead.
-	 * @noinspection JavaDoc
-     */
-	public void setIdentifier(Object entity, Serializable id) throws HibernateException;
-
-    /**
-     * Inject the identifier value into the given entity.
-     * </p>
-     * Has no effect if the entity does not define an identifier property
-     *
-     * @param entity The entity to inject with the identifier value.
-     * @param id The value to be injected as the identifier.
-	 * @param session The session from which is requests originates
-     */
-	public void setIdentifier(Object entity, Serializable id, SessionImplementor session);
-
-	/**
-	 * Inject the given identifier and version into the entity, in order to
-	 * "roll back" to their original values.
-	 *
-	 * @param entity The entity for which to reset the id/version values
-	 * @param currentId The identifier value to inject into the entity.
-	 * @param currentVersion The version value to inject into the entity.
-	 *
-	 * @deprecated Use {@link #resetIdentifier(Object, Serializable, Object, SessionImplementor)} instead
-	 */
-	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion);
-
-	/**
-	 * Inject the given identifier and version into the entity, in order to
-	 * "roll back" to their original values.
-	 *
-	 * @param entity The entity for which to reset the id/version values
-	 * @param currentId The identifier value to inject into the entity.
-	 * @param currentVersion The version value to inject into the entity.
-	 * @param session The session from which the request originated
-	 */
-	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, SessionImplementor session);
-
-    /**
-     * Extract the value of the version property from the given entity.
-     *
-     * @param entity The entity from which to extract the version value.
-     * @return The value of the version property, or null if not versioned.
-     * @throws HibernateException
-     */
-	public Object getVersion(Object entity) throws HibernateException;
-
-	/**
-	 * Inject the value of a particular property.
-	 *
-	 * @param entity The entity into which to inject the value.
-	 * @param i The property's index.
-	 * @param value The property value to inject.
-	 * @throws HibernateException
-	 */
-	public void setPropertyValue(Object entity, int i, Object value) throws HibernateException;
-
-	/**
-	 * Inject the value of a particular property.
-	 *
-	 * @param entity The entity into which to inject the value.
-	 * @param propertyName The name of the property.
-	 * @param value The property value to inject.
-	 * @throws HibernateException
-	 */
-	public void setPropertyValue(Object entity, String propertyName, Object value) throws HibernateException;
-
-	/**
-	 * Extract the values of the insertable properties of the entity (including backrefs)
-	 *
-	 * @param entity The entity from which to extract.
-	 * @param mergeMap a map of instances being merged to merged instances
-	 * @param session The session in which the resuest is being made.
-	 * @return The insertable property values.
-	 * @throws HibernateException
-	 */
-	public Object[] getPropertyValuesToInsert(Object entity, Map mergeMap, SessionImplementor session)
-	throws HibernateException;
-
-	/**
-	 * Extract the value of a particular property from the given entity.
-	 *
-	 * @param entity The entity from which to extract the property value.
-	 * @param propertyName The name of the property for which to extract the value.
-	 * @return The current value of the given property on the given entity.
-	 * @throws HibernateException
-	 */
-	public Object getPropertyValue(Object entity, String propertyName) throws HibernateException;
-
-    /**
-     * Called just after the entities properties have been initialized.
-     *
-     * @param entity The entity being initialized.
-     * @param lazyPropertiesAreUnfetched Are defined lazy properties currently unfecthed
-     * @param session The session initializing this entity.
-     */
-	public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session);
-
-	/**
-	 * Does this entity, for this mode, present a possibility for proxying?
-	 *
-	 * @return True if this tuplizer can generate proxies for this entity.
-	 */
-	public boolean hasProxy();
-
-	/**
-	 * Generates an appropriate proxy representation of this entity for this
-	 * entity-mode.
-	 *
-	 * @param id The id of the instance for which to generate a proxy.
-	 * @param session The session to which the proxy should be bound.
-	 * @return The generate proxies.
-	 * @throws HibernateException Indicates an error generating the proxy.
-	 */
-	public Object createProxy(Serializable id, SessionImplementor session) throws HibernateException;
-
-	/**
-	 * Does the {@link #getMappedClass() class} managed by this tuplizer implement
-	 * the {@link org.hibernate.classic.Lifecycle} interface.
-	 *
-	 * @return True if the Lifecycle interface is implemented; false otherwise.
-	 */
-	public boolean isLifecycleImplementor();
-
-	/**
-	 * Does the {@link #getMappedClass() class} managed by this tuplizer implement
-	 * the {@link org.hibernate.classic.Validatable} interface.
-	 *
-	 * @return True if the Validatable interface is implemented; false otherwise.
-	 */
-	public boolean isValidatableImplementor();
-
-	/**
-	 * Returns the java class to which generated proxies will be typed.
-	 * <p/>
-	 * todo : look at fully encapsulating {@link org.hibernate.engine.PersistenceContext#narrowProxy} here,
-	 * since that is the only external use of this method
-	 *
-	 * @return The java class to which generated proxies will be typed
-	 */
-	public Class getConcreteProxyClass();
-	
-    /**
-     * Does the given entity instance have any currently uninitialized lazy properties?
-     *
-     * @param entity The entity to be check for uninitialized lazy properties.
-     * @return True if uninitialized lazy properties were found; false otherwise.
-     */
-	public boolean hasUninitializedLazyProperties(Object entity);
-	
-	/**
-	 * Is it an instrumented POJO?
-	 */
-	public boolean isInstrumented();
-
-	/**
-	 * Get any {@link EntityNameResolver EntityNameResolvers} associated with this {@link Tuplizer}.
-	 *
-	 * @return The associated resolvers.  May be null or empty.
-	 */
-	public EntityNameResolver[] getEntityNameResolvers();
-
-	/**
-	 * Given an entity instance, determine the most appropriate (most targeted) entity-name which represents it.
-	 * This is called in situations where we already know an entity name for the given entityInstance; we are being
-	 * asked to determine if there is a more appropriate entity-name to use, specifically within an inheritence
-	 * hierarchy.
-	 * <p/>
-	 * For example, consider a case where a user calls <tt>session.update( "Animal", cat );</tt>.  Here, the
-	 * user has explicitly provided <tt>Animal</tt> as the entity-name.  However, they have passed in an instance
-	 * of <tt>Cat</tt> which is a subclass of <tt>Animal</tt>.  In this case, we would return <tt>Cat</tt> as the
-	 * entity-name.
-	 * <p/>
-	 * <tt>null</tt> may be returned from calls to this method.  The meaining of <tt>null</tt> in that case is assumed
-	 * to be that we should use whatever explicit entity-name the user provided (<tt>Animal</tt> rather than <tt>Cat</tt>
-	 * in the example above).
-	 *
-	 * @param entityInstance The entity instance.
-	 * @param factory Reference to the SessionFactory.
-	 *
-	 * @return The most appropriate entity name to use.
-	 *
-	 * @throws HibernateException If we are unable to determine an entity-name within the inheritence hierarchy.
-	 */
-	public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory);
-
-	/**
-	 * Retrieve the getter for the identifier property.  May return null.
-	 *
-	 * @return The getter for the identifier property.
-	 */
-	public Getter getIdentifierGetter();
-
-	/**
-	 * Retrieve the getter for the version property.  May return null.
-	 *
-	 * @return The getter for the version property.
-	 */
-	public Getter getVersionGetter();
+import java.io.Serializable;
+import java.util.Map;
+import org.hibernate.EntityMode;
+import org.hibernate.EntityNameResolver;
+import org.hibernate.HibernateException;
+import org.hibernate.engine.SessionFactoryImplementor;
+import org.hibernate.engine.SessionImplementor;
+import org.hibernate.property.Getter;
+import org.hibernate.tuple.Tuplizer;
+
+/**
+ * Defines further responsibilities reagarding tuplization based on
+ * a mapped entity.
+ * <p/>
+ * EntityTuplizer implementations should have the following constructor signature:
+ *      (org.hibernate.tuple.entity.EntityMetamodel, org.hibernate.mapping.PersistentClass)
+ *
+ * @author Gavin King
+ * @author Steve Ebersole
+ */
+public interface EntityTuplizer extends Tuplizer {
+	/**
+	 * Return the entity-mode handled by this tuplizer instance.
+	 *
+	 * @return The entity-mode
+	 */
+	public EntityMode getEntityMode();
+
+    /**
+     * Create an entity instance initialized with the given identifier.
+     *
+     * @param id The identifier value for the entity to be instantiated.
+     * @return The instantiated entity.
+     * @throws HibernateException
+	 *
+	 * @deprecated Use {@link #instantiate(Serializable, SessionImplementor)} instead.
+	 * @noinspection JavaDoc
+     */
+	public Object instantiate(Serializable id) throws HibernateException;
+
+    /**
+     * Create an entity instance initialized with the given identifier.
+     *
+     * @param id The identifier value for the entity to be instantiated.
+	 * @param session The session from which is requests originates
+	 *
+     * @return The instantiated entity.
+     */
+	public Object instantiate(Serializable id, SessionImplementor session);
+
+    /**
+     * Extract the identifier value from the given entity.
+     *
+     * @param entity The entity from which to extract the identifier value.
+	 *
+     * @return The identifier value.
+	 *
+     * @throws HibernateException If the entity does not define an identifier property, or an
+     * error occurs accessing its value.
+	 *
+	 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
+     */
+	public Serializable getIdentifier(Object entity) throws HibernateException;
+
+    /**
+     * Extract the identifier value from the given entity.
+     *
+     * @param entity The entity from which to extract the identifier value.
+	 * @param session The session from which is requests originates
+	 *
+     * @return The identifier value.
+     */
+	public Serializable getIdentifier(Object entity, SessionImplementor session);
+
+    /**
+     * Inject the identifier value into the given entity.
+     * </p>
+     * Has no effect if the entity does not define an identifier property
+     *
+     * @param entity The entity to inject with the identifier value.
+     * @param id The value to be injected as the identifier.
+	 *
+	 * @deprecated Use {@link #setIdentifier(Object, Serializable, SessionImplementor)} instead.
+	 * @noinspection JavaDoc
+     */
+	public void setIdentifier(Object entity, Serializable id) throws HibernateException;
+
+    /**
+     * Inject the identifier value into the given entity.
+     * </p>
+     * Has no effect if the entity does not define an identifier property
+     *
+     * @param entity The entity to inject with the identifier value.
+     * @param id The value to be injected as the identifier.
+	 * @param session The session from which is requests originates
+     */
+	public void setIdentifier(Object entity, Serializable id, SessionImplementor session);
+
+	/**
+	 * Inject the given identifier and version into the entity, in order to
+	 * "roll back" to their original values.
+	 *
+	 * @param entity The entity for which to reset the id/version values
+	 * @param currentId The identifier value to inject into the entity.
+	 * @param currentVersion The version value to inject into the entity.
+	 *
+	 * @deprecated Use {@link #resetIdentifier(Object, Serializable, Object, SessionImplementor)} instead
+	 */
+	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion);
+
+	/**
+	 * Inject the given identifier and version into the entity, in order to
+	 * "roll back" to their original values.
+	 *
+	 * @param entity The entity for which to reset the id/version values
+	 * @param currentId The identifier value to inject into the entity.
+	 * @param currentVersion The version value to inject into the entity.
+	 * @param session The session from which the request originated
+	 */
+	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, SessionImplementor session);
+
+    /**
+     * Extract the value of the version property from the given entity.
+     *
+     * @param entity The entity from which to extract the version value.
+     * @return The value of the version property, or null if not versioned.
+     * @throws HibernateException
+     */
+	public Object getVersion(Object entity) throws HibernateException;
+
+	/**
+	 * Inject the value of a particular property.
+	 *
+	 * @param entity The entity into which to inject the value.
+	 * @param i The property's index.
+	 * @param value The property value to inject.
+	 * @throws HibernateException
+	 */
+	public void setPropertyValue(Object entity, int i, Object value) throws HibernateException;
+
+	/**
+	 * Inject the value of a particular property.
+	 *
+	 * @param entity The entity into which to inject the value.
+	 * @param propertyName The name of the property.
+	 * @param value The property value to inject.
+	 * @throws HibernateException
+	 */
+	public void setPropertyValue(Object entity, String propertyName, Object value) throws HibernateException;
+
+	/**
+	 * Extract the values of the insertable properties of the entity (including backrefs)
+	 *
+	 * @param entity The entity from which to extract.
+	 * @param mergeMap a map of instances being merged to merged instances
+	 * @param session The session in which the resuest is being made.
+	 * @return The insertable property values.
+	 * @throws HibernateException
+	 */
+	public Object[] getPropertyValuesToInsert(Object entity, Map mergeMap, SessionImplementor session)
+	throws HibernateException;
+
+	/**
+	 * Extract the value of a particular property from the given entity.
+	 *
+	 * @param entity The entity from which to extract the property value.
+	 * @param propertyName The name of the property for which to extract the value.
+	 * @return The current value of the given property on the given entity.
+	 * @throws HibernateException
+	 */
+	public Object getPropertyValue(Object entity, String propertyName) throws HibernateException;
+
+    /**
+     * Called just after the entities properties have been initialized.
+     *
+     * @param entity The entity being initialized.
+     * @param lazyPropertiesAreUnfetched Are defined lazy properties currently unfecthed
+     * @param session The session initializing this entity.
+     */
+	public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session);
+
+	/**
+	 * Does this entity, for this mode, present a possibility for proxying?
+	 *
+	 * @return True if this tuplizer can generate proxies for this entity.
+	 */
+	public boolean hasProxy();
+
+	/**
+	 * Generates an appropriate proxy representation of this entity for this
+	 * entity-mode.
+	 *
+	 * @param id The id of the instance for which to generate a proxy.
+	 * @param session The session to which the proxy should be bound.
+	 * @return The generate proxies.
+	 * @throws HibernateException Indicates an error generating the proxy.
+	 */
+	public Object createProxy(Serializable id, SessionImplementor session) throws HibernateException;
+
+	/**
+	 * Does the {@link #getMappedClass() class} managed by this tuplizer implement
+	 * the {@link org.hibernate.classic.Lifecycle} interface.
+	 *
+	 * @return True if the Lifecycle interface is implemented; false otherwise.
+	 */
+	public boolean isLifecycleImplementor();
+
+	/**
+	 * Returns the java class to which generated proxies will be typed.
+	 * <p/>
+	 * todo : look at fully encapsulating {@link org.hibernate.engine.PersistenceContext#narrowProxy} here,
+	 * since that is the only external use of this method
+	 *
+	 * @return The java class to which generated proxies will be typed
+	 */
+	public Class getConcreteProxyClass();
+	
+    /**
+     * Does the given entity instance have any currently uninitialized lazy properties?
+     *
+     * @param entity The entity to be check for uninitialized lazy properties.
+     * @return True if uninitialized lazy properties were found; false otherwise.
+     */
+	public boolean hasUninitializedLazyProperties(Object entity);
+	
+	/**
+	 * Is it an instrumented POJO?
+	 */
+	public boolean isInstrumented();
+
+	/**
+	 * Get any {@link EntityNameResolver EntityNameResolvers} associated with this {@link Tuplizer}.
+	 *
+	 * @return The associated resolvers.  May be null or empty.
+	 */
+	public EntityNameResolver[] getEntityNameResolvers();
+
+	/**
+	 * Given an entity instance, determine the most appropriate (most targeted) entity-name which represents it.
+	 * This is called in situations where we already know an entity name for the given entityInstance; we are being
+	 * asked to determine if there is a more appropriate entity-name to use, specifically within an inheritence
+	 * hierarchy.
+	 * <p/>
+	 * For example, consider a case where a user calls <tt>session.update( "Animal", cat );</tt>.  Here, the
+	 * user has explicitly provided <tt>Animal</tt> as the entity-name.  However, they have passed in an instance
+	 * of <tt>Cat</tt> which is a subclass of <tt>Animal</tt>.  In this case, we would return <tt>Cat</tt> as the
+	 * entity-name.
+	 * <p/>
+	 * <tt>null</tt> may be returned from calls to this method.  The meaining of <tt>null</tt> in that case is assumed
+	 * to be that we should use whatever explicit entity-name the user provided (<tt>Animal</tt> rather than <tt>Cat</tt>
+	 * in the example above).
+	 *
+	 * @param entityInstance The entity instance.
+	 * @param factory Reference to the SessionFactory.
+	 *
+	 * @return The most appropriate entity name to use.
+	 *
+	 * @throws HibernateException If we are unable to determine an entity-name within the inheritence hierarchy.
+	 */
+	public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory);
+
+	/**
+	 * Retrieve the getter for the identifier property.  May return null.
+	 *
+	 * @return The getter for the identifier property.
+	 */
+	public Getter getIdentifierGetter();
+
+	/**
+	 * Retrieve the getter for the version property.  May return null.
+	 *
+	 * @return The getter for the version property.
+	 */
+	public Getter getVersionGetter();
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java
index 1114a585b7..3b45990f5e 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java
@@ -1,379 +1,370 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tuple.entity;
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
+
+import org.jboss.logging.Logger;
+
 import org.hibernate.EntityMode;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.HibernateException;
 import org.hibernate.HibernateLogger;
 import org.hibernate.MappingException;
+import org.hibernate.bytecode.instrumentation.internal.FieldInterceptionHelper;
+import org.hibernate.bytecode.instrumentation.spi.FieldInterceptor;
 import org.hibernate.bytecode.spi.ReflectionOptimizer;
 import org.hibernate.cfg.Environment;
 import org.hibernate.classic.Lifecycle;
-import org.hibernate.classic.Validatable;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.SessionImplementor;
-import org.hibernate.bytecode.instrumentation.internal.FieldInterceptionHelper;
-import org.hibernate.bytecode.instrumentation.spi.FieldInterceptor;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Subclass;
 import org.hibernate.property.Getter;
 import org.hibernate.property.Setter;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.tuple.Instantiator;
 import org.hibernate.tuple.PojoInstantiator;
 import org.hibernate.type.CompositeType;
-import org.jboss.logging.Logger;
 
 /**
  * An {@link EntityTuplizer} specific to the pojo entity mode.
  *
  * @author Steve Ebersole
  * @author Gavin King
  */
 public class PojoEntityTuplizer extends AbstractEntityTuplizer {
 
     private static final HibernateLogger LOG = Logger.getMessageLogger(HibernateLogger.class, PojoEntityTuplizer.class.getName());
 
 	private final Class mappedClass;
 	private final Class proxyInterface;
 	private final boolean lifecycleImplementor;
-	private final boolean validatableImplementor;
 	private final Set lazyPropertyNames = new HashSet();
 	private final ReflectionOptimizer optimizer;
 
 	public PojoEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
 		super( entityMetamodel, mappedEntity );
 		this.mappedClass = mappedEntity.getMappedClass();
 		this.proxyInterface = mappedEntity.getProxyInterface();
 		this.lifecycleImplementor = Lifecycle.class.isAssignableFrom( mappedClass );
-		this.validatableImplementor = Validatable.class.isAssignableFrom( mappedClass );
 
 		Iterator iter = mappedEntity.getPropertyClosureIterator();
 		while ( iter.hasNext() ) {
 			Property property = (Property) iter.next();
 			if ( property.isLazy() ) {
 				lazyPropertyNames.add( property.getName() );
 			}
 		}
 
 		String[] getterNames = new String[propertySpan];
 		String[] setterNames = new String[propertySpan];
 		Class[] propTypes = new Class[propertySpan];
 		for ( int i = 0; i < propertySpan; i++ ) {
 			getterNames[i] = getters[i].getMethodName();
 			setterNames[i] = setters[i].getMethodName();
 			propTypes[i] = getters[i].getReturnType();
 		}
 
 		if ( hasCustomAccessors || !Environment.useReflectionOptimizer() ) {
 			optimizer = null;
 		}
 		else {
 			// todo : YUCK!!!
 			optimizer = Environment.getBytecodeProvider().getReflectionOptimizer( mappedClass, getterNames, setterNames, propTypes );
 //			optimizer = getFactory().getSettings().getBytecodeProvider().getReflectionOptimizer(
 //					mappedClass, getterNames, setterNames, propTypes
 //			);
 		}
 
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     protected ProxyFactory buildProxyFactory(PersistentClass persistentClass, Getter idGetter, Setter idSetter) {
 		// determine the id getter and setter methods from the proxy interface (if any)
         // determine all interfaces needed by the resulting proxy
 		HashSet<Class> proxyInterfaces = new HashSet<Class>();
 		proxyInterfaces.add( HibernateProxy.class );
 
 		Class mappedClass = persistentClass.getMappedClass();
 		Class proxyInterface = persistentClass.getProxyInterface();
 
 		if ( proxyInterface!=null && !mappedClass.equals( proxyInterface ) ) {
 			if ( !proxyInterface.isInterface() ) {
 				throw new MappingException(
 						"proxy must be either an interface, or the class itself: " + getEntityName()
 				);
 			}
 			proxyInterfaces.add( proxyInterface );
 		}
 
 		if ( mappedClass.isInterface() ) {
 			proxyInterfaces.add( mappedClass );
 		}
 
 		Iterator subclasses = persistentClass.getSubclassIterator();
 		while ( subclasses.hasNext() ) {
 			final Subclass subclass = ( Subclass ) subclasses.next();
 			final Class subclassProxy = subclass.getProxyInterface();
 			final Class subclassClass = subclass.getMappedClass();
 			if ( subclassProxy!=null && !subclassClass.equals( subclassProxy ) ) {
 				if ( !subclassProxy.isInterface() ) {
 					throw new MappingException(
 							"proxy must be either an interface, or the class itself: " + subclass.getEntityName()
 					);
 				}
 				proxyInterfaces.add( subclassProxy );
 			}
 		}
 
 		Iterator properties = persistentClass.getPropertyIterator();
 		Class clazz = persistentClass.getMappedClass();
 		while ( properties.hasNext() ) {
 			Property property = (Property) properties.next();
 			Method method = property.getGetter(clazz).getMethod();
 			if ( method != null && Modifier.isFinal( method.getModifiers() ) ) {
                 LOG.gettersOfLazyClassesCannotBeFinal(persistentClass.getEntityName(), property.getName());
 			}
 			method = property.getSetter(clazz).getMethod();
             if ( method != null && Modifier.isFinal( method.getModifiers() ) ) {
                 LOG.settersOfLazyClassesCannotBeFinal(persistentClass.getEntityName(), property.getName());
 			}
 		}
 
 		Method idGetterMethod = idGetter==null ? null : idGetter.getMethod();
 		Method idSetterMethod = idSetter==null ? null : idSetter.getMethod();
 
 		Method proxyGetIdentifierMethod = idGetterMethod==null || proxyInterface==null ?
 				null :
 		        ReflectHelper.getMethod(proxyInterface, idGetterMethod);
 		Method proxySetIdentifierMethod = idSetterMethod==null || proxyInterface==null  ?
 				null :
 		        ReflectHelper.getMethod(proxyInterface, idSetterMethod);
 
 		ProxyFactory pf = buildProxyFactoryInternal( persistentClass, idGetter, idSetter );
 		try {
 			pf.postInstantiate(
 					getEntityName(),
 					mappedClass,
 					proxyInterfaces,
 					proxyGetIdentifierMethod,
 					proxySetIdentifierMethod,
 					persistentClass.hasEmbeddedIdentifier() ?
 			                (CompositeType) persistentClass.getIdentifier().getType() :
 			                null
 			);
 		}
 		catch ( HibernateException he ) {
             LOG.unableToCreateProxyFactory(getEntityName(), he);
 			pf = null;
 		}
 		return pf;
 	}
 
 	protected ProxyFactory buildProxyFactoryInternal(PersistentClass persistentClass, Getter idGetter, Setter idSetter) {
 		// TODO : YUCK!!!  fix after HHH-1907 is complete
 		return Environment.getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();
 //		return getFactory().getSettings().getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     protected Instantiator buildInstantiator(PersistentClass persistentClass) {
 		if ( optimizer == null ) {
 			return new PojoInstantiator( persistentClass, null );
 		}
 		else {
 			return new PojoInstantiator( persistentClass, optimizer.getInstantiationOptimizer() );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public void setPropertyValues(Object entity, Object[] values) throws HibernateException {
 		if ( !getEntityMetamodel().hasLazyProperties() && optimizer != null && optimizer.getAccessOptimizer() != null ) {
 			setPropertyValuesWithOptimizer( entity, values );
 		}
 		else {
 			super.setPropertyValues( entity, values );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public Object[] getPropertyValues(Object entity) throws HibernateException {
 		if ( shouldGetAllProperties( entity ) && optimizer != null && optimizer.getAccessOptimizer() != null ) {
 			return getPropertyValuesWithOptimizer( entity );
 		}
 		else {
 			return super.getPropertyValues( entity );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public Object[] getPropertyValuesToInsert(Object entity, Map mergeMap, SessionImplementor session) throws HibernateException {
 		if ( shouldGetAllProperties( entity ) && optimizer != null && optimizer.getAccessOptimizer() != null ) {
 			return getPropertyValuesWithOptimizer( entity );
 		}
 		else {
 			return super.getPropertyValuesToInsert( entity, mergeMap, session );
 		}
 	}
 
 	protected void setPropertyValuesWithOptimizer(Object object, Object[] values) {
 		optimizer.getAccessOptimizer().setPropertyValues( object, values );
 	}
 
 	protected Object[] getPropertyValuesWithOptimizer(Object object) {
 		return optimizer.getAccessOptimizer().getPropertyValues( object );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public EntityMode getEntityMode() {
 		return EntityMode.POJO;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Class getMappedClass() {
 		return mappedClass;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public boolean isLifecycleImplementor() {
 		return lifecycleImplementor;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
-    public boolean isValidatableImplementor() {
-		return validatableImplementor;
-	}
-
-	/**
-	 * {@inheritDoc}
-	 */
-	@Override
     protected Getter buildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity) {
 		return mappedProperty.getGetter( mappedEntity.getMappedClass() );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     protected Setter buildPropertySetter(Property mappedProperty, PersistentClass mappedEntity) {
 		return mappedProperty.getSetter( mappedEntity.getMappedClass() );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Class getConcreteProxyClass() {
 		return proxyInterface;
 	}
 
     //TODO: need to make the majority of this functionality into a top-level support class for custom impl support
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session) {
 		if ( isInstrumented() ) {
 			Set lazyProps = lazyPropertiesAreUnfetched && getEntityMetamodel().hasLazyProperties() ?
 					lazyPropertyNames : null;
 			//TODO: if we support multiple fetch groups, we would need
 			//      to clone the set of lazy properties!
 			FieldInterceptionHelper.injectFieldInterceptor( entity, getEntityName(), lazyProps, session );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public boolean hasUninitializedLazyProperties(Object entity) {
 		if ( getEntityMetamodel().hasLazyProperties() ) {
 			FieldInterceptor callback = FieldInterceptionHelper.extractFieldInterceptor( entity );
 			return callback != null && !callback.isInitialized();
 		}
 		else {
 			return false;
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public boolean isInstrumented() {
 		return FieldInterceptionHelper.isInstrumented( getMappedClass() );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
 		final Class concreteEntityClass = entityInstance.getClass();
 		if ( concreteEntityClass == getMappedClass() ) {
 			return getEntityName();
 		}
 		else {
 			String entityName = getEntityMetamodel().findEntityNameByEntityClass( concreteEntityClass );
 			if ( entityName == null ) {
 				throw new HibernateException(
 						"Unable to resolve entity name from Class [" + concreteEntityClass.getName() + "]"
 								+ " expected instance/subclass of [" + getEntityName() + "]"
 				);
 			}
 			return entityName;
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public EntityNameResolver[] getEntityNameResolvers() {
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/TypeFactory.java b/hibernate-core/src/main/java/org/hibernate/type/TypeFactory.java
index e2490bbcfb..04e6d17d2d 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/TypeFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/TypeFactory.java
@@ -1,323 +1,324 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Properties;
+
+import org.jboss.logging.Logger;
+
 import org.hibernate.HibernateException;
 import org.hibernate.HibernateLogger;
 import org.hibernate.MappingException;
 import org.hibernate.classic.Lifecycle;
-import org.hibernate.classic.Validatable;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.tuple.component.ComponentMetamodel;
 import org.hibernate.usertype.CompositeUserType;
 import org.hibernate.usertype.ParameterizedType;
 import org.hibernate.usertype.UserType;
-import org.jboss.logging.Logger;
 
 /**
  * Used internally to build instances of {@link Type}, specifically it builds instances of
  *
  *
  * Used internally to obtain instances of <tt>Type</tt>. Applications should use static methods
  * and constants on <tt>org.hibernate.Hibernate</tt>.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 @SuppressWarnings({ "unchecked" })
 public final class TypeFactory implements Serializable {
 
     private static final HibernateLogger LOG = Logger.getMessageLogger(HibernateLogger.class, TypeFactory.class.getName());
 
 	private final TypeScopeImpl typeScope = new TypeScopeImpl();
 
 	public static interface TypeScope extends Serializable {
 		public SessionFactoryImplementor resolveFactory();
 	}
 
 	private static class TypeScopeImpl implements TypeFactory.TypeScope {
 		private SessionFactoryImplementor factory;
 
 		public void injectSessionFactory(SessionFactoryImplementor factory) {
             if (this.factory != null) LOG.scopingTypesToSessionFactoryAfterAlreadyScoped(this.factory, factory);
             else LOG.trace("Scoping types to session factory " + factory);
 			this.factory = factory;
 		}
 
 		public SessionFactoryImplementor resolveFactory() {
 			if ( factory == null ) {
 				throw new HibernateException( "SessionFactory for type scoping not yet known" );
 			}
 			return factory;
 		}
 	}
 
 	public void injectSessionFactory(SessionFactoryImplementor factory) {
 		typeScope.injectSessionFactory( factory );
 	}
 
 	public SessionFactoryImplementor resolveSessionFactory() {
 		return typeScope.resolveFactory();
 	}
 
 	public Type byClass(Class clazz, Properties parameters) {
 		if ( Type.class.isAssignableFrom( clazz ) ) {
 			return type( clazz, parameters );
 		}
 
 		if ( CompositeUserType.class.isAssignableFrom( clazz ) ) {
 			return customComponent( clazz, parameters );
 		}
 
 		if ( UserType.class.isAssignableFrom( clazz ) ) {
 			return custom( clazz, parameters );
 		}
 
-		if ( Lifecycle.class.isAssignableFrom( clazz ) || Validatable.class.isAssignableFrom( clazz ) ) {
+		if ( Lifecycle.class.isAssignableFrom( clazz ) ) {
 			// not really a many-to-one association *necessarily*
 			return manyToOne( clazz.getName() );
 		}
 
 		if ( Serializable.class.isAssignableFrom( clazz ) ) {
 			return serializable( clazz );
 		}
 
 		return null;
 	}
 
 	public Type type(Class<Type> typeClass, Properties parameters) {
 		try {
 			Type type = typeClass.newInstance();
 			injectParameters( type, parameters );
 			return type;
 		}
 		catch (Exception e) {
 			throw new MappingException( "Could not instantiate Type: " + typeClass.getName(), e );
 		}
 	}
 
 	public static void injectParameters(Object type, Properties parameters) {
 		if ( ParameterizedType.class.isInstance( type ) ) {
 			( (ParameterizedType) type ).setParameterValues(parameters);
 		}
 		else if ( parameters!=null && !parameters.isEmpty() ) {
 			throw new MappingException( "type is not parameterized: " + type.getClass().getName() );
 		}
 	}
 
 	public CompositeCustomType customComponent(Class<CompositeUserType> typeClass, Properties parameters) {
 		return customComponent( typeClass, parameters, typeScope );
 	}
 
 	/**
 	 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 	 */
 	@Deprecated
     @SuppressWarnings({ "JavaDoc" })
 	public static CompositeCustomType customComponent(Class<CompositeUserType> typeClass, Properties parameters, TypeScope scope) {
 		try {
 			CompositeUserType userType = typeClass.newInstance();
 			injectParameters( userType, parameters );
 			return new CompositeCustomType( userType );
 		}
 		catch ( Exception e ) {
 			throw new MappingException( "Unable to instantiate custom type: " + typeClass.getName(), e );
 		}
 	}
 
 	public CollectionType customCollection(
 			String typeName,
 			Properties typeParameters,
 			String role,
 			String propertyRef,
 			boolean embedded) {
 		Class typeClass;
 		try {
 			typeClass = ReflectHelper.classForName( typeName );
 		}
 		catch ( ClassNotFoundException cnfe ) {
 			throw new MappingException( "user collection type class not found: " + typeName, cnfe );
 		}
 		CustomCollectionType result = new CustomCollectionType( typeScope, typeClass, role, propertyRef, embedded );
 		if ( typeParameters != null ) {
 			injectParameters( result.getUserType(), typeParameters );
 		}
 		return result;
 	}
 
 	public CustomType custom(Class<UserType> typeClass, Properties parameters) {
 		return custom( typeClass, parameters, typeScope );
 	}
 
 	/**
 	 * @deprecated Only for use temporary use by {@link org.hibernate.Hibernate}
 	 */
 	@Deprecated
     public static CustomType custom(Class<UserType> typeClass, Properties parameters, TypeScope scope) {
 		try {
 			UserType userType = typeClass.newInstance();
 			injectParameters( userType, parameters );
 			return new CustomType( userType );
 		}
 		catch ( Exception e ) {
 			throw new MappingException( "Unable to instantiate custom type: " + typeClass.getName(), e );
 		}
 	}
 
 	/**
 	 * Build a {@link SerializableType} from the given {@link Serializable} class.
 	 *
 	 * @param serializableClass The {@link Serializable} class.
 	 * @param <T> The actual class type (extends Serializable)
 	 *
 	 * @return The built {@link SerializableType}
 	 */
 	public static <T extends Serializable> SerializableType<T> serializable(Class<T> serializableClass) {
 		return new SerializableType<T>( serializableClass );
 	}
 
 
 	// one-to-one type builders ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public EntityType oneToOne(
 			String persistentClass,
 			ForeignKeyDirection foreignKeyType,
 			String uniqueKeyPropertyName,
 			boolean lazy,
 			boolean unwrapProxy,
 			boolean isEmbeddedInXML,
 			String entityName,
 			String propertyName) {
 		return new OneToOneType( typeScope, persistentClass, foreignKeyType, uniqueKeyPropertyName,
 				lazy, unwrapProxy, isEmbeddedInXML, entityName, propertyName );
 	}
 
 	public EntityType specialOneToOne(
 			String persistentClass,
 			ForeignKeyDirection foreignKeyType,
 			String uniqueKeyPropertyName,
 			boolean lazy,
 			boolean unwrapProxy,
 			String entityName,
 			String propertyName) {
 		return new SpecialOneToOneType( typeScope, persistentClass, foreignKeyType, uniqueKeyPropertyName,
 				lazy, unwrapProxy, entityName, propertyName );
 	}
 
 
 	// many-to-one type builders ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public EntityType manyToOne(String persistentClass) {
 		return new ManyToOneType( typeScope, persistentClass );
 	}
 
 	public EntityType manyToOne(String persistentClass, boolean lazy) {
 		return new ManyToOneType( typeScope, persistentClass, lazy );
 	}
 
 	public EntityType manyToOne(
 			String persistentClass,
 			String uniqueKeyPropertyName,
 			boolean lazy,
 			boolean unwrapProxy,
 			boolean isEmbeddedInXML,
 			boolean ignoreNotFound,
 			boolean isLogicalOneToOne) {
 		return new ManyToOneType(
 				typeScope,
 				persistentClass,
 				uniqueKeyPropertyName,
 				lazy,
 				unwrapProxy,
 				isEmbeddedInXML,
 				ignoreNotFound,
 				isLogicalOneToOne
 		);
 	}
 
 
 	// collection type builders ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public CollectionType array(String role, String propertyRef, boolean embedded, Class elementClass) {
 		return new ArrayType( typeScope, role, propertyRef, elementClass, embedded );
 	}
 
 	public CollectionType list(String role, String propertyRef, boolean embedded) {
 		return new ListType( typeScope, role, propertyRef, embedded );
 	}
 
 	public CollectionType bag(String role, String propertyRef, boolean embedded) {
 		return new BagType( typeScope, role, propertyRef, embedded );
 	}
 
 	public CollectionType idbag(String role, String propertyRef, boolean embedded) {
 		return new IdentifierBagType( typeScope, role, propertyRef, embedded );
 	}
 
 	public CollectionType map(String role, String propertyRef, boolean embedded) {
 		return new MapType( typeScope, role, propertyRef, embedded );
 	}
 
 	public CollectionType orderedMap(String role, String propertyRef, boolean embedded) {
 		return new OrderedMapType( typeScope, role, propertyRef, embedded );
 	}
 
 	public CollectionType sortedMap(String role, String propertyRef, boolean embedded, Comparator comparator) {
 		return new SortedMapType( typeScope, role, propertyRef, comparator, embedded );
 	}
 
 	public CollectionType set(String role, String propertyRef, boolean embedded) {
 		return new SetType( typeScope, role, propertyRef, embedded );
 	}
 
 	public CollectionType orderedSet(String role, String propertyRef, boolean embedded) {
 		return new OrderedSetType( typeScope, role, propertyRef, embedded );
 	}
 
 	public CollectionType sortedSet(String role, String propertyRef, boolean embedded, Comparator comparator) {
 		return new SortedSetType( typeScope, role, propertyRef, comparator, embedded );
 	}
 
 
 	// component type builders ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public ComponentType component(ComponentMetamodel metamodel) {
 		return new ComponentType( typeScope, metamodel );
 	}
 
 	public EmbeddedComponentType embeddedComponent(ComponentMetamodel metamodel) {
 		return new EmbeddedComponentType( typeScope, metamodel );
 	}
 
 
 	// any type builder ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public Type any(Type metaType, Type identifierType) {
 		return new AnyType( metaType, identifierType );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/SQLFunctionsInterSystemsTest.java b/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/SQLFunctionsInterSystemsTest.java
index 68c50ff0cb..18e62e0ae2 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/SQLFunctionsInterSystemsTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/SQLFunctionsInterSystemsTest.java
@@ -1,771 +1,768 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.dialect.functional.cache;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.LockMode;
 import org.hibernate.Query;
 import org.hibernate.ScrollableResults;
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 import org.hibernate.dialect.Cache71Dialect;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.jdbc.Work;
 
 import org.junit.Test;
 
 import org.hibernate.testing.RequiresDialect;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.hibernate.test.legacy.Blobber;
 import org.hibernate.test.legacy.Broken;
 import org.hibernate.test.legacy.Fixed;
 import org.hibernate.test.legacy.Simple;
 import org.hibernate.test.legacy.Single;
 
 import static org.hibernate.testing.TestLogger.LOG;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Tests for function support on CacheSQL...
  *
  * @author Jonathan Levinson
  */
 @RequiresDialect( value = Cache71Dialect.class )
 public class SQLFunctionsInterSystemsTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] {
 				"legacy/AltSimple.hbm.xml",
 				"legacy/Broken.hbm.xml",
 				"legacy/Blobber.hbm.xml",
 				"dialect/functional/cache/TestInterSystemsFunctionsClass.hbm.xml"
 		};
 	}
 
 	@Test
 	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testDialectSQLFunctions() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf( 10 ) );
 		simple.setName("Simple Dialect Function Test");
 		simple.setAddress("Simple Address");
 		simple.setPay(new Float(45.8));
 		simple.setCount(2);
-		s.save(simple, Long.valueOf( 10 ) );
+		s.save( simple );
 
 		// Test to make sure allocating an specified object operates correctly.
 		assertTrue(
 				s.createQuery( "select new org.hibernate.test.legacy.S(s.count, s.address) from Simple s" ).list().size() == 1
 		);
 
 		// Quick check the base dialect functions operate correctly
 		assertTrue(
 				s.createQuery( "select max(s.count) from Simple s" ).list().size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select count(*) from Simple s" ).list().size() == 1
 		);
 
 		List rset = s.createQuery( "select s.name, sysdate, floor(s.pay), round(s.pay,0) from Simple s" ).list();
 		assertNotNull("Name string should have been returned",(((Object[])rset.get(0))[0]));
 		assertNotNull("Todays Date should have been returned",(((Object[])rset.get(0))[1]));
 		assertEquals("floor(45.8) result was incorrect ", new Integer(45), ( (Object[]) rset.get(0) )[2] );
 		assertEquals("round(45.8) result was incorrect ", new Float(46), ( (Object[]) rset.get(0) )[3] );
 
 		simple.setPay(new Float(-45.8));
 		s.update(simple);
 
 		// Test type conversions while using nested functions (Float to Int).
 		rset = s.createQuery( "select abs(round(s.pay,0)) from Simple s" ).list();
 		assertEquals("abs(round(-45.8)) result was incorrect ", new Float(46), rset.get(0));
 
 		// Test a larger depth 3 function example - Not a useful combo other than for testing
 		assertTrue(
 				s.createQuery( "select floor(round(sysdate,1)) from Simple s" ).list().size() == 1
 		);
 
 		// Test the oracle standard NVL funtion as a test of multi-param functions...
 		simple.setPay(null);
 		s.update(simple);
 		Double value = (Double) s.createQuery("select mod( nvl(s.pay, 5000), 2 ) from Simple as s where s.id = 10").list().get(0);
 		assertTrue( 0 == value.intValue() );
 
 		// Test the hsql standard MOD funtion as a test of multi-param functions...
 		value = (Double) s.createQuery( "select MOD(s.count, 2) from Simple as s where s.id = 10" )
 				.list()
 				.get(0);
 		assertTrue( 0 == value.intValue() );
 
         s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"UnnecessaryBoxing", "unchecked"})
 	public void testSetProperties() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf( 10 ) );
 		simple.setName("Simple 1");
-		s.save(simple, Long.valueOf( 10 ) );
+		s.save( simple );
 		Query q = s.createQuery("from Simple s where s.name=:name and s.count=:count");
 		q.setProperties(simple);
 		assertTrue( q.list().get(0)==simple );
 		//misuse of "Single" as a propertyobject, but it was the first testclass i found with a collection ;)
 		Single single = new Single() { // trivial hack to test properties with arrays.
 			@SuppressWarnings( {"unchecked"})
 			String[] getStuff() { 
 				return (String[]) getSeveral().toArray(new String[getSeveral().size()]);
 			}
 		};
 
 		List l = new ArrayList();
 		l.add("Simple 1");
 		l.add("Slimeball");
 		single.setSeveral(l);
 		q = s.createQuery("from Simple s where s.name in (:several)");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 
 
 		q = s.createQuery("from Simple s where s.name in (:stuff)");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testBroken() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Broken b = new Fixed();
 		b.setId( Long.valueOf( 123 ));
 		b.setOtherId("foobar");
 		s.save(b);
 		s.flush();
 		b.setTimestamp( new Date() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update(b);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		b = (Broken) s.load( Broken.class, b );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete(b);
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testNothinToUpdate() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
-		s.save( simple, Long.valueOf(10) );
+		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		s.update( simple, Long.valueOf(10) );
+		s.update( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		s.update( simple, Long.valueOf(10) );
+		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testCachedQuery() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
-		s.save( simple, Long.valueOf(10) );
+		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setCacheable(true);
 		q.setString("name", "Simple 1");
 		assertTrue( q.list().size()==1 );
 		simple = (Simple) q.list().get(0);
 
 		q.setString("name", "Simple 2");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		simple.setName("Simple 2");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setString("name", "Simple 2");
 		q.setCacheable(true);
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		s.update( simple, Long.valueOf(10) );
+		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testCachedQueryRegion() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
-		s.save( simple, Long.valueOf(10) );
+		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString("name", "Simple 1");
 		assertTrue( q.list().size()==1 );
 		simple = (Simple) q.list().get(0);
 
 		q.setString("name", "Simple 2");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		simple.setName("Simple 2");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		s.update( simple, Long.valueOf(10) );
+		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"UnnecessaryBoxing", "unchecked"})
 	public void testSQLFunctions() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
-		s.save(simple, Long.valueOf(10) );
+		s.save(simple );
 
 		s.createQuery( "from Simple s where repeat('foo', 3) = 'foofoofoo'" ).list();
 		s.createQuery( "from Simple s where repeat(s.name, 3) = 'foofoofoo'" ).list();
 		s.createQuery( "from Simple s where repeat( lower(s.name), (3 + (1-1)) / 2) = 'foofoofoo'" ).list();
 
 		assertTrue(
 				s.createQuery( "from Simple s where upper( s.name ) ='SIMPLE 1'" ).list().size()==1
 		);
 		assertTrue(
 				s.createQuery(
 						"from Simple s where not( upper( s.name ) ='yada' or 1=2 or 'foo'='bar' or not('foo'='foo') or 'foo' like 'bar' )"
 				).list()
 						.size()==1
 		);
 
 		assertTrue(
 				s.createQuery( "from Simple s where lower( s.name || ' foo' ) ='simple 1 foo'" ).list().size()==1
 		);
 		assertTrue(
 				s.createQuery( "from Simple s where lower( concat(s.name, ' foo') ) ='simple 1 foo'" ).list().size()==1
 		);
 
-		Simple other = new Simple();
+		Simple other = new Simple( Long.valueOf(20) );
 		other.setName( "Simple 2" );
 		other.setCount( 12 );
 		simple.setOther( other );
-		s.save( other, Long.valueOf(20) );
+		s.save( other );
 		//s.find("from Simple s where s.name ## 'cat|rat|bag'");
 		assertTrue(
 				s.createQuery( "from Simple s where upper( s.other.name ) ='SIMPLE 2'" ).list().size()==1
 		);
 		assertTrue(
 				s.createQuery( "from Simple s where not ( upper( s.other.name ) ='SIMPLE 2' )" ).list().size()==0
 		);
 		assertTrue(
 				s.createQuery(
 						"select distinct s from Simple s where ( ( s.other.count + 3 ) = (15*2)/2 and s.count = 69) or ( ( s.other.count + 2 ) / 7 ) = 2"
 				).list()
 						.size()==1
 		);
 		assertTrue(
 				s.createQuery(
 						"select s from Simple s where ( ( s.other.count + 3 ) = (15*2)/2 and s.count = 69) or ( ( s.other.count + 2 ) / 7 ) = 2 order by s.other.count"
 				).list()
 						.size()==1
 		);
-		Simple min = new Simple();
+		Simple min = new Simple( Long.valueOf(30) );
 		min.setCount( -1 );
-		s.save(min, Long.valueOf(30) );
+		s.save(min );
 
 		assertTrue(
 				s.createQuery( "from Simple s where s.count > ( select min(sim.count) from Simple sim )" )
 						.list()
 						.size()==2
 		);
 		t.commit();
 		t = s.beginTransaction();
 		assertTrue(
 				s.createQuery(
 						"from Simple s where s = some( select sim from Simple sim where sim.count>=0 ) and s.count >= 0"
 				).list()
 						.size()==2
 		);
 		assertTrue(
 				s.createQuery(
 						"from Simple s where s = some( select sim from Simple sim where sim.other.count=s.other.count ) and s.other.count > 0"
 				).list()
 						.size()==1
 		);
 
 		Iterator iter = s.createQuery( "select sum(s.count) from Simple s group by s.count having sum(s.count) > 10" )
 				.iterate();
 		assertTrue( iter.hasNext() );
 		assertEquals( Long.valueOf( 12 ), iter.next() );
 		assertTrue( !iter.hasNext() );
 		iter = s.createQuery( "select s.count from Simple s group by s.count having s.count = 12" ).iterate();
 		assertTrue( iter.hasNext() );
 
 		s.createQuery(
 				"select s.id, s.count, count(t), max(t.date) from Simple s, Simple t where s.count = t.count group by s.id, s.count order by s.count"
 		).iterate();
 
 		Query q = s.createQuery("from Simple s");
 		q.setMaxResults( 10 );
 		assertTrue( q.list().size()==3 );
 		q = s.createQuery("from Simple s");
 		q.setMaxResults( 1 );
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s");
 		assertTrue( q.list().size() == 3 );
 		q = s.createQuery("from Simple s where s.name = ?");
 		q.setString( 0, "Simple 1" );
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name = ? and upper(s.name) = ?");
 		q.setString(1, "SIMPLE 1");
 		q.setString( 0, "Simple 1" );
 		q.setFirstResult(0);
 		assertTrue( q.iterate().hasNext() );
 		q = s.createQuery("from Simple s where s.name = :foo and upper(s.name) = :bar or s.count=:count or s.count=:count + 1");
 		q.setParameter( "bar", "SIMPLE 1" );
 		q.setString( "foo", "Simple 1" );
 		q.setInteger("count", 69);
 		q.setFirstResult(0);
 		assertTrue( q.iterate().hasNext() );
 		q = s.createQuery("select s.id from Simple s");
 		q.setFirstResult(1);
 		q.setMaxResults( 2 );
 		iter = q.iterate();
 		int i=0;
 		while ( iter.hasNext() ) {
 			assertTrue( iter.next() instanceof Long );
 			i++;
 		}
 		assertTrue( i == 2 );
 		q = s.createQuery("select all s, s.other from Simple s where s = :s");
 		q.setParameter("s", simple);
 		assertTrue( q.list().size()==1 );
 
 
 		q = s.createQuery("from Simple s where s.name in (:name_list) and s.count > :count");
 		HashSet set = new HashSet();
 		set.add("Simple 1");
 		set.add("foo");
 		q.setParameterList( "name_list", set );
 		q.setParameter("count", new Integer(-1) );
 		assertTrue( q.list().size()==1 );
 
 		ScrollableResults sr = s.createQuery("from Simple s").scroll();
 		sr.next();
 		sr.get(0);
 		sr.close();
 
-		s.delete(other);
-		s.delete(simple);
-		s.delete(min);
+		s.delete( other );
+		s.delete( simple );
+		s.delete( min );
 		t.commit();
 		s.close();
 
 	}
 
 	public void testBlobClob() throws Exception {
-
 		Session s = openSession();
 		s.beginTransaction();
 		Blobber b = new Blobber();
 		b.setBlob( s.getLobHelper().createBlob( "foo/bar/baz".getBytes() ) );
 		b.setClob( s.getLobHelper().createClob("foo/bar/baz") );
 		s.save(b);
 		//s.refresh(b);
 		//assertTrue( b.getClob() instanceof ClobImpl );
 		s.flush();
 		s.refresh(b);
 		//b.getBlob().setBytes( 2, "abc".getBytes() );
         LOG.debug("levinson: just bfore b.getClob()");
         b.getClob().getSubString(2, 3);
 		//b.getClob().setString(2, "abc");
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		Blobber b2 = new Blobber();
 		s.save(b2);
 		b2.setBlob( b.getBlob() );
 		b.setBlob(null);
 		//assertTrue( b.getClob().getSubString(1, 3).equals("fab") );
 		b.getClob().getSubString(1, 6);
 		//b.getClob().setString(1, "qwerty");
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		b.setClob( s.getLobHelper().createClob("xcvfxvc xcvbx cvbx cvbx cvbxcvbxcvbxcvb") );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		assertTrue( b.getClob().getSubString(1, 7).equals("xcvfxvc") );
 		//b.getClob().setString(5, "1234567890");
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testSqlFunctionAsAlias() throws Exception {
 		String functionName = locateAppropriateDialectFunctionNameForAliasTest();
 		if (functionName == null) {
             LOG.info("Dialect does not list any no-arg functions");
 			return;
 		}
 
         LOG.info("Using function named [" + functionName + "] for 'function as alias' test");
 		String query = "select " + functionName + " from Simple as " + functionName + " where " + functionName + ".id = 10";
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
-		s.save( simple, Long.valueOf(10) );
+		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List result = s.createQuery( query ).list();
 		assertTrue( result.size() == 1 );
 		assertTrue(result.get(0) instanceof Simple);
 		s.delete( result.get(0) );
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"ForLoopReplaceableByForEach"})
 	private String locateAppropriateDialectFunctionNameForAliasTest() {
 		for (Iterator itr = getDialect().getFunctions().entrySet().iterator(); itr.hasNext(); ) {
 			final Map.Entry entry = (Map.Entry) itr.next();
 			final SQLFunction function = (SQLFunction) entry.getValue();
 			if ( !function.hasArguments() && !function.hasParenthesesIfNoArguments() ) {
 				return (String) entry.getKey();
 			}
 		}
 		return null;
 	}
 
 	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testCachedQueryOnInsert() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
-		s.save( simple, Long.valueOf(10) );
+		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s");
 		List list = q.setCacheable(true).list();
 		assertTrue( list.size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		Simple simple2 = new Simple();
+		Simple simple2 = new Simple( Long.valueOf(12) );
 		simple2.setCount(133);
-		s.save( simple2, Long.valueOf(12) );
+		s.save( simple2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==2 );
 		for ( Object o : list ) {
 			s.delete( o );
 		}
 		t.commit();
 		s.close();
 
 	}
 
     @SuppressWarnings( {"UnnecessaryBoxing", "UnnecessaryUnboxing"})
 	public void testInterSystemsFunctions() throws Exception {
         Calendar cal = new GregorianCalendar();
         cal.set(1977,6,3,0,0,0);
         java.sql.Timestamp testvalue = new java.sql.Timestamp(cal.getTimeInMillis());
         testvalue.setNanos(0);
         Calendar cal3 = new GregorianCalendar();
         cal3.set(1976,2,3,0,0,0);
         java.sql.Timestamp testvalue3 = new java.sql.Timestamp(cal3.getTimeInMillis());
         testvalue3.setNanos(0);
 
         Session s = openSession();
         s.beginTransaction();
         try {
 			s.doWork(
 					new Work() {
 						@Override
 						public void execute(Connection connection) throws SQLException {
 							Statement stmt = connection.createStatement();
 							stmt.executeUpdate( "DROP FUNCTION spLock FROM TestInterSystemsFunctionsClass" );
 						}
 					}
 			);
         }
         catch (Exception ex) {
             System.out.println("as we expected stored procedure sp does not exist when we drop it");
 
         }
 		s.getTransaction().commit();
 
         s.beginTransaction();
 		s.doWork(
 				new Work() {
 					@Override
 					public void execute(Connection connection) throws SQLException {
 						Statement stmt = connection.createStatement();
 						String create_function = "CREATE FUNCTION SQLUser.TestInterSystemsFunctionsClass_spLock\n" +
 								"     ( INOUT pHandle %SQLProcContext, \n" +
 								"       ROWID INTEGER \n" +
 								" )\n" +
 								" FOR User.TestInterSystemsFunctionsClass " +
 								"    PROCEDURE\n" +
 								"    RETURNS INTEGER\n" +
 								"    LANGUAGE OBJECTSCRIPT\n" +
 								"    {\n" +
 								"        q 0\n" +
 								"     }";
 						stmt.executeUpdate(create_function);
 					}
 				}
 		);
         s.getTransaction().commit();
 
         s.beginTransaction();
 
-        TestInterSystemsFunctionsClass object = new TestInterSystemsFunctionsClass();
+        TestInterSystemsFunctionsClass object = new TestInterSystemsFunctionsClass( Long.valueOf( 10 ) );
         object.setDateText("1977-07-03");
         object.setDate1( testvalue );
         object.setDate3( testvalue3 );
-        s.save( object, Long.valueOf( 10 ) );
+        s.save( object );
         s.getTransaction().commit();
         s.close();
 
         s = openSession();
         s.beginTransaction();
         TestInterSystemsFunctionsClass test = (TestInterSystemsFunctionsClass) s.get(TestInterSystemsFunctionsClass.class, Long.valueOf(10));
         assertTrue( test.getDate1().equals(testvalue));
         test = (TestInterSystemsFunctionsClass) s.get(TestInterSystemsFunctionsClass.class, Long.valueOf(10), LockMode.UPGRADE);
         assertTrue( test.getDate1().equals(testvalue));
         Date value = (Date) s.createQuery( "select nvl(o.date,o.dateText) from TestInterSystemsFunctionsClass as o" )
 				.list()
 				.get(0);
         assertTrue( value.equals(testvalue));
         Object nv = s.createQuery( "select nullif(o.dateText,o.dateText) from TestInterSystemsFunctionsClass as o" )
 				.list()
 				.get(0);
         assertTrue( nv == null);
         String dateText = (String) s.createQuery(
 				"select nvl(o.dateText,o.date) from TestInterSystemsFunctionsClass as o"
 		).list()
 				.get(0);
         assertTrue( dateText.equals("1977-07-03"));
         value = (Date) s.createQuery( "select ifnull(o.date,o.date1) from TestInterSystemsFunctionsClass as o" )
 				.list()
 				.get(0);
         assertTrue( value.equals(testvalue));
         value = (Date) s.createQuery( "select ifnull(o.date3,o.date,o.date1) from TestInterSystemsFunctionsClass as o" )
 				.list()
 				.get(0);
         assertTrue( value.equals(testvalue));
         Integer pos = (Integer) s.createQuery(
 				"select position('07', o.dateText) from TestInterSystemsFunctionsClass as o"
 		).list()
 				.get(0);
         assertTrue(pos.intValue() == 6);
         String st = (String) s.createQuery( "select convert(o.date1, SQL_TIME) from TestInterSystemsFunctionsClass as o" )
 				.list()
 				.get(0);
         assertTrue( st.equals("00:00:00"));
         java.sql.Time tm = (java.sql.Time) s.createQuery(
 				"select cast(o.date1, time) from TestInterSystemsFunctionsClass as o"
 		).list()
 				.get(0);
         assertTrue( tm.toString().equals("00:00:00"));
         Double diff = (Double) s.createQuery(
 				"select timestampdiff(SQL_TSI_FRAC_SECOND, o.date3, o.date1) from TestInterSystemsFunctionsClass as o"
 		).list()
 				.get(0);
         assertTrue(diff.doubleValue() != 0.0);
         diff = (Double) s.createQuery(
 				"select timestampdiff(SQL_TSI_MONTH, o.date3, o.date1) from TestInterSystemsFunctionsClass as o"
 		).list()
 				.get(0);
         assertTrue(diff.doubleValue() == 16.0);
         diff = (Double) s.createQuery(
 				"select timestampdiff(SQL_TSI_WEEK, o.date3, o.date1) from TestInterSystemsFunctionsClass as o"
 		).list()
 				.get(0);
         assertTrue(diff.doubleValue() >= 16*4);
         diff = (Double) s.createQuery(
 				"select timestampdiff(SQL_TSI_YEAR, o.date3, o.date1) from TestInterSystemsFunctionsClass as o"
 		).list()
 				.get(0);
         assertTrue(diff.doubleValue() == 1.0);
 
         s.getTransaction().commit();
         s.close();
-
-
     }
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/TestInterSystemsFunctionsClass.hbm.xml b/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/TestInterSystemsFunctionsClass.hbm.xml
index 31a48bac25..b56229f126 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/TestInterSystemsFunctionsClass.hbm.xml
+++ b/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/TestInterSystemsFunctionsClass.hbm.xml
@@ -1,18 +1,18 @@
-<?xml version="1.0"?>
-<!DOCTYPE hibernate-mapping PUBLIC
-	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
-	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
-
-<hibernate-mapping package="org.hibernate.test.dialect.functional.cache" >
-
-    <class name="TestInterSystemsFunctionsClass" table="SQLUser.TestInterSystemsFunctionsClass">
-        <id type="long" column="id_">
-            <generator class="assigned"/>
-        </id>
-        <property name="date" column="date_"/>
-        <property name="date1" column="date1_"/>
-        <property name="date3" column="date3_"/>
-        <property name="dateText" column="dateText_"/>
-    </class>
-
-</hibernate-mapping>
+<?xml version="1.0"?>
+<!DOCTYPE hibernate-mapping PUBLIC
+	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
+	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
+
+<hibernate-mapping package="org.hibernate.test.dialect.functional.cache" >
+
+    <class name="TestInterSystemsFunctionsClass" table="SQLUser.TestInterSystemsFunctionsClass">
+        <id name="id" type="long" column="id_">
+            <generator class="assigned"/>
+        </id>
+        <property name="date" column="date_"/>
+        <property name="date1" column="date1_"/>
+        <property name="date3" column="date3_"/>
+        <property name="dateText" column="dateText_"/>
+    </class>
+
+</hibernate-mapping>
diff --git a/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/TestInterSystemsFunctionsClass.java b/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/TestInterSystemsFunctionsClass.java
index 7c650e4999..c510aa5f21 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/TestInterSystemsFunctionsClass.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/TestInterSystemsFunctionsClass.java
@@ -1,50 +1,66 @@
 package org.hibernate.test.dialect.functional.cache;
 import java.util.Date;
-
-/**
- * Entity for testing function support of InterSystems' CacheSQL...
- *
- * @author Jonathan Levinson
- */
-public class TestInterSystemsFunctionsClass {
-    private java.util.Date date3;
-    private java.util.Date date1;
-    private java.util.Date date;
-    private String dateText;
-
-	public Date getDate() {
-        return date;
-    }
-
-    public void setDate(Date date) {
-        this.date = date;
-    }
-
-
-    public String getDateText() {
-        return dateText;
-    }
-
-    public void setDateText(String dateText) {
-        this.dateText = dateText;
-    }
-
-
-    public Date getDate1() {
-        return date1;
-    }
-
-    public void setDate1(Date date1) {
-        this.date1 = date1;
-    }
-
-
-    public Date getDate3() {
-        return date3;
-    }
-
-    public void setDate3(Date date3) {
-        this.date3 = date3;
-    }
-
-}
+
+/**
+ * Entity for testing function support of InterSystems' CacheSQL...
+ *
+ * @author Jonathan Levinson
+ */
+public class TestInterSystemsFunctionsClass {
+	private Long id;
+    private java.util.Date date3;
+    private java.util.Date date1;
+    private java.util.Date date;
+    private String dateText;
+
+	public TestInterSystemsFunctionsClass() {
+	}
+
+	public TestInterSystemsFunctionsClass(Long id) {
+		this.id = id;
+	}
+
+	public Long getId() {
+		return id;
+	}
+
+	public void setId(Long id) {
+		this.id = id;
+	}
+
+	public Date getDate() {
+        return date;
+    }
+
+    public void setDate(Date date) {
+        this.date = date;
+    }
+
+
+    public String getDateText() {
+        return dateText;
+    }
+
+    public void setDateText(String dateText) {
+        this.dateText = dateText;
+    }
+
+
+    public Date getDate1() {
+        return date1;
+    }
+
+    public void setDate1(Date date1) {
+        this.date1 = date1;
+    }
+
+
+    public Date getDate3() {
+        return date3;
+    }
+
+    public void setDate3(Date date3) {
+        this.date3 = date3;
+    }
+
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/entitymode/multi/MultiRepresentationTest.java b/hibernate-core/src/test/java/org/hibernate/test/entitymode/multi/MultiRepresentationTest.java
index 2105906856..3dcefa65b5 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/entitymode/multi/MultiRepresentationTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/entitymode/multi/MultiRepresentationTest.java
@@ -1,212 +1,214 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.entitymode.multi;
+
 import java.sql.Date;
 import java.util.Iterator;
 import java.util.List;
 
 import org.dom4j.DocumentFactory;
 import org.dom4j.Element;
 import org.dom4j.io.OutputFormat;
 import org.dom4j.io.XMLWriter;
+
 import org.hibernate.EntityMode;
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Implementation of MultiRepresentationTest.
  *
  * @author Steve Ebersole
  */
 public class MultiRepresentationTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "entitymode/multi/Stock.hbm.xml", "entitymode/multi/Valuation.hbm.xml" };
 	}
 
 	@Test
 	public void testPojoRetreival() {
 		TestData testData = new TestData();
 		testData.create();
 
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 
 		Stock stock = ( Stock ) session.get( Stock.class, new Long( 1 ) );
 		assertEquals( "Something wrong!", new Long( 1 ), stock.getId() );
 
 		txn.commit();
 		session.close();
 
 		testData.destroy();
 	}
 
 	@Test
 	public void testDom4jRetreival() {
 		TestData testData = new TestData();
 		testData.create();
 
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 		org.hibernate.Session dom4j = session.getSession( EntityMode.DOM4J );
 
 		Object rtn = dom4j.get( Stock.class.getName(), testData.stockId );
 		Element element = ( Element ) rtn;
 
 		assertEquals( "Something wrong!", testData.stockId, Long.valueOf( element.attributeValue( "id" ) ) );
 
 		System.out.println( "**** XML: ****************************************************" );
 		prettyPrint( element );
 		System.out.println( "**************************************************************" );
 
 		Element currVal = element.element( "currentValuation" );
 
 		System.out.println( "**** XML: ****************************************************" );
 		prettyPrint( currVal );
 		System.out.println( "**************************************************************" );
 
 		txn.rollback();
 		session.close();
 
 		testData.destroy();
 	}
 
 	@Test
 	public void testDom4jSave() {
 		TestData testData = new TestData();
 		testData.create();
 
 		Session pojos = openSession();
 		Transaction txn = pojos.beginTransaction();
 		org.hibernate.Session dom4j = pojos.getSession( EntityMode.DOM4J );
 
 		Element stock = DocumentFactory.getInstance().createElement( "stock" );
 		stock.addElement( "tradeSymbol" ).setText( "IBM" );
 
 		Element val = stock.addElement( "currentValuation" ).addElement( "valuation" );
 		val.appendContent( stock );
 		val.addElement( "valuationDate" ).setText( new java.util.Date().toString() );
 		val.addElement( "value" ).setText( "121.00" );
 
 		dom4j.save( Stock.class.getName(), stock );
 		dom4j.flush();
 
 		txn.rollback();
 		pojos.close();
 
 		assertTrue( !pojos.isOpen() );
 		assertTrue( !dom4j.isOpen() );
 
 		prettyPrint( stock );
 
 		testData.destroy();
 	}
 
 	@Test
 	public void testDom4jHQL() {
 		TestData testData = new TestData();
 		testData.create();
 
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 		org.hibernate.Session dom4j = session.getSession( EntityMode.DOM4J );
 
 		List result = dom4j.createQuery( "from Stock" ).list();
 
 		assertEquals( "Incorrect result size", 1, result.size() );
 		Element element = ( Element ) result.get( 0 );
 		assertEquals( "Something wrong!", testData.stockId, Long.valueOf( element.attributeValue( "id" ) ) );
 
 		System.out.println( "**** XML: ****************************************************" );
 		prettyPrint( element );
 		System.out.println( "**************************************************************" );
 
 		txn.rollback();
 		session.close();
 
 		testData.destroy();
 	}
 
 	private class TestData {
 		private Long stockId;
 
 		private void create() {
 			Session session = sessionFactory().openSession();
 			session.beginTransaction();
 			Stock stock = new Stock();
 			stock.setTradeSymbol( "JBOSS" );
 			Valuation valuation = new Valuation();
 			valuation.setStock( stock );
 			valuation.setValuationDate( new Date( new java.util.Date().getTime() ) );
 			valuation.setValue( new Double( 200.0 ) );
 			stock.setCurrentValuation( valuation );
 			stock.getValuations().add( valuation );
 
 			session.save( stock );
 			session.save( valuation );
 
 			session.getTransaction().commit();
 			session.close();
 
 			stockId = stock.getId();
 		}
 
 		private void destroy() {
 			Session session = sessionFactory().openSession();
 			session.beginTransaction();
 			Iterator stocks = session.createQuery( "from Stock" ).list().iterator();
 			while ( stocks.hasNext() ) {
 				final Stock stock = ( Stock ) stocks.next();
 				stock.setCurrentValuation( null );
 				session.flush();
 				Iterator valuations = stock.getValuations().iterator();
 				while ( valuations.hasNext() ) {
 					session.delete( valuations.next() );
 				}
 				session.delete( stock );
 			}
 			session.getTransaction().commit();
 			session.close();
 		}
 	}
 
 	private void prettyPrint(Element element) {
 		//System.out.println( element.asXML() );
 		try {
 			OutputFormat format = OutputFormat.createPrettyPrint();
 			new XMLWriter( System.out, format ).write( element );
 			System.out.println();
 		}
 		catch ( Throwable t ) {
 			System.err.println( "Unable to pretty print element : " + t );
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java
index b5f73b9253..8475783715 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java
@@ -1,1031 +1,1032 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
+
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
 
 import org.hibernate.QueryException;
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.hql.ast.HqlSqlWalker;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.persister.entity.EntityPersister;
 
 import org.junit.Test;
 import junit.framework.AssertionFailedError;
 
 import org.hibernate.testing.DialectChecks;
 import org.hibernate.testing.RequiresDialectFeature;
 import org.hibernate.testing.SkipLog;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * Tests execution of bulk UPDATE/DELETE statements through the new AST parser.
  *
  * @author Steve Ebersole
  */
 public class BulkManipulationTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] {
 				"hql/Animal.hbm.xml",
 		        "hql/Vehicle.hbm.xml",
 		        "hql/KeyManyToOneEntity.hbm.xml",
 		        "hql/Versions.hbm.xml",
 				"hql/FooBarCopy.hbm.xml",
 				"legacy/Multi.hbm.xml",
 				"hql/EntityWithCrazyCompositeKey.hbm.xml",
 				"hql/SimpleEntityWithAssociation.hbm.xml",
 				"hql/BooleanLiteralEntity.hbm.xml"
 		};
 	}
 
 	@Test
 	public void testDeleteNonExistentEntity() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		try {
 			s.createQuery( "delete NonExistentEntity" ).executeUpdate();
 			fail( "no exception thrown" );
 		}
 		catch( QueryException ignore ) {
 		}
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testUpdateNonExistentEntity() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		try {
 			s.createQuery( "update NonExistentEntity e set e.someProp = ?" ).executeUpdate();
 			fail( "no exception thrown" );
 		}
 		catch( QueryException e ) {
 		}
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testTempTableGenerationIsolation() throws Throwable{
 		Session s = openSession();
 		s.beginTransaction();
 
 		Truck truck = new Truck();
 		truck.setVin( "123t" );
 		truck.setOwner( "Steve" );
 		s.save( truck );
 
 		// manually flush the session to ensure the insert happens
 		s.flush();
 
 		// now issue a bulk delete against Car which should force the temp table to be
 		// created.  we need to test to ensure that this does not cause the transaction
 		// to be committed...
 		s.createQuery( "delete from Vehicle" ).executeUpdate();
 
 		s.getTransaction().rollback();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List list = s.createQuery( "from Car" ).list();
 		assertEquals( "temp table gen caused premature commit", 0, list.size() );
 		s.createQuery( "delete from Car" ).executeUpdate();
 		s.getTransaction().rollback();
 		s.close();
 	}
 
 	@Test
 	public void testBooleanHandling() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// currently, we need the three different binds because they are different underlying types...
 		int count = s.createQuery( "update BooleanLiteralEntity set yesNoBoolean = :b1, trueFalseBoolean = :b2, zeroOneBoolean = :b3" )
 				.setBoolean( "b1", true )
 				.setBoolean( "b2", true )
 				.setBoolean( "b3", true )
 				.executeUpdate();
 		assertEquals( 1, count );
 		BooleanLiteralEntity entity = ( BooleanLiteralEntity ) s.createQuery( "from BooleanLiteralEntity" ).uniqueResult();
 		assertTrue( entity.isYesNoBoolean() );
 		assertTrue( entity.isTrueFalseBoolean() );
 		assertTrue( entity.isZeroOneBoolean() );
 		s.clear();
 
 		count = s.createQuery( "update BooleanLiteralEntity set yesNoBoolean = true, trueFalseBoolean = true, zeroOneBoolean = true" )
 				.executeUpdate();
 		assertEquals( 1, count );
 		entity = ( BooleanLiteralEntity ) s.createQuery( "from BooleanLiteralEntity" ).uniqueResult();
 		assertTrue( entity.isYesNoBoolean() );
 		assertTrue( entity.isTrueFalseBoolean() );
 		assertTrue( entity.isZeroOneBoolean() );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testSimpleInsert() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		s.createQuery( "insert into Pickup (id, vin, owner) select id, vin, owner from Car" ).executeUpdate();
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createQuery( "delete Vehicle" ).executeUpdate();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testSimpleNativeSQLInsert() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		List l = s.createQuery("from Vehicle").list();
 		assertEquals(l.size(),4);
 
 		s.createSQLQuery( "insert into Pickup (id, vin, owner) select id, vin, owner from Car" ).executeUpdate();
 
 		l = s.createQuery("from Vehicle").list();
 		assertEquals( l.size(), 5 );
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createSQLQuery( "delete from Truck" ).executeUpdate();
 
 		l = s.createQuery("from Vehicle").list();
 		assertEquals(l.size(),4);
 
 		Car c = (Car) s.createQuery( "from Car where owner = 'Kirsten'" ).uniqueResult();
 		c.setOwner( "NotKirsten" );
 		assertEquals( 0, s.getNamedQuery( "native-delete-car" ).setString( 0, "Kirsten" ).executeUpdate() );
 		assertEquals( 1, s.getNamedQuery( "native-delete-car" ).setString( 0, "NotKirsten" ).executeUpdate() );
 
 
 		assertEquals(
 				0, s.createSQLQuery( "delete from SUV where owner = :owner" )
 				.setString( "owner", "NotThere" )
 				.executeUpdate()
 		);
 		assertEquals(
 				1, s.createSQLQuery( "delete from SUV where owner = :owner" )
 				.setString( "owner", "Joe" )
 				.executeUpdate()
 		);
 		s.createSQLQuery( "delete from Pickup" ).executeUpdate();
 
 		l = s.createQuery("from Vehicle").list();
 		assertEquals(l.size(),0);
 
 
 		t.commit();
 		s.close();
 
 
 		data.cleanup();
 	}
 	
 	@Test
 	public void testInsertWithManyToOne() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		s.createQuery( "insert into Animal (description, bodyWeight, mother) select description, bodyWeight, mother from Human" ).executeUpdate();
 
 		t.commit();
 		t = s.beginTransaction();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testInsertWithMismatchedTypes() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		try {
 			s.createQuery( "insert into Pickup (owner, vin, id) select id, vin, owner from Car" ).executeUpdate();
 			fail( "mismatched types did not error" );
 		}
 		catch( QueryException e ) {
 			// expected result
 		}
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createQuery( "delete Vehicle" ).executeUpdate();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testInsertIntoSuperclassPropertiesFails() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		try {
 			s.createQuery( "insert into Human (id, bodyWeight) select id, bodyWeight from Lizard" ).executeUpdate();
 			fail( "superclass prop insertion did not error" );
 		}
 		catch( QueryException e ) {
 			// expected result
 		}
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createQuery( "delete Animal where mother is not null" ).executeUpdate();
 		s.createQuery( "delete Animal where father is not null" ).executeUpdate();
 		s.createQuery( "delete Animal" ).executeUpdate();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testInsertAcrossMappedJoinFails() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		try {
 			s.createQuery( "insert into Joiner (name, joinedName) select vin, owner from Car" ).executeUpdate();
 			fail( "mapped-join insertion did not error" );
 		}
 		catch( QueryException e ) {
 			// expected result
 		}
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createQuery( "delete Joiner" ).executeUpdate();
 		s.createQuery( "delete Vehicle" ).executeUpdate();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	protected boolean supportsBulkInsertIdGeneration(Class entityClass) {
 		EntityPersister persister = sessionFactory().getEntityPersister( entityClass.getName() );
 		IdentifierGenerator generator = persister.getIdentifierGenerator();
 		return HqlSqlWalker.supportsIdGenWithBulkInsertion( generator );
 	}
 
 	@Test
 	public void testInsertWithGeneratedId() {
 		// Make sure the env supports bulk inserts with generated ids...
 		if ( !supportsBulkInsertIdGeneration( PettingZoo.class ) ) {
 			SkipLog.reportSkip(
 					"bulk id generation not supported",
 					"test bulk inserts with generated id and generated timestamp"
 			);
 			return;
 		}
 
 		// create a Zoo
 		Zoo zoo = new Zoo();
 		zoo.setName( "zoo" );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.save( zoo );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "insert into PettingZoo (name) select name from Zoo" ).executeUpdate();
 		t.commit();
 		s.close();
 
 		assertEquals( "unexpected insertion count", 1, count );
 
 		s = openSession();
 		t = s.beginTransaction();
 		PettingZoo pz = ( PettingZoo ) s.createQuery( "from PettingZoo" ).uniqueResult();
 		t.commit();
 		s.close();
 
 		assertEquals( zoo.getName(), pz.getName() );
 		assertTrue( !zoo.getId().equals( pz.getId() ) );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete Zoo" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	@Test
 	public void testInsertWithGeneratedVersionAndId() {
 		// Make sure the env supports bulk inserts with generated ids...
 		if ( !supportsBulkInsertIdGeneration( IntegerVersioned.class ) ) {
 			SkipLog.reportSkip(
 					"bulk id generation not supported",
 					"test bulk inserts with generated id and generated timestamp"
 			);
 			return;
 		}
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		IntegerVersioned entity = new IntegerVersioned( "int-vers" );
 		s.save( entity );
 		s.createQuery( "select id, name, version from IntegerVersioned" ).list();
 		t.commit();
 		s.close();
 
 		Long initialId = entity.getId();
 		int initialVersion = entity.getVersion();
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "insert into IntegerVersioned ( name ) select name from IntegerVersioned" ).executeUpdate();
 		t.commit();
 		s.close();
 
 		assertEquals( "unexpected insertion count", 1, count );
 
 		s = openSession();
 		t = s.beginTransaction();
 		IntegerVersioned created = ( IntegerVersioned ) s.createQuery( "from IntegerVersioned where id <> :initialId" )
 				.setLong( "initialId", initialId.longValue() )
 				.uniqueResult();
 		t.commit();
 		s.close();
 
 		assertEquals( "version was not seeded", initialVersion, created.getVersion() );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete IntegerVersioned" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	@RequiresDialectFeature(
 			value = DialectChecks.SupportsParametersInInsertSelectCheck.class,
 			comment = "dialect does not support parameter in INSERT ... SELECT"
 	)
 	public void testInsertWithGeneratedTimestampVersion() {
 		// Make sure the env supports bulk inserts with generated ids...
 		if ( !supportsBulkInsertIdGeneration( TimestampVersioned.class ) ) {
 			SkipLog.reportSkip(
 					"bulk id generation not supported",
 					"test bulk inserts with generated id and generated timestamp"
 			);
 			return;
 		}
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		TimestampVersioned entity = new TimestampVersioned( "int-vers" );
 		s.save( entity );
 		s.createQuery( "select id, name, version from TimestampVersioned" ).list();
 		t.commit();
 		s.close();
 
 		Long initialId = entity.getId();
 		//Date initialVersion = entity.getVersion();
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "insert into TimestampVersioned ( name ) select name from TimestampVersioned" ).executeUpdate();
 		t.commit();
 		s.close();
 
 		assertEquals( "unexpected insertion count", 1, count );
 
 		s = openSession();
 		t = s.beginTransaction();
 		TimestampVersioned created = ( TimestampVersioned ) s.createQuery( "from TimestampVersioned where id <> :initialId" )
 				.setLong( "initialId", initialId.longValue() )
 				.uniqueResult();
 		t.commit();
 		s.close();
 
 		assertNotNull( created.getVersion() );
 		//assertEquals( "version was not seeded", initialVersion, created.getVersion() );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete TimestampVersioned" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testInsertWithSelectListUsingJoins() {
 		// this is just checking parsing and syntax...
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "insert into Animal (description, bodyWeight) select h.description, h.bodyWeight from Human h where h.mother.mother is not null" ).executeUpdate();
 		s.createQuery( "insert into Animal (description, bodyWeight) select h.description, h.bodyWeight from Human h join h.mother m where m.mother is not null" ).executeUpdate();
 		s.createQuery( "delete from Animal" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testIncorrectSyntax() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		try {
 			s.createQuery( "update Human set Human.description = 'xyz' where Human.id = 1 and Human.description is null" );
 			fail( "expected failure" );
 		}
 		catch( QueryException expected ) {
 			// ignore : expected behavior
 		}
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testUpdateWithWhereExistsSubquery() {
 		// multi-table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Human joe = new Human();
 		joe.setName( new Name( "Joe", 'Q', "Public" ) );
 		s.save( joe );
 		Human doll = new Human();
 		doll.setName( new Name( "Kyu", 'P', "Doll" ) );
 		doll.setFriends( new ArrayList() );
 		doll.getFriends().add( joe );
 		s.save( doll );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		String updateQryString = "update Human h " +
 		                         "set h.description = 'updated' " +
 		                         "where exists (" +
 		                         "      select f.id " +
 		                         "      from h.friends f " +
 		                         "      where f.name.last = 'Public' " +
 		                         ")";
 		int count = s.createQuery( updateQryString ).executeUpdate();
 		assertEquals( 1, count );
 		s.delete( doll );
 		s.delete( joe );
 		t.commit();
 		s.close();
 
 		// single-table (one-to-many & many-to-many) ~~~~~~~~~~~~~~~~~~~~~~~~~~
 		s = openSession();
 		t = s.beginTransaction();
 		SimpleEntityWithAssociation entity = new SimpleEntityWithAssociation();
 		SimpleEntityWithAssociation other = new SimpleEntityWithAssociation();
 		entity.setName( "main" );
 		other.setName( "many-to-many-association" );
 		entity.getManyToManyAssociatedEntities().add( other );
 		entity.addAssociation( "one-to-many-association" );
 		s.save( entity );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		// one-to-many test
 		updateQryString = "update SimpleEntityWithAssociation e " +
 		                         "set e.name = 'updated' " +
 		                         "where exists (" +
 		                         "      select a.id " +
 		                         "      from e.associatedEntities a " +
 		                         "      where a.name = 'one-to-many-association' " +
 		                         ")";
 		count = s.createQuery( updateQryString ).executeUpdate();
 		assertEquals( 1, count );
 		// many-to-many test
 		if ( getDialect().supportsSubqueryOnMutatingTable() ) {
 			updateQryString = "update SimpleEntityWithAssociation e " +
 									 "set e.name = 'updated' " +
 									 "where exists (" +
 									 "      select a.id " +
 									 "      from e.manyToManyAssociatedEntities a " +
 									 "      where a.name = 'many-to-many-association' " +
 									 ")";
 			count = s.createQuery( updateQryString ).executeUpdate();
 			assertEquals( 1, count );
 		}
 		s.delete( entity.getManyToManyAssociatedEntities().iterator().next() );
 		s.delete( entity );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testIncrementCounterVersion() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		IntegerVersioned entity = new IntegerVersioned( "int-vers" );
 		s.save( entity );
 		t.commit();
 		s.close();
 
 		int initialVersion = entity.getVersion();
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "update versioned IntegerVersioned set name = name" ).executeUpdate();
 		assertEquals( "incorrect exec count", 1, count );
 		t.commit();
 
 		t = s.beginTransaction();
 		entity = ( IntegerVersioned ) s.load( IntegerVersioned.class, entity.getId() );
 		assertEquals( "version not incremented", initialVersion + 1, entity.getVersion() );
 
 		s.delete( entity );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testIncrementTimestampVersion() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		TimestampVersioned entity = new TimestampVersioned( "ts-vers" );
 		s.save( entity );
 		t.commit();
 		s.close();
 
 		Date initialVersion = entity.getVersion();
 
 		synchronized (this) {
 			try {
 				wait(1500);
 			}
 			catch (InterruptedException ie) {}
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "update versioned TimestampVersioned set name = name" ).executeUpdate();
 		assertEquals( "incorrect exec count", 1, count );
 		t.commit();
 
 		t = s.beginTransaction();
 		entity = ( TimestampVersioned ) s.load( TimestampVersioned.class, entity.getId() );
 		assertTrue( "version not incremented", entity.getVersion().after( initialVersion ) );
 
 		s.delete( entity );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	public void testUpdateOnComponent() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Human human = new Human();
 		human.setName( new Name( "Stevee", 'X', "Ebersole" ) );
 
 		s.save( human );
 		s.flush();
 
 		t.commit();
 
 		String correctName = "Steve";
 
 		t = s.beginTransaction();
 
 		int count = s.createQuery( "update Human set name.first = :correction where id = :id" )
 				.setString( "correction", correctName )
 				.setLong( "id", human.getId().longValue() )
 				.executeUpdate();
 
 		assertEquals( "Incorrect update count", 1, count );
 
 		t.commit();
 
 		t = s.beginTransaction();
 
 		s.refresh( human );
 
 		assertEquals( "Update did not execute properly", correctName, human.getName().getFirst() );
 
 		s.createQuery( "delete Human" ).executeUpdate();
 		t.commit();
 
 		s.close();
 	}
 
 	@Test
 	public void testUpdateOnManyToOne() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		s.createQuery( "update Animal a set a.mother = null where a.id = 2" ).executeUpdate();
 		if ( ! ( getDialect() instanceof MySQLDialect ) ) {
 			// MySQL does not support (even un-correlated) subqueries against the update-mutating table
 			s.createQuery( "update Animal a set a.mother = (from Animal where id = 1) where a.id = 2" ).executeUpdate();
 		}
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testUpdateOnImplicitJoinFails() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Human human = new Human();
 		human.setName( new Name( "Steve", 'E', null ) );
 
 		Human mother = new Human();
 		mother.setName( new Name( "Jane", 'E', null ) );
 		human.setMother( mother );
 
 		s.save( human );
 		s.save( mother );
 		s.flush();
 
 		t.commit();
 
 		t = s.beginTransaction();
 		try {
 			s.createQuery( "update Human set mother.name.initial = :initial" ).setString( "initial", "F" ).executeUpdate();
 			fail( "update allowed across implicit join" );
 		}
 		catch( QueryException e ) {
 		}
 
 		s.createQuery( "delete Human where mother is not null" ).executeUpdate();
 		s.createQuery( "delete Human" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	public void testUpdateOnDiscriminatorSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update PettingZoo set name = name" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass update count", 1, count );
 
 		t.rollback();
 		t = s.beginTransaction();
 
 		count = s.createQuery( "update PettingZoo pz set pz.name = pz.name where pz.id = :id" )
 				.setLong( "id", data.pettingZoo.getId().longValue() )
 				.executeUpdate();
 		assertEquals( "Incorrect discrim subclass update count", 1, count );
 
 		t.rollback();
 		t = s.beginTransaction();
 
 		count = s.createQuery( "update Zoo as z set z.name = z.name" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass update count", 2, count );
 
 		t.rollback();
 		t = s.beginTransaction();
 
 		// TODO : not so sure this should be allowed.  Seems to me that if they specify an alias,
 		// property-refs should be required to be qualified.
 		count = s.createQuery( "update Zoo as z set name = name where id = :id" )
 				.setLong( "id", data.zoo.getId().longValue() )
 				.executeUpdate();
 		assertEquals( "Incorrect discrim subclass update count", 1, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateOnAnimal() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		int count = s.createQuery( "update Animal set description = description where description = :desc" )
 				.setString( "desc", data.frog.getDescription() )
 				.executeUpdate();
 		assertEquals( "Incorrect entity-updated count", 1, count );
 
 		count = s.createQuery( "update Animal set description = :newDesc where description = :desc" )
 				.setString( "desc", data.polliwog.getDescription() )
 				.setString( "newDesc", "Tadpole" )
 				.executeUpdate();
 		assertEquals( "Incorrect entity-updated count", 1, count );
 
 		Animal tadpole = ( Animal ) s.load( Animal.class, data.polliwog.getId() );
 		assertEquals( "Update did not take effect", "Tadpole", tadpole.getDescription() );
 
 		count = s.createQuery( "update Animal set bodyWeight = bodyWeight + :w1 + :w2" )
 				.setDouble( "w1", 1 )
 				.setDouble( "w2", 2 )
 				.executeUpdate();
 		assertEquals( "incorrect count on 'complex' update assignment", count, 6 );
 
 		if ( ! ( getDialect() instanceof MySQLDialect ) ) {
 			// MySQL does not support (even un-correlated) subqueries against the update-mutating table
 			s.createQuery( "update Animal set bodyWeight = ( select max(bodyWeight) from Animal )" )
 					.executeUpdate();
 		}
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateOnMammal() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update Mammal set description = description" ).executeUpdate();
 		assertEquals( "incorrect update count against 'middle' of joined-subclass hierarchy", 2, count );
 
 		count = s.createQuery( "update Mammal set bodyWeight = 25" ).executeUpdate();
 		assertEquals( "incorrect update count against 'middle' of joined-subclass hierarchy", 2, count );
 
 		if ( ! ( getDialect() instanceof MySQLDialect ) ) {
 			// MySQL does not support (even un-correlated) subqueries against the update-mutating table
 			count = s.createQuery( "update Mammal set bodyWeight = ( select max(bodyWeight) from Animal )" ).executeUpdate();
 			assertEquals( "incorrect update count against 'middle' of joined-subclass hierarchy", 2, count );
 		}
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateSetNullUnionSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		// These should reach out into *all* subclass tables...
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update Vehicle set owner = 'Steve'" ).executeUpdate();
 		assertEquals( "incorrect restricted update count", 4, count );
 		count = s.createQuery( "update Vehicle set owner = null where owner = 'Steve'" ).executeUpdate();
 		assertEquals( "incorrect restricted update count", 4, count );
 
 		try {
 			count = s.createQuery( "delete Vehicle where owner is null" ).executeUpdate();
 			assertEquals( "incorrect restricted delete count", 4, count );
 		}
 		catch ( AssertionFailedError afe ) {
 			if ( H2Dialect.class.isInstance( getDialect() ) ) {
 				// http://groups.google.com/group/h2-database/t/5548ff9fd3abdb7
 				// this is fixed in H2 1.2.140
 				count = s.createQuery( "delete Vehicle" ).executeUpdate();
 				assertEquals( "incorrect count", 4, count );
 			}
 			else {
 				throw afe;
 			}
 		}
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateSetNullOnDiscriminatorSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update PettingZoo set address.city = null" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 		count = s.createQuery( "delete Zoo where address.city is null" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 
 		count = s.createQuery( "update Zoo set address.city = null" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 		count = s.createQuery( "delete Zoo where address.city is null" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateSetNullOnJoinedSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update Mammal set bodyWeight = null" ).executeUpdate();
 		assertEquals( "Incorrect deletion count on joined subclass", 2, count );
 
 		count = s.createQuery( "delete Animal where bodyWeight = null" ).executeUpdate();
 		assertEquals( "Incorrect deletion count on joined subclass", 2, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testDeleteWithSubquery() {
 		// setup the test data...
 		Session s = openSession();
 		s.beginTransaction();
 		SimpleEntityWithAssociation owner = new SimpleEntityWithAssociation( "myEntity-1" );
 		owner.addAssociation( "assoc-1" );
 		owner.addAssociation( "assoc-2" );
 		owner.addAssociation( "assoc-3" );
 		s.save( owner );
 		SimpleEntityWithAssociation owner2 = new SimpleEntityWithAssociation( "myEntity-2" );
 		owner2.addAssociation( "assoc-1" );
 		owner2.addAssociation( "assoc-2" );
 		owner2.addAssociation( "assoc-3" );
 		owner2.addAssociation( "assoc-4" );
 		s.save( owner2 );
 		SimpleEntityWithAssociation owner3 = new SimpleEntityWithAssociation( "myEntity-3" );
 		s.save( owner3 );
 		s.getTransaction().commit();
 		s.close();
 
 		// now try the bulk delete
 		s = openSession();
 		s.beginTransaction();
 		int count = s.createQuery( "delete SimpleEntityWithAssociation e where size( e.associatedEntities ) = 0 and e.name like '%'" ).executeUpdate();
 		assertEquals( "incorrect delete count", 1, count );
 		s.getTransaction().commit();
 		s.close();
 
 		// finally, clean up
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete SimpleAssociatedEntity" ).executeUpdate();
 		s.createQuery( "delete SimpleEntityWithAssociation" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	@RequiresDialectFeature(
 			value = DialectChecks.HasSelfReferentialForeignKeyBugCheck.class,
 			comment = "self referential FK bug"
 	)
 	public void testSimpleDeleteOnAnimal() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "delete from Animal as a where a.id = :id" )
 				.setLong( "id", data.polliwog.getId().longValue() )
 				.executeUpdate();
 		assertEquals( "Incorrect delete count", 1, count );
 
 		count = s.createQuery( "delete Animal where id = :id" )
 				.setLong( "id", data.catepillar.getId().longValue() )
 				.executeUpdate();
 		assertEquals( "incorrect delete count", 1, count );
 
 		if ( getDialect().supportsSubqueryOnMutatingTable() ) {
 			count = s.createQuery( "delete from User u where u not in (select u from User u)" ).executeUpdate();
 			assertEquals( 0, count );
 		}
 
 		count = s.createQuery( "delete Animal a" ).executeUpdate();
 		assertEquals( "Incorrect delete count", 4, count );
 
 		List list = s.createQuery( "select a from Animal as a" ).list();
 		assertTrue( "table not empty", list.isEmpty() );
 
 		t.commit();
 		s.close();
 		data.cleanup();
 	}
 
 	@Test
 	public void testDeleteOnDiscriminatorSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "delete PettingZoo" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 
 		count = s.createQuery( "delete Zoo" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/CriteriaHQLAlignmentTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/CriteriaHQLAlignmentTest.java
index bd2c7902bd..3f72640ab7 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/CriteriaHQLAlignmentTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/CriteriaHQLAlignmentTest.java
@@ -1,385 +1,386 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
+
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Collections;
 
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 import org.hibernate.criterion.Projections;
 import org.hibernate.exception.SQLGrammarException;
 import org.hibernate.hql.QueryTranslator;
 import org.hibernate.hql.QueryTranslatorFactory;
 import org.hibernate.hql.ast.QueryTranslatorImpl;
 import org.hibernate.hql.ast.tree.SelectClause;
 import org.hibernate.hql.classic.ClassicQueryTranslatorFactory;
 import org.hibernate.type.BigDecimalType;
 import org.hibernate.type.BigIntegerType;
 import org.hibernate.type.DoubleType;
 import org.hibernate.type.LongType;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.testing.TestForIssue;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 
 /**
  * Tests cases for ensuring alignment between HQL and Criteria behavior. 
  *
  * @author Max Rydahl Andersen
  */
 public class CriteriaHQLAlignmentTest extends QueryTranslatorTestCase {
 	private boolean initialVersion2SqlFlagValue;
 
 	@Before
 	public void setVersion2SqlFlag() {
 		initialVersion2SqlFlagValue = SelectClause.VERSION2_SQL;
 		SelectClause.VERSION2_SQL = true;
 	}
 
 	@After
 	public void resetVersion2SqlFlag() {
 		SelectClause.VERSION2_SQL = initialVersion2SqlFlagValue;
 	}
 
 	@Override
 	public String[] getMappings() {
 			return new String[] {
 					"hql/Animal.hbm.xml",
 			};
 	}
 
 	@Override
 	public boolean createSchema() {
 		return true; // needed for the Criteria return type test
 	}
 
 	@Override
 	public boolean rebuildSessionFactoryOnError() {
 		return true;
 	}
 
 	@Test
 	public void testHQLAggregationReturnType() {
 		// EJB3: COUNT returns Long
 		QueryTranslatorImpl translator = createNewQueryTranslator( "select count(*) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", LongType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		translator = createNewQueryTranslator( "select count(h.heightInches) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", LongType.INSTANCE, translator.getReturnTypes()[0] );
 				
 		// MAX, MIN return the type of the state-field to which they are applied. 
 		translator = createNewQueryTranslator( "select max(h.heightInches) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		translator = createNewQueryTranslator( "select max(h.id) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", LongType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		// AVG returns Double.
 		translator = createNewQueryTranslator( "select avg(h.heightInches) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		translator = createNewQueryTranslator( "select avg(h.id) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		translator = createNewQueryTranslator( "select avg(h.bigIntegerValue) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 		
         // SUM returns Long when applied to state-fields of integral types (other than BigInteger);
  	    translator = createNewQueryTranslator( "select sum(h.id) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", LongType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		translator = createNewQueryTranslator( "select sum(h.intValue) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", LongType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		// SUM returns Double when applied to state-fields of floating point types; 
 		translator = createNewQueryTranslator( "select sum(h.heightInches) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 
 		translator = createNewQueryTranslator( "select sum(h.floatValue) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 		
 	    // SUM returns BigInteger when applied to state-fields of type BigInteger 
 		translator = createNewQueryTranslator( "select sum(h.bigIntegerValue) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", BigIntegerType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		// SUM and BigDecimal when applied to state-fields of type BigDecimal.
 		translator = createNewQueryTranslator( "select sum(h.bigDecimalValue) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", BigDecimalType.INSTANCE, translator.getReturnTypes()[0] );
 
 		// special case to test classicquery special case handling of count(*)
 		String hql = "select count(*) from Human h";
 		QueryTranslatorFactory classic = new ClassicQueryTranslatorFactory();
 		QueryTranslator oldQueryTranslator = classic.createQueryTranslator( hql, hql, Collections.EMPTY_MAP, sessionFactory() );
 		oldQueryTranslator.compile( Collections.EMPTY_MAP, true);
 		assertEquals( "incorrect return type count", 1, oldQueryTranslator.getReturnTypes().length );
 		assertEquals( "incorrect return type", LongType.INSTANCE, oldQueryTranslator.getReturnTypes()[0] );
 
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-1724" )
 	public void testCriteriaAggregationReturnType() {
 		Session s = openSession();
 		s.beginTransaction();
 		Human human = new Human();
 		human.setBigIntegerValue( new BigInteger("42") );
 		human.setBigDecimalValue( new BigDecimal(45) );
 		s.save(human);
 		s.flush();
 		s.clear();
 		// EJB3: COUNT returns Long
 		Long longValue = (Long) s.createCriteria( Human.class ).setProjection( Projections.rowCount()).uniqueResult();
 		assertEquals(longValue, new Long(1));
 		longValue = (Long) s.createCriteria( Human.class ).setProjection( Projections.count("heightInches")).uniqueResult();
 		assertEquals(longValue, new Long(1));
 		
 		 // MAX, MIN return the type of the state-field to which they are applied. 		
 		Double dblValue = (Double) s.createCriteria( Human.class ).setProjection( Projections.max( "heightInches" )).uniqueResult();
 		assertNotNull(dblValue);
 		
 		longValue = (Long) s.createCriteria( Human.class ).setProjection( Projections.max( "id" )).uniqueResult();
 		assertNotNull(longValue);
 		
 		// AVG returns Double.
 		dblValue = (Double) s.createCriteria( Human.class ).setProjection( Projections.avg( "heightInches" )).uniqueResult();
 		assertNotNull(dblValue);
 		
 		dblValue = (Double) s.createCriteria( Human.class ).setProjection( Projections.avg( "id" )).uniqueResult();
 		assertNotNull(dblValue);
 		
 		dblValue = (Double) s.createCriteria( Human.class ).setProjection( Projections.avg( "bigIntegerValue" )).uniqueResult();
 		assertNotNull(dblValue);
 		
         // SUM returns Long when applied to state-fields of integral types (other than BigInteger);
 		longValue = (Long) s.createCriteria( Human.class ).setProjection( Projections.sum( "id" )).uniqueResult();
 		assertNotNull(longValue);
 		
 		longValue = (Long) s.createCriteria( Human.class ).setProjection( Projections.sum( "intValue" )).uniqueResult();
 		assertNotNull(longValue);
 		
 		// SUM returns Double when applied to state-fields of floating point types; 
 		dblValue = (Double) s.createCriteria( Human.class ).setProjection( Projections.sum( "heightInches" )).uniqueResult();
 		assertNotNull(dblValue);
 		
 		dblValue = (Double) s.createCriteria( Human.class ).setProjection( Projections.sum( "floatValue" )).uniqueResult();
 		assertNotNull(dblValue);
 		
 	    // SUM returns BigInteger when applied to state-fields of type BigInteger 
 		BigInteger bigIValue = (BigInteger) s.createCriteria( Human.class ).setProjection( Projections.sum( "bigIntegerValue" )).uniqueResult();
 		assertNotNull(bigIValue);
 		
 		// SUM and BigDecimal when applied to state-fields of type BigDecimal.
 		BigDecimal bigDValue = (BigDecimal) s.createCriteria( Human.class ).setProjection( Projections.sum( "bigDecimalValue" )).uniqueResult();
 		assertNotNull(bigDValue);
 		
 		s.delete( human );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCountReturnValues() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Human human1 = new Human();
 		human1.setName( new Name( "John", 'Q', "Public" ) );
 		human1.setNickName( "Johnny" );
 		s.save(human1);
 		Human human2 = new Human();
 		human2.setName( new Name( "John", 'A', "Doe" ) );
 		human2.setNickName( "Johnny" );
 		s.save( human2 );
 		Human human3 = new Human();
 		human3.setName( new Name( "John", 'A', "Doe" ) );
 		human3.setNickName( "Jack" );
 		s.save( human3 );
 		Human human4 = new Human();
 		human4.setName( new Name( "John", 'A', "Doe" ) );
 		s.save( human4 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 
 		Long count = ( Long ) s.createQuery( "select count( * ) from Human" ).uniqueResult();
 		assertEquals( 4, count.longValue() );
 		s.clear();
 		count = ( Long ) s.createCriteria( Human.class )
 				.setProjection( Projections.rowCount() )
 				.uniqueResult();
 		assertEquals( 4, count.longValue() );
 		s.clear();
 
 		count = ( Long ) s.createQuery( "select count( nickName ) from Human" ).uniqueResult();
 		assertEquals( 3, count.longValue() );
 		s.clear();
 		count = ( Long ) s.createCriteria( Human.class )
 				.setProjection( Projections.count( "nickName" ) )
 				.uniqueResult();
 		assertEquals( 3, count.longValue() );
 		s.clear();
 
 		count = ( Long ) s.createQuery( "select count( distinct nickName ) from Human" ).uniqueResult();
 		assertEquals( 2, count.longValue() );
 		s.clear();
 		count = ( Long ) s.createCriteria( Human.class )
 				.setProjection( Projections.count( "nickName" ).setDistinct() )
 				.uniqueResult();
 		assertEquals( 2, count.longValue() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		try {
 			count = ( Long ) s.createQuery( "select count( distinct name ) from Human" ).uniqueResult();
 			if ( ! getDialect().supportsTupleDistinctCounts() ) {
 				fail( "expected SQLGrammarException" );
 			}
 			assertEquals( 2, count.longValue() );
 		}
 		catch ( SQLGrammarException ex ) {
 			if ( ! getDialect().supportsTupleDistinctCounts() ) {
 				// expected
 			}
 			else {
 				throw ex;
 			}
 		}
 		finally {
 			t.rollback();
 			s.close();
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		try {
 			count = ( Long ) s.createCriteria( Human.class )
 					.setProjection( Projections.count( "name" ).setDistinct() )
 					.uniqueResult();
 			if ( ! getDialect().supportsTupleDistinctCounts() ) {
 				fail( "expected SQLGrammarException" );
 			}
 			assertEquals( 2, count.longValue() );
 		}
 		catch ( SQLGrammarException ex ) {
 			if ( ! getDialect().supportsTupleDistinctCounts() ) {
 				// expected
 			}
 			else {
 				throw ex;
 			}
 		}
 		finally {
 			t.rollback();
 			s.close();
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		count = ( Long ) s.createQuery( "select count( distinct name.first ) from Human" ).uniqueResult();
 		assertEquals( 1, count.longValue() );
 		s.clear();
 		count = ( Long ) s.createCriteria( Human.class )
 				.setProjection( Projections.count( "name.first" ).setDistinct() )
 				.uniqueResult();
 		assertEquals( 1, count.longValue() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		try {
 			count = ( Long ) s.createQuery( "select count( name ) from Human" ).uniqueResult();
 			if ( ! getDialect().supportsTupleCounts() ) {
 				fail( "expected SQLGrammarException" );
 			}
 			assertEquals( 1, count.longValue() );
 		}
 		catch ( SQLGrammarException ex ) {
 			if ( ! getDialect().supportsTupleCounts() ) {
 				// expected
 			}
 			else {
 				throw ex;
 			}
 		}
 		finally {
 			t.rollback();
 			s.close();
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		try {
 			count = ( Long ) s.createCriteria( Human.class )
 					.setProjection( Projections.count( "name" ) )
 					.uniqueResult();
 			if ( ! getDialect().supportsTupleCounts() ) {
 				fail( "expected SQLGrammarException" );
 			}
 			assertEquals( 1, count.longValue() );
 		}
 		catch ( SQLGrammarException ex ) {
 			if ( ! getDialect().supportsTupleCounts() ) {
 				// expected
 			}
 			else {
 				throw ex;
 			}
 		}
 		finally {
 			t.rollback();
 			s.close();
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete from Human" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/TestCustomColumnReadAndWrite.java b/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/TestCustomColumnReadAndWrite.java
index 302bb3efc2..8319f2eb7b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/TestCustomColumnReadAndWrite.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/TestCustomColumnReadAndWrite.java
@@ -1,64 +1,67 @@
 package org.hibernate.test.instrument.cases;
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertTrue;
+
 import org.hibernate.Hibernate;
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
+
 import org.hibernate.test.instrument.domain.Document;
 import org.hibernate.test.instrument.domain.Folder;
 import org.hibernate.test.instrument.domain.Owner;
 
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertTrue;
+
 /**
  * @author Rob.Hasselbaum
  */
 public class TestCustomColumnReadAndWrite extends AbstractExecutable {
 	public void execute() {
 		Session s = getFactory().openSession();
 		Transaction t = s.beginTransaction();
 		final double SIZE_IN_KB = 20480;
 		final double SIZE_IN_MB = SIZE_IN_KB / 1024d;
 		Owner o = new Owner();
 		Document doc = new Document();
 		Folder fol = new Folder();
 		o.setName("gavin");
 		doc.setName("Hibernate in Action");
 		doc.setSummary("blah");
 		doc.updateText("blah blah");	
 		fol.setName("books");
 		doc.setOwner(o);
 		doc.setFolder(fol);
 		doc.setSizeKb(SIZE_IN_KB);
 		fol.getDocuments().add(doc);
 		s.persist(o);
 		s.persist(fol);
 		t.commit();
 		s.close();
 
 		s = getFactory().openSession();
 		t = s.beginTransaction();
 		
 		// Check value conversion on insert
 		Double sizeViaSql = (Double)s.createSQLQuery("select size_mb from documents").uniqueResult();
 		assertEquals( SIZE_IN_MB, sizeViaSql, 0.01d );
 
 		// Test explicit fetch of all properties
 		doc = (Document) s.createQuery("from Document fetch all properties").uniqueResult();
 		assertTrue( Hibernate.isPropertyInitialized( doc, "sizeKb" ) );
 		assertEquals( SIZE_IN_KB, doc.getSizeKb() );
 		t.commit();
 		s.close();		
 
 		// Test lazy fetch with custom read
 		s = getFactory().openSession();
 		t = s.beginTransaction();
 		doc = (Document) s.get( Document.class, doc.getId() );
 		assertFalse( Hibernate.isPropertyInitialized( doc, "sizeKb" ) );
 		assertEquals( SIZE_IN_KB, doc.getSizeKb() );
 		s.delete(doc);
 		s.delete( doc.getOwner() );
 		s.delete( doc.getFolder() );
 		t.commit();
 		s.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/A.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/A.java
index 04a36806ec..a85879a761 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/A.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/A.java
@@ -1,56 +1,63 @@
 package org.hibernate.test.legacy;
 
 
 
 public class A {
 	private Long id;
 	private String name;
 	private E forward;
-	
+
+	public A() {
+	}
+
+	public A(Long id) {
+		this.id = id;
+	}
+
 	/**
 	 * Returns the id.
 	 * @return Long
 	 */
 	public Long getId() {
 		return id;
 	}
 	
 	/**
 	 * Returns the name.
 	 * @return String
 	 */
 	public String getName() {
 		return name;
 	}
 	
 	/**
 	 * Sets the id.
 	 * @param id The id to set
 	 */
 	public void setId(Long id) {
 		this.id = id;
 	}
 	
 	/**
 	 * Sets the name.
 	 * @param name The name to set
 	 */
 	public void setName(String name) {
 		this.name = name;
 	}
 	
 	public E getForward() {
 		return forward;
 	}
 
 	public void setForward(E e) {
 		forward = e;
 	}
 
 }
 
 
 
 
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/ABC.hbm.xml b/hibernate-core/src/test/java/org/hibernate/test/legacy/ABC.hbm.xml
index 8e351ed23d..f19c895009 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/ABC.hbm.xml
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/ABC.hbm.xml
@@ -1,55 +1,59 @@
 <?xml version="1.0"?>
 <!DOCTYPE hibernate-mapping PUBLIC 
 	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
 	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
 <hibernate-mapping default-lazy="false">
 
 	<class name="org.hibernate.test.legacy.A" discriminator-value="0" lazy="true" table="TA">
 		<id name = "id" column="identifier_column" unsaved-value = "null">
 			<generator class="increment"/>
 		</id>
 		<discriminator column="clazz_discriminata" type="integer" not-null="false"/>
 
 		<property name="name" index="indx_a_name">
 			<column name="name" index="indx_a_name2"/>
 		</property>
 
 		<subclass name="org.hibernate.test.legacy.B" discriminator-value="-1" lazy="true">
 			<property name="count" column="count_"/>
 			<join fetch="select" table="B2">
 				<key column="bid"/>
 				<property name="BName" not-null="true"/>
 			</join>
 			<subclass name="org.hibernate.test.legacy.C1" discriminator-value="null" lazy="true">
 				<property name="address" column="c1"/>
 				<one-to-one name="d"/>
 				<join table="cmore" fetch="select">
 					<key column="c1" on-delete="cascade"/>
 					<property name="C1Name"/>
 				</join>
 			</subclass>
 		</subclass>
 	</class>
 
 	<class name="org.hibernate.test.legacy.D" discriminator-value="0" proxy="org.hibernate.test.legacy.D" table="TD">
 		<id name = "id" unsaved-value = "null">
 			<generator class="assigned"/>
 		</id>
 		<property name="amount"/>
+        <!-- these definitions both relied on the ability to save A with alternate assigned id
 		<many-to-one name="reverse" insert="false" update="false" outer-join="true">
 			<formula>(id)</formula>
 		</many-to-one>
 		<many-to-one name="inverse" access="field" insert="false" update="false" formula = "(id)" outer-join="true"/>
+		-->
+        <many-to-one name="reverse" column="rev_a_id" outer-join="true"/>
+        <many-to-one name="inverse" access="field" column="inv_a_id" outer-join="true"/>
 		<!--many-to-one name="reverse" formula = "(select a.id from TA a where a.id = id)"/-->
 	</class>
 	
 	<sql-query name="propertyResultDiscriminator">
 		<return alias="a" class="org.hibernate.test.legacy.A">
   			<return-discriminator column="clazz"/>
 			<return-property name="id" column="identifier_column"/>
 			<return-property name="name" column="name"/>
 			<return-property name="count" column="count_"/>
 		</return>
 		select identifier_column, clazz_discriminata as clazz, name, count_ from TA s
 	</sql-query>
 </hibernate-mapping>
\ No newline at end of file
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/ABCProxyTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/ABCProxyTest.java
index 9608eb58e6..615584856c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/ABCProxyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/ABCProxyTest.java
@@ -1,321 +1,328 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
+
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.Hibernate;
 import org.hibernate.LockMode;
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 import org.hibernate.dialect.HSQLDialect;
 
 import org.junit.Test;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 
 public class ABCProxyTest extends LegacyTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] {  "legacy/ABCProxy.hbm.xml" };
 	}
 
 	@Test
 	public void testDiscriminatorFiltering() throws Exception {
 		if ( ( getDialect() instanceof HSQLDialect ) ) return;
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.createQuery("from C1 c1 left join c1.c2s c2").list();
 		s.createCriteria(C1.class).createCriteria("c2s").list();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testNarrow() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.createQuery("from E e join e.reverse as b where b.count=1").list();
 		s.createQuery("from E e join e.as as b where b.count=1").list();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSharedColumn() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		C1 c1 = new C1();
 		C2 c2 = new C2();
 		c1.setC2(c2);
 		c2.setC1(c1);
 		s.save(c1); s.save(c2);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List list = s.createQuery( "from B" ).list();
 		assertTrue( list.size()==2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c1 = (C1) s.createQuery("from C1").uniqueResult();
 		c2 = (C2) s.createQuery("from C2").uniqueResult();
 		assertTrue( c1.getC2()==c2 );
 		assertTrue( c2.getC1()==c1 );
 		assertTrue( c1.getC2s().contains(c2) );
 		assertTrue( c2.getC1s().contains(c1) );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c1 = (C1) s.get( A.class, c1.getId() );
 		c2 = (C2) s.get( A.class, c2.getId() );
 		assertTrue( c1.getC2()==c2 );
 		assertTrue( c2.getC1()==c1 );
 		assertTrue( c1.getC2s().contains(c2) );
 		assertTrue( c2.getC1s().contains(c1) );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete(c1); s.delete(c2);
 		t.commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testSubclassing() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		C1 c1 = new C1();
 		D d = new D();
 		d.setAmount(213.34f);
 		c1.setAddress("foo bar");
 		c1.setCount(23432);
 		c1.setName("c1");
 		c1.setD(d);
 		s.save(c1);
 		d.setId( c1.getId() );
 		s.save(d);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		A c1a = (A) s.load( A.class, c1.getId() );
 		assertFalse( Hibernate.isInitialized(c1a) );
 		assertTrue( c1a.getName().equals("c1") );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		B c1b = (B) s.load( B.class, c1.getId() );
 		assertTrue(
 			(c1b.getCount()==23432) &&
 			c1b.getName().equals("c1")
 		);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c1 = (C1) s.load( C1.class, c1.getId() );
 		assertTrue(
 			c1.getAddress().equals("foo bar") &&
 			(c1.getCount()==23432) &&
 			c1.getName().equals("c1") &&
 			c1.getD().getAmount()>213.3f
 		);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c1a = (A) s.load( A.class, c1.getId() );
 		assertTrue( c1a.getName().equals("c1") );
 		c1 = (C1) s.load( C1.class, c1.getId() );
 		assertTrue(
 			c1.getAddress().equals("foo bar") &&
 			(c1.getCount()==23432) &&
 			c1.getName().equals("c1") &&
 			c1.getD().getAmount()>213.3f
 		);
 		c1b = (B) s.load( B.class, c1.getId() );
 		assertTrue(
 			(c1b.getCount()==23432) &&
 			c1b.getName().equals("c1")
 		);
 		assertTrue( c1a.getName().equals("c1") );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c1a = (A) s.load( A.class, c1.getId() );
 		assertTrue( c1a.getName().equals("c1") );
 		c1 = (C1) s.load( C1.class, c1.getId(), LockMode.UPGRADE );
 		assertTrue(
 			c1.getAddress().equals("foo bar") &&
 			(c1.getCount()==23432) &&
 			c1.getName().equals("c1") &&
 			c1.getD().getAmount()>213.3f
 		);
 		c1b = (B) s.load( B.class, c1.getId(), LockMode.UPGRADE );
 		assertTrue(
 			(c1b.getCount()==23432) &&
 			c1b.getName().equals("c1")
 		);
 		assertTrue( c1a.getName().equals("c1") );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c1a = (A) s.load( A.class, c1.getId() );
 		c1 = (C1) s.load( C1.class, c1.getId() );
 		c1b = (B) s.load( B.class, c1.getId() );
 		assertTrue( c1a.getName().equals("c1") );
 		assertTrue(
 			c1.getAddress().equals("foo bar") &&
 			(c1.getCount()==23432) &&
 			c1.getName().equals("c1") &&
 			c1.getD().getAmount()>213.3f
 		);
 		assertTrue(
 			(c1b.getCount()==23432) &&
 			c1b.getName().equals("c1")
 		);
-		System.out.println( s.delete("from A") );
+		for ( Object a : s.createQuery( "from A" ).list() ) {
+			s.delete( a );
+		}
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.save( new B() );
 		s.save( new A() );
 		assertTrue( s.createQuery( "from B" ).list().size()==1 );
 		assertTrue( s.createQuery( "from A" ).list().size()==2 );
-		s.delete("from A");
+		for ( Object a : s.createQuery( "from A" ).list() ) {
+			s.delete( a );
+		}
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSubclassMap() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		B b = new B();
 		s.save(b);
 		Map map = new HashMap();
 		map.put("3", new Integer(1) );
 		b.setMap(map);
 		s.flush();
 		s.delete(b);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		map = new HashMap();
 		map.put("3", new Integer(1) );
 		b = new B();
 		b.setMap(map);
 		s.save(b);
 		s.flush();
 		s.delete(b);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testOneToOne() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		A a = new A();
 		E d1 = new E();
 		C1 c = new C1();
 		E d2 = new E();
 		a.setForward(d1);
 		d1.setReverse(a);
 		c.setForward(d2);
 		d2.setReverse(c);
 		Serializable aid = s.save(a);
 		Serializable d2id = s.save(d2);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		List l = s.find( "from E e, A a where e.reverse = a.forward and a = ?", a, Hibernate.entity(A.class) );
+		List l = s.createQuery( "from E e, A a where e.reverse = a.forward and a = ?" )
+				.setEntity( 0, a )
+				.list();
 		assertTrue( l.size()==1 );
 		l = s.createQuery( "from E e join fetch e.reverse" ).list();
 		assertTrue( l.size()==2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		l = s.createQuery( "from E e" ).list();
 		assertTrue( l.size()==2 );
 		E e = (E) l.get(0);
 		assertTrue( e==e.getReverse().getForward() );
 		e = (E) l.get(1);
 		assertTrue( e==e.getReverse().getForward() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		a = (A) s.load(A.class, aid);
 		d2 = (E) s.load(E.class, d2id);
 		assertTrue( a==a.getForward().getReverse() );
 		assertTrue( d2==d2.getReverse().getForward() );
 		s.delete(a);
 		s.delete( a.getForward() );
 		s.delete(d2);
 		s.delete( d2.getReverse() );
 		t.commit();
 
 		s = openSession();
 		t = s.beginTransaction();
 		l = s.createQuery( "from E e" ).list();
 		assertTrue( l.size()==0 );
 		t.commit();
 		s.close();
 	}
 
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/ABCTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/ABCTest.java
index 3fab53fbaf..72281e2a45 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/ABCTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/ABCTest.java
@@ -1,179 +1,183 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
+
 import java.util.List;
 
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
+@SuppressWarnings( {"UnnecessaryBoxing"})
 public class ABCTest extends LegacyTestCase {
 	public String[] getMappings() {
 		return new String[] { "legacy/ABC.hbm.xml", "legacy/ABCExtends.hbm.xml" };
 	}
 
 	@Test
 	public void testFormulaAssociation() throws Throwable {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		D d = new D();
-		Long did = new Long(12);
-		s.save(d, did);
+		Long did = Long.valueOf(12);
+		D d = new D( did );
+		s.save(d);
 		A a = new A();
 		a.setName("a");
-		s.save(a, did);
+		s.save( a );
+		d.setReverse( a );
+		d.inverse = a;
 		t.commit();
 		s.close();
 		
 		s = openSession();
 		t = s.beginTransaction();
 		d = (D) s.get(D.class, did);
-		assertTrue(d.getReverse().getId().equals(did));
+		assertNotNull( d.getReverse() );
 		s.clear();
-		sessionFactory().evict(D.class);
-		sessionFactory().evict(A.class);
+		sessionFactory().getCache().evictEntityRegion( D.class );
+		sessionFactory().getCache().evictEntityRegion(A.class);
 		d = (D) s.get(D.class, did);
-		assertTrue(d.inverse.getId().equals(did));
+		assertNotNull( d.inverse );
 		assertTrue(d.inverse.getName().equals("a"));
 		s.clear();
-		sessionFactory().evict(D.class);
-		sessionFactory().evict(A.class);
+		sessionFactory().getCache().evictEntityRegion( D.class );
+		sessionFactory().getCache().evictEntityRegion( A.class );
 		assertTrue( s.createQuery( "from D d join d.reverse r join d.inverse i where i = r" ).list().size()==1 );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testHigherLevelIndexDefinition() throws Throwable {
 		String[] commands = configuration().generateSchemaCreationScript( getDialect() );
 		int max = commands.length;
 		boolean found = false;
 		for (int indx = 0; indx < max; indx++) {
 			System.out.println("Checking command : " + commands[indx]);
 			found = commands[indx].indexOf("create index indx_a_name") >= 0;
 			if (found)
 				break;
 		}
 		assertTrue("Unable to locate indx_a_name index creation", found);
 	}
 
 	@Test
 	public void testSubclassing() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		C1 c1 = new C1();
 		D d = new D();
 		d.setAmount(213.34f);
 		c1.setAddress("foo bar");
 		c1.setCount(23432);
 		c1.setName("c1");
 		c1.setBName("a funny name");
 		c1.setD(d);
 		s.save(c1);
 		d.setId( c1.getId() );
 		s.save(d);
 
 		assertTrue( s.createQuery( "from C2 c where 1=1 or 1=1" ).list().size()==0 );
 
 		t.commit();
 		s.close();
 
-		sessionFactory().evict(A.class);
+		sessionFactory().getCache().evictEntityRegion( A.class );
 		
 		s = openSession();
 		t = s.beginTransaction();
 		c1 = (C1) s.get( A.class, c1.getId() );
 		assertTrue(
 			c1.getAddress().equals("foo bar") &&
 			(c1.getCount()==23432) &&
 			c1.getName().equals("c1") &&
 			c1.getD().getAmount()>213.3f
 		);
 		assertEquals( "a funny name", c1.getBName() );
 		t.commit();
 		s.close();
 		
-		sessionFactory().evict(A.class);
+		sessionFactory().getCache().evictEntityRegion( A.class );
 
 		s = openSession();
 		t = s.beginTransaction();
 		c1 = (C1) s.get( B.class, c1.getId() );
 		assertTrue(
 			c1.getAddress().equals("foo bar") &&
 			(c1.getCount()==23432) &&
 			c1.getName().equals("c1") &&
 			c1.getD().getAmount()>213.3f
 		);
 		assertEquals( "a funny name", c1.getBName() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c1 = (C1) s.load( C1.class, c1.getId() );
 		assertTrue(
 			c1.getAddress().equals("foo bar") &&
 			(c1.getCount()==23432) &&
 			c1.getName().equals("c1") &&
 			c1.getD().getAmount()>213.3f
 		);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List bs = s.createQuery("from B").list();
 		for (int i=0; i<bs.size(); i++) {
 			C1 b = (C1) bs.get(i);
 			s.delete(b);
 			s.delete( b.getD() );
 		}
 		t.commit();
 		s.close();
 	}
 	
 	@Test
 	public void testGetSave() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		assertNull( s.get( D.class, new Long(1) ) );
+		assertNull( s.get( D.class, Long.valueOf(1) ) );
 		D d = new D();
-		d.setId( new Long(1) );
+		d.setId( Long.valueOf(1) );
 		s.save(d);
 		s.flush();
-		assertNotNull( s.get( D.class, new Long(1) ) );
+		assertNotNull( s.get( D.class, Long.valueOf(1) ) );
 		s.delete(d);
 		s.flush();
 		t.commit();
 		s.close();
 	}
 
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/AltSimple.hbm.xml b/hibernate-core/src/test/java/org/hibernate/test/legacy/AltSimple.hbm.xml
index 5636ee6dc0..0bdb776c8e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/AltSimple.hbm.xml
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/AltSimple.hbm.xml
@@ -1,20 +1,20 @@
 <?xml version="1.0"?>
 <!DOCTYPE hibernate-mapping PUBLIC 
 	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
 	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
 <hibernate-mapping default-lazy="false">
 
     <class name="org.hibernate.test.legacy.Simple" table="SIMP">
-        <id type="long" column="id_">
+        <id name="id" type="long" column="id_">
             <generator class="assigned"/>
         </id>
         <property name="name"/>
         <property name="address"/>
         <property name="count" column="count_" not-null="true" unique="true"/> 
         <property name="date" column="date_"/>
         <property name="pay"/>
         <many-to-one name="other"/>
     </class>
     
 
 </hibernate-mapping>
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/CustomSQLTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/CustomSQLTest.java
index 113237815a..57506ca7dd 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/CustomSQLTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/CustomSQLTest.java
@@ -1,214 +1,215 @@
 //$Id: CustomSQLTest.java 10977 2006-12-12 23:28:04Z steve.ebersole@jboss.com $
 package org.hibernate.test.legacy;
+
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.hibernate.HibernateException;
-import org.hibernate.classic.Session;
+import org.hibernate.Session;
 import org.hibernate.id.PostInsertIdentifierGenerator;
 
 import org.junit.Test;
 
 import org.hibernate.testing.SkipLog;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author MAX
  *
  */
 public class CustomSQLTest extends LegacyTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "legacy/CustomSQL.hbm.xml" };
 	}
 
 	private boolean isUsingIdentity() {
 		return PostInsertIdentifierGenerator.class.isAssignableFrom( getDialect().getNativeIdentifierGeneratorClass() );
 	}
 
 	@Test
 	public void testInsert() throws HibernateException, SQLException {
 		if ( isUsingIdentity() ) {
 			SkipLog.reportSkip( "hand sql expecting non-identity id gen", "Custom SQL" );
 			return;
 		}
 
 		Role p = new Role();
 
 		p.setName("Patient");
 
 		Session s = openSession();
 
 		s.save(p);
 		s.flush();
 
 		s.connection().commit();
 		s.close();
 
 		sessionFactory().evict(Role.class);
 		s = openSession();
 
 		Role p2 = (Role) s.get(Role.class, new Long(p.getId()));
 		assertNotSame(p, p2);
 		assertEquals(p2.getId(),p.getId());
 		assertTrue(p2.getName().equalsIgnoreCase(p.getName()));
 		s.delete(p2);
 		s.flush();
 
 
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testJoinedSubclass() throws HibernateException, SQLException {
 		Medication m = new Medication();
 
 		m.setPrescribedDrug(new Drug());
 
 		m.getPrescribedDrug().setName("Morphine");
 
 
 		Session s = openSession();
 
 		s.save(m.getPrescribedDrug());
 		s.save(m);
 
 		s.flush();
 		s.connection().commit();
 		s.close();
 		s = openSession();
 
 		Medication m2  = (Medication) s.get(Medication.class, m.getId());
 		assertNotSame(m, m2);
 
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testCollectionCUD() throws HibernateException, SQLException {
 		if ( isUsingIdentity() ) {
 			SkipLog.reportSkip( "hand sql expecting non-identity id gen", "Custom SQL" );
 			return;
 		}
 
 		Role role = new Role();
 
 		role.setName("Jim Flanders");
 
 		Intervention iv = new Medication();
 		iv.setDescription("JF medical intervention");
 
 		role.getInterventions().add(iv);
 
 		List sx = new ArrayList();
 		sx.add("somewhere");
 		sx.add("somehow");
 		sx.add("whatever");
 		role.setBunchOfStrings(sx);
 
 		Session s = openSession();
 
 		s.save(role);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 
 		Role r = (Role) s.get(Role.class,new Long(role.getId()));
 		assertNotSame(role,r);
 
 		assertEquals(1,r.getInterventions().size());
 
 		assertEquals(3, r.getBunchOfStrings().size());
 
 		r.getBunchOfStrings().set(1, "replacement");
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 
 		r = (Role) s.get(Role.class,new Long(role.getId()));
 		assertNotSame(role,r);
 
 		assertEquals(r.getBunchOfStrings().get(1),"replacement");
 		assertEquals(3, r.getBunchOfStrings().size());
 
 		r.getBunchOfStrings().set(1, "replacement");
 
 		r.getBunchOfStrings().remove(1);
 		s.flush();
 
 		r.getBunchOfStrings().clear();
 		s.flush();
 
 		s.connection().commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testCRUD() throws HibernateException, SQLException {
 		if ( isUsingIdentity() ) {
 			SkipLog.reportSkip( "hand sql expecting non-identity id gen", "Custom SQL" );
 			return;
 		}
 
 		Person p = new Person();
 
 		p.setName("Max");
 		p.setLastName("Andersen");
 		p.setNationalID("110974XYZ");
 		p.setAddress("P. P. Street 8");
 
 		Session s = openSession();
 
 		s.save(p);
 		s.flush();
 
 		s.connection().commit();
 		s.close();
 
 		sessionFactory().evict(Person.class);
 		s = openSession();
 
 		Person p2 = (Person) s.get(Person.class, p.getId());
 		assertNotSame(p, p2);
 		assertEquals(p2.getId(),p.getId());
 		assertEquals(p2.getLastName(),p.getLastName());
 		s.flush();
 
 		List list = s.createQuery( "select p from Party as p" ).list();
 		assertTrue(list.size() == 1);
 
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 
 		list = s.createQuery( "select p from Person as p where p.address = 'Lrkevnget 1'" ).list();
 		assertTrue(list.size() == 0);
 		p.setAddress("Lrkevnget 1");
 		s.update(p);
 		list = s.createQuery( "select p from Person as p where p.address = 'Lrkevnget 1'" ).list();
 		assertTrue(list.size() == 1);
 		list = s.createQuery( "select p from Party as p where p.address = 'P. P. Street 8'" ).list();
 		assertTrue(list.size() == 0);
 
 		s.delete(p);
 		list = s.createQuery( "select p from Person as p" ).list();
 		assertTrue(list.size() == 0);
 
 		s.connection().commit();
 		s.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/D.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/D.java
index e2fe313615..63b5d73dae 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/D.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/D.java
@@ -1,62 +1,68 @@
 //$Id: D.java 4599 2004-09-26 05:18:27Z oneovthafew $
 package org.hibernate.test.legacy;
 
 
 public class D {
 	private Long id;
 	private float amount;
 	private A reverse;
 	public A inverse;
-	
+
 	public D() {
 		// try to induce an infinite loop in the lazy-loading machinery
 		setAmount(100.0f);
 		getAmount();
 	}	
+
+	public D(Long id) {
+		this();
+		this.id = id;
+	}
+
 	/**
 	 * Returns the amount.
 	 * @return float
 	 */
 	public float getAmount() {
 		return amount;
 	}
 	
 	/**
 	 * Returns the id.
 	 * @return long
 	 */
 	public Long getId() {
 		return id;
 	}
 	
 	/**
 	 * Sets the amount.
 	 * @param amount The amount to set
 	 */
 	public void setAmount(float amount) {
 		this.amount = amount;
 	}
 	
 	/**
 	 * Sets the id.
 	 * @param id The id to set
 	 */
 	public void setId(Long id) {
 		this.id = id;
 	}
 	
 	public A getReverse() {
 		return reverse;
 	}
 
 	public void setReverse(A a) {
 		reverse = a;
 	}
 
 }
 
 
 
 
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/Fee.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/Fee.java
index 4dca5d2a5c..95333b98a7 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/Fee.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/Fee.java
@@ -1,97 +1,97 @@
 //$Id: Fee.java 4599 2004-09-26 05:18:27Z oneovthafew $
 package org.hibernate.test.legacy;
 import java.io.Serializable;
 import java.util.Set;
 
 public class Fee implements Serializable {
 	public Fee fee;
 	public Fee anotherFee;
 	public String fi;
 	public String key;
 	public Set fees;
 	private Qux qux;
 	private FooComponent compon;
 	private int count;
 	
 	public Fee() {
 	}
-	
+
 	public Fee getFee() {
 		return fee;
 	}
 	
 	public void setFee(Fee fee) {
 		this.fee = fee;
 	}
 	
 	public String getFi() {
 		return fi;
 	}
 	
 	public void setFi(String fi) {
 		this.fi = fi;
 	}
 	
 	public String getKey() {
 		return key;
 	}
 	
 	public void setKey(String key) {
 		this.key = key;
 	}
 	
 	public Set getFees() {
 		return fees;
 	}
 	
 	public void setFees(Set fees) {
 		this.fees = fees;
 	}
 	
 	public Fee getAnotherFee() {
 		return anotherFee;
 	}
 	
 	public void setAnotherFee(Fee anotherFee) {
 		this.anotherFee = anotherFee;
 	}
 	
 	public Qux getQux() {
 		return qux;
 	}
 	
 	public void setQux(Qux qux) {
 		this.qux = qux;
 	}
 	
 	public FooComponent getCompon() {
 		return compon;
 	}
 	
 	public void setCompon(FooComponent compon) {
 		this.compon = compon;
 	}
 	
 	/**
 	 * Returns the count.
 	 * @return int
 	 */
 	public int getCount() {
 		return count;
 	}
 
 	/**
 	 * Sets the count.
 	 * @param count The count to set
 	 */
 	public void setCount(int count) {
 		this.count = count;
 	}
 
 }
 
 
 
 
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/Fo.hbm.xml b/hibernate-core/src/test/java/org/hibernate/test/legacy/Fo.hbm.xml
index ea2e150eec..00b3d34de0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/Fo.hbm.xml
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/Fo.hbm.xml
@@ -1,21 +1,21 @@
 <?xml version="1.0"?>
 <!DOCTYPE hibernate-mapping PUBLIC 
 	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
 	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
 <hibernate-mapping default-lazy="false">
 
 	<class name="org.hibernate.test.legacy.Fo" table="foes">
-		<composite-id class="org.hibernate.test.legacy.FumCompositeID">
+		<composite-id name="id" class="org.hibernate.test.legacy.FumCompositeID">
 			<key-property name="string">
 				<column name="string_" length="20"/>
 			</key-property>
 			<key-property name="short" column="short_"/>
 			<key-property name="date" column="date_" type="date"/>
 		</composite-id>
 		<version name="version" type="long"/>
 		<property name="serial" column="serial_"/>
 		<property name="buf"/>
 		<property name="x"/>
 	</class>
 	
 </hibernate-mapping>
\ No newline at end of file
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/Fo.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/Fo.java
index 9b63e6feb1..2650be960e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/Fo.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/Fo.java
@@ -1,59 +1,74 @@
 //$Id: Fo.java 4599 2004-09-26 05:18:27Z oneovthafew $
 package org.hibernate.test.legacy;
 import java.io.Serializable;
 
 public final class Fo {
 	
+	public static Fo newFo(FumCompositeID id) {
+		Fo fo = newFo();
+		fo.id = id;
+		return fo;
+	}
+
 	public static Fo newFo() {
 		return new Fo();
 	}
 	
 	private Fo() {}
-	
+
+	private FumCompositeID id;
 	private byte[] buf;
 	private Serializable serial;
 	private long version;
 	private int x;
-	
+
+	public FumCompositeID getId() {
+		return id;
+	}
+
+	public void setId(FumCompositeID id) {
+		this.id = id;
+	}
+
 	public int getX() {
 		return x;
 	}
 	public void setX(int x) {
 		this.x = x;
 	}
 	
 	public byte[] getBuf() {
 		return buf;
 	}
 	
 	
 	public Serializable getSerial() {
 		return serial;
 	}
 	
 	
 	public void setBuf(byte[] buf) {
 		this.buf = buf;
 	}
 	
 	
 	public void setSerial(Serializable serial) {
 		this.serial = serial;
 	}
 	
 	public long getVersion() {
 		return version;
 	}
 	
 	public void setVersion(long version) {
 		this.version = version;
 	}
 	
 }
 
 
 
 
 
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/Foo.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/Foo.java
index 44888e36fa..0af857e3d6 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/Foo.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/Foo.java
@@ -1,435 +1,439 @@
 //$Id: Foo.java 4599 2004-09-26 05:18:27Z oneovthafew $
 package org.hibernate.test.legacy;
 import java.io.Serializable;
 import java.sql.Timestamp;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Locale;
 import org.hibernate.CallbackException;
 import org.hibernate.Session;
 import org.hibernate.classic.Lifecycle;
 
 public class Foo implements Lifecycle, FooProxy, Serializable {
 
 	private static int count=0;
 
 	public static class Struct implements java.io.Serializable {
 		String name;
 		int count;
 		public boolean equals(Object other) {
 			Struct s = (Struct) other;
 			return ( s.name==name || s.name.equals(name) ) && s.count==count;
 		}
 		public int hashCode() {
 			return count;
 		}
 	}
 
 	/*public boolean equals(Object other) {
 		FooProxy otherFoo = (FooProxy) other;
 		return this.key.equals( otherFoo.getKey() ) && this._string.equals( otherFoo.getString() );
 	}
 
 	public int hashCode() {
 		return key.hashCode() - _string.hashCode();
 	}*/
 
 	String key;
 	FooProxy _foo;
 	String _string;
 	Date _date;
 	Date _timestamp;
 	Integer _integer;
 	Long _long;
 	Short _short;
 	Float _float;
 	Double _double;
 	Boolean _boolean;
 	Byte _byte;
 	Integer _null;
 	int _int;
 	boolean _bool;
 	float _zero;
 	byte[] _bytes;
 	boolean yesno;
 	java.io.Serializable blob;
 	java.io.Serializable nullBlob;
 	byte[] binary;
 	String[] custom;
 	FooComponent component;
 	char _char;
 	Fee dependent;
 	Locale theLocale;
 	private int version;
 	private Timestamp versionTimestamp;
 	private Calendar versionCalendar;
 	private float formula;
 	private String joinedProp;
 
 	private int x;
 
 	public int getX() {
 		return x;
 	}
 	public void setX(int x) {
 		this.x = x;
 	}
 
 	public Foo() {
 	}
 
+	public Foo(String key) {
+		this.key = key;
+	}
+
 	public Foo(int x) {
 		this.x=x;
 	}
 
 	public boolean onSave(Session db) throws CallbackException {
 		_string = "a string";
 		_date = new Date(123);
 		_timestamp = new Date( System.currentTimeMillis() );
 		_integer = new Integer( -666 );
 		_long = new Long( 696969696969696969l - count++ );
 		_short = new Short("42");
 		_float = new Float( 6666.66f );
 		//_double = new Double( 1.33e-69 );  // this double is too big for the sap db jdbc driver
 		_double = new Double( 1.12e-36 );
 		_boolean = new Boolean(true);
 		_byte = new Byte( (byte) 127 );
 		_int = 2;
 		_char = '@';
 		_bytes = _string.getBytes();
 		Struct s = new Struct();
 		s.name="name";
 		s.count = 69;
 		blob = s;
 		binary = ( _string + "yada yada yada" ).getBytes();
 		custom = new String[] { "foo", "bar" };
 		component = new FooComponent("foo", 12, new Date[] { _date, _timestamp, null, new Date() }, new FooComponent("bar", 666, new Date[] { new Date(123456l), null }, null ) );
 		component.setGlarch( new Glarch() );
 		dependent = new Fee();
 		dependent.setFi( "belongs to foo # " + getKey() );
 		theLocale = Locale.getDefault();
 		return NO_VETO;
 	}
 
 	public boolean onDelete(Session db) throws CallbackException {
 		return NO_VETO;
 	}
 	public boolean onUpdate(Session db) throws CallbackException {
 		return NO_VETO;
 	}
 
 	public void onLoad(Session db, Serializable id) {
 	}
 
 	public String getKey() {
 		return key;
 	}
 	public void setKey(String key) {
 		this.key = key;
 	}
 
 	public FooProxy getFoo() {
 		return _foo;
 	}
 	public void setFoo(FooProxy foo) {
 		_foo = foo;
 	}
 
 	public String getString() {
 		return _string;
 	}
 	public void setString(String string) {
 		_string = string;
 		//if (_foo!=null) _foo.setString(string);
 	}
 
 	public java.util.Date getDate() {
 		return _date;
 	}
 	public void setDate(java.util.Date date) {
 		_date = date;
 	}
 
 	public java.util.Date getTimestamp() {
 		return _timestamp;
 	}
 	public void setTimestamp(java.util.Date timestamp) {
 		_timestamp = timestamp;
 	}
 
 	public Integer getInteger() {
 		return _integer;
 	}
 	public void setInteger(Integer iinteger) {
 		_integer = iinteger;
 	}
 	public Long getLong() {
 		return _long;
 	}
 	public void setLong(Long llong) {
 		_long = llong;
 	}
 
 
 	public Short getShort() {
 		return _short;
 	}
 	public void setShort(Short sshort) {
 		_short = sshort;
 	}
 	public Float getFloat() {
 		return _float;
 	}
 	public void setFloat(Float ffloat) {
 		_float = ffloat;
 	}
 	public Double getDouble() {
 		return _double;
 	}
 	public void setDouble(Double ddouble) {
 		_double = ddouble;
 	}
 	public Boolean getBoolean() {
 		return _boolean;
 	}
 	public void setBoolean(Boolean bboolean) {
 		_boolean = bboolean;
 	}
 	public byte[] getBytes() {
 		return _bytes;
 	}
 	public void setBytes(byte[] bytes) {
 		_bytes = bytes;
 	}
 	public float getZero() {
 		return _zero;
 	}
 	public void setZero(float zero) {
 		_zero = zero;
 	}
 	public boolean getBool() {
 		return _bool;
 	}
 	public void setBool(boolean bool) {
 		_bool = bool;
 	}
 
 	public int getInt() {
 		return _int;
 	}
 	public void setInt(int iint) {
 		_int = iint;
 	}
 
 	public Integer getNull() {
 		return _null;
 	}
 	public void setNull(Integer nnull) {
 		_null = nnull;
 	}
 
 	public Byte getByte() {
 		return _byte;
 	}
 
 	public void setByte(Byte bbyte) {
 		_byte = bbyte;
 	}
 
 	public String toString() {
 		return this.getClass().getName() + ": " + key;
 	}
 
 	public void disconnect() {
 		if ( _foo!=null) _foo.disconnect();
 		_foo=null;
 	}
 
 	public boolean equalsFoo(Foo other) {
 		if ( _bytes!=other._bytes ) {
 			if ( _bytes==null || other._bytes==null ) return false;
 			if ( _bytes.length!=other._bytes.length ) return false;
 			for ( int i=0; i< _bytes.length; i++) {
 				if ( _bytes[i] != other._bytes[i] ) return false;
 			}
 		}
 
 		return ( this._bool == other._bool )
 		&& ( ( this._boolean == other._boolean ) || ( this._boolean.equals(other._boolean) ) )
 		&& ( ( this._byte == other._byte ) || ( this._byte.equals(other._byte) ) )
 		//&& ( ( this._date == other._date ) || ( this._date.getDate() == other._date.getDate() && this._date.getMonth() == other._date.getMonth() && this._date.getYear() == other._date.getYear() ) )
 		&& ( ( this._double == other._double ) || ( this._double.equals(other._double) ) )
 		&& ( ( this._float == other._float ) || ( this._float.equals(other._float) ) )
 		&& ( this._int == other._int )
 		&& ( ( this._integer == other._integer ) || ( this._integer.equals(other._integer) ) )
 		&& ( ( this._long == other._long ) || ( this._long.equals(other._long) ) )
 		&& ( this._null == other._null )
 		&& ( ( this._short == other._short ) || ( this._short.equals(other._short) ) )
 		&& ( ( this._string == other._string) || ( this._string.equals(other._string) ) )
 		//&& ( ( this._timestamp==other._timestamp) || ( this._timestamp.getDate() == other._timestamp.getDate() && this._timestamp.getYear() == other._timestamp.getYear() && this._timestamp.getMonth() == other._timestamp.getMonth() ) )
 		&& ( this._zero == other._zero )
 		&& ( ( this._foo == other._foo ) || ( this._foo.getKey().equals( other._foo.getKey() ) ) )
 		&& ( ( this.blob == other.blob ) || ( this.blob.equals(other.blob) ) )
 		&& ( this.yesno == other.yesno )
 		&& ( ( this.binary == other.binary ) || java.util.Arrays.equals(this.binary, other.binary) )
 		&& ( this.key.equals(other.key) )
 		&& ( this.theLocale.equals(other.theLocale) )
 		&& ( ( this.custom == other.custom ) || ( this.custom[0].equals(other.custom[0]) && this.custom[1].equals(other.custom[1]) ) );
 
 	}
 
 	public boolean getYesno() {
 		return yesno;
 	}
 
 	public void setYesno(boolean yesno) {
 		this.yesno = yesno;
 	}
 
 	public java.io.Serializable getBlob() {
 		return blob;
 	}
 
 	public void setBlob(java.io.Serializable blob) {
 		this.blob = blob;
 	}
 
 	public java.io.Serializable getNullBlob() {
 		return nullBlob;
 	}
 
 	public void setNullBlob(java.io.Serializable nullBlob) {
 		this.nullBlob = nullBlob;
 	}
 
 	public byte[] getBinary() {
 		return binary;
 	}
 	public void setBinary(byte[] binary) {
 		this.binary = binary;
 	}
 
 	public String[] getCustom() {
 		return custom;
 	}
 
 	public void setCustom(String[] custom) {
 		this.custom = custom;
 	}
 
 	public FooComponent getComponent() {
 		return component;
 	}
 	public void setComponent(FooComponent component) {
 		this.component = component;
 	}
 
 	public FooComponent getNullComponent() {
 		return null;
 	}
 	public void setNullComponent(FooComponent fc) throws Exception {
 		if (fc!=null) throw new Exception("Null component");
 	}
 
 	public Character getChar() {
 		return new Character(_char);
 	}
 
 	public void setChar(Character _char) {
 		this._char = _char.charValue();
 	}
 
 	public Fee getDependent() {
 		return dependent;
 	}
 
 	public void setDependent(Fee dependent) {
 		this.dependent = dependent;
 	}
 
 	/**
 	 * Returns the locale.
 	 * @return Locale
 	 */
 	public Locale getLocale() {
 		return theLocale;
 	}
 
 	/**
 	 * Sets the locale.
 	 * @param locale The locale to set
 	 */
 	public void setLocale(Locale locale) {
 		this.theLocale = locale;
 	}
 
 	/**
 	 * Returns the version.
 	 * @return int
 	 */
 	public int getVersion() {
 		return version;
 	}
 
 	/**
 	 * Sets the version.
 	 * @param version The version to set
 	 */
 	public void setVersion(int version) {
 		this.version = version;
 	}
 
 	/**
 	 * Returns the versionTimestamp.
 	 * @return Timestamp
 	 */
 	public Timestamp getVersionTimestamp() {
 		return versionTimestamp;
 	}
 
 	/**
 	 * Sets the versionTimestamp.
 	 * @param versionTimestamp The versionTimestamp to set
 	 */
 	public void setVersionTimestamp(Timestamp versionTimestamp) {
 		this.versionTimestamp = versionTimestamp;
 	}
 
 	public void finalize() { }
 
 	public Calendar getVersionCalendar() {
 		return versionCalendar;
 	}
 
 	public void setVersionCalendar(Calendar calendar) {
 		versionCalendar = calendar;
 	}
 
 	public float getFormula() {
 		return formula;
 	}
 
 	public void setFormula(float f) {
 		formula = f;
 	}
 
 	/**
 	 * @return Returns the joinedProp.
 	 */
 	public String getJoinedProp() {
 		return joinedProp;
 	}
 
 	/**
 	 * @param joinedProp The joinedProp to set.
 	 */
 	public void setJoinedProp(String joinedProp) {
 		this.joinedProp = joinedProp;
 	}
 
 }
 
 
 
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/FooBarTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/FooBarTest.java
index aab33c296a..0e710f69c6 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/FooBarTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/FooBarTest.java
@@ -1,4855 +1,4862 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
 
-import static org.hibernate.testing.TestLogger.LOG;
 import java.io.Serializable;
 import java.sql.Connection;
 import java.sql.Time;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
 import java.util.SortedSet;
 import java.util.TimeZone;
 import java.util.TreeMap;
 import java.util.TreeSet;
 
 import org.hibernate.Criteria;
 import org.hibernate.FetchMode;
 import org.hibernate.FlushMode;
 import org.hibernate.Hibernate;
 import org.hibernate.HibernateException;
 import org.hibernate.LazyInitializationException;
 import org.hibernate.LockMode;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.Query;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 import org.hibernate.criterion.Example;
 import org.hibernate.criterion.MatchMode;
 import org.hibernate.criterion.Order;
 import org.hibernate.criterion.Restrictions;
 import org.hibernate.dialect.DB2Dialect;
 import org.hibernate.dialect.DerbyDialect;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.InterbaseDialect;
 import org.hibernate.dialect.MckoiDialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.Oracle8iDialect;
 import org.hibernate.dialect.PointbaseDialect;
 import org.hibernate.dialect.PostgreSQLDialect;
 import org.hibernate.dialect.SAPDBDialect;
 import org.hibernate.dialect.Sybase11Dialect;
 import org.hibernate.dialect.SybaseASE15Dialect;
 import org.hibernate.dialect.SybaseDialect;
 import org.hibernate.dialect.TimesTenDialect;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.internal.util.SerializationHelper;
 import org.hibernate.internal.util.collections.JoinedIterator;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
 
 import org.junit.Test;
 
 import org.hibernate.testing.DialectChecks;
 import org.hibernate.testing.RequiresDialectFeature;
 import org.hibernate.testing.env.ConnectionProviderBuilder;
 
+import static org.hibernate.testing.TestLogger.LOG;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public class FooBarTest extends LegacyTestCase {
 
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 			"legacy/FooBar.hbm.xml",
 			"legacy/Baz.hbm.xml",
 			"legacy/Qux.hbm.xml",
 			"legacy/Glarch.hbm.xml",
 			"legacy/Fum.hbm.xml",
 			"legacy/Fumm.hbm.xml",
 			"legacy/Fo.hbm.xml",
 			"legacy/One.hbm.xml",
 			"legacy/Many.hbm.xml",
 			"legacy/Immutable.hbm.xml",
 			"legacy/Fee.hbm.xml",
 			"legacy/Vetoer.hbm.xml",
 			"legacy/Holder.hbm.xml",
 			"legacy/Location.hbm.xml",
 			"legacy/Stuff.hbm.xml",
 			"legacy/Container.hbm.xml",
 			"legacy/Simple.hbm.xml",
 			"legacy/XY.hbm.xml"
 		};
 	}
 
 	@Test
 	public void testSaveOrUpdateCopyAny() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Bar bar = new Bar();
 		One one = new One();
 		bar.setObject(one);
 		s.save(bar);
 		GlarchProxy g = bar.getComponent().getGlarch();
 		bar.getComponent().setGlarch(null);
 		s.delete(g);
 		s.flush();
 		assertTrue( s.contains(one) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
-		Bar bar2 = (Bar) s.saveOrUpdateCopy(bar);
+		Bar bar2 = (Bar) s.merge( bar );
 		s.flush();
 		s.delete(bar2);
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testRefreshProxy() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Glarch g = new Glarch();
 		Serializable gid = s.save(g);
 		s.flush();
 		s.clear();
 		GlarchProxy gp = (GlarchProxy) s.load(Glarch.class, gid);
 		gp.getName(); //force init
 		s.refresh(gp);
 		s.delete(gp);
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@RequiresDialectFeature(
 			value = DialectChecks.SupportsCircularCascadeDeleteCheck.class,
 			comment = "db/dialect does not support circular cascade delete constraints"
 	)
 	public void testOnCascadeDelete() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.subs = new ArrayList();
 		Baz sub = new Baz();
 		sub.superBaz = baz;
 		baz.subs.add(sub);
 		s.save(baz);
 		s.flush();
 		assertTrue( s.createQuery("from Baz").list().size()==2 );
 		s.getTransaction().commit();
 		s.beginTransaction();
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.beginTransaction();
 		assertTrue( s.createQuery("from Baz").list().size()==0 );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testRemoveFromIdbag() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setByteBag( new ArrayList() );
 		byte[] bytes = { 12, 13 };
 		baz.getByteBag().add( new byte[] { 10, 45 } );
 		baz.getByteBag().add(bytes);
 		baz.getByteBag().add( new byte[] { 1, 11 } );
 		baz.getByteBag().add( new byte[] { 12 } );
 		s.save(baz);
 		s.flush();
 		baz.getByteBag().remove(bytes);
 		s.flush();
 		baz.getByteBag().add(bytes);
 		s.flush();
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testLoad() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Qux q = new Qux();
 		s.save(q);
 		BarProxy b = new Bar();
 		s.save(b);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		q = (Qux) s.load(Qux.class, q.getKey() );
 		b = (BarProxy) s.load( Foo.class, b.getKey() );
 		b.getKey();
 		assertFalse( Hibernate.isInitialized(b) );
 		b.getBarString();
 		assertTrue( Hibernate.isInitialized(b) );
 		BarProxy b2 = (BarProxy) s.load( Bar.class, b.getKey() );
 		Qux q2 = (Qux) s.load( Qux.class, q.getKey() );
 		assertTrue( "loaded same object", q==q2 );
 		assertTrue( "loaded same object", b==b2 );
 		assertTrue( Math.round( b.getFormula() ) == b.getInt() / 2 );
 		s.delete(q2);
 		s.delete( b2 );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testJoin() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo foo = new Foo();
 		foo.setJoinedProp("foo");
 		s.save( foo );
 		s.flush();
 		foo.setJoinedProp("bar");
 		s.flush();
 		String fid = foo.getKey();
 		s.delete( foo );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Foo foo2 = new Foo();
 		foo2.setJoinedProp("foo");
 		s.save(foo2);
 		s.createQuery( "select foo.id from Foo foo where foo.joinedProp = 'foo'" ).list();
 		assertNull( s.get(Foo.class, fid) );
 		s.delete(foo2);
 		s.getTransaction().commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testDereferenceLazyCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setFooSet( new HashSet() );
 		Foo foo = new Foo();
 		baz.getFooSet().add(foo);
 		s.save(foo);
 		s.save(baz);
 		foo.setBytes( "foobar".getBytes() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo = (Foo) s.get( Foo.class, foo.getKey() );
 		assertTrue( Hibernate.isInitialized( foo.getBytes() ) );
 		assertTrue( foo.getBytes().length==6 );
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		assertTrue( baz.getFooSet().size()==1 );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().evictCollection("org.hibernate.test.legacy.Baz.fooSet");
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		assertFalse( Hibernate.isInitialized( baz.getFooSet() ) );
 		baz.setFooSet(null);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo = (Foo) s.get( Foo.class, foo.getKey() );
 		assertTrue( foo.getBytes().length==6 );
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		assertFalse( Hibernate.isInitialized( baz.getFooSet() ) );
 		assertTrue( baz.getFooSet().size()==0 );
 		s.delete(baz);
 		s.delete(foo);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testMoveLazyCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		Baz baz2 = new Baz();
 		baz.setFooSet( new HashSet() );
 		Foo foo = new Foo();
 		baz.getFooSet().add(foo);
 		s.save(foo);
 		s.save(baz);
 		s.save(baz2);
 		foo.setBytes( "foobar".getBytes() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo = (Foo) s.get( Foo.class, foo.getKey() );
 		assertTrue( Hibernate.isInitialized( foo.getBytes() ) );
 		assertTrue( foo.getBytes().length==6 );
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		assertTrue( baz.getFooSet().size()==1 );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().evictCollection("org.hibernate.test.legacy.Baz.fooSet");
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		assertFalse( Hibernate.isInitialized( baz.getFooSet() ) );
 		baz2 = (Baz) s.get( Baz.class, baz2.getCode() );
 		baz2.setFooSet( baz.getFooSet() );
 		baz.setFooSet(null);
 		assertFalse( Hibernate.isInitialized( baz2.getFooSet() ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo = (Foo) s.get( Foo.class, foo.getKey() );
 		assertTrue( foo.getBytes().length==6 );
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		baz2 = (Baz) s.get( Baz.class, baz2.getCode() );
 		assertFalse( Hibernate.isInitialized( baz.getFooSet() ) );
 		assertTrue( baz.getFooSet().size()==0 );
 		assertTrue( Hibernate.isInitialized( baz2.getFooSet() ) ); //fooSet has batching enabled
 		assertTrue( baz2.getFooSet().size()==1 );
 		s.delete(baz);
 		s.delete(baz2);
 		s.delete(foo);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCriteriaCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz bb = (Baz) s.createCriteria(Baz.class).uniqueResult();
 		assertTrue( bb == null );
 		Baz baz = new Baz();
 		s.save( baz );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Baz b = (Baz) s.createCriteria(Baz.class).uniqueResult();
 		assertTrue( Hibernate.isInitialized( b.getTopGlarchez() ) );
 		assertTrue( b.getTopGlarchez().size() == 0 );
 		s.delete( b );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testQuery() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Foo foo = new Foo();
 		s.save(foo);
 		Foo foo2 = new Foo();
 		s.save(foo2);
 		foo.setFoo(foo2);
 
 		List list = s.createQuery( "from Foo foo inner join fetch foo.foo" ).list();
 		Foo foof = (Foo) list.get(0);
 		assertTrue( Hibernate.isInitialized( foof.getFoo() ) );
 
 		s.createQuery( "from Baz baz left outer join fetch baz.fooToGlarch" ).list();
 
 		list = s.createQuery( "select foo, bar from Foo foo left outer join foo.foo bar where foo = ?" )
 				.setParameter( 0, foo, Hibernate.entity(Foo.class) )
 				.list();
 		Object[] row1 = (Object[]) list.get(0);
 		assertTrue( row1[0]==foo && row1[1]==foo2 );
 
 		s.createQuery( "select foo.foo.foo.string from Foo foo where foo.foo = 'bar'" ).list();
 		s.createQuery( "select foo.foo.foo.foo.string from Foo foo where foo.foo = 'bar'" ).list();
 		s.createQuery( "select foo from Foo foo where foo.foo.foo = 'bar'" ).list();
 		s.createQuery( "select foo.foo.foo.foo.string from Foo foo where foo.foo.foo = 'bar'" ).list();
 		s.createQuery( "select foo.foo.foo.string from Foo foo where foo.foo.foo.foo.string = 'bar'" ).list();
 		if ( ! (getDialect() instanceof HSQLDialect) )
 			s.createQuery( "select foo.string from Foo foo where foo.foo.foo.foo = foo.foo.foo" ).list();
 		s.createQuery( "select foo.string from Foo foo where foo.foo.foo = 'bar' and foo.foo.foo.foo = 'baz'" ).list();
 		s.createQuery( "select foo.string from Foo foo where foo.foo.foo.foo.string = 'a' and foo.foo.string = 'b'" )
 				.list();
 
 		s.createQuery( "from Bar bar, foo in elements(bar.baz.fooArray)" ).list();
 
 		//s.find("from Baz as baz where baz.topComponents[baz].name = 'bazzz'");
 
 		if ( (getDialect() instanceof DB2Dialect) && !(getDialect() instanceof DerbyDialect) ) {
 			s.createQuery( "from Foo foo where lower( foo.foo.string ) = 'foo'" ).list();
 			s.createQuery( "from Foo foo where lower( (foo.foo.string || 'foo') || 'bar' ) = 'foo'" ).list();
 			s.createQuery( "from Foo foo where repeat( (foo.foo.string || 'foo') || 'bar', 2 ) = 'foo'" ).list();
 			s.createQuery(
 					"from Bar foo where foo.foo.integer is not null and repeat( (foo.foo.string || 'foo') || 'bar', (5+5)/2 ) = 'foo'"
 			).list();
 			s.createQuery(
 					"from Bar foo where foo.foo.integer is not null or repeat( (foo.foo.string || 'foo') || 'bar', (5+5)/2 ) = 'foo'"
 			).list();
 		}
 		if (getDialect() instanceof SybaseDialect) {
 			s.createQuery( "select baz from Baz as baz join baz.fooArray foo group by baz order by sum(foo.float)" )
 					.iterate();
 		}
 
 		s.createQuery( "from Foo as foo where foo.component.glarch.name is not null" ).list();
 		s.createQuery( "from Foo as foo left outer join foo.component.glarch as glarch where glarch.name = 'foo'" )
 				.list();
 
 		list = s.createQuery( "from Foo" ).list();
 		assertTrue( list.size()==2 && list.get(0) instanceof FooProxy );
 		list = s.createQuery( "from Foo foo left outer join foo.foo" ).list();
 		assertTrue( list.size()==2 && ( (Object[]) list.get(0) )[0] instanceof FooProxy );
 
 		s.createQuery("from Bar, Bar").list();
 		s.createQuery("from Foo, Bar").list();
 		s.createQuery( "from Baz baz left join baz.fooToGlarch, Bar bar join bar.foo" ).list();
 		s.createQuery( "from Baz baz left join baz.fooToGlarch join baz.fooSet" ).list();
 		s.createQuery( "from Baz baz left join baz.fooToGlarch join fetch baz.fooSet foo left join fetch foo.foo" )
 				.list();
 
 		list = s.createQuery(
 				"from Foo foo where foo.string='osama bin laden' and foo.boolean = true order by foo.string asc, foo.component.count desc"
 		).list();
 		assertTrue( "empty query", list.size()==0 );
 		Iterator iter = s.createQuery(
 				"from Foo foo where foo.string='osama bin laden' order by foo.string asc, foo.component.count desc"
 		).iterate();
 		assertTrue( "empty iterator", !iter.hasNext() );
 
 		list = s.createQuery( "select foo.foo from Foo foo" ).list();
 		assertTrue( "query", list.size()==1 );
 		assertTrue( "returned object", list.get(0)==foo.getFoo() );
 		foo.getFoo().setFoo(foo);
 		foo.setString("fizard");
 		//The following test is disabled for databases with no subselects...also for Interbase (not sure why).
 		if (
 				!(getDialect() instanceof MySQLDialect) &&
 				!(getDialect() instanceof HSQLDialect) &&
 				!(getDialect() instanceof MckoiDialect) &&
 				!(getDialect() instanceof SAPDBDialect) &&
 				!(getDialect() instanceof PointbaseDialect) &&
 				!(getDialect() instanceof DerbyDialect)
 		)  {
 			// && !db.equals("weblogic") {
 			if ( !( getDialect() instanceof InterbaseDialect ) ) {
 				list = s.createQuery( "from Foo foo where ? = some elements(foo.component.importantDates)" )
 						.setParameter( 0, new Date(), Hibernate.DATE )
 						.list();
 				assertTrue( "component query", list.size()==2 );
 			}
 			if( !( getDialect() instanceof TimesTenDialect)) {
 				list = s.createQuery( "from Foo foo where size(foo.component.importantDates) = 3" ).list(); //WAS: 4
 				assertTrue( "component query", list.size()==2 );
 				list = s.createQuery( "from Foo foo where 0 = size(foo.component.importantDates)" ).list();
 				assertTrue( "component query", list.size()==0 );
 			}
 			list = s.createQuery( "from Foo foo where exists elements(foo.component.importantDates)" ).list();
 			assertTrue( "component query", list.size()==2 );
 			s.createQuery( "from Foo foo where not exists (from Bar bar where bar.id = foo.id)" ).list();
 
 			s.createQuery(
 					"select foo.foo from Foo foo where foo = some(select x from Foo x where x.long > foo.foo.long)"
 			).list();
 			s.createQuery( "select foo.foo from Foo foo where foo = some(from Foo x where (x.long > foo.foo.long))" )
 					.list();
 			if ( !( getDialect() instanceof TimesTenDialect)) {
 				s.createQuery(
 						"select foo.foo from Foo foo where foo.long = some( select max(x.long) from Foo x where (x.long > foo.foo.long) group by x.foo )"
 				).list();
 			}
 			s.createQuery(
 					"from Foo foo where foo = some(select x from Foo x where x.long > foo.foo.long) and foo.foo.string='baz'"
 			).list();
 			s.createQuery(
 					"from Foo foo where foo.foo.string='baz' and foo = some(select x from Foo x where x.long > foo.foo.long)"
 			).list();
 			s.createQuery( "from Foo foo where foo = some(select x from Foo x where x.long > foo.foo.long)" ).list();
 
 			s.createQuery(
 					"select foo.string, foo.date, foo.foo.string, foo.id from Foo foo, Baz baz where foo in elements(baz.fooArray) and foo.string like 'foo'"
 			).iterate();
 		}
 		list = s.createQuery( "from Foo foo where foo.component.count is null order by foo.component.count" ).list();
 		assertTrue( "component query", list.size()==0 );
 		list = s.createQuery( "from Foo foo where foo.component.name='foo'" ).list();
 		assertTrue( "component query", list.size()==2 );
 		list = s.createQuery(
 				"select distinct foo.component.name, foo.component.name from Foo foo where foo.component.name='foo'"
 		).list();
 		assertTrue( "component query", list.size()==1 );
 		list = s.createQuery( "select distinct foo.component.name, foo.id from Foo foo where foo.component.name='foo'" )
 				.list();
 		assertTrue( "component query", list.size()==2 );
 		list = s.createQuery( "select foo.foo from Foo foo" ).list();
 		assertTrue( "query", list.size()==2 );
 		list = s.createQuery( "from Foo foo where foo.id=?" )
 				.setParameter( 0, foo.getKey(), Hibernate.STRING )
 				.list();
 		assertTrue( "id query", list.size()==1 );
 		list = s.createQuery( "from Foo foo where foo.key=?" )
 				.setParameter( 0, foo.getKey(), Hibernate.STRING )
 				.list();
 		assertTrue( "named id query", list.size()==1 );
 		assertTrue( "id query", list.get(0)==foo );
 		list = s.createQuery( "select foo.foo from Foo foo where foo.string='fizard'" ).list();
 		assertTrue( "query", list.size()==1 );
 		assertTrue( "returned object", list.get(0)==foo.getFoo() );
 		list = s.createQuery( "from Foo foo where foo.component.subcomponent.name='bar'" ).list();
 		assertTrue( "components of components", list.size()==2 );
 		list = s.createQuery( "select foo.foo from Foo foo where foo.foo.id=?" )
 				.setParameter( 0, foo.getFoo().getKey(), Hibernate.STRING )
 				.list();
 		assertTrue( "by id query", list.size()==1 );
 		assertTrue( "by id returned object", list.get(0)==foo.getFoo() );
 
 		s.createQuery( "from Foo foo where foo.foo = ?" ).setParameter( 0, foo.getFoo(), Hibernate.entity(Foo.class) ).list();
 
 		assertTrue( !s.createQuery( "from Bar bar where bar.string='a string' or bar.string='a string'" )
 				.iterate()
 				.hasNext() );
 
 		iter = s.createQuery( "select foo.component.name, elements(foo.component.importantDates) from Foo foo where foo.foo.id=?" )
 				.setParameter( 0, foo.getFoo().getKey(), Hibernate.STRING )
 				.iterate();
 		int i=0;
 		while ( iter.hasNext() ) {
 			i++;
 			Object[] row = (Object[]) iter.next();
 			assertTrue( row[0] instanceof String && ( row[1]==null || row[1] instanceof Date ) );
 		}
 		assertTrue(i==3); //WAS: 4
 		iter = s.createQuery( "select max( elements(foo.component.importantDates) ) from Foo foo group by foo.id" )
 				.iterate();
 		assertTrue( iter.next() instanceof Date );
 
 		list = s.createQuery(
 				"select foo.foo.foo.foo from Foo foo, Foo foo2 where"
 						+ " foo = foo2.foo and not not ( not foo.string='fizard' )"
 						+ " and foo2.string between 'a' and (foo.foo.string)"
 						+ ( ( getDialect() instanceof HSQLDialect || getDialect() instanceof InterbaseDialect || getDialect() instanceof TimesTenDialect ) ?
 						" and ( foo2.string in ( 'fiz', 'blah') or 1=1 )"
 						:
 						" and ( foo2.string in ( 'fiz', 'blah', foo.foo.string, foo.string, foo2.string ) )"
 				)
 		).list();
 		assertTrue( "complex query", list.size()==1 );
 		assertTrue( "returned object", list.get(0)==foo );
 		foo.setString("from BoogieDown  -tinsel town  =!@#$^&*())");
 		list = s.createQuery( "from Foo foo where foo.string='from BoogieDown  -tinsel town  =!@#$^&*())'" ).list();
 		assertTrue( "single quotes", list.size()==1 );
 		list = s.createQuery( "from Foo foo where not foo.string='foo''bar'" ).list();
 		assertTrue( "single quotes", list.size()==2 );
 		list = s.createQuery( "from Foo foo where foo.component.glarch.next is null" ).list();
 		assertTrue( "query association in component", list.size()==2 );
 		Bar bar = new Bar();
 		Baz baz = new Baz();
 		baz.setDefaults();
 		bar.setBaz(baz);
 		baz.setManyToAny( new ArrayList() );
 		baz.getManyToAny().add(bar);
 		baz.getManyToAny().add(foo);
 		s.save(bar);
 		s.save(baz);
 		list = s.createQuery(
 				" from Bar bar where bar.baz.count=667 and bar.baz.count!=123 and not bar.baz.name='1-E-1'"
 		).list();
 		assertTrue( "query many-to-one", list.size()==1 );
 		list = s.createQuery( " from Bar i where i.baz.name='Bazza'" ).list();
 		assertTrue( "query many-to-one", list.size()==1 );
 
 		Iterator rs = s.createQuery( "select count(distinct foo.foo) from Foo foo" ).iterate();
 		assertTrue( "count", ( (Long) rs.next() ).longValue()==2 );
 		assertTrue( !rs.hasNext() );
 		rs = s.createQuery( "select count(foo.foo.boolean) from Foo foo" ).iterate();
 		assertTrue( "count", ( (Long) rs.next() ).longValue()==2 );
 		assertTrue( !rs.hasNext() );
 		rs = s.createQuery( "select count(*), foo.int from Foo foo group by foo.int" ).iterate();
 		assertTrue( "count(*) group by", ( (Object[]) rs.next() )[0].equals( new Long(3) ) );
 		assertTrue( !rs.hasNext() );
 		rs = s.createQuery( "select sum(foo.foo.int) from Foo foo" ).iterate();
 		assertTrue( "sum", ( (Long) rs.next() ).longValue()==4 );
 		assertTrue( !rs.hasNext() );
 		rs = s.createQuery( "select count(foo) from Foo foo where foo.id=?" )
 				.setParameter( 0, foo.getKey(), Hibernate.STRING )
 				.iterate();
 		assertTrue( "id query count", ( (Long) rs.next() ).longValue()==1 );
 		assertTrue( !rs.hasNext() );
 
 		s.createQuery( "from Foo foo where foo.boolean = ?" )
 				.setParameter( 0, new Boolean(true), Hibernate.BOOLEAN )
 				.list();
 
 		s.createQuery( "select new Foo(fo.x) from Fo fo" ).list();
 		s.createQuery( "select new Foo(fo.integer) from Foo fo" ).list();
 
 		list = s.createQuery("select new Foo(fo.x) from Foo fo")
 			//.setComment("projection test")
 			.setCacheable(true)
 			.list();
 		assertTrue(list.size()==3);
 		list = s.createQuery("select new Foo(fo.x) from Foo fo")
 			//.setComment("projection test 2")
 			.setCacheable(true)
 			.list();
 		assertTrue(list.size()==3);
 
 		rs = s.createQuery( "select new Foo(fo.x) from Foo fo" ).iterate();
 		assertTrue( "projection iterate (results)", rs.hasNext() );
 		assertTrue( "projection iterate (return check)", Foo.class.isAssignableFrom( rs.next().getClass() ) );
 
 		ScrollableResults sr = s.createQuery("select new Foo(fo.x) from Foo fo").scroll();
 		assertTrue( "projection scroll (results)", sr.next() );
 		assertTrue( "projection scroll (return check)", Foo.class.isAssignableFrom( sr.get(0).getClass() ) );
 
 		list = s.createQuery( "select foo.long, foo.component.name, foo, foo.foo from Foo foo" ).list();
 		rs = list.iterator();
 		int count=0;
 		while ( rs.hasNext() ) {
 			count++;
 			Object[] row = (Object[]) rs.next();
 			assertTrue( row[0] instanceof Long );
 			assertTrue( row[1] instanceof String );
 			assertTrue( row[2] instanceof Foo );
 			assertTrue( row[3] instanceof Foo );
 		}
 		assertTrue(count!=0);
 		list = s.createQuery( "select avg(foo.float), max(foo.component.name), count(distinct foo.id) from Foo foo" )
 				.list();
 		rs = list.iterator();
 		count=0;
 		while ( rs.hasNext() ) {
 			count++;
 			Object[] row = (Object[]) rs.next();
 			assertTrue( row[0] instanceof Double );
 			assertTrue( row[1] instanceof String );
 			assertTrue( row[2] instanceof Long );
 		}
 		assertTrue(count!=0);
 		list = s.createQuery( "select foo.long, foo.component, foo, foo.foo from Foo foo" ).list();
 		rs = list.iterator();
 		count=0;
 		while ( rs.hasNext() ) {
 			count++;
 			Object[] row = (Object[]) rs.next();
 			assertTrue( row[0] instanceof Long );
 			assertTrue( row[1] instanceof FooComponent );
 			assertTrue( row[2] instanceof Foo );
 			assertTrue( row[3] instanceof Foo );
 		}
 		assertTrue(count!=0);
 
 		s.save( new Holder("ice T") );
 		s.save( new Holder("ice cube") );
 
 		assertTrue( s.createQuery( "from java.lang.Object as o" ).list().size()==15 );
 		assertTrue( s.createQuery( "from Named" ).list().size()==7 );
 		assertTrue( s.createQuery( "from Named n where n.name is not null" ).list().size()==4 );
 		iter = s.createQuery( "from Named n" ).iterate();
 		while ( iter.hasNext() ) {
 			assertTrue( iter.next() instanceof Named );
 		}
 
 		s.save( new Holder("bar") );
 		iter = s.createQuery( "from Named n0, Named n1 where n0.name = n1.name" ).iterate();
 		int cnt = 0;
 		while ( iter.hasNext() ) {
 			Object[] row = (Object[]) iter.next();
 			if ( row[0]!=row[1] ) cnt++;
 		}
 		if ( !(getDialect() instanceof HSQLDialect) ) {
 			assertTrue(cnt==2);
 			assertTrue( s.createQuery( "from Named n0, Named n1 where n0.name = n1.name" ).list().size()==7 );
 		}
 
 		Query qu = s.createQuery("from Named n where n.name = :name");
 		qu.getReturnTypes();
 		qu.getNamedParameters();
 
 		iter = s.createQuery( "from java.lang.Object" ).iterate();
 		int c = 0;
 		while ( iter.hasNext() ) {
 			iter.next();
 			c++;
 		}
 		assertTrue(c==16);
 
 		s.createQuery( "select baz.code, min(baz.count) from Baz baz group by baz.code" ).iterate();
 
 		iter = s.createQuery( "selecT baz from Baz baz where baz.stringDateMap['foo'] is not null or baz.stringDateMap['bar'] = ?" )
 				.setParameter( 0, new Date(), Hibernate.DATE )
 				.iterate();
 		assertFalse( iter.hasNext() );
 		list = s.createQuery( "select baz from Baz baz where baz.stringDateMap['now'] is not null" ).list();
 		assertTrue( list.size()==1 );
 		list = s.createQuery(
 				"select baz from Baz baz where baz.stringDateMap['now'] is not null and baz.stringDateMap['big bang'] < baz.stringDateMap['now']"
 		).list();
 		assertTrue( list.size()==1 );
 		list = s.createQuery( "select index(date) from Baz baz join baz.stringDateMap date" ).list();
 		System.out.println(list);
 		assertTrue( list.size()==2 );
 
 		s.createQuery(
 				"from Foo foo where foo.integer not between 1 and 5 and foo.string not in ('cde', 'abc') and foo.string is not null and foo.integer<=3"
 		).list();
 
 		s.createQuery( "from Baz baz inner join baz.collectionComponent.nested.foos foo where foo.string is null" )
 				.list();
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof MckoiDialect) && !(getDialect() instanceof SAPDBDialect) && !(getDialect() instanceof PointbaseDialect) )  {
 			s.createQuery(
 					"from Baz baz inner join baz.fooSet where '1' in (from baz.fooSet foo where foo.string is not null)"
 			).list();
 			s.createQuery(
 					"from Baz baz where 'a' in elements(baz.collectionComponent.nested.foos) and 1.0 in elements(baz.collectionComponent.nested.floats)"
 			).list();
 			s.createQuery(
 					"from Baz baz where 'b' in elements(baz.collectionComponent.nested.foos) and 1.0 in elements(baz.collectionComponent.nested.floats)"
 			).list();
 		}
 
 		s.createQuery( "from Foo foo join foo.foo where foo.foo in ('1','2','3')" ).list();
 		if ( !(getDialect() instanceof HSQLDialect) )
 			s.createQuery( "from Foo foo left join foo.foo where foo.foo in ('1','2','3')" ).list();
 		s.createQuery( "select foo.foo from Foo foo where foo.foo in ('1','2','3')" ).list();
 		s.createQuery( "select foo.foo.string from Foo foo where foo.foo in ('1','2','3')" ).list();
 		s.createQuery( "select foo.foo.string from Foo foo where foo.foo.string in ('1','2','3')" ).list();
 		s.createQuery( "select foo.foo.long from Foo foo where foo.foo.string in ('1','2','3')" ).list();
 		s.createQuery( "select count(*) from Foo foo where foo.foo.string in ('1','2','3') or foo.foo.long in (1,2,3)" )
 				.list();
 		s.createQuery( "select count(*) from Foo foo where foo.foo.string in ('1','2','3') group by foo.foo.long" )
 				.list();
 
 		s.createQuery( "from Foo foo1 left join foo1.foo foo2 left join foo2.foo where foo1.string is not null" )
 				.list();
 		s.createQuery( "from Foo foo1 left join foo1.foo.foo where foo1.string is not null" ).list();
 		s.createQuery( "from Foo foo1 left join foo1.foo foo2 left join foo1.foo.foo foo3 where foo1.string is not null" )
 				.list();
 
 		s.createQuery( "select foo.formula from Foo foo where foo.formula > 0" ).list();
 
 		int len = s.createQuery( "from Foo as foo join foo.foo as foo2 where foo2.id >'a' or foo2.id <'a'" ).list().size();
 		assertTrue(len==2);
 
-		s.delete("from Holder");
+		for ( Object entity : s.createQuery( "from Holder" ).list() ) {
+			s.delete( entity );
+		}
 
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		baz = (Baz) s.createQuery("from Baz baz left outer join fetch baz.manyToAny").uniqueResult();
 		assertTrue( Hibernate.isInitialized( baz.getManyToAny() ) );
 		assertTrue( baz.getManyToAny().size()==2 );
 		BarProxy barp = (BarProxy) baz.getManyToAny().get(0);
 		s.createQuery( "from Baz baz join baz.manyToAny" ).list();
 		assertTrue( s.createQuery( "select baz from Baz baz join baz.manyToAny a where index(a) = 0" ).list().size()==1 );
 
 		FooProxy foop = (FooProxy) s.get( Foo.class, foo.getKey() );
 		assertTrue( foop == baz.getManyToAny().get(1) );
 
 		barp.setBaz(baz);
 		assertTrue(
 				s.createQuery( "select bar from Bar bar where bar.baz.stringDateMap['now'] is not null" ).list().size()==1 );
 		assertTrue(
 				s.createQuery(
 						"select bar from Bar bar join bar.baz b where b.stringDateMap['big bang'] < b.stringDateMap['now'] and b.stringDateMap['now'] is not null"
 				).list()
 						.size()==1 );
 		assertTrue(
 				s.createQuery(
 						"select bar from Bar bar where bar.baz.stringDateMap['big bang'] < bar.baz.stringDateMap['now'] and bar.baz.stringDateMap['now'] is not null"
 				).list()
 						.size()==1 );
 
 		list = s.createQuery( "select foo.string, foo.component, foo.id from Bar foo" ).list();
 		assertTrue ( ( (FooComponent) ( (Object[]) list.get(0) )[1] ).getName().equals("foo") );
 		list = s.createQuery( "select elements(baz.components) from Baz baz" ).list();
 		assertTrue( list.size()==2 );
 		list = s.createQuery( "select bc.name from Baz baz join baz.components bc" ).list();
 		assertTrue( list.size()==2 );
 		//list = s.find("select bc from Baz baz join baz.components bc");
 
 		s.createQuery("from Foo foo where foo.integer < 10 order by foo.string").setMaxResults(12).list();
 
 		s.delete(barp);
 		s.delete(baz);
 		s.delete( foop.getFoo() );
 		s.delete(foop);
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCascadeDeleteDetached() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		List list = new ArrayList();
 		list.add( new Fee() );
 		baz.setFees( list );
 		s.save( baz );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		s.getTransaction().commit();
 		s.close();
 
 		assertFalse( Hibernate.isInitialized( baz.getFees() ) );
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( baz );
 		s.flush();
 		assertFalse( s.createQuery( "from Fee" ).iterate().hasNext() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = new Baz();
 		list = new ArrayList();
 		list.add( new Fee() );
 		list.add( new Fee() );
 		baz.setFees(list);
 		s.save( baz );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		Hibernate.initialize( baz.getFees() );
 		s.getTransaction().commit();
 		s.close();
 
 		assertTrue( baz.getFees().size() == 2 );
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete(baz);
 		s.flush();
 		assertFalse( s.createQuery( "from Fee" ).iterate().hasNext() );
 		s.getTransaction().commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testForeignKeys() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		Foo foo = new Foo();
 		List bag = new ArrayList();
 		bag.add(foo);
 		baz.setIdFooBag(bag);
 		baz.setFoo(foo);
 		s.save(baz);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNonlazyCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		s.save( baz );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.createCriteria(Baz.class)
 			//.setComment("criteria test")
 			.setFetchMode( "stringDateMap", FetchMode.JOIN )
 			.uniqueResult();
 		assertTrue( Hibernate.isInitialized( baz.getFooToGlarch() ) );
 		assertTrue( Hibernate.isInitialized( baz.getFooComponentToFoo() ) );
 		assertTrue( !Hibernate.isInitialized( baz.getStringSet() ) );
 		assertTrue( Hibernate.isInitialized( baz.getStringDateMap() ) );
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testReuseDeletedCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setDefaults();
 		s.save(baz);
 		s.flush();
 		s.delete(baz);
 		Baz baz2 = new Baz();
 		baz2.setStringArray( new String[] {"x-y-z"} );
 		s.save(baz2);
 		s.getTransaction().commit();
 		s.close();
 
 		baz2.setStringSet( baz.getStringSet() );
 		baz2.setStringArray( baz.getStringArray() );
 		baz2.setFooArray( baz.getFooArray() );
 
 		s = openSession();
 		s.beginTransaction();
 		s.update(baz2);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		assertTrue( baz2.getStringArray().length==3 );
 		assertTrue( baz2.getStringSet().size()==3 );
 		s.delete(baz2);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testPropertyRef() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Holder h = new Holder();
 		h.setName("foo");
 		Holder h2 = new Holder();
 		h2.setName("bar");
 		h.setOtherHolder(h2);
 		Serializable hid = s.save(h);
 		Qux q = new Qux();
 		q.setHolder(h2);
 		Serializable qid = s.save(q);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		h = (Holder) s.load(Holder.class, hid);
 		assertEquals( h.getName(), "foo");
 		assertEquals( h.getOtherHolder().getName(), "bar");
 		Object[] res = (Object[]) s.createQuery( "from Holder h join h.otherHolder oh where h.otherHolder.name = 'bar'" )
 				.list()
 				.get(0);
 		assertTrue( res[0]==h );
 		q = (Qux) s.get(Qux.class, qid);
 		assertTrue( q.getHolder() == h.getOtherHolder() );
 		s.delete(h);
 		s.delete(q);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testQueryCollectionOfValues() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setDefaults();
 		s.save(baz);
 		Glarch g = new Glarch();
 		Serializable gid = s.save(g);
 
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof HSQLDialect) /*&& !(dialect instanceof MckoiDialect)*/ && !(getDialect() instanceof SAPDBDialect) && !(getDialect() instanceof PointbaseDialect) && !(getDialect() instanceof TimesTenDialect) ) {
 			s.createFilter( baz.getFooArray(), "where size(this.bytes) > 0" ).list();
 			s.createFilter( baz.getFooArray(), "where 0 in elements(this.bytes)" ).list();
 		}
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Baz baz join baz.fooSet foo join foo.foo.foo foo2 where foo2.string = 'foo'" ).list();
 		s.createQuery( "from Baz baz join baz.fooArray foo join foo.foo.foo foo2 where foo2.string = 'foo'" ).list();
 		s.createQuery( "from Baz baz join baz.stringDateMap date where index(date) = 'foo'" ).list();
 		s.createQuery( "from Baz baz join baz.topGlarchez g where index(g) = 'A'" ).list();
 		s.createQuery( "select index(g) from Baz baz join baz.topGlarchez g" ).list();
 
 		assertTrue( s.createQuery( "from Baz baz left join baz.stringSet" ).list().size()==3 );
 		baz = (Baz) s.createQuery( "from Baz baz join baz.stringSet str where str='foo'" ).list().get(0);
 		assertTrue( !Hibernate.isInitialized( baz.getStringSet() ) );
 		baz = (Baz) s.createQuery( "from Baz baz left join fetch baz.stringSet" ).list().get(0);
 		assertTrue( Hibernate.isInitialized( baz.getStringSet() ) );
 		assertTrue( s.createQuery( "from Baz baz join baz.stringSet string where string='foo'" ).list().size()==1 );
 		assertTrue( s.createQuery( "from Baz baz inner join baz.components comp where comp.name='foo'" ).list().size()==1 );
 		//List bss = s.find("select baz, ss from Baz baz inner join baz.stringSet ss");
 		s.createQuery( "from Glarch g inner join g.fooComponents comp where comp.fee is not null" ).list();
 		s.createQuery( "from Glarch g inner join g.fooComponents comp join comp.fee fee where fee.count > 0" ).list();
 		s.createQuery( "from Glarch g inner join g.fooComponents comp where comp.fee.count is not null" ).list();
 
 		s.delete(baz);
 		s.delete( s.get(Glarch.class, gid) );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testBatchLoad() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		SortedSet stringSet = new TreeSet();
 		stringSet.add("foo");
 		stringSet.add("bar");
 		Set fooSet = new HashSet();
 		for (int i=0; i<3; i++) {
 			Foo foo = new Foo();
 			s.save(foo);
 			fooSet.add(foo);
 		}
 		baz.setFooSet(fooSet);
 		baz.setStringSet(stringSet);
 		s.save(baz);
 		Baz baz2 = new Baz();
 		fooSet = new HashSet();
 		for (int i=0; i<2; i++) {
 			Foo foo = new Foo();
 			s.save(foo);
 			fooSet.add(foo);
 		}
 		baz2.setFooSet(fooSet);
 		s.save(baz2);
 		Baz baz3 = new Baz();
 		stringSet = new TreeSet();
 		stringSet.add("foo");
 		stringSet.add("baz");
 		baz3.setStringSet(stringSet);
 		s.save(baz3);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		baz3 = (Baz) s.load( Baz.class, baz3.getCode() );
 		assertFalse( Hibernate.isInitialized(baz.getFooSet()) || Hibernate.isInitialized(baz2.getFooSet()) || Hibernate.isInitialized(baz3.getFooSet()) );
 		assertFalse( Hibernate.isInitialized(baz.getStringSet()) || Hibernate.isInitialized(baz2.getStringSet()) || Hibernate.isInitialized(baz3.getStringSet()) );
 		assertTrue( baz.getFooSet().size()==3 );
 		assertTrue( Hibernate.isInitialized(baz.getFooSet()) && Hibernate.isInitialized(baz2.getFooSet()) && Hibernate.isInitialized(baz3.getFooSet()));
 		assertTrue( baz2.getFooSet().size()==2 );
 		assertTrue( baz3.getStringSet().contains("baz") );
 		assertTrue( Hibernate.isInitialized(baz.getStringSet()) && Hibernate.isInitialized(baz2.getStringSet()) && Hibernate.isInitialized(baz3.getStringSet()));
 		assertTrue( baz.getStringSet().size()==2 && baz2.getStringSet().size()==0 );
 		s.delete(baz);
 		s.delete(baz2);
 		s.delete(baz3);
 		Iterator iter = new JoinedIterator( new Iterator[] { baz.getFooSet().iterator(), baz2.getFooSet().iterator() } );
 		while ( iter.hasNext() ) s.delete( iter.next() );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testFetchInitializedCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		Collection fooBag = new ArrayList();
 		fooBag.add( new Foo() );
 		fooBag.add( new Foo() );
 		baz.setFooBag( fooBag );
 		s.save(baz);
 		s.flush();
 		fooBag = baz.getFooBag();
 		s.createQuery( "from Baz baz left join fetch baz.fooBag" ).list();
 		assertTrue( fooBag == baz.getFooBag() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		Object bag = baz.getFooBag();
 		assertFalse( Hibernate.isInitialized( bag ) );
 		s.createQuery( "from Baz baz left join fetch baz.fooBag" ).list();
 		assertTrue( bag==baz.getFooBag() );
 		assertTrue( baz.getFooBag().size() == 2 );
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testLateCollectionAdd() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		List l = new ArrayList();
 		baz.setStringList(l);
 		l.add( "foo" );
 		Serializable id = s.save(baz);
 		l.add("bar");
 		s.flush();
 		l.add( "baz" );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load(Baz.class, id);
 		assertTrue( baz.getStringList().size() == 3 && baz.getStringList().contains( "bar" ) );
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testUpdate() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo foo = new Foo();
 		s.save( foo );
 		s.getTransaction().commit();
 		s.close();
 
 		foo = (Foo) SerializationHelper.deserialize( SerializationHelper.serialize(foo) );
 
 		s = openSession();
 		s.beginTransaction();
 		FooProxy foo2 = (FooProxy) s.load( Foo.class, foo.getKey() );
 		foo2.setString("dirty");
 		foo2.setBoolean( new Boolean( false ) );
 		foo2.setBytes( new byte[] {1, 2, 3} );
 		foo2.setDate( null );
 		foo2.setShort( new Short( "69" ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo2.setString( "dirty again" );
 		s.update(foo2);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo2.setString( "dirty again 2" );
 		s.update( foo2 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Foo foo3 = new Foo();
 		s.load( foo3, foo.getKey() );
 		// There is an interbase bug that causes null integers to return as 0, also numeric precision is <= 15
 		assertTrue( "update", foo2.equalsFoo(foo3) );
 		s.delete( foo3 );
 		doDelete( s, "from Glarch" );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testListRemove() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz b = new Baz();
 		List stringList = new ArrayList();
 		List feeList = new ArrayList();
 		b.setFees(feeList);
 		b.setStringList(stringList);
 		feeList.add( new Fee() );
 		feeList.add( new Fee() );
 		feeList.add( new Fee() );
 		feeList.add( new Fee() );
 		stringList.add("foo");
 		stringList.add("bar");
 		stringList.add("baz");
 		stringList.add("glarch");
 		s.save(b);
 		s.flush();
 		stringList.remove(1);
 		feeList.remove(1);
 		s.flush();
 		s.evict(b);
 		s.refresh(b);
 		assertTrue( b.getFees().size()==3 );
 		stringList = b.getStringList();
 		assertTrue(
 			stringList.size()==3 &&
 			"baz".equals( stringList.get(1) ) &&
 			"foo".equals( stringList.get(0) )
 		);
 		s.delete(b);
 		doDelete( s, "from Fee" );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testFetchInitializedCollectionDupe() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		Collection fooBag = new ArrayList();
 		fooBag.add( new Foo() );
 		fooBag.add( new Foo() );
 		baz.setFooBag(fooBag);
 		s.save( baz );
 		s.flush();
 		fooBag = baz.getFooBag();
 		s.createQuery( "from Baz baz left join fetch baz.fooBag" ).list();
 		assertTrue( Hibernate.isInitialized( fooBag ) );
 		assertTrue( fooBag == baz.getFooBag() );
 		assertTrue( baz.getFooBag().size() == 2 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		Object bag = baz.getFooBag();
 		assertFalse( Hibernate.isInitialized(bag) );
 		s.createQuery( "from Baz baz left join fetch baz.fooBag" ).list();
 		assertTrue( Hibernate.isInitialized( bag ) );
 		assertTrue( bag==baz.getFooBag() );
 		assertTrue( baz.getFooBag().size()==2 );
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSortables() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz b = new Baz();
 		b.setName("name");
 		SortedSet ss = new TreeSet();
 		ss.add( new Sortable("foo") );
 		ss.add( new Sortable("bar") );
 		ss.add( new Sortable("baz") );
 		b.setSortablez(ss);
 		s.save(b);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Criteria cr = s.createCriteria(Baz.class);
 		cr.setFetchMode( "topGlarchez", FetchMode.SELECT );
 		List result = cr
 			.addOrder( Order.asc("name") )
 			.list();
 		assertTrue( result.size()==1 );
 		b = (Baz) result.get(0);
 		assertTrue( b.getSortablez().size()==3 );
 		assertEquals( ( (Sortable) b.getSortablez().iterator().next() ).getName(), "bar" );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		result = s.createQuery("from Baz baz left join fetch baz.sortablez order by baz.name asc")
 			.list();
 		b = (Baz) result.get(0);
 		assertTrue( b.getSortablez().size()==3 );
 		assertEquals( ( (Sortable) b.getSortablez().iterator().next() ).getName(), "bar" );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		result = s.createQuery("from Baz baz order by baz.name asc")
 			.list();
 		b = (Baz) result.get(0);
 		assertTrue( b.getSortablez().size()==3 );
 		assertEquals( ( (Sortable) b.getSortablez().iterator().next() ).getName(), "bar" );
 		s.delete(b);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testFetchList() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		s.save(baz);
 		Foo foo = new Foo();
 		s.save(foo);
 		Foo foo2 = new Foo();
 		s.save(foo2);
 		s.flush();
 		List list = new ArrayList();
 		for ( int i=0; i<5; i++ ) {
 			Fee fee = new Fee();
 			list.add(fee);
 		}
 		baz.setFees(list);
 		list = s.createQuery( "from Foo foo, Baz baz left join fetch baz.fees" ).list();
 		assertTrue( Hibernate.isInitialized( ( (Baz) ( (Object[]) list.get(0) )[1] ).getFees() ) );
 		s.delete(foo);
 		s.delete(foo2);
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testBagOneToMany() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		List list = new ArrayList();
 		baz.setBazez(list);
 		list.add( new Baz() );
 		s.save(baz);
 		s.flush();
 		list.add( new Baz() );
 		s.flush();
 		list.add( 0, new Baz() );
 		s.flush();
 		s.delete( list.remove(1) );
 		s.flush();
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testQueryLockMode() throws Exception {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Bar bar = new Bar();
 		s.save(bar);
 		s.flush();
 		bar.setString("changed");
 		Baz baz = new Baz();
 		baz.setFoo(bar);
 		s.save(baz);
 		Query q = s.createQuery("from Foo foo, Bar bar");
 		if ( !(getDialect() instanceof DB2Dialect) ) {
 			q.setLockMode("bar", LockMode.UPGRADE);
 		}
 		Object[] result = (Object[]) q.uniqueResult();
 		Object b = result[0];
 		assertTrue( s.getCurrentLockMode(b)==LockMode.WRITE && s.getCurrentLockMode( result[1] )==LockMode.WRITE );
 		tx.commit();
 
 		tx = s.beginTransaction();
 		assertTrue( s.getCurrentLockMode( b ) == LockMode.NONE );
 		s.createQuery( "from Foo foo" ).list();
 		assertTrue( s.getCurrentLockMode(b)==LockMode.NONE );
 		q = s.createQuery("from Foo foo");
 		q.setLockMode( "foo", LockMode.READ );
 		q.list();
 		assertTrue( s.getCurrentLockMode( b ) == LockMode.READ );
 		s.evict( baz );
 		tx.commit();
 
 		tx = s.beginTransaction();
 		assertTrue( s.getCurrentLockMode(b)==LockMode.NONE );
 		s.delete( s.load( Baz.class, baz.getCode() ) );
 		assertTrue( s.getCurrentLockMode(b)==LockMode.NONE );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		q = s.createQuery("from Foo foo, Bar bar, Bar bar2");
 		if ( !(getDialect() instanceof DB2Dialect) ) {
 			q.setLockMode("bar", LockMode.UPGRADE);
 		}
 		q.setLockMode("bar2", LockMode.READ);
 		result = (Object[]) q.list().get(0);
 		if ( !(getDialect() instanceof DB2Dialect) ) {
 			assertTrue( s.getCurrentLockMode( result[0] )==LockMode.UPGRADE && s.getCurrentLockMode( result[1] )==LockMode.UPGRADE );
 		}
 		s.delete( result[0] );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testManyToManyBag() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		Serializable id = s.save(baz);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load(Baz.class, id);
 		baz.getFooBag().add( new Foo() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load(Baz.class, id);
 		assertTrue( !Hibernate.isInitialized( baz.getFooBag() ) );
 		assertTrue( baz.getFooBag().size()==1 );
 		if ( !(getDialect() instanceof HSQLDialect) ) assertTrue( Hibernate.isInitialized( baz.getFooBag().iterator().next() ) );
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testIdBag() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		s.save(baz);
 		List l = new ArrayList();
 		List l2 = new ArrayList();
 		baz.setIdFooBag(l);
 		baz.setByteBag(l2);
 		l.add( new Foo() );
 		l.add( new Bar() );
 		byte[] bytes = "ffo".getBytes();
 		l2.add(bytes);
 		l2.add( "foo".getBytes() );
 		s.flush();
 		l.add( new Foo() );
 		l.add( new Bar() );
 		l2.add( "bar".getBytes() );
 		s.flush();
 		s.delete( l.remove(3) );
 		bytes[1]='o';
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load(Baz.class, baz.getCode());
 		assertTrue( baz.getIdFooBag().size()==3 );
 		assertTrue( baz.getByteBag().size()==3 );
 		bytes = "foobar".getBytes();
 		Iterator iter = baz.getIdFooBag().iterator();
 		while ( iter.hasNext() ) s.delete( iter.next() );
 		baz.setIdFooBag(null);
 		baz.getByteBag().add(bytes);
 		baz.getByteBag().add(bytes);
 		assertTrue( baz.getByteBag().size()==5 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load(Baz.class, baz.getCode());
 		assertTrue( baz.getIdFooBag().size()==0 );
 		assertTrue( baz.getByteBag().size()==5 );
 		baz.getIdFooBag().add( new Foo() );
 		iter = baz.getByteBag().iterator();
 		iter.next();
 		iter.remove();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load(Baz.class, baz.getCode());
 		assertTrue( baz.getIdFooBag().size()==1 );
 		assertTrue( baz.getByteBag().size()==4 );
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	private boolean isOuterJoinFetchingDisabled() {
 		return new Integer(0).equals( ( (SessionFactoryImplementor) sessionFactory() ).getSettings().getMaximumFetchDepth() );
 	}
 
 	@Test
 	public void testForceOuterJoin() throws Exception {
 		if ( isOuterJoinFetchingDisabled() ) {
 			return;
 		}
 
 		Session s = openSession();
 		s.beginTransaction();
 		Glarch g = new Glarch();
 		FooComponent fc = new FooComponent();
 		fc.setGlarch(g);
 		FooProxy f = new Foo();
 		FooProxy f2 = new Foo();
 		f.setComponent(fc);
 		f.setFoo(f2);
 		s.save(f2);
 		Serializable id = s.save(f);
 		Serializable gid = s.getIdentifier( f.getComponent().getGlarch() );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().evict(Foo.class);
 
 		s = openSession();
 		s.beginTransaction();
 		f = (FooProxy) s.load(Foo.class, id);
 		assertFalse( Hibernate.isInitialized(f) );
 		assertTrue( Hibernate.isInitialized( f.getComponent().getGlarch() ) ); //outer-join="true"
 		assertFalse( Hibernate.isInitialized( f.getFoo() ) ); //outer-join="auto"
 		assertEquals( s.getIdentifier( f.getComponent().getGlarch() ), gid );
 		s.delete(f);
 		s.delete( f.getFoo() );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testEmptyCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Serializable id = s.save( new Baz() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Baz baz = (Baz) s.load(Baz.class, id);
 		Set foos = baz.getFooSet();
 		assertTrue( foos.size() == 0 );
 		Foo foo = new Foo();
 		foos.add( foo );
 		s.save(foo);
 		s.flush();
 		s.delete(foo);
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testOneToOneGenerator() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		X x = new X();
 		Y y = new Y();
 		x.setY(y);
 		y.setTheX(x);
 		x.getXxs().add( new X.XX(x) );
 		x.getXxs().add( new X.XX(x) );
 		Serializable id = s.save(y);
 		assertEquals( id, s.save(x) );
 		s.flush();
 		assertTrue( s.contains(y) && s.contains(x) );
 		s.getTransaction().commit();
 		s.close();
 		assertEquals( new Long(x.getId()), y.getId() );
 
 		s = openSession();
 		s.beginTransaction();
 		x = new X();
 		y = new Y();
 		x.setY(y);
 		y.setTheX(x);
 		x.getXxs().add( new X.XX(x) );
 		s.save(y);
 		s.flush();
 		assertTrue( s.contains(y) && s.contains(x) );
 		s.getTransaction().commit();
 		s.close();
 		assertEquals( new Long(x.getId()), y.getId() );
 
 		s = openSession();
 		s.beginTransaction();
 		x = new X();
 		y = new Y();
 		x.setY(y);
 		y.setTheX(x);
 		x.getXxs().add( new X.XX(x) );
 		x.getXxs().add( new X.XX(x) );
 		id = s.save(x);
 		assertEquals( id, y.getId() );
 		assertEquals( id, new Long( x.getId() ) );
 		s.flush();
 		assertTrue( s.contains(y) && s.contains(x) );
 		doDelete( s, "from X x" );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testLimit() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		for ( int i=0; i<10; i++ ) s.save( new Foo() );
 		Iterator iter = s.createQuery("from Foo foo")
 			.setMaxResults(4)
 			.setFirstResult(2)
 			.iterate();
 		int count=0;
 		while ( iter.hasNext() ) {
 			iter.next();
 			count++;
 		}
 		assertTrue(count==4);
 		iter = s.createQuery("select distinct foo from Foo foo")
 			.setMaxResults(2)
 			.setFirstResult(2)
 			.list()
 			.iterator();
 		count=0;
 		while ( iter.hasNext() ) {
 			iter.next();
 			count++;
 		}
 		assertTrue(count==2);
 		iter = s.createQuery("select distinct foo from Foo foo")
 		.setMaxResults(3)
 		.list()
 		.iterator();
 		count=0;
 		while ( iter.hasNext() ) {
 			iter.next();
 			count++;
 		}
 		assertTrue(count==3);
 		assertEquals( 10, doDelete( s, "from Foo foo" ) );
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCustom() throws Exception {
 		GlarchProxy g = new Glarch();
 		Multiplicity m = new Multiplicity();
 		m.count = 12;
 		m.glarch = (Glarch) g;
 		g.setMultiple(m);
 
 		Session s = openSession();
 		s.beginTransaction();
 		Serializable gid = s.save(g);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		//g = (Glarch) s.createQuery( "from Glarch g where g.multiple.count=12" ).list().get(0);
 		s.createQuery( "from Glarch g where g.multiple.count=12" ).list().get( 0 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (Glarch) s.createQuery( "from Glarch g where g.multiple.glarch=g and g.multiple.count=12" ).list().get(0);
 		assertTrue( g.getMultiple()!=null );
 		assertEquals( g.getMultiple().count, 12 );
 		assertSame(g.getMultiple().glarch, g);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( g.getMultiple() != null );
 		assertEquals( g.getMultiple().count, 12 );
 		assertSame( g.getMultiple().glarch, g );
 		s.delete(g);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSaveAddDelete() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		Set bars = new HashSet();
 		baz.setCascadingBars( bars );
 		s.save( baz );
 		s.flush();
 		baz.getCascadingBars().add( new Bar() );
 		s.delete(baz);
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNamedParams() throws Exception {
 		Bar bar = new Bar();
 		Bar bar2 = new Bar();
 		bar.setName("Bar");
 		bar2.setName("Bar Two");
 		bar.setX( 10 );
 		bar2.setX( 1000 );Baz baz = new Baz();
 		baz.setCascadingBars( new HashSet() );
 		baz.getCascadingBars().add(bar);
 		bar.setBaz(baz);
 
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		s.save( baz );
 		s.save( bar2 );
 
 		List list = s.createQuery(
 				"from Bar bar left join bar.baz baz left join baz.cascadingBars b where bar.name like 'Bar %'"
 		).list();
 		Object row = list.iterator().next();
 		assertTrue( row instanceof Object[] && ( (Object[]) row ).length==3 );
 
 		Query q = s.createQuery("select bar, b from Bar bar left join bar.baz baz left join baz.cascadingBars b where bar.name like 'Bar%'");
 		list = q.list();
 		if ( !(getDialect() instanceof SAPDBDialect) ) assertTrue( list.size()==2 );
 
 		q = s.createQuery("select bar, b from Bar bar left join bar.baz baz left join baz.cascadingBars b where ( bar.name in (:nameList) or bar.name in (:nameList) ) and bar.string = :stringVal");
 		HashSet nameList = new HashSet();
 		nameList.add( "bar" );
 		nameList.add( "Bar" );
 		nameList.add( "Bar Two" );
 		q.setParameterList( "nameList", nameList );
 		q.setParameter( "stringVal", "a string" );
 		list = q.list();
 		if ( !(getDialect() instanceof SAPDBDialect) ) assertTrue( list.size()==2 );
 
 		try {
 			q.setParameterList("nameList", (Collection)null);
 			fail("Should throw an queryexception when passing a null!");
 		} catch (QueryException qe) {
 			//should happen
 		}
 
 		q = s.createQuery("select bar, b from Bar bar inner join bar.baz baz inner join baz.cascadingBars b where bar.name like 'Bar%'");
 		Object result = q.uniqueResult();
 		assertTrue( result != null );
 		q = s.createQuery("select bar, b from Bar bar left join bar.baz baz left join baz.cascadingBars b where bar.name like :name and b.name like :name");
 		q.setString( "name", "Bar%" );
 		list = q.list();
 		assertTrue( list.size()==1 );
 
 
 		// This test added for issue HB-297 - there is an named parameter in the Order By clause
 		q = s.createQuery("select bar from Bar bar order by ((bar.x - :valueX)*(bar.x - :valueX))");
 		q.setInteger( "valueX", bar.getX() + 1 );
 		list = q.list();
 		assertTrue( ((Bar) list.get( 0 )).getX() == bar.getX() );
 		q.setInteger( "valueX", bar2.getX() + 1 );
 		list = q.list();
 		assertTrue( ((Bar)list.get(0)).getX() == bar2.getX());
 
 		s.delete(baz);
 		s.delete(bar2);
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	@RequiresDialectFeature(
 			value = DialectChecks.SupportsEmptyInListCheck.class,
 			comment = "Dialect does not support SQL empty in list [x in ()]"
 	)
 	public void testEmptyInListQuery() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		Query q = s.createQuery( "select bar from Bar as bar where bar.name in (:nameList)" );
 		q.setParameterList( "nameList", Collections.EMPTY_LIST );
 		assertEquals( 0, q.list().size() );
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testParameterCheck() throws HibernateException {
 		Session s = openSession();
 		try {
 			Query q = s.createQuery("select bar from Bar as bar where bar.x > :myX");
 			q.list();
 			fail("Should throw QueryException for missing myX");
 		}
 		catch (QueryException iae) {
 			// should happen
 		}
 		finally {
 			s.close();
 		}
 
 		s = openSession();
 		try {
 			Query q = s.createQuery("select bar from Bar as bar where bar.x > ?");
 			q.list();
 			fail("Should throw QueryException for missing ?");
 		}
 		catch (QueryException iae) {
 			// should happen
 		}
 		finally {
 			s.close();
 		}
 
 		s = openSession();
 		try {
 			Query q = s.createQuery("select bar from Bar as bar where bar.x > ? or bar.short = 1 or bar.string = 'ff ? bb'");
 			q.setInteger(0, 1);
 			q.list();
 		}
 		catch (QueryException iae) {
 			fail("Should not throw QueryException for missing ?");
 		}
 		finally {
 			s.close();
 		}
 
 		s = openSession();
 		try {
 			Query q = s.createQuery("select bar from Bar as bar where bar.string = ' ? ' or bar.string = '?'");
 			q.list();
 		}
 		catch (QueryException iae) {
 			fail("Should not throw QueryException for ? in quotes");
 		}
 		finally {
 			s.close();
 		}
 
 		s = openSession();
 		try {
 			Query q = s.createQuery("select bar from Bar as bar where bar.string = ? or bar.string = ? or bar.string = ?");
 			q.setParameter(0, "bull");
 			q.setParameter(2, "shit");
 			q.list();
 			fail("should throw exception telling me i have not set parameter 1");
 		}
 		catch (QueryException iae) {
 			// should happen!
 		}
 		finally {
 			s.close();
 		}
 	}
 
 	@Test
 	public void testDyna() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		GlarchProxy g = new Glarch();
 		g.setName("G");
 		Serializable id = s.save(g);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, id);
 		assertTrue( g.getName().equals("G") );
 		assertTrue( g.getDynaBean().get("foo").equals("foo") && g.getDynaBean().get("bar").equals( new Integer(66) ) );
 		assertTrue( ! (g instanceof Glarch) );
 		g.getDynaBean().put("foo", "bar");
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, id);
 		assertTrue( g.getDynaBean().get("foo").equals("bar") && g.getDynaBean().get("bar").equals( new Integer(66) ) );
 		g.setDynaBean(null);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, id);
 		assertTrue( g.getDynaBean()==null );
 		s.delete(g);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testFindByCriteria() throws Exception {
 		if ( getDialect() instanceof DB2Dialect ) {
 			return;
 		}
 
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Foo f = new Foo();
 		s.save( f );
 		s.flush();
 
 		List list = s.createCriteria(Foo.class)
 			.add( Restrictions.eq( "integer", f.getInteger() ) )
 			.add( Restrictions.eqProperty("integer", "integer") )
 			.add( Restrictions.like( "string", f.getString().toUpperCase() ).ignoreCase() )
 			.add( Restrictions.in( "boolean", new Boolean[] { f.getBoolean(), f.getBoolean() } ) )
 			.setFetchMode("foo", FetchMode.JOIN)
 			.setFetchMode("baz", FetchMode.SELECT)
 			.setFetchMode("abstracts", FetchMode.JOIN)
 			.list();
 		assertTrue( list.size() == 1 && list.get( 0 ) == f );
 
 		list = s.createCriteria(Foo.class).add(
 				Restrictions.disjunction()
 					.add( Restrictions.eq( "integer", f.getInteger() ) )
 					.add( Restrictions.like( "string", f.getString() ) )
 					.add( Restrictions.eq( "boolean", f.getBoolean() ) )
 			)
 			.add( Restrictions.isNotNull("boolean") )
 			.list();
 		assertTrue( list.size() == 1 && list.get( 0 ) == f );
 
 		Foo example = new Foo();
 		example.setString("a STRing");
 		list = s.createCriteria(Foo.class).add(
 			Example.create(example)
 				.excludeZeroes()
 				.ignoreCase()
 				.excludeProperty("bool")
 				.excludeProperty("char")
 				.excludeProperty("yesno")
 			)
 			.list();
 		assertTrue(
 				"Example API without like did not work correctly, size was " + list.size(),
 				list.size() == 1 && list.get( 0 ) == f
 		);
 		example.setString("rin");
 
 		list = s.createCriteria(Foo.class).add(
 			Example.create(example)
 				.excludeZeroes()
 				.enableLike(MatchMode.ANYWHERE)
 				.excludeProperty("bool")
 				.excludeProperty("char")
 				.excludeProperty("yesno")
 			)
 			.list();
 		assertTrue( "Example API without like did not work correctly, size was " + list.size(), list.size()==1 && list.get(0)==f );
 
 		list = s.createCriteria(Foo.class)
 			.add( Restrictions.or(
 					Restrictions.and(
 					Restrictions.eq( "integer", f.getInteger() ),
 					Restrictions.like( "string", f.getString() )
 				),
 				Restrictions.eq( "boolean", f.getBoolean() )
 			) )
 			.list();
 		assertTrue( list.size()==1 && list.get(0)==f );
 		list = s.createCriteria(Foo.class)
 			.setMaxResults(5)
 			.addOrder( Order.asc("date") )
 			.list();
 		assertTrue( list.size()==1 && list.get(0)==f );
 		if(!(getDialect() instanceof TimesTenDialect || getDialect() instanceof HSQLDialect)) {
 			list = s.createCriteria(Foo.class).setMaxResults(0).list();
 			assertTrue( list.size()==0 );
 		}
 		list = s.createCriteria(Foo.class)
 			.setFirstResult(1)
 			.addOrder( Order.asc("date") )
 			.addOrder( Order.desc("string") )
 			.list();
 		assertTrue( list.size() == 0 );
 		list = s.createCriteria(Foo.class)
 			.setFetchMode( "component.importantDates", FetchMode.JOIN )
 			.list();
 		assertTrue( list.size() == 3 );
 
 		list = s.createCriteria(Foo.class)
 			.setFetchMode( "component.importantDates", FetchMode.JOIN )
 			.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY)
 			.list();
 		assertTrue( list.size()==1 );
 
 		f.setFoo( new Foo() );
 		s.save( f.getFoo() );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		list = s.createCriteria(Foo.class)
 			.add( Restrictions.eq( "integer", f.getInteger() ) )
 			.add( Restrictions.like( "string", f.getString() ) )
 			.add( Restrictions.in( "boolean", new Boolean[] { f.getBoolean(), f.getBoolean() } ) )
 			.add( Restrictions.isNotNull("foo") )
 			.setFetchMode( "foo", FetchMode.JOIN )
 			.setFetchMode( "baz", FetchMode.SELECT )
 			.setFetchMode( "component.glarch", FetchMode.SELECT )
 			.setFetchMode( "foo.baz", FetchMode.SELECT )
 			.setFetchMode( "foo.component.glarch", FetchMode.SELECT )
 			.list();
 		f = (Foo) list.get(0);
 		assertTrue( Hibernate.isInitialized( f.getFoo() ) );
 		assertTrue( !Hibernate.isInitialized( f.getComponent().getGlarch() ) );
 
 		s.save( new Bar() );
 		list = s.createCriteria(Bar.class)
 			.list();
 		assertTrue( list.size() == 1 );
 		assertTrue( s.createCriteria(Foo.class).list().size()==3 );
 		s.delete( list.get( 0 ) );
 
 		s.delete( f.getFoo() );
 		s.delete(f);
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testAfterDelete() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo foo = new Foo();
 		s.save(foo);
 		s.flush();
 		s.delete(foo);
 		s.save(foo);
 		s.delete(foo);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionWhere() throws Exception {
 		Foo foo1 = new Foo();
 		Foo foo2 = new Foo();
 		Baz baz = new Baz();
 		Foo[] arr = new Foo[10];
 		arr[0] = foo1;
 		arr[9] = foo2;
 
 		Session s = openSession();
 		s.beginTransaction();
 		s.save( foo1 );
 		s.save(foo2);
 		baz.setFooArray( arr );
 		s.save( baz );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		assertTrue( baz.getFooArray().length == 1 );
 		assertTrue( s.createQuery( "from Baz baz join baz.fooArray foo" ).list().size()==1 );
 		assertTrue( s.createQuery( "from Foo foo" ).list().size()==2 );
 		assertTrue( s.createFilter( baz.getFooArray(), "" ).list().size() == 1 );
 		//assertTrue( s.delete("from java.lang.Object o")==9 );
 		doDelete( s, "from Foo foo" );
 		String bazid = baz.getCode();
 		s.delete( baz );
 		int rows=s.connection().createStatement().executeUpdate(
 			"delete from FOO_ARRAY where id_='" + bazid + "' and i>=8"
 		);
 		assertTrue( rows == 1 );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testComponentParent() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		BarProxy bar = new Bar();
 		bar.setBarComponent( new FooComponent() );
 		Baz baz = new Baz();
 		baz.setComponents( new FooComponent[] { new FooComponent(), new FooComponent() } );
 		s.save(bar);
 		s.save(baz);
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		bar = (BarProxy) s.load(Bar.class, bar.getKey());
 		s.load(baz, baz.getCode());
 		assertTrue( bar.getBarComponent().getParent()==bar );
 		assertTrue( baz.getComponents()[0].getBaz()==baz && baz.getComponents()[1].getBaz()==baz );
 		s.delete(baz);
 		s.delete(bar);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionCache() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setDefaults();
 		s.save(baz);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.load( Baz.class, baz.getCode() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void ntestAssociationId() throws Exception {
 		// IMPL NOTE : previously not being run due to the name
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Bar bar = new Bar();
 		String id = (String) s.save(bar);
 		MoreStuff more = new MoreStuff();
 		more.setName("More Stuff");
 		more.setIntId(12);
 		more.setStringId("id");
 		Stuff stuf = new Stuff();
 		stuf.setMoreStuff(more);
 		more.setStuffs( new ArrayList() );
 		more.getStuffs().add(stuf);
 		stuf.setFoo(bar);
 		stuf.setId(1234);
 		stuf.setProperty( TimeZone.getDefault() );
 		s.save(more);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List results = s.createQuery(
 				"from Stuff as s where s.foo.id = ? and s.id.id = ? and s.moreStuff.id.intId = ? and s.moreStuff.id.stringId = ?"
 		)
 				.setParameter( 0, bar, Hibernate.entity(Foo.class) )
 				.setParameter( 1, new Long(1234), Hibernate.LONG )
 				.setParameter( 2, new Integer(12), Hibernate.INTEGER )
 				.setParameter( 3, "id", Hibernate.STRING )
 				.list();
 		assertEquals( 1, results.size() );
 		results = s.createQuery( "from Stuff as s where s.foo.id = ? and s.id.id = ? and s.moreStuff.name = ?" )
 				.setParameter( 0, bar, Hibernate.entity(Foo.class) )
 				.setParameter( 1, new Long(1234), Hibernate.LONG )
 				.setParameter( 2, "More Stuff", Hibernate.STRING )
 				.list();
 		assertEquals( 1, results.size() );
 		s.createQuery( "from Stuff as s where s.foo.string is not null" ).list();
 		assertTrue(
 				s.createQuery( "from Stuff as s where s.foo > '0' order by s.foo" ).list().size()==1
 		);
 		//s.createCriteria(Stuff.class).createCriteria("id.foo").add( Expression.isNull("foo") ).list();
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		FooProxy foo = (FooProxy) s.load(Foo.class, id);
 		s.load(more, more);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Stuff stuff = new Stuff();
 		stuff.setFoo(foo);
 		stuff.setId(1234);
 		stuff.setMoreStuff(more);
 		s.load(stuff, stuff);
 		assertTrue( stuff.getProperty().equals( TimeZone.getDefault() ) );
 		assertTrue( stuff.getMoreStuff().getName().equals("More Stuff") );
 		doDelete( s, "from MoreStuff" );
 		doDelete( s, "from Foo foo" );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCascadeSave() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		List list = new ArrayList();
 		list.add( new Fee() );
 		list.add( new Fee() );
 		baz.setFees( list );
 		s.save(baz);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		assertTrue( baz.getFees().size() == 2 );
 		s.delete(baz);
 		assertTrue( !s.createQuery( "from Fee fee" ).iterate().hasNext() );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionsInSelect() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Foo[] foos = new Foo[] { null, new Foo() };
 		s.save( foos[1] );
 		Baz baz = new Baz();
 		baz.setDefaults();
 		baz.setFooArray(foos);
 		s.save(baz);
 		Baz baz2 = new Baz();
 		baz2.setDefaults();
 		s.save(baz2);
 
 		Bar bar = new Bar();
 		bar.setBaz(baz);
 		s.save(bar);
 
 		List list = s.createQuery( "select new Result(foo.string, foo.long, foo.integer) from Foo foo" ).list();
 		assertTrue( list.size()==2 && ( list.get(0) instanceof Result ) && ( list.get(1) instanceof Result ) );
 		/*list = s.find("select new Result( baz.name, foo.long, count(elements(baz.fooArray)) ) from Baz baz join baz.fooArray foo group by baz.name, foo.long");
 		assertTrue( list.size()==1 && ( list.get(0) instanceof Result ) );
 		Result r = ((Result) list.get(0) );
 		assertEquals( r.getName(), baz.getName() );
 		assertEquals( r.getCount(), 1 );
 		assertEquals( r.getAmount(), foos[1].getLong().longValue() );*/
 		list = s.createQuery(
 				"select new Result( baz.name, max(foo.long), count(foo) ) from Baz baz join baz.fooArray foo group by baz.name"
 		).list();
 		assertTrue( list.size()==1 && ( list.get(0) instanceof Result ) );
 		Result r = ((Result) list.get(0) );
 		assertEquals( r.getName(), baz.getName() );
 		assertEquals( r.getCount(), 1 );
 		assertTrue( r.getAmount() > 696969696969696000l );
 
 
 		//s.find("select max( elements(bar.baz.fooArray) ) from Bar as bar");
 		//The following test is disabled for databases with no subselects...also for Interbase (not sure why).
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof HSQLDialect) /*&& !(dialect instanceof MckoiDialect)*/ && !(getDialect() instanceof SAPDBDialect) && !(getDialect() instanceof PointbaseDialect) )  {
 			s.createQuery( "select count(*) from Baz as baz where 1 in indices(baz.fooArray)" ).list();
 			s.createQuery( "select count(*) from Bar as bar where 'abc' in elements(bar.baz.fooArray)" ).list();
 			s.createQuery( "select count(*) from Bar as bar where 1 in indices(bar.baz.fooArray)" ).list();
 			if ( !(getDialect() instanceof DB2Dialect) &&  !(getDialect() instanceof Oracle8iDialect ) && !( getDialect() instanceof SybaseDialect ) && !( getDialect() instanceof Sybase11Dialect ) && !( getDialect() instanceof SybaseASE15Dialect ) && !( getDialect() instanceof PostgreSQLDialect )) {
 				// SybaseAnywhereDialect supports implicit conversions from strings to ints
 				s.createQuery(
 						"select count(*) from Bar as bar, bar.component.glarch.proxyArray as g where g.id in indices(bar.baz.fooArray)"
 				).list();
 				s.createQuery(
 						"select max( elements(bar.baz.fooArray) ) from Bar as bar, bar.component.glarch.proxyArray as g where g.id in indices(bar.baz.fooArray)"
 				).list();
 			}
 			s.createQuery(
 					"select count(*) from Bar as bar where '1' in (from bar.component.glarch.proxyArray g where g.name='foo')"
 			).list();
 			s.createQuery(
 					"select count(*) from Bar as bar where '1' in (from bar.component.glarch.proxyArray g where g.name='foo')"
 			).list();
 			s.createQuery(
 					"select count(*) from Bar as bar left outer join bar.component.glarch.proxyArray as pg where '1' in (from bar.component.glarch.proxyArray)"
 			).list();
 		}
 
 		list = s.createQuery(
 				"from Baz baz left join baz.fooToGlarch join fetch baz.fooArray foo left join fetch foo.foo"
 		).list();
 		assertTrue( list.size()==1 && ( (Object[]) list.get(0) ).length==2 );
 
 		s.createQuery(
 				"select baz.name from Bar bar inner join bar.baz baz inner join baz.fooSet foo where baz.name = bar.string"
 		).list();
 		s.createQuery(
 				"SELECT baz.name FROM Bar AS bar INNER JOIN bar.baz AS baz INNER JOIN baz.fooSet AS foo WHERE baz.name = bar.string"
 		).list();
 
 		if ( !( getDialect() instanceof HSQLDialect ) ) s.createQuery(
 				"select baz.name from Bar bar join bar.baz baz left outer join baz.fooSet foo where baz.name = bar.string"
 		).list();
 
 		s.createQuery( "select baz.name from Bar bar join bar.baz baz join baz.fooSet foo where baz.name = bar.string" )
 				.list();
 		s.createQuery(
 				"SELECT baz.name FROM Bar AS bar JOIN bar.baz AS baz JOIN baz.fooSet AS foo WHERE baz.name = bar.string"
 		).list();
 
 		if ( !( getDialect() instanceof HSQLDialect ) ) {
 			s.createQuery(
 					"select baz.name from Bar bar left join bar.baz baz left join baz.fooSet foo where baz.name = bar.string"
 			).list();
 			s.createQuery( "select foo.string from Bar bar left join bar.baz.fooSet foo where bar.string = foo.string" )
 					.list();
 		}
 
 		s.createQuery(
 				"select baz.name from Bar bar left join bar.baz baz left join baz.fooArray foo where baz.name = bar.string"
 		).list();
 		s.createQuery( "select foo.string from Bar bar left join bar.baz.fooArray foo where bar.string = foo.string" )
 				.list();
 
 		s.createQuery(
 				"select bar.string, foo.string from Bar bar inner join bar.baz as baz inner join baz.fooSet as foo where baz.name = 'name'"
 		).list();
 		s.createQuery( "select foo from Bar bar inner join bar.baz as baz inner join baz.fooSet as foo" ).list();
 		s.createQuery( "select foo from Bar bar inner join bar.baz.fooSet as foo" ).list();
 
 		s.createQuery(
 				"select bar.string, foo.string from Bar bar join bar.baz as baz join baz.fooSet as foo where baz.name = 'name'"
 		).list();
 		s.createQuery( "select foo from Bar bar join bar.baz as baz join baz.fooSet as foo" ).list();
 		s.createQuery( "select foo from Bar bar join bar.baz.fooSet as foo" ).list();
 
 		assertTrue( s.createQuery( "from Bar bar join bar.baz.fooArray foo" ).list().size()==1 );
 
 		assertTrue( s.createQuery( "from Bar bar join bar.baz.fooSet foo" ).list().size()==0 );
 		assertTrue( s.createQuery( "from Bar bar join bar.baz.fooArray foo" ).list().size()==1 );
 
 		s.delete(bar);
 
 		if ( getDialect() instanceof DB2Dialect || getDialect() instanceof PostgreSQLDialect ) {
 			s.createQuery( "select one from One one join one.manies many group by one order by count(many)" ).iterate();
 			s.createQuery( "select one from One one join one.manies many group by one having count(many) < 5" )
 					.iterate();
 		}
 
 		s.createQuery( "from One one join one.manies many where one.id = 1 and many.id = 1" ).list();
 		s.createQuery( "select one.id, elements(one.manies) from One one" ).iterate();
 		s.createQuery( "select max( elements(one.manies) ) from One one" ).iterate();
 		s.createQuery( "select one, elements(one.manies) from One one" ).list();
 		Iterator iter = s.createQuery( "select elements(baz.fooArray) from Baz baz where baz.id=?" )
 				.setParameter( 0, baz.getCode(), Hibernate.STRING )
 				.iterate();
 		assertTrue( iter.next()==foos[1] && !iter.hasNext() );
 		list = s.createQuery( "select elements(baz.fooArray) from Baz baz where baz.id=?" )
 				.setParameter( 0, baz.getCode(), Hibernate.STRING )
 				.list();
 		assertEquals( 1, list.size() );
 		iter = s.createQuery( "select indices(baz.fooArray) from Baz baz where baz.id=?" )
 				.setParameter( 0, baz.getCode(), Hibernate.STRING )
 				.iterate();
 		assertTrue( iter.next().equals( new Integer(1) ) && !iter.hasNext() );
 
 		iter = s.createQuery( "select size(baz.stringSet) from Baz baz where baz.id=?" )
 				.setParameter( 0, baz.getCode(), Hibernate.STRING )
 				.iterate();
 		assertEquals( new Integer(3), iter.next() );
 
 		s.createQuery( "from Foo foo where foo.component.glarch.id is not null" ).list();
 
 		iter = s.createQuery(
 				"select baz, size(baz.stringSet), count( distinct elements(baz.stringSet) ), max( elements(baz.stringSet) ) from Baz baz group by baz"
 		).iterate();
 		while ( iter.hasNext() ) {
 			Object[] arr = (Object[]) iter.next();
             LOG.info(arr[0] + " " + arr[1] + " " + arr[2] + " " + arr[3]);
 		}
 
 		s.delete(baz);
 		s.delete(baz2);
 		s.delete( foos[1] );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testNewFlushing() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setDefaults();
 		s.save(baz);
 		s.flush();
 		baz.getStringArray()[0] = "a new value";
 		Iterator iter = s.createQuery( "from Baz baz" ).iterate();//no flush
 		assertTrue( iter.next()==baz );
 		iter = s.createQuery( "select elements(baz.stringArray) from Baz baz" ).iterate();
 		boolean found = false;
 		while ( iter.hasNext() ) {
 			if ( iter.next().equals("a new value") ) found = true;
 		}
 		assertTrue( found );
 		baz.setStringArray( null );
 		s.createQuery( "from Baz baz" ).iterate(); //no flush
 		iter = s.createQuery( "select elements(baz.stringArray) from Baz baz" ).iterate();
 		assertTrue( !iter.hasNext() );
 		baz.getStringList().add( "1E1" );
 		iter = s.createQuery( "from Foo foo" ).iterate();//no flush
 		assertTrue( !iter.hasNext() );
 		iter = s.createQuery( "select elements(baz.stringList) from Baz baz" ).iterate();
 		found = false;
 		while ( iter.hasNext() ) {
 			if ( iter.next().equals("1E1") ) found = true;
 		}
 		assertTrue( found );
 		baz.getStringList().remove( "1E1" );
 		iter = s.createQuery( "select elements(baz.stringArray) from Baz baz" ).iterate(); //no flush
 		iter = s.createQuery( "select elements(baz.stringList) from Baz baz" ).iterate();
 		found = false;
 		while ( iter.hasNext() ) {
 			if ( iter.next().equals("1E1") ) found = true;
 		}
 		assertTrue(!found);
 
 		List newList = new ArrayList();
 		newList.add("value");
 		baz.setStringList( newList );
 		iter = s.createQuery( "from Foo foo" ).iterate();//no flush
 		baz.setStringList( null );
 		iter = s.createQuery( "select elements(baz.stringList) from Baz baz" ).iterate();
 		assertTrue( !iter.hasNext() );
 
 		baz.setStringList(newList);
 		iter = s.createQuery( "from Foo foo" ).iterate();//no flush
 		iter = s.createQuery( "select elements(baz.stringList) from Baz baz" ).iterate();
 		assertTrue( iter.hasNext() );
 
 		s.delete( baz );
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testPersistCollections() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		assertEquals( 0, ( (Long) s.createQuery( "select count(*) from Bar" ).iterate().next() ).longValue() );
 		assertTrue( s.createQuery( "select count(*) from Bar b" ).iterate().next().equals( new Long(0) ) );
 		assertFalse( s.createQuery( "from Glarch g" ).iterate().hasNext() );
 
 		Baz baz = new Baz();
 		s.save(baz);
 		baz.setDefaults();
 		baz.setStringArray( new String[] { "stuff" } );
 		Set bars = new HashSet();
 		bars.add( new Bar() );
 		baz.setCascadingBars(bars);
 		HashMap sgm = new HashMap();
 		sgm.put( "a", new Glarch() );
 		sgm.put( "b", new Glarch() );
 		baz.setStringGlarchMap(sgm);
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		assertTrue( ( (Long) s.createQuery( "select count(*) from Bar" ).iterate().next() ).longValue()==1 );
 		baz = (Baz) ( (Object[]) s.createQuery( "select baz, baz from Baz baz" ).list().get(0) )[1];
 		assertTrue( baz.getCascadingBars().size()==1 );
 		//System.out.println( s.print(baz) );
 		Foo foo = new Foo();
 		s.save(foo);
 		Foo foo2 = new Foo() ;
 		s.save(foo2);
 		baz.setFooArray( new Foo[] { foo, foo, null, foo2 } );
 		baz.getFooSet().add(foo);
 		baz.getCustoms().add( new String[] { "new", "custom" } );
 		baz.setStringArray(null);
 		baz.getStringList().set(0, "new value");
 		baz.setStringSet( new TreeSet() );
 		Time time = new java.sql.Time(12345);
 		baz.getTimeArray()[2] = time;
 		//System.out.println(time);
 
 		assertTrue( baz.getStringGlarchMap().size()==1 );
 
 		//The following test is disabled databases with no subselects
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof HSQLDialect) && !(getDialect() instanceof PointbaseDialect) )  {
 			List list = s.createQuery(
 					"select foo from Foo foo, Baz baz where foo in elements(baz.fooArray) and 3 = some elements(baz.intArray) and 4 > all indices(baz.intArray)"
 			).list();
 			assertTrue( "collection.elements find", list.size()==2 );
 		}
 		if (!(getDialect() instanceof SAPDBDialect) ) { // SAPDB doesn't like distinct with binary type
 			List list = s.createQuery( "select distinct foo from Baz baz join baz.fooArray foo" ).list();
 			assertTrue( "collection.elements find", list.size()==2 );
 		}
 
 		List list = s.createQuery( "select foo from Baz baz join baz.fooSet foo" ).list();
 		assertTrue( "association.elements find", list.size()==1 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		assertTrue( ( (Long) s.createQuery( "select count(*) from Bar" ).iterate().next() ).longValue()==1 );
 		baz = (Baz) s.createQuery( "select baz from Baz baz order by baz" ).list().get(0);
 		assertTrue( "collection of custom types - added element", baz.getCustoms().size()==4 && baz.getCustoms().get(0)!=null );
 		assertTrue ( "component of component in collection", baz.getComponents()[1].getSubcomponent()!=null );
 		assertTrue( baz.getComponents()[1].getBaz()==baz );
 		assertTrue( "set of objects", ( (FooProxy) baz.getFooSet().iterator().next() ).getKey().equals( foo.getKey() ));
 		assertTrue( "collection removed", baz.getStringArray().length==0 );
 		assertTrue( "changed element", baz.getStringList().get(0).equals("new value"));
 		assertTrue( "replaced set", baz.getStringSet().size()==0 );
 		assertTrue( "array element change", baz.getTimeArray()[2]!=null );
 		assertTrue( baz.getCascadingBars().size()==1 );
 		//System.out.println( s.print(baz) );
 		baz.getStringSet().add("two");
 		baz.getStringSet().add("one");
 		baz.getBag().add("three");
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		baz = (Baz) s.createQuery( "select baz from Baz baz order by baz" ).list().get(0);
 		assertTrue( baz.getStringSet().size()==2 );
 		assertTrue( baz.getStringSet().first().equals("one") );
 		assertTrue( baz.getStringSet().last().equals("two") );
 		assertTrue( baz.getBag().size()==5 );
 		baz.getStringSet().remove("two");
 		baz.getBag().remove("duplicate");
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		assertTrue( ( (Long) s.createQuery( "select count(*) from Bar" ).iterate().next() ).longValue()==1 );
 		baz = (Baz) s.load(Baz.class, baz.getCode());
 		assertTrue( baz.getCascadingBars().size()==1 );
 		Bar bar = new Bar();
 		Bar bar2 = new Bar();
 		s.save(bar); s.save(bar2);
 		baz.setTopFoos( new HashSet() );
 		baz.getTopFoos().add(bar);
 		baz.getTopFoos().add(bar2);
 		assertTrue( baz.getCascadingBars().size()==1 );
 		baz.setTopGlarchez( new TreeMap() );
 		GlarchProxy g = new Glarch();
 		s.save(g);
 		baz.getTopGlarchez().put( new Character('G'), g );
 		HashMap map = new HashMap();
 		map.put(bar, g);
 		map.put(bar2, g);
 		baz.setFooToGlarch(map);
 		map = new HashMap();
 		map.put( new FooComponent("name", 123, null, null), bar );
 		map.put( new FooComponent("nameName", 12, null, null), bar );
 		baz.setFooComponentToFoo(map);
 		map = new HashMap();
 		map.put(bar, g);
 		baz.setGlarchToFoo(map);
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		baz = (Baz) s.createQuery( "select baz from Baz baz order by baz" ).list().get(0);
 		assertTrue( baz.getCascadingBars().size()==1 );
 
 		Session s2 = openSession();
 		Transaction txn2 = s2.beginTransaction();
 		assertTrue( ( (Long) s2.createQuery( "select count(*) from Bar" ).iterate().next() ).longValue()==3 );
 		Baz baz2 = (Baz) s2.createQuery( "select baz from Baz baz order by baz" ).list().get(0);
 		Object o = baz2.getFooComponentToFoo().get( new FooComponent("name", 123, null, null) );
 		assertTrue(
 			o==baz2.getFooComponentToFoo().get( new FooComponent("nameName", 12, null, null) ) && o!=null
 		);
 		txn2.commit();
 		s2.close();
 
 		assertTrue( Hibernate.isInitialized( baz.getFooToGlarch() ) );
 		assertTrue( baz.getTopFoos().size()==2 );
 		assertTrue( baz.getTopGlarchez().size()==1 );
 		assertTrue( baz.getTopFoos().iterator().next()!=null );
 		assertTrue( baz.getStringSet().size()==1 );
 		assertTrue( baz.getBag().size()==4 );
 		assertTrue( baz.getFooToGlarch().size()==2 );
 		assertTrue( baz.getFooComponentToFoo().size()==2 );
 		assertTrue( baz.getGlarchToFoo().size()==1 );
 		Iterator iter = baz.getFooToGlarch().keySet().iterator();
 		for (int i=0; i<2; i++ ) assertTrue( iter.next() instanceof BarProxy );
 		FooComponent fooComp = (FooComponent) baz.getFooComponentToFoo().keySet().iterator().next();
 		assertTrue(
 			( (fooComp.getCount()==123 && fooComp.getName().equals("name"))
 			|| (fooComp.getCount()==12 && fooComp.getName().equals("nameName")) )
 			&& ( baz.getFooComponentToFoo().get(fooComp) instanceof BarProxy )
 		);
 		Glarch g2 = new Glarch();
 		s.save(g2);
 		g = (GlarchProxy) baz.getTopGlarchez().get( new Character('G') );
 		baz.getTopGlarchez().put( new Character('H'), g );
 		baz.getTopGlarchez().put( new Character('G'), g2 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		baz = (Baz) s.load(Baz.class, baz.getCode());
 		assertTrue( baz.getTopGlarchez().size()==2 );
 		assertTrue( baz.getCascadingBars().size()==1 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		assertTrue( ( (Long) s.createQuery( "select count(*) from Bar" ).iterate().next() ).longValue()==3 );
 		baz = (Baz) s.createQuery( "select baz from Baz baz order by baz" ).list().get(0);
 		assertTrue( baz.getTopGlarchez().size()==2 );
 		assertTrue( baz.getCascadingBars().size()==1 );
 		txn.commit();
 
 		s2 = (Session) SerializationHelper.deserialize( SerializationHelper.serialize(s) );
 		s.close();
 
 		txn2 = s2.beginTransaction();
 		baz = (Baz) s2.load(Baz.class, baz.getCode());
 		assertTrue( ( (Long) s2.createQuery( "select count(*) from Bar" ).iterate().next() ).longValue()==3 );
 		s2.delete(baz);
 		s2.delete( baz.getTopGlarchez().get( new Character('G') ) );
 		s2.delete( baz.getTopGlarchez().get( new Character('H') ) );
 		int rows = s2.connection().createStatement().executeUpdate("update " + getDialect().openQuote() + "glarchez" + getDialect().closeQuote() + " set baz_map_id=null where baz_map_index='a'");
 		assertTrue(rows==1);
 		assertEquals( 2, doDelete( s2, "from Bar bar" ) );
 		FooProxy[] arr = baz.getFooArray();
 		assertTrue( "new array of objects", arr.length==4 && arr[1].getKey().equals( foo.getKey() ) );
 		for ( int i=1; i<arr.length; i++ ) {
 			if ( arr[i]!=null) s2.delete(arr[i]);
 		}
 
 		s2.load( Qux.class, new Long(666) ); //nonexistent
 
 		assertEquals( 1, doDelete( s2, "from Glarch g" ) );
 		txn2.commit();
 
 		s2.disconnect();
 
 		Session s3 = (Session) SerializationHelper.deserialize( SerializationHelper.serialize( s2 ) );
 		s2.close();
 		//s3.reconnect();
 		assertTrue( s3.load( Qux.class, new Long(666) )!=null ); //nonexistent
 		//s3.disconnect();
 		s3.close();
 	}
 
 	@Test
 	public void testSaveFlush() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Fee fee = new Fee();
-		s.save( fee, "key" );
-		fee.setFi("blah");
+		s.save( fee );
+		fee.setFi( "blah" );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		fee = (Fee) s.load( Fee.class, fee.getKey() );
 		assertTrue( "blah".equals( fee.getFi() ) );
-		assertTrue( "key".equals( fee.getKey() ) );
 		s.delete(fee);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCreateUpdate() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo foo = new Foo();
 		s.save(foo);
 		foo.setString("dirty");
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Foo foo2 = new Foo();
 		s.load( foo2, foo.getKey() );
 		// There is an interbase bug that causes null integers to return as 0, also numeric precision is <= 15
 		assertTrue( "create-update", foo.equalsFoo(foo2) );
 		//System.out.println( s.print(foo2) );
 		s.delete(foo2);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo = new Foo();
-		s.save(foo, "assignedid");
+		s.save(foo);
 		foo.setString("dirty");
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
-		s.load(foo2, "assignedid");
+		s.load(foo2, foo.getKey());
 		// There is an interbase bug that causes null integers to return as 0, also numeric precision is <= 15
 		assertTrue( "create-update", foo.equalsFoo(foo2) );
 		//System.out.println( s.print(foo2) );
 		s.delete(foo2);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testUpdateCollections() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Holder baz = new Holder();
 		baz.setName("123");
 		Foo f1 = new Foo();
 		Foo f2 = new Foo();
 		Foo f3 = new Foo();
 		One o = new One();
 		baz.setOnes( new ArrayList() );
 		baz.getOnes().add(o);
 		Foo[] foos = new Foo[] { f1, null, f2 };
 		baz.setFooArray(foos);
 		baz.setFoos( new HashSet() );
 		baz.getFoos().add(f1);
 		s.save(f1);
 		s.save(f2);
 		s.save(f3);
 		s.save(o);
 		s.save(baz);
 		s.getTransaction().commit();
 		s.close();
 
 		baz.getOnes().set(0, null);
 		baz.getOnes().add(o);
 		baz.getFoos().add(f2);
 		foos[0] = f3;
 		foos[1] = f1;
 
 		s = openSession();
 		s.beginTransaction();
 		s.saveOrUpdate(baz);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Holder h = (Holder) s.load(Holder.class, baz.getId());
 		assertTrue( h.getOnes().get(0)==null );
 		assertTrue( h.getOnes().get(1)!=null );
 		assertTrue( h.getFooArray()[0]!=null);
 		assertTrue( h.getFooArray()[1]!=null);
 		assertTrue( h.getFooArray()[2]!=null);
 		assertTrue( h.getFoos().size()==2 );
 		s.getTransaction().commit();
 		s.close();
 
 		baz.getFoos().remove(f1);
 		baz.getFoos().remove(f2);
 		baz.getFooArray()[0]=null;
 		baz.getFooArray()[0]=null;
 		baz.getFooArray()[0]=null;
 
 		s = openSession();
 		s.beginTransaction();
 		s.saveOrUpdate(baz);
 		doDelete( s, "from Foo" );
 		baz.getOnes().remove(o);
 		doDelete( s, "from One" );
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCreate() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo foo = new Foo();
 		s.save(foo);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Foo foo2 = new Foo();
 		s.load( foo2, foo.getKey() );
 		// There is an interbase bug that causes null integers to return as 0, also numeric precision is <= 15
 		assertTrue( "create", foo.equalsFoo( foo2 ) );
 		s.delete(foo2);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCallback() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Qux q = new Qux("0");
 		s.save(q);
 		q.setChild( new Qux( "1" ) );
 		s.save( q.getChild() );
 		Qux q2 = new Qux("2");
 		q2.setChild( q.getChild() );
 		Qux q3 = new Qux("3");
 		q.getChild().setChild(q3);
 		s.save( q3 );
 		Qux q4 = new Qux("4");
 		q4.setChild( q3 );
 		s.save(q4);
 		s.save( q2 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List l = s.createQuery( "from Qux" ).list();
 		assertTrue( "", l.size() == 5 );
 		s.delete( l.get( 0 ) );
 		s.delete( l.get( 1 ) );
 		s.delete( l.get( 2 ) );
 		s.delete( l.get(3) );
 		s.delete( l.get(4) );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testPolymorphism() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Bar bar = new Bar();
 		s.save(bar);
 		bar.setBarString("bar bar");
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		FooProxy foo = (FooProxy) s.load( Foo.class, bar.getKey() );
 		assertTrue( "polymorphic", foo instanceof BarProxy );
 		assertTrue( "subclass property", ( (BarProxy) foo ).getBarString().equals( bar.getBarString() ) );
 		//System.out.println( s.print(foo) );
 		s.delete(foo);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testRemoveContains() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setDefaults();
 		s.save( baz );
 		s.flush();
 		assertTrue( s.contains(baz) );
 		s.evict( baz );
 		assertFalse( s.contains(baz) );
 		Baz baz2 = (Baz) s.load( Baz.class, baz.getCode() );
 		assertFalse( baz == baz2 );
 		s.delete(baz2);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionOfSelf() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Bar bar = new Bar();
 		s.save(bar);
 		bar.setAbstracts( new HashSet() );
 		bar.getAbstracts().add( bar );
 		Bar bar2 = new Bar();
 		bar.getAbstracts().add( bar2 );
 		bar.setFoo(bar);
 		s.save( bar2 );
 		s.getTransaction().commit();
 		s.close();
 
 		bar.setAbstracts( null );
 
 		s = openSession();
 		s.beginTransaction();
 		s.load( bar, bar.getKey() );
 		assertTrue( "collection contains self", bar.getAbstracts().size() == 2 && bar.getAbstracts().contains( bar ) );
 		assertTrue( "association to self", bar.getFoo()==bar );
 		Iterator iter = bar.getAbstracts().iterator();
 		while ( iter.hasNext() ) {
 			s.delete( iter.next() );
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testFind() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 
 		Bar bar = new Bar();
 		s.save(bar);
 		bar.setBarString("bar bar");
 		bar.setString("xxx");
 		Foo foo = new Foo();
 		s.save(foo);
 		foo.setString("foo bar");
 		s.save( new Foo() );
 		s.save( new Bar() );
 		List list1 = s.createQuery( "select foo from Foo foo where foo.string='foo bar'" ).list();
 		assertTrue( "find size", list1.size()==1 );
 		assertTrue( "find ==", list1.get(0)==foo );
 		List list2 = s.createQuery( "from Foo foo order by foo.string, foo.date" ).list();
 		assertTrue( "find size", list2.size()==4 );
 
 		list1 = s.createQuery( "from Foo foo where foo.class='B'" ).list();
 		assertTrue( "class special property", list1.size()==2);
 		list1 = s.createQuery( "from Foo foo where foo.class=Bar" ).list();
 		assertTrue( "class special property", list1.size()==2);
 		list1 = s.createQuery( "from Foo foo where foo.class=Bar" ).list();
 		list2 = s.createQuery( "select bar from Bar bar, Foo foo where bar.string = foo.string and not bar=foo" ).list();
 		assertTrue( "class special property", list1.size()==2);
 		assertTrue( "select from a subclass", list2.size()==1);
 		Trivial t = new Trivial();
 		s.save(t);
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		list1 = s.createQuery( "from Foo foo where foo.string='foo bar'" ).list();
 		assertTrue( "find size", list1.size()==1 );
 		// There is an interbase bug that causes null integers to return as 0, also numeric precision is <= 15
 		assertTrue( "find equals", ( (Foo) list1.get(0) ).equalsFoo(foo) );
 		list2 = s.createQuery( "select foo from Foo foo" ).list();
 		assertTrue( "find size", list2.size()==5 );
 		List list3 = s.createQuery( "from Bar bar where bar.barString='bar bar'" ).list();
 		assertTrue( "find size", list3.size()==1 );
 		assertTrue( "find same instance", list2.contains( list1.get(0) ) && list2.contains( list2.get(0) ) );
 		assertTrue( s.createQuery( "from Trivial" ).list().size()==1 );
 		doDelete( s, "from Trivial" );
 
 		list2 = s.createQuery( "from Foo foo where foo.date = ?" )
 				.setParameter( 0, new java.sql.Date(123), Hibernate.DATE )
 				.list();
 		assertTrue ( "find by date", list2.size()==4 );
 		Iterator iter = list2.iterator();
 		while ( iter.hasNext() ) {
 			s.delete( iter.next() );
 		}
 		list2 = s.createQuery( "from Foo foo" ).list();
 		assertTrue( "find deleted", list2.size()==0);
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testDeleteRecursive() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo x = new Foo();
 		Foo y = new Foo();
 		x.setFoo( y );
 		y.setFoo( x );
 		s.save( x );
 		s.save( y );
 		s.flush();
 		s.delete( y );
 		s.delete( x );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testReachability() throws Exception {
 		//first for unkeyed collections
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz1 = new Baz();
 		s.save(baz1);
 		Baz baz2 = new Baz();
 		s.save(baz2);
 		baz1.setIntArray( new int[] {1 ,2, 3, 4} );
 		baz1.setFooSet( new HashSet() );
 		Foo foo = new Foo();
 		s.save(foo);
 		baz1.getFooSet().add(foo);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		baz1 = (Baz) s.load( Baz.class, baz1.getCode() );
 		baz2.setFooSet( baz1.getFooSet() ); baz1.setFooSet(null);
 		baz2.setIntArray( baz1.getIntArray() ); baz1.setIntArray(null);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		baz1 = (Baz) s.load( Baz.class, baz1.getCode() );
 		assertTrue( "unkeyed reachability", baz2.getIntArray().length==4 );
 		assertTrue( "unkeyed reachability", baz2.getFooSet().size()==1 );
 		assertTrue( "unkeyed reachability", baz1.getIntArray().length==0 );
 		assertTrue( "unkeyed reachability", baz1.getFooSet().size()==0 );
 		//System.out.println( s.print(baz1) + s.print(baz2) );
 		FooProxy fp = (FooProxy) baz2.getFooSet().iterator().next();
 		s.delete(fp);
 		s.delete(baz1);
 		s.delete(baz2);
 		s.getTransaction().commit();
 		s.close();
 
 		//now for collections of collections
 		s = openSession();
 		s.beginTransaction();
 		baz1 = new Baz();
 		s.save(baz1);
 		baz2 = new Baz();
 		s.save(baz2);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		baz1 = (Baz) s.load( Baz.class, baz1.getCode() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		baz1 = (Baz) s.load( Baz.class, baz1.getCode() );
 		s.delete(baz1);
 		s.delete(baz2);
 		s.getTransaction().commit();
 		s.close();
 
 		//now for keyed collections
 		s = openSession();
 		s.beginTransaction();
 		baz1 = new Baz();
 		s.save(baz1);
 		baz2 = new Baz();
 		s.save(baz2);
 		Foo foo1 = new Foo();
 		Foo foo2 = new Foo();
 		s.save(foo1); s.save(foo2);
 		baz1.setFooArray( new Foo[] { foo1, null, foo2 } );
 		baz1.setStringDateMap( new TreeMap() );
 		baz1.getStringDateMap().put("today", new Date( System.currentTimeMillis() ) );
 		baz1.getStringDateMap().put("tomorrow", new Date( System.currentTimeMillis() + 86400000 ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		baz1 = (Baz) s.load( Baz.class, baz1.getCode() );
 		baz2.setFooArray( baz1.getFooArray() ); baz1.setFooArray(null);
 		baz2.setStringDateMap( baz1.getStringDateMap() ); baz1.setStringDateMap(null);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		baz1 = (Baz) s.load( Baz.class, baz1.getCode() );
 		assertTrue( "reachability", baz2.getStringDateMap().size()==2 );
 		assertTrue( "reachability", baz2.getFooArray().length==3 );
 		assertTrue( "reachability", baz1.getStringDateMap().size()==0 );
 		assertTrue( "reachability", baz1.getFooArray().length==0 );
 		assertTrue( "null element", baz2.getFooArray()[1]==null );
 		assertTrue( "non-null element", baz2.getStringDateMap().get("today")!=null );
 		assertTrue( "non-null element", baz2.getStringDateMap().get("tomorrow")!=null );
 		assertTrue( "null element", baz2.getStringDateMap().get("foo")==null );
 		s.delete( baz2.getFooArray()[0] );
 		s.delete( baz2.getFooArray()[2] );
 		s.delete(baz1);
 		s.delete(baz2);
 		s.flush();
 		assertTrue( s.createQuery( "from java.lang.Object" ).list().size()==0 );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testPersistentLifecycle() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Qux q = new Qux();
 		s.save(q);
 		q.setStuff("foo bar baz qux");
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		q = (Qux) s.load( Qux.class, q.getKey() );
 		assertTrue( "lifecycle create", q.getCreated() );
 		assertTrue( "lifecycle load", q.getLoaded() );
 		assertTrue( "lifecycle subobject", q.getFoo()!=null );
 		s.delete(q);
 		assertTrue( "lifecycle delete", q.getDeleted() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		assertTrue( "subdeletion", s.createQuery( "from Foo foo" ).list().size()==0);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testIterators() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		for ( int i=0; i<10; i++ ) {
 			Qux q = new Qux();
 			Object qid = s.save(q);
 			assertTrue("not null", qid!=null);
 		}
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Iterator iter = s.createQuery( "from Qux q where q.stuff is null" ).iterate();
 		int count=0;
 		while ( iter.hasNext() ) {
 			Qux q = (Qux) iter.next();
 			q.setStuff("foo");
 			if (count==0 || count==5) iter.remove();
 			count++;
 		}
 		assertTrue("iterate", count==10);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		assertEquals( 8, doDelete( s, "from Qux q where q.stuff=?", "foo", Hibernate.STRING ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		iter = s.createQuery( "from Qux q" ).iterate();
 		assertTrue( "empty iterator", !iter.hasNext() );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testVersioning() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		GlarchProxy g = new Glarch();
 		s.save(g);
 		GlarchProxy g2 = new Glarch();
 		s.save(g2);
 		Serializable gid = s.getIdentifier(g);
 		Serializable g2id = s.getIdentifier(g2);
 		g.setName("glarch");
 		txn.commit();
 		s.close();
 
 		sessionFactory().evict(Glarch.class);
 
 		s = openSession();
 		txn = s.beginTransaction();
 		g = (GlarchProxy) s.load( Glarch.class, gid );
 		s.lock(g, LockMode.UPGRADE);
 		g2 = (GlarchProxy) s.load( Glarch.class, g2id );
 		assertTrue( "version", g.getVersion()==1 );
 		assertTrue( "version", g.getDerivedVersion()==1 );
 		assertTrue( "version", g2.getVersion()==0 );
 		g.setName("foo");
 		assertTrue(
 			"find by version",
 				s.createQuery( "from Glarch g where g.version=2" ).list().size()==1
 		);
 		g.setName("bar");
 		txn.commit();
 		s.close();
 
 		sessionFactory().evict(Glarch.class);
 
 		s = openSession();
 		txn = s.beginTransaction();
 		g = (GlarchProxy) s.load( Glarch.class, gid );
 		g2 = (GlarchProxy) s.load( Glarch.class, g2id );
 		assertTrue( "version", g.getVersion()==3 );
 		assertTrue( "version", g.getDerivedVersion()==3 );
 		assertTrue( "version", g2.getVersion()==0 );
 		g.setNext(null);
 		g2.setNext(g);
 		s.delete(g2);
 		s.delete(g);
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testVersionedCollections() throws Exception {
 		Session s = openSession();
 		GlarchProxy g = new Glarch();
 		s.save(g);
 		g.setProxyArray( new GlarchProxy[] { g } );
 		String gid = (String) s.getIdentifier(g);
 		ArrayList list = new ArrayList();
 		list.add("foo");
 		g.setStrings(list);
 		HashSet set = new HashSet();
 		set.add(g);
 		g.setProxySet(set);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( g.getStrings().size()==1 );
 		assertTrue( g.getProxyArray().length==1 );
 		assertTrue( g.getProxySet().size()==1 );
 		assertTrue( "versioned collection before", g.getVersion()==1 );
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( g.getStrings().get(0).equals("foo") );
 		assertTrue( g.getProxyArray()[0]==g );
 		assertTrue( g.getProxySet().iterator().next()==g );
 		assertTrue( "versioned collection before", g.getVersion()==1 );
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( "versioned collection before", g.getVersion()==1 );
 		g.getStrings().add("bar");
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( "versioned collection after", g.getVersion()==2 );
 		assertTrue( "versioned collection after", g.getStrings().size()==2 );
 		g.setProxyArray(null);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( "versioned collection after", g.getVersion()==3 );
 		assertTrue( "versioned collection after", g.getProxyArray().length==0 );
 		g.setFooComponents( new ArrayList() );
 		g.setProxyArray(null);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( "versioned collection after", g.getVersion()==4 );
 		s.delete(g);
 		s.flush();
 		assertTrue( s.createQuery( "from java.lang.Object" ).list().size()==0 );
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testRecursiveLoad() throws Exception {
 		//Non polymorphic class (there is an implementation optimization
 		//being tested here)
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		GlarchProxy last = new Glarch();
 		s.save(last);
 		last.setOrder( (short) 0 );
 		for (int i=0; i<5; i++) {
 			GlarchProxy next = new Glarch();
 			s.save(next);
 			last.setNext(next);
 			last = next;
 			last.setOrder( (short) (i+1) );
 		}
 		Iterator iter = s.createQuery( "from Glarch g" ).iterate();
 		while ( iter.hasNext() ) {
 			iter.next();
 		}
 		List list = s.createQuery( "from Glarch g" ).list();
 		assertTrue( "recursive find", list.size()==6 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		list = s.createQuery( "from Glarch g" ).list();
 		assertTrue( "recursive iter", list.size()==6 );
 		list = s.createQuery( "from Glarch g where g.next is not null" ).list();
 		assertTrue( "recursive iter", list.size()==5 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		iter = s.createQuery( "from Glarch g order by g.order asc" ).iterate();
 		while ( iter.hasNext() ) {
 			GlarchProxy g = (GlarchProxy) iter.next();
 			assertTrue( "not null", g!=null );
 			iter.remove();
 		}
 		txn.commit();
 		s.close();
 
 		//Same thing but using polymorphic class (no optimisation possible):
 		s = openSession();
 		txn = s.beginTransaction();
 		FooProxy flast = new Bar();
 		s.save(flast);
 		flast.setString( "foo0" );
 		for (int i=0; i<5; i++) {
 			FooProxy foo = new Bar();
 			s.save(foo);
 			flast.setFoo(foo);
 			flast = flast.getFoo();
 			flast.setString( "foo" + (i+1) );
 		}
 		iter = s.createQuery( "from Foo foo" ).iterate();
 		while ( iter.hasNext() ) {
 			iter.next();
 		}
 		list = s.createQuery( "from Foo foo" ).list();
 		assertTrue( "recursive find", list.size()==6 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		list = s.createQuery( "from Foo foo" ).list();
 		assertTrue( "recursive iter", list.size()==6 );
 		iter = list.iterator();
 		while ( iter.hasNext() ) {
 			assertTrue( "polymorphic recursive load", iter.next() instanceof BarProxy );
 		}
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		iter = s.createQuery( "from Foo foo order by foo.string asc" ).iterate();
 		while ( iter.hasNext() ) {
 			BarProxy bar = (BarProxy) iter.next();
 			assertTrue( "not null", bar!=null );
 			iter.remove();
 		}
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testScrollableIterator() throws Exception {
 		// skip if not one of these named dialects
 		boolean match = getDialect() instanceof DB2Dialect
 				|| getDialect() instanceof SybaseDialect
 				|| getDialect() instanceof HSQLDialect
 				|| getDialect() instanceof Oracle8iDialect // 9i/10g too because of inheritence...
 				;
 		if ( ! match ) {
 			return;
 		}
 
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		s.save( new Foo() );
 		s.save( new Foo() );
 		s.save( new Foo() );
 		s.save( new Bar() );
 		Query query = s.createQuery("select f, f.integer from Foo f");
 		assertTrue( query.getReturnTypes().length==2 );
 		ScrollableResults iter = query.scroll();
 		assertTrue( iter.next() );
 		assertTrue( iter.scroll(1) );
 		FooProxy f2 = (FooProxy) iter.get()[0];
 		assertTrue( f2!=null );
 		assertTrue( iter.scroll(-1) );
 		Object f1 = iter.get(0);
 		iter.next();
 		assertTrue( f1!=null && iter.get(0)==f2 );
 		iter.getInteger(1);
 
 		assertTrue( !iter.scroll(100) );
 		assertTrue( iter.first() );
 		assertTrue( iter.scroll(3) );
 		Object f4 = iter.get(0);
 		assertTrue( f4!=null );
 		assertTrue( !iter.next() );
 		assertTrue( iter.first() );
 		assertTrue( iter.get(0)==f1 );
 		assertTrue( iter.last() );
 		assertTrue( iter.get(0)==f4 );
 		assertTrue( iter.previous() );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		query = s.createQuery("select f, f.integer from Foo f");
 		assertTrue( query.getReturnTypes().length==2 );
 		iter = query.scroll();
 		assertTrue( iter.next() );
 		assertTrue( iter.scroll(1) );
 		f2 = (FooProxy) iter.get()[0];
 		assertTrue( f2!=null );
 		assertTrue( f2.getString()!=null  && f2.getComponent().getImportantDates().length > 0 );
 		assertTrue( iter.scroll(-1) );
 		f1 = iter.get(0);
 		iter.next();
 		assertTrue( f1!=null && iter.get(0)==f2 );
 		iter.getInteger(1);
 
 		assertTrue( !iter.scroll(100) );
 		assertTrue( iter.first() );
 		assertTrue( iter.scroll(3) );
 		f4 = iter.get(0);
 		assertTrue( f4!=null );
 		assertTrue( !iter.next() );
 		assertTrue( iter.first() );
 		assertTrue( iter.get(0)==f1 );
 		assertTrue( iter.last() );
 		assertTrue( iter.get(0)==f4 );
 		assertTrue( iter.previous() );
-		assertTrue( s.delete("from Foo")==4 );
+		int i = 0;
+		for ( Object entity : s.createQuery( "from Foo" ).list() ) {
+			i++;
+			s.delete( entity );
+		}
+		assertEquals( 4, i );
 		s.flush();
 		assertTrue( s.createQuery( "from java.lang.Object" ).list().size()==0 );
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testMultiColumnQueries() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Foo foo = new Foo();
 		s.save(foo);
 		Foo foo1 = new Foo();
 		s.save(foo1);
 		foo.setFoo(foo1);
 		List l = s.createQuery( "select parent, child from Foo parent, Foo child where parent.foo = child" ).list();
 		assertTrue( "multi-column find", l.size()==1 );
 
 		Iterator rs = s.createQuery(
 				"select count(distinct child.id), count(distinct parent.id) from Foo parent, Foo child where parent.foo = child"
 		).iterate();
 		Object[] row = (Object[]) rs.next();
 		assertTrue( "multi-column count", ( (Long) row[0] ).intValue()==1 );
 		assertTrue( "multi-column count", ( (Long) row[1] ).intValue()==1 );
 		assertTrue( !rs.hasNext() );
 
 		rs = s.createQuery( "select child.id, parent.id, child.long from Foo parent, Foo child where parent.foo = child" )
 				.iterate();
 		row = (Object[]) rs.next();
 		assertTrue( "multi-column id", row[0].equals( foo.getFoo().getKey() ) );
 		assertTrue( "multi-column id", row[1].equals( foo.getKey() ) );
 		assertTrue( "multi-column property", row[2].equals( foo.getFoo().getLong() ) );
 		assertTrue( !rs.hasNext() );
 
 		rs = s.createQuery(
 				"select child.id, parent.id, child.long, child, parent.foo from Foo parent, Foo child where parent.foo = child"
 		).iterate();
 		row = (Object[]) rs.next();
 		assertTrue(
 			foo.getFoo().getKey().equals( row[0] ) &&
 			foo.getKey().equals( row[1] ) &&
 			foo.getFoo().getLong().equals( row[2] ) &&
 			row[3] == foo.getFoo() &&
 			row[3]==row[4]
 		);
 		assertTrue( !rs.hasNext() );
 
 		row = (Object[]) l.get(0);
 		assertTrue( "multi-column find", row[0]==foo && row[1]==foo.getFoo() );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		Iterator iter = s.createQuery(
 				"select parent, child from Foo parent, Foo child where parent.foo = child and parent.string='a string'"
 		).iterate();
 		int deletions=0;
 		while ( iter.hasNext() ) {
 			Object[] pnc = (Object[]) iter.next();
 			s.delete( pnc[0] );
 			s.delete( pnc[1] );
 			deletions++;
 		}
 		assertTrue("multi-column iterate", deletions==1);
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testDeleteTransient() throws Exception {
 		Fee fee = new Fee();
 		Fee fee2 = new Fee();
 		fee2.setAnotherFee(fee);
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		s.save(fee);
 		s.save(fee2);
 		s.flush();
 		fee.setCount(123);
 		tx.commit();
 		s.close();
 		s = openSession();
 		tx = s.beginTransaction();
 		s.delete(fee);
 		s.delete(fee2);
 		//foo.setAnotherFee(null);
 		tx.commit();
 		s.close();
 		s = openSession();
 		tx = s.beginTransaction();
 		assertTrue( s.createQuery( "from Fee fee" ).list().size()==0 );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testDeleteUpdatedTransient() throws Exception {
 		Fee fee = new Fee();
 		Fee fee2 = new Fee();
 		fee2.setAnotherFee(fee);
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		s.save(fee);
 		s.save(fee2);
 		s.flush();
 		fee.setCount(123);
 		tx.commit();
 		s.close();
 		s = openSession();
 		tx = s.beginTransaction();
 		s.update(fee);
 		//fee2.setAnotherFee(null);
 		s.update(fee2);
 		s.delete(fee);
 		s.delete(fee2);
 		tx.commit();
 		s.close();
 		s = openSession();
 		tx = s.beginTransaction();
 		assertTrue( s.createQuery( "from Fee fee" ).list().size()==0 );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testUpdateOrder() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Fee fee1 = new Fee();
 		s.save(fee1);
 		Fee fee2 = new Fee();
 		fee1.setFee(fee2);
 		fee2.setFee(fee1);
 		fee2.setFees( new HashSet() );
 		Fee fee3 = new Fee();
 		fee3.setFee(fee1);
 		fee3.setAnotherFee(fee2);
 		fee2.setAnotherFee(fee3);
 		s.save(fee3);
 		s.save(fee2);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		fee1.setCount(10);
 		fee2.setCount(20);
 		fee3.setCount(30);
 		s.update(fee1);
 		s.update(fee2);
 		s.update(fee3);
 		s.flush();
 		s.delete(fee1);
 		s.delete(fee2);
 		s.delete(fee3);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		assertTrue( s.createQuery( "from Fee fee" ).list().size()==0 );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testUpdateFromTransient() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Fee fee1 = new Fee();
 		s.save(fee1);
 		Fee fee2 = new Fee();
 		fee1.setFee(fee2);
 		fee2.setFee(fee1);
 		fee2.setFees( new HashSet() );
 		Fee fee3 = new Fee();
 		fee3.setFee(fee1);
 		fee3.setAnotherFee(fee2);
 		fee2.setAnotherFee(fee3);
 		s.save(fee3);
 		s.save(fee2);
 		s.getTransaction().commit();
 		s.close();
 
 		fee1.setFi("changed");
 
 		s = openSession();
 		s.beginTransaction();
 		s.saveOrUpdate(fee1);
 		s.getTransaction().commit();
 		s.close();
 
 		Qux q = new Qux("quxxy");
 		q.setTheKey(0);
 		fee1.setQux(q);
 
 		s = openSession();
 		s.beginTransaction();
 		s.saveOrUpdate(fee1);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		fee1 = (Fee) s.load( Fee.class, fee1.getKey() );
 		assertTrue( "updated from transient", fee1.getFi().equals("changed") );
 		assertTrue( "unsaved value", fee1.getQux()!=null );
 		s.delete( fee1.getQux() );
 		fee1.setQux(null);
 		s.getTransaction().commit();
 		s.close();
 
 		fee2.setFi("CHANGED");
 		fee2.getFees().add("an element");
 		fee1.setFi("changed again");
 
 		s = openSession();
 		s.beginTransaction();
 		s.saveOrUpdate(fee2);
-		s.update( fee1, fee1.getKey() );
+		s.update( fee1 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Fee fee = new Fee();
 		s.load( fee, fee2.getKey() );
 		fee1 = (Fee) s.load( Fee.class, fee1.getKey() );
 		assertTrue( "updated from transient", fee1.getFi().equals("changed again") );
 		assertTrue( "updated from transient", fee.getFi().equals("CHANGED") );
 		assertTrue( "updated collection", fee.getFees().contains("an element") );
 		s.getTransaction().commit();
 		s.close();
 
 		fee.getFees().clear();
 		fee.getFees().add("new element");
 		fee1.setFee(null);
 
 		s = openSession();
 		s.beginTransaction();
 		s.saveOrUpdate(fee);
 		s.saveOrUpdate(fee1);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.load( fee, fee.getKey() );
 		assertTrue( "update", fee.getAnotherFee()!=null );
 		assertTrue( "update", fee.getFee()!=null );
 		assertTrue( "update", fee.getAnotherFee().getFee()==fee.getFee() );
 		assertTrue( "updated collection", fee.getFees().contains("new element") );
 		assertTrue( "updated collection", !fee.getFees().contains("an element") );
 		s.getTransaction().commit();
 		s.close();
 
 		fee.setQux( new Qux("quxy") );
 
 		s = openSession();
 		s.beginTransaction();
 		s.saveOrUpdate(fee);
 		s.getTransaction().commit();
 		s.close();
 
 		fee.getQux().setStuff("xxx");
 
 		s = openSession();
 		s.beginTransaction();
 		s.saveOrUpdate(fee);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.load( fee, fee.getKey() );
 		assertTrue( "cascade update", fee.getQux()!=null );
 		assertTrue( "cascade update", fee.getQux().getStuff().equals("xxx") );
 		assertTrue( "update", fee.getAnotherFee()!=null );
 		assertTrue( "update", fee.getFee()!=null );
 		assertTrue( "update", fee.getAnotherFee().getFee()==fee.getFee() );
 		fee.getAnotherFee().setAnotherFee(null);
 		s.delete(fee);
 		doDelete( s, "from Fee fee" );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		assertTrue( s.createQuery( "from Fee fee" ).list().size()==0 );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testArraysOfTimes() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz() ;
 		s.save(baz);
 		baz.setDefaults();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz.getTimeArray()[2] = new Date(123);
 		baz.getTimeArray()[3] = new java.sql.Time(1234);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		s.delete( baz );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testComponents() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Foo foo = new Foo();
-		foo.setComponent( new FooComponent("foo", 69, null, new FooComponent("bar", 96, null, null) ) );
+//		foo.setComponent( new FooComponent("foo", 69, null, new FooComponent("bar", 96, null, null) ) );
 		s.save(foo);
 		foo.getComponent().setName( "IFA" );
 		txn.commit();
 		s.close();
 
 		foo.setComponent( null );
 
 		s = openSession();
 		txn = s.beginTransaction();
 		s.load( foo, foo.getKey() );
 		assertTrue(
 			"save components",
 			foo.getComponent().getName().equals("IFA") &&
 			foo.getComponent().getSubcomponent().getName().equals("bar")
 		);
 		assertTrue( "cascade save via component", foo.getComponent().getGlarch() != null );
 		foo.getComponent().getSubcomponent().setName("baz");
 		txn.commit();
 		s.close();
 
 		foo.setComponent(null);
 
 		s = openSession();
 		txn = s.beginTransaction();
 		s.load( foo, foo.getKey() );
 		assertTrue(
 			"update components",
 			foo.getComponent().getName().equals("IFA") &&
 			foo.getComponent().getSubcomponent().getName().equals("baz")
 		);
 		s.delete(foo);
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		foo = new Foo();
 		s.save( foo );
 		foo.setCustom( new String[] { "one", "two" } );
 		assertTrue( s.createQuery( "from Foo foo where foo.custom.s1 = 'one'" ).list().get(0)==foo );
 		s.delete( foo );
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testNoForeignKeyViolations() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Glarch g1 = new Glarch();
 		Glarch g2 = new Glarch();
 		g1.setNext(g2);
 		g2.setNext(g1);
 		s.save(g1);
 		s.save(g2);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List l = s.createQuery( "from Glarch g where g.next is not null" ).list();
 		s.delete( l.get(0) );
 		s.delete( l.get(1) );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testLazyCollections() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Qux q = new Qux();
 		s.save(q);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		q = (Qux) s.load( Qux.class, q.getKey() );
 		s.getTransaction().commit();
 		s.close();
 
 		System.out.println("Two exceptions are supposed to occur:");
 		boolean ok = false;
 		try {
 			q.getMoreFums().isEmpty();
 		}
 		catch (LazyInitializationException e) {
 			ok = true;
 		}
 		assertTrue( "lazy collection with one-to-many", ok );
 
 		ok = false;
 		try {
 			q.getFums().isEmpty();
 		}
 		catch (LazyInitializationException e) {
 			ok = true;
 		}
 		assertTrue( "lazy collection with many-to-many", ok );
 
 		s = openSession();
 		s.beginTransaction();
 		q = (Qux) s.load( Qux.class, q.getKey() );
 		s.delete(q);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNewSessionLifecycle() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Serializable fid = null;
 		try {
 			Foo f = new Foo();
 			s.save(f);
 			fid = s.getIdentifier(f);
 			s.getTransaction().commit();
 		}
 		catch (Exception e) {
 			s.getTransaction().rollback();
 			throw e;
 		}
 		finally {
 			s.close();
 		}
 
 		s = openSession();
 		s.beginTransaction();
 		try {
 			Foo f = new Foo();
 			s.delete(f);
 			s.getTransaction().commit();
 		}
 		catch (Exception e) {
 			s.getTransaction().rollback();
 		}
 		finally {
 			s.close();
 		}
 
 		s = openSession();
 		s.beginTransaction();
 		try {
 			Foo f = (Foo) s.load(Foo.class, fid, LockMode.UPGRADE);
 			s.delete(f);
 			s.flush();
 			s.getTransaction().commit();
 		}
 		catch (Exception e) {
 			s.getTransaction().rollback();
 			throw e;
 		}
 		finally {
 			assertTrue( s.close()==null );
 		}
 	}
 
 	@Test
 	public void testOrderBy() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo foo = new Foo();
 		s.save(foo);
 		List list = s.createQuery(
 				"select foo from Foo foo, Fee fee where foo.dependent = fee order by foo.string desc, foo.component.count asc, fee.id"
 		).list();
 		assertTrue( "order by", list.size()==1 );
 		Foo foo2 = new Foo();
 		s.save(foo2);
 		foo.setFoo(foo2);
 		list = s.createQuery(
 				"select foo.foo, foo.dependent from Foo foo order by foo.foo.string desc, foo.component.count asc, foo.dependent.id"
 		).list();
 		assertTrue( "order by", list.size()==1 );
 		list = s.createQuery( "select foo from Foo foo order by foo.dependent.id, foo.dependent.fi" ).list();
 		assertTrue( "order by", list.size()==2 );
 		s.delete(foo);
 		s.delete(foo2);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Many manyB = new Many();
 		s.save(manyB);
 		One oneB = new One();
 		s.save(oneB);
 		oneB.setValue("b");
 		manyB.setOne(oneB);
 		Many manyA = new Many();
 		s.save(manyA);
 		One oneA = new One();
 		s.save(oneA);
 		oneA.setValue("a");
 		manyA.setOne(oneA);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List results = s.createQuery( "SELECT one FROM " + One.class.getName() + " one ORDER BY one.value ASC" ).list();
 		assertEquals( 2, results.size() );
 		assertEquals( "'a' isn't first element", "a", ( (One) results.get(0) ).getValue() );
 		assertEquals( "'b' isn't second element", "b", ( (One) results.get(1) ).getValue() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		results = s.createQuery( "SELECT many.one FROM " + Many.class.getName() + " many ORDER BY many.one.value ASC, many.one.id" )
 				.list();
 		assertEquals( 2, results.size() );
 		assertEquals( 2, results.size() );
 		assertEquals( "'a' isn't first element", "a", ( (One) results.get(0) ).getValue() );
 		assertEquals( "'b' isn't second element", "b", ( (One) results.get(1) ).getValue() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		oneA = (One)s.load(One.class, oneA.getKey());
 		manyA = (Many)s.load(Many.class, manyA.getKey());
 		oneB = (One)s.load(One.class, oneB.getKey());
 		manyB = (Many)s.load(Many.class, manyB.getKey());
 		s.delete(manyA);
 		s.delete(oneA);
 		s.delete(manyB);
 		s.delete(oneB);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testManyToOne() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		One one = new One();
 		s.save(one);
 		one.setValue( "yada" );
 		Many many = new Many();
 		many.setOne( one );
 		s.save( many );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		one = (One) s.load( One.class, one.getKey() );
 		one.getManies().size();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		many = (Many) s.load( Many.class, many.getKey() );
 		assertTrue( "many-to-one assoc", many.getOne()!=null );
 		s.delete( many.getOne() );
 		s.delete(many);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSaveDelete() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo f = new Foo();
 		s.save(f);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( s.load( Foo.class, f.getKey() ) );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testProxyArray() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		GlarchProxy g = new Glarch();
 		Glarch g1 = new Glarch();
 		Glarch g2 = new Glarch();
 		g.setProxyArray( new GlarchProxy[] { g1, g2 } );
 		Glarch g3 = new Glarch();
 		s.save(g3);
 		g2.setProxyArray( new GlarchProxy[] {null, g3, g} );
 		Set set = new HashSet();
 		set.add(g1);
 		set.add(g2);
 		g.setProxySet(set);
 		s.save(g);
 		s.save(g1);
 		s.save(g2);
 		Serializable id = s.getIdentifier(g);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, id);
 		assertTrue( "array of proxies", g.getProxyArray().length==2 );
 		assertTrue( "array of proxies", g.getProxyArray()[0]!=null );
 		assertTrue("deferred load test",g.getProxyArray()[1].getProxyArray()[0]==null );
 		assertTrue("deferred load test",g.getProxyArray()[1].getProxyArray()[2]==g );
 		assertTrue( "set of proxies", g.getProxySet().size()==2 );
 		Iterator iter = s.createQuery( "from Glarch g" ).iterate();
 		while ( iter.hasNext() ) {
 			iter.next();
 			iter.remove();
 		}
 		s.getTransaction().commit();
 		s.disconnect();
 		SerializationHelper.deserialize( SerializationHelper.serialize(s) );
 		s.close();
 	}
 
 	@Test
 	public void testCache() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Immutable im = new Immutable();
 		s.save(im);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.load( im, im.getId() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.load( im, im.getId() );
 		assertEquals(
 				"cached object identity",
 				im,
 				s.createQuery( "from Immutable im where im = ?" ).setParameter( 0, im, Hibernate.entity(Immutable.class) ).uniqueResult()
 		);
 		s.connection().createStatement().executeUpdate("delete from immut");
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testFindLoad() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		FooProxy foo = new Foo();
 		s.save(foo);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo = (FooProxy) s.createQuery( "from Foo foo" ).list().get(0);
 		FooProxy foo2 = (FooProxy) s.load( Foo.class, foo.getKey() );
 		assertTrue( "find returns same object as load", foo == foo2 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo2 = (FooProxy) s.load( Foo.class, foo.getKey() );
 		foo = (FooProxy) s.createQuery( "from Foo foo" ).list().get(0);
 		assertTrue( "find returns same object as load", foo == foo2 );
 		doDelete( s, "from Foo foo" );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testRefresh() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo foo = new Foo();
 		s.save(foo);
 		s.flush();
 		s.connection().createStatement().executeUpdate( "update " + getDialect().openQuote() + "foos" + getDialect().closeQuote() + " set long_ = -3" );
 		s.refresh(foo);
 		assertTrue( foo.getLong().longValue() == -3l );
 		assertTrue( s.getCurrentLockMode(foo)==LockMode.READ );
 		s.refresh(foo, LockMode.UPGRADE);
 		if ( getDialect().supportsOuterJoinForUpdate() ) {
 			assertTrue( s.getCurrentLockMode(foo)==LockMode.UPGRADE );
 		}
 		s.delete(foo);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testAutoFlush() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		FooProxy foo = new Foo();
 		s.save(foo);
 		assertTrue( "autoflush create", s.createQuery( "from Foo foo" ).list().size()==1 );
 		foo.setChar( new Character('X') );
 		assertTrue( "autoflush update", s.createQuery( "from Foo foo where foo.char='X'" ).list().size()==1 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		foo = (FooProxy) s.load( Foo.class, foo.getKey() );
 		//s.update( new Foo(), foo.getKey() );
 		//assertTrue( s.find("from Foo foo where not foo.char='X'").size()==1, "autoflush update" );
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof HSQLDialect) && !(getDialect() instanceof PointbaseDialect) )  {
 			foo.setBytes( "osama".getBytes() );
 			assertTrue( "autoflush collection update",
 					s.createQuery( "from Foo foo where 111 in elements(foo.bytes)" ).list().size()==1 );
 			foo.getBytes()[0] = 69;
 			assertTrue( "autoflush collection update",
 					s.createQuery( "from Foo foo where 69 in elements(foo.bytes)" ).list()
 							.size()==1 );
 		}
 		s.delete(foo);
 		assertTrue( "autoflush delete", s.createQuery( "from Foo foo" ).list().size()==0 );
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testVeto() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Vetoer v = new Vetoer();
-		s.save(v); Serializable id = s.save(v);
+		s.save(v);
+		s.save(v);
 		s.getTransaction().commit();
 		s.close();
 		s = openSession();
 		s.beginTransaction();
-		s.update( v, id );
-		s.update( v, id );
+		s.update( v );
+		s.update( v );
 		s.delete( v );
 		s.delete( v );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSerializableType() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Vetoer v = new Vetoer();
 		v.setStrings( new String[] {"foo", "bar", "baz"} );
 		s.save( v ); Serializable id = s.save(v);
 		v.getStrings()[1] = "osama";
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		v = (Vetoer) s.load(Vetoer.class, id);
 		assertTrue( "serializable type", v.getStrings()[1].equals( "osama" ) );
 		s.delete(v); s.delete( v );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testAutoFlushCollections() throws Exception {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setDefaults();
 		s.save(baz);
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		baz = (Baz) s.load(Baz.class, baz.getCode());
 		baz.getStringArray()[0] = "bark";
 		Iterator i = s.createQuery( "select elements(baz.stringArray) from Baz baz" ).iterate();
 		boolean found = false;
 		while ( i.hasNext() ) {
 			if ( "bark".equals( i.next() ) ) found = true;
 		}
 		assertTrue(found);
 		baz.setStringArray(null);
 		i = s.createQuery( "select distinct elements(baz.stringArray) from Baz baz" ).iterate();
 		assertTrue( !i.hasNext() );
 		baz.setStringArray( new String[] { "foo", "bar" } );
 		i = s.createQuery( "select elements(baz.stringArray) from Baz baz" ).iterate();
 		assertTrue( i.hasNext() );
 
 		Foo foo = new Foo();
 		s.save(foo);
 		s.flush();
 		baz.setFooArray( new Foo[] {foo} );
 
 		i = s.createQuery( "select foo from Baz baz join baz.fooArray foo" ).iterate();
 		found = false;
 		while ( i.hasNext() ) {
 			if ( foo==i.next() ) found = true;
 		}
 		assertTrue(found);
 
 		baz.getFooArray()[0] = null;
 		i = s.createQuery( "select foo from Baz baz join baz.fooArray foo" ).iterate();
 		assertTrue( !i.hasNext() );
 		baz.getFooArray()[0] = foo;
 		i = s.createQuery( "select elements(baz.fooArray) from Baz baz" ).iterate();
 		assertTrue( i.hasNext() );
 
 		if ( !(getDialect() instanceof MySQLDialect)
 				&& !(getDialect() instanceof HSQLDialect)
 				&& !(getDialect() instanceof InterbaseDialect)
 				&& !(getDialect() instanceof PointbaseDialect)
 				&& !(getDialect() instanceof SAPDBDialect) )  {
 			baz.getFooArray()[0] = null;
 			i = s.createQuery( "from Baz baz where ? in elements(baz.fooArray)" )
 					.setParameter( 0, foo, Hibernate.entity( Foo.class ) )
 					.iterate();
 			assertTrue( !i.hasNext() );
 			baz.getFooArray()[0] = foo;
 			i = s.createQuery( "select foo from Foo foo where foo in (select elt from Baz baz join baz.fooArray elt)" )
 					.iterate();
 			assertTrue( i.hasNext() );
 		}
 		s.delete(foo);
 		s.delete(baz);
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testUserProvidedConnection() throws Exception {
 		ConnectionProvider dcp = ConnectionProviderBuilder.buildConnectionProvider();
 		Session s = sessionFactory().openSession( dcp.getConnection() );
 		Transaction tx = s.beginTransaction();
 		s.createQuery( "from Fo" ).list();
 		tx.commit();
 		Connection c = s.disconnect();
 		assertTrue( c != null );
 		s.reconnect( c );
 		tx = s.beginTransaction();
 		s.createQuery( "from Fo" ).list();
 		tx.commit();
 		assertTrue( s.close() == c );
 		c.close();
 	}
 
 	@Test
 	public void testCachedCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setDefaults();
 		s.save(baz);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		( (FooComponent) baz.getTopComponents().get(0) ).setCount(99);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		assertTrue( ((FooComponent) baz.getTopComponents().get( 0 )).getCount() == 99 );
 		s.delete( baz );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testComplicatedQuery() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Foo foo = new Foo();
 		Serializable id = s.save(foo);
 		assertTrue( id != null );
 		Qux q = new Qux("q");
 		foo.getDependent().setQux(q);
 		s.save( q );
 		q.getFoo().setString( "foo2" );
 		//s.flush();
 		//s.connection().commit();
 		assertTrue(
 				s.createQuery( "from Foo foo where foo.dependent.qux.foo.string = 'foo2'" ).iterate().hasNext()
 		);
 		s.delete( foo );
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testLoadAfterDelete() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo foo = new Foo();
 		Serializable id = s.save(foo);
 		s.flush();
 		s.delete(foo);
 		boolean err=false;
 		try {
 			s.load(Foo.class, id);
 		}
 		catch (ObjectNotFoundException ode) {
 			err=true;
 		}
 		assertTrue(err);
 		s.flush();
 		err=false;
 		try {
 			( (FooProxy) s.load(Foo.class, id) ).getBool();
 		}
 		catch (ObjectNotFoundException onfe) {
 			err=true;
 		}
 		assertTrue(err);
-		Fo fo = Fo.newFo();
-		id = new FumTest().fumKey("abc"); //yuck!!
-		s.save(fo, id);
+		id = FumTest.fumKey( "abc" ); //yuck!!
+		Fo fo = Fo.newFo( (FumCompositeID) id );
+		s.save(fo);
 		s.flush();
 		s.delete(fo);
 		err=false;
 		try {
 			s.load(Fo.class, id);
 		}
 		catch (ObjectNotFoundException ode) {
 			err=true;
 		}
 		assertTrue(err);
 		s.flush();
 		err=false;
 		try {
 			s.load(Fo.class, id);
 		}
 		catch (ObjectNotFoundException onfe) {
 			err=true;
 		}
 		assertTrue(err);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testObjectType() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		GlarchProxy g = new Glarch();
 		Foo foo = new Foo();
 		g.setAny( foo );
 		Serializable gid = s.save( g );
 		s.save(foo);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( g.getAny()!=null && g.getAny() instanceof FooProxy );
 		s.delete( g.getAny() );
 		s.delete( g );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testAny() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		One one = new One();
 		BarProxy foo = new Bar();
 		foo.setObject(one);
 		Serializable fid = s.save(foo);
 		Serializable oid = one.getKey();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List results = s.createQuery( "from Bar bar where bar.object.id = ? and bar.object.class = ?" )
 				.setParameter( 0, oid, Hibernate.LONG )
 				.setParameter( 1, new Character('O'), Hibernate.CHARACTER )
 				.list();
 		assertEquals( 1, results.size() );
 		results = s.createQuery( "select one from One one, Bar bar where bar.object.id = one.id and bar.object.class = 'O'" )
 				.list();
 		assertEquals( 1, results.size() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo = (BarProxy) s.load(Foo.class, fid);
 		assertTrue( foo.getObject()!=null && foo.getObject() instanceof One && s.getIdentifier( foo.getObject() ).equals(oid) );
 		//s.delete( foo.getObject() );
 		s.delete(foo);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testEmbeddedCompositeID() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Location l = new Location();
 		l.setCountryCode("AU");
 		l.setDescription("foo bar");
 		l.setLocale( Locale.getDefault() );
 		l.setStreetName("Brunswick Rd");
 		l.setStreetNumber(300);
 		l.setCity("Melbourne");
 		s.save(l);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.setFlushMode(FlushMode.MANUAL);
 		l = (Location) s.createQuery( "from Location l where l.countryCode = 'AU' and l.description='foo bar'" )
 				.list()
 				.get(0);
 		assertTrue( l.getCountryCode().equals("AU") );
 		assertTrue( l.getCity().equals("Melbourne") );
 		assertTrue( l.getLocale().equals( Locale.getDefault() ) );
 		assertTrue( s.createCriteria(Location.class).add( Restrictions.eq( "streetNumber", new Integer(300) ) ).list().size()==1 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		l.setDescription("sick're");
 		s.update(l);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		l = new Location();
 		l.setCountryCode("AU");
 		l.setDescription("foo bar");
 		l.setLocale(Locale.ENGLISH);
 		l.setStreetName("Brunswick Rd");
 		l.setStreetNumber(300);
 		l.setCity("Melbourne");
 		assertTrue( l==s.load(Location.class, l) );
 		assertTrue( l.getLocale().equals( Locale.getDefault() ) );
 		s.delete(l);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testAutosaveChildren() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		Set bars = new HashSet();
 		baz.setCascadingBars(bars);
 		s.save(baz);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		baz.getCascadingBars().add( new Bar() );
 		baz.getCascadingBars().add( new Bar() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		assertTrue( baz.getCascadingBars().size()==2 );
 		assertTrue( baz.getCascadingBars().iterator().next()!=null );
 		baz.getCascadingBars().clear(); //test all-delete-orphan;
 		s.flush();
 		assertTrue( s.createQuery( "from Bar bar" ).list().size()==0 );
 		s.delete(baz);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testOrphanDelete() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		Set bars = new HashSet();
 		baz.setCascadingBars(bars);
 		bars.add( new Bar() );
 		bars.add( new Bar() );
 		bars.add( new Bar() );
 		bars.add( new Bar() );
 		s.save(baz);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		bars = baz.getCascadingBars();
 		assertEquals( 4, bars.size() );
 		bars.remove( bars.iterator().next() );
 		assertEquals( 3, s.createQuery( "From Bar bar" ).list().size() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		bars = baz.getCascadingBars();
 		assertEquals( 3, bars.size() );
 		bars.remove( bars.iterator().next() );
 		s.delete(baz);
 		bars.remove( bars.iterator().next() );
 		assertEquals( 0, s.createQuery( "From Bar bar" ).list().size() );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testTransientOrphanDelete() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		Set bars = new HashSet();
 		baz.setCascadingBars(bars);
 		bars.add( new Bar() );
 		bars.add( new Bar() );
 		bars.add( new Bar() );
 		List foos = new ArrayList();
 		foos.add( new Foo() );
 		foos.add( new Foo() );
 		baz.setFooBag(foos);
 		s.save(baz);
 		Iterator i = new JoinedIterator( new Iterator[] {foos.iterator(), bars.iterator()} );
 		while ( i.hasNext() ) {
 			FooComponent cmp = ( (Foo) i.next() ).getComponent();
 			s.delete( cmp.getGlarch() );
 			cmp.setGlarch(null);
 		}
 		t.commit();
 		s.close();
 
 		bars.remove( bars.iterator().next() );
 		foos.remove(1);
 		s = openSession();
 		t = s.beginTransaction();
 		s.update(baz);
 		assertEquals( 2, s.createQuery( "From Bar bar" ).list().size() );
 		assertEquals( 3, s.createQuery( "From Foo foo" ).list().size() );
 		t.commit();
 		s.close();
 
 		foos.remove(0);
 		s = openSession();
 		t = s.beginTransaction();
 		s.update(baz);
 		bars.remove( bars.iterator().next() );
 		assertEquals( 1, s.createQuery( "From Foo foo" ).list().size() );
 		s.delete(baz);
 		//s.flush();
 		assertEquals( 0, s.createQuery( "From Foo foo" ).list().size() );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testProxiesInCollections() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		Bar bar = new Bar();
 		Bar bar2 = new Bar();
 		s.save(bar);
 		Serializable bar2id = s.save(bar2);
 		baz.setFooArray( new Foo[] { bar, bar2 } );
 		HashSet set = new HashSet();
 		bar = new Bar();
 		s.save(bar);
 		set.add(bar);
 		baz.setFooSet(set);
 		set = new HashSet();
 		set.add( new Bar() );
 		set.add( new Bar() );
 		baz.setCascadingBars(set);
 		ArrayList list = new ArrayList();
 		list.add( new Foo() );
 		baz.setFooBag(list);
 		Serializable id = s.save(baz);
 		Serializable bid = ( (Bar) baz.getCascadingBars().iterator().next() ).getKey();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		BarProxy barprox = (BarProxy) s.load(Bar.class, bid);
 		BarProxy bar2prox = (BarProxy) s.load(Bar.class, bar2id);
 		assertTrue(bar2prox instanceof HibernateProxy);
 		assertTrue(barprox instanceof HibernateProxy);
 		baz = (Baz) s.load(Baz.class, id);
 		Iterator i = baz.getCascadingBars().iterator();
 		BarProxy b1 = (BarProxy) i.next();
 		BarProxy b2 = (BarProxy) i.next();
 		assertTrue( ( b1==barprox && !(b2 instanceof HibernateProxy) ) || ( b2==barprox && !(b1 instanceof HibernateProxy) ) ); //one-to-many
 		assertTrue( baz.getFooArray()[0] instanceof HibernateProxy ); //many-to-many
 		assertTrue( baz.getFooArray()[1]==bar2prox );
 		if ( !isOuterJoinFetchingDisabled() ) assertTrue( !(baz.getFooBag().iterator().next() instanceof HibernateProxy) ); //many-to-many outer-join="true"
 		assertTrue( !(baz.getFooSet().iterator().next() instanceof HibernateProxy) ); //one-to-many
 		doDelete( s, "from Baz" );
 		doDelete( s, "from Foo" );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testPSCache() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		for ( int i=0; i<10; i++ ) s.save( new Foo() );
 		Query q = s.createQuery("from Foo");
 		q.setMaxResults(2);
 		q.setFirstResult(5);
 		assertTrue( q.list().size()==2 );
 		q = s.createQuery("from Foo");
 		assertTrue( q.list().size()==10 );
 		assertTrue( q.list().size()==10 );
 		q.setMaxResults(3);
 		q.setFirstResult(3);
 		assertTrue( q.list().size()==3 );
 		q = s.createQuery("from Foo");
 		assertTrue( q.list().size()==10 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		q = s.createQuery("from Foo");
 		assertTrue( q.list().size()==10 );
 		q.setMaxResults(5);
 		assertTrue( q.list().size()==5 );
 		doDelete( s, "from Foo" );
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testForCertain() throws Exception {
 		Glarch g = new Glarch();
 		Glarch g2 = new Glarch();
 		List set = new ArrayList();
 		set.add("foo");
 		g2.setStrings(set);
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Serializable gid = (Serializable) s.save(g);
 		Serializable g2id = (Serializable) s.save(g2);
 		t.commit();
 		assertTrue( g.getVersion()==0 );
 		assertTrue( g2.getVersion()==0 );
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		g = (Glarch) s.get(Glarch.class, gid);
 		g2 = (Glarch) s.get(Glarch.class, g2id);
 		assertTrue( g2.getStrings().size()==1 );
 		s.delete(g);
 		s.delete(g2);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testBagMultipleElements() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setBag( new ArrayList() );
 		baz.setByteBag( new ArrayList() );
 		s.save(baz);
 		baz.getBag().add("foo");
 		baz.getBag().add("bar");
 		baz.getByteBag().add( "foo".getBytes() );
 		baz.getByteBag().add( "bar".getBytes() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		//put in cache
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		assertTrue( baz.getBag().size()==2 );
 		assertTrue( baz.getByteBag().size()==2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		assertTrue( baz.getBag().size()==2 );
 		assertTrue( baz.getByteBag().size()==2 );
 		baz.getBag().remove("bar");
  		baz.getBag().add("foo");
  		baz.getByteBag().add( "bar".getBytes() );
 		t.commit();
 		s.close();
 
  		s = openSession();
  		t = s.beginTransaction();
  		baz = (Baz) s.get( Baz.class, baz.getCode() );
  		assertTrue( baz.getBag().size()==2 );
  		assertTrue( baz.getByteBag().size()==3 );
  		s.delete(baz);
  		t.commit();
  		s.close();
  	}
 
 	@Test
 	public void testWierdSession() throws Exception {
  		Session s = openSession();
  		Transaction t = s.beginTransaction();
  		Serializable id =  s.save( new Foo() );
  		t.commit();
  		s.close();
 
  		s = openSession();
  		s.setFlushMode(FlushMode.MANUAL);
 		t = s.beginTransaction();
 		Foo foo = (Foo) s.get(Foo.class, id);
 		t.commit();
 
 		t = s.beginTransaction();
 		s.flush();
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		foo = (Foo) s.get(Foo.class, id);
 		s.delete(foo);
 		t.commit();
 		s.close();
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/FumTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/FumTest.java
index 7eead2d02a..ed5b2de2a2 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/FumTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/FumTest.java
@@ -1,901 +1,901 @@
 //$Id: FumTest.java 10977 2006-12-12 23:28:04Z steve.ebersole@jboss.com $
 package org.hibernate.test.legacy;
+
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 
 import org.hibernate.Criteria;
 import org.hibernate.FetchMode;
 import org.hibernate.FlushMode;
 import org.hibernate.Hibernate;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.Query;
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 import org.hibernate.criterion.MatchMode;
 import org.hibernate.criterion.Restrictions;
-import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.MckoiDialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.PointbaseDialect;
 import org.hibernate.dialect.TimesTenDialect;
 import org.hibernate.transform.Transformers;
 import org.hibernate.type.DateType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.StringType;
 import org.hibernate.type.Type;
 
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 public class FumTest extends LegacyTestCase {
 	private static short fumKeyShort = 1;
 
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 			"legacy/FooBar.hbm.xml",
 			"legacy/Baz.hbm.xml",
 			"legacy/Qux.hbm.xml",
 			"legacy/Glarch.hbm.xml",
 			"legacy/Fum.hbm.xml",
 			"legacy/Fumm.hbm.xml",
 			"legacy/Fo.hbm.xml",
 			"legacy/One.hbm.xml",
 			"legacy/Many.hbm.xml",
 			"legacy/Immutable.hbm.xml",
 			"legacy/Fee.hbm.xml",
 			"legacy/Vetoer.hbm.xml",
 			"legacy/Holder.hbm.xml",
 			"legacy/Location.hbm.xml",
 			"legacy/Stuff.hbm.xml",
 			"legacy/Container.hbm.xml",
 			"legacy/Simple.hbm.xml",
 			"legacy/Middle.hbm.xml"
 		};
 	}
 
 	@Test
 	public void testQuery() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.createQuery("from Fum fum where fum.fo.id.string = 'x'").list();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCriteriaCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Fum fum = new Fum( fumKey("fum") );
 		fum.setFum("a value");
 		fum.getMapComponent().getFummap().put("self", fum);
 		fum.getMapComponent().getStringmap().put("string", "a staring");
 		fum.getMapComponent().getStringmap().put("string2", "a notha staring");
 		fum.getMapComponent().setCount(1);
 		s.save(fum);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Fum b = (Fum) s.createCriteria(Fum.class).add(
 			Restrictions.in("fum", new String[] { "a value", "no value" } )
 		)
 		.uniqueResult();
 		assertTrue( Hibernate.isInitialized( b.getMapComponent().getStringmap() ) );
 		assertTrue( b.getMapComponent().getFummap().size()==1 );
 		assertTrue( b.getMapComponent().getStringmap().size()==2 );
 		s.delete(b);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCriteria() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Fum fum = new Fum( fumKey("fum") );
 		fum.setFo( new Fum( fumKey("fo") ) );
 		fum.setFum("fo fee fi");
 		fum.getFo().setFum("stuff");
 		Fum fr = new Fum( fumKey("fr") );
 		fr.setFum("goo");
 		Fum fr2 = new Fum( fumKey("fr2") );
 		fr2.setFum("soo");
 		fum.setFriends( new HashSet() );
 		fum.getFriends().add(fr);
 		fum.getFriends().add(fr2);
 		s.save(fr);
 		s.save(fr2);
 		s.save( fum.getFo() );
 		s.save(fum);
 
 		Criteria base = s.createCriteria(Fum.class)
 			.add( Restrictions.like("fum", "f", MatchMode.START) );
 		base.createCriteria("fo")
 			.add( Restrictions.isNotNull("fum") );
 		base.createCriteria("friends")
 			.add( Restrictions.like("fum", "g%") );
 		List list = base.list();
 		assertTrue( list.size()==1 && list.get(0)==fum );
 
 		base = s.createCriteria(Fum.class)
 			.add( Restrictions.like("fum", "f%") )
 			.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP);
 		base.createCriteria("fo", "fo")
 			.add( Restrictions.isNotNull("fum") );
 		base.createCriteria("friends", "fum")
 			.add( Restrictions.like("fum", "g", MatchMode.START) );
 		Map map = (Map) base.uniqueResult();
 
 		assertTrue(
 			map.get("this")==fum &&
 			map.get("fo")==fum.getFo() &&
 			fum.getFriends().contains( map.get("fum") ) &&
 			map.size()==3
 		);
 
 		base = s.createCriteria(Fum.class)
 			.add( Restrictions.like("fum", "f%") )
 			.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP)
 			.setFetchMode( "friends", FetchMode.JOIN );
 		base.createCriteria("fo", "fo")
 			.add( Restrictions.eq( "fum", fum.getFo().getFum() ) );
 		map = (Map) base.list().get(0);
 
 		assertTrue(
 			map.get("this")==fum &&
 			map.get("fo")==fum.getFo() &&
 			map.size()==2
 		);
 
 		list = s.createCriteria(Fum.class)
 			.createAlias("friends", "fr")
 			.createAlias("fo", "fo")
 			.add( Restrictions.like("fum", "f%") )
 			.add( Restrictions.isNotNull("fo") )
 			.add( Restrictions.isNotNull("fo.fum") )
 			.add( Restrictions.like("fr.fum", "g%") )
 			.add( Restrictions.eqProperty("fr.id.short", "id.short") )
 			.list();
 		assertTrue( list.size()==1 && list.get(0)==fum );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		base = s.createCriteria(Fum.class)
 			.add( Restrictions.like("fum", "f%") );
 		base.createCriteria("fo")
 			.add( Restrictions.isNotNull("fum") );
 		base.createCriteria("friends")
 			.add( Restrictions.like("fum", "g%") );
 		fum = (Fum) base.list().get(0);
 		assertTrue(  fum.getFriends().size()==2 );
 		s.delete(fum);
 		s.delete( fum.getFo() );
 		Iterator iter = fum.getFriends().iterator();
 		while ( iter.hasNext() ) {
 			s.delete( iter.next() );
 		}
 		txn.commit();
 		s.close();
 	}
 
 	static public class ABean {
 		public Fum fum;
 		public Fum fo;
 		public Fum getFo() {
 			return fo;
 		}
 		public void setFo(Fum fo) {
 			this.fo = fo;
 		}
 		public Fum getFum() {
 			return fum;
 		}
 		public void setFum(Fum fum) {
 			this.fum = fum;
 		}
 	}
 
 	@Test
 	public void testBeanResultTransformer() throws HibernateException, SQLException {
 		Session s = openSession();
 		Transaction transaction = s.beginTransaction();
 		Fum fum = new Fum( fumKey("fum") );
 		fum.setFo( new Fum( fumKey("fo") ) );
 		fum.setFum("fo fee fi");
 		fum.getFo().setFum("stuff");
 		Fum fr = new Fum( fumKey("fr") );
 		fr.setFum("goo");
 		Fum fr2 = new Fum( fumKey("fr2") );
 		fr2.setFum("soo");
 		fum.setFriends( new HashSet() );
 		fum.getFriends().add(fr);
 		fum.getFriends().add(fr2);
 		s.save(fr);
 		s.save(fr2);
 		s.save( fum.getFo() );
 		s.save(fum);
 		
 		Criteria test = s.createCriteria(Fum.class, "xam")
 			.createCriteria("fo", "fo")
 			.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP);
 		
 		Map fc = (Map) test.list().get(0);
 		assertNotNull(fc.get("xam"));
 		
 		Criteria base = s.createCriteria(Fum.class, "fum")
 		.add( Restrictions.like("fum", "f%") )
 		.setResultTransformer(Transformers.aliasToBean(ABean.class))
 		.setFetchMode("friends", FetchMode.JOIN);
 		base.createCriteria("fo", "fo")
 		.add( Restrictions.eq( "fum", fum.getFo().getFum() ) );
 		ABean map = (ABean) base.list().get(0);
 
 		assertTrue(
 				map.getFum()==fum &&
 				map.getFo()==fum.getFo() );
 		
 		s.delete(fr);
 		s.delete(fr2);
 		s.delete(fum);
 		s.delete(fum.getFo());
 		s.flush();
 		transaction.commit();
 		s.close();
 	}
 
 	@Test
 	public void testListIdentifiers() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Fum fum = new Fum( fumKey("fum") );
 		fum.setFum("fo fee fi");
 		s.save(fum);
 		fum = new Fum( fumKey("fi") );
 		fum.setFum("fee fi fo");
 		s.save(fum);
 		List list = s.createQuery( "select fum.id from Fum as fum where not fum.fum='FRIEND'" ).list();
 		assertTrue( "list identifiers", list.size()==2);
 		Iterator iter = s.createQuery( "select fum.id from Fum fum where not fum.fum='FRIEND'" ).iterate();
 		int i=0;
 		while ( iter.hasNext() ) {
 			assertTrue( "iterate identifiers",  iter.next() instanceof FumCompositeID);
 			i++;
 		}
 		assertTrue(i==2);
 
 		s.delete( s.load(Fum.class, (Serializable) list.get(0) ) );
 		s.delete( s.load(Fum.class, (Serializable) list.get(1) ) );
 		txn.commit();
 		s.close();
 	}
 
 
-	public FumCompositeID fumKey(String str) {
+	public static FumCompositeID fumKey(String str) {
 		return fumKey(str,false);
 	}
 
-	private FumCompositeID fumKey(String str, boolean aCompositeQueryTest) {
+	private static FumCompositeID fumKey(String str, boolean aCompositeQueryTest) {
 		FumCompositeID id = new FumCompositeID();
-		if ( Dialect.getDialect() instanceof MckoiDialect ) {
+		if ( getDialect() instanceof MckoiDialect ) {
 			GregorianCalendar now = new GregorianCalendar();
 			GregorianCalendar cal = new GregorianCalendar(
 				now.get(java.util.Calendar.YEAR),
 				now.get(java.util.Calendar.MONTH),
 				now.get(java.util.Calendar.DATE)
 			);
 			id.setDate( cal.getTime() );
 		}
 		else {
 			id.setDate( new Date() );
 		}
 		id.setString( str );
 
 		if (aCompositeQueryTest) {
 			id.setShort( fumKeyShort++ );
 		}
 		else {
 			id.setShort( (short) 12 );
 		}
 
 		return id;
 	}
 
 	@Test
 	public void testCompositeID() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Fum fum = new Fum( fumKey("fum") );
 		fum.setFum("fee fi fo");
 		s.save(fum);
 		assertTrue( "load by composite key", fum==s.load( Fum.class, fumKey("fum") ) );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		fum = (Fum) s.load( Fum.class, fumKey("fum"), LockMode.UPGRADE );
 		assertTrue( "load by composite key", fum!=null );
 
 		Fum fum2 = new Fum( fumKey("fi") );
 		fum2.setFum("fee fo fi");
 		fum.setFo(fum2);
 		s.save(fum2);
 		assertTrue(
 			"find composite keyed objects",
 				s.createQuery( "from Fum fum where not fum.fum='FRIEND'" ).list().size()==2
 		);
 		assertTrue(
 			"find composite keyed object",
 				s.createQuery( "select fum from Fum fum where fum.fum='fee fi fo'" ).list().get(0)==fum
 		);
 		fum.setFo(null);
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		Iterator iter = s.createQuery( "from Fum fum where not fum.fum='FRIEND'" ).iterate();
 		int i = 0;
 		while ( iter.hasNext() ) {
 			fum = (Fum) iter.next();
 			//iter.remove();
 			s.delete(fum);
 			i++;
 		}
 		assertTrue( "iterate on composite key", i==2 );
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCompositeIDOneToOne() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Fum fum = new Fum( fumKey("fum") );
 		fum.setFum("fee fi fo");
 		//s.save(fum);
 		Fumm fumm = new Fumm();
 		fumm.setFum(fum);
 		s.save(fumm);
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		fumm = (Fumm) s.load( Fumm.class, fumKey("fum") );
 		//s.delete( fumm.getFum() );
 		s.delete(fumm);
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCompositeIDQuery() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Fum fee = new Fum( fumKey("fee",true) );
 		fee.setFum("fee");
 		s.save(fee);
 		Fum fi = new Fum( fumKey("fi",true) );
 		fi.setFum("fi");
 		short fiShort = fi.getId().getShort();
 		s.save(fi);
 		Fum fo = new Fum( fumKey("fo",true) );
 		fo.setFum("fo");
 		s.save(fo);
 		Fum fum = new Fum( fumKey("fum",true) );
 		fum.setFum("fum");
 		s.save(fum);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		// Try to find the Fum object "fo" that we inserted searching by the string in the id
 		List vList = s.createQuery( "from Fum fum where fum.id.string='fo'" ).list();
 		assertTrue( "find by composite key query (find fo object)", vList.size() == 1 );
 		fum = (Fum)vList.get(0);
 		assertTrue( "find by composite key query (check fo object)", fum.getId().getString().equals("fo") );
 
 		// Try to find the Fum object "fi" that we inserted searching by the date in the id
 		vList = s.createQuery( "from Fum fum where fum.id.short = ?" )
 				.setParameter( 0, new Short(fiShort), Hibernate.SHORT )
 				.list();
 		assertEquals( "find by composite key query (find fi object)", 1, vList.size() );
 		fi = (Fum)vList.get(0);
 		assertEquals( "find by composite key query (check fi object)", "fi", fi.getId().getString() );
 
 		// Make sure we can return all of the objects by searching by the date id
 		vList = s.createQuery( "from Fum fum where fum.id.date <= ? and not fum.fum='FRIEND'" )
 				.setParameter( 0, new Date(), Hibernate.DATE )
 				.list();
 		assertEquals( "find by composite key query with arguments", 4, vList.size() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		assertTrue(
 				s.createQuery( "select fum.id.short, fum.id.date, fum.id.string from Fum fum" ).iterate().hasNext()
 		);
 		assertTrue(
 				s.createQuery( "select fum.id from Fum fum" ).iterate().hasNext()
 		);
 		Query qu = s.createQuery("select fum.fum, fum , fum.fum, fum.id.date from Fum fum");
 		Type[] types = qu.getReturnTypes();
 		assertTrue(types.length==4);
 		for ( int k=0; k<types.length; k++) {
 			assertTrue( types[k]!=null );
 		}
 		assertTrue(types[0] instanceof StringType);
 		assertTrue(types[1] instanceof EntityType);
 		assertTrue(types[2] instanceof StringType);
 		assertTrue(types[3] instanceof DateType);
 		Iterator iter = qu.iterate();
 		int j = 0;
 		while ( iter.hasNext() ) {
 			j++;
 			assertTrue( ( (Object[]) iter.next() )[1] instanceof Fum );
 		}
 		assertTrue( "iterate on composite key", j==8 );
 
 		fum = (Fum) s.load( Fum.class, fum.getId() );
 		s.createFilter( fum.getQuxArray(), "where this.foo is null" ).list();
 		s.createFilter( fum.getQuxArray(), "where this.foo.id = ?" )
 				.setParameter( 0, "fooid", Hibernate.STRING )
 				.list();
 		Query f = s.createFilter( fum.getQuxArray(), "where this.foo.id = :fooId" );
 		f.setString("fooId", "abc");
 		assertFalse( f.iterate().hasNext() );
 
 		iter = s.createQuery( "from Fum fum where not fum.fum='FRIEND'" ).iterate();
 		int i = 0;
 		while ( iter.hasNext() ) {
 			fum = (Fum) iter.next();
 			s.delete(fum);
 			i++;
 		}
 		assertTrue( "iterate on composite key", i==4 );
 		s.flush();
 
 		s.createQuery( "from Fum fu, Fum fo where fu.fo.id.string = fo.id.string and fo.fum is not null" ).iterate();
 
 		s.createQuery( "from Fumm f1 inner join f1.fum f2" ).list();
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCompositeIDCollections() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Fum fum1 = new Fum( fumKey("fum1") );
 		Fum fum2 = new Fum( fumKey("fum2") );
 		fum1.setFum("fee fo fi");
 		fum2.setFum("fee fo fi");
 		s.save(fum1);
 		s.save(fum2);
 		Qux q = new Qux();
 		s.save(q);
 		Set set = new HashSet();
 		List list = new ArrayList();
 		set.add(fum1); set.add(fum2);
 		list.add(fum1);
 		q.setFums(set);
 		q.setMoreFums(list);
 		fum1.setQuxArray( new Qux[] {q} );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		q = (Qux) s.load( Qux.class, q.getKey() );
 		assertTrue( "collection of fums", q.getFums().size()==2 );
 		assertTrue( "collection of fums", q.getMoreFums().size()==1 );
 		assertTrue( "unkeyed composite id collection", ( (Fum) q.getMoreFums().get(0) ).getQuxArray()[0]==q );
 		Iterator iter = q.getFums().iterator();
 		iter.hasNext();
 		Fum f = (Fum) iter.next();
 		s.delete(f);
 		iter.hasNext();
 		f = (Fum) iter.next();
 		s.delete(f);
 		s.delete(q);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testDeleteOwner() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Qux q = new Qux();
 		s.save(q);
 		Fum f1 = new Fum( fumKey("f1") );
 		Fum f2 = new Fum( fumKey("f2") );
 		Set set = new HashSet();
 		set.add(f1);
 		set.add(f2);
 		List list = new LinkedList();
 		list.add(f1);
 		list.add(f2);
 		f1.setFum("f1");
 		f2.setFum("f2");
 		q.setFums(set);
 		q.setMoreFums(list);
 		s.save(f1);
 		s.save(f2);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		q = (Qux) s.load( Qux.class, q.getKey(), LockMode.UPGRADE );
 		s.lock( q, LockMode.UPGRADE );
 		s.delete(q);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		list = s.createQuery( "from Fum fum where not fum.fum='FRIEND'" ).list();
 		assertTrue( "deleted owner", list.size()==2 );
 		s.lock( list.get(0), LockMode.UPGRADE );
 		s.lock( list.get(1), LockMode.UPGRADE );
 		Iterator iter = list.iterator();
 		while ( iter.hasNext() ) {
 			s.delete( iter.next() );
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCompositeIDs() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
-		Fo fo = Fo.newFo();
+		Fo fo = Fo.newFo( fumKey("an instance of fo") );
 		Properties props = new Properties();
 		props.setProperty("foo", "bar");
 		props.setProperty("bar", "foo");
 		fo.setSerial(props);
 		fo.setBuf( "abcdefghij1`23%$*^*$*\n\t".getBytes() );
-		s.save( fo, fumKey("an instance of fo") );
+		s.save( fo );
 		s.flush();
 		props.setProperty("x", "y");
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		fo = (Fo) s.load( Fo.class, fumKey("an instance of fo") );
 		props = (Properties) fo.getSerial();
 		assertTrue( props.getProperty("foo").equals("bar") );
 		//assertTrue( props.contains("x") );
 		assertTrue( props.getProperty("x").equals("y") );
 		assertTrue( fo.getBuf()[0]=='a' );
 		fo.getBuf()[1]=(byte)126;
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		fo = (Fo) s.load( Fo.class, fumKey("an instance of fo") );
 		assertTrue( fo.getBuf()[1]==126 );
 		assertTrue(
 				s.createQuery( "from Fo fo where fo.id.string like 'an instance of fo'" ).iterate().next()==fo
 		);
 		s.delete(fo);
 		s.flush();
 		try {
 			s.save( Fo.newFo() );
 			assertTrue(false);
 		}
 		catch (Exception e) {
 			//System.out.println( e.getMessage() );
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testKeyManyToOne() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Inner sup = new Inner();
 		InnerKey sid = new InnerKey();
 		sup.setDudu("dudu");
 		sid.setAkey("a");
 		sid.setBkey("b");
 		sup.setId(sid);
 		Middle m = new Middle();
 		MiddleKey mid = new MiddleKey();
 		mid.setOne("one");
 		mid.setTwo("two");
 		mid.setSup(sup);
 		m.setId(mid);
 		m.setBla("bla");
 		Outer d = new Outer();
 		OuterKey did = new OuterKey();
 		did.setMaster(m);
 		did.setDetailId("detail");
 		d.setId(did);
 		d.setBubu("bubu");
 		s.save(sup);
 		s.save(m);
 		s.save(d);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Inner in = (Inner) s.createQuery( "from Inner" ).list().get(0);
 		assertTrue( in.getMiddles().size()==1 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		assertTrue( s.createQuery( "from Inner _inner join _inner.middles middle" ).list().size()==1 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		d = (Outer) s.load(Outer.class, did);
 		assertTrue( d.getId().getMaster().getId().getSup().getDudu().equals("dudu") );
 		s.delete(d);
 		s.delete( d.getId().getMaster() );
 		s.save( d.getId().getMaster() );
 		s.save(d);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		d = (Outer) s.createQuery( "from Outer o where o.id.detailId = ?" )
 				.setParameter( 0, d.getId().getDetailId(), Hibernate.STRING )
 				.list()
 				.get(0);
 		s.createQuery( "from Outer o where o.id.master.id.sup.dudu is not null" ).list();
 		s.createQuery( "from Outer o where o.id.master.id.sup.id.akey is not null" ).list();
 		s.createQuery( "from Inner i where i.backOut.id.master.id.sup.id.akey = i.id.bkey" ).list();
 		List l = s.createQuery( "select o.id.master.id.sup.dudu from Outer o where o.id.master.id.sup.dudu is not null" )
 				.list();
 		assertTrue(l.size()==1);
 		l = s.createQuery( "select o.id.master.id.sup.id.akey from Outer o where o.id.master.id.sup.id.akey is not null" )
 				.list();
 		assertTrue(l.size()==1);
 		s.createQuery(
 				"select i.backOut.id.master.id.sup.id.akey from Inner i where i.backOut.id.master.id.sup.id.akey = i.id.bkey"
 		).list();
 		s.createQuery( "from Outer o where o.id.master.bla = ''" ).list();
 		s.createQuery( "from Outer o where o.id.master.id.one = ''" ).list();
 		s.createQuery( "from Inner inn where inn.id.bkey is not null and inn.backOut.id.master.id.sup.id.akey > 'a'" )
 				.list();
 		s.createQuery( "from Outer as o left join o.id.master m left join m.id.sup where o.bubu is not null" ).list();
 		s.createQuery( "from Outer as o left join o.id.master.id.sup s where o.bubu is not null" ).list();
 		s.createQuery( "from Outer as o left join o.id.master m left join o.id.master.id.sup s where o.bubu is not null" )
 				.list();
 		s.delete(d);
 		s.delete( d.getId().getMaster() );
 		s.delete( d.getId().getMaster().getId().getSup() );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCompositeKeyPathExpressions() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "select fum1.fo from Fum fum1 where fum1.fo.fum is not null" ).list();
 		s.createQuery( "from Fum fum1 where fum1.fo.fum is not null order by fum1.fo.fum" ).list();
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof HSQLDialect) && !(getDialect() instanceof MckoiDialect) && !(getDialect() instanceof PointbaseDialect) ) {
 			s.createQuery( "from Fum fum1 where exists elements(fum1.friends)" ).list();
 			if(!(getDialect() instanceof TimesTenDialect)) { // can't execute because TimesTen can't do subqueries combined with aggreations
 				s.createQuery( "from Fum fum1 where size(fum1.friends) = 0" ).list();
 			}
 		}
 		s.createQuery( "select elements(fum1.friends) from Fum fum1" ).list();
 		s.createQuery( "from Fum fum1, fr in elements( fum1.friends )" ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testUnflushedSessionSerialization() throws Exception {
 		///////////////////////////////////////////////////////////////////////////
 		// Test insertions across serializations
 		Session s = sessionFactory().openSession();
 		s.setFlushMode(FlushMode.MANUAL);
 		s.beginTransaction();
 
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setAddress("123 Main St. Anytown USA");
 		simple.setCount(1);
 		simple.setDate( new Date() );
 		simple.setName("My UnflushedSessionSerialization Simple");
-		simple.setPay( new Float(5000) );
-		s.save( simple, new Long(10) );
+		simple.setPay( Float.valueOf(5000) );
+		s.save( simple );
 
 		// Now, try to serialize session without flushing...
 		s.getTransaction().commit();
 		Session s2 = spoofSerialization(s);
 		s.close();
 		s = s2;
 		s.beginTransaction();
 
 		simple = (Simple) s.load( Simple.class, new Long(10) );
-		Simple other = new Simple();
+		Simple other = new Simple( Long.valueOf(11) );
 		other.init();
-		s.save( other, new Long(11) );
+		s.save( other );
 
 		simple.setOther(other);
 		s.flush();
 
 		s.getTransaction().commit();
 		s.close();
 		Simple check = simple;
 
 		///////////////////////////////////////////////////////////////////////////
 		// Test updates across serializations
 		s = sessionFactory().openSession();
 		s.setFlushMode(FlushMode.MANUAL);
 		s.beginTransaction();
 
-		simple = (Simple) s.get( Simple.class, new Long(10) );
+		simple = (Simple) s.get( Simple.class, Long.valueOf(10) );
 		assertTrue("Not same parent instances", check.getName().equals( simple.getName() ) );
 		assertTrue("Not same child instances", check.getOther().getName().equals( other.getName() ) );
 
 		simple.setName("My updated name");
 
 		s.getTransaction().commit();
 		s2 = spoofSerialization(s);
 		s.close();
 		s = s2;
 		s.beginTransaction();
 		s.flush();
 
 		s.getTransaction().commit();
 		s.close();
 		check = simple;
 
 		///////////////////////////////////////////////////////////////////////////
 		// Test deletions across serializations
 		s = sessionFactory().openSession();
 		s.setFlushMode(FlushMode.MANUAL);
 		s.beginTransaction();
 
-		simple = (Simple) s.get( Simple.class, new Long(10) );
+		simple = (Simple) s.get( Simple.class, Long.valueOf( 10 ) );
 		assertTrue("Not same parent instances", check.getName().equals( simple.getName() ) );
 		assertTrue("Not same child instances", check.getOther().getName().equals( other.getName() ) );
 
 		// Now, lets delete across serialization...
 		s.delete(simple);
 
 		s.getTransaction().commit();
 		s2 = spoofSerialization(s);
 		s.close();
 		s = s2;
 		s.beginTransaction();
 		s.flush();
 
 		s.getTransaction().commit();
 		s.close();
 
 		///////////////////////////////////////////////////////////////////////////
 		// Test collection actions across serializations
 		s = sessionFactory().openSession();
 		s.setFlushMode(FlushMode.MANUAL);
 		s.beginTransaction();
 
 		Fum fum = new Fum( fumKey("uss-fum") );
 		fum.setFo( new Fum( fumKey("uss-fo") ) );
 		fum.setFum("fo fee fi");
 		fum.getFo().setFum("stuff");
 		Fum fr = new Fum( fumKey("uss-fr") );
 		fr.setFum("goo");
 		Fum fr2 = new Fum( fumKey("uss-fr2") );
 		fr2.setFum("soo");
 		fum.setFriends( new HashSet() );
 		fum.getFriends().add(fr);
 		fum.getFriends().add(fr2);
 		s.save(fr);
 		s.save(fr2);
 		s.save( fum.getFo() );
 		s.save(fum);
 
 		s.getTransaction().commit();
 		s2 = spoofSerialization(s);
 		s.close();
 		s = s2;
 		s.beginTransaction();
 		s.flush();
 
 		s.getTransaction().commit();
 		s.close();
 
 		s = sessionFactory().openSession();
 		s.setFlushMode(FlushMode.MANUAL);
 		s.beginTransaction();
 		fum = (Fum) s.load( Fum.class, fum.getId() );
 
 		assertTrue("the Fum.friends did not get saved", fum.getFriends().size() == 2);
 
 		fum.setFriends(null);
 		s.getTransaction().commit();
 		s2 = spoofSerialization(s);
 		s.close();
 		
 		s = s2;
 		s.beginTransaction();
 		s.flush();
 
 		s.getTransaction().commit();
 		s.close();
 
 		s = sessionFactory().openSession();
 		s.setFlushMode(FlushMode.MANUAL);
 		fum = (Fum) s.load( Fum.class, fum.getId() );
 		assertTrue("the Fum.friends is not empty", fum.getFriends() == null || fum.getFriends().size() == 0);
 		s.connection().commit();
 		s.close();
 	}
 
 	private Session spoofSerialization(Session session) throws IOException {
 		try {
 			// Serialize the incoming out to memory
 			ByteArrayOutputStream serBaOut = new ByteArrayOutputStream();
 			ObjectOutputStream serOut = new ObjectOutputStream(serBaOut);
 
 			serOut.writeObject(session);
 
 			// Now, re-constitute the model from memory
 			ByteArrayInputStream serBaIn =
 			        new ByteArrayInputStream(serBaOut.toByteArray());
 			ObjectInputStream serIn = new ObjectInputStream(serBaIn);
 
 			Session outgoing = (Session) serIn.readObject();
 
 			return outgoing;
 		}
 		catch (ClassNotFoundException cnfe) {
 			throw new IOException("Unable to locate class on reconstruction");
 		}
 	}
 
 }
 
 
 
 
 
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/IJ2Test.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/IJ2Test.java
index 1475472017..fd1d163ab0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/IJ2Test.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/IJ2Test.java
@@ -1,146 +1,146 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
 import java.io.Serializable;
 
 import org.hibernate.LockMode;
-import org.hibernate.classic.Session;
+import org.hibernate.Session;
 
 import org.junit.Test;
 
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Gavin King
  */
 public class IJ2Test extends LegacyTestCase {
 
 	public String[] getMappings() {
 		return new String[] { "legacy/IJ2.hbm.xml" };
 	}
 
 	@SuppressWarnings( {"UnusedAssignment"})
 	@Test
 	public void testUnionSubclass() throws Exception {
 		Session s = sessionFactory().openSession();
 		s.beginTransaction();
 		I i = new I();
 		i.setName( "i" );
 		i.setType( 'a' );
 		J j = new J();
 		j.setName( "j" );
 		j.setType( 'x' );
 		j.setAmount( 1.0f );
 		Serializable iid = s.save(i);
 		Serializable jid = s.save(j);
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getCache().evictEntityRegion( I.class );
 
 		s = sessionFactory().openSession();
 		s.beginTransaction();
 		j = (J) s.get(I.class, jid);
 		j = (J) s.get(J.class, jid);
 		i = (I) s.get(I.class, iid);
 		assertTrue( i.getClass()==I.class );
 		j.setAmount( 0.5f );
 		s.lock(i, LockMode.UPGRADE);
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getCache().evictEntityRegion( I.class );
 
 		s = sessionFactory().openSession();
 		s.beginTransaction();
 		j = (J) s.get(J.class, jid);
 		j = (J) s.get(I.class, jid);
 		i = (I) s.get(I.class, iid);
 		assertTrue( i.getClass()==I.class );
 		j.setAmount( 0.5f );
 		s.lock(i, LockMode.UPGRADE);
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getCache().evictEntityRegion( I.class );
 
 		s = sessionFactory().openSession();
 		s.beginTransaction();
 		assertTrue( s.createQuery( "from I" ).list().size()==2 );
 		assertTrue( s.createQuery( "from J" ).list().size()==1 );
 		assertTrue( s.createQuery( "from J j where j.amount > 0 and j.name is not null" ).list().size()==1 );
 		assertTrue( s.createQuery( "from I i where i.class = org.hibernate.test.legacy.I" ).list().size()==1 );
 		assertTrue( s.createQuery( "from I i where i.class = J" ).list().size()==1 );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getCache().evictEntityRegion( I.class );
 
 		s = sessionFactory().openSession();
 		s.beginTransaction();
 		j = (J) s.get(J.class, jid);
 		i = (I) s.get(I.class, iid);
 		K k = new K();
 		Serializable kid = s.save(k);
 		i.setParent(k);
 		j.setParent(k);
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getCache().evictEntityRegion( I.class );
 
 		s = sessionFactory().openSession();
 		s.beginTransaction();
 		j = (J) s.get(J.class, jid);
 		i = (I) s.get(I.class, iid);
 		k = (K) s.get(K.class, kid);
 		System.out.println(k + "=" + i.getParent());
 		assertTrue( i.getParent()==k );
 		assertTrue( j.getParent()==k );
 		assertTrue( k.getIs().size()==2 );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getCache().evictEntityRegion( I.class );
 
 		s = sessionFactory().openSession();
 		s.beginTransaction();
 		assertTrue( s.createQuery( "from K k inner join k.is i where i.name = 'j'" ).list().size()==1 );
 		assertTrue( s.createQuery( "from K k inner join k.is i where i.name = 'i'" ).list().size()==1 );
 		assertTrue( s.createQuery( "from K k left join fetch k.is" ).list().size()==2 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = sessionFactory().openSession();
 		s.beginTransaction();
 		j = (J) s.get(J.class, jid);
 		i = (I) s.get(I.class, iid);
 		k = (K) s.get(K.class, kid);
 		s.delete(k);
 		s.delete(j);
 		s.delete(i);
 		s.getTransaction().commit();
 		s.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/IJTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/IJTest.java
index 2206986142..91fcb2f4af 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/IJTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/IJTest.java
@@ -1,77 +1,78 @@
 //$Id: IJTest.java 10977 2006-12-12 23:28:04Z steve.ebersole@jboss.com $
 package org.hibernate.test.legacy;
+
 import java.io.Serializable;
 
 import org.hibernate.LockMode;
-import org.hibernate.classic.Session;
+import org.hibernate.Session;
 import org.hibernate.dialect.HSQLDialect;
 
 import org.junit.Test;
 
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Gavin King
  */
 public class IJTest extends LegacyTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "legacy/IJ.hbm.xml" };
 	}
 
 	@Test
 	public void testFormulaDiscriminator() throws Exception {
 		if ( getDialect() instanceof HSQLDialect ) return;
 		Session s = sessionFactory().openSession();
 		s.beginTransaction();
 		I i = new I();
 		i.setName( "i" );
 		i.setType( 'a' );
 		J j = new J();
 		j.setName( "j" );
 		j.setType( 'x' );
 		j.setAmount( 1.0f );
 		Serializable iid = s.save(i);
 		Serializable jid = s.save(j);
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getCache().evictEntityRegion( I.class );
 
 		s = sessionFactory().openSession();
 		s.beginTransaction();
 		j = (J) s.get(I.class, jid);
 		i = (I) s.get(I.class, iid);
 		assertTrue( i.getClass()==I.class );
 		j.setAmount( 0.5f );
 		s.lock(i, LockMode.UPGRADE);
 		s.getTransaction().commit();
 		s.close();
 
 		s = sessionFactory().openSession();
 		s.beginTransaction();
 		j = (J) s.get(I.class, jid, LockMode.UPGRADE);
 		i = (I) s.get(I.class, iid, LockMode.UPGRADE);
 		s.getTransaction().commit();
 		s.close();
 
 		s = sessionFactory().openSession();
 		s.beginTransaction();
 		assertTrue( s.createQuery( "from I" ).list().size()==2 );
 		assertTrue( s.createQuery( "from J" ).list().size()==1 );
 		assertTrue( s.createQuery( "from I i where i.class = 0" ).list().size()==1 );
 		assertTrue( s.createQuery( "from I i where i.class = 1" ).list().size()==1 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = sessionFactory().openSession();
 		s.beginTransaction();
 		j = (J) s.get(J.class, jid);
 		i = (I) s.get(I.class, iid);
 		s.delete(j);
 		s.delete(i);
 		s.getTransaction().commit();
 		s.close();
 
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/LegacyTestCase.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/LegacyTestCase.java
index 98d35ed79b..77123cc672 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/LegacyTestCase.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/LegacyTestCase.java
@@ -1,109 +1,109 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
 
 import org.hibernate.Query;
+import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.DefaultNamingStrategy;
 import org.hibernate.cfg.Environment;
-import org.hibernate.classic.Session;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.hql.classic.ClassicQueryTranslatorFactory;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.type.Type;
 
 import org.junit.Before;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 /**
  * @author Steve Ebersole
  */
 public abstract class LegacyTestCase extends BaseCoreFunctionalTestCase {
 	public static final String USE_ANTLR_PARSER_PROP = "legacy.use_antlr_hql_parser";
 
 	private boolean useAntlrParser;
 
 	@Before
 	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	public void checkAntlrParserSetting() {
 		useAntlrParser = Boolean.valueOf( extractFromSystem( USE_ANTLR_PARSER_PROP ) ).booleanValue();
 	}
 
 	protected static String extractFromSystem(String systemPropertyName) {
 		try {
 			return System.getProperty( systemPropertyName );
 		}
 		catch( Throwable t ) {
 			return null;
 		}
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		if ( !useAntlrParser ) {
 			cfg.setProperty( Environment.QUERY_TRANSLATOR, ClassicQueryTranslatorFactory.class.getName() );
 			try {
 				String dialectTrueRepresentation = Dialect.getDialect().toBooleanValueString( true );
 				// if this call succeeds, then the dialect is saying to represent true/false as int values...
 				Integer.parseInt( dialectTrueRepresentation );
 				String subs = cfg.getProperties().getProperty( Environment.QUERY_SUBSTITUTIONS );
 				if ( subs == null ) {
 					subs = "";
 				}
 				if ( StringHelper.isEmpty( subs ) ) {
 					subs = "true=1, false=0";
 				}
 				else {
 					subs += ", true=1, false=0";
 				}
 				cfg.getProperties().setProperty( Environment.QUERY_SUBSTITUTIONS, subs );
 				cfg.setNamingStrategy( DefaultNamingStrategy.INSTANCE );
 			}
 			catch( NumberFormatException nfe ) {
 				// the Integer#parseInt call failed...
 			}
 		}
 	}
 
 	protected int doDelete(Session session, String queryString) {
 		return doDelete( session, session.createQuery( queryString ) );
 	}
 
 	protected int doDelete(Session session, String queryString, Object param, Type paramType) {
 		Query query = session.createQuery( queryString )
 				.setParameter( 0, param, paramType );
 		return doDelete( session, query );
 	}
 
 	protected int doDelete(Session session, Query selectQuery) {
 		int count = 0;
 		for ( Object o : selectQuery.list() ) {
 			session.delete( o );
 			count++;
 		}
 		return count;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/Master.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/Master.java
index f79a28ed12..1cfee87661 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/Master.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/Master.java
@@ -1,142 +1,155 @@
 //$Id: Master.java 4599 2004-09-26 05:18:27Z oneovthafew $
 package org.hibernate.test.legacy;
 import java.io.Serializable;
 import java.math.BigDecimal;
 import java.util.Collection;
 import java.util.Date;
 import java.util.HashSet;
 import java.util.Set;
 
 public class Master implements Serializable, Named {
+	private Long id;
 	private Master otherMaster;
 	private Set details = new HashSet();
 	private Set moreDetails = new HashSet();
 	private Set incoming = new HashSet();
 	private Set outgoing = new HashSet();
 	private String name="master";
 	private Date stamp;
 	private int version;
 	private BigDecimal bigDecimal = new BigDecimal("1234.123");
 	private int x;
 	private Collection allDetails;
-	
+
+	public Master() {
+	}
+
+	public Long getId() {
+		return id;
+	}
+
+	public void setId(Long id) {
+		this.id = id;
+	}
+
 	public int getX() {
 		return x;
 	}
+
 	public void setX(int x) {
 		this.x = x;
 	}
 	
 	public Set getDetails() {
 		return details;
 	}
 	
 	private void setDetails(Set details) {
 		this.details = details;
 	}
 	
 	public void addDetail(Detail d) {
 		details.add(d);
 	}
 	
 	public void removeDetail(Detail d) {
 		details.remove(d);
 	}
 	
 	public void addIncoming(Master m) {
 		incoming.add(m);
 	}
 	
 	public void removeIncoming(Master m) {
 		incoming.remove(m);
 	}
 	
 	public void addOutgoing(Master m) {
 		outgoing.add(m);
 	}
 	
 	public void removeOutgoing(Master m) {
 		outgoing.remove(m);
 	}
 	
 	public Set getIncoming() {
 		return incoming;
 	}
 	
 	public void setIncoming(Set incoming) {
 		this.incoming = incoming;
 	}
 	
 	public Set getOutgoing() {
 		return outgoing;
 	}
 	
 	public void setOutgoing(Set outgoing) {
 		this.outgoing = outgoing;
 	}
 	
 	public Set getMoreDetails() {
 		return moreDetails;
 	}
 	
 	public void setMoreDetails(Set moreDetails) {
 		this.moreDetails = moreDetails;
 	}
 	
 	public String getName() {
 		return name;
 	}
 	
 	public void setName(String name) {
 		this.name = name;
 	}
 	
 	public Date getStamp() {
 		return stamp;
 	}
 	
 	public void setStamp(Date stamp) {
 		this.stamp = stamp;
 	}
 	
 	public BigDecimal getBigDecimal() {
 		return bigDecimal;
 	}
 	
 	public void setBigDecimal(BigDecimal bigDecimal) {
 		this.bigDecimal = bigDecimal;
 	}
 	
 	/**
 	 * @return
 	 */
 	public Master getOtherMaster() {
 		return otherMaster;
 	}
 
 	/**
 	 * @param master
 	 */
 	public void setOtherMaster(Master master) {
 		otherMaster = master;
 	}
 
 	/**
 	 * @return Returns the allDetails.
 	 */
 	public Collection getAllDetails() {
 		return allDetails;
 	}
 	/**
 	 * @param allDetails The allDetails to set.
 	 */
 	public void setAllDetails(Collection allDetails) {
 		this.allDetails = allDetails;
 	}
 }
 
 
 
 
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/MasterDetail.hbm.xml b/hibernate-core/src/test/java/org/hibernate/test/legacy/MasterDetail.hbm.xml
index d6d75aa6e3..f6d67d79da 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/MasterDetail.hbm.xml
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/MasterDetail.hbm.xml
@@ -1,78 +1,78 @@
 <?xml version="1.0"?>
 <!DOCTYPE hibernate-mapping PUBLIC 
 	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
 	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
 	
 <hibernate-mapping default-lazy="false">
 
 	<class name="org.hibernate.test.legacy.Master" table="`master`">
 		<meta attribute="foo">foo</meta>
-		<id column="master_key_column" type="long">
+		<id name="id" column="master_key_column" type="long">
 			<generator class="native"/>
 		</id>
 		<version name="version" access="field"/>
 		<!--version type="timestamp" name="stamp" column="ts_"/-->
 		<!--timestamp name="stamp" column="ts_"/-->
 		<property name="name">
 			<meta attribute="bar">bar</meta>
 			<meta attribute="bar">bar2</meta>
 		</property>
 		<property name="x"/>
 		<property name="bigDecimal" column="big_dec" precision="7" scale="3"/>
 		<set name="details" inverse="true" lazy="true" order-by="i asc">
 			<key column="master_key"/>
 			<one-to-many class="org.hibernate.test.legacy.Detail"/>
 		</set>
 		<set name="moreDetails" cascade="all" lazy="true" order-by="i desc">
 			<key column="more_master_key"/>
 			<one-to-many class="org.hibernate.test.legacy.Detail"/>
 		</set>
 		<set name="incoming" lazy="true" table="mtm">
 			<key foreign-key="AA" column="outgoingabcdef"/>
 			<many-to-many class="org.hibernate.test.legacy.Master" foreign-key="BB">
 				<column name="incomingabcdef" index="IBB"/>
 			</many-to-many>
 		</set>
 		<set name="outgoing" lazy="true" table="mtm" inverse="true">
 			<key column="incomingabcdef"/>
 			<many-to-many class="org.hibernate.test.legacy.Master" column="outgoingabcdef"/>
 		</set>
 		<many-to-one name="otherMaster"/>
 		<!--query-list name="allDetails" query-ref="all_details"/-->
 	</class>
 	
 	<class name="org.hibernate.test.legacy.Detail">
 		<id column="detail_key_column" type="long">
 			<generator class="native"/>
 		</id>
 		<property name="x">
 			<column name="x" unique-key="uk" not-null="true"/>
 		</property>
 		<property name="i">
 			<column name="i" unique-key="uk" not-null="true"/>
 		</property>
 		<many-to-one name="master" foreign-key="CC"> <!--not-null="true"-->
 			<column name="master_key" unique-key="uk" not-null="true"/>
 		</many-to-one>
 		<!-- <cache timeout="10000" type="readwrite"/> -->
 		<set name="subDetails" lazy="true" cascade="all">
 			<key column="detail_key"/>
 			<one-to-many class="org.hibernate.test.legacy.SubDetail"/>
 		</set>
 	</class>
 	
 	<class name="org.hibernate.test.legacy.SubDetail">
 		<id column="subdetail_key_col" type="long">
 			<generator class="native">
 				<param name="sequence">fooseq</param>
 			</generator>
 		</id>
 		<property name="name"/>
 	</class>
 	
 	<query name="all_details" cacheable="true" fetch-size="10"><![CDATA[
 		from 
 			Detail as d
 	]]></query>
 
 </hibernate-mapping>
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/MasterDetailTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/MasterDetailTest.java
index 015f2ce30d..77049b0b4a 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/MasterDetailTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/MasterDetailTest.java
@@ -1,1102 +1,1103 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
+
 import java.io.Serializable;
 import java.sql.Connection;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 
 import org.hibernate.Hibernate;
 import org.hibernate.LockMode;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.Query;
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 import org.hibernate.criterion.Example;
 import org.hibernate.criterion.Restrictions;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.MckoiDialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.SAPDBDialect;
 import org.hibernate.mapping.MetaAttribute;
 import org.hibernate.mapping.PersistentClass;
 
 import org.junit.Test;
 
 import org.hibernate.testing.SkipLog;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 
 public class MasterDetailTest extends LegacyTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 			"legacy/MasterDetail.hbm.xml",
 			"legacy/Custom.hbm.xml",
 			"legacy/Category.hbm.xml",
 			"legacy/Nameable.hbm.xml",
 			"legacy/SingleSeveral.hbm.xml",
 			"legacy/WZ.hbm.xml",
 			"legacy/UpDown.hbm.xml",
 			"legacy/Eye.hbm.xml"
 		};
 	}
 
 	@Test
 	public void testOuterJoin() throws Exception {
 		Session s = openSession();
 		Eye e = new Eye();
 		e.setName("Eye Eye");
 		Jay jay = new Jay(e);
 		e.setJay(jay);
 		s.saveOrUpdate(e);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		e = (Eye) s.createCriteria(Eye.class).uniqueResult();
 		assertTrue( Hibernate.isInitialized( e.getJay() ) );
 		assertTrue( Hibernate.isInitialized( e.getJays() ) );
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		jay = (Jay) s.createQuery("select new Jay(eye) from Eye eye").uniqueResult();
 		assertTrue( "Eye Eye".equals( jay.getEye().getName() ) );
 		s.delete( jay.getEye() );
 		s.flush();
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testMeta() throws Exception {
 		PersistentClass clazz = configuration().getClassMapping( Master.class.getName() );
 		MetaAttribute meta = clazz.getMetaAttribute("foo");
 		assertTrue( "foo".equals( meta.getValue() ) );
 		meta = clazz.getProperty("name").getMetaAttribute("bar");
 		assertTrue( meta.isMultiValued() );
 	}
 
 	@Test
 	public void testCopy() throws Exception {
 		Category catWA = new Category();
 		catWA.setName("HSQL workaround");
 		Category cat = new Category();
 		cat.setName("foo");
 		Category subCatBar = new Category();
 		subCatBar.setName("bar");
 		Category subCatBaz = new Category();
 		subCatBaz.setName("baz");
 		cat.getSubcategories().add(subCatBar);
 		cat.getSubcategories().add(subCatBaz);
 		Session s = openSession();
 		s.save(catWA);
 		s.save(cat);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		cat.setName("new foo");
 		subCatBar.setName("new bar");
 		cat.getSubcategories().remove(subCatBaz);
 		Category newCat = new Category();
 		newCat.setName("new");
 		cat.getSubcategories().add(newCat);
 		Category newSubCat = new Category();
 		newSubCat.setName("new sub");
 		newCat.getSubcategories().add(newSubCat);
 
 		s = openSession();
-		Category copiedCat = (Category) s.saveOrUpdateCopy(cat);
+		Category copiedCat = (Category) s.merge( cat );
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		assertFalse( copiedCat==cat );
 		//assertFalse( copiedCat.getSubcategories().contains(newCat) );
 		assertTrue( cat.getSubcategories().contains(newCat) );
 
 		s = openSession();
 		cat = (Category) s.createQuery("from Category cat where cat.name='new foo'").uniqueResult();
 		newSubCat = (Category) s.createQuery("from Category cat left join fetch cat.subcategories where cat.name='new sub'").uniqueResult();
 		assertTrue( newSubCat.getName().equals("new sub") );
 		s.close();
 
 		newSubCat.getSubcategories().add(cat);
 		cat.setName("new new foo");
 
 		s = openSession();
-		newSubCat = (Category) s.saveOrUpdateCopy( newSubCat, new Long( newSubCat.getId() ) );
-		assertTrue( newSubCat.getName().equals("new sub") );
-		assertTrue( newSubCat.getSubcategories().size()==1 );
-		cat = (Category) newSubCat.getSubcategories().get(0);
-		assertTrue( cat.getName().equals("new new foo") );
-		newSubCat.getSubcategories().remove(cat);
 		s.delete(cat);
 		s.delete(subCatBaz);
 		s.delete(catWA);
 		s.flush();
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNotNullDiscriminator() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Up up = new Up();
 		up.setId1("foo");
 		up.setId2(123l);
 		Down down = new Down();
 		down.setId1("foo");
 		down.setId2(321l);
 		down.setValue(12312312l);
 		s.save(up);
 		s.save(down);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List list = s.createQuery( "from Up up order by up.id2 asc" ).list();
 		assertTrue( list.size()==2 );
 		assertFalse( list.get(0) instanceof Down );
 		assertTrue( list.get(1) instanceof Down );
 		list = s.createQuery( "from Down down" ).list();
 		assertTrue( list.size()==1 );
 		assertTrue( list.get(0) instanceof Down );
 		//list = s.find("from Up down where down.class = Down");
 		assertTrue( list.size()==1 );
 		assertTrue( list.get(0) instanceof Down );
-		s.delete("from Up up");
+		for ( Object entity : s.createQuery( "from Up" ).list() ) {
+			s.delete( entity );
+		}
 		t.commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testSelfManyToOne() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Master m = new Master();
 		m.setOtherMaster(m);
 		s.save(m);
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		Iterator i = s.createQuery( "from Master" ).iterate();
 		m = (Master) i.next();
 		assertTrue( m.getOtherMaster()==m );
 		if (getDialect() instanceof HSQLDialect) { m.setOtherMaster(null); s.flush(); }
 		s.delete(m);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testExample() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Master m = new Master();
 		m.setName("name");
 		m.setX(5);
 		m.setOtherMaster(m);
 		s.save(m);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Master m1 = (Master) s.createCriteria(Master.class)
 			.add( Example.create(m).enableLike().ignoreCase().excludeProperty("bigDecimal") )
 			.uniqueResult();
 		assertTrue( m1.getOtherMaster()==m1 );
 		m1 = (Master) s.createCriteria(Master.class)
 			.add( Restrictions.eq("name", "foobar") )
 			.uniqueResult();
 		assertTrue( m1==null );
 		m1 = (Master) s.createCriteria(Master.class)
 			.add( Example.create(m).excludeProperty("bigDecimal") )
 			.createCriteria("otherMaster")
 				.add( Example.create(m).excludeZeroes().excludeProperty("bigDecimal") )
 			.uniqueResult();
 		assertTrue( m1.getOtherMaster()==m1 );
 		Master m2 = (Master) s.createCriteria(Master.class)
 			.add( Example.create(m).excludeNone().excludeProperty("bigDecimal") )
 			.uniqueResult();
 		assertTrue( m2==m1 );
 		m.setName(null);
 		m2 = (Master) s.createCriteria(Master.class)
 			.add( Example.create(m).excludeNone().excludeProperty("bigDecimal") )
 			.uniqueResult();
 		assertTrue( null==m2 );
 		if (getDialect() instanceof HSQLDialect) { m1.setOtherMaster(null); s.flush(); }
 		s.delete(m1);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testNonLazyBidirectional() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Single sin = new Single();
 		sin.setId("asdfds");
 		sin.setString("adsa asdfasd");
 		Several sev = new Several();
 		sev.setId("asdfasdfasd");
 		sev.setString("asd ddd");
 		sin.getSeveral().add(sev);
 		sev.setSingle(sin);
 		s.save(sin);
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		sin = (Single) s.load( Single.class, sin );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		sev = (Several) s.load( Several.class, sev );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "from Several" ).list();
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
-		s.delete("from Single");
+		for ( Object entity : s.createQuery( "from Single" ).list() ) {
+			s.delete( entity );
+		}
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionQuery() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof SAPDBDialect) && !(getDialect() instanceof MckoiDialect) ) {
 			s.createQuery( "FROM Master m WHERE NOT EXISTS ( FROM m.details d WHERE NOT d.i=5 )" ).iterate();
 			s.createQuery( "FROM Master m WHERE NOT 5 IN ( SELECT d.i FROM m.details AS d )" ).iterate();
 		}
 		s.createQuery( "SELECT m FROM Master m JOIN m.details d WHERE d.i=5" ).iterate();
 		s.createQuery( "SELECT m FROM Master m JOIN m.details d WHERE d.i=5" ).list();
 		s.createQuery( "SELECT m.id FROM Master AS m JOIN m.details AS d WHERE d.i=5" ).list();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testMasterDetail() throws Exception {
 		if (getDialect() instanceof HSQLDialect) return;
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Master master = new Master();
 		assertTrue( "save returned native id", s.save(master)!=null );
 		Serializable mid = s.getIdentifier(master);
 		Detail d1 = new Detail();
 		d1.setMaster(master);
 		Serializable did = s.save(d1);
 		Detail d2 = new Detail();
 		d2.setI(12);
 		d2.setMaster(master);
 		assertTrue( "generated id returned", s.save(d2)!=null);
 		master.addDetail(d1);
 		master.addDetail(d2);
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof SAPDBDialect) && !(getDialect() instanceof MckoiDialect) && !(getDialect() instanceof org.hibernate.dialect.TimesTenDialect)) {
 			assertTrue(
 				"query",
 					s.createQuery(
 							"from Detail d, Master m where m = d.master and size(m.outgoing) = 0 and size(m.incoming) = 0"
 					).list().size()==2
 			);
 		}
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		master = new Master();
 		s.load(master, mid);
 		assertTrue( master.getDetails().size()==2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		master = (Master) s.load(Master.class, mid);
 		Iterator iter = master.getDetails().iterator();
 		int i=0;
 		while ( iter.hasNext() ) {
 			Detail d = (Detail) iter.next();
 			assertTrue( "master-detail", d.getMaster()==master );
 			i++;
 		}
 		assertTrue( "master-detail", i==2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		assertTrue( s.createQuery( "select elements(master.details) from Master master" ).list().size()==2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List list = s.createQuery( "from Master m left join fetch m.details" ).list();
 		Master m = (Master) list.get(0);
 		assertTrue( Hibernate.isInitialized( m.getDetails() ) );
 		assertTrue( m.getDetails().size()==2 );
 		list = s.createQuery( "from Detail d inner join fetch d.master" ).list();
 		Detail dt = (Detail) list.get(0);
 		Serializable dtid = s.getIdentifier(dt);
 		assertTrue( dt.getMaster()==m );
 
 		//assertTrue(m.getAllDetails().size()==2);
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		list = s.createQuery( "select m from Master m1, Master m left join fetch m.details where m.name=m1.name" )
 				.list();
 		assertTrue( Hibernate.isInitialized( ( (Master) list.get(0) ).getDetails() ) );
 		dt = (Detail) s.load(Detail.class, dtid);
 		assertTrue( ( (Master) list.get(0) ).getDetails().contains(dt) );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		list = s.createQuery(
 				"select m, m1.name from Master m1, Master m left join fetch m.details where m.name=m1.name"
 		).list();
 		assertTrue( Hibernate.isInitialized( ( (Master) ( (Object[]) list.get(0) )[0] ).getDetails() ) );
 		dt = (Detail) s.load(Detail.class, dtid);
 		assertTrue( ( (Master) ( (Object[]) list.get(0) )[0] ).getDetails().contains(dt) );
 		//list = s.find("select m from Master m, Master m2 left join fetch m.details");
 // depracted syntax
 //		list = s.find("select m.id from Master m inner join fetch m.details");
 		t.commit();
 		s.close();
 
 
 		s = openSession();
 		t = s.beginTransaction();
 		Detail dd = (Detail) s.load(Detail.class, did);
 		master = dd.getMaster();
 		assertTrue( "detail-master", master.getDetails().contains(dd) );
 		assertTrue( s.createFilter( master.getDetails(), "order by this.i desc" ).list().size()==2 );
 		assertTrue( s.createFilter( master.getDetails(), "select this where this.id > -1" ).list().size()==2 );
 		Query q = s.createFilter( master.getDetails(), "where this.id > :id" );
 		q.setInteger("id", -1);
 		assertTrue( q.list().size()==2 );
 		q = s.createFilter( master.getDetails(), "where this.id > :id1 and this.id < :id2" );
 		q.setInteger("id1", -1);
 		q.setInteger("id2", 99999999);
 		assertTrue( q.list().size()==2 );
 		q.setInteger("id2", -1);
 		assertTrue( q.list().size()==0 );
 		q = s.createFilter( master.getDetails(), "where this.id in (:ids)" );
 		list = new ArrayList();
 		list.add(did);
 		list.add( new Long(-1) );
 		q.setParameterList("ids", list);
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.iterate().hasNext() );
 		assertTrue( s.createFilter( master.getDetails(), "where this.id > -1" ).list().size()==2 );
 		assertTrue( s.createFilter( master.getDetails(), "select this.master where this.id > -1" ).list().size()==2 );
 		assertTrue(
 				s.createFilter( master.getDetails(), "select m from Master m where this.id > -1 and this.master=m" )
 						.list()
 						.size()==2 );
 		assertTrue( s.createFilter( master.getIncoming(), "where this.id > -1 and this.name is not null" ).list().size()==0 );
 
 		assertTrue( s.createFilter( master.getDetails(), "select max(this.i)" ).iterate().next() instanceof Integer );
 		assertTrue( s.createFilter( master.getDetails(), "select max(this.i) group by this.id" ).iterate().next() instanceof Integer );
 		assertTrue( s.createFilter( master.getDetails(), "select count(*)" ).iterate().next() instanceof Long );
 
 		assertTrue( s.createFilter( master.getDetails(), "select this.master" ).list().size()==2 );
 		assertTrue( s.createFilter( master.getMoreDetails(), "" ).list().size()==0 );
 		assertTrue( s.createFilter( master.getIncoming(), "" ).list().size()==0 );
 
 		Query f = s.createFilter( master.getDetails(), "select max(this.i) where this.i < :top and this.i>=:bottom" );
 		f.setInteger("top", 100);
 		f.setInteger("bottom", 0);
 		assertEquals( f.iterate().next(), new Integer(12) );
 		f.setInteger("top", 2);
 		assertEquals( f.iterate().next(), new Integer(0) );
 
 		f = s.createFilter( master.getDetails(), "select max(this.i) where this.i not in (:list)" );
 		Collection coll = new ArrayList();
 		coll.add( new Integer(-666) );
 		coll.add( new Integer(22) );
 		coll.add( new Integer(0) );
 		f.setParameterList("list", coll);
 		assertEquals( f.iterate().next(), new Integer(12) );
 
 		f = s.createFilter( master.getDetails(), "select max(this.i) where this.i not in (:list) and this.master.name = :listy2" );
 		f.setParameterList("list", coll);
 		f.setParameter( "listy2", master.getName() );
 		assertEquals( f.iterate().next(), new Integer(12) );
 
 		iter = master.getDetails().iterator();
 		i=0;
 		while ( iter.hasNext() ) {
 			Detail d = (Detail) iter.next();
 			assertTrue( "master-detail", d.getMaster()==master );
 			s.delete(d);
 			i++;
 		}
 		assertTrue( "master-detail", i==2 );
 		s.delete(master);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testIncomingOutgoing() throws Exception {
 		Session s = openSession();
 		Master master1 = new Master();
 		Master master2 = new Master();
 		Master master3 = new Master();
 		s.save(master1);
 		s.save(master2);
 		s.save(master3);
 		master1.addIncoming(master2);
 		master2.addOutgoing(master1);
 		master1.addIncoming(master3);
 		master3.addOutgoing(master1);
 		Serializable m1id = s.getIdentifier(master1);
 		assertTrue( s.createFilter( master1.getIncoming(), "where this.id > 0 and this.name is not null" ).list().size()==2 );
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		master1 = (Master) s.load(Master.class, m1id);
 		Iterator iter = master1.getIncoming().iterator();
 		int i=0;
 		while ( iter.hasNext() ) {
 			Master m = (Master) iter.next();
 			assertTrue( "outgoing", m.getOutgoing().size()==1 );
 			assertTrue( "outgoing", m.getOutgoing().contains(master1) );
 			s.delete(m);
 			i++;
 		}
 		assertTrue( "incoming-outgoing", i==2 );
 		s.delete(master1);
 		s.flush();
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCascading() throws Exception {
 		Session s = openSession();
 		Detail d1 = new Detail();
 		Detail d2 = new Detail();
 		d2.setI(22);
 		Master m = new Master();
 		Master m0 = new Master();
 		Serializable m0id = s.save(m0);
 		m0.addDetail(d1); m0.addDetail(d2);
 		d1.setMaster(m0); d2.setMaster(m0);
 		m.getMoreDetails().add(d1);
 		m.getMoreDetails().add(d2);
 		Serializable mid = s.save(m);
 		s.flush();
 		s.connection().commit();
 		s.close();
 		s = openSession();
 		m = (Master) s.load(Master.class, mid);
 		assertTrue( "cascade save", m.getMoreDetails().size()==2 );
 		assertTrue( "cascade save", ( (Detail) m.getMoreDetails().iterator().next() ).getMaster().getDetails().size()==2 );
 
 		s.delete(m);
 		s.delete( s.load(Master.class, m0id) );
 
 		s.flush();
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNamedQuery() throws Exception {
 		Session s = openSession();
 		Query q = s.getNamedQuery("all_details");
 		q.list();
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testUpdateLazyCollections() throws Exception {
 		Session s = openSession();
 		Master m = new Master();
-		Serializable mid = s.save(m);
+		s.save( m );
 		Detail d1 = new Detail();
 		Detail d2 = new Detail();
 		d2.setX(14);
 		d1.setMaster(m);
 		d2.setMaster(m);
 		s.save(d1);
 		s.save(d2);
 		m.addDetail(d1);
 		m.addDetail(d2);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
-		m = (Master) s.load(Master.class, mid);
+		m = (Master) s.load( Master.class, m.getId() );
 		s.connection().commit();
 		s.close();
 		m.setName("New Name");
 		s = openSession();
-		s.update(m, mid);
+		s.update( m );
 		Iterator iter = m.getDetails().iterator();
 		int i=0;
 		while ( iter.hasNext() ) {
 			assertTrue( iter.next()!=null );
 			i++;
 		}
 		assertTrue(i==2);
 		iter = m.getDetails().iterator();
 		while ( iter.hasNext() ) s.delete( iter.next() );
 		s.delete(m);
 		s.flush();
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testMultiLevelCascade() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Detail detail = new Detail();
 		SubDetail subdetail = new SubDetail();
 		Master m = new Master();
 		Master m0 = new Master();
 		Serializable m0id = s.save(m0);
 		m0.addDetail(detail);
 		detail.setMaster(m0);
 		m.getMoreDetails().add(detail);
 		detail.setSubDetails( new HashSet() );
 		detail.getSubDetails().add(subdetail);
 		Serializable mid = s.save(m);
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		m = (Master) s.load( Master.class, mid );
 		assertTrue( ( (Detail) m.getMoreDetails().iterator().next() ).getSubDetails().size()!=0 );
 		s.delete(m);
 		assertTrue( s.createQuery( "from SubDetail" ).list().size()==0 );
 		assertTrue( s.createQuery( "from Detail d" ).list().size()==0 );
 		s.delete( s.load(Master.class, m0id) );
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testMixNativeAssigned() throws Exception {
 		Session s = openSession();
 		Category c = new Category();
 		c.setName("NAME");
 		Assignable assn = new Assignable();
 		assn.setId("i.d.");
 		List l = new ArrayList();
 		l.add(c);
 		assn.setCategories(l);
 		c.setAssignable(assn);
 		s.save(assn);
 		s.flush();
 		s.connection().commit();
 		s.close();
 		s = openSession();
 		s.delete(assn);
 		s.flush();
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionReplaceOnUpdate() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Category c = new Category();
 		List list = new ArrayList();
 		c.setSubcategories(list);
 		list.add( new Category() );
 		s.save(c);
 		t.commit();
 		s.close();
 		c.setSubcategories(list);
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update(c);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Category) s.load( Category.class, new Long( c.getId() ), LockMode.UPGRADE );
 		List list2 = c.getSubcategories();
 		t.commit();
 		s.close();
 
 		assertTrue( !Hibernate.isInitialized( c.getSubcategories() ) );
 
 		c.setSubcategories(list2);
 		s = openSession();
 		t = s.beginTransaction();
 		s.update(c);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Category) s.load( Category.class, new Long( c.getId() ), LockMode.UPGRADE );
 		assertTrue( c.getSubcategories().size()==1 );
 		s.delete(c);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionReplace2() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Category c = new Category();
 		List list = new ArrayList();
 		c.setSubcategories(list);
 		list.add( new Category() );
 		Category c2 = new Category();
 		s.save(c2);
 		s.save(c);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Category) s.load( Category.class, new Long( c.getId() ), LockMode.UPGRADE );
 		List list2 = c.getSubcategories();
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c2 = (Category) s.load( Category.class, new Long( c2.getId() ), LockMode.UPGRADE );
 		c2.setSubcategories(list2);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c2 = (Category) s.load( Category.class, new Long( c2.getId() ), LockMode.UPGRADE );
 		assertTrue( c2.getSubcategories().size()==1 );
 		s.delete(c2);
 		s.delete( s.load( Category.class, new Long( c.getId() ) ) );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionReplace() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Category c = new Category();
 		List list = new ArrayList();
 		c.setSubcategories(list);
 		list.add( new Category() );
 		s.save(c);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Category) s.load( Category.class, new Long( c.getId() ), LockMode.UPGRADE );
 		c.setSubcategories(list);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Category) s.load( Category.class, new Long( c.getId() ), LockMode.UPGRADE );
 		List list2 = c.getSubcategories();
 		t.commit();
 		s.close();
 
 		assertTrue( !Hibernate.isInitialized( c.getSubcategories() ) );
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Category) s.load( Category.class, new Long( c.getId() ), LockMode.UPGRADE );
 		c.setSubcategories(list2);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Category) s.load( Category.class, new Long( c.getId() ), LockMode.UPGRADE );
 		assertTrue( c.getSubcategories().size()==1 );
 		s.delete(c);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCategories() throws Exception {
 		Session s = openSession();
 		Category c = new Category();
 		c.setName(Category.ROOT_CATEGORY);
 		Category c1 = new Category();
 		Category c2 = new Category();
 		Category c3 = new Category();
 		c.getSubcategories().add(c1);
 		c.getSubcategories().add(c2);
 		c2.getSubcategories().add(null);
 		c2.getSubcategories().add(c3);
 		s.save(c);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		Transaction tx = s.beginTransaction();
 		s.lock(c, LockMode.UPGRADE);
 		Category loaded = (Category) s.load( Category.class, new Long( c3.getId() ) );
 		assertTrue( s.contains(c3) );
 		assertTrue(loaded==c3);
 		assertTrue( s.getCurrentLockMode(c3)==LockMode.NONE );
 		assertTrue( s.getCurrentLockMode(c)==LockMode.UPGRADE );
 		s.flush();
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		loaded = (Category) s.load( Category.class, new Long( c.getId() ) );
 		assertFalse( Hibernate.isInitialized( loaded.getSubcategories() ) );
 		s.connection().commit();
 		s.close();
 		s = openSession();
 		s.lock(loaded, LockMode.NONE);
 		assertTrue( loaded.getSubcategories().size()==2 );
 		s.connection().commit();
 		s.close();
 
 
 		s = openSession();
 		c = (Category) s.load( Category.class, new Long( c.getId() ) );
 		System.out.println( c.getSubcategories() );
 		assertTrue( c.getSubcategories().get(0)!=null && c.getSubcategories().get(1)!=null );
 		List list = ( (Category) c.getSubcategories().get(1) ).getSubcategories();
 		assertTrue( list.get(1)!=null && list.get(0)==null );
 
 		assertTrue(
 				s.createQuery( "from Category c where c.name = org.hibernate.test.legacy.Category.ROOT_CATEGORY" )
 						.iterate().hasNext()
 		);
 		s.delete(c);
 		s.flush();
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionRefresh() throws Exception {
 		Session s = openSession();
 		Category c = new Category();
 		List list = new ArrayList();
 		c.setSubcategories(list);
 		list.add( new Category() );
 		c.setName("root");
 		Serializable id = s.save(c);
 		s.flush();
 		s.connection().commit();
 		s.close();
 		s = openSession();
 		c = (Category) s.load(Category.class, id);
 		s.refresh(c);
 		s.flush();
 		assertTrue( c.getSubcategories().size()==1 );
 		s.flush();
 		s.connection().commit();
 		s.close();
 		s = openSession();
 		c = (Category) s.load(Category.class, id);
 		assertTrue( c.getSubcategories().size()==1 );
 		s.delete(c);
 		s.flush();
 		s.connection().commit();
 		s.close();
 	}
 
 	protected boolean isSerializableIsolationEnforced() throws Exception {
 		Connection conn = null;
 		try {
 			conn = sessionFactory().getConnectionProvider().getConnection();
 			return conn.getTransactionIsolation() >= Connection.TRANSACTION_SERIALIZABLE;
 		}
 		finally {
 			if ( conn != null ) {
 				try {
 					sessionFactory().getConnectionProvider().closeConnection( conn );
 				}
 				catch ( Throwable ignore ) {
 					// ignore...
 				}
 			}
 		}
 	}
 
 	@Test
 	public void testCachedCollectionRefresh() throws Exception {
 		if ( isSerializableIsolationEnforced() ) {
 			SkipLog.reportSkip( "SERIALIZABLE isolation", "cached collection refreshing" );
 			return;
 		}
 		Session s = openSession();
 		Category c = new Category();
 		List list = new ArrayList();
 		c.setSubcategories(list);
 		list.add( new Category() );
 		c.setName("root");
 		Serializable id = s.save(c);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		c = (Category) s.load(Category.class, id);
 		c.getSubcategories().size(); //force load and cache
 		s.connection().commit();
 		s.close();
 		
 		s = openSession();
 		if ( (getDialect() instanceof MySQLDialect) ) {
 			s.connection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
 		}
 		c = (Category) s.load(Category.class, id);
 		c.getSubcategories().size(); //force load
 
 		Session ss = openSession();
 		Category c2 = (Category) ss.load(Category.class, id);
 		ss.delete( c2.getSubcategories().get(0) );
 		c2.getSubcategories().clear();
 		ss.flush();
 		ss.connection().commit();
 		ss.close();
 
 		s.refresh(c);
 		assertTrue( c.getSubcategories().size()==0 );
 
 		ss = openSession();
 		c2 = (Category) ss.load(Category.class, id);
 		c2.getSubcategories().add( new Category() );
 		c2.getSubcategories().add( new Category() );
 		ss.flush();
 		ss.connection().commit();
 		ss.close();
 
 		s.refresh(c);
 		assertEquals( 2, c.getSubcategories().size() );
 
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		c = (Category) s.load(Category.class, id);
 		assertEquals( 2, c.getSubcategories().size() );
 		s.delete(c);
 		s.flush();
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCustomPersister() throws Exception {
 		Session s = openSession();
 		Custom c = new Custom();
 		c.setName( "foo" );
 		c.id="100";
 		String id = (String) s.save(c);
 		assertTrue( c==s.load(Custom.class, id) );
 		s.flush();
 		s.close();
 		s = openSession();
 		c = (Custom) s.load(Custom.class, id);
 		assertTrue( c.getName().equals("foo") );
 		c.setName( "bar" );
 		s.flush();
 		s.close();
 		s = openSession();
 		c = (Custom) s.load(Custom.class, id);
 		assertTrue( c.getName().equals("bar") );
 		s.delete(c);
 		s.flush();
 		s.close();
 		s = openSession();
 		boolean none = false;
 		try {
 			s.load(Custom.class, id);
 		}
 		catch (ObjectNotFoundException onfe) {
 			none=true;
 		}
 		assertTrue(none);
 		s.close();
 
 	}
 
 	@Test
 	public void testInterface() throws Exception {
 		Session s = openSession();
 		Serializable id = s.save( new BasicNameable() );
 		s.flush();
 		s.connection().commit();
 		s.close();
 		s = openSession();
 		Nameable n = (Nameable) s.load(Nameable.class, id);
 		s.delete(n);
 		s.flush();
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNoUpdateManyToOne() throws Exception {
 		Session s = openSession();
 		W w1 = new W();
 		W w2 = new W();
 		Z z = new Z();
 		z.setW(w1);
 		s.save(z);
 		s.flush();
 		z.setW(w2);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		s.update(z);
 		s.flush();
 		s.delete(z);
-		s.delete("from W");
+		for ( Object entity : s.createQuery( "from W" ).list() ) {
+			s.delete( entity );
+		}
 		s.flush();
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testQueuedBagAdds() throws Exception {
 		Session s = openSession();
 		Assignable a = new Assignable();
 		a.setId("foo");
 		a.setCategories( new ArrayList() );
 		Category c = new Category();
 		c.setAssignable(a);
 		a.getCategories().add(c);
 		s.save(a);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		sessionFactory().evictCollection("org.hibernate.test.legacy.Assignable.categories");
 
 		s = openSession();
 		a = (Assignable) s.get(Assignable.class, "foo");
 		c = new Category();
 		c.setAssignable(a);
 		a.getCategories().add(c);
 		assertFalse( Hibernate.isInitialized( a.getCategories() ) );
 		assertTrue( a.getCategories().size()==2 );
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		sessionFactory().evictCollection("org.hibernate.test.legacy.Assignable.categories");
 
 		s = openSession();
 		a = (Assignable) s.get(Assignable.class, "foo");
 		c = new Category();
 		c.setAssignable(a);
 		a.getCategories().add(c);
 		assertFalse( Hibernate.isInitialized( a.getCategories() ) );
 		s.flush();
 		assertFalse( Hibernate.isInitialized( a.getCategories() ) );
 		assertTrue( a.getCategories().size()==3 );
 		s.connection().commit();
 		s.close();
 
 		sessionFactory().evictCollection("org.hibernate.test.legacy.Assignable.categories");
 
 		s = openSession();
 		a = (Assignable) s.get(Assignable.class, "foo");
 		assertTrue( a.getCategories().size()==3 );
 		s.delete(a);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testPolymorphicCriteria() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Category f = new Category();
 		Single b = new Single();
 		b.setId("asdfa");
 		b.setString("asdfasdf");
 		s.save(f);
 		s.save(b);
 		List list = s.createCriteria(Object.class).list();
 		assertTrue( list.size()==2 );
 		assertTrue( list.contains(f) && list.contains(b) );
 		s.delete(f);
 		s.delete(b);
 		txn.commit();
 		s.close();
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/MultiTableTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/MultiTableTest.java
index 1e5c1d0e4c..bc09289efa 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/MultiTableTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/MultiTableTest.java
@@ -1,651 +1,652 @@
 //$Id: MultiTableTest.java 10977 2006-12-12 23:28:04Z steve.ebersole@jboss.com $
 package org.hibernate.test.legacy;
+
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
 import org.hibernate.Criteria;
 import org.hibernate.FetchMode;
 import org.hibernate.LockMode;
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 import org.hibernate.criterion.Restrictions;
 import org.hibernate.dialect.MySQLDialect;
 
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 
 public class MultiTableTest extends LegacyTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "legacy/Multi.hbm.xml", "legacy/MultiExtends.hbm.xml" };
 	}
 
 	@Test
 	public void testCriteria() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Lower l = new Lower();
 		s.save(l);
 		assertTrue( l==s.createCriteria(Top.class).uniqueResult() );
 		s.delete(l);
 		s.flush();
 		Criteria c = s.createCriteria(Lower.class);
 		c.createCriteria("yetanother")
 			.add( Restrictions.isNotNull("id") )
 			.createCriteria("another");
 		c.createCriteria("another").add( Restrictions.isNotNull("id") );
 		c.list();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testFetchOneToMany() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		s.createCriteria(Po.class).setFetchMode("set", FetchMode.JOIN).list();
 		s.createCriteria(Po.class).setFetchMode("list", FetchMode.JOIN).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNarrow() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery("from Po po, Lower low where low.mypo = po").list();
 		s.createQuery("from Po po join po.set as sm where sm.amount > 0").list();
 		s.createQuery("from Po po join po.top as low where low.foo = 'po'").list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testJoins() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Lower l join l.yetanother l2 where lower(l2.name) > 'a'" ).list();
 		s.createQuery( "from Lower l where lower(l.yetanother.top.name) > 'a'" ).list();
 		s.createQuery( "from SubMulti sm join sm.children smc where smc.name > 'a'" ).list();
 		s.createQuery( "select s, ya from Lower s join s.yetanother ya" ).list();
 		s.createQuery( "from Lower s1 join s1.bag s2" ).list();
 		s.createQuery( "from Lower s1 left join s1.bag s2" ).list();
 		s.createQuery( "select s, a from Lower s join s.another a" ).list();
 		s.createQuery( "select s, a from Lower s left join s.another a" ).list();
 		s.createQuery( "from Top s, Lower ls" ).list();
 		s.createQuery( "from Lower ls join ls.set s where s.name > 'a'" ).list();
 		s.createQuery( "from Po po join po.list sm where sm.name > 'a'" ).list();
 		s.createQuery( "from Lower ls inner join ls.another s where s.name is not null" ).list();
 		s.createQuery( "from Lower ls where ls.other.another.name is not null" ).list();
 		s.createQuery( "from Multi m where m.derived like 'F%'" ).list();
 		s.createQuery( "from SubMulti m where m.derived like 'F%'" ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSubclassCollection() throws Exception {
 		//if ( getDialect() instanceof HSQLDialect ) return; //TODO: figure out why!?
 		Session s = openSession();
 		s.beginTransaction();
 		SubMulti sm = new SubMulti();
 		SubMulti sm1 = new SubMulti();
 		SubMulti sm2 = new SubMulti();
 		ArrayList list = new ArrayList();
 		ArrayList anotherList = new ArrayList();
 		sm.setChildren(list);
 		sm.setMoreChildren(anotherList);
 		sm.setExtraProp("foo");
 		list.add(sm1);
 		list.add(sm2);
 		anotherList.add(sm1);
 		anotherList.add(sm2);
 		sm1.setParent(sm);
 		sm2.setParent(sm);
 		Serializable id = s.save(sm);
 		s.save(sm1);
 		s.save(sm2);
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().evict(SubMulti.class);
 
 		s = openSession();
 		s.beginTransaction();
 		s.connection().createStatement().executeQuery(
 			"select * from leafsubsubclass sm, nonleafsubclass m, rootclass s where sm.sid=m.sid and sm.sid=s.id1_ and sm.sid=1"
 		).next();
 		assertTrue(
 				s.createQuery(
 						"select s from SubMulti as sm join sm.children as s where s.amount>-1 and s.name is null"
 				).list().size()==2 );
 		s.createQuery( "select c from SubMulti sm join sm.children c" ).list();
 		assertTrue( s.createQuery( "select elements(sm.children) from SubMulti as sm" ).list().size()==2 );
 		assertTrue(
 				s.createQuery(
 						"select distinct sm from SubMulti as sm join sm.children as s where s.amount>-1 and s.name is null"
 				).list().size()==1 );
 		sm = (SubMulti) s.load(SubMulti.class, id);
 		assertTrue( sm.getChildren().size()==2 );
 		assertEquals(
 			s.createFilter( sm.getMoreChildren(), "select count(*) where this.amount>-1 and this.name is null" ).list().get(0),
 			new Long(2)
 		);
 		assertEquals( "FOO", sm.getDerived() );
 		assertSame(
 				s.createQuery( "select distinct s from SubMulti s where s.moreChildren[1].amount < 1.0" ).iterate().next(),
 			sm
 		);
 		assertTrue( sm.getMoreChildren().size()==2 );
 		s.delete(sm);
 		Iterator iter = sm.getChildren().iterator();
 		while ( iter.hasNext() ) {
 			s.delete( iter.next() );
 		}
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testCollectionOnly() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Mono m = new Mono();
 		Long id = (Long) s.save(m);
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
-		s.update(m, id);
+		s.update( m );
 		s.flush();
 		m.setAddress("foo bar");
 		s.flush();
 		s.delete(m);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testQueries() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Long id = ( Long ) s.save( new TrivialClass() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		TrivialClass tc = (TrivialClass) s.load(TrivialClass.class, id);
 		s.createQuery( "from TrivialClass s where s.id = 2" ).list();
 		s.createQuery( "select t.count from Top t" ).list();
 		s.createQuery( "from Lower s where s.another.name='name'" ).list();
 		s.createQuery( "from Lower s where s.yetanother.name='name'" ).list();
 		s.createQuery( "from Lower s where s.yetanother.name='name' and s.yetanother.foo is null" ).list();
 		s.createQuery( "from Top s where s.count=1" ).list();
 		s.createQuery( "select s.count from Top s, Lower ls where ls.another=s" ).list();
 		s.createQuery( "select elements(ls.bag), elements(ls.set) from Lower ls" ).list();
 		s.createQuery( "from Lower" ).iterate();
 		s.createQuery( "from Top" ).iterate();
 		s.delete(tc);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testConstraints() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		SubMulti sm = new SubMulti();
 		sm.setAmount(66.5f);
 		s.save( sm );
 		t.commit();
 		s.close();
 
 		s = openSession();
 //		doDelete( s, "from SubMulti" );
 //		t = s.beginTransaction();
 		t = s.beginTransaction();
 		doDelete( s, "from SubMulti" );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testMultiTable() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Multi multi = new Multi();
 		multi.setExtraProp("extra");
 		multi.setName("name");
 		Top simp = new Top();
 		simp.setDate( new Date() );
 		simp.setName("simp");
 
 		Serializable mid = s.save(multi);
 		Serializable sid = s.save(simp);
 
 		SubMulti sm = new SubMulti();
 		sm.setAmount(66.5f);
 		Serializable smid = s.save(sm);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		multi.setExtraProp( multi.getExtraProp() + "2" );
 		//multi.setCount( multi.getCount() + 1 );
 		multi.setName("new name");
-		s.update(multi, mid);
+		s.update( multi );
 		simp.setName("new name");
-		s.update(simp, sid);
+		s.update( simp );
 		sm.setAmount(456.7f);
-		s.update(sm, smid);
+		s.update( sm );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		multi = (Multi) s.load(Multi.class, mid);
 		assertTrue( multi.getExtraProp().equals("extra2") );
 		multi.setExtraProp( multi.getExtraProp() + "3" );
 		//multi.setCount( multi.getCount() + 1 );
 		assertTrue( multi.getName().equals("new name") );
 		multi.setName("newer name");
 		sm = (SubMulti) s.load(SubMulti.class, smid);
 		assertTrue( sm.getAmount()==456.7f );
 		sm.setAmount(23423f);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		multi = (Multi) s.load(Top.class, mid);
 		simp = (Top) s.load(Top.class, sid);
 		assertTrue( ! (simp instanceof Multi) );
 		assertTrue( multi.getExtraProp().equals("extra23") );
 		//multi.setCount( multi.getCount() + 1 );
 		assertTrue( multi.getName().equals("newer name") );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Iterator iter = s.createQuery( "select\n\nt from Top t where t.count>0" ).iterate();
 		boolean foundSimp = false;
 		boolean foundMulti = false;
 		boolean foundSubMulti = false;
 		while ( iter.hasNext() ) {
 			Object o = iter.next();
 			if ( ( o instanceof Top ) && !( o instanceof Multi) ) foundSimp = true;
 			if ( o instanceof Multi && !(o instanceof SubMulti) ) foundMulti = true;
 			if ( o instanceof SubMulti ) foundSubMulti = true;
 		}
 		assertTrue( foundSimp&&foundMulti&&foundSubMulti );
 		s.createQuery( "from Multi m where m.count>0 and m.extraProp is not null" ).list();
 		s.createQuery( "from Top m where m.count>0 and m.name is not null" ).list();
 		s.createQuery( "from Lower m where m.other is not null" ).list();
 		s.createQuery( "from Multi m where m.other.id = 1" ).list();
 		s.createQuery( "from SubMulti m where m.amount > 0.0" ).list();
 
 		assertTrue(
 				s.createQuery( "from Multi" ).list().size()==2
 		);
 		assertTrue(
 				s.createQuery( "from Multi m where m.class = SubMulti" ).list().size()==1
 		);
 		assertTrue(
 				s.createQuery( "from Top m where m.class = Multi" ).list().size()==1
 		);
 		assertTrue(
 				s.createQuery( "from Top" ).list().size()==3
 		);
 		assertTrue(
 				s.createQuery( "from Lower" ).list().size()==0
 		);
 		assertTrue(
 				s.createQuery( "from SubMulti" ).list().size()==1
 		);
 
 		s.createQuery( "from Lower ls join ls.bag s where s.id is not null" ).list();
 		s.createQuery( "from Lower ls join ls.set s where s.id is not null" ).list();
 		if ( !(getDialect() instanceof MySQLDialect) )
 			s.createQuery( "from SubMulti sm where exists elements(sm.children)" ).list();
 
 		List l = s.createCriteria(Top.class).list();
 		assertTrue( l.size()==3 );
 		assertTrue( s.createCriteria(SubMulti.class).list().size()==1 );
 		assertTrue(
 			s.createCriteria(SubMulti.class)
 				.add( Restrictions.lt("amount", new Float(0)) )
 				.list()
 				.size()==0
 		);
 		assertTrue(
 			s.createCriteria(SubMulti.class)
 				.add( Restrictions.ge("amount", new Float(0)) )
 				.list()
 				.size()==1
 		);
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		multi = (Multi) s.load(Top.class, mid, LockMode.UPGRADE);
 		simp = (Top) s.load(Top.class, sid);
 		s.lock(simp, LockMode.UPGRADE_NOWAIT);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		s.update(multi, mid);
+		s.update(multi);
 		s.delete(multi);
 		assertEquals( 2, doDelete( s, "from Top" ) );
 		t.commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testMultiTableGeneratedId() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Multi multi = new Multi();
 		multi.setExtraProp("extra");
 		//multi.setCount(666);
 		multi.setName("name");
 		Top simp = new Top();
 		simp.setDate( new Date() );
 		simp.setName("simp");
 		//simp.setCount(132);
 		Serializable multiId = s.save( multi );
 		Serializable simpId = s.save( simp );
 		SubMulti sm = new SubMulti();
 		sm.setAmount(66.5f);
 		Serializable smId = s.save( sm );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		multi.setExtraProp( multi.getExtraProp() + "2" );
 		//multi.setCount( multi.getCount() + 1 );
 		multi.setName("new name");
-		s.update( multi, multiId );
+		s.update( multi );
 		simp.setName("new name");
-		s.update( simp, simpId );
+		s.update( simp );
 		sm.setAmount(456.7f);
-		s.update( sm, smId );
+		s.update( sm );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		multi = (Multi) s.load( Multi.class, multiId );
 		assertTrue( multi.getExtraProp().equals("extra2") );
 		multi.setExtraProp( multi.getExtraProp() + "3" );
 		//multi.setCount( multi.getCount() + 1 );
 		assertTrue( multi.getName().equals("new name") );
 		multi.setName("newer name");
 		sm = (SubMulti) s.load( SubMulti.class, smId );
 		assertTrue( sm.getAmount()==456.7f );
 		sm.setAmount(23423f);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		multi = (Multi) s.load( Top.class, multiId );
 		simp = (Top) s.load( Top.class, simpId );
 		assertTrue( ! (simp instanceof Multi) );
 		assertTrue( multi.getExtraProp().equals("extra23") );
 		//multi.setCount( multi.getCount() + 1 );
 		assertTrue( multi.getName().equals("newer name") );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Iterator iter = s.createQuery( "select\n\nt from Top t where t.count>0" ).iterate();
 		boolean foundSimp = false;
 		boolean foundMulti = false;
 		boolean foundSubMulti = false;
 		while ( iter.hasNext() ) {
 			Object o = iter.next();
 			if ( ( o instanceof Top ) && !( o instanceof Multi) ) foundSimp = true;
 			if ( o instanceof Multi && !(o instanceof SubMulti) ) foundMulti = true;
 			if ( o instanceof SubMulti ) foundSubMulti = true;
 		}
 		assertTrue( foundSimp&&foundMulti&&foundSubMulti );
 		s.createQuery( "from Multi m where m.count>0 and m.extraProp is not null" ).list();
 		s.createQuery( "from Top m where m.count>0 and m.name is not null" ).list();
 		s.createQuery( "from Lower m where m.other is not null" ).list();
 		s.createQuery( "from Multi m where m.other.id = 1" ).list();
 		s.createQuery( "from SubMulti m where m.amount > 0.0" ).list();
 
 		assertTrue(
 				s.createQuery( "from Multi" ).list().size()==2
 		);
 		/*assertTrue(
 			s.find("from m in class Multi where m.class = Multi").size()==1
 		);*/
 		assertTrue(
 				s.createQuery( "from Top" ).list().size()==3
 		);
 		assertTrue(
 				s.createQuery( "from Lower" ).list().size()==0
 		);
 		assertTrue(
 				s.createQuery( "from SubMulti" ).list().size()==1
 		);
 
 		s.createQuery( "from Lower ls join ls.bag s where s.id is not null" ).list();
 		if ( !(getDialect() instanceof MySQLDialect) )
 			s.createQuery( "from SubMulti sm where exists elements(sm.children)" ).list();
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		multi = (Multi) s.load( Top.class, multiId, LockMode.UPGRADE );
 		simp = (Top) s.load( Top.class, simpId );
 		s.lock(simp, LockMode.UPGRADE_NOWAIT);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		s.update( multi, multiId );
+		s.update( multi );
 		s.delete(multi);
 		assertEquals( 2, doDelete( s, "from Top" ) );
 		t.commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testMultiTableCollections() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		assertTrue( s.createQuery( "from Top" ).list().size()==0 );
 		Multi multi = new Multi();
 		multi.setExtraProp("extra");
 		multi.setName("name");
 		Top simp = new Top();
 		simp.setDate( new Date() );
 		simp.setName("simp");
 
 		s.save(multi);
 		s.save(simp);
 
 		Lower ls = new Lower();
 		ls.setOther(ls);
 		ls.setAnother(ls);
 		ls.setYetanother(ls);
 		ls.setName("Less Simple");
 		Set set = new HashSet();
 		ls.setSet(set);
 		set.add(multi);
 		set.add(simp);
 		Serializable id = s.save(ls);
 		t.commit();
 		s.close();
 		assertTrue( ls.getOther()==ls && ls.getAnother()==ls && ls.getYetanother()==ls );
 
 		s = openSession();
 		t = s.beginTransaction();
 		ls = (Lower) s.load(Lower.class, id);
 		assertTrue( ls.getOther()==ls && ls.getAnother()==ls && ls.getYetanother()==ls );
 		assertTrue( ls.getSet().size()==2 );
 		Iterator iter = ls.getSet().iterator();
 		int foundMulti = 0;
 		int foundSimple = 0;
 		while ( iter.hasNext() ) {
 			Object o = iter.next();
 			if ( o instanceof Top ) foundSimple++;
 			if ( o instanceof Multi ) foundMulti++;
 		}
 		assertTrue( foundSimple==2 && foundMulti==1 );
 		assertEquals( 3, doDelete( s, "from Top" ) );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testMultiTableManyToOne() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		assertTrue( s.createQuery( "from Top" ).list().size()==0 );
 		Multi multi = new Multi();
 		multi.setExtraProp("extra");
 		multi.setName("name");
 		Top simp = new Top();
 		simp.setDate( new Date() );
 		simp.setName("simp");
 		s.save(multi);
 		Lower ls = new Lower();
 		ls.setOther(ls);
 		ls.setAnother(multi);
 		ls.setYetanother(ls);
 		ls.setName("Less Simple");
 		Serializable id = s.save(ls);
 		t.commit();
 		s.close();
 		assertTrue( ls.getOther()==ls && ls.getAnother()==multi && ls.getYetanother()==ls );
 
 		s = openSession();
 		t = s.beginTransaction();
 		ls = (Lower) s.load(Lower.class, id);
 		assertTrue( ls.getOther()==ls && ls.getYetanother()==ls );
 		assertTrue( ls.getAnother().getName().equals("name") && ls.getAnother() instanceof Multi );
 		s.delete(ls);
 		s.delete( ls.getAnother() );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testMultiTableNativeId() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Multi multi = new Multi();
 		multi.setExtraProp("extra");
 		Long id = (Long) s.save(multi);
 		assertTrue( id!=null );
 		s.delete(multi);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollection() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Multi multi1 = new Multi();
 		multi1.setExtraProp("extra1");
 		Multi multi2 = new Multi();
 		multi2.setExtraProp("extra2");
 		Po po = new Po();
 		multi1.setPo(po); multi2.setPo(po);
 		po.setSet( new HashSet() );
 		po.getSet().add(multi1);
 		po.getSet().add(multi2);
 		po.setList( new ArrayList() );
 		//po.getList().add(null);
 		po.getList().add( new SubMulti() );
 		Serializable id = s.save(po);
 		assertTrue( id!=null );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		po = (Po) s.load(Po.class, id);
 		assertTrue( po.getSet().size()==2 );
 		assertTrue( po.getList().size()==1 );
 		s.delete(po);
 		assertTrue( s.createQuery( "from Top" ).list().size()==0 );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testOneToOne() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Lower ls = new Lower();
 		Serializable id = s.save(ls);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.load(Lower.class, id);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( s.load(Lower.class, id) );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionPointer() throws Exception {
 		Session sess = openSession();
 		sess.beginTransaction();
 		Lower ls = new Lower();
 		List list = new ArrayList();
 		ls.setBag(list);
 		Top s = new Top();
 		Serializable id = sess.save(ls);
 		sess.save(s);
 		sess.flush();
 		list.add(s);
 		sess.getTransaction().commit();
 		sess.close();
 
 		sess = openSession();
 		sess.beginTransaction();
 		ls = (Lower) sess.load(Lower.class, id);
 		assertTrue( ls.getBag().size()==1 );
 		doDelete( sess, "from java.lang.Object" );
 		sess.getTransaction().commit();
 		sess.close();
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/ParentChildTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/ParentChildTest.java
index 6005ac3a61..0ae9dc18c7 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/ParentChildTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/ParentChildTest.java
@@ -1,1223 +1,1237 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
+
 import java.io.Serializable;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.Criteria;
 import org.hibernate.FetchMode;
 import org.hibernate.Hibernate;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.ReplicationMode;
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 import org.hibernate.criterion.Restrictions;
 import org.hibernate.dialect.DB2Dialect;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.IngresDialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.engine.EntityEntry;
 import org.hibernate.impl.SessionImpl;
 import org.hibernate.proxy.HibernateProxy;
 
 import org.junit.Test;
 
 import org.hibernate.testing.FailureExpected;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 
+@SuppressWarnings( {"UnnecessaryBoxing"})
 public class ParentChildTest extends LegacyTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 			"legacy/ParentChild.hbm.xml",
 			"legacy/FooBar.hbm.xml",
 		 	"legacy/Baz.hbm.xml",
 		 	"legacy/Qux.hbm.xml",
 		 	"legacy/Glarch.hbm.xml",
 		 	"legacy/Fum.hbm.xml",
 		 	"legacy/Fumm.hbm.xml",
 		 	"legacy/Fo.hbm.xml",
 		 	"legacy/One.hbm.xml",
 		 	"legacy/Many.hbm.xml",
 		 	"legacy/Immutable.hbm.xml",
 		 	"legacy/Fee.hbm.xml",
 		 	"legacy/Vetoer.hbm.xml",
 		 	"legacy/Holder.hbm.xml",
 		 	"legacy/Simple.hbm.xml",
 		 	"legacy/Container.hbm.xml",
 		 	"legacy/Circular.hbm.xml",
 		 	"legacy/Stuff.hbm.xml"
 		};
 	}
 
 	@Test
 	public void testReplicate() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Container baz = new Container();
 		Contained f = new Contained();
 		List list = new ArrayList();
 		list.add(baz);
 		f.setBag(list);
 		List list2 = new ArrayList();
 		list2.add(f);
 		baz.setBag(list2);
 		s.save(f);
 		s.save(baz);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.replicate(baz, ReplicationMode.OVERWRITE);
 		// HHH-2378
 		SessionImpl x = (SessionImpl)s;
 		EntityEntry entry = x.getPersistenceContext().getEntry( baz );
 		assertNull(entry.getVersion());
 		// ~~~~~~~
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.replicate(baz, ReplicationMode.IGNORE);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete(baz);
 		s.delete(f);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testQueryOneToOne() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Serializable id = s.save( new Parent() );
 		assertTrue( s.createQuery( "from Parent p left join fetch p.child" ).list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Parent p = (Parent) s.createQuery("from Parent p left join fetch p.child").uniqueResult();
 		assertTrue( p.getChild()==null );
 		s.createQuery( "from Parent p join p.child c where c.x > 0" ).list();
 		s.createQuery( "from Child c join c.parent p where p.x > 0" ).list();
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete( s.get(Parent.class, id) );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "unknown" )
 	public void testProxyReuse() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		FooProxy foo = new Foo();
 		FooProxy foo2 = new Foo();
 		Serializable id = s.save(foo);
 		Serializable id2 = s.save(foo2);
 		foo2.setInt(1234567);
 		foo.setInt(1234);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		foo = (FooProxy) s.load(Foo.class, id);
 		foo2 = (FooProxy) s.load(Foo.class, id2);
 		assertFalse( Hibernate.isInitialized(foo) );
 		Hibernate.initialize(foo2);
 		Hibernate.initialize(foo);
 		assertTrue( foo.getComponent().getImportantDates().length==4 );
 		assertTrue( foo2.getComponent().getImportantDates().length==4 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		foo.setFloat( new Float(1.2f) );
+		foo.setKey( "xyzid" );
+		foo.setFloat( new Float( 1.2f ) );
+		foo2.setKey( (String) id ); //intentionally id, not id2!
 		foo2.setFloat( new Float(1.3f) );
-		foo2.getDependent().setKey(null);
+		foo2.getDependent().setKey( null );
 		foo2.getComponent().getSubcomponent().getFee().setKey(null);
-		assertFalse( foo2.getKey().equals(id) );
-		s.save(foo, "xyzid");
-		s.update(foo2, id); //intentionally id, not id2!
+		assertFalse( foo2.getKey().equals( id ) );
+		s.save( foo );
+		s.update( foo2 );
 		assertEquals( foo2.getKey(), id );
 		assertTrue( foo2.getInt()==1234567 );
 		assertEquals( foo.getKey(), "xyzid" );
 		t.commit();
 		s.close();
 		
 		s = openSession();
 		t = s.beginTransaction();
 		foo = (FooProxy) s.load(Foo.class, id);
 		assertTrue( foo.getInt()==1234567 );
 		assertTrue( foo.getComponent().getImportantDates().length==4 );
 		String feekey = foo.getDependent().getKey();
 		String fookey = foo.getKey();
 		s.delete(foo);
 		s.delete( s.get(Foo.class, id2) );
 		s.delete( s.get(Foo.class, "xyzid") );
 // here is the issue (HHH-4092).  After the deletes above there are 2 Fees and a Glarch unexpectedly hanging around
 		assertEquals( 2, doDelete( s, "from java.lang.Object" ) );
 		t.commit();
 		s.close();
 		
 		//to account for new id rollback shit
 		foo.setKey(fookey);
 		foo.getDependent().setKey(feekey);
 		foo.getComponent().setGlarch(null);
 		foo.getComponent().setSubcomponent(null);
 		
 		s = openSession();
 		t = s.beginTransaction();
 		//foo.getComponent().setGlarch(null); //no id property!
 		s.replicate(foo, ReplicationMode.OVERWRITE);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Foo refoo = (Foo) s.get(Foo.class, id);
 		assertEquals( feekey, refoo.getDependent().getKey() );
 		s.delete(refoo);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testComplexCriteria() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		s.save(baz);
 		baz.setDefaults();
 		Map topGlarchez = new HashMap();
 		baz.setTopGlarchez(topGlarchez);
 		Glarch g1 = new Glarch();
 		g1.setName("g1");
 		s.save(g1);
 		Glarch g2 = new Glarch();
 		g2.setName("g2");
 		s.save(g2);
 		g1.setProxyArray( new GlarchProxy[] {g2} );
 		topGlarchez.put( new Character('1'),g1 );
 		topGlarchez.put( new Character('2'), g2);
 		Foo foo1 = new Foo();
 		Foo foo2 = new Foo();
 		s.save(foo1);
 		s.save(foo2);
 		baz.getFooSet().add(foo1);
 		baz.getFooSet().add(foo2);
 		baz.setFooArray( new FooProxy[] { foo1 } );
 
 		LockMode lockMode = (getDialect() instanceof DB2Dialect) ? LockMode.READ : LockMode.UPGRADE;
 
 		Criteria crit = s.createCriteria(Baz.class);
 		crit.createCriteria("topGlarchez")
 			.add( Restrictions.isNotNull("name") )
 			.createCriteria("proxyArray")
 				.add( Restrictions.eqProperty("name", "name") )
 				.add( Restrictions.eq("name", "g2") )
 				.add( Restrictions.gt("x", new Integer(-666) ) );
 		crit.createCriteria("fooSet")
 			.add( Restrictions.isNull("null") )
 			.add( Restrictions.eq("string", "a string") )
 			.add( Restrictions.lt("integer", new Integer(-665) ) );
 		crit.createCriteria("fooArray")
 				// this is the bit causing the problems; creating the criteria on fooArray does not add it to FROM,
 				// and so restriction below leads to an invalid reference.
 			.add( Restrictions.eq("string", "a string") )
 			.setLockMode(lockMode);
 
 		List list = crit.list();
 		assertTrue( list.size()==2 );
 		
 		s.createCriteria(Glarch.class).setLockMode(LockMode.UPGRADE).list();
 		s.createCriteria(Glarch.class).setLockMode(Criteria.ROOT_ALIAS, LockMode.UPGRADE).list();
 		
 		g2.setName(null);
 		t.commit();
 		s.close();
 		
 		s = openSession();
 		t = s.beginTransaction();
 		
 		list = s.createCriteria(Baz.class).add( Restrictions.isEmpty("fooSet") ).list();
 		assertEquals( list.size(), 0 );
 
 		list = s.createCriteria(Baz.class).add( Restrictions.isNotEmpty("fooSet") ).list();
 		assertEquals( new HashSet(list).size(), 1 );
 
 		list = s.createCriteria(Baz.class).add( Restrictions.sizeEq("fooSet", 2) ).list();
 		assertEquals( new HashSet(list).size(), 1 );
 		
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 
 		crit = s.createCriteria(Baz.class)
 			.setLockMode(lockMode);
 		crit.createCriteria("topGlarchez")
 			.add( Restrictions.gt( "x", new Integer(-666) ) );
 		crit.createCriteria("fooSet")
 			.add( Restrictions.isNull("null") );
 		list = crit.list();
 
 		assertTrue( list.size()==4 );
 		baz = (Baz) crit.uniqueResult();
 		assertTrue( Hibernate.isInitialized(baz.getTopGlarchez()) ); //cos it is nonlazy
 		assertTrue( !Hibernate.isInitialized(baz.getFooSet()) );
 
 		list = s.createCriteria(Baz.class)
 			.createCriteria("fooSet")
 				.createCriteria("foo")
 					.createCriteria("component.glarch")
 						.add( Restrictions.eq("name", "xxx") )
 			.list();
 		assertTrue( list.size()==0 );
 
 		list = s.createCriteria(Baz.class)
 			.createAlias("fooSet", "foo")
 			.createAlias("foo.foo", "foo2")
 			.setLockMode("foo2", lockMode)
 			.add( Restrictions.isNull("foo2.component.glarch") )
 			.createCriteria("foo2.component.glarch")
 				.add( Restrictions.eq("name", "xxx") )
 			.list();
 		assertTrue( list.size()==0 );
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 
 		crit = s.createCriteria(Baz.class);
 		crit.createCriteria("topGlarchez")
 			.add( Restrictions.isNotNull("name") );
 		crit.createCriteria("fooSet")
 			.add( Restrictions.isNull("null") );
 
 		list = crit.list();
 		assertTrue( list.size()==2 );
 		baz = (Baz) crit.uniqueResult();
 		assertTrue( Hibernate.isInitialized(baz.getTopGlarchez()) ); //cos it is nonlazy
 		assertTrue( !Hibernate.isInitialized(baz.getFooSet()) );
 		
 		s.createCriteria(Child.class).setFetchMode("parent", FetchMode.JOIN).list();
 
 		doDelete( s, "from Glarch g" );
 		s.delete( s.get(Foo.class, foo1.getKey() ) );
 		s.delete( s.get(Foo.class, foo2.getKey() ) );
 		s.delete(baz);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testArrayHQL() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		s.save(baz);
 		Foo foo1 = new Foo();
 		s.save(foo1);
 		baz.setFooArray( new FooProxy[] { foo1 } );
 
 		s.flush();
 		s.clear();
 
 		baz = ( Baz ) s.createQuery("from Baz b left join fetch b.fooArray").uniqueResult();
 		assertEquals( 1, baz.getFooArray().length );
 
 		t.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testArrayCriteria() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		s.save(baz);
 		Foo foo1 = new Foo();
 		s.save(foo1);
 		baz.setFooArray( new FooProxy[] { foo1 } );
 
 		s.flush();
 		s.clear();
 
 		baz = ( Baz ) s.createCriteria(Baz.class).createCriteria( "fooArray" ).uniqueResult();
 		assertEquals( 1, baz.getFooArray().length );
 
 		t.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testLazyManyToOneHQL() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		s.save(baz);
 		Foo foo1 = new Foo();
 		s.save(foo1);
 		baz.setFoo( foo1 );
 
 		s.flush();
 		s.clear();
 
 		baz = ( Baz ) s.createQuery("from Baz b").uniqueResult();
 		assertFalse( Hibernate.isInitialized( baz.getFoo() ) );
 		assertTrue( baz.getFoo() instanceof HibernateProxy );
 
 		t.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testLazyManyToOneCriteria() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		s.save(baz);
 		Foo foo1 = new Foo();
 		s.save(foo1);
 		baz.setFoo( foo1 );
 
 		s.flush();
 		s.clear();
 
 		baz = ( Baz ) s.createCriteria( Baz.class ).uniqueResult();
 		assertTrue( Hibernate.isInitialized( baz.getFoo() ) );
 		assertFalse( baz.getFoo() instanceof HibernateProxy );
 
 		t.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testLazyManyToOneGet() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		s.save(baz);
 		Foo foo1 = new Foo();
 		s.save(foo1);
 		baz.setFoo( foo1 );
 
 		s.flush();
 		s.clear();
 
 		baz = ( Baz ) s.get( Baz.class, baz.getCode() );
 		assertTrue( Hibernate.isInitialized( baz.getFoo() ) );
 		assertFalse( baz.getFoo() instanceof HibernateProxy );
 
 		t.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testClassWhere() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setParts( new ArrayList() );
 		Part p1 = new Part();
 		p1.setDescription("xyz");
 		Part p2 = new Part();
 		p2.setDescription("abc");
 		baz.getParts().add(p1);
 		baz.getParts().add(p2);
 		s.save(baz);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		assertTrue( s.createCriteria(Part.class).list().size()==1 ); //there is a where condition on Part mapping
 		assertTrue( s.createCriteria(Part.class).add( Restrictions.eq( "id", p1.getId() ) ).list().size()==1 );
 		assertTrue( s.createQuery("from Part").list().size()==1 );
 		assertTrue( s.createQuery("from Baz baz join baz.parts").list().size()==2 );
 		baz = (Baz) s.createCriteria(Baz.class).uniqueResult();
 		assertTrue( s.createFilter( baz.getParts(), "" ).list().size()==2 );
 		//assertTrue( baz.getParts().size()==1 );
 		s.delete( s.get( Part.class, p1.getId() ));
 		s.delete( s.get( Part.class, p2.getId() ));
 		s.delete(baz);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testClassWhereManyToMany() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setMoreParts( new ArrayList() );
 		Part p1 = new Part();
 		p1.setDescription("xyz");
 		Part p2 = new Part();
 		p2.setDescription("abc");
 		baz.getMoreParts().add(p1);
 		baz.getMoreParts().add(p2);
 		s.save(baz);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		assertTrue( s.createCriteria(Part.class).list().size()==1 ); //there is a where condition on Part mapping
 		assertTrue( s.createCriteria(Part.class).add( Restrictions.eq( "id", p1.getId() ) ).list().size()==1 );
 		assertTrue( s.createQuery("from Part").list().size()==1 );
 		assertTrue( s.createQuery("from Baz baz join baz.moreParts").list().size()==2 );
 		baz = (Baz) s.createCriteria(Baz.class).uniqueResult();
 		assertTrue( s.createFilter( baz.getMoreParts(), "" ).list().size()==2 );
 		//assertTrue( baz.getParts().size()==1 );
 		s.delete( s.get( Part.class, p1.getId() ));
 		s.delete( s.get( Part.class, p2.getId() ));
 		s.delete(baz);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionQuery() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
-		Simple s1 = new Simple();
+		Simple s1 = new Simple( Long.valueOf(1) );
 		s1.setName("s");
 		s1.setCount(0);
-		Simple s2 = new Simple();
+		Simple s2 = new Simple( Long.valueOf(2) );
 		s2.setCount(2);
-		Simple s3 = new Simple();
+		Simple s3 = new Simple( Long.valueOf(3) );
 		s3.setCount(3);
-		s.save( s1, new Long(1) ); s.save( s2, new Long(2) ); s.save( s3, new Long(3) );
+		s.save( s1 );
+		s.save( s2 );
+		s.save( s3 );
 		Container c = new Container();
 		Contained cd = new Contained();
 		List bag = new ArrayList();
 		bag.add(cd);
 		c.setBag(bag);
 		List l = new ArrayList();
 		l.add(s1);
 		l.add(s3);
 		l.add(s2);
 		c.setOneToMany(l);
 		l = new ArrayList();
 		l.add(s1);
 		l.add(null);
 		l.add(s2);
 		c.setManyToMany(l);
 		s.save(c);
 		Container cx = new Container();
 		s.save(cx);
-		Simple sx = new Simple();
+		Simple sx = new Simple( Long.valueOf(5) );
 		sx.setCount(5);
 		sx.setName("s");
-		s.save( sx, new Long(5) );
+		s.save( sx );
 		assertTrue(
 				s.createQuery( "select c from ContainerX c, Simple s where c.oneToMany[2] = s" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c, Simple s where c.manyToMany[2] = s" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c, Simple s where s = c.oneToMany[2]" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c, Simple s where s = c.manyToMany[2]" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c where c.oneToMany[0].name = 's'" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c where c.manyToMany[0].name = 's'" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c where 's' = c.oneToMany[2 - 2].name" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c where 's' = c.manyToMany[(3+1)/4-1].name" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c where c.oneToMany[ c.manyToMany[0].count ].name = 's'" )
 						.list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c where c.manyToMany[ c.oneToMany[0].count ].name = 's'" )
 						.list()
 						.size() == 1
 		);
 		if ( ! ( getDialect() instanceof MySQLDialect ) && !(getDialect() instanceof org.hibernate.dialect.TimesTenDialect) ) {
 			assertTrue(
 					s.createQuery( "select c from ContainerX c where c.manyToMany[ maxindex(c.manyToMany) ].count = 2" )
 							.list()
 							.size() == 1
 			);
 		}
 		assertTrue( s.contains(cd) );
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof HSQLDialect) )  {
 			s.createFilter( c.getBag(), "where 0 in elements(this.bag)" ).list();
 			s.createFilter( c.getBag(), "where 0 in elements(this.lazyBag)" ).list();
 		}
 		s.createQuery( "select count(comp.name) from ContainerX c join c.components comp" ).list();
 		s.delete(cd);
 		s.delete(c);
 		s.delete(s1);
 		s.delete(s2);
 		s.delete(s3);
 		s.delete(cx);
 		s.delete(sx);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testParentChild() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Parent p = new Parent();
 		Child c = new Child();
 		c.setParent(p);
 		p.setChild(c);
 		s.save(p);
 		s.save(c);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Child) s.load( Child.class, new Long( c.getId() ) );
 		p = c.getParent();
 		assertTrue( "1-1 parent", p!=null );
 		c.setCount(32);
 		p.setCount(66);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Child) s.load( Child.class, new Long( c.getId() ) );
 		p = c.getParent();
 		assertTrue( "1-1 update", p.getCount()==66 );
 		assertTrue( "1-1 update", c.getCount()==32 );
 		assertTrue(
 			"1-1 query",
 				s.createQuery( "from Child c where c.parent.count=66" ).list().size()==1
 		);
 		assertTrue(
 			"1-1 query",
 			( (Object[]) s.createQuery( "from Parent p join p.child c where p.count=66" ).list().get(0) ).length==2
 		);
 		s.createQuery( "select c, c.parent from Child c order by c.parent.count" ).list();
 		s.createQuery( "select c, c.parent from Child c where c.parent.count=66 order by c.parent.count" ).list();
 		s.createQuery( "select c, c.parent, c.parent.count from Child c order by c.parent.count" ).iterate();
 		List result = s.createQuery( "FROM Parent AS p WHERE p.count = ?" )
 				.setParameter( 0, new Integer(66), Hibernate.INTEGER )
 				.list();
 		assertEquals( "1-1 query", 1, result.size() );
 		s.delete(c); s.delete(p);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testParentNullChild() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Parent p = new Parent();
 		s.save(p);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = (Parent) s.load( Parent.class, new Long( p.getId() ) );
 		assertTrue( p.getChild()==null );
 		p.setCount(66);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = (Parent) s.load( Parent.class, new Long( p.getId() ) );
 		assertTrue( "null 1-1 update", p.getCount()==66 );
 		assertTrue( p.getChild()==null );
 		s.delete(p);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testManyToMany() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Container c = new Container();
 		c.setManyToMany( new ArrayList() );
 		c.setBag( new ArrayList() );
-		Simple s1 = new Simple();
-		Simple s2 = new Simple();
+		Simple s1 = new Simple( Long.valueOf(12) );
+		Simple s2 = new Simple( Long.valueOf(-1) );
 		s1.setCount(123); s2.setCount(654);
 		Contained c1 = new Contained();
 		c1.setBag( new ArrayList() );
 		c1.getBag().add(c);
 		c.getBag().add(c1);
 		c.getManyToMany().add(s1);
 		c.getManyToMany().add(s2);
-		Serializable cid = s.save(c); //s.save(c1);
-		s.save(s1, new Long(12) ); s.save(s2, new Long(-1) );
+		Serializable cid = s.save(c);
+		s.save( s1 );
+		s.save( s2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.load(Container.class, cid);
 		assertTrue( c.getBag().size()==1 );
 		assertTrue( c.getManyToMany().size()==2 );
 		c1 = (Contained) c.getBag().iterator().next();
 		assertTrue( c.getBag().size()==1 );
 		c.getBag().remove(c1);
 		c1.getBag().remove(c);
 		assertTrue( c.getManyToMany().remove(0)!=null );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.load(Container.class, cid);
 		assertTrue( c.getBag().size()==0 );
 		assertTrue( c.getManyToMany().size()==1 );
 		c1 = (Contained) s.load( Contained.class, new Long(c1.getId()) );
 		assertTrue( c1.getBag().size()==0 );
 		assertEquals( 1, doDelete( s, "from ContainerX c" ) );
 		assertEquals( 1, doDelete( s, "from Contained" ) );
 		assertEquals( 2, doDelete( s, "from Simple" ) );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testContainer() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Container c = new Container();
-		Simple x = new Simple(); x.setCount(123);
-		Simple y = new Simple(); y.setCount(456);
-		s.save( x, new Long(1) ); s.save( y, new Long(0) );
+		Simple x = new Simple( Long.valueOf(1) );
+		x.setCount(123);
+		Simple y = new Simple( Long.valueOf(0) );
+		y.setCount(456);
+		s.save( x );
+		s.save( y );
 		List o2m = new ArrayList();
 		o2m.add(x); o2m.add(null); o2m.add(y);
 		List m2m = new ArrayList();
 		m2m.add(x); m2m.add(null); m2m.add(y);
 		c.setOneToMany(o2m); c.setManyToMany(m2m);
 		List comps = new ArrayList();
 		Container.ContainerInnerClass ccic = new Container.ContainerInnerClass();
 		ccic.setName("foo");
 		ccic.setSimple(x);
 		comps.add(ccic);
 		comps.add(null);
 		ccic = new Container.ContainerInnerClass();
 		ccic.setName("bar");
 		ccic.setSimple(y);
 		comps.add(ccic);
 		HashSet compos = new HashSet();
 		compos.add(ccic);
 		c.setComposites(compos);
 		c.setComponents(comps);
 		One one = new One();
 		Many many = new Many();
 		HashSet manies = new HashSet();
 		manies.add(many);
 		one.setManies(manies);
 		many.setOne(one);
 		ccic.setMany(many);
 		ccic.setOne(one);
 		s.save(one);
 		s.save(many);
 		s.save(c);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Long count = (Long) s.createQuery("select count(*) from ContainerX as c join c.components as ce join ce.simple as s where ce.name='foo'").uniqueResult();
 		assertTrue( count.intValue()==1 );
 		List res = s.createQuery(
 				"select c, s from ContainerX as c join c.components as ce join ce.simple as s where ce.name='foo'"
 		).list();
 		assertTrue(res.size()==1);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.load( Container.class, new Long( c.getId() ) );
 		System.out.println( c.getOneToMany() );
 		System.out.println( c.getManyToMany() );
 		System.out.println( c.getComponents() );
 		System.out.println( c.getComposites() );
 		ccic = (Container.ContainerInnerClass) c.getComponents().get(2);
 		assertTrue( ccic.getMany().getOne()==ccic.getOne() );
 		assertTrue( c.getComponents().size()==3 );
 		assertTrue( c.getComposites().size()==1 );
 		assertTrue( c.getOneToMany().size()==3 );
 		assertTrue( c.getManyToMany().size()==3 );
 		assertTrue( c.getOneToMany().get(0)!=null );
 		assertTrue( c.getOneToMany().get(2)!=null );
 		for ( int i=0; i<3; i++ ) {
 			assertTrue( c.getManyToMany().get(i) == c.getOneToMany().get(i) );
 		}
 		Object o1 = c.getOneToMany().get(0);
 		Object o2 = c.getOneToMany().remove(2);
 		c.getOneToMany().set(0, o2);
 		c.getOneToMany().set(1, o1);
 		o1 = c.getComponents().remove(2);
 		c.getComponents().set(0, o1);
 		c.getManyToMany().set( 0, c.getManyToMany().get(2) );
 		Container.ContainerInnerClass ccic2 = new Container.ContainerInnerClass();
 		ccic2.setName("foo");
 		ccic2.setOne(one);
 		ccic2.setMany(many);
 		ccic2.setSimple( (Simple) s.load(Simple.class, new Long(0) ) );
 		c.getComposites().add(ccic2);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.load( Container.class, new Long( c.getId() ) );
 		System.out.println( c.getOneToMany() );
 		System.out.println( c.getManyToMany() );
 		System.out.println( c.getComponents() );
 		System.out.println( c.getComposites() );
 		assertTrue( c.getComponents().size()==1 ); //WAS: 2
 		assertTrue( c.getComposites().size()==2 );
 		assertTrue( c.getOneToMany().size()==2 );
 		assertTrue( c.getManyToMany().size()==3 );
 		assertTrue( c.getOneToMany().get(0)!=null );
 		assertTrue( c.getOneToMany().get(1)!=null );
 		( (Container.ContainerInnerClass) c.getComponents().get(0) ).setName("a different name");
 		( (Container.ContainerInnerClass) c.getComposites().iterator().next() ).setName("once again");
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.load( Container.class, new Long( c.getId() ) );
 		System.out.println( c.getOneToMany() );
 		System.out.println( c.getManyToMany() );
 		System.out.println( c.getComponents() );
 		System.out.println( c.getComposites() );
 		assertTrue( c.getComponents().size()==1 ); //WAS: 2
 		assertTrue( c.getComposites().size()==2 );
 		assertTrue( ( (Container.ContainerInnerClass) c.getComponents().get(0) ).getName().equals("a different name") );
 		Iterator iter = c.getComposites().iterator();
 		boolean found = false;
 		while ( iter.hasNext() ) {
 			if ( ( (Container.ContainerInnerClass) iter.next() ).getName().equals("once again") ) found = true;
 		}
 		assertTrue(found);
 		c.getOneToMany().clear();
 		c.getManyToMany().clear();
 		c.getComposites().clear();
 		c.getComponents().clear();
 		doDelete( s, "from Simple" );
 		doDelete( s, "from Many" );
 		doDelete( s, "from One" );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.load( Container.class, new Long( c.getId() ) );
 		assertTrue( c.getComponents().size()==0 );
 		assertTrue( c.getComposites().size()==0 );
 		assertTrue( c.getOneToMany().size()==0 );
 		assertTrue( c.getManyToMany().size()==0 );
 		s.delete(c);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCascadeCompositeElements() throws Exception {
 		Container c = new Container();
 		List list = new ArrayList();
 		c.setCascades(list);
 		Container.ContainerInnerClass cic = new Container.ContainerInnerClass();
 		cic.setMany( new Many() );
 		cic.setOne( new One() );
 		list.add(cic);
 		Session s = openSession();
 		s.beginTransaction();
 		s.save(c);
 		s.getTransaction().commit();
 		s.close();
 		
 		s=openSession();
 		s.beginTransaction();
 		c = (Container) s.createQuery( "from ContainerX c" ).iterate().next();
 		cic = (Container.ContainerInnerClass) c.getCascades().iterator().next();
 		assertTrue( cic.getMany()!=null && cic.getOne()!=null );
 		assertTrue( c.getCascades().size()==1 );
 		s.delete(c);
 		s.getTransaction().commit();
 		s.close();
 
 		c = new Container();
 		s = openSession();
 		s.beginTransaction();
 		s.save(c);
 		list = new ArrayList();
 		c.setCascades(list);
 		cic = new Container.ContainerInnerClass();
 		cic.setMany( new Many() );
 		cic.setOne( new One() );
 		list.add(cic);
 		s.getTransaction().commit();
 		s.close();
 		
 		s=openSession();
 		s.beginTransaction();
 		c = (Container) s.createQuery( "from ContainerX c" ).iterate().next();
 		cic = (Container.ContainerInnerClass) c.getCascades().iterator().next();
 		assertTrue( cic.getMany()!=null && cic.getOne()!=null );
 		assertTrue( c.getCascades().size()==1 );
 		s.delete(c);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testBag() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Container c = new Container();
 		Contained c1 = new Contained();
 		Contained c2 = new Contained();
 		c.setBag( new ArrayList() );
 		c.getBag().add(c1);
 		c.getBag().add(c2);
 		c1.getBag().add(c);
 		c2.getBag().add(c);
 		s.save(c);
 		c.getBag().add(c2);
 		c2.getBag().add(c);
 		c.getLazyBag().add(c1);
 		c1.getLazyBag().add(c);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.createQuery( "from ContainerX c" ).list().get(0);
 		c.getLazyBag().size();
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.createQuery( "from ContainerX c" ).list().get(0);
 		Contained c3 = new Contained();
 		//c.getBag().add(c3);
 		//c3.getBag().add(c);
 		c.getLazyBag().add(c3);
 		c3.getLazyBag().add(c);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.createQuery( "from ContainerX c" ).list().get(0);
 		Contained c4 = new Contained();
 		c.getLazyBag().add(c4);
 		c4.getLazyBag().add(c);
 		assertTrue( c.getLazyBag().size()==3 ); //forces initialization
 		//s.save(c4);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.createQuery( "from ContainerX c" ).list().get(0);
 		Iterator i = c.getBag().iterator();
 		int j=0;
 		while ( i.hasNext() ) {
 			assertTrue( i.next()!=null );
 			j++;
 		}
 		assertTrue(j==3);
 		assertTrue( c.getLazyBag().size()==3 );
 		s.delete(c);
 		c.getBag().remove(c2);
 		Iterator iter = c.getBag().iterator();
 		j=0;
 		while ( iter.hasNext() ) {
 			j++;
 			s.delete( iter.next() );
 		}
 		assertTrue(j==2);
 		s.delete( s.load(Contained.class, new Long( c4.getId() ) ) );
 		s.delete( s.load(Contained.class, new Long( c3.getId() ) ) );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCircularCascade() throws Exception {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Circular c = new Circular();
 		c.setClazz(Circular.class);
 		c.setOther( new Circular() );
 		c.getOther().setOther( new Circular() );
 		c.getOther().getOther().setOther(c);
 		c.setAnyEntity( c.getOther() );
 		String id = (String) s.save(c);
 		tx.commit();
 		s.close();
 		s = openSession();
 		tx = s.beginTransaction();
 		c = (Circular) s.load(Circular.class, id);
 		c.getOther().getOther().setClazz(Foo.class);
 		tx.commit();
 		s.close();
 		c.getOther().setClazz(Qux.class);
 		s = openSession();
 		tx = s.beginTransaction();
 		s.saveOrUpdate(c);
 		tx.commit();
 		s.close();
 		c.getOther().getOther().setClazz(Bar.class);
 		s = openSession();
 		tx = s.beginTransaction();
 		s.saveOrUpdate(c);
 		tx.commit();
 		s.close();
 		s = openSession();
 		tx = s.beginTransaction();
 		c = (Circular) s.load(Circular.class, id);
 		assertTrue( c.getOther().getOther().getClazz()==Bar.class);
 		assertTrue( c.getOther().getClazz()==Qux.class);
 		assertTrue( c.getOther().getOther().getOther()==c);
 		assertTrue( c.getAnyEntity()==c.getOther() );
 		assertEquals( 3, doDelete( s, "from Universe" ) );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testDeleteEmpty() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		assertEquals( 0, doDelete( s, "from Simple" ) );
 		assertEquals( 0, doDelete( s, "from Universe" ) );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testLocking() throws Exception {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
-		Simple s1 = new Simple(); s1.setCount(1);
-		Simple s2 = new Simple(); s2.setCount(2);
-		Simple s3 = new Simple(); s3.setCount(3);
-		Simple s4 = new Simple(); s4.setCount(4);
-		s.save(s1, new Long(1) );
-		s.save(s2, new Long(2) );
-		s.save(s3, new Long(3) );
-		s.save(s4, new Long(4) );
+		Simple s1 = new Simple( Long.valueOf(1) );
+		s1.setCount(1);
+		Simple s2 = new Simple( Long.valueOf(2) );
+		s2.setCount(2);
+		Simple s3 = new Simple( Long.valueOf(3) );
+		s3.setCount(3);
+		Simple s4 = new Simple( Long.valueOf(4) );
+		s4.setCount(4);
+		s.save( s1 );
+		s.save( s2 );
+		s.save( s3 );
+		s.save( s4 );
 		assertTrue( s.getCurrentLockMode(s1)==LockMode.WRITE );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s1 = (Simple) s.load(Simple.class, new Long(1), LockMode.NONE);
 		assertTrue( s.getCurrentLockMode(s1)==LockMode.READ || s.getCurrentLockMode(s1)==LockMode.NONE ); //depends if cache is enabled
 		s2 = (Simple) s.load(Simple.class, new Long(2), LockMode.READ);
 		assertTrue( s.getCurrentLockMode(s2)==LockMode.READ );
 		s3 = (Simple) s.load(Simple.class, new Long(3), LockMode.UPGRADE);
 		assertTrue( s.getCurrentLockMode(s3)==LockMode.UPGRADE );
 		s4 = (Simple) s.get(Simple.class, new Long(4), LockMode.UPGRADE_NOWAIT);
 		assertTrue( s.getCurrentLockMode(s4)==LockMode.UPGRADE_NOWAIT );
 
 		s1 = (Simple) s.load(Simple.class, new Long(1), LockMode.UPGRADE); //upgrade
 		assertTrue( s.getCurrentLockMode(s1)==LockMode.UPGRADE );
 		s2 = (Simple) s.load(Simple.class, new Long(2), LockMode.NONE);
 		assertTrue( s.getCurrentLockMode(s2)==LockMode.READ );
 		s3 = (Simple) s.load(Simple.class, new Long(3), LockMode.READ);
 		assertTrue( s.getCurrentLockMode(s3)==LockMode.UPGRADE );
 		s4 = (Simple) s.load(Simple.class, new Long(4), LockMode.UPGRADE);
 		assertTrue( s.getCurrentLockMode(s4)==LockMode.UPGRADE_NOWAIT );
 
 		s.lock(s2, LockMode.UPGRADE); //upgrade
 		assertTrue( s.getCurrentLockMode(s2)==LockMode.UPGRADE );
 		s.lock(s3, LockMode.UPGRADE);
 		assertTrue( s.getCurrentLockMode(s3)==LockMode.UPGRADE );
 		s.lock(s1, LockMode.UPGRADE_NOWAIT);
 		s.lock(s4, LockMode.NONE);
 		assertTrue( s.getCurrentLockMode(s4)==LockMode.UPGRADE_NOWAIT );
 
 		tx.commit();
 		tx = s.beginTransaction();
 
 		assertTrue( s.getCurrentLockMode(s3)==LockMode.NONE );
 		assertTrue( s.getCurrentLockMode(s1)==LockMode.NONE );
 		assertTrue( s.getCurrentLockMode(s2)==LockMode.NONE );
 		assertTrue( s.getCurrentLockMode(s4)==LockMode.NONE );
 
 		s.lock(s1, LockMode.READ); //upgrade
 		assertTrue( s.getCurrentLockMode(s1)==LockMode.READ );
 		s.lock(s2, LockMode.UPGRADE); //upgrade
 		assertTrue( s.getCurrentLockMode(s2)==LockMode.UPGRADE );
 		s.lock(s3, LockMode.UPGRADE_NOWAIT); //upgrade
 		assertTrue( s.getCurrentLockMode(s3)==LockMode.UPGRADE_NOWAIT );
 		s.lock(s4, LockMode.NONE);
 		assertTrue( s.getCurrentLockMode(s4)==LockMode.NONE );
 
 		s4.setName("s4");
 		s.flush();
 		assertTrue( s.getCurrentLockMode(s4)==LockMode.WRITE );
 		tx.commit();
 
 		tx = s.beginTransaction();
 
 		assertTrue( s.getCurrentLockMode(s3)==LockMode.NONE );
 		assertTrue( s.getCurrentLockMode(s1)==LockMode.NONE );
 		assertTrue( s.getCurrentLockMode(s2)==LockMode.NONE );
 		assertTrue( s.getCurrentLockMode(s4)==LockMode.NONE );
 
 		s.delete(s1); s.delete(s2); s.delete(s3); s.delete(s4);
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testObjectType() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Parent g = new Parent();
 		Foo foo = new Foo();
 		g.setAny(foo);
 		s.save(g);
 		s.save(foo);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (Parent) s.load( Parent.class, new Long( g.getId() ) );
 		assertTrue( g.getAny()!=null && g.getAny() instanceof FooProxy );
 		s.delete( g.getAny() );
 		s.delete(g);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testLoadAfterNonExists() throws HibernateException, SQLException {
 		Session session = openSession();
 		if ( ( getDialect() instanceof MySQLDialect ) || ( getDialect() instanceof IngresDialect ) ) {
 			session.connection().setTransactionIsolation( Connection.TRANSACTION_READ_COMMITTED );
 		}
 		session.getTransaction().begin();
 
 		// First, prime the fixture session to think the entity does not exist
 		try {
 			session.load( Simple.class, new Long(-1) );
 			fail();
 		}
 		catch(ObjectNotFoundException onfe) {
 			// this is correct
 		}
 
 		// Next, lets create that entity "under the covers"
 		Session anotherSession = sessionFactory().openSession();
 		anotherSession.beginTransaction();
-		Simple myNewSimple = new Simple();
+		Simple myNewSimple = new Simple( Long.valueOf(-1) );
 		myNewSimple.setName("My under the radar Simple entity");
 		myNewSimple.setAddress("SessionCacheTest.testLoadAfterNonExists");
 		myNewSimple.setCount(1);
 		myNewSimple.setDate( new Date() );
-		myNewSimple.setPay( new Float(100000000) );
-		anotherSession.save( myNewSimple, new Long(-1) );
+		myNewSimple.setPay( Float.valueOf( 100000000 ) );
+		anotherSession.save( myNewSimple );
 		anotherSession.getTransaction().commit();
 		anotherSession.close();
 
 		// Now, lets make sure the original session can see the created row...
 		session.clear();
 		try {
-			Simple dummy = (Simple) session.get( Simple.class, new Long(-1) );
+			Simple dummy = (Simple) session.get( Simple.class, Long.valueOf(-1) );
 			assertNotNull("Unable to locate entity Simple with id = -1", dummy);
 			session.delete( dummy );
 		}
 		catch(ObjectNotFoundException onfe) {
 			fail("Unable to locate entity Simple with id = -1");
 		}
 		session.getTransaction().commit();
 		session.close();
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/QueryByExampleTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/QueryByExampleTest.java
index 6df42fe9bc..8e908bcee0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/QueryByExampleTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/QueryByExampleTest.java
@@ -1,154 +1,156 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
 import java.util.List;
 
 import org.hibernate.Criteria;
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 import org.hibernate.criterion.Example;
 import org.hibernate.criterion.Restrictions;
 
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 
 /**
  * Query by example test to allow nested components
  *
  * @author Emmanuel Bernard
  */
 public class QueryByExampleTest extends LegacyTestCase {
 	@Override
     public String[] getMappings() {
         return new String[] { "legacy/Componentizable.hbm.xml" };
     }
 
 	@Test
     public void testSimpleQBE() throws Exception {
     	deleteData();
         initData();
 
         Session s = openSession();
 
         Transaction t = s.beginTransaction();
         Componentizable master = getMaster("hibernate", "open sourc%", "open source1");
         Criteria crit = s.createCriteria(Componentizable.class);
         Example ex = Example.create(master).enableLike();
         crit.add(ex);
         List result = crit.list();
         assertNotNull(result);
         assertEquals(1, result.size());
 
         t.commit();
         s.close();
     }
 
 	@Test
     public void testJunctionNotExpressionQBE() throws Exception {
         deleteData();
         initData();
         Session s = openSession();
         Transaction t = s.beginTransaction();
         Componentizable master = getMaster("hibernate", null, "ope%");
         Criteria crit = s.createCriteria(Componentizable.class);
         Example ex = Example.create(master).enableLike();
 
         crit.add(Restrictions.or(Restrictions.not(ex), ex));
 
         List result = crit.list();
         assertNotNull(result);
         assertEquals(2, result.size());
         t.commit();
         s.close();
 
     }
 
 	@Test
     public void testExcludingQBE() throws Exception {
         deleteData();
         initData();
         Session s = openSession();
         Transaction t = s.beginTransaction();
         Componentizable master = getMaster("hibernate", null, "ope%");
         Criteria crit = s.createCriteria(Componentizable.class);
         Example ex = Example.create(master).enableLike()
             .excludeProperty("component.subComponent");
         crit.add(ex);
         List result = crit.list();
         assertNotNull(result);
         assertEquals(3, result.size());
 
         master = getMaster("hibernate", "ORM tool", "fake stuff");
         crit = s.createCriteria(Componentizable.class);
         ex = Example.create(master).enableLike()
             .excludeProperty("component.subComponent.subName1");
         crit.add(ex);
         result = crit.list();
         assertNotNull(result);
         assertEquals(1, result.size());
         t.commit();
         s.close();
 
 
     }
 
     private void initData() throws Exception {
         Session s = openSession();
         Transaction t = s.beginTransaction();
         Componentizable master = getMaster("hibernate", "ORM tool", "ORM tool1");
         s.saveOrUpdate(master);
         master = getMaster("hibernate", "open source", "open source1");
         s.saveOrUpdate(master);
         master = getMaster("hibernate", null, null);
         s.saveOrUpdate(master);
         t.commit();
         s.close();
     }
 
     private void deleteData() throws Exception {
     	Session s = openSession();
         Transaction t = s.beginTransaction();
-        s.delete("from Componentizable");
+		for ( Object entity : s.createQuery( "from Componentizable" ).list() ) {
+			s.delete( entity );
+		}
         t.commit();
         s.close();
     }
 
     private Componentizable getMaster(String name, String subname, String subname1) {
         Componentizable master = new Componentizable();
         if (name != null) {
             Component masterComp = new Component();
             masterComp.setName(name);
             if (subname != null || subname1 != null) {
                 SubComponent subComponent = new SubComponent();
                 subComponent.setSubName(subname);
                 subComponent.setSubName1(subname1);
                 masterComp.setSubComponent(subComponent);
             }
             master.setComponent(masterComp);
         }
         return master;
     }
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLFunctionsTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLFunctionsTest.java
index 1c55ce5f56..eb7d8c921d 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLFunctionsTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLFunctionsTest.java
@@ -1,697 +1,701 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
-import static org.hibernate.testing.TestLogger.LOG;
+
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.hibernate.Query;
 import org.hibernate.ScrollableResults;
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 import org.hibernate.dialect.DB2Dialect;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.InterbaseDialect;
 import org.hibernate.dialect.MckoiDialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.Oracle9iDialect;
 import org.hibernate.dialect.SQLServerDialect;
 import org.hibernate.dialect.Sybase11Dialect;
 import org.hibernate.dialect.SybaseASE15Dialect;
 import org.hibernate.dialect.SybaseAnywhereDialect;
 import org.hibernate.dialect.SybaseDialect;
 import org.hibernate.dialect.TimesTenDialect;
 import org.hibernate.dialect.function.SQLFunction;
 
 import org.junit.Test;
 
+import static org.hibernate.testing.TestLogger.LOG;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 
+@SuppressWarnings( {"UnnecessaryUnboxing", "UnnecessaryBoxing"})
 public class SQLFunctionsTest extends LegacyTestCase {
 	private static final Logger log = LoggerFactory.getLogger(SQLFunctionsTest.class);
 
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 			"legacy/AltSimple.hbm.xml",
 			"legacy/Broken.hbm.xml",
 			"legacy/Blobber.hbm.xml"
 		};
 	}
 
 	@Test
 	public void testDialectSQLFunctions() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Iterator iter = s.createQuery( "select max(s.count) from Simple s" ).iterate();
 
 		if ( getDialect() instanceof MySQLDialect ) assertTrue( iter.hasNext() && iter.next()==null );
 
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple Dialect Function Test");
 		simple.setAddress("Simple Address");
-		simple.setPay(new Float(45.8));
+		simple.setPay( Float.valueOf(45.8f) );
 		simple.setCount(2);
-		s.save(simple, new Long(10) );
+		s.save( simple );
 
 		// Test to make sure allocating an specified object operates correctly.
 		assertTrue(
 				s.createQuery( "select new org.hibernate.test.legacy.S(s.count, s.address) from Simple s" ).list().size() == 1
 		);
 
 		// Quick check the base dialect functions operate correctly
 		assertTrue(
 				s.createQuery( "select max(s.count) from Simple s" ).list().size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select count(*) from Simple s" ).list().size() == 1
 		);
 
 		if ( getDialect() instanceof Oracle9iDialect ) {
 			// Check Oracle Dialect mix of dialect functions - no args (no parenthesis and single arg functions
 			List rset = s.createQuery( "select s.name, sysdate(), trunc(s.pay), round(s.pay) from Simple s" ).list();
 			assertNotNull("Name string should have been returned",(((Object[])rset.get(0))[0]));
 			assertNotNull("Todays Date should have been returned",(((Object[])rset.get(0))[1]));
-			assertEquals("trunc(45.8) result was incorrect ", new Float(45), ( (Object[]) rset.get(0) )[2] );
-			assertEquals("round(45.8) result was incorrect ", new Float(46), ( (Object[]) rset.get(0) )[3] );
+			assertEquals("trunc(45.8) result was incorrect ", Float.valueOf(45), ( (Object[]) rset.get(0) )[2] );
+			assertEquals("round(45.8) result was incorrect ", Float.valueOf(46), ( (Object[]) rset.get(0) )[3] );
 
 			simple.setPay(new Float(-45.8));
 			s.update(simple);
 
 			// Test type conversions while using nested functions (Float to Int).
 			rset = s.createQuery( "select abs(round(s.pay)) from Simple s" ).list();
-			assertEquals("abs(round(-45.8)) result was incorrect ", new Float(46), rset.get(0));
+			assertEquals("abs(round(-45.8)) result was incorrect ", Float.valueOf( 46 ), rset.get(0));
 
 			// Test a larger depth 3 function example - Not a useful combo other than for testing
 			assertTrue(
 					s.createQuery( "select trunc(round(sysdate())) from Simple s" ).list().size() == 1
 			);
 
 			// Test the oracle standard NVL funtion as a test of multi-param functions...
 			simple.setPay(null);
 			s.update(simple);
 			Integer value = (Integer) s.createQuery(
 					"select MOD( NVL(s.pay, 5000), 2 ) from Simple as s where s.id = 10"
 			).list()
 					.get(0);
 			assertTrue( 0 == value.intValue() );
 		}
 
 		if ( (getDialect() instanceof HSQLDialect) ) {
 			// Test the hsql standard MOD funtion as a test of multi-param functions...
 			Integer value = (Integer) s.createQuery( "select MOD(s.count, 2) from Simple as s where s.id = 10" )
 					.list()
 					.get(0);
 			assertTrue( 0 == value.intValue() );
 		}
 
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSetProperties() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
-		s.save(simple, new Long(10) );
+		s.save( simple );
 		Query q = s.createQuery("from Simple s where s.name=:name and s.count=:count");
 		q.setProperties(simple);
 		assertTrue( q.list().get(0)==simple );
 		//misuse of "Single" as a propertyobject, but it was the first testclass i found with a collection ;)
 		Single single = new Single() { // trivial hack to test properties with arrays.
 			String[] getStuff() { return (String[]) getSeveral().toArray(new String[getSeveral().size()]); }
 		};
 
 		List l = new ArrayList();
 		l.add("Simple 1");
 		l.add("Slimeball");
 		single.setSeveral(l);
 		q = s.createQuery("from Simple s where s.name in (:several)");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 
 		q = s.createQuery("from Simple s where s.name in :several");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 
 		q = s.createQuery("from Simple s where s.name in (:stuff)");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 
 		q = s.createQuery("from Simple s where s.name in :stuff");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSetPropertiesMap() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
-		s.save(simple, new Long(10) );
+		s.save( simple );
 		Map parameters = new HashMap();
 		parameters.put("name", simple.getName());
 		parameters.put("count", new Integer(simple.getCount()));
 
 		Query q = s.createQuery("from Simple s where s.name=:name and s.count=:count");
 		q.setProperties((parameters));
 		assertTrue( q.list().get(0)==simple );
 
 		List l = new ArrayList();
 		l.add("Simple 1");
 		l.add("Slimeball");
 		parameters.put("several", l);
 		q = s.createQuery("from Simple s where s.name in (:several)");
 		q.setProperties(parameters);
 		assertTrue( q.list().get(0)==simple );
 
 
 		parameters.put("stuff", l.toArray(new String[0]));
 		q = s.createQuery("from Simple s where s.name in (:stuff)");
 		q.setProperties(parameters);
 		assertTrue( q.list().get(0)==simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testBroken() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Broken b = new Fixed();
 		b.setId( new Long(123));
 		b.setOtherId("foobar");
 		s.save(b);
 		s.flush();
 		b.setTimestamp( new Date() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update(b);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		b = (Broken) s.load( Broken.class, b );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete(b);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testNothinToUpdate() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
-		s.save( simple, new Long(10) );
+		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		s.update( simple, new Long(10) );
+		s.update( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		s.update( simple, new Long(10) );
+		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCachedQuery() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
-		simple.setName("Simple 1");
-		s.save( simple, new Long(10) );
+		Simple simple = new Simple( Long.valueOf(10) );
+		simple.setName( "Simple 1" );
+		Long id = (Long) s.save( simple );
+		assertEquals( Long.valueOf( 10 ), id );
+		assertEquals( Long.valueOf( 10 ), simple.getId() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setCacheable(true);
 		q.setString("name", "Simple 1");
 		assertTrue( q.list().size()==1 );
 		simple = (Simple) q.list().get(0);
 
 		q.setString("name", "Simple 2");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		simple.setName("Simple 2");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setString("name", "Simple 2");
 		q.setCacheable(true);
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		s.update( simple, new Long(10) );
+		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCachedQueryRegion() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
-		s.save( simple, new Long(10) );
+		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString("name", "Simple 1");
 		assertTrue( q.list().size()==1 );
 		simple = (Simple) q.list().get(0);
 
 		q.setString("name", "Simple 2");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		simple.setName("Simple 2");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		s.update( simple, new Long(10) );
+		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSQLFunctions() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
-		s.save(simple, new Long(10) );
+		s.save( simple );
 
 		if ( getDialect() instanceof DB2Dialect) {
 			s.createQuery( "from Simple s where repeat('foo', 3) = 'foofoofoo'" ).list();
 			s.createQuery( "from Simple s where repeat(s.name, 3) = 'foofoofoo'" ).list();
 			s.createQuery( "from Simple s where repeat( lower(s.name), 3 + (1-1) / 2) = 'foofoofoo'" ).list();
 		}
 
 		assertTrue(
 				s.createQuery( "from Simple s where upper( s.name ) ='SIMPLE 1'" ).list().size()==1
 		);
 		if ( !(getDialect() instanceof HSQLDialect) ) {
 			assertTrue(
 					s.createQuery(
 							"from Simple s where not( upper( s.name ) ='yada' or 1=2 or 'foo'='bar' or not('foo'='foo') or 'foo' like 'bar' )"
 					).list()
 							.size()==1
 			);
 		}
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof SybaseDialect) && !(getDialect() instanceof SQLServerDialect) && !(getDialect() instanceof MckoiDialect) && !(getDialect() instanceof InterbaseDialect) && !(getDialect() instanceof TimesTenDialect) ) { //My SQL has a funny concatenation operator
 			assertTrue(
 					s.createQuery( "from Simple s where lower( s.name || ' foo' ) ='simple 1 foo'" ).list().size()==1
 			);
 		}
 		if ( (getDialect() instanceof SybaseDialect) ) {
 			assertTrue(
 					s.createQuery( "from Simple s where lower( s.name + ' foo' ) ='simple 1 foo'" ).list().size()==1
 			);
 		}
 		if ( (getDialect() instanceof MckoiDialect) || (getDialect() instanceof TimesTenDialect)) {
 			assertTrue(
 					s.createQuery( "from Simple s where lower( concat(s.name, ' foo') ) ='simple 1 foo'" ).list().size()==1
 			);
 		}
 
-		Simple other = new Simple();
+		Simple other = new Simple( Long.valueOf(20) );
 		other.setName("Simple 2");
 		other.setCount(12);
 		simple.setOther(other);
-		s.save( other, new Long(20) );
+		s.save( other );
 		//s.find("from Simple s where s.name ## 'cat|rat|bag'");
 		assertTrue(
 				s.createQuery( "from Simple s where upper( s.other.name ) ='SIMPLE 2'" ).list().size()==1
 		);
 		assertTrue(
 				s.createQuery( "from Simple s where not ( upper( s.other.name ) ='SIMPLE 2' )" ).list().size()==0
 		);
 		assertTrue(
 				s.createQuery(
 						"select distinct s from Simple s where ( ( s.other.count + 3 ) = (15*2)/2 and s.count = 69) or ( ( s.other.count + 2 ) / 7 ) = 2"
 				).list()
 						.size()==1
 		);
 		assertTrue(
 				s.createQuery(
 						"select s from Simple s where ( ( s.other.count + 3 ) = (15*2)/2 and s.count = 69) or ( ( s.other.count + 2 ) / 7 ) = 2 order by s.other.count"
 				).list()
 						.size()==1
 		);
-		Simple min = new Simple();
+		Simple min = new Simple( Long.valueOf(30) );
 		min.setCount(-1);
-		s.save(min, new Long(30) );
+		s.save( min );
 		if ( ! (getDialect() instanceof MySQLDialect) && ! (getDialect() instanceof HSQLDialect) ) { //My SQL has no subqueries
 			assertTrue(
 					s.createQuery( "from Simple s where s.count > ( select min(sim.count) from Simple sim )" )
 							.list()
 							.size()==2
 			);
 			t.commit();
 			t = s.beginTransaction();
 			assertTrue(
 					s.createQuery(
 							"from Simple s where s = some( select sim from Simple sim where sim.count>=0 ) and s.count >= 0"
 					).list()
 							.size()==2
 			);
 			assertTrue(
 					s.createQuery(
 							"from Simple s where s = some( select sim from Simple sim where sim.other.count=s.other.count ) and s.other.count > 0"
 					).list()
 							.size()==1
 			);
 		}
 
 		Iterator iter = s.createQuery( "select sum(s.count) from Simple s group by s.count having sum(s.count) > 10" )
 				.iterate();
 		assertTrue( iter.hasNext() );
-		assertEquals( new Long(12), iter.next() );
+		assertEquals( Long.valueOf(12), iter.next() );
 		assertTrue( !iter.hasNext() );
 		if ( ! (getDialect() instanceof MySQLDialect) ) {
 			iter = s.createQuery( "select s.count from Simple s group by s.count having s.count = 12" ).iterate();
 			assertTrue( iter.hasNext() );
 		}
 
 		s.createQuery(
 				"select s.id, s.count, count(t), max(t.date) from Simple s, Simple t where s.count = t.count group by s.id, s.count order by s.count"
 		).iterate();
 
 		Query q = s.createQuery("from Simple s");
 		q.setMaxResults(10);
 		assertTrue( q.list().size()==3 );
 		q = s.createQuery("from Simple s");
 		q.setMaxResults(1);
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s");
 		assertTrue( q.list().size()==3 );
 		q = s.createQuery("from Simple s where s.name = ?");
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name = ? and upper(s.name) = ?");
 		q.setString(1, "SIMPLE 1");
 		q.setString(0, "Simple 1");
 		q.setFirstResult(0);
 		assertTrue( q.iterate().hasNext() );
 		q = s.createQuery("from Simple s where s.name = :foo and upper(s.name) = :bar or s.count=:count or s.count=:count + 1");
 		q.setParameter("bar", "SIMPLE 1");
 		q.setString("foo", "Simple 1");
 		q.setInteger("count", 69);
 		q.setFirstResult(0);
 		assertTrue( q.iterate().hasNext() );
 		q = s.createQuery("select s.id from Simple s");
 		q.setFirstResult(1);
 		q.setMaxResults(2);
 		iter = q.iterate();
 		int i=0;
 		while ( iter.hasNext() ) {
 			assertTrue( iter.next() instanceof Long );
 			i++;
 		}
 		assertTrue(i==2);
 		q = s.createQuery("select all s, s.other from Simple s where s = :s");
 		q.setParameter("s", simple);
 		assertTrue( q.list().size()==1 );
 
 
 		q = s.createQuery("from Simple s where s.name in (:name_list) and s.count > :count");
 		HashSet set = new HashSet();
 		set.add("Simple 1"); set.add("foo");
 		q.setParameterList( "name_list", set );
-		q.setParameter("count", new Integer(-1) );
+		q.setParameter("count", Integer.valueOf( -1 ) );
 		assertTrue( q.list().size()==1 );
 
 		ScrollableResults sr = s.createQuery("from Simple s").scroll();
 		sr.next();
 		sr.get(0);
 		sr.close();
 
 		s.delete(other);
 		s.delete(simple);
 		s.delete(min);
 		t.commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testBlobClob() throws Exception {
 		// Sybase does not support ResultSet.getBlob(String)
 		if ( getDialect() instanceof SybaseDialect || getDialect() instanceof Sybase11Dialect || getDialect() instanceof SybaseASE15Dialect || getDialect() instanceof SybaseAnywhereDialect ) {
 			return;
 		}
 		Session s = openSession();
 		Blobber b = new Blobber();
 		b.setBlob( s.getLobHelper().createBlob( "foo/bar/baz".getBytes() ) );
 		b.setClob( s.getLobHelper().createClob("foo/bar/baz") );
 		s.save(b);
 		//s.refresh(b);
 		//assertTrue( b.getClob() instanceof ClobImpl );
 		s.flush();
 
 		s.refresh(b);
 		//b.getBlob().setBytes( 2, "abc".getBytes() );
 		b.getClob().getSubString(2, 3);
 		//b.getClob().setString(2, "abc");
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		Blobber b2 = new Blobber();
 		s.save(b2);
 		b2.setBlob( b.getBlob() );
 		b.setBlob(null);
 		//assertTrue( b.getClob().getSubString(1, 3).equals("fab") );
 		b.getClob().getSubString(1, 6);
 		//b.getClob().setString(1, "qwerty");
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		b.setClob( s.getLobHelper().createClob("xcvfxvc xcvbx cvbx cvbx cvbxcvbxcvbxcvb") );
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		assertTrue( b.getClob().getSubString(1, 7).equals("xcvfxvc") );
 		//b.getClob().setString(5, "1234567890");
 		s.flush();
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSqlFunctionAsAlias() throws Exception {
 		String functionName = locateAppropriateDialectFunctionNameForAliasTest();
 		if (functionName == null) {
             LOG.info("Dialect does not list any no-arg functions");
 			return;
 		}
 
         LOG.info("Using function named [" + functionName + "] for 'function as alias' test");
 		String query = "select " + functionName + " from Simple as " + functionName + " where " + functionName + ".id = 10";
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
-		s.save( simple, new Long(10) );
+		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List result = s.createQuery( query ).list();
 		assertTrue( result.size() == 1 );
 		assertTrue(result.get(0) instanceof Simple);
 		s.delete( result.get(0) );
 		t.commit();
 		s.close();
 	}
 
 	private String locateAppropriateDialectFunctionNameForAliasTest() {
 		for (Iterator itr = getDialect().getFunctions().entrySet().iterator(); itr.hasNext(); ) {
 			final Map.Entry entry = (Map.Entry) itr.next();
 			final SQLFunction function = (SQLFunction) entry.getValue();
 			if ( !function.hasArguments() && !function.hasParenthesesIfNoArguments() ) {
 				return (String) entry.getKey();
 			}
 		}
 		return null;
 	}
 
 	@Test
 	public void testCachedQueryOnInsert() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
-		s.save( simple, new Long(10) );
+		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s");
 		List list = q.setCacheable(true).list();
 		assertTrue( list.size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		Simple simple2 = new Simple();
+		Simple simple2 = new Simple( Long.valueOf(12) );
 		simple2.setCount(133);
-		s.save( simple2, new Long(12) );
+		s.save( simple2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==2 );
 		Iterator i = list.iterator();
 		while ( i.hasNext() ) s.delete( i.next() );
 		t.commit();
 		s.close();
 
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLLoaderTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLLoaderTest.java
index 69c8a12571..d00d924790 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLLoaderTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLLoaderTest.java
@@ -1,677 +1,741 @@
 //$Id: SQLLoaderTest.java 11383 2007-04-02 15:34:02Z steve.ebersole@jboss.com $
 package org.hibernate.test.legacy;
+
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Query;
+import org.hibernate.SQLQuery;
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.PostgreSQLDialect;
 import org.hibernate.dialect.TimesTenDialect;
 
 import org.junit.Test;
 
 import org.hibernate.testing.FailureExpected;
 import org.hibernate.testing.SkipForDialect;
 import org.hibernate.testing.TestForIssue;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
-
 public class SQLLoaderTest extends LegacyTestCase {
 	static int nextInt = 1;
 	static long nextLong = 1;
 
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 			"legacy/ABC.hbm.xml",
 			"legacy/Category.hbm.xml",
 			"legacy/Simple.hbm.xml",
 			"legacy/Fo.hbm.xml",
 			"legacy/SingleSeveral.hbm.xml",
 			"legacy/Componentizable.hbm.xml",
             "legacy/CompositeIdId.hbm.xml"
 		};
 	}
 
 	@Test
 	public void testTS() throws Exception {
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
-		Simple sim = new Simple();
+		Simple sim = new Simple( Long.valueOf(1) );
 		sim.setDate( new Date() );
-		session.save( sim, new Long(1) );
-		Query q = session.createSQLQuery("select {sim.*} from Simple {sim} where {sim}.date_ = ?", "sim", Simple.class);
+		session.save( sim );
+		Query q = session.createSQLQuery( "select {sim.*} from Simple {sim} where {sim}.date_ = ?" ).addEntity( "sim", Simple.class );
 		q.setTimestamp( 0, sim.getDate() );
 		assertTrue ( q.list().size()==1 );
 		session.delete(sim);
 		txn.commit();
 		session.close();
 	}
 
 	@Test
 	public void testFindBySQLStar() throws HibernateException, SQLException {
 		Session session = openSession();
-		session.delete("from Assignable");
-		session.delete("from Category");
-		session.delete("from Simple");
-		session.delete("from A");
+		for ( Object entity : session.createQuery( "from Assignable" ).list() ) {
+			session.delete( entity );
+		}
+		for ( Object entity : session.createQuery( "from Category" ).list() ) {
+			session.delete( entity );
+		}
+		for ( Object entity : session.createQuery( "from Simple" ).list() ) {
+			session.delete( entity );
+		}
+		for ( Object entity : session.createQuery( "from A" ).list() ) {
+			session.delete( entity );
+		}
 
 		Category s = new Category();
 		s.setName(String.valueOf(nextLong++));
 		session.save(s);
 
-		Simple simple = new Simple();
+		Simple simple = new Simple( Long.valueOf(nextLong++) );
 		simple.init();
-		session.save(simple, new Long(nextLong++));
+		session.save( simple );
 
 		A a = new A();
 		session.save(a);
 
 		B b = new B();
 		session.save(b);
 		session.flush();
 
-		session.createSQLQuery("select {category.*} from category {category}", "category", Category.class).list();
-		session.createSQLQuery("select {simple.*} from Simple {simple}", "simple", Simple.class).list();
-		session.createSQLQuery("select {a.*} from TA {a}", "a", A.class).list();
+		session.createSQLQuery( "select {category.*} from category {category}" ).addEntity( "category", Category.class ).list();
+		session.createSQLQuery( "select {simple.*} from Simple {simple}" ).addEntity( "simple", Simple.class ).list();
+		session.createSQLQuery( "select {a.*} from TA {a}" ).addEntity( "a", A.class ).list();
 
 		session.connection().commit();
 		session.close();
 	}
 
 	@Test
 	public void testFindBySQLProperties() throws HibernateException, SQLException {
-			Session session = openSession();
-			session.delete("from Category");
+		Session session = openSession();
+		for ( Object entity : session.createQuery( "from Category" ).list() ) {
+			session.delete( entity );
+		}
 
-			Category s = new Category();
-			s.setName(String.valueOf(nextLong++));
-			session.save(s);
+		Category s = new Category();
+		s.setName(String.valueOf(nextLong++));
+		session.save(s);
 
-			s = new Category();
-			s.setName("WannaBeFound");
-			session.flush();
+		s = new Category();
+		s.setName("WannaBeFound");
+		session.flush();
 
-			Query query = session.createSQLQuery("select {category.*} from category {category} where {category}.name = :name", "category", Category.class);
+		Query query = session.createSQLQuery( "select {category.*} from category {category} where {category}.name = :name" )
+				.addEntity( "category", Category.class );
 
-			query.setProperties(s);
-			//query.setParameter("name", s.getName());
+		query.setProperties(s);
+		//query.setParameter("name", s.getName());
 
-			query.list();
+		query.list();
 
-			query = session.createSQLQuery("select {category.*} from category {category} where {category}.name in (:names)", "category", Category.class);
-			String[] str = new String[] { "WannaBeFound", "NotThere" };
-			query.setParameterList("names", str);
-			query.uniqueResult();
+		query = session.createSQLQuery( "select {category.*} from category {category} where {category}.name in (:names)" )
+				.addEntity( "category", Category.class );
+		String[] str = new String[] { "WannaBeFound", "NotThere" };
+		query.setParameterList("names", str);
+		query.uniqueResult();
 
-			query = session.createSQLQuery("select {category.*} from category {category} where {category}.name in :names", "category", Category.class);
-			query.setParameterList("names", str);
-			query.uniqueResult();
+		query = session.createSQLQuery( "select {category.*} from category {category} where {category}.name in :names" )
+				.addEntity( "category", Category.class );
+		query.setParameterList("names", str);
+		query.uniqueResult();
 
-			query = session.createSQLQuery("select {category.*} from category {category} where {category}.name in (:names)", "category", Category.class);
-			str = new String[] { "WannaBeFound" };
-			query.setParameterList("names", str);
-			query.uniqueResult();
+		query = session.createSQLQuery( "select {category.*} from category {category} where {category}.name in (:names)" )
+				.addEntity( "category", Category.class );
+		str = new String[] { "WannaBeFound" };
+		query.setParameterList("names", str);
+		query.uniqueResult();
 
-			query = session.createSQLQuery("select {category.*} from category {category} where {category}.name in :names", "category", Category.class);
-			query.setParameterList("names", str);			
-			query.uniqueResult();
+		query = session.createSQLQuery( "select {category.*} from category {category} where {category}.name in :names" )
+				.addEntity( "category", Category.class );
+		query.setParameterList("names", str);
+		query.uniqueResult();
 
-			session.connection().commit();
-			session.close();
+		session.connection().commit();
+		session.close();
 	}
 
 	@Test
 	public void testFindBySQLAssociatedObjects() throws HibernateException, SQLException {
 		Session s = openSession();
-		s.delete("from Assignable");
-		s.delete("from Category");
+		for ( Object entity : s.createQuery( "from Assignable" ).list() ) {
+			s.delete( entity );
+		}
+		for ( Object entity : s.createQuery( "from Category" ).list() ) {
+			s.delete( entity );
+		}
 
 		Category c = new Category();
 		c.setName("NAME");
 		Assignable assn = new Assignable();
 		assn.setId("i.d.");
 		List l = new ArrayList();
 		l.add(c);
 		assn.setCategories(l);
 		c.setAssignable(assn);
 		s.save(assn);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
-		List list = s.createSQLQuery("select {category.*} from category {category}", "category", Category.class).list();
+		List list = s.createSQLQuery( "select {category.*} from category {category}" ).addEntity( "category", Category.class ).list();
 		list.get(0);
 		s.connection().commit();
 		s.close();
 		
 		if ( getDialect() instanceof MySQLDialect ) return;
 
 		s = openSession();
 
 		Query query = s.getNamedQuery("namedsql");
 		assertNotNull(query);
 		list = query.list();
         assertNotNull(list);
 		
 		Object[] values = (Object[]) list.get(0);
 		assertNotNull(values[0]);
 		assertNotNull(values[1]);
 		assertTrue("wrong type: " + values[0].getClass(), values[0] instanceof Category);
 		assertTrue("wrong type: " + values[1].getClass(), values[1] instanceof Assignable);
 		
 		s.connection().commit();
 		s.close();
 
 	}
 
 	@Test
 	@SkipForDialect( MySQLDialect.class )
 	public void testPropertyResultSQL() throws HibernateException, SQLException {
 		Session s = openSession();
-		s.delete("from Assignable");
-		s.delete("from Category");
+		for ( Object entity : s.createQuery( "from Assignable" ).list() ) {
+			s.delete( entity );
+		}
+		for ( Object entity : s.createQuery( "from Category" ).list() ) {
+			s.delete( entity );
+		}
 
 		Category c = new Category();
 		c.setName("NAME");
 		Assignable assn = new Assignable();
 		assn.setId("i.d.");
 		List l = new ArrayList();
 		l.add(c);
 		assn.setCategories(l);
 		c.setAssignable(assn);
 		s.save(assn);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
 
 		Query query = s.getNamedQuery("nonaliasedsql");
 		assertNotNull(query);
 		List list = query.list();
         assertNotNull(list);
 		
 		assertTrue(list.get(0) instanceof Category);
 		
 		s.connection().commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testFindBySQLMultipleObject() throws HibernateException, SQLException {
 		Session s = openSession();
-		s.delete("from Assignable");
-		s.delete("from Category");
+		for ( Object entity : s.createQuery( "from Assignable" ).list() ) {
+			s.delete( entity );
+		}
+		for ( Object entity : s.createQuery( "from Category" ).list() ) {
+			s.delete( entity );
+		}
+
 		s.flush();
 		s.connection().commit();
 		s.close();
 		s = openSession();
 		Category c = new Category();
 		c.setName("NAME");
 		Assignable assn = new Assignable();
 		assn.setId("i.d.");
 		List l = new ArrayList();
 		l.add(c);
 		assn.setCategories(l);
 		c.setAssignable(assn);
 		s.save(assn);
 		s.flush();
 		c = new Category();
 		c.setName("NAME2");
 		assn = new Assignable();
 		assn.setId("i.d.2");
 		l = new ArrayList();
 		l.add(c);
 		assn.setCategories(l);
 		c.setAssignable(assn);
 		s.save(assn);
 		s.flush();
 
 		assn = new Assignable();
 		assn.setId("i.d.3");
 		s.save(assn);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		if ( getDialect() instanceof MySQLDialect ) return;
 
 		s = openSession();
-		List list = s.createSQLQuery("select {category.*}, {assignable.*} from category {category}, \"assign-able\" {assignable}", new String[] { "category", "assignable" }, new Class[] { Category.class, Assignable.class }).list();
+		String sql = "select {category.*}, {assignable.*} from category {category}, \"assign-able\" {assignable}";
+
+		List list = s.createSQLQuery( sql ).addEntity( "category", Category.class ).addEntity( "assignable", Assignable.class ).list();
 
 		assertTrue(list.size() == 6); // crossproduct of 2 categories x 3 assignables
 		assertTrue(list.get(0) instanceof Object[]);
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	public void testFindBySQLParameters() throws HibernateException, SQLException {
 		Session s = openSession();
-		s.delete("from Assignable");
-		s.delete("from Category");
+		for ( Object entity : s.createQuery( "from Assignable" ).list() ) {
+			s.delete( entity );
+		}
+		for ( Object entity : s.createQuery( "from Category" ).list() ) {
+			s.delete( entity );
+		}
 		s.flush();
 		s.connection().commit();
 		s.close();
 		s = openSession();
 		Category c = new Category();
 		c.setName("Good");
 		Assignable assn = new Assignable();
 		assn.setId("i.d.");
 		List l = new ArrayList();
 		l.add(c);
 		assn.setCategories(l);
 		c.setAssignable(assn);
 		s.save(assn);
 		s.flush();
 		c = new Category();
 		c.setName("Best");
 		assn = new Assignable();
 		assn.setId("i.d.2");
 		l = new ArrayList();
 		l.add(c);
 		assn.setCategories(l);
 		c.setAssignable(assn);
 		s.save(assn);
 		s.flush();
 		c = new Category();
 		c.setName("Better");
 		assn = new Assignable();
 		assn.setId("i.d.7");
 		l = new ArrayList();
 		l.add(c);
 		assn.setCategories(l);
 		c.setAssignable(assn);
 		s.save(assn);
 		s.flush();
 
 		assn = new Assignable();
 		assn.setId("i.d.3");
 		s.save(assn);
 		s.flush();
 		s.connection().commit();
 		s.close();
 
 		s = openSession();
-		Query basicParam = s.createSQLQuery("select {category.*} from category {category} where {category}.name = 'Best'", "category", Category.class);
+		Query basicParam = s.createSQLQuery( "select {category.*} from category {category} where {category}.name = 'Best'" )
+				.addEntity( "category", Category.class );
 		List list = basicParam.list();
 		assertEquals(1, list.size());
 
-		Query unnamedParam = s.createSQLQuery("select {category.*} from category {category} where {category}.name = ? or {category}.name = ?", "category", Category.class);
+		Query unnamedParam = s.createSQLQuery( "select {category.*} from category {category} where {category}.name = ? or {category}.name = ?" )
+				.addEntity( "category", Category.class );
 		unnamedParam.setString(0, "Good");
 		unnamedParam.setString(1, "Best");
 		list = unnamedParam.list();
 		assertEquals(2, list.size());
 
-		Query namedParam = s.createSQLQuery("select {category.*} from category {category} where ({category}.name=:firstCat or {category}.name=:secondCat)", "category", Category.class);
+		Query namedParam = s.createSQLQuery( "select {category.*} from category {category} where ({category}.name=:firstCat or {category}.name=:secondCat)" )
+				.addEntity( "category", Category.class);
 		namedParam.setString("firstCat", "Better");
 		namedParam.setString("secondCat", "Best");
 		list = namedParam.list();
 		assertEquals(2, list.size());
 
 		s.connection().commit();
 		s.close();
 	}
 
 	@Test
 	@SkipForDialect( { HSQLDialect.class, PostgreSQLDialect.class } )
 	public void testEscapedJDBC() throws HibernateException, SQLException {
 		Session session = openSession();
-		session.delete("from A");
+		for ( Object entity : session.createQuery( "from A" ).list() ) {
+			session.delete( entity );
+		}
 		A savedA = new A();
 		savedA.setName("Max");
 		session.save(savedA);
 
 		B savedB = new B();
 		session.save(savedB);
 		session.flush();
 
 		int count = session.createQuery("from A").list().size();
 		session.close();
 
 		session = openSession();
 
 		Query query;
 		if( getDialect() instanceof TimesTenDialect) {
             // TimesTen does not permit general expressions (like UPPER) in the second part of a LIKE expression,
             // so we execute a similar test 
-            query = session.createSQLQuery("select identifier_column as {a.id}, clazz_discriminata as {a.class}, count_ as {a.count}, name as {a.name} from TA where {fn ucase(name)} like 'MAX'", "a", A.class);
-        } else {
-            query = session.createSQLQuery("select identifier_column as {a.id}, clazz_discriminata as {a.class}, count_ as {a.count}, name as {a.name} from TA where {fn ucase(name)} like {fn ucase('max')}", "a", A.class);
+            query = session.createSQLQuery("select identifier_column as {a.id}, clazz_discriminata as {a.class}, count_ as {a.count}, name as {a.name} from TA where {fn ucase(name)} like 'MAX'" )
+					.addEntity( "a", A.class );
+        }
+		else {
+            query = session.createSQLQuery( "select identifier_column as {a.id}, clazz_discriminata as {a.class}, count_ as {a.count}, name as {a.name} from TA where {fn ucase(name)} like {fn ucase('max')}" )
+					.addEntity( "a", A.class );
         }
 		List list = query.list();
 
 		assertNotNull(list);
 		assertEquals(1, list.size());
 		session.connection().commit();
 		session.close();
 	}
 
 	@Test
 	public void testDoubleAliasing() throws HibernateException, SQLException {
 		Session session = openSession();
-		session.delete("from A");
+		for ( Object entity : session.createQuery( "from A" ).list() ) {
+			session.delete( entity );
+		}
 		A savedA = new A();
 		savedA.setName("Max");
 		session.save(savedA);
 
 		B savedB = new B();
 		session.save(savedB);
 		session.flush();
 
 		int count = session.createQuery("from A").list().size();
 		session.close();
 
 		session = openSession();
 
-		Query query = session.createSQLQuery("select a.identifier_column as {a1.id}, a.clazz_discriminata as {a1.class}, a.count_ as {a1.count}, a.name as {a1.name} " +
-											", b.identifier_column as {a2.id}, b.clazz_discriminata as {a2.class}, b.count_ as {a2.count}, b.name as {a2.name} " +
-											" from TA a, TA b" +
-											" where a.identifier_column = b.identifier_column", new String[] {"a1", "a2" }, new Class[] {A.class, A.class});
+		String sql = "select a.identifier_column as {a1.id}, " +
+				"    a.clazz_discriminata as {a1.class}, " +
+				"    a.count_ as {a1.count}, " +
+				"    a.name as {a1.name}, " +
+				"    b.identifier_column as {a2.id}, " +
+				"    b.clazz_discriminata as {a2.class}, " +
+				"    b.count_ as {a2.count}, " +
+				"    b.name as {a2.name} " +
+				"from TA a, TA b " +
+				"where a.identifier_column = b.identifier_column";
+		Query query = session.createSQLQuery( sql ).addEntity( "a1", A.class ).addEntity( "a2", A.class );
 		List list = query.list();
 
 		assertNotNull(list);
 		assertEquals(2, list.size());
 		session.connection().commit();
 		session.close();
 	}
 
 	@Test
 	public void testEmbeddedCompositeProperties() throws HibernateException, SQLException {
 	   Session session = openSession();
 
 	   Single s = new Single();
 	   s.setId("my id");
 	   s.setString("string 1");
 	   session.save(s);
 	   session.flush();
 	   session.connection().commit();
 
 	   session.clear();
 
-	   Query query = session.createSQLQuery("select {sing.*} from Single {sing}", "sing", Single.class);
+	   SQLQuery query = session.createSQLQuery( "select {sing.*} from Single {sing}" ).addEntity( "sing", Single.class );
 
 	   List list = query.list();
 
 	   assertTrue(list.size()==1);
 
 	   session.clear();
 
-	   query = session.createSQLQuery("select {sing.*} from Single {sing} where sing.id = ?", "sing", Single.class);
+	   query = session.createSQLQuery( "select {sing.*} from Single {sing} where sing.id = ?" ).addEntity( "sing", Single.class );
 	   query.setString(0, "my id");
 	   list = query.list();
 
 	   assertTrue(list.size()==1);
 
 	   session.clear();
 
-	   query = session.createSQLQuery("select s.id as {sing.id}, s.string_ as {sing.string}, s.prop as {sing.prop} from Single s where s.id = ?", "sing", Single.class);
+	   query = session.createSQLQuery( "select s.id as {sing.id}, s.string_ as {sing.string}, s.prop as {sing.prop} from Single s where s.id = ?" )
+			   .addEntity( "sing", Single.class );
 	   query.setString(0, "my id");
 	   list = query.list();
 
 	   assertTrue(list.size()==1);
 
 	   session.clear();
 
-	   query = session.createSQLQuery("select s.id as {sing.id}, s.string_ as {sing.string}, s.prop as {sing.prop} from Single s where s.id = ?", "sing", Single.class);
+	   query = session.createSQLQuery( "select s.id as {sing.id}, s.string_ as {sing.string}, s.prop as {sing.prop} from Single s where s.id = ?" )
+			   .addEntity( "sing", Single.class );
 	   query.setString(0, "my id");
 	   list = query.list();
 
 	   assertTrue(list.size()==1);
 
 	   session.connection().commit();
 	   session.close();
 
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "unknown" )
 	public void testReturnPropertyComponentRename() throws HibernateException, SQLException {
 		// failure expected because this was a regression introduced previously which needs to get tracked down.
 		Session session = openSession();
 		Componentizable componentizable = setupComponentData(session);
 		
 		Query namedQuery = session.getNamedQuery("queryComponentWithOtherColumn");
 		List list = namedQuery.list();
 		
 		assertEquals(1, list.size());
 		assertEquals( "flakky comp", ( (Componentizable) list.get(0) ).getComponent().getName() );
 		
 		session.clear();
 		
 		session.delete(componentizable);
 		session.flush();
 		
 		session.connection().commit();
 		session.close();
 	}
 	
 	@Test
 	public void testComponentStar() throws HibernateException, SQLException {
 	    componentTest("select {comp.*} from Componentizable comp");
 	}
 	
 	@Test
 	public void testComponentNoStar() throws HibernateException, SQLException {
 	    componentTest("select comp.id as {comp.id}, comp.nickName as {comp.nickName}, comp.name as {comp.component.name}, comp.subName as {comp.component.subComponent.subName}, comp.subName1 as {comp.component.subComponent.subName1} from Componentizable comp");
 	}
 
 	private void componentTest(String sql) throws SQLException {
         Session session = openSession();
 	    
 	    Componentizable c = setupComponentData( session );
-        
-	    Query q = session.createSQLQuery(sql, "comp", Componentizable.class);
+
+		SQLQuery q = session.createSQLQuery( sql )
+				.addEntity( "comp", Componentizable.class );
 	    List list = q.list();
 	    
 	    assertEquals(list.size(),1);
 	    
 	    Componentizable co = (Componentizable) list.get(0);
 	    
 	    assertEquals(c.getNickName(), co.getNickName());
 	    assertEquals(c.getComponent().getName(), co.getComponent().getName());
 	    assertEquals(c.getComponent().getSubComponent().getSubName(), co.getComponent().getSubComponent().getSubName());
 	    
 	    session.delete(co);
 	    session.flush();
 	    session.connection().commit();
 	    session.close();
     }
 
 	private Componentizable setupComponentData(Session session) throws SQLException {
 		Componentizable c = new Componentizable();
 	    c.setNickName("Flacky");
 	    Component component = new Component();
 	    component.setName("flakky comp");
 	    SubComponent subComponent = new SubComponent();
 	    subComponent.setSubName("subway");
         component.setSubComponent(subComponent);
 	    
         c.setComponent(component);
         
         session.save(c);
         
         session.flush();
         session.connection().commit();
         
         session.clear();
 		return c;
 	}
 
 	@Test
 	@SkipForDialect( MySQLDialect.class )
     public void testFindSimpleBySQL() throws Exception {
 		Session session = openSession();
 		Category s = new Category();
 		s.setName(String.valueOf(nextLong++));
 		session.save(s);
 		session.flush();
 
-		Query query = session.createSQLQuery("select s.category_key_col as {category.id}, s.name as {category.name}, s.\"assign-able-id\" as {category.assignable} from {category} s", "category", Category.class);
+		Query query = session.createSQLQuery( "select s.category_key_col as {category.id}, s.name as {category.name}, s.\"assign-able-id\" as {category.assignable} from {category} s" )
+				.addEntity( "category", Category.class );
 		List list = query.list();
 
 		assertNotNull(list);
 		assertTrue(list.size() > 0);
 		assertTrue(list.get(0) instanceof Category);
 		session.connection().commit();
 		session.close();
 		// How do we handle objects with composite id's ? (such as Single)
 	}
 
 	@Test
 	public void testFindBySQLSimpleByDiffSessions() throws Exception {
 		Session session = openSession();
 		Category s = new Category();
 		s.setName(String.valueOf(nextLong++));
 		session.save(s);
 		session.flush();
 		session.connection().commit();
 		session.close();
 
 		if ( getDialect() instanceof MySQLDialect ) return;
 
 		session = openSession();
 
-		Query query = session.createSQLQuery("select s.category_key_col as {category.id}, s.name as {category.name}, s.\"assign-able-id\" as {category.assignable} from {category} s", "category", Category.class);
+		Query query = session.createSQLQuery( "select s.category_key_col as {category.id}, s.name as {category.name}, s.\"assign-able-id\" as {category.assignable} from {category} s" )
+				.addEntity( "category", Category.class );
 		List list = query.list();
 
 		assertNotNull(list);
 		assertTrue(list.size() > 0);
 		assertTrue(list.get(0) instanceof Category);
 
 		// How do we handle objects that does not have id property (such as Simple ?)
 		// How do we handle objects with composite id's ? (such as Single)
 		session.connection().commit();
 		session.close();
 	}
 
 	@Test
 	public void testFindBySQLDiscriminatedSameSession() throws Exception {
 		Session session = openSession();
-		session.delete("from A");
+		for ( Object entity : session.createQuery( "from A" ).list() ) {
+			session.delete( entity );
+		}
 		A savedA = new A();
 		session.save(savedA);
 
 		B savedB = new B();
 		session.save(savedB);
 		session.flush();
 
-		Query query = session.createSQLQuery("select identifier_column as {a.id}, clazz_discriminata as {a.class}, name as {a.name}, count_ as {a.count} from TA {a}", "a", A.class);
+		Query query = session.createSQLQuery( "select identifier_column as {a.id}, clazz_discriminata as {a.class}, name as {a.name}, count_ as {a.count} from TA {a}" )
+				.addEntity( "a", A.class );
 		List list = query.list();
 
 		assertNotNull(list);
 		assertEquals(2, list.size());
 
 		A a1 = (A) list.get(0);
 		A a2 = (A) list.get(1);
 
 		assertTrue((a2 instanceof B) || (a1 instanceof B));
 		assertFalse(a1 instanceof B && a2 instanceof B);
 
 		if (a1 instanceof B) {
 			assertSame(a1, savedB);
 			assertSame(a2, savedA);
 		}
 		else {
 			assertSame(a2, savedB);
 			assertSame(a1, savedA);
 		}
 
 		session.clear();
 		List list2 = session.getNamedQuery("propertyResultDiscriminator").list();
 		assertEquals(2, list2.size());
 		
 		session.connection().commit();
 		session.close();
 	}
 
 	@Test
 	public void testFindBySQLDiscriminatedDiffSession() throws Exception {
 		Session session = openSession();
-		session.delete("from A");
+		for ( Object entity : session.createQuery( "from A" ).list() ) {
+			session.delete( entity );
+		}
 		A savedA = new A();
 		session.save(savedA);
 
 		B savedB = new B();
 		session.save(savedB);
 		session.flush();
 
 		int count = session.createQuery("from A").list().size();
 		session.close();
 
 		session = openSession();
 
-		Query query = session.createSQLQuery("select identifier_column as {a.id}, clazz_discriminata as {a.class}, count_ as {a.count}, name as {a.name} from TA", "a", A.class);
+		Query query = session.createSQLQuery( "select identifier_column as {a.id}, clazz_discriminata as {a.class}, count_ as {a.count}, name as {a.name} from TA" )
+				.addEntity( "a", A.class );
 		List list = query.list();
 
 		assertNotNull(list);
 		assertEquals(count, list.size());
 		session.connection().commit();
 		session.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-21" )
     public void testCompositeIdId() throws HibernateException, SQLException {
         Session s = openSession();
 
         CompositeIdId id = new CompositeIdId();
         id.setName("Max");
         id.setSystem("c64");
         id.setId("games");
 
         s.save(id);
         s.flush();
         s.connection().commit();
         s.close();
 
         s = openSession();
         // having a composite id with one property named id works since the map used by sqlloader to map names to properties handles it.
-        Query query = s.createSQLQuery("select system as {c.system}, id as {c.id}, name as {c.name}, foo as {c.composite.foo}, bar as {c.composite.bar} from CompositeIdId where system=? and id=?", "c", CompositeIdId.class);
+		String sql = "select system as {c.system}, id as {c.id}, name as {c.name}, foo as {c.composite.foo}, bar as {c.composite.bar} from CompositeIdId where system=? and id=?";
+		SQLQuery query = s.createSQLQuery( sql ).addEntity( "c", CompositeIdId.class );
         query.setString(0, "c64");
         query.setString(1, "games");
 
         CompositeIdId id2 = (CompositeIdId) query.uniqueResult();
         check(id, id2);
 
         s.flush();
         s.connection().commit();
         s.close();
 
         s = openSession();
 
         CompositeIdId useForGet = new CompositeIdId();
         useForGet.setSystem("c64");
         useForGet.setId("games");
         // this doesn't work since the verification does not take column span into respect!
         CompositeIdId getted = (CompositeIdId) s.get(CompositeIdId.class, useForGet);
         check(id,getted);
 
 
         s.connection().commit();
         s.close();
 
     }
 
     private void check(CompositeIdId id, CompositeIdId id2) {
         assertEquals(id,id2);
         assertEquals(id.getName(), id2.getName());
         assertEquals(id.getId(), id2.getId());
         assertEquals(id.getSystem(), id2.getSystem());
     }
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/Simple.hbm.xml b/hibernate-core/src/test/java/org/hibernate/test/legacy/Simple.hbm.xml
index 9686f51a88..ac91907f6c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/Simple.hbm.xml
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/Simple.hbm.xml
@@ -1,20 +1,20 @@
 <?xml version="1.0"?>
 <!DOCTYPE hibernate-mapping PUBLIC 
 	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
 	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
 <hibernate-mapping default-lazy="false">
 
     <class name="org.hibernate.test.legacy.Simple">
-        <id type="long" column="id_">
+        <id name="id" type="long" column="id_">
             <generator class="assigned"/>
         </id>
         <property name="name"/>
         <property name="address"/>
         <property name="count" column="count_" not-null="true" unique="true"/> 
         <property name="date" column="date_"/>
         <property name="pay"/>
         <many-to-one name="other" access="field"/>
     </class>
     
 
 </hibernate-mapping>
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/Simple.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/Simple.java
index 13d47e37fa..5a06c1b943 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/Simple.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/Simple.java
@@ -1,126 +1,166 @@
-//$Id: Simple.java 4599 2004-09-26 05:18:27Z oneovthafew $
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2004-2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
 package org.hibernate.test.legacy;
+
 import java.io.Serializable;
 
+/**
+ * @author Gavin King
+ */
 public class Simple implements Serializable {
+	private Long id;
 	private String name;
 	private String address;
 	private int count;
 	private java.util.Date date;
 	private Float number;
 	private Simple other;
 
 	private Long parent;
 
+	public Simple(Long id) {
+		this.id = id;
+	}
+
 	public Simple(int c) {
 		count=c;
 	}
 	public Simple() {}
 
 	public void init() {
 		name="Someone With Along Name";
 		address="1234 Some Street, Some City, Victoria, 3000, Austraya";
 		count=69;
 		date=new java.sql.Date(666);
 		number=new Float(55.8);
 	}
+
+	public Long getId() {
+		return id;
+	}
+
+	public void setId(Long id) {
+		this.id = id;
+	}
+
 	/**
 	 * Gets the name
 	 * @return Returns a String
 	 */
 	public String getName() {
 		return name;
 	}
 	/**
 	 * Sets the name
 	 * @param name The name to set
 	 */
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	/**
 	 * Gets the address
 	 * @return Returns a String
 	 */
 	public String getAddress() {
 		return address;
 	}
 	/**
 	 * Sets the address
 	 * @param address The address to set
 	 */
 	public void setAddress(String address) {
 		this.address = address;
 	}
 
 	/**
 	 * Gets the count
 	 * @return Returns a int
 	 */
 	public int getCount() {
 		return count;
 	}
 	/**
 	 * Sets the count
 	 * @param count The count to set
 	 */
 	public void setCount(int count) {
 		this.count = count;
 	}
 
 	/**
 	 * Gets the date
 	 * @return Returns a java.util.Date
 	 */
 	public java.util.Date getDate() {
 		return date;
 	}
 	/**
 	 * Sets the date
 	 * @param date The date to set
 	 */
 	public void setDate(java.util.Date date) {
 		this.date = date;
 	}
 
 	/**
 	 * Gets the pay number
 	 * @return Returns a Float
 	 */
 	public Float getPay() {
 		return number;
 	}
 
 	/**
 	 * Sets the pay number
 	 * @param number The Pay to set
 	 */
 	public void setPay(Float number) {
 		this.number = number;
 	}
 
 	/**
 	 * Returns the other.
 	 * @return Simple
 	 */
 	public Simple getOther() {
 		return other;
 	}
 
 	/**
 	 * Sets the other.
 	 * @param other The other to set
 	 */
 	public void setOther(Simple other) {
 		this.other = other;
 	}
 
 }
 
 
 
 
 
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/Top.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/Top.java
index dcd24a5ef4..dc9dfdf25f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/Top.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/Top.java
@@ -1,116 +1,118 @@
 //$Id: Top.java 5686 2005-02-12 07:27:32Z steveebersole $
 package org.hibernate.test.legacy;
 
 
 public class Top {
 	private long id;
 	private String name;
 	private String address;
 	private int count;
 	private java.util.Date date;
 	private Top other;
 	private Top top;
 	
 	public Top(int c) {
 		count=c;
 	}
-	public Top() {}
+
+	public Top() {
+	}
 	
 	public void init() {
 		name="Someone With Along Name";
 		address="1234 Some Street, Some City, Victoria, 3000, Austraya";
 		count=69;
 		date=new java.sql.Date(666);
 	}
 	/**
 	 * Gets the name
 	 * @return Returns a String
 	 */
 	public String getName() {
 		return name;
 	}
 	/**
 	 * Sets the name
 	 * @param name The name to set
 	 */
 	public void setName(String name) {
 		this.name = name;
 	}
 	
 	/**
 	 * Gets the address
 	 * @return Returns a String
 	 */
 	public String getAddress() {
 		return address;
 	}
 	/**
 	 * Sets the address
 	 * @param address The address to set
 	 */
 	public void setAddress(String address) {
 		this.address = address;
 	}
 	
 	/**
 	 * Gets the count
 	 * @return Returns a int
 	 */
 	public int getCount() {
 		return count;
 	}
 	/**
 	 * Sets the count
 	 * @param count The count to set
 	 */
 	public void setCount(int count) {
 		this.count = count;
 	}
 	
 	/**
 	 * Gets the date
 	 * @return Returns a java.util.Date
 	 */
 	public java.util.Date getDate() {
 		return date;
 	}
 	/**
 	 * Sets the date
 	 * @param date The date to set
 	 */
 	public void setDate(java.util.Date date) {
 		this.date = date;
 	}
 	
 	/**
 	 * Returns the other.
 	 * @return Simple
 	 */
 	public Top getOther() {
 		return other;
 	}
 	
 	/**
 	 * Sets the other.
 	 * @param other The other to set
 	 */
 	public void setOther(Top other) {
 		this.other = other;
 	}
 	
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long l) {
 		id = l;
 	}
 
 }
 
 
 
 
 
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/Vetoer.hbm.xml b/hibernate-core/src/test/java/org/hibernate/test/legacy/Vetoer.hbm.xml
index 6b6700fea5..bbe8f744a2 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/Vetoer.hbm.xml
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/Vetoer.hbm.xml
@@ -1,15 +1,15 @@
 <?xml version="1.0"?>
 <!DOCTYPE hibernate-mapping PUBLIC 
 	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
 	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
 <hibernate-mapping default-lazy="false">
 
     <class name="org.hibernate.test.legacy.Vetoer">
-        <id type="string" column="id_" length="32">
+        <id name="id" type="string" column="id_" length="32">
             <generator class="uuid.hex"/>
         </id>
         <property name="name"/>
         <property name="strings"/>
     </class>
 
 </hibernate-mapping>
\ No newline at end of file
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/Vetoer.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/Vetoer.java
index 89cfc73608..16e61b9e9b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/Vetoer.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/Vetoer.java
@@ -1,59 +1,66 @@
 //$Id: Vetoer.java 4599 2004-09-26 05:18:27Z oneovthafew $
 package org.hibernate.test.legacy;
 import java.io.Serializable;
 import org.hibernate.CallbackException;
 import org.hibernate.Session;
 import org.hibernate.classic.Lifecycle;
 
 public class Vetoer implements Lifecycle {
+	private String id;
+	private String name;
+	private String[] strings;
+
+	public String getId() {
+		return id;
+	}
+
+	public void setId(String id) {
+		this.id = id;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public void setName(String name) {
+		this.name = name;
+	}
+
+	public String[] getStrings() {
+		return strings;
+	}
+
+	public void setStrings(String[] strings) {
+		this.strings = strings;
+	}
 
 	boolean onSaveCalled;
 	boolean onUpdateCalled;
 	boolean onDeleteCalled;
 
-	private String name;
-	private String[] strings;
-
 	public boolean onSave(Session s) throws CallbackException {
 		boolean result = !onSaveCalled;
 		onSaveCalled = true;
 		return result;
 	}
 
 	public boolean onUpdate(Session s) throws CallbackException {
 		boolean result = !onUpdateCalled;
 		onUpdateCalled = true;
 		return result;
 	}
 
 	public boolean onDelete(Session s) throws CallbackException {
 		boolean result = !onDeleteCalled;
 		onDeleteCalled = true;
 		return result;
 	}
 
 	public void onLoad(Session s, Serializable id) {}
-
-	public String getName() {
-		return name;
-	}
-
-	public void setName(String name) {
-		this.name = name;
-	}
-
-	public String[] getStrings() {
-		return strings;
-	}
-
-	public void setStrings(String[] strings) {
-		this.strings = strings;
-	}
-
 }
 
 
 
 
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/onetomany/AbstractRecursiveBidirectionalOneToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/onetomany/AbstractRecursiveBidirectionalOneToManyTest.java
index 5379ce0278..6c19026a11 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/onetomany/AbstractRecursiveBidirectionalOneToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/onetomany/AbstractRecursiveBidirectionalOneToManyTest.java
@@ -1,192 +1,192 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.onetomany;
 import java.util.ArrayList;
 import org.hibernate.CacheMode;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 /**
  *  What is done:
  *    ___                   ___
  *   |   |                 |   |
  *    -> 1                  -> 1
  *       |   -transform->     / \
  *       2                   2   3
  *       |
  *     	 3
  *
  * @author Burkhard Graves
  * @author Gail Badner
  */
 @SuppressWarnings( {"UnusedDeclaration"})
 public abstract class AbstractRecursiveBidirectionalOneToManyTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "onetomany/Node.hbm.xml" };
 	}
 
 	@Override
-	public org.hibernate.classic.Session openSession() {
-		org.hibernate.classic.Session s = super.openSession();
+	public Session openSession() {
+		Session s = super.openSession();
 		s.setCacheMode( getSessionCacheMode() );
 		return s;
 	}
 
 	protected abstract CacheMode getSessionCacheMode();
 
 	@Test
 	public void testOneToManyMoveElement() {
 		init();
 		transformMove();
 		check( false );
 		delete();
 	}
 
 	@Test
 	public void testOneToManyMoveElementWithDirtySimpleProperty() {
 		init();
 		transformMoveWithDirtySimpleProperty();
 		check( true );
 		delete();
 	}
 
 	@Test
 	public void testOneToManyReplaceList() {
 		init();
 		transformReplace();
 		check( false );
 		delete();
 	}
 
 	void init() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 
 		Node node1 = new Node( 1, "node1" );
 		Node node2 = new Node( 2, "node2" );
 		Node node3 = new Node( 3, "node3" );
 
 		node1.addSubNode( node2 );
 		node2.addSubNode( node3 );
 
 		s.save(node1);
 
 		tx.commit();
 		s.close();
 	}
 
 	void transformMove() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 
 		Node node3 = (Node) s.load(Node.class, new Integer(3));
 		Node node2 = node3.getParentNode();
 		Node node1 = node2.getParentNode();
 
 		node2.removeSubNode( node3 );
 		node1.addSubNode( node3 );
 
 		tx.commit();
 		s.close();
 	}
 
 	void transformMoveWithDirtySimpleProperty() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 
 		Node node3 = (Node) s.load(Node.class, new Integer(3));
 		Node node2 = node3.getParentNode();
 		Node node1 = node2.getParentNode();
 
 		node2.removeSubNode( node3 );
 		node1.addSubNode( node3 );
 		node3.setDescription( "node3-updated" );
 
 		tx.commit();
 		s.close();
 	}
 
 	void transformReplace() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 
 		Node node3 = (Node) s.load(Node.class, new Integer(3));
 		Node node2 = node3.getParentNode();
 		Node node1 = node2.getParentNode();
 
 		node2.removeSubNode( node3 );
 		node1.setSubNodes(  new ArrayList() );
 		node1.addSubNode( node2 );
 		node1.addSubNode( node3 );
 
 		tx.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"UnnecessaryBoxing"})
 	void check(boolean simplePropertyUpdated) {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Node node3 = (Node) s.get( Node.class, Integer.valueOf(3) );
 
 		// fails with 2nd level cache enabled
 		assertEquals( 1, node3.getParentNode().getId().intValue() );
 		assertEquals( ( simplePropertyUpdated ? "node3-updated" : "node3" ), node3.getDescription() );
 		assertTrue( node3.getSubNodes().isEmpty() );
 
 		Node node1 = node3.getParentNode();
 		assertNull( node1.getParentNode() );
 		assertEquals( 2, node1.getSubNodes().size() );
 		assertEquals( 2, ( ( Node ) node1.getSubNodes().get( 0 ) ).getId().intValue() );
 		assertEquals( "node1", node1.getDescription() );
 
 		Node node2 = ( Node ) node1.getSubNodes().get( 0 );
 		assertSame( node1, node2.getParentNode() );
 		assertTrue( node2.getSubNodes().isEmpty() );
 		assertEquals( "node2", node2.getDescription() );
 
 		tx.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"UnnecessaryBoxing"})
 	void delete() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Node node1 = ( Node ) s.get(  Node.class, Integer.valueOf( 1 ) );
 		s.delete( node1 );
 		tx.commit();
 		s.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/readonly/AbstractReadOnlyTest.java b/hibernate-core/src/test/java/org/hibernate/test/readonly/AbstractReadOnlyTest.java
index 229a648d98..ac68d95bb3 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/readonly/AbstractReadOnlyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/readonly/AbstractReadOnlyTest.java
@@ -1,76 +1,77 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.readonly;
 import org.hibernate.CacheMode;
+import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Gail Badner
  */
 public abstract class AbstractReadOnlyTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public void configure(Configuration cfg) {
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true");
 		cfg.setProperty( Environment.STATEMENT_BATCH_SIZE, "0" );
 	}
 
 	@Override
 	public String getCacheConcurrencyStrategy() {
 		return null;
 	}
 
-	public org.hibernate.classic.Session openSession() {
-		org.hibernate.classic.Session s = super.openSession();
+	public Session openSession() {
+		Session s = super.openSession();
 		s.setCacheMode( getSessionCacheMode() );
 		return s;
 	}
 
 	protected CacheMode getSessionCacheMode() {
 		return CacheMode.IGNORE;
 	}
 
 	protected void clearCounts() {
 		sessionFactory().getStatistics().clear();
 	}
 
 	protected void assertInsertCount(int expected) {
 		int inserts = ( int ) sessionFactory().getStatistics().getEntityInsertCount();
 		assertEquals( "unexpected insert count", expected, inserts );
 	}
 
 	protected void assertUpdateCount(int expected) {
 		int updates = ( int ) sessionFactory().getStatistics().getEntityUpdateCount();
 		assertEquals( "unexpected update counts", expected, updates );
 	}
 
 	protected void assertDeleteCount(int expected) {
 		int deletes = ( int ) sessionFactory().getStatistics().getEntityDeleteCount();
 		assertEquals( "unexpected delete counts", expected, deletes );
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/test/java/org/hibernate/test/subclassfilter/DiscrimSubclassFilterTest.java b/hibernate-core/src/test/java/org/hibernate/test/subclassfilter/DiscrimSubclassFilterTest.java
index 3c40ff14fb..910e57c789 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/subclassfilter/DiscrimSubclassFilterTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/subclassfilter/DiscrimSubclassFilterTest.java
@@ -1,147 +1,147 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.subclassfilter;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Steve Ebersole
  */
 public class DiscrimSubclassFilterTest extends BaseCoreFunctionalTestCase {
 	public final String[] getMappings() {
 		return new String[] { "subclassfilter/discrim-subclass.hbm.xml" };
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testFiltersWithSubclass() {
 		Session s = openSession();
 		s.enableFilter( "region" ).setParameter( "userRegion", "US" );
 		Transaction t = s.beginTransaction();
 
 		prepareTestData( s );
 		s.clear();
 
 		List results;
 		Iterator itr;
 
 		results = s.createQuery( "from Person" ).list();
 		assertEquals( "Incorrect qry result count", 4, results.size() );
 		s.clear();
 
 		results = s.createQuery( "from Employee" ).list();
 		assertEquals( "Incorrect qry result count", 2, results.size() );
 		s.clear();
 
 		results = new ArrayList( new HashSet( s.createQuery( "from Person as p left join fetch p.minions" ).list() ) );
 		assertEquals( "Incorrect qry result count", 4, results.size() );
 		itr = results.iterator();
 		while ( itr.hasNext() ) {
 			// find john
 			final Person p = ( Person ) itr.next();
 			if ( p.getName().equals( "John Doe" ) ) {
 				Employee john = ( Employee ) p;
 				assertEquals( "Incorrect fecthed minions count", 1, john.getMinions().size() );
 				break;
 			}
 		}
 		s.clear();
 
 		results = new ArrayList( new HashSet( s.createQuery( "from Employee as p left join fetch p.minions" ).list() ) );
 		assertEquals( "Incorrect qry result count", 2, results.size() );
 		itr = results.iterator();
 		while ( itr.hasNext() ) {
 			// find john
 			final Person p = ( Person ) itr.next();
 			if ( p.getName().equals( "John Doe" ) ) {
 				Employee john = ( Employee ) p;
 				assertEquals( "Incorrect fecthed minions count", 1, john.getMinions().size() );
 				break;
 			}
 		}
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete Customer where contactOwner is not null" ).executeUpdate();
 		s.createQuery( "delete Employee where manager is not null" ).executeUpdate();
 		s.createQuery( "delete Person" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	private void prepareTestData(Session s) {
 		Employee john = new Employee("John Doe");
 		john.setCompany( "JBoss" );
 		john.setDepartment( "hr" );
 		john.setTitle( "hr guru" );
 		john.setRegion( "US" );
 
 		Employee polli = new Employee("Polli Wog");
 		polli.setCompany( "JBoss" );
 		polli.setDepartment( "hr" );
 		polli.setTitle( "hr novice" );
 		polli.setRegion( "US" );
 		polli.setManager( john );
 		john.getMinions().add( polli );
 
 		Employee suzie = new Employee( "Suzie Q" );
 		suzie.setCompany( "JBoss" );
 		suzie.setDepartment( "hr" );
 		suzie.setTitle( "hr novice" );
 		suzie.setRegion( "EMEA" );
 		suzie.setManager( john );
 		john.getMinions().add( suzie );
 
 		Customer cust = new Customer( "John Q Public" );
 		cust.setCompany( "Acme" );
 		cust.setRegion( "US" );
 		cust.setContactOwner( john );
 
 		Person ups = new Person( "UPS guy" );
 		ups.setCompany( "UPS" );
 		ups.setRegion( "US" );
 
 		s.save( john );
 		s.save( cust );
 		s.save( ups );
 
 		s.flush();
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/subclassfilter/JoinedSubclassFilterTest.java b/hibernate-core/src/test/java/org/hibernate/test/subclassfilter/JoinedSubclassFilterTest.java
index 98805f1b73..31af9124ed 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/subclassfilter/JoinedSubclassFilterTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/subclassfilter/JoinedSubclassFilterTest.java
@@ -1,158 +1,158 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.subclassfilter;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Steve Ebersole
  */
 public class JoinedSubclassFilterTest extends BaseCoreFunctionalTestCase {
 	public final String[] getMappings() {
 		return new String[] { "subclassfilter/joined-subclass.hbm.xml" };
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testFiltersWithJoinedSubclass() {
 		Session s = openSession();
 		s.enableFilter( "region" ).setParameter( "userRegion", "US" );
 		Transaction t = s.beginTransaction();
 
 		prepareTestData( s );
 		s.clear();
 
 		List results = s.createQuery( "from Person" ).list();
 		assertEquals( "Incorrect qry result count", 4, results.size() );
 		s.clear();
 
 		results = s.createQuery( "from Employee" ).list();
 		assertEquals( "Incorrect qry result count", 2, results.size() );
 		Iterator itr = results.iterator();
 		while ( itr.hasNext() ) {
 			// find john
 			final Person p = ( Person ) itr.next();
 			if ( p.getName().equals( "John Doe" ) ) {
 				Employee john = ( Employee ) p;
 				assertEquals( "Incorrect fecthed minions count", 2, john.getMinions().size() );
 				break;
 			}
 		}
 		s.clear();
 
 		// TODO : currently impossible to define a collection-level filter w/ joined-subclass elements that will filter based on a superclass column and function correctly in (theta only?) outer joins;
 		// this is consistent with the behaviour of a collection-level where.
 		// this might be one argument for "pulling" the attached class-level filters into collection assocations,
 		// although we'd need some way to apply the appropriate alias in that scenario.
 		results = new ArrayList( new HashSet( s.createQuery( "from Person as p left join fetch p.minions" ).list() ) );
 		assertEquals( "Incorrect qry result count", 4, results.size() );
 		itr = results.iterator();
 		while ( itr.hasNext() ) {
 			// find john
 			final Person p = ( Person ) itr.next();
 			if ( p.getName().equals( "John Doe" ) ) {
 				Employee john = ( Employee ) p;
 				assertEquals( "Incorrect fecthed minions count", 2, john.getMinions().size() );
 				break;
 			}
 		}
 		s.clear();
 
 		results = new ArrayList( new HashSet( s.createQuery( "from Employee as p left join fetch p.minions" ).list() ) );
 		assertEquals( "Incorrect qry result count", 2, results.size() );
 		itr = results.iterator();
 		while ( itr.hasNext() ) {
 			// find john
 			final Person p = ( Person ) itr.next();
 			if ( p.getName().equals( "John Doe" ) ) {
 				Employee john = ( Employee ) p;
 				assertEquals( "Incorrect fecthed minions count", 2, john.getMinions().size() );
 				break;
 			}
 		}
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete Customer where contactOwner is not null" ).executeUpdate();
 		s.createQuery( "delete Employee where manager is not null" ).executeUpdate();
 		s.createQuery( "delete Person" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	private void prepareTestData(Session s) {
 		Employee john = new Employee("John Doe");
 		john.setCompany( "JBoss" );
 		john.setDepartment( "hr" );
 		john.setTitle( "hr guru" );
 		john.setRegion( "US" );
 
 		Employee polli = new Employee("Polli Wog");
 		polli.setCompany( "JBoss" );
 		polli.setDepartment( "hr" );
 		polli.setTitle( "hr novice" );
 		polli.setRegion( "US" );
 		polli.setManager( john );
 		john.getMinions().add( polli );
 
 		Employee suzie = new Employee( "Suzie Q" );
 		suzie.setCompany( "JBoss" );
 		suzie.setDepartment( "hr" );
 		suzie.setTitle( "hr novice" );
 		suzie.setRegion( "EMEA" );
 		suzie.setManager( john );
 		john.getMinions().add( suzie );
 
 		Customer cust = new Customer( "John Q Public" );
 		cust.setCompany( "Acme" );
 		cust.setRegion( "US" );
 		cust.setContactOwner( john );
 
 		Person ups = new Person( "UPS guy" );
 		ups.setCompany( "UPS" );
 		ups.setRegion( "US" );
 
 		s.save( john );
 		s.save( cust );
 		s.save( ups );
 
 		s.flush();
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/subclassfilter/UnionSubclassFilterTest.java b/hibernate-core/src/test/java/org/hibernate/test/subclassfilter/UnionSubclassFilterTest.java
index dcf4eb88eb..3fbfcc4ce2 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/subclassfilter/UnionSubclassFilterTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/subclassfilter/UnionSubclassFilterTest.java
@@ -1,146 +1,148 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.subclassfilter;
 
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Steve Ebersole
  */
 public class UnionSubclassFilterTest extends BaseCoreFunctionalTestCase {
 	public final String[] getMappings() {
 		return new String[] { "subclassfilter/union-subclass.hbm.xml" };
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testFiltersWithUnionSubclass() {
 		Session s = openSession();
 		s.enableFilter( "region" ).setParameter( "userRegion", "US" );
 		Transaction t = s.beginTransaction();
 
 		prepareTestData( s );
 		s.clear();
 
 		List results;
 		Iterator itr;
 
 		results = s.createQuery( "from Person" ).list();
 		assertEquals( "Incorrect qry result count", 4, results.size() );
 		s.clear();
 
 		results = s.createQuery( "from Employee" ).list();
 		assertEquals( "Incorrect qry result count", 2, results.size() );
 		s.clear();
 
 		results = new ArrayList( new HashSet( s.createQuery( "from Person as p left join fetch p.minions" ).list() ) );
 		assertEquals( "Incorrect qry result count", 4, results.size() );
 		itr = results.iterator();
 		while ( itr.hasNext() ) {
 			// find john
 			final Person p = ( Person ) itr.next();
 			if ( p.getName().equals( "John Doe" ) ) {
 				Employee john = ( Employee ) p;
 				assertEquals( "Incorrect fecthed minions count", 1, john.getMinions().size() );
 				break;
 			}
 		}
 		s.clear();
 
 		results = new ArrayList( new HashSet( s.createQuery( "from Employee as p left join fetch p.minions" ).list() ) );
 		assertEquals( "Incorrect qry result count", 2, results.size() );
 		itr = results.iterator();
 		while ( itr.hasNext() ) {
 			// find john
 			final Person p = ( Person ) itr.next();
 			if ( p.getName().equals( "John Doe" ) ) {
 				Employee john = ( Employee ) p;
 				assertEquals( "Incorrect fecthed minions count", 1, john.getMinions().size() );
 				break;
 			}
 		}
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
-		s.delete( "from Person" );
+		for ( Object entity : s.createQuery( "from Person" ).list() ) {
+			s.delete( entity );
+		}
 		t.commit();
 		s.close();
 
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	private void prepareTestData(Session s) {
 		Employee john = new Employee( "John Doe" );
 		john.setCompany( "JBoss" );
 		john.setDepartment( "hr" );
 		john.setTitle( "hr guru" );
 		john.setRegion( "US" );
 
 		Employee polli = new Employee( "Polli Wog" );
 		polli.setCompany( "JBoss" );
 		polli.setDepartment( "hr" );
 		polli.setTitle( "hr novice" );
 		polli.setRegion( "US" );
 		polli.setManager( john );
 		john.getMinions().add( polli );
 
 		Employee suzie = new Employee( "Suzie Q" );
 		suzie.setCompany( "JBoss" );
 		suzie.setDepartment( "hr" );
 		suzie.setTitle( "hr novice" );
 		suzie.setRegion( "EMEA" );
 		suzie.setManager( john );
 		john.getMinions().add( suzie );
 
 		Customer cust = new Customer( "John Q Public" );
 		cust.setCompany( "Acme" );
 		cust.setRegion( "US" );
 		cust.setContactOwner( john );
 
 		Person ups = new Person( "UPS guy" );
 		ups.setCompany( "UPS" );
 		ups.setRegion( "US" );
 
 		s.save( john );
 		s.save( cust );
 		s.save( ups );
 
 		s.flush();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/ternary/TernaryTest.java b/hibernate-core/src/test/java/org/hibernate/test/ternary/TernaryTest.java
index 9032b5dc47..9a466f43d3 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/ternary/TernaryTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/ternary/TernaryTest.java
@@ -1,150 +1,152 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.ternary;
 
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.Hibernate;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Gavin King
  */
 public class TernaryTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "ternary/Ternary.hbm.xml" };
 	}
 
 	@Override
 	public String getCacheConcurrencyStrategy() {
 		return null;
 	}
 
 	@Test
 	public void testTernary() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Employee bob = new Employee("Bob");
 		Employee tom = new Employee("Tom");
 		Employee jim = new Employee("Jim");
 		Employee tim = new Employee("Tim");
 		Site melb = new Site("Melbourne");
 		Site geel = new Site("Geelong");
 		s.persist(bob);
 		s.persist(tom);
 		s.persist(jim);
 		s.persist(tim);
 		s.persist(melb);
 		s.persist(geel);
 		bob.getManagerBySite().put(melb, tom);
 		bob.getManagerBySite().put(geel, jim);
 		tim.getManagerBySite().put(melb, tom);
 		t.commit();
 		s.close();
 		
 		s = openSession();
 		t = s.beginTransaction();
 		tom = (Employee) s.get(Employee.class, "Tom");
 		assertFalse( Hibernate.isInitialized(tom.getUnderlings()) );
 		assertEquals( tom.getUnderlings().size(), 2 );
 		bob = (Employee) s.get(Employee.class, "Bob");
 		assertFalse( Hibernate.isInitialized(bob.getManagerBySite()) );
 		assertTrue( tom.getUnderlings().contains(bob) );
 		melb = (Site) s.get(Site.class, "Melbourne");
 		assertSame( bob.getManagerBySite().get(melb), tom );
 		assertTrue( melb.getEmployees().contains(bob) );
 		assertTrue( melb.getManagers().contains(tom) );
 		t.commit();
 		s.close();		
 
 		s = openSession();
 		t = s.beginTransaction();
 		List l = s.createQuery("from Employee e join e.managerBySite m where m.name='Bob'").list();
 		assertEquals( l.size(), 0 );
 		l = s.createQuery("from Employee e join e.managerBySite m where m.name='Tom'").list();
 		assertEquals( l.size(), 2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		l = s.createQuery("from Employee e left join fetch e.managerBySite").list();
 		assertEquals( l.size(), 5 );
 		Set set = new HashSet(l);
 		assertEquals( set.size(), 4 );
 		Iterator iter = set.iterator();
 		int total=0;
 		while ( iter.hasNext() ) {
 			Map map = ( (Employee) iter.next() ).getManagerBySite();
 			assertTrue( Hibernate.isInitialized(map) );
 			total += map.size();
 		}
 		assertTrue(total==3);
 
 		l = s.createQuery("from Employee e left join e.managerBySite m left join m.managerBySite m2").list();
 
 		// clean up...
 		l = s.createQuery("from Employee e left join fetch e.managerBySite").list();
 		Iterator itr = l.iterator();
 		while ( itr.hasNext() ) {
 			Employee emp = ( Employee ) itr.next();
 			emp.setManagerBySite( new HashMap() );
 			s.delete( emp );
 		}
-		((org.hibernate.classic.Session)s).delete("from Site");
+		for ( Object entity : s.createQuery( "from Site" ).list() ) {
+			s.delete( entity );
+		}
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testIndexRelatedFunctions() {
 		Session session = openSession();
 		session.beginTransaction();
 		session.createQuery( "from Employee e join e.managerBySite as m where index(m) is not null" )
 				.list();
 		session.createQuery( "from Employee e join e.managerBySite as m where minIndex(m) is not null" )
 				.list();
 		session.createQuery( "from Employee e join e.managerBySite as m where maxIndex(m) is not null" )
 				.list();
 		session.getTransaction().commit();
 		session.close();
 	}
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/typeparameters/TypeParameterTest.java b/hibernate-core/src/test/java/org/hibernate/test/typeparameters/TypeParameterTest.java
index db1f6e31d0..cf165f40c4 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/typeparameters/TypeParameterTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/typeparameters/TypeParameterTest.java
@@ -1,150 +1,150 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.typeparameters;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
+import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.classic.Session;
 import org.hibernate.jdbc.Work;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Test for parameterizable types.
  * 
  * @author Michael Gloegl
  */
 public class TypeParameterTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] {
 				"typeparameters/Typedef.hbm.xml",
 				"typeparameters/Widget.hbm.xml"
 		};
 	}
 
 	@Test
 	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	public void testSave() throws Exception {
 		deleteData();
 
 		Session s = openSession();
 		s.beginTransaction();
 		Widget obj = new Widget();
 		obj.setValueThree(5);
 		final Integer id = (Integer) s.save(obj);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 
 		s.doWork(
 				new Work() {
 					@Override
 					public void execute(Connection connection) throws SQLException {
 						PreparedStatement statement = connection.prepareStatement("SELECT * FROM STRANGE_TYPED_OBJECT WHERE ID=?");
 						statement.setInt(1, id.intValue());
 						ResultSet resultSet = statement.executeQuery();
 
 						assertTrue("A row should have been returned", resultSet.next());
 						assertTrue("Default value should have been mapped to null", resultSet.getObject("VALUE_ONE") == null);
 						assertTrue("Default value should have been mapped to null", resultSet.getObject("VALUE_TWO") == null);
 						assertEquals("Non-Default value should not be changed", resultSet.getInt("VALUE_THREE"), 5);
 						assertTrue("Default value should have been mapped to null", resultSet.getObject("VALUE_FOUR") == null);
 					}
 				}
 		);
 
 		s.getTransaction().commit();
 		s.close();
 
 		deleteData();
 	}
 
 	@Test
 	public void testLoading() throws Exception {
 		initData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Widget obj = (Widget) s.createQuery("from Widget o where o.string = :string").setString("string", "all-normal").uniqueResult();
 		assertEquals("Non-Default value incorrectly loaded", obj.getValueOne(), 7);
 		assertEquals("Non-Default value incorrectly loaded", obj.getValueTwo(), 8);
 		assertEquals("Non-Default value incorrectly loaded", obj.getValueThree(), 9);
 		assertEquals("Non-Default value incorrectly loaded", obj.getValueFour(), 10);
 
 		obj = (Widget) s.createQuery("from Widget o where o.string = :string").setString("string", "all-default").uniqueResult();
 		assertEquals("Default value incorrectly loaded", obj.getValueOne(), 1);
 		assertEquals("Default value incorrectly loaded", obj.getValueTwo(), 2);
 		assertEquals("Default value incorrectly loaded", obj.getValueThree(), -1);
 		assertEquals("Default value incorrectly loaded", obj.getValueFour(), -5);
 
 		
 		t.commit();
 		s.close();
 		deleteData();
 	}
 
 	private void initData() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Widget obj = new Widget();
 		obj.setValueOne(7);
 		obj.setValueTwo(8);
 		obj.setValueThree(9);
 		obj.setValueFour(10);
 		obj.setString("all-normal");
 		s.save(obj);
 
 		obj = new Widget();
 		obj.setValueOne(1);
 		obj.setValueTwo(2);
 		obj.setValueThree(-1);
 		obj.setValueFour(-5);
 		obj.setString("all-default");
 		s.save(obj);
 
 		t.commit();
 		s.close();
 	}
 
 	private void deleteData() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.createQuery( "delete from Widget" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 }
\ No newline at end of file
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3DeleteEventListener.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3DeleteEventListener.java
index ae5675f30f..05953195de 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3DeleteEventListener.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/event/EJB3DeleteEventListener.java
@@ -1,65 +1,64 @@
 /*
  * Copyright (c) 2009, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb.event;
 import java.io.Serializable;
 import org.hibernate.event.DeleteEvent;
 import org.hibernate.event.EventSource;
 import org.hibernate.event.def.DefaultDeleteEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Overrides the LifeCycle OnSave call to call the PreRemove operation
  *
  * @author Emmanuel Bernard
  */
 public class EJB3DeleteEventListener extends DefaultDeleteEventListener implements CallbackHandlerConsumer {
 	private EntityCallbackHandler callbackHandler;
 
 	public void setCallbackHandler(EntityCallbackHandler callbackHandler) {
 		this.callbackHandler = callbackHandler;
 	}
 
 	public EJB3DeleteEventListener() {
 		super();
 	}
 
 	public EJB3DeleteEventListener(EntityCallbackHandler callbackHandler) {
 		this();
 		this.callbackHandler = callbackHandler;
 	}
 
 	@Override
-	protected boolean invokeDeleteLifecycle(EventSource session, Object entity, EntityPersister persister) {
+	protected void invokeDeleteLifecycle(EventSource session, Object entity, EntityPersister persister) {
 		callbackHandler.preRemove( entity );
-		return super.invokeDeleteLifecycle( session, entity, persister );
 	}
 
 	@Override
 	protected void performDetachedEntityDeletionCheck(DeleteEvent event) {
 		EventSource source = event.getSession();
 		String entityName = event.getEntityName();
 		EntityPersister persister = source.getEntityPersister( entityName, event.getObject() );
 		Serializable id =  persister.getIdentifier( event.getObject(), source );
 		entityName = entityName == null ? source.guessEntityName( event.getObject() ) : entityName; 
 		throw new IllegalArgumentException("Removing a detached instance "+ entityName + "#" + id);
 	}
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/bulk/BulkOperationsTestCase.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/bulk/BulkOperationsTestCase.java
index 389cb987c9..3cbf2000a1 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/bulk/BulkOperationsTestCase.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/bulk/BulkOperationsTestCase.java
@@ -1,421 +1,421 @@
 /*
  * JBoss, Home of Professional Open Source.
  * Copyright 2009, Red Hat, Inc. and/or it's affiliates, and individual contributors
  * as indicated by the @author tags. See the copyright.txt file in the
  * distribution for a full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as
  * published by the Free Software Foundation; either version 2.1 of
  * the License, or (at your option) any later version.
  *
  * This software is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this software; if not, write to the Free
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
 package org.hibernate.test.cache.infinispan.functional.bulk;
 
 import javax.transaction.Status;
 import javax.transaction.TransactionManager;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 import org.hibernate.FlushMode;
+import org.hibernate.Session;
 import org.hibernate.cache.RegionFactory;
 import org.hibernate.cache.infinispan.InfinispanRegionFactory;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
-import org.hibernate.classic.Session;
 import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
 import org.hibernate.engine.transaction.spi.TransactionFactory;
 import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.jta.platform.internal.JtaPlatformInitiator;
 import org.hibernate.service.jta.platform.spi.JtaPlatform;
 import org.hibernate.stat.SecondLevelCacheStatistics;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.hibernate.test.cache.infinispan.functional.Contact;
 import org.hibernate.test.cache.infinispan.functional.Customer;
 import org.hibernate.test.cache.infinispan.tm.JtaPlatformImpl;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 
 /**
  * BulkOperationsTestCase.
  *
  * @author Galder Zamarreo
  * @since 3.5
  */
 public class BulkOperationsTestCase extends BaseCoreFunctionalTestCase {
 	private TransactionManager tm;
 
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 				"cache/infinispan/functional/Contact.hbm.xml",
 				"cache/infinispan/functional/Customer.hbm.xml"
 		};
 	}
 
 	@Override
 	public String getCacheConcurrencyStrategy() {
 		return "transactional";
 	}
 
 	protected Class<? extends RegionFactory> getCacheRegionFactory() {
 		return InfinispanRegionFactory.class;
 	}
 
 	protected Class<? extends TransactionFactory> getTransactionFactoryClass() {
 		return CMTTransactionFactory.class;
 	}
 
 	protected Class<? extends ConnectionProvider> getConnectionProviderClass() {
 		return org.hibernate.test.cache.infinispan.tm.XaConnectionProvider.class;
 	}
 
 	protected JtaPlatform getJtaPlatform() {
 		return new JtaPlatformImpl();
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.USE_SECOND_LEVEL_CACHE, "true" );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 		cfg.setProperty( Environment.USE_QUERY_CACHE, "false" );
 		cfg.setProperty( Environment.CACHE_REGION_FACTORY, getCacheRegionFactory().getName() );
 		cfg.setProperty( Environment.TRANSACTION_STRATEGY, getTransactionFactoryClass().getName() );
 		cfg.getProperties().put( JtaPlatformInitiator.JTA_PLATFORM, getJtaPlatform() );
 		cfg.setProperty( Environment.CONNECTION_PROVIDER, getConnectionProviderClass().getName() );
 	}
 
 	@Test
 	public void testBulkOperations() throws Throwable {
 		boolean cleanedUp = false;
 		try {
 			tm = getJtaPlatform().retrieveTransactionManager();
 
 			createContacts();
 
 			List<Integer> rhContacts = getContactsByCustomer( "Red Hat" );
 			assertNotNull( "Red Hat contacts exist", rhContacts );
 			assertEquals( "Created expected number of Red Hat contacts", 10, rhContacts.size() );
 
 			SecondLevelCacheStatistics contactSlcs = sessionFactory()
 					.getStatistics()
 					.getSecondLevelCacheStatistics( Contact.class.getName() );
 			assertEquals( 20, contactSlcs.getElementCountInMemory() );
 
 			assertEquals( "Deleted all Red Hat contacts", 10, deleteContacts() );
 			assertEquals( 0, contactSlcs.getElementCountInMemory() );
 
 			List<Integer> jbContacts = getContactsByCustomer( "JBoss" );
 			assertNotNull( "JBoss contacts exist", jbContacts );
 			assertEquals( "JBoss contacts remain", 10, jbContacts.size() );
 
 			for ( Integer id : rhContacts ) {
 				assertNull( "Red Hat contact " + id + " cannot be retrieved", getContact( id ) );
 			}
 			rhContacts = getContactsByCustomer( "Red Hat" );
 			if ( rhContacts != null ) {
 				assertEquals( "No Red Hat contacts remain", 0, rhContacts.size() );
 			}
 
 			updateContacts( "Kabir", "Updated" );
 			assertEquals( 0, contactSlcs.getElementCountInMemory() );
 			for ( Integer id : jbContacts ) {
 				Contact contact = getContact( id );
 				assertNotNull( "JBoss contact " + id + " exists", contact );
 				String expected = ("Kabir".equals( contact.getName() )) ? "Updated" : "2222";
 				assertEquals( "JBoss contact " + id + " has correct TLF", expected, contact.getTlf() );
 			}
 
 			List<Integer> updated = getContactsByTLF( "Updated" );
 			assertNotNull( "Got updated contacts", updated );
 			assertEquals( "Updated contacts", 5, updated.size() );
 
 			updateContactsWithOneManual( "Kabir", "UpdatedAgain" );
 			assertEquals( contactSlcs.getElementCountInMemory(), 0 );
 			for ( Integer id : jbContacts ) {
 				Contact contact = getContact( id );
 				assertNotNull( "JBoss contact " + id + " exists", contact );
 				String expected = ("Kabir".equals( contact.getName() )) ? "UpdatedAgain" : "2222";
 				assertEquals( "JBoss contact " + id + " has correct TLF", expected, contact.getTlf() );
 			}
 
 			updated = getContactsByTLF( "UpdatedAgain" );
 			assertNotNull( "Got updated contacts", updated );
 			assertEquals( "Updated contacts", 5, updated.size() );
 		}
 		catch (Throwable t) {
 			cleanedUp = true;
 			cleanup( true );
 			throw t;
 		}
 		finally {
 			// cleanup the db so we can run this test multiple times w/o restarting the cluster
 			if ( !cleanedUp ) {
 				cleanup( false );
 			}
 		}
 	}
 
 	public void createContacts() throws Exception {
 		tm.begin();
 		try {
 			for ( int i = 0; i < 10; i++ ) {
 				createCustomer( i );
 			}
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				tm.rollback();
 			}
 		}
 	}
 
 	public int deleteContacts() throws Exception {
 		String deleteHQL = "delete Contact where customer in ";
 		deleteHQL += " (select customer FROM Customer as customer ";
 		deleteHQL += " where customer.name = :cName)";
 
 		tm.begin();
 		try {
 			Session session = sessionFactory().getCurrentSession();
 			int rowsAffected = session.createQuery( deleteHQL ).setFlushMode( FlushMode.AUTO )
 					.setParameter( "cName", "Red Hat" ).executeUpdate();
 			tm.commit();
 			return rowsAffected;
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				try {
 					tm.rollback();
 				}
 				catch (Exception ee) {
 					// ignored
 				}
 			}
 		}
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	public List<Integer> getContactsByCustomer(String customerName) throws Exception {
 		String selectHQL = "select contact.id from Contact contact";
 		selectHQL += " where contact.customer.name = :cName";
 
 		tm.begin();
 		try {
 
 			Session session = sessionFactory().getCurrentSession();
 			return session.createQuery( selectHQL )
 					.setFlushMode( FlushMode.AUTO )
 					.setParameter( "cName", customerName )
 					.list();
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				tm.rollback();
 			}
 		}
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	public List<Integer> getContactsByTLF(String tlf) throws Exception {
 		String selectHQL = "select contact.id from Contact contact";
 		selectHQL += " where contact.tlf = :cTLF";
 
 		tm.begin();
 		try {
 			Session session = sessionFactory().getCurrentSession();
 			return session.createQuery( selectHQL )
 					.setFlushMode( FlushMode.AUTO )
 					.setParameter( "cTLF", tlf )
 					.list();
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				tm.rollback();
 			}
 		}
 	}
 
 	public int updateContacts(String name, String newTLF) throws Exception {
 		String updateHQL = "update Contact set tlf = :cNewTLF where name = :cName";
 		tm.begin();
 		try {
 			Session session = sessionFactory().getCurrentSession();
 			return session.createQuery( updateHQL )
 					.setFlushMode( FlushMode.AUTO )
 					.setParameter( "cNewTLF", newTLF )
 					.setParameter( "cName", name )
 					.executeUpdate();
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				tm.rollback();
 			}
 		}
 	}
 
 	public int updateContactsWithOneManual(String name, String newTLF) throws Exception {
 		String queryHQL = "from Contact c where c.name = :cName";
 		String updateHQL = "update Contact set tlf = :cNewTLF where name = :cName";
 		tm.begin();
 		try {
 			Session session = sessionFactory().getCurrentSession();
 			@SuppressWarnings("unchecked")
 			List<Contact> list = session.createQuery( queryHQL ).setParameter( "cName", name ).list();
 			list.get( 0 ).setTlf( newTLF );
 			return session.createQuery( updateHQL )
 					.setFlushMode( FlushMode.AUTO )
 					.setParameter( "cNewTLF", newTLF )
 					.setParameter( "cName", name )
 					.executeUpdate();
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				tm.rollback();
 			}
 		}
 	}
 
 	public Contact getContact(Integer id) throws Exception {
 		tm.begin();
 		try {
 			Session session = sessionFactory().getCurrentSession();
 			return (Contact) session.get( Contact.class, id );
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				tm.rollback();
 			}
 		}
 	}
 
 	public void cleanup(boolean ignore) throws Exception {
 		String deleteContactHQL = "delete from Contact";
 		String deleteCustomerHQL = "delete from Customer";
 		tm.begin();
 		try {
 			Session session = sessionFactory().getCurrentSession();
 			session.createQuery( deleteContactHQL ).setFlushMode( FlushMode.AUTO ).executeUpdate();
 			session.createQuery( deleteCustomerHQL ).setFlushMode( FlushMode.AUTO ).executeUpdate();
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				if ( !ignore ) {
 					try {
 						tm.rollback();
 					}
 					catch (Exception ee) {
 						// ignored
 					}
 				}
 			}
 		}
 	}
 
 	private Customer createCustomer(int id) throws Exception {
 		System.out.println( "CREATE CUSTOMER " + id );
 		try {
 			Customer customer = new Customer();
 			customer.setName( (id % 2 == 0) ? "JBoss" : "Red Hat" );
 			Set<Contact> contacts = new HashSet<Contact>();
 
 			Contact kabir = new Contact();
 			kabir.setCustomer( customer );
 			kabir.setName( "Kabir" );
 			kabir.setTlf( "1111" );
 			contacts.add( kabir );
 
 			Contact bill = new Contact();
 			bill.setCustomer( customer );
 			bill.setName( "Bill" );
 			bill.setTlf( "2222" );
 			contacts.add( bill );
 
 			customer.setContacts( contacts );
 
 			Session s = openSession();
 			s.getTransaction().begin();
 			s.persist( customer );
 			s.getTransaction().commit();
 			s.close();
 
 			return customer;
 		}
 		finally {
 			System.out.println( "CREATE CUSTOMER " + id + " -  END" );
 		}
 	}
 
 }
diff --git a/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseCoreFunctionalTestCase.java b/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseCoreFunctionalTestCase.java
index 3d43a69787..a3e41afe09 100644
--- a/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseCoreFunctionalTestCase.java
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseCoreFunctionalTestCase.java
@@ -1,406 +1,401 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.testing.junit4;
 
 import java.io.InputStream;
 import java.sql.Blob;
 import java.sql.Clob;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.Session;
 import org.hibernate.cache.HashtableCacheProvider;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.Mappings;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.SessionFactoryImplementor;
 import org.hibernate.engine.SessionImplementor;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.jdbc.Work;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.service.internal.ServiceRegistryImpl;
 
 import org.junit.After;
 import org.junit.Before;
 
 import org.hibernate.testing.AfterClassOnce;
 import org.hibernate.testing.BeforeClassOnce;
 import org.hibernate.testing.OnExpectedFailure;
 import org.hibernate.testing.OnFailure;
 import org.hibernate.testing.SkipLog;
 
 import static org.junit.Assert.fail;
 
 /**
  * Applies functional testing logic for core Hibernate testing on top of {@link BaseUnitTestCase}
  *
  * @author Steve Ebersole
  */
 public abstract class BaseCoreFunctionalTestCase extends BaseUnitTestCase {
 	public static final String VALIDATE_DATA_CLEANUP = "hibernate.test.validateDataCleanup";
 	public static final Dialect DIALECT = Dialect.getDialect();
 
 	private Configuration configuration;
 	private ServiceRegistryImpl serviceRegistry;
 	private SessionFactoryImplementor sessionFactory;
 
-	private org.hibernate.classic.Session session;
+	private Session session;
 
-	protected Dialect getDialect() {
+	protected static Dialect getDialect() {
 		return DIALECT;
 	}
 
 	protected Configuration configuration() {
 		return configuration;
 	}
 
 	protected ServiceRegistryImpl serviceRegistry() {
 		return serviceRegistry;
 	}
 
 	protected SessionFactoryImplementor sessionFactory() {
 		return sessionFactory;
 	}
 
-	protected org.hibernate.classic.Session openSession() throws HibernateException {
+	protected Session openSession() throws HibernateException {
 		session = sessionFactory().openSession();
 		return session;
 	}
 
-	protected org.hibernate.classic.Session openSession(Interceptor interceptor) throws HibernateException {
+	protected Session openSession(Interceptor interceptor) throws HibernateException {
 		session = sessionFactory().openSession(interceptor);
 		return session;
 	}
 
 
 	// before/after test class ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@BeforeClassOnce
 	private void buildSessionFactory() {
 		configuration = buildConfiguration();
 		serviceRegistry = buildServiceRegistry( configuration );
 		sessionFactory = (SessionFactoryImplementor) configuration.buildSessionFactory( serviceRegistry );
 		afterSessionFactoryBuilt();
 	}
 
 	protected Configuration buildConfiguration() {
 		Configuration cfg = constructConfiguration();
 		configure( cfg );
 		addMappings( cfg );
 		cfg.buildMappings();
 		applyCacheSettings( cfg );
 		afterConfigurationBuilt( cfg );
 		return cfg;
 	}
 
 	protected Configuration constructConfiguration() {
 		Configuration configuration = new Configuration()
 				.setProperty( Environment.CACHE_PROVIDER, HashtableCacheProvider.class.getName() );
 		configuration.setProperty( Configuration.USE_NEW_ID_GENERATOR_MAPPINGS, "true" );
 		if ( createSchema() ) {
 			configuration.setProperty( Environment.HBM2DDL_AUTO, "create-drop" );
 		}
 		configuration.setProperty( Environment.DIALECT, getDialect().getClass().getName() );
 		return configuration;
 	}
 
 	protected void configure(Configuration configuration) {
 	}
 
 	protected void addMappings(Configuration configuration) {
 		String[] mappings = getMappings();
 		if ( mappings != null ) {
 			for ( String mapping : mappings ) {
 				configuration.addResource(
 						getBaseForMappings() + mapping,
 						getClass().getClassLoader()
 				);
 			}
 		}
 		Class<?>[] annotatedClasses = getAnnotatedClasses();
 		if ( annotatedClasses != null ) {
 			for ( Class<?> annotatedClass : annotatedClasses ) {
 				configuration.addAnnotatedClass( annotatedClass );
 			}
 		}
 		String[] annotatedPackages = getAnnotatedPackages();
 		if ( annotatedPackages != null ) {
 			for ( String annotatedPackage : annotatedPackages ) {
 				configuration.addPackage( annotatedPackage );
 			}
 		}
 		String[] xmlFiles = getXmlFiles();
 		if ( xmlFiles != null ) {
 			for ( String xmlFile : xmlFiles ) {
 				InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( xmlFile );
 				configuration.addInputStream( is );
 			}
 		}
 	}
 
 	protected static final String[] NO_MAPPINGS = new String[0];
 
 	protected String[] getMappings() {
 		return NO_MAPPINGS;
 	}
 
 	protected String getBaseForMappings() {
 		return "org/hibernate/test/";
 	}
 
 	protected static final Class<?>[] NO_CLASSES = new Class[0];
 
 	protected Class<?>[] getAnnotatedClasses() {
 		return NO_CLASSES;
 	}
 
 	protected String[] getAnnotatedPackages() {
 		return NO_MAPPINGS;
 	}
 
 	protected String[] getXmlFiles() {
 		// todo : rename to getOrmXmlFiles()
 		return NO_MAPPINGS;
 	}
 
 	protected void applyCacheSettings(Configuration configuration) {
 		if ( getCacheConcurrencyStrategy() != null ) {
 			Iterator itr = configuration.getClassMappings();
 			while ( itr.hasNext() ) {
 				PersistentClass clazz = (PersistentClass) itr.next();
 				Iterator props = clazz.getPropertyClosureIterator();
 				boolean hasLob = false;
 				while ( props.hasNext() ) {
 					Property prop = (Property) props.next();
 					if ( prop.getValue().isSimpleValue() ) {
 						String type = ( (SimpleValue) prop.getValue() ).getTypeName();
 						if ( "blob".equals(type) || "clob".equals(type) ) {
 							hasLob = true;
 						}
 						if ( Blob.class.getName().equals(type) || Clob.class.getName().equals(type) ) {
 							hasLob = true;
 						}
 					}
 				}
 				if ( !hasLob && !clazz.isInherited() && overrideCacheStrategy() ) {
 					configuration.setCacheConcurrencyStrategy( clazz.getEntityName(), getCacheConcurrencyStrategy() );
 				}
 			}
 			itr = configuration.getCollectionMappings();
 			while ( itr.hasNext() ) {
 				Collection coll = (Collection) itr.next();
 				configuration.setCollectionCacheConcurrencyStrategy( coll.getRole(), getCacheConcurrencyStrategy() );
 			}
 		}
 	}
 
 	protected boolean overrideCacheStrategy() {
 		return true;
 	}
 
 	protected String getCacheConcurrencyStrategy() {
-//		return "nonstrict-read-write";
 		return null;
 	}
 
 	protected void afterConfigurationBuilt(Configuration configuration) {
 		afterConfigurationBuilt( configuration.createMappings(), getDialect() );
 	}
 
 	protected void afterConfigurationBuilt(Mappings mappings, Dialect dialect) {
 	}
 
 	protected ServiceRegistryImpl buildServiceRegistry(Configuration configuration) {
 		Properties properties = new Properties();
 		properties.putAll( configuration.getProperties() );
 		Environment.verifyProperties( properties );
 		ConfigurationHelper.resolvePlaceHolders( properties );
 		ServiceRegistryImpl serviceRegistry = new ServiceRegistryImpl( properties );
 		applyServices( serviceRegistry );
 		return serviceRegistry;
 	}
 
 	protected void applyServices(ServiceRegistryImpl serviceRegistry) {
 	}
 
 	protected void afterSessionFactoryBuilt() {
 	}
 
 	protected boolean createSchema() {
 		return true;
 	}
 
 	protected boolean rebuildSessionFactoryOnError() {
 		return true;
 	}
 
 	@AfterClassOnce
 	private void releaseSessionFactory() {
 		if ( sessionFactory == null ) {
 			return;
 		}
 		sessionFactory.close();
 		sessionFactory = null;
 		configuration = null;
 	}
 
 	@OnFailure
 	@OnExpectedFailure
 	public void onFailure() {
-//		cleanupSession();
-
 		if ( rebuildSessionFactoryOnError() ) {
 			rebuildSessionFactory();
 		}
 	}
 
 	protected void rebuildSessionFactory() {
 		if ( sessionFactory == null ) {
 			return;
 		}
 		sessionFactory.close();
 		serviceRegistry.destroy();
 
 		serviceRegistry = buildServiceRegistry( configuration );
 		sessionFactory = (SessionFactoryImplementor) configuration.buildSessionFactory( serviceRegistry );
 		afterSessionFactoryBuilt();
 	}
 
 
 	// before/after each test ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Before
 	public final void beforeTest() throws Exception {
-		System.out.println( " IN @Before CALLBACK!" );
 		prepareTest();
 	}
 
 	protected void prepareTest() throws Exception {
 	}
 
 	@After
 	public final void afterTest() throws Exception {
-		System.out.println( " IN @After CALLBACK!" );
 		cleanupTest();
 
 		cleanupSession();
 
 		assertAllDataRemoved();
 	}
 
 	private void cleanupSession() {
 		if ( session != null && ! ( (SessionImplementor) session ).isClosed() ) {
 			if ( session.isConnected() ) {
 				session.doWork( new RollbackWork() );
 			}
 			session.close();
 		}
 		session = null;
 	}
 
 	public class RollbackWork implements Work {
 		public void execute(Connection connection) throws SQLException {
 			connection.rollback();
 		}
 	}
 
 	protected void cleanupTest() throws Exception {
 	}
 
 	@SuppressWarnings( {"UnnecessaryBoxing", "UnnecessaryUnboxing"})
 	protected void assertAllDataRemoved() {
 		if ( !createSchema() ) {
 			return; // no tables were created...
 		}
 		if ( !Boolean.getBoolean( VALIDATE_DATA_CLEANUP ) ) {
 			return;
 		}
 
 		Session tmpSession = sessionFactory.openSession();
 		try {
 			List list = tmpSession.createQuery( "select o from java.lang.Object o" ).list();
 
 			Map<String,Integer> items = new HashMap<String,Integer>();
 			if ( !list.isEmpty() ) {
 				for ( Object element : list ) {
 					Integer l = (Integer) items.get( tmpSession.getEntityName( element ) );
 					if ( l == null ) {
 						l = Integer.valueOf( 0 );
 					}
 					l = Integer.valueOf( l.intValue() + 1 ) ;
 					items.put( tmpSession.getEntityName( element ), l );
 					System.out.println( "Data left: " + element );
 				}
 				fail( "Data is left in the database: " + items.toString() );
 			}
 		}
 		finally {
 			try {
 				tmpSession.close();
 			}
 			catch( Throwable t ) {
 				// intentionally empty
 			}
 		}
 	}
 
 	protected boolean readCommittedIsolationMaintained(String scenario) {
 		int isolation = java.sql.Connection.TRANSACTION_READ_UNCOMMITTED;
 		Session testSession = null;
 		try {
 			testSession = openSession();
 			isolation = testSession.connection().getTransactionIsolation();
 		}
 		catch( Throwable ignore ) {
 		}
 		finally {
 			if ( testSession != null ) {
 				try {
 					testSession.close();
 				}
 				catch( Throwable ignore ) {
 				}
 			}
 		}
 		if ( isolation < java.sql.Connection.TRANSACTION_READ_COMMITTED ) {
 			SkipLog.reportSkip( "environment does not support at least read committed isolation", scenario );
 			return false;
 		}
 		else {
 			return true;
 		}
 	}
 
 }
