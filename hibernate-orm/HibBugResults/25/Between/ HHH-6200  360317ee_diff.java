diff --git a/documentation/src/main/docbook/devguide/en-US/appendix-Configuration_Properties.xml b/documentation/src/main/docbook/devguide/en-US/appendix-Configuration_Properties.xml
index a0985f450f..fd0888a4eb 100644
--- a/documentation/src/main/docbook/devguide/en-US/appendix-Configuration_Properties.xml
+++ b/documentation/src/main/docbook/devguide/en-US/appendix-Configuration_Properties.xml
@@ -1,367 +1,367 @@
 <?xml version='1.0' encoding='utf-8' ?>
 <!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
 <!ENTITY % BOOK_ENTITIES SYSTEM "Hibernate_Development_Guide.ent">
 %BOOK_ENTITIES;
 ]>
 <appendix id="appendix-Configuration_Properties">
   <title>Configuration properties</title>
   <section>
     <title>General Configuration</title>
     <informaltable>
       <tgroup cols="3">
         <colspec colwidth="100px" />
         <colspec colwidth="120px" />
         <colspec colwidth="250px" />
         <tbody>
           <row>
             <entry>hibernate.dialect</entry>
             <entry>A fully-qualified classname</entry>
             <entry>
               <para>
                 The classname of a Hibernate <classname>org.hibernate.dialect.Dialect</classname> from which Hibernate
                 can generate SQL optimized for a particular relational database.
               </para>
               <para>
                 In most cases Hibernate can choose the correct <classname>org.hibernate.dialect.Dialect</classname>
                 implementation based on the JDBC metadata returned by the JDBC driver.
               </para>
             </entry>
           </row>
           <row>
             <entry>hibernate.show_sql</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry>Write all SQL statements to the console. This is an alternative to setting the log category
             <property>org.hibernate.SQL</property> to debug.</entry>
           </row>
           <row>
             <entry>hibernate.format_sql</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry>Pretty-print the SQL in the log and console.</entry>
           </row>
           <row>
             <entry>hibernate.default_schema</entry>
             <entry>A schema name</entry>
             <entry>Qualify unqualified table names with the given schema or tablespace in generated SQL.</entry>
           </row>
           <row>
             <entry>hibernate.default_catalog</entry>
             <entry>A catalog name</entry>
             <entry>Qualifies unqualified table names with the given catalog in generated SQL.</entry>
           </row>
           <row>
             <entry>hibernate.session_factory_name</entry>
             <entry>A JNDI name</entry>
             <entry>The <classname>org.hibernate.SessionFactory</classname> is automatically bound to this name in JNDI
             after it is created.</entry>
           </row>
           <row>
             <entry>hibernate.max_fetch_depth</entry>
             <entry>A value between <literal>0</literal> and <literal>3</literal></entry>
             <entry>Sets a maximum depth for the outer join fetch tree for single-ended associations. A single-ended
             assocation is a one-to-one or many-to-one assocation. A value of <literal>0</literal> disables default outer
             join fetching.</entry>
           </row>
           <row>
             <entry>hibernate.default_batch_fetch_size</entry>
             <entry><para><literal>4</literal>,<literal>8</literal>, or <literal>16</literal></para></entry>
             <entry>Default size for Hibernate batch fetching of associations.</entry>
           </row>
           <row>
             <entry>hibernate.default_entity_mode</entry>
             <entry><para>One of <literal>dynamic-map</literal>, <literal>dom4j</literal>,
             <literal>pojo</literal></para></entry>
             <entry>Default mode for entity representation for all sessions opened from this
             <classname>SessionFactory</classname></entry>
           </row>
           <row>
             <entry>hibernate.order_updates</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry>Forces Hibernate to order SQL updates by the primary key value of the items being updated. This
             reduces the likelihood of transaction deadlocks in highly-concurrent systems.</entry>
           </row>
           <row>
             <entry>hibernate.generate_statistics</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry>Causes Hibernate to collect statistics for performance tuning.</entry>
           </row>
           <row>
             <entry>hibernate.use_identifier_rollback</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry>If true, generated identifier properties are reset to default values when objects are
             deleted.</entry>
           </row>
           <row>
             <entry>hibernate.use_sql_comments</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry>If true, Hibernate generates comments inside the SQL, for easier debugging.</entry>
           </row>
         </tbody>
       </tgroup>
     </informaltable>
   </section>
   <section>
     <title>Database configuration</title>
     <table>
       <title>JDBC properties</title>
       <tgroup cols="3">
         <thead>
           <row>
             <entry>Property</entry>
             <entry>Example</entry>
             <entry>Purpose</entry>
           </row>
         </thead>
         <tbody>
           <row>
             <entry>hibernate.jdbc.fetch_size</entry>
             <entry><literal>0</literal> or an integer</entry>
             <entry>A non-zero value determines the JDBC fetch size, by calling
             <methodname>Statement.setFetchSize()</methodname>.</entry>
           </row>
           <row>
             <entry>hibernate.jdbc.batch_size</entry>
             <entry><para>A value between <literal>5</literal> and <literal>30</literal></para></entry>
             <entry>A non-zero value causes Hibernate to use JDBC2 batch updates.</entry>
           </row>
           <row>
             <entry>hibernate.jdbc.batch_versioned_data</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry><para>Set this property to <literal>true</literal> if your JDBC driver returns correct row counts
             from <methodname>executeBatch()</methodname>. This option is usually safe, but is disabled by default. If
             enabled, Hibernate uses batched DML for automatically versioned data.</para></entry>
           </row>
           <row>
             <entry>hibernate.jdbc.factory_class</entry>
             <entry>The fully-qualified class name of the factory</entry>
             <entry><para>Select a custom <classname>org.hibernate.jdbc.Batcher</classname>. Irrelevant for most
             applications.</para></entry>
           </row>
           <row>
             <entry>hibernate.jdbc.use_scrollable_resultset</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry>Enables Hibernate to use JDBC2 scrollable resultsets. This property is only relevant for
             user-supplied JDBC connections. Otherwise, Hibernate uses connection metadata.</entry>
           </row>
           <row>
             <entry>hibernate.jdbc.use_streams_for_binary</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry><para>Use streams when writing or reading <type>binary</type> or <type>serializable</type> types to
             or from JDBC. This is a system-level property.</para></entry>
           </row>
           <row>
             <entry>hibernate.jdbc.use_get_generated_keys</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry><para>Allows Hibernate to use JDBC3 <classname>PreparedStatement.getGeneratedKeys()</classname> to
             retrieve natively-generated keys after insert. You need the JDBC3+ driver and JRE1.4+. Disable this property
             if your driver has problems with the Hibernate identifier generators. By default, it tries to detect the
             driver capabilities from connection metadata.</para></entry>
           </row>
         </tbody>
       </tgroup>
     </table>
     <table>
       <title>Cache Properties</title>
       <tgroup cols="3">
         <colspec colwidth="100px" />
         <colspec colwidth="100px" />
         <colspec colwidth="240px" />
         <thead>
           <row>
             <entry>Property</entry>
             <entry>Example</entry>
             <entry>Purpose</entry>
           </row>
         </thead>
         <tbody>
           <row>
             <entry>hibernate.cache.provider_class</entry>
             <entry>Fully-qualified classname</entry>
             <entry>The classname of a custom CacheProvider.</entry>
           </row>
           <row>
             <entry>hibernate.cache.use_minimal_puts</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry>Optimizes second-level cache operation to minimize writes, at the cost of more frequent reads. This
             is most useful for clustered caches and is enabled by default for clustered cache implementations.</entry>
           </row>
           <row>
             <entry>hibernate.cache.use_query_cache</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry>Enables the query cache. You still need to set individual queries to be cachable.</entry>
           </row>
           <row>
             <entry>hibernate.cache.use_second_level_cache</entry> <entry><para><literal>true</literal> or
             <literal>false</literal></para></entry> <entry>Completely disable the second level cache, which is enabled
             by default for classes which specify a &lt;cache&gt; mapping.</entry>
           </row>
           <row>
             <entry>hibernate.cache.query_cache_factory</entry>
             <entry>Fully-qualified classname</entry>
             <entry>A custom <interfacename>QueryCache</interfacename> interface. The default is the built-in
             <interfacename>StandardQueryCache</interfacename>.</entry>
           </row>
           <row>
             <entry>hibernate.cache.region_prefix</entry>
             <entry>A string</entry>
             <entry>A prefix for second-level cache region names.</entry>
           </row>
           <row>
             <entry>hibernate.cache.use_structured_entries</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry>Forces Hibernate to store data in the second-level cache in a more human-readable format.</entry>
           </row>
         </tbody>
       </tgroup>
     </table>
     <table>
       <title>Transactions properties</title>
       <tgroup cols="3">
         <colspec colwidth="100px" />
         <colspec colwidth="100px" />
         <colspec colwidth="240px" />
 
         <thead>
           <row>
             <entry>Property</entry>
             <entry>Example</entry>
             <entry>Purpose</entry>
           </row>
         </thead>
         <tbody>
           <row>
             <entry>hibernate.transaction.factory_class</entry>
             <entry>A fully-qualified classname</entry>
             <entry>The classname of a <classname>TransactionFactory</classname> to use with Hibernate Transaction API. The
             default is <classname>JDBCTransactionFactory</classname>).</entry>
           </row>
           <row>
             <entry>jta.UserTransaction</entry>
             <entry>A JNDI name</entry>
             <entry><para>The <classname>JTATransactionFactory</classname> needs a JNDI name to obtain the JTA
             UserTransaction from the application server.</para></entry>
           </row>
           <row>
             <entry>hibernate.transaction.manager_lookup_class</entry>
             <entry>A fully-qualified classname</entry>
             <entry><para>The classname of a <classname>TransactionManagerLookup</classname>, which is used in
             conjunction with JVM-level or the hilo generator in a JTA environment.</para></entry>
           </row>
           <row>
             <entry>hibernate.transaction.flush_before_completion</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry>Causes the session be flushed during the <phrase>before completion</phrase> phase of the
             transaction. If possible, use built-in and automatic session context management instead.</entry>
           </row>
           <row>
             <entry>hibernate.transaction.auto_close_session</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry>Causes the session to be closed during the <phrase>after completion</phrase> phase of the
             transaction. If possible, use built-in and automatic session context management instead.</entry>
           </row>
         </tbody>
       </tgroup>
     </table>
     <note>
       <para>
         Each of the properties in the following table are prefixed by <literal>hibernate.</literal>. It has been removed
         in the table to conserve space.
       </para>
     </note>
     <table>
       <title>Miscellaneous properties</title>
       <tgroup cols="3">
         <thead>
           <row>
             <entry>Property</entry>
             <entry>Example</entry>
             <entry>Purpose</entry>
           </row>
         </thead>
         <tbody>
           <row>
             <entry>current_session_context_class</entry>
             <entry><para>One of <literal>jta</literal>, <literal>thread</literal>, <literal>managed</literal>, or
             <literal>custom.Class</literal></para></entry>
             <entry><para>Supply a custom strategy for the scoping of the <classname>Current</classname>
             Session.</para></entry>
           </row>
           <row>
             <entry>factory_class</entry>
-            <entry><para><literal>org.hibernate.hql.ast.ASTQueryTranslatorFactory</literal> or
-            <literal>org.hibernate.hql.classic.ClassicQueryTranslatorFactory</literal></para></entry>
+            <entry><para><literal>org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory</literal> or
+            <literal>org.hibernate.hql.internal.classic.ClassicQueryTranslatorFactory</literal></para></entry>
             <entry>Chooses the HQL parser implementation.</entry>
           </row>
           <row>
             <entry>query.substitutions</entry>
             <entry><para><literal>hqlLiteral=SQL_LITERAL</literal> or <literal>hqlFunction=SQLFUNC</literal>
             </para></entry>
             <entry>Map from tokens in Hibernate queries to SQL tokens, such as function or literal names.</entry>
           </row>
           <row>
             <entry>hbm2ddl.auto</entry>
             <entry><para><literal>validate</literal>, <literal>update</literal>, <literal>create</literal>,
             <literal>create-drop</literal></para></entry>
             <entry>Validates or exports schema DDL to the database when the <classname>SessionFactory</classname> is
             created. With <command>create-drop</command>, the database schema is dropped when the
             <classname>SessionFactory</classname> is closed explicitly.</entry>
           </row>
           <row>          
             <entry>cglib.use_reflection_optimizer</entry>
             <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
             <entry>If enabled, Hibernate uses CGLIB instead of runtime reflection. This is a system-level
             property. Reflection is useful for troubleshooting. Hibernate always requires CGLIB even if you disable the
             optimizer. You cannot set this property in hibernate.cfg.xml.</entry>
           </row>
         </tbody>
       </tgroup>
     </table>
   </section>
   <section>
     <title>Connection pool properties</title>
     <itemizedlist>
       <title>c3p0 connection pool properties</title>
       <listitem><para>hibernate.c3p0.min_size</para></listitem>
       <listitem><para>hibernate.c3p0.max_size</para></listitem>
       <listitem><para>hibernate.c3p0.timeout</para></listitem>
       <listitem><para>hibernate.c3p0.max_statements</para></listitem>
     </itemizedlist>
     <table>
       <title>Proxool connection pool properties</title>
       <tgroup cols="2">
         <colspec colwidth="100px" />
         <colspec colwidth="340px" />
         <thead>
           <row>
             <entry>Property</entry>
             <entry>Description</entry>
           </row>
         </thead>
         <tbody>
           <row>
             <entry>hibernate.proxool.xml</entry>
             <entry>Configure Proxool provider using an XML file (.xml is appended automatically)</entry>
           </row>
           <row>
             <entry>hibernate.proxool.properties</entry>
             <entry>Configure the Proxool provider using a properties file (.properties is appended
             automatically)</entry>
           </row>
           <row>
             <entry>hibernate.proxool.existing_pool</entry>
             <entry>Whether to configure the Proxool provider from an existing pool</entry>
           </row>
           <row>
             <entry>hibernate.proxool.pool_alias</entry>
             <entry>Proxool pool alias to use. Required.</entry>
           </row>
         </tbody>
       </tgroup>
     </table>
     <note>
       <para>
         For information on specific configuration of Proxool, refer to the Proxool documentation available from <ulink
         url="http://proxool.sourceforge.net/" />.
       </para>
     </note>
   </section>
 </appendix>
\ No newline at end of file
diff --git a/documentation/src/main/docbook/manual/en-US/content/configuration.xml b/documentation/src/main/docbook/manual/en-US/content/configuration.xml
index 55fd460ecd..30d2c6289e 100644
--- a/documentation/src/main/docbook/manual/en-US/content/configuration.xml
+++ b/documentation/src/main/docbook/manual/en-US/content/configuration.xml
@@ -1,1802 +1,1802 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
   ~ Hibernate, Relational Persistence for Idiomatic Java
   ~
   ~ Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
   ~ indicated by the @author tags or express copyright attribution
   ~ statements applied by the authors.  All third-party contributions are
   ~ distributed under license by Red Hat Middleware LLC.
   ~
   ~ This copyrighted material is made available to anyone wishing to use, modify,
   ~ copy, or redistribute it subject to the terms and conditions of the GNU
   ~ Lesser General Public License, as published by the Free Software Foundation.
   ~
   ~ This program is distributed in the hope that it will be useful,
   ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
   ~ for more details.
   ~
   ~ You should have received a copy of the GNU Lesser General Public License
   ~ along with this distribution; if not, write to:
   ~ Free Software Foundation, Inc.
   ~ 51 Franklin Street, Fifth Floor
   ~ Boston, MA  02110-1301  USA
   -->
 <!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
 <!ENTITY % BOOK_ENTITIES SYSTEM "../HIBERNATE_-_Relational_Persistence_for_Idiomatic_Java.ent">
 %BOOK_ENTITIES;
 ]>
 <chapter id="session-configuration" revision="1">
   <title>Configuration</title>
 
   <para>Hibernate is designed to operate in many different environments and,
   as such, there is a broad range of configuration parameters. Fortunately,
   most have sensible default values and Hibernate is distributed with an
   example <literal>hibernate.properties</literal> file in
   <literal>etc/</literal> that displays the various options. Simply put the
   example file in your classpath and customize it to suit your needs.</para>
 
   <section id="configuration-programmatic" revision="1">
     <title>Programmatic configuration</title>
 
     <para>An instance of
     <classname>org.hibernate.cfg.Configuration</classname> represents an
     entire set of mappings of an application's Java types to an SQL database.
     The <classname>org.hibernate.cfg.Configuration</classname> is used to
     build an immutable
     <interfacename>org.hibernate.SessionFactory</interfacename>. The mappings
     are compiled from various XML mapping files.</para>
 
     <para>You can obtain a
     <classname>org.hibernate.cfg.Configuration</classname> instance by
     instantiating it directly and specifying XML mapping documents. If the
     mapping files are in the classpath, use <literal>addResource()</literal>.
     For example:</para>
 
     <programlisting role="JAVA">Configuration cfg = new Configuration()
     .addResource("Item.hbm.xml")
     .addResource("Bid.hbm.xml");</programlisting>
 
     <para>An alternative way is to specify the mapped class and allow
     Hibernate to find the mapping document for you:</para>
 
     <programlisting role="JAVA">Configuration cfg = new Configuration()
     .addClass(org.hibernate.auction.Item.class)
     .addClass(org.hibernate.auction.Bid.class);</programlisting>
 
     <para>Hibernate will then search for mapping files named
     <filename>/org/hibernate/auction/Item.hbm.xml</filename> and
     <filename>/org/hibernate/auction/Bid.hbm.xml</filename> in the classpath.
     This approach eliminates any hardcoded filenames.</para>
 
     <para>A <classname>org.hibernate.cfg.Configuration</classname> also allows
     you to specify configuration properties. For example:</para>
 
     <programlisting role="JAVA">Configuration cfg = new Configuration()
     .addClass(org.hibernate.auction.Item.class)
     .addClass(org.hibernate.auction.Bid.class)
     .setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLInnoDBDialect")
     .setProperty("hibernate.connection.datasource", "java:comp/env/jdbc/test")
     .setProperty("hibernate.order_updates", "true");</programlisting>
 
     <para>This is not the only way to pass configuration properties to
     Hibernate. Some alternative options include:</para>
 
     <orderedlist spacing="compact">
       <listitem>
         <para>Pass an instance of <classname>java.util.Properties</classname>
         to <literal>Configuration.setProperties()</literal>.</para>
       </listitem>
 
       <listitem>
         <para>Place a file named <filename>hibernate.properties</filename> in
         a root directory of the classpath.</para>
       </listitem>
 
       <listitem>
         <para>Set <literal>System</literal> properties using <literal>java
         -Dproperty=value</literal>.</para>
       </listitem>
 
       <listitem>
         <para>Include <literal>&lt;property&gt;</literal> elements in
         <literal>hibernate.cfg.xml</literal> (this is discussed later).</para>
       </listitem>
     </orderedlist>
 
     <para>If you want to get started
     quickly<filename>hibernate.properties</filename> is the easiest
     approach.</para>
 
     <para>The <classname>org.hibernate.cfg.Configuration</classname> is
     intended as a startup-time object that will be discarded once a
     <literal>SessionFactory</literal> is created.</para>
   </section>
 
   <section id="configuration-sessionfactory">
     <title>Obtaining a SessionFactory</title>
 
     <para>When all mappings have been parsed by the
     <classname>org.hibernate.cfg.Configuration</classname>, the application
     must obtain a factory for
     <interfacename>org.hibernate.Session</interfacename> instances. This
     factory is intended to be shared by all application threads:</para>
 
     <programlisting role="JAVA">SessionFactory sessions = cfg.buildSessionFactory();</programlisting>
 
     <para>Hibernate does allow your application to instantiate more than one
     <interfacename>org.hibernate.SessionFactory</interfacename>. This is
     useful if you are using more than one database.</para>
   </section>
 
   <section id="configuration-hibernatejdbc" revision="1">
     <title>JDBC connections</title>
 
     <para>It is advisable to have the
     <interfacename>org.hibernate.SessionFactory</interfacename> create and
     pool JDBC connections for you. If you take this approach, opening a
     <interfacename>org.hibernate.Session</interfacename> is as simple
     as:</para>
 
     <programlisting role="JAVA">Session session = sessions.openSession(); // open a new Session</programlisting>
 
     <para>Once you start a task that requires access to the database, a JDBC
     connection will be obtained from the pool.</para>
 
     <para>Before you can do this, you first need to pass some JDBC connection
     properties to Hibernate. All Hibernate property names and semantics are
     defined on the class <classname>org.hibernate.cfg.Environment</classname>.
     The most important settings for JDBC connection configuration are outlined
     below.</para>
 
     <para>Hibernate will obtain and pool connections using
     <classname>java.sql.DriverManager</classname> if you set the following
     properties:</para>
 
     <table frame="topbot">
       <title>Hibernate JDBC Properties</title>
 
       <tgroup cols="2">
         <colspec colname="c1" colwidth="1*" />
 
         <colspec colname="c2" colwidth="1*" />
 
         <thead>
           <row>
             <entry>Property name</entry>
 
             <entry>Purpose</entry>
           </row>
         </thead>
 
         <tbody>
           <row>
             <entry><property>hibernate.connection.driver_class</property></entry>
 
             <entry><emphasis>JDBC driver class</emphasis></entry>
           </row>
 
           <row>
             <entry><property>hibernate.connection.url</property></entry>
 
             <entry><emphasis>JDBC URL</emphasis></entry>
           </row>
 
           <row>
             <entry><property>hibernate.connection.username</property></entry>
 
             <entry><emphasis>database user</emphasis></entry>
           </row>
 
           <row>
             <entry><property>hibernate.connection.password</property></entry>
 
             <entry><emphasis>database user password</emphasis></entry>
           </row>
 
           <row>
             <entry><property>hibernate.connection.pool_size</property></entry>
 
             <entry><emphasis>maximum number of pooled
             connections</emphasis></entry>
           </row>
         </tbody>
       </tgroup>
     </table>
 
     <para>Hibernate's own connection pooling algorithm is, however, quite
     rudimentary. It is intended to help you get started and is <emphasis>not
     intended for use in a production system</emphasis>, or even for
     performance testing. You should use a third party pool for best
     performance and stability. Just replace the
     <property>hibernate.connection.pool_size</property> property with
     connection pool specific settings. This will turn off Hibernate's internal
     pool. For example, you might like to use c3p0.</para>
 
     <para>C3P0 is an open source JDBC connection pool distributed along with
     Hibernate in the <filename>lib</filename> directory. Hibernate will use
     its <classname>org.hibernate.connection.C3P0ConnectionProvider</classname>
     for connection pooling if you set <property>hibernate.c3p0.*</property>
     properties. If you would like to use Proxool, refer to the packaged
     <filename>hibernate.properties</filename> and the Hibernate web site for
     more information.</para>
 
     <para>The following is an example
     <filename>hibernate.properties</filename> file for c3p0:</para>
 
     <programlisting>hibernate.connection.driver_class = org.postgresql.Driver
 hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
 hibernate.connection.username = myuser
 hibernate.connection.password = secret
 hibernate.c3p0.min_size=5
 hibernate.c3p0.max_size=20
 hibernate.c3p0.timeout=1800
 hibernate.c3p0.max_statements=50
 hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</programlisting>
 
     <para>For use inside an application server, you should almost always
     configure Hibernate to obtain connections from an application server
     <interfacename>javax.sql.Datasource</interfacename> registered in JNDI.
     You will need to set at least one of the following properties:</para>
 
     <table frame="topbot">
       <title>Hibernate Datasource Properties</title>
 
       <tgroup cols="2">
         <colspec colname="c1" colwidth="1*" />
 
         <colspec colname="c2" colwidth="1*" />
 
         <thead>
           <row>
             <entry>Property name</entry>
 
             <entry>Purpose</entry>
           </row>
         </thead>
 
         <tbody>
           <row>
             <entry><property>hibernate.connection.datasource</property></entry>
 
             <entry><emphasis>datasource JNDI name</emphasis></entry>
           </row>
 
           <row>
             <entry><property>hibernate.jndi.url</property></entry>
 
             <entry><emphasis>URL of the JNDI provider</emphasis>
             (optional)</entry>
           </row>
 
           <row>
             <entry><property>hibernate.jndi.class</property></entry>
 
             <entry><emphasis>class of the JNDI
             <literal>InitialContextFactory</literal></emphasis>
             (optional)</entry>
           </row>
 
           <row>
             <entry><property>hibernate.connection.username</property></entry>
 
             <entry><emphasis>database user</emphasis> (optional)</entry>
           </row>
 
           <row>
             <entry><property>hibernate.connection.password</property></entry>
 
             <entry><emphasis>database user password</emphasis>
             (optional)</entry>
           </row>
         </tbody>
       </tgroup>
     </table>
 
     <para>Here is an example <filename>hibernate.properties</filename> file
     for an application server provided JNDI datasource:</para>
 
     <programlisting>hibernate.connection.datasource = java:/comp/env/jdbc/test
 hibernate.transaction.factory_class = \
     org.hibernate.transaction.JTATransactionFactory
 hibernate.transaction.manager_lookup_class = \
     org.hibernate.transaction.JBossTransactionManagerLookup
 hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect</programlisting>
 
     <para>JDBC connections obtained from a JNDI datasource will automatically
     participate in the container-managed transactions of the application
     server.</para>
 
     <para>Arbitrary connection properties can be given by prepending
     "<literal>hibernate.connection</literal>" to the connection property name.
     For example, you can specify a <property>charSet</property> connection
     property using <property>hibernate.connection.charSet</property>.</para>
 
     <para>You can define your own plugin strategy for obtaining JDBC
     connections by implementing the interface
     <interfacename>org.hibernate.connection.ConnectionProvider</interfacename>,
     and specifying your custom implementation via the
     <property>hibernate.connection.provider_class</property> property.</para>
   </section>
 
   <section id="configuration-optional" revision="1">
     <title>Optional configuration properties</title>
 
     <para>There are a number of other properties that control the behavior of
     Hibernate at runtime. All are optional and have reasonable default
     values.</para>
 
     <para><warning>
         <para><emphasis>Some of these properties are "system-level"
         only.</emphasis> System-level properties can be set only via
         <literal>java -Dproperty=value</literal> or
         <filename>hibernate.properties</filename>. They
         <emphasis>cannot</emphasis> be set by the other techniques described
         above.</para>
       </warning></para>
 
     <table frame="topbot" id="configuration-optional-properties" revision="8">
       <title>Hibernate Configuration Properties</title>
 
       <tgroup cols="2">
         <colspec colname="c1" colwidth="1*" />
 
         <colspec colname="c2" colwidth="1*" />
 
         <thead>
           <row>
             <entry>Property name</entry>
 
             <entry>Purpose</entry>
           </row>
         </thead>
 
         <tbody>
           <row>
             <entry><property>hibernate.dialect</property></entry>
 
             <entry>The classname of a Hibernate
             <classname>org.hibernate.dialect.Dialect</classname> which allows
             Hibernate to generate SQL optimized for a particular relational
             database. <para> <emphasis role="strong">e.g.</emphasis>
             <literal>full.classname.of.Dialect</literal> </para> <para> In
             most cases Hibernate will actually be able to choose the correct
             <classname>org.hibernate.dialect.Dialect</classname>
             implementation based on the <literal>JDBC metadata</literal>
             returned by the JDBC driver. </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.show_sql</property></entry>
 
             <entry>Write all SQL statements to console. This is an alternative
             to setting the log category <literal>org.hibernate.SQL</literal>
             to <literal>debug</literal>. <para> <emphasis
             role="strong">e.g.</emphasis> <literal>true</literal> |
             <literal>false</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.format_sql</property></entry>
 
             <entry>Pretty print the SQL in the log and console. <para>
             <emphasis role="strong">e.g.</emphasis> <literal>true</literal> |
             <literal>false</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.default_schema</property></entry>
 
             <entry>Qualify unqualified table names with the given
             schema/tablespace in generated SQL. <para> <emphasis
             role="strong">e.g.</emphasis> <literal>SCHEMA_NAME</literal>
             </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.default_catalog</property></entry>
 
             <entry>Qualifies unqualified table names with the given catalog in
             generated SQL. <para> <emphasis role="strong">e.g.</emphasis>
             <literal>CATALOG_NAME</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.session_factory_name</property></entry>
 
             <entry>The
             <interfacename>org.hibernate.SessionFactory</interfacename> will
             be automatically bound to this name in JNDI after it has been
             created. <para> <emphasis role="strong">e.g.</emphasis>
             <literal>jndi/composite/name</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.max_fetch_depth</property></entry>
 
             <entry>Sets a maximum "depth" for the outer join fetch tree for
             single-ended associations (one-to-one, many-to-one). A
             <literal>0</literal> disables default outer join fetching. <para>
             <emphasis role="strong">e.g.</emphasis> recommended values between
             <literal>0</literal> and <literal>3</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.default_batch_fetch_size</property></entry>
 
             <entry>Sets a default size for Hibernate batch fetching of
             associations. <para> <emphasis role="strong">e.g.</emphasis>
             recommended values <literal>4</literal>, <literal>8</literal>,
             <literal>16</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.default_entity_mode</property></entry>
 
             <entry>Sets a default mode for entity representation for all
             sessions opened from this <literal>SessionFactory</literal> <para>
             <literal>dynamic-map</literal>, <literal>dom4j</literal>,
             <literal>pojo</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.order_updates</property></entry>
 
             <entry>Forces Hibernate to order SQL updates by the primary key
             value of the items being updated. This will result in fewer
             transaction deadlocks in highly concurrent systems. <para>
             <emphasis role="strong">e.g.</emphasis> <literal>true</literal> |
             <literal>false</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.generate_statistics</property></entry>
 
             <entry>If enabled, Hibernate will collect statistics useful for
             performance tuning. <para> <emphasis role="strong">e.g.</emphasis>
             <literal>true</literal> | <literal>false</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.use_identifier_rollback</property></entry>
 
             <entry>If enabled, generated identifier properties will be reset
             to default values when objects are deleted. <para> <emphasis
             role="strong">e.g.</emphasis> <literal>true</literal> |
             <literal>false</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.use_sql_comments</property></entry>
 
             <entry>If turned on, Hibernate will generate comments inside the
             SQL, for easier debugging, defaults to <literal>false</literal>.
             <para> <emphasis role="strong">e.g.</emphasis>
             <literal>true</literal> | <literal>false</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.id.new_generator_mappings</property></entry>
 
             <entry>Setting is relevant when using
             <classname>@GeneratedValue</classname>. It indicates whether or
             not the new <classname>IdentifierGenerator</classname>
             implementations are used for
             <classname>javax.persistence.GenerationType.AUTO</classname>,
             <classname>javax.persistence.GenerationType.TABLE</classname> and
             <classname>javax.persistence.GenerationType.SEQUENCE</classname>.
             Default to <literal>false</literal> to keep backward
             compatibility. <para> <emphasis role="strong">e.g.</emphasis>
             <literal>true</literal> | <literal>false</literal> </para></entry>
           </row>
         </tbody>
       </tgroup>
     </table>
 
     <note>
       <para>We recommend all new projects which make use of to use
       <classname>@GeneratedValue</classname> to also set
       <code>hibernate.id.new_generator_mappings=true</code> as the new
       generators are more efficient and closer to the JPA 2 specification
       semantic. However they are not backward compatible with existing
       databases (if a sequence or a table is used for id generation).</para>
     </note>
 
     <table frame="topbot" id="configuration-jdbc-properties" revision="8">
       <title>Hibernate JDBC and Connection Properties</title>
 
       <tgroup cols="2">
         <!--
                 <colspec colname="c1" colwidth="1*"/>
                 <colspec colname="c2" colwidth="1*"/>
 -->
 
         <thead>
           <row>
             <entry>Property name</entry>
 
             <entry>Purpose</entry>
           </row>
         </thead>
 
         <tbody>
           <row>
             <entry><property>hibernate.jdbc.fetch_size</property></entry>
 
             <entry>A non-zero value determines the JDBC fetch size (calls
             <literal>Statement.setFetchSize()</literal>).</entry>
           </row>
 
           <row>
             <entry><property>hibernate.jdbc.batch_size</property></entry>
 
             <entry>A non-zero value enables use of JDBC2 batch updates by
             Hibernate. <para> <emphasis role="strong">e.g.</emphasis>
             recommended values between <literal>5</literal> and
             <literal>30</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.jdbc.batch_versioned_data</property></entry>
 
             <entry>Set this property to <literal>true</literal> if your JDBC
             driver returns correct row counts from
             <literal>executeBatch()</literal>. It is usually safe to turn this
             option on. Hibernate will then use batched DML for automatically
             versioned data. Defaults to <literal>false</literal>. <para>
             <emphasis role="strong">e.g.</emphasis> <literal>true</literal> |
             <literal>false</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.jdbc.factory_class</property></entry>
 
             <entry>Select a custom
             <interfacename>org.hibernate.jdbc.Batcher</interfacename>. Most
             applications will not need this configuration property. <para>
             <emphasis role="strong">e.g.</emphasis>
             <literal>classname.of.BatcherFactory</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.jdbc.use_scrollable_resultset</property></entry>
 
             <entry>Enables use of JDBC2 scrollable resultsets by Hibernate.
             This property is only necessary when using user-supplied JDBC
             connections. Hibernate uses connection metadata otherwise. <para>
             <emphasis role="strong">e.g.</emphasis> <literal>true</literal> |
             <literal>false</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.jdbc.use_streams_for_binary</property></entry>
 
             <entry>Use streams when writing/reading <literal>binary</literal>
             or <literal>serializable</literal> types to/from JDBC.
             <emphasis>*system-level property*</emphasis> <para> <emphasis
             role="strong">e.g.</emphasis> <literal>true</literal> |
             <literal>false</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.jdbc.use_get_generated_keys</property></entry>
 
             <entry>Enables use of JDBC3
             <literal>PreparedStatement.getGeneratedKeys()</literal> to
             retrieve natively generated keys after insert. Requires JDBC3+
             driver and JRE1.4+, set to false if your driver has problems with
             the Hibernate identifier generators. By default, it tries to
             determine the driver capabilities using connection metadata.
             <para> <emphasis role="strong">e.g.</emphasis>
             <literal>true|false</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.connection.provider_class</property></entry>
 
             <entry>The classname of a custom
             <interfacename>org.hibernate.connection.ConnectionProvider</interfacename>
             which provides JDBC connections to Hibernate. <para> <emphasis
             role="strong">e.g.</emphasis>
             <literal>classname.of.ConnectionProvider</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.connection.isolation</property></entry>
 
             <entry>Sets the JDBC transaction isolation level. Check
             <interfacename>java.sql.Connection</interfacename> for meaningful
             values, but note that most databases do not support all isolation
             levels and some define additional, non-standard isolations. <para>
             <emphasis role="strong">e.g.</emphasis> <literal>1, 2, 4,
             8</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.connection.autocommit</property></entry>
 
             <entry>Enables autocommit for JDBC pooled connections (it is not
             recommended). <para> <emphasis role="strong">e.g.</emphasis>
             <literal>true</literal> | <literal>false</literal> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.connection.release_mode</property></entry>
 
             <entry>Specifies when Hibernate should release JDBC connections.
             By default, a JDBC connection is held until the session is
             explicitly closed or disconnected. For an application server JTA
             datasource, use <literal>after_statement</literal> to aggressively
             release connections after every JDBC call. For a non-JTA
             connection, it often makes sense to release the connection at the
             end of each transaction, by using
             <literal>after_transaction</literal>. <literal>auto</literal> will
             choose <literal>after_statement</literal> for the JTA and CMT
             transaction strategies and <literal>after_transaction</literal>
             for the JDBC transaction strategy. <para> <emphasis
             role="strong">e.g.</emphasis> <literal>auto</literal> (default) |
             <literal>on_close</literal> | <literal>after_transaction</literal>
             | <literal>after_statement</literal> </para> <para> This setting
             only affects <literal>Session</literal>s returned from
             <literal>SessionFactory.openSession</literal>. For
             <literal>Session</literal>s obtained through
             <literal>SessionFactory.getCurrentSession</literal>, the
             <literal>CurrentSessionContext</literal> implementation configured
             for use controls the connection release mode for those
             <literal>Session</literal>s. See <xref
             linkend="architecture-current-session" /> </para></entry>
           </row>
 
           <row>
             <entry><property>hibernate.connection.</property><emphasis>&lt;propertyName&gt;</emphasis></entry>
 
             <entry>Pass the JDBC property
             <emphasis>&lt;propertyName&gt;</emphasis> to
             <literal>DriverManager.getConnection()</literal>.</entry>
           </row>
 
           <row>
             <entry><property>hibernate.jndi.</property><emphasis>&lt;propertyName&gt;</emphasis></entry>
 
             <entry>Pass the property <emphasis>&lt;propertyName&gt;</emphasis>
             to the JNDI <literal>InitialContextFactory</literal>.</entry>
           </row>
         </tbody>
       </tgroup>
     </table>
 
     <table frame="topbot" id="configuration-cache-properties" revision="7">
       <title>Hibernate Cache Properties</title>
 
       <tgroup cols="2">
         <colspec colname="c1" colwidth="1*" />
 
         <colspec colname="c2" colwidth="1*" />
 
         <thead>
           <row>
             <entry>Property name</entry>
 
             <entry>Purpose</entry>
           </row>
         </thead>
 
         <tbody>
           <row>
             <entry><literal>hibernate.cache.provider_class</literal></entry>
 
             <entry>The classname of a custom <literal>CacheProvider</literal>.
             <para> <emphasis role="strong">e.g.</emphasis>
             <literal>classname.of.CacheProvider</literal> </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.cache.use_minimal_puts</literal></entry>
 
             <entry>Optimizes second-level cache operation to minimize writes,
             at the cost of more frequent reads. This setting is most useful
             for clustered caches and, in Hibernate3, is enabled by default for
             clustered cache implementations. <para> <emphasis
             role="strong">e.g.</emphasis> <literal>true|false</literal>
             </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.cache.use_query_cache</literal></entry>
 
             <entry>Enables the query cache. Individual queries still have to
             be set cachable. <para> <emphasis role="strong">e.g.</emphasis>
             <literal>true|false</literal> </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.cache.use_second_level_cache</literal></entry>
 
             <entry>Can be used to completely disable the second level cache,
             which is enabled by default for classes which specify a
             <literal>&lt;cache&gt;</literal> mapping. <para> <emphasis
             role="strong">e.g.</emphasis> <literal>true|false</literal>
             </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.cache.query_cache_factory</literal></entry>
 
             <entry>The classname of a custom <literal>QueryCache</literal>
             interface, defaults to the built-in
             <literal>StandardQueryCache</literal>. <para> <emphasis
             role="strong">e.g.</emphasis>
             <literal>classname.of.QueryCache</literal> </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.cache.region_prefix</literal></entry>
 
             <entry>A prefix to use for second-level cache region names. <para>
             <emphasis role="strong">e.g.</emphasis> <literal>prefix</literal>
             </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.cache.use_structured_entries</literal></entry>
 
             <entry>Forces Hibernate to store data in the second-level cache in
             a more human-friendly format. <para> <emphasis
             role="strong">e.g.</emphasis> <literal>true|false</literal>
             </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.cache.default_cache_concurrency_strategy</literal></entry>
 
             <entry>Setting used to give the name of the default
             <classname>org.hibernate.annotations.CacheConcurrencyStrategy</classname>
             to use when either <classname>@Cacheable</classname> or
             <classname>@Cache</classname> is used.
             <code>@Cache(strategy="..")</code> is used to override this
             default.</entry>
           </row>
         </tbody>
       </tgroup>
     </table>
 
     <table frame="topbot" id="configuration-transaction-properties"
            revision="9">
       <title>Hibernate Transaction Properties</title>
 
       <tgroup cols="2">
         <colspec colname="c1" colwidth="1*" />
 
         <colspec colname="c2" colwidth="1*" />
 
         <thead>
           <row>
             <entry>Property name</entry>
 
             <entry>Purpose</entry>
           </row>
         </thead>
 
         <tbody>
           <row>
             <entry><literal>hibernate.transaction.factory_class</literal></entry>
 
             <entry>The classname of a <literal>TransactionFactory</literal> to
             use with Hibernate <literal>Transaction</literal> API (defaults to
             <literal>JDBCTransactionFactory</literal>). <para> <emphasis
             role="strong">e.g.</emphasis>
             <literal>classname.of.TransactionFactory</literal> </para></entry>
           </row>
 
           <row>
             <entry><literal>jta.UserTransaction</literal></entry>
 
             <entry>A JNDI name used by
             <literal>JTATransactionFactory</literal> to obtain the JTA
             <literal>UserTransaction</literal> from the application server.
             <para> <emphasis role="strong">e.g.</emphasis>
             <literal>jndi/composite/name</literal> </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.transaction.manager_lookup_class</literal></entry>
 
             <entry>The classname of a
             <literal>TransactionManagerLookup</literal>. It is required when
             JVM-level caching is enabled or when using hilo generator in a JTA
             environment. <para> <emphasis role="strong">e.g.</emphasis>
             <literal>classname.of.TransactionManagerLookup</literal>
             </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.transaction.flush_before_completion</literal></entry>
 
             <entry>If enabled, the session will be automatically flushed
             during the before completion phase of the transaction. Built-in
             and automatic session context management is preferred, see <xref
             linkend="architecture-current-session" />. <para> <emphasis
             role="strong">e.g.</emphasis> <literal>true</literal> |
             <literal>false</literal> </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.transaction.auto_close_session</literal></entry>
 
             <entry>If enabled, the session will be automatically closed during
             the after completion phase of the transaction. Built-in and
             automatic session context management is preferred, see <xref
             linkend="architecture-current-session" />. <para> <emphasis
             role="strong">e.g.</emphasis> <literal>true</literal> |
             <literal>false</literal> </para></entry>
           </row>
         </tbody>
       </tgroup>
     </table>
 
     <table frame="topbot" id="configuration-misc-properties" revision="11">
       <title>Miscellaneous Properties</title>
 
       <tgroup cols="2">
         <colspec colname="c1" colwidth="1*" />
 
         <colspec colname="c2" colwidth="1*" />
 
         <thead>
           <row>
             <entry>Property name</entry>
 
             <entry>Purpose</entry>
           </row>
         </thead>
 
         <tbody>
           <row>
             <entry><literal>hibernate.current_session_context_class</literal></entry>
 
             <entry>Supply a custom strategy for the scoping of the "current"
             <literal>Session</literal>. See <xref
             linkend="architecture-current-session" /> for more information
             about the built-in strategies. <para> <emphasis
             role="strong">e.g.</emphasis> <literal>jta</literal> |
             <literal>thread</literal> | <literal>managed</literal> |
             <literal>custom.Class</literal> </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.query.factory_class</literal></entry>
 
             <entry>Chooses the HQL parser implementation. <para> <emphasis
             role="strong">e.g.</emphasis>
-            <literal>org.hibernate.hql.ast.ASTQueryTranslatorFactory</literal>
+            <literal>org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory</literal>
             or
-            <literal>org.hibernate.hql.classic.ClassicQueryTranslatorFactory</literal>
+            <literal>org.hibernate.hql.internal.classic.ClassicQueryTranslatorFactory</literal>
             </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.query.substitutions</literal></entry>
 
             <entry>Is used to map from tokens in Hibernate queries to SQL
             tokens (tokens might be function or literal names, for example).
             <para> <emphasis role="strong">e.g.</emphasis>
             <literal>hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</literal>
             </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.hbm2ddl.auto</literal></entry>
 
             <entry>Automatically validates or exports schema DDL to the
             database when the <literal>SessionFactory</literal> is created.
             With <literal>create-drop</literal>, the database schema will be
             dropped when the <literal>SessionFactory</literal> is closed
             explicitly. <para> <emphasis role="strong">e.g.</emphasis>
             <literal>validate</literal> | <literal>update</literal> |
             <literal>create</literal> | <literal>create-drop</literal>
             </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.hbm2ddl.import_files</literal></entry>
 
             <entry><para>Comma-separated names of the optional files
             containing SQL DML statements executed during the
             <classname>SessionFactory</classname> creation. This is useful for
             testing or demoing: by adding INSERT statements for example you
             can populate your database with a minimal set of data when it is
             deployed.</para><para>File order matters, the statements of a give
             file are executed before the statements of the following files.
             These statements are only executed if the schema is created ie if
             <literal>hibernate.hbm2ddl.auto</literal> is set to
             <literal>create</literal> or
             <literal>create-drop</literal>.</para><para> <emphasis
             role="strong">e.g.</emphasis>
             <literal>/humans.sql,/dogs.sql</literal> </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.bytecode.use_reflection_optimizer</literal></entry>
 
             <entry><para>Enables the use of bytecode manipulation instead of
             runtime reflection. This is a System-level property and cannot be
             set in <literal>hibernate.cfg.xml</literal>. Reflection can
             sometimes be useful when troubleshooting. Hibernate always
             requires either CGLIB or javassist even if you turn off the
             optimizer.</para><para> <emphasis role="strong">e.g.</emphasis>
             <literal>true</literal> | <literal>false</literal> </para></entry>
           </row>
 
           <row>
             <entry><literal>hibernate.bytecode.provider</literal></entry>
 
             <entry><para>Both javassist or cglib can be used as byte
             manipulation engines; the default is
             <literal>javassist</literal>.</para><para> <emphasis
             role="strong">e.g.</emphasis> <literal>javassist</literal> |
             <literal>cglib</literal> </para></entry>
           </row>
         </tbody>
       </tgroup>
     </table>
 
     <section id="configuration-optional-dialects" revision="1">
       <title>SQL Dialects</title>
 
       <para>Always set the <literal>hibernate.dialect</literal> property to
       the correct <literal>org.hibernate.dialect.Dialect</literal> subclass
       for your database. If you specify a dialect, Hibernate will use sensible
       defaults for some of the other properties listed above. This means that
       you will not have to specify them manually.</para>
 
       <table frame="topbot" id="sql-dialects" revision="3">
         <title>Hibernate SQL Dialects
         (<literal>hibernate.dialect</literal>)</title>
 
         <tgroup cols="2">
           <!--
                     <colspec colwidth="1*"/>
                     <colspec colwidth="2.5*"/>
 -->
 
           <thead>
             <row>
               <entry>RDBMS</entry>
 
               <entry>Dialect</entry>
             </row>
           </thead>
 
           <tbody>
             <row>
               <entry>DB2</entry>
 
               <entry><literal>org.hibernate.dialect.DB2Dialect</literal></entry>
             </row>
 
             <row>
               <entry>DB2 AS/400</entry>
 
               <entry><literal>org.hibernate.dialect.DB2400Dialect</literal></entry>
             </row>
 
             <row>
               <entry>DB2 OS390</entry>
 
               <entry><literal>org.hibernate.dialect.DB2390Dialect</literal></entry>
             </row>
 
             <row>
               <entry>PostgreSQL</entry>
 
               <entry><literal>org.hibernate.dialect.PostgreSQLDialect</literal></entry>
             </row>
 
             <row>
               <entry>MySQL5</entry>
 
               <entry><literal>org.hibernate.dialect.MySQL5Dialect</literal></entry>
             </row>
 
             <row>
               <entry>MySQL5 with InnoDB</entry>
 
               <entry><literal>org.hibernate.dialect.MySQL5InnoDBDialect</literal></entry>
             </row>
 
             <row>
               <entry>MySQL with MyISAM</entry>
 
               <entry><literal>org.hibernate.dialect.MySQLMyISAMDialect</literal></entry>
             </row>
 
             <row>
               <entry>Oracle (any version)</entry>
 
               <entry><literal>org.hibernate.dialect.OracleDialect</literal></entry>
             </row>
 
             <row>
               <entry>Oracle 9i</entry>
 
               <entry><literal>org.hibernate.dialect.Oracle9iDialect</literal></entry>
             </row>
 
             <row>
               <entry>Oracle 10g</entry>
 
               <entry><literal>org.hibernate.dialect.Oracle10gDialect</literal></entry>
             </row>
 
             <row>
               <entry>Oracle 11g</entry>
 
               <entry><literal>org.hibernate.dialect.Oracle10gDialect</literal></entry>
             </row>
 
             <row>
               <entry>Sybase</entry>
 
               <entry><literal>org.hibernate.dialect.SybaseASE15Dialect</literal></entry>
             </row>
 
             <row>
               <entry>Sybase Anywhere</entry>
 
               <entry><literal>org.hibernate.dialect.SybaseAnywhereDialect</literal></entry>
             </row>
 
             <row>
               <entry>Microsoft SQL Server 2000</entry>
 
               <entry><literal>org.hibernate.dialect.SQLServerDialect</literal></entry>
             </row>
 
             <row>
               <entry>Microsoft SQL Server 2005</entry>
 
               <entry><literal>org.hibernate.dialect.SQLServer2005Dialect</literal></entry>
             </row>
 
             <row>
               <entry>Microsoft SQL Server 2008</entry>
 
               <entry><literal>org.hibernate.dialect.SQLServer2008Dialect</literal></entry>
             </row>
 
             <row>
               <entry>SAP DB</entry>
 
               <entry><literal>org.hibernate.dialect.SAPDBDialect</literal></entry>
             </row>
 
             <row>
               <entry>Informix</entry>
 
               <entry><literal>org.hibernate.dialect.InformixDialect</literal></entry>
             </row>
 
             <row>
               <entry>HypersonicSQL</entry>
 
               <entry><literal>org.hibernate.dialect.HSQLDialect</literal></entry>
             </row>
 
             <row>
               <entry>H2 Database</entry>
 
               <entry><literal>org.hibernate.dialect.H2Dialect</literal></entry>
             </row>
 
             <row>
               <entry>Ingres</entry>
 
               <entry><literal>org.hibernate.dialect.IngresDialect</literal></entry>
             </row>
 
             <row>
               <entry>Progress</entry>
 
               <entry><literal>org.hibernate.dialect.ProgressDialect</literal></entry>
             </row>
 
             <row>
               <entry>Mckoi SQL</entry>
 
               <entry><literal>org.hibernate.dialect.MckoiDialect</literal></entry>
             </row>
 
             <row>
               <entry>Interbase</entry>
 
               <entry><literal>org.hibernate.dialect.InterbaseDialect</literal></entry>
             </row>
 
             <row>
               <entry>Pointbase</entry>
 
               <entry><literal>org.hibernate.dialect.PointbaseDialect</literal></entry>
             </row>
 
             <row>
               <entry>FrontBase</entry>
 
               <entry><literal>org.hibernate.dialect.FrontbaseDialect</literal></entry>
             </row>
 
             <row>
               <entry>Firebird</entry>
 
               <entry><literal>org.hibernate.dialect.FirebirdDialect</literal></entry>
             </row>
           </tbody>
         </tgroup>
       </table>
     </section>
 
     <section id="configuration-optional-outerjoin" revision="4">
       <title>Outer Join Fetching</title>
 
       <para>If your database supports ANSI, Oracle or Sybase style outer
       joins, <emphasis>outer join fetching</emphasis> will often increase
       performance by limiting the number of round trips to and from the
       database. This is, however, at the cost of possibly more work performed
       by the database itself. Outer join fetching allows a whole graph of
       objects connected by many-to-one, one-to-many, many-to-many and
       one-to-one associations to be retrieved in a single SQL
       <literal>SELECT</literal>.</para>
 
       <para>Outer join fetching can be disabled <emphasis>globally</emphasis>
       by setting the property <literal>hibernate.max_fetch_depth</literal> to
       <literal>0</literal>. A setting of <literal>1</literal> or higher
       enables outer join fetching for one-to-one and many-to-one associations
       that have been mapped with <literal>fetch="join"</literal>.</para>
 
       <para>See <xref linkend="performance-fetching" /> for more
       information.</para>
     </section>
 
     <section id="configuration-optional-binarystreams" revision="1">
       <title>Binary Streams</title>
 
       <para>Oracle limits the size of <literal>byte</literal> arrays that can
       be passed to and/or from its JDBC driver. If you wish to use large
       instances of <literal>binary</literal> or
       <literal>serializable</literal> type, you should enable
       <literal>hibernate.jdbc.use_streams_for_binary</literal>. <emphasis>This
       is a system-level setting only.</emphasis></para>
     </section>
 
     <section id="configuration-optional-cacheprovider" revision="2">
       <title>Second-level and query cache</title>
 
       <para>The properties prefixed by <literal>hibernate.cache</literal>
       allow you to use a process or cluster scoped second-level cache system
       with Hibernate. See the <xref linkend="performance-cache" /> for more
       information.</para>
     </section>
 
     <section id="configuration-optional-querysubstitution">
       <title>Query Language Substitution</title>
 
       <para>You can define new Hibernate query tokens using
       <literal>hibernate.query.substitutions</literal>. For example:</para>
 
       <programlisting>hibernate.query.substitutions true=1, false=0</programlisting>
 
       <para>This would cause the tokens <literal>true</literal> and
       <literal>false</literal> to be translated to integer literals in the
       generated SQL.</para>
 
       <programlisting>hibernate.query.substitutions toLowercase=LOWER</programlisting>
 
       <para>This would allow you to rename the SQL <literal>LOWER</literal>
       function.</para>
     </section>
 
     <section id="configuration-optional-statistics" revision="2">
       <title>Hibernate statistics</title>
 
       <para>If you enable <literal>hibernate.generate_statistics</literal>,
       Hibernate exposes a number of metrics that are useful when tuning a
       running system via <literal>SessionFactory.getStatistics()</literal>.
       Hibernate can even be configured to expose these statistics via JMX.
       Read the Javadoc of the interfaces in
       <literal>org.hibernate.stats</literal> for more information.</para>
     </section>
   </section>
 
   <section id="configuration-logging">
     <title>Logging</title>
 
     <para>Hibernate utilizes <ulink url="http://www.slf4j.org/">Simple Logging
     Facade for Java</ulink> (SLF4J) in order to log various system events.
     SLF4J can direct your logging output to several logging frameworks (NOP,
     Simple, log4j version 1.2, JDK 1.4 logging, JCL or logback) depending on
     your chosen binding. In order to setup logging you will need
     <filename>slf4j-api.jar</filename> in your classpath together with the jar
     file for your preferred binding - <filename>slf4j-log4j12.jar</filename>
     in the case of Log4J. See the SLF4J <ulink
     url="http://www.slf4j.org/manual.html">documentation</ulink> for more
     detail. To use Log4j you will also need to place a
     <filename>log4j.properties</filename> file in your classpath. An example
     properties file is distributed with Hibernate in the
     <literal>src/</literal> directory.</para>
 
     <para>It is recommended that you familiarize yourself with Hibernate's log
     messages. A lot of work has been put into making the Hibernate log as
     detailed as possible, without making it unreadable. It is an essential
     troubleshooting device. The most interesting log categories are the
     following:</para>
 
     <table frame="topbot" id="log-categories" revision="2">
       <title>Hibernate Log Categories</title>
 
       <tgroup cols="2">
         <colspec colwidth="1*" />
 
         <colspec colwidth="2.5*" />
 
         <thead>
           <row>
             <entry>Category</entry>
 
             <entry>Function</entry>
           </row>
         </thead>
 
         <tbody>
           <row>
             <entry><literal>org.hibernate.SQL</literal></entry>
 
             <entry>Log all SQL DML statements as they are executed</entry>
           </row>
 
           <row>
             <entry><literal>org.hibernate.type</literal></entry>
 
             <entry>Log all JDBC parameters</entry>
           </row>
 
           <row>
             <entry><literal>org.hibernate.tool.hbm2ddl</literal></entry>
 
             <entry>Log all SQL DDL statements as they are executed</entry>
           </row>
 
           <row>
             <entry><literal>org.hibernate.pretty</literal></entry>
 
             <entry>Log the state of all entities (max 20 entities) associated
             with the session at flush time</entry>
           </row>
 
           <row>
             <entry><literal>org.hibernate.cache</literal></entry>
 
             <entry>Log all second-level cache activity</entry>
           </row>
 
           <row>
             <entry><literal>org.hibernate.transaction</literal></entry>
 
             <entry>Log transaction related activity</entry>
           </row>
 
           <row>
             <entry><literal>org.hibernate.jdbc</literal></entry>
 
             <entry>Log all JDBC resource acquisition</entry>
           </row>
 
           <row>
-            <entry><literal>org.hibernate.hql.ast.AST</literal></entry>
+            <entry><literal>org.hibernate.hql.internal.ast.AST</literal></entry>
 
             <entry>Log HQL and SQL ASTs during query parsing</entry>
           </row>
 
           <row>
             <entry><literal>org.hibernate.secure</literal></entry>
 
             <entry>Log all JAAS authorization requests</entry>
           </row>
 
           <row>
             <entry><literal>org.hibernate</literal></entry>
 
             <entry>Log everything. This is a lot of information but it is
             useful for troubleshooting</entry>
           </row>
         </tbody>
       </tgroup>
     </table>
 
     <para>When developing applications with Hibernate, you should almost
     always work with <literal>debug</literal> enabled for the category
     <literal>org.hibernate.SQL</literal>, or, alternatively, the property
     <literal>hibernate.show_sql</literal> enabled.</para>
   </section>
 
   <section id="configuration-namingstrategy">
     <title>Implementing a <literal>NamingStrategy</literal></title>
 
     <para>The interface <literal>org.hibernate.cfg.NamingStrategy</literal>
     allows you to specify a "naming standard" for database objects and schema
     elements.</para>
 
     <para>You can provide rules for automatically generating database
     identifiers from Java identifiers or for processing "logical" column and
     table names given in the mapping file into "physical" table and column
     names. This feature helps reduce the verbosity of the mapping document,
     eliminating repetitive noise (<literal>TBL_</literal> prefixes, for
     example). The default strategy used by Hibernate is quite minimal.</para>
 
     <para>You can specify a different strategy by calling
     <literal>Configuration.setNamingStrategy()</literal> before adding
     mappings:</para>
 
     <programlisting role="JAVA">SessionFactory sf = new Configuration()
     .setNamingStrategy(ImprovedNamingStrategy.INSTANCE)
     .addFile("Item.hbm.xml")
     .addFile("Bid.hbm.xml")
     .buildSessionFactory();</programlisting>
 
     <para><literal>org.hibernate.cfg.ImprovedNamingStrategy</literal> is a
     built-in strategy that might be a useful starting point for some
     applications.</para>
   </section>
 
   <section>
     <title>Implementing a PersisterClassProvider</title>
 
     <para>You can configure the persister implementation used to persist your
     entities and collections:</para>
 
     <itemizedlist>
       <listitem>
         <para>by default, Hibernate uses persisters that make sense in a
         relational model and follow Java Persistence's specification</para>
       </listitem>
 
       <listitem>
         <para>you can define a <classname>PersisterClassProvider</classname>
         implementation that provides the persister class used of a given
         entity or collection</para>
       </listitem>
 
       <listitem>
         <para>finally, you can override them on a per entity and collection
         basis in the mapping using <classname>@Persister</classname> or its
         XML equivalent</para>
       </listitem>
     </itemizedlist>
 
     <para>The latter in the list the higher in priority.</para>
 
     <para>You can pass the <classname>PersisterClassProvider</classname>
     instance to the <classname>Configuration</classname> object.</para>
 
     <programlisting role="JAVA">SessionFactory sf = new Configuration()
     .setPersisterClassProvider(customPersisterClassProvider)
     .addAnnotatedClass(Order.class)
     .buildSessionFactory();</programlisting>
 
     <para>The persister class provider methods, when returning a non null
     persister class, override the default Hibernate persisters. The entity
     name or the collection role are passed to the methods. It is a nice way to
     centralize the overriding logic of the persisters instead of spreading
     them on each entity or collection mapping. </para>
   </section>
 
   <section id="configuration-xmlconfig" revision="2">
     <title>XML configuration file</title>
 
     <para>An alternative approach to configuration is to specify a full
     configuration in a file named <literal>hibernate.cfg.xml</literal>. This
     file can be used as a replacement for the
     <literal>hibernate.properties</literal> file or, if both are present, to
     override properties.</para>
 
     <para>The XML configuration file is by default expected to be in the root
     of your <literal>CLASSPATH</literal>. Here is an example:</para>
 
     <programlisting role="XML">&lt;?xml version='1.0' encoding='utf-8'?&gt;
 &lt;!DOCTYPE hibernate-configuration PUBLIC
     "-//Hibernate/Hibernate Configuration DTD//EN"
     "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;
 
 &lt;hibernate-configuration&gt;
 
     &lt;!-- a SessionFactory instance listed as /jndi/name --&gt;
     &lt;session-factory
         name="java:hibernate/SessionFactory"&gt;
 
         &lt;!-- properties --&gt;
         &lt;property name="connection.datasource"&gt;java:/comp/env/jdbc/MyDB&lt;/property&gt;
         &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;
         &lt;property name="show_sql"&gt;false&lt;/property&gt;
         &lt;property name="transaction.factory_class"&gt;
             org.hibernate.transaction.JTATransactionFactory
         &lt;/property&gt;
         &lt;property name="jta.UserTransaction"&gt;java:comp/UserTransaction&lt;/property&gt;
 
         &lt;!-- mapping files --&gt;
         &lt;mapping resource="org/hibernate/auction/Item.hbm.xml"/&gt;
         &lt;mapping resource="org/hibernate/auction/Bid.hbm.xml"/&gt;
 
         &lt;!-- cache settings --&gt;
         &lt;class-cache class="org.hibernate.auction.Item" usage="read-write"/&gt;
         &lt;class-cache class="org.hibernate.auction.Bid" usage="read-only"/&gt;
         &lt;collection-cache collection="org.hibernate.auction.Item.bids" usage="read-write"/&gt;
 
     &lt;/session-factory&gt;
 
 &lt;/hibernate-configuration&gt;</programlisting>
 
     <para>The advantage of this approach is the externalization of the mapping
     file names to configuration. The <literal>hibernate.cfg.xml</literal> is
     also more convenient once you have to tune the Hibernate cache. It is your
     choice to use either <literal>hibernate.properties</literal> or
     <literal>hibernate.cfg.xml</literal>. Both are equivalent, except for the
     above mentioned benefits of using the XML syntax.</para>
 
     <para>With the XML configuration, starting Hibernate is then as simple
     as:</para>
 
     <programlisting role="JAVA">SessionFactory sf = new Configuration().configure().buildSessionFactory();</programlisting>
 
     <para>You can select a different XML configuration file using:</para>
 
     <programlisting role="JAVA">SessionFactory sf = new Configuration()
     .configure("catdb.cfg.xml")
     .buildSessionFactory();</programlisting>
   </section>
 
   <section id="configuration-j2ee" revision="1">
     <title>Java EE Application Server integration</title>
 
     <para>Hibernate has the following integration points for J2EE
     infrastructure:</para>
 
     <itemizedlist>
       <listitem>
         <para><emphasis>Container-managed datasources</emphasis>: Hibernate
         can use JDBC connections managed by the container and provided through
         JNDI. Usually, a JTA compatible <literal>TransactionManager</literal>
         and a <literal>ResourceManager</literal> take care of transaction
         management (CMT), especially distributed transaction handling across
         several datasources. You can also demarcate transaction boundaries
         programmatically (BMT), or you might want to use the optional
         Hibernate <literal>Transaction</literal> API for this to keep your
         code portable.</para>
       </listitem>
     </itemizedlist>
 
     <itemizedlist>
       <listitem>
         <para><emphasis>Automatic JNDI binding</emphasis>: Hibernate can bind
         its <literal>SessionFactory</literal> to JNDI after startup.</para>
       </listitem>
     </itemizedlist>
 
     <itemizedlist>
       <listitem>
         <para><emphasis>JTA Session binding:</emphasis> the Hibernate
         <literal>Session</literal> can be automatically bound to the scope of
         JTA transactions. Simply lookup the <literal>SessionFactory</literal>
         from JNDI and get the current <literal>Session</literal>. Let
         Hibernate manage flushing and closing the <literal>Session</literal>
         when your JTA transaction completes. Transaction demarcation is either
         declarative (CMT) or programmatic (BMT/UserTransaction).</para>
       </listitem>
     </itemizedlist>
 
     <itemizedlist>
       <listitem>
         <para><emphasis>JMX deployment:</emphasis> if you have a JMX capable
         application server (e.g. JBoss AS), you can choose to deploy Hibernate
         as a managed MBean. This saves you the one line startup code to build
         your <literal>SessionFactory</literal> from a
         <literal>Configuration</literal>. The container will startup your
         <literal>HibernateService</literal> and also take care of service
         dependencies (datasource has to be available before Hibernate starts,
         etc).</para>
       </listitem>
     </itemizedlist>
 
     <para>Depending on your environment, you might have to set the
     configuration option
     <literal>hibernate.connection.aggressive_release</literal> to true if your
     application server shows "connection containment" exceptions.</para>
 
     <section id="configuration-optional-transactionstrategy" revision="3">
       <title>Transaction strategy configuration</title>
 
       <para>The Hibernate <literal>Session</literal> API is independent of any
       transaction demarcation system in your architecture. If you let
       Hibernate use JDBC directly through a connection pool, you can begin and
       end your transactions by calling the JDBC API. If you run in a J2EE
       application server, you might want to use bean-managed transactions and
       call the JTA API and <literal>UserTransaction</literal> when
       needed.</para>
 
       <para>To keep your code portable between these two (and other)
       environments we recommend the optional Hibernate
       <literal>Transaction</literal> API, which wraps and hides the underlying
       system. You have to specify a factory class for
       <literal>Transaction</literal> instances by setting the Hibernate
       configuration property
       <literal>hibernate.transaction.factory_class</literal>.</para>
 
       <para>There are three standard, or built-in, choices:</para>
 
       <variablelist spacing="compact">
         <varlistentry>
           <term><literal>org.hibernate.transaction.JDBCTransactionFactory</literal></term>
 
           <listitem>
             <para>delegates to database (JDBC) transactions (default)</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term><literal>org.hibernate.transaction.JTATransactionFactory</literal></term>
 
           <listitem>
             <para>delegates to container-managed transactions if an existing
             transaction is underway in this context (for example, EJB session
             bean method). Otherwise, a new transaction is started and
             bean-managed transactions are used.</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term><literal>org.hibernate.transaction.CMTTransactionFactory</literal></term>
 
           <listitem>
             <para>delegates to container-managed JTA transactions</para>
           </listitem>
         </varlistentry>
       </variablelist>
 
       <para>You can also define your own transaction strategies (for a CORBA
       transaction service, for example).</para>
 
       <para>Some features in Hibernate (i.e., the second level cache,
       Contextual Sessions with JTA, etc.) require access to the JTA
       <literal>TransactionManager</literal> in a managed environment. In an
       application server, since J2EE does not standardize a single mechanism,
       you have to specify how Hibernate should obtain a reference to the
       <literal>TransactionManager</literal>:</para>
 
       <table frame="topbot" id="jtamanagerlookup" revision="1">
         <title>JTA TransactionManagers</title>
 
         <tgroup cols="2">
           <colspec colwidth="2.5*" />
 
           <colspec colwidth="1*" />
 
           <thead>
             <row>
               <entry>Transaction Factory</entry>
 
               <entry align="center">Application Server</entry>
             </row>
           </thead>
 
           <tbody>
             <row>
               <entry><literal>org.hibernate.transaction.JBossTransactionManagerLookup</literal></entry>
 
               <entry align="center">JBoss AS</entry>
             </row>
 
             <row>
               <entry><literal>org.hibernate.transaction.WeblogicTransactionManagerLookup</literal></entry>
 
               <entry align="center">Weblogic</entry>
             </row>
 
             <row>
               <entry><literal>org.hibernate.transaction.WebSphereTransactionManagerLookup</literal></entry>
 
               <entry align="center">WebSphere</entry>
             </row>
 
             <row>
               <entry><literal>org.hibernate.transaction.WebSphereExtendedJTATransactionLookup</literal></entry>
 
               <entry align="center">WebSphere 6</entry>
             </row>
 
             <row>
               <entry><literal>org.hibernate.transaction.OrionTransactionManagerLookup</literal></entry>
 
               <entry align="center">Orion</entry>
             </row>
 
             <row>
               <entry><literal>org.hibernate.transaction.ResinTransactionManagerLookup</literal></entry>
 
               <entry align="center">Resin</entry>
             </row>
 
             <row>
               <entry><literal>org.hibernate.transaction.JOTMTransactionManagerLookup</literal></entry>
 
               <entry align="center">JOTM</entry>
             </row>
 
             <row>
               <entry><literal>org.hibernate.transaction.JOnASTransactionManagerLookup</literal></entry>
 
               <entry align="center">JOnAS</entry>
             </row>
 
             <row>
               <entry><literal>org.hibernate.transaction.JRun4TransactionManagerLookup</literal></entry>
 
               <entry align="center">JRun4</entry>
             </row>
 
             <row>
               <entry><literal>org.hibernate.transaction.BESTransactionManagerLookup</literal></entry>
 
               <entry align="center">Borland ES</entry>
             </row>
 
             <row>
               <entry><literal>org.hibernate.transaction.JBossTSStandaloneTransactionManagerLookup</literal></entry>
 
               <entry align="center">JBoss TS used standalone (ie. outside
               JBoss AS and a JNDI environment generally). Known to work for
               <literal>org.jboss.jbossts:jbossjta:4.11.0.Final</literal></entry>
             </row>
           </tbody>
         </tgroup>
       </table>
     </section>
 
     <section id="configuration-optional-jndi" revision="3">
       <title>JNDI-bound <literal>SessionFactory</literal></title>
 
       <para>A JNDI-bound Hibernate <literal>SessionFactory</literal> can
       simplify the lookup function of the factory and create new
       <literal>Session</literal>s. This is not, however, related to a JNDI
       bound <literal>Datasource</literal>; both simply use the same
       registry.</para>
 
       <para>If you wish to have the <literal>SessionFactory</literal> bound to
       a JNDI namespace, specify a name (e.g.
       <literal>java:hibernate/SessionFactory</literal>) using the property
       <literal>hibernate.session_factory_name</literal>. If this property is
       omitted, the <literal>SessionFactory</literal> will not be bound to
       JNDI. This is especially useful in environments with a read-only JNDI
       default implementation (in Tomcat, for example).</para>
 
       <para>When binding the <literal>SessionFactory</literal> to JNDI,
       Hibernate will use the values of <literal>hibernate.jndi.url</literal>,
       <literal>hibernate.jndi.class</literal> to instantiate an initial
       context. If they are not specified, the default
       <literal>InitialContext</literal> will be used.</para>
 
       <para>Hibernate will automatically place the
       <literal>SessionFactory</literal> in JNDI after you call
       <literal>cfg.buildSessionFactory()</literal>. This means you will have
       this call in some startup code, or utility class in your application,
       unless you use JMX deployment with the
       <literal>HibernateService</literal> (this is discussed later in greater
       detail).</para>
 
       <para>If you use a JNDI <literal>SessionFactory</literal>, an EJB or any
       other class, you can obtain the <literal>SessionFactory</literal> using
       a JNDI lookup.</para>
 
       <para>It is recommended that you bind the
       <literal>SessionFactory</literal> to JNDI in a managed environment and
       use a <literal>static</literal> singleton otherwise. To shield your
       application code from these details, we also recommend to hide the
       actual lookup code for a <literal>SessionFactory</literal> in a helper
       class, such as <literal>HibernateUtil.getSessionFactory()</literal>.
       Note that such a class is also a convenient way to startup Hibernate—see
       chapter 1.</para>
     </section>
 
     <section id="configuration-j2ee-currentsession" revision="4">
       <title>Current Session context management with JTA</title>
 
       <para>The easiest way to handle <literal>Sessions</literal> and
       transactions is Hibernate's automatic "current"
       <literal>Session</literal> management. For a discussion of contextual
       sessions see <xref linkend="architecture-current-session" />. Using the
       <literal>"jta"</literal> session context, if there is no Hibernate
       <literal>Session</literal> associated with the current JTA transaction,
       one will be started and associated with that JTA transaction the first
       time you call <literal>sessionFactory.getCurrentSession()</literal>. The
       <literal>Session</literal>s retrieved via
       <literal>getCurrentSession()</literal> in the <literal>"jta"</literal>
       context are set to automatically flush before the transaction completes,
       close after the transaction completes, and aggressively release JDBC
       connections after each statement. This allows the
       <literal>Session</literal>s to be managed by the life cycle of the JTA
       transaction to which it is associated, keeping user code clean of such
       management concerns. Your code can either use JTA programmatically
       through <literal>UserTransaction</literal>, or (recommended for portable
       code) use the Hibernate <literal>Transaction</literal> API to set
       transaction boundaries. If you run in an EJB container, declarative
       transaction demarcation with CMT is preferred.</para>
     </section>
 
     <section id="configuration-j2ee-jmx" revision="1">
       <title>JMX deployment</title>
 
       <para>The line <literal>cfg.buildSessionFactory()</literal> still has to
       be executed somewhere to get a <literal>SessionFactory</literal> into
       JNDI. You can do this either in a <literal>static</literal> initializer
       block, like the one in <literal>HibernateUtil</literal>, or you can
       deploy Hibernate as a <emphasis>managed service</emphasis>.</para>
 
       <para>Hibernate is distributed with
       <literal>org.hibernate.jmx.HibernateService</literal> for deployment on
       an application server with JMX capabilities, such as JBoss AS. The
       actual deployment and configuration is vendor-specific. Here is an
       example <literal>jboss-service.xml</literal> for JBoss 4.0.x:</para>
 
       <programlisting role="XML">&lt;?xml version="1.0"?&gt;
 &lt;server&gt;
 
 &lt;mbean code="org.hibernate.jmx.HibernateService"
     name="jboss.jca:service=HibernateFactory,name=HibernateFactory"&gt;
 
     &lt;!-- Required services --&gt;
     &lt;depends&gt;jboss.jca:service=RARDeployer&lt;/depends&gt;
     &lt;depends&gt;jboss.jca:service=LocalTxCM,name=HsqlDS&lt;/depends&gt;
 
     &lt;!-- Bind the Hibernate service to JNDI --&gt;
     &lt;attribute name="JndiName"&gt;java:/hibernate/SessionFactory&lt;/attribute&gt;
 
     &lt;!-- Datasource settings --&gt;
     &lt;attribute name="Datasource"&gt;java:HsqlDS&lt;/attribute&gt;
     &lt;attribute name="Dialect"&gt;org.hibernate.dialect.HSQLDialect&lt;/attribute&gt;
 
     &lt;!-- Transaction integration --&gt;
     &lt;attribute name="TransactionStrategy"&gt;
         org.hibernate.transaction.JTATransactionFactory&lt;/attribute&gt;
     &lt;attribute name="TransactionManagerLookupStrategy"&gt;
         org.hibernate.transaction.JBossTransactionManagerLookup&lt;/attribute&gt;
     &lt;attribute name="FlushBeforeCompletionEnabled"&gt;true&lt;/attribute&gt;
     &lt;attribute name="AutoCloseSessionEnabled"&gt;true&lt;/attribute&gt;
 
     &lt;!-- Fetching options --&gt;
     &lt;attribute name="MaximumFetchDepth"&gt;5&lt;/attribute&gt;
 
     &lt;!-- Second-level caching --&gt;
     &lt;attribute name="SecondLevelCacheEnabled"&gt;true&lt;/attribute&gt;
     &lt;attribute name="CacheProviderClass"&gt;org.hibernate.cache.internal.EhCacheProvider&lt;/attribute&gt;
     &lt;attribute name="QueryCacheEnabled"&gt;true&lt;/attribute&gt;
 
     &lt;!-- Logging --&gt;
     &lt;attribute name="ShowSqlEnabled"&gt;true&lt;/attribute&gt;
 
     &lt;!-- Mapping files --&gt;
     &lt;attribute name="MapResources"&gt;auction/Item.hbm.xml,auction/Category.hbm.xml&lt;/attribute&gt;
 
 &lt;/mbean&gt;
 
 &lt;/server&gt;</programlisting>
 
       <para>This file is deployed in a directory called
       <literal>META-INF</literal> and packaged in a JAR file with the
       extension <literal>.sar</literal> (service archive). You also need to
       package Hibernate, its required third-party libraries, your compiled
       persistent classes, as well as your mapping files in the same archive.
       Your enterprise beans (usually session beans) can be kept in their own
       JAR file, but you can include this EJB JAR file in the main service
       archive to get a single (hot-)deployable unit. Consult the JBoss AS
       documentation for more information about JMX service and EJB
       deployment.</para>
     </section>
   </section>
 </chapter>
diff --git a/etc/hibernate.properties b/etc/hibernate.properties
index 098787d587..668ea03a45 100644
--- a/etc/hibernate.properties
+++ b/etc/hibernate.properties
@@ -1,529 +1,529 @@
 ######################
 ### Query Language ###
 ######################
 
 ## define query language constants / function names
 
 hibernate.query.substitutions yes 'Y', no 'N'
 
 
 ## select the classic query parser
 
-#hibernate.query.factory_class org.hibernate.hql.classic.ClassicQueryTranslatorFactory
+#hibernate.query.factory_class org.hibernate.hql.internal.classic.ClassicQueryTranslatorFactory
 
 
 
 #################
 ### Platforms ###
 #################
 
 ## JNDI Datasource
 
 #hibernate.connection.datasource jdbc/test
 #hibernate.connection.username db2
 #hibernate.connection.password db2
 
 
 ## HypersonicSQL
 
 hibernate.dialect org.hibernate.dialect.HSQLDialect
 hibernate.connection.driver_class org.hsqldb.jdbcDriver
 hibernate.connection.username sa
 hibernate.connection.password
 hibernate.connection.url jdbc:hsqldb:./build/db/hsqldb/hibernate
 #hibernate.connection.url jdbc:hsqldb:hsql://localhost
 #hibernate.connection.url jdbc:hsqldb:test
 
 ## H2 (www.h2database.com)
 #hibernate.dialect org.hibernate.dialect.H2Dialect
 #hibernate.connection.driver_class org.h2.Driver
 #hibernate.connection.username sa
 #hibernate.connection.password
 #hibernate.connection.url jdbc:h2:mem:./build/db/h2/hibernate
 #hibernate.connection.url jdbc:h2:testdb/h2test
 #hibernate.connection.url jdbc:h2:mem:imdb1
 #hibernate.connection.url jdbc:h2:tcp://dbserv:8084/sample; 	
 #hibernate.connection.url jdbc:h2:ssl://secureserv:8085/sample; 	
 #hibernate.connection.url jdbc:h2:ssl://secureserv/testdb;cipher=AES
 
 ## MySQL
 
 #hibernate.dialect org.hibernate.dialect.MySQLDialect
 #hibernate.dialect org.hibernate.dialect.MySQLInnoDBDialect
 #hibernate.dialect org.hibernate.dialect.MySQLMyISAMDialect
 #hibernate.connection.driver_class com.mysql.jdbc.Driver
 #hibernate.connection.url jdbc:mysql:///test
 #hibernate.connection.username gavin
 #hibernate.connection.password
 
 
 ## Oracle
 
 #hibernate.dialect org.hibernate.dialect.Oracle8iDialect
 #hibernate.dialect org.hibernate.dialect.Oracle9iDialect
 #hibernate.dialect org.hibernate.dialect.Oracle10gDialect
 #hibernate.connection.driver_class oracle.jdbc.driver.OracleDriver
 #hibernate.connection.username ora
 #hibernate.connection.password ora
 #hibernate.connection.url jdbc:oracle:thin:@localhost:1521:orcl
 #hibernate.connection.url jdbc:oracle:thin:@localhost:1522:XE
 
 
 ## PostgreSQL
 
 #hibernate.dialect org.hibernate.dialect.PostgreSQLDialect
 #hibernate.connection.driver_class org.postgresql.Driver
 #hibernate.connection.url jdbc:postgresql:template1
 #hibernate.connection.username pg
 #hibernate.connection.password
 
 
 ## DB2
 
 #hibernate.dialect org.hibernate.dialect.DB2Dialect
 #hibernate.connection.driver_class com.ibm.db2.jcc.DB2Driver
 #hibernate.connection.driver_class COM.ibm.db2.jdbc.app.DB2Driver
 #hibernate.connection.url jdbc:db2://localhost:50000/somename
 #hibernate.connection.url jdbc:db2:somename
 #hibernate.connection.username db2
 #hibernate.connection.password db2
 
 ## TimesTen
 
 #hibernate.dialect org.hibernate.dialect.TimesTenDialect
 #hibernate.connection.driver_class com.timesten.jdbc.TimesTenDriver
 #hibernate.connection.url jdbc:timesten:direct:test
 #hibernate.connection.username
 #hibernate.connection.password 
 
 ## DB2/400
 
 #hibernate.dialect org.hibernate.dialect.DB2400Dialect
 #hibernate.connection.username user
 #hibernate.connection.password password
 
 ## Native driver
 #hibernate.connection.driver_class COM.ibm.db2.jdbc.app.DB2Driver
 #hibernate.connection.url jdbc:db2://systemname
 
 ## Toolbox driver
 #hibernate.connection.driver_class com.ibm.as400.access.AS400JDBCDriver
 #hibernate.connection.url jdbc:as400://systemname
 
 
 ## Derby (not supported!)
 
 #hibernate.dialect org.hibernate.dialect.DerbyDialect
 #hibernate.connection.driver_class org.apache.derby.jdbc.EmbeddedDriver
 #hibernate.connection.username
 #hibernate.connection.password
 #hibernate.connection.url jdbc:derby:build/db/derby/hibernate;create=true
 
 
 ## Sybase
 
 #hibernate.dialect org.hibernate.dialect.SybaseDialect
 #hibernate.connection.driver_class com.sybase.jdbc2.jdbc.SybDriver
 #hibernate.connection.username sa
 #hibernate.connection.password sasasa
 #hibernate.connection.url jdbc:sybase:Tds:co3061835-a:5000/tempdb
 
 
 ## Mckoi SQL
 
 #hibernate.dialect org.hibernate.dialect.MckoiDialect
 #hibernate.connection.driver_class com.mckoi.JDBCDriver
 #hibernate.connection.url jdbc:mckoi:///
 #hibernate.connection.url jdbc:mckoi:local://C:/mckoi1.0.3/db.conf
 #hibernate.connection.username admin
 #hibernate.connection.password nimda
 
 
 ## SAP DB
 
 #hibernate.dialect org.hibernate.dialect.SAPDBDialect
 #hibernate.connection.driver_class com.sap.dbtech.jdbc.DriverSapDB
 #hibernate.connection.url jdbc:sapdb://localhost/TST
 #hibernate.connection.username TEST
 #hibernate.connection.password TEST
 #hibernate.query.substitutions yes 'Y', no 'N'
 
 
 ## MS SQL Server
 
 #hibernate.dialect org.hibernate.dialect.SQLServerDialect
 #hibernate.connection.username sa
 #hibernate.connection.password sa
 
 ## JSQL Driver
 #hibernate.connection.driver_class com.jnetdirect.jsql.JSQLDriver
 #hibernate.connection.url jdbc:JSQLConnect://1E1/test
 
 ## JTURBO Driver
 #hibernate.connection.driver_class com.newatlanta.jturbo.driver.Driver
 #hibernate.connection.url jdbc:JTurbo://1E1:1433/test
 
 ## WebLogic Driver
 #hibernate.connection.driver_class weblogic.jdbc.mssqlserver4.Driver
 #hibernate.connection.url jdbc:weblogic:mssqlserver4:1E1:1433
 
 ## Microsoft Driver (not recommended!)
 #hibernate.connection.driver_class com.microsoft.jdbc.sqlserver.SQLServerDriver
 #hibernate.connection.url jdbc:microsoft:sqlserver://1E1;DatabaseName=test;SelectMethod=cursor
 
 ## The New Microsoft Driver 
 #hibernate.connection.driver_class com.microsoft.sqlserver.jdbc.SQLServerDriver
 #hibernate.connection.url jdbc:sqlserver://localhost
 
 ## jTDS (since version 0.9)
 #hibernate.connection.driver_class net.sourceforge.jtds.jdbc.Driver
 #hibernate.connection.url jdbc:jtds:sqlserver://1E1/test
 
 ## Interbase
 
 #hibernate.dialect org.hibernate.dialect.InterbaseDialect
 #hibernate.connection.username sysdba
 #hibernate.connection.password masterkey
 
 ## DO NOT specify hibernate.connection.sqlDialect
 
 ## InterClient
 
 #hibernate.connection.driver_class interbase.interclient.Driver
 #hibernate.connection.url jdbc:interbase://localhost:3060/C:/firebird/test.gdb
 
 ## Pure Java
 
 #hibernate.connection.driver_class org.firebirdsql.jdbc.FBDriver
 #hibernate.connection.url jdbc:firebirdsql:localhost/3050:/firebird/test.gdb
 
 
 ## Pointbase
 
 #hibernate.dialect org.hibernate.dialect.PointbaseDialect
 #hibernate.connection.driver_class com.pointbase.jdbc.jdbcUniversalDriver
 #hibernate.connection.url jdbc:pointbase:embedded:sample
 #hibernate.connection.username PBPUBLIC
 #hibernate.connection.password PBPUBLIC
 
 
 ## Ingres
 
 ## older versions (before Ingress 2006)
 
 #hibernate.dialect org.hibernate.dialect.IngresDialect
 #hibernate.connection.driver_class ca.edbc.jdbc.EdbcDriver
 #hibernate.connection.url jdbc:edbc://localhost:II7/database
 #hibernate.connection.username user
 #hibernate.connection.password password
 
 ## Ingres 2006 or later
 
 #hibernate.dialect org.hibernate.dialect.IngresDialect
 #hibernate.connection.driver_class com.ingres.jdbc.IngresDriver
 #hibernate.connection.url jdbc:ingres://localhost:II7/database;CURSOR=READONLY;auto=multi
 #hibernate.connection.username user
 #hibernate.connection.password password
 
 ## Mimer SQL
 
 #hibernate.dialect org.hibernate.dialect.MimerSQLDialect
 #hibernate.connection.driver_class com.mimer.jdbc.Driver
 #hibernate.connection.url jdbc:mimer:multi1
 #hibernate.connection.username hibernate
 #hibernate.connection.password hibernate
 
 
 ## InterSystems Cache
 
 #hibernate.dialect org.hibernate.dialect.Cache71Dialect
 #hibernate.connection.driver_class com.intersys.jdbc.CacheDriver
 #hibernate.connection.username _SYSTEM
 #hibernate.connection.password SYS
 #hibernate.connection.url jdbc:Cache://127.0.0.1:1972/HIBERNATE
 
 
 #################################
 ### Hibernate Connection Pool ###
 #################################
 
 hibernate.connection.pool_size 1
 
 
 
 ###########################
 ### C3P0 Connection Pool###
 ###########################
 
 #hibernate.c3p0.max_size 2
 #hibernate.c3p0.min_size 2
 #hibernate.c3p0.timeout 5000
 #hibernate.c3p0.max_statements 100
 #hibernate.c3p0.idle_test_period 3000
 #hibernate.c3p0.acquire_increment 2
 #hibernate.c3p0.validate false
 
 
 
 ##############################
 ### Proxool Connection Pool###
 ##############################
 
 ## Properties for external configuration of Proxool
 
 hibernate.proxool.pool_alias pool1
 
 ## Only need one of the following
 
 #hibernate.proxool.existing_pool true
 #hibernate.proxool.xml proxool.xml
 #hibernate.proxool.properties proxool.properties
 
 
 
 #################################
 ### Plugin ConnectionProvider ###
 #################################
 
 ## use a custom ConnectionProvider (if not set, Hibernate will choose a built-in ConnectionProvider using hueristics)
 
 #hibernate.connection.provider_class org.hibernate.connection.DriverManagerConnectionProvider
 #hibernate.connection.provider_class org.hibernate.connection.DatasourceConnectionProvider
 #hibernate.connection.provider_class org.hibernate.connection.C3P0ConnectionProvider
 #hibernate.connection.provider_class org.hibernate.connection.ProxoolConnectionProvider
 
 
 
 #######################
 ### Transaction API ###
 #######################
 
 ## Enable automatic flush during the JTA beforeCompletion() callback
 ## (This setting is relevant with or without the Transaction API)
 
 #hibernate.transaction.flush_before_completion
 
 
 ## Enable automatic session close at the end of transaction
 ## (This setting is relevant with or without the Transaction API)
 
 #hibernate.transaction.auto_close_session
 
 
 ## the Transaction API abstracts application code from the underlying JTA or JDBC transactions
 
 #hibernate.transaction.factory_class org.hibernate.transaction.JTATransactionFactory
 #hibernate.transaction.factory_class org.hibernate.transaction.JDBCTransactionFactory
 
 
 ## to use JTATransactionFactory, Hibernate must be able to locate the UserTransaction in JNDI
 ## default is java:comp/UserTransaction
 ## you do NOT need this setting if you specify hibernate.transaction.manager_lookup_class
 
 #jta.UserTransaction jta/usertransaction
 #jta.UserTransaction javax.transaction.UserTransaction
 #jta.UserTransaction UserTransaction
 
 
 ## to use the second-level cache with JTA, Hibernate must be able to obtain the JTA TransactionManager
 
 #hibernate.transaction.manager_lookup_class org.hibernate.transaction.JBossTransactionManagerLookup
 #hibernate.transaction.manager_lookup_class org.hibernate.transaction.WeblogicTransactionManagerLookup
 #hibernate.transaction.manager_lookup_class org.hibernate.transaction.WebSphereTransactionManagerLookup
 #hibernate.transaction.manager_lookup_class org.hibernate.transaction.OrionTransactionManagerLookup
 #hibernate.transaction.manager_lookup_class org.hibernate.transaction.ResinTransactionManagerLookup
 
 
 
 ##############################
 ### Miscellaneous Settings ###
 ##############################
 
 ## print all generated SQL to the console
 
 #hibernate.show_sql true
 
 
 ## format SQL in log and console
 
 hibernate.format_sql true
 
 
 ## add comments to the generated SQL
 
 #hibernate.use_sql_comments true
 
 
 ## generate statistics
 
 #hibernate.generate_statistics true
 
 
 ## auto schema export
 
 #hibernate.hbm2ddl.auto create-drop
 #hibernate.hbm2ddl.auto create
 #hibernate.hbm2ddl.auto update
 #hibernate.hbm2ddl.auto validate
 
 
 ## specify a default schema and catalog for unqualified tablenames
 
 #hibernate.default_schema test
 #hibernate.default_catalog test
 
 
 ## enable ordering of SQL UPDATEs by primary key
 
 #hibernate.order_updates true
 
 
 ## set the maximum depth of the outer join fetch tree
 
 hibernate.max_fetch_depth 1
 
 
 ## set the default batch size for batch fetching
 
 #hibernate.default_batch_fetch_size 8
 
 
 ## rollback generated identifier values of deleted entities to default values
 
 #hibernate.use_identifer_rollback true
 
 
 ## enable bytecode reflection optimizer (disabled by default)
 
 #hibernate.bytecode.use_reflection_optimizer true
 
 
 
 #####################
 ### JDBC Settings ###
 #####################
 
 ## specify a JDBC isolation level
 
 #hibernate.connection.isolation 4
 
 
 ## enable JDBC autocommit (not recommended!)
 
 #hibernate.connection.autocommit true
 
 
 ## set the JDBC fetch size
 
 #hibernate.jdbc.fetch_size 25
 
 
 ## set the maximum JDBC 2 batch size (a nonzero value enables batching)
 
 #hibernate.jdbc.batch_size 5
 #hibernate.jdbc.batch_size 0
 
 
 ## enable batch updates even for versioned data
 
 hibernate.jdbc.batch_versioned_data true
 
 
 ## enable use of JDBC 2 scrollable ResultSets (specifying a Dialect will cause Hibernate to use a sensible default)
 
 #hibernate.jdbc.use_scrollable_resultset true
 
 
 ## use streams when writing binary types to / from JDBC
 
 hibernate.jdbc.use_streams_for_binary true
 
 
 ## use JDBC 3 PreparedStatement.getGeneratedKeys() to get the identifier of an inserted row
 
 #hibernate.jdbc.use_get_generated_keys false
 
 
 ## choose a custom JDBC batcher
 
 # hibernate.jdbc.factory_class
 
 
 ## enable JDBC result set column alias caching 
 ## (minor performance enhancement for broken JDBC drivers)
 
 # hibernate.jdbc.wrap_result_sets
 
 
 ## choose a custom SQL exception converter
 
 #hibernate.jdbc.sql_exception_converter
 
 
 
 ##########################
 ### Second-level Cache ###
 ##########################
 
 ## optimize chache for minimal "puts" instead of minimal "gets" (good for clustered cache)
 
 #hibernate.cache.use_minimal_puts true
 
 
 ## set a prefix for cache region names
 
 hibernate.cache.region_prefix hibernate.test
 
 
 ## disable the second-level cache
 
 #hibernate.cache.use_second_level_cache false
 
 
 ## enable the query cache
 
 #hibernate.cache.use_query_cache true
 
 
 ## store the second-level cache entries in a more human-friendly format
 
 #hibernate.cache.use_structured_entries true
 
 
 ## choose a cache implementation
 
 #hibernate.cache.provider_class org.hibernate.cache.EhCacheProvider
 #hibernate.cache.provider_class org.hibernate.cache.EmptyCacheProvider
 hibernate.cache.provider_class org.hibernate.cache.internal.HashtableCacheProvider
 #hibernate.cache.provider_class org.hibernate.cache.TreeCacheProvider
 #hibernate.cache.provider_class org.hibernate.cache.OSCacheProvider
 #hibernate.cache.provider_class org.hibernate.cache.SwarmCacheProvider
 
 
 ## choose a custom query cache implementation
 
 #hibernate.cache.query_cache_factory
 
 
 
 ############
 ### JNDI ###
 ############
 
 ## specify a JNDI name for the SessionFactory
 
 #hibernate.session_factory_name hibernate/session_factory
 
 
 ## Hibernate uses JNDI to bind a name to a SessionFactory and to look up the JTA UserTransaction;
 ## if hibernate.jndi.* are not specified, Hibernate will use the default InitialContext() which
 ## is the best approach in an application server
 
 #file system
 #hibernate.jndi.class com.sun.jndi.fscontext.RefFSContextFactory
 #hibernate.jndi.url file:/
 
 #WebSphere
 #hibernate.jndi.class com.ibm.websphere.naming.WsnInitialContextFactory
 #hibernate.jndi.url iiop://localhost:900/
 
diff --git a/hibernate-core/src/main/antlr/hql-sql.g b/hibernate-core/src/main/antlr/hql-sql.g
index 01a64e4849..f830f7ba1c 100644
--- a/hibernate-core/src/main/antlr/hql-sql.g
+++ b/hibernate-core/src/main/antlr/hql-sql.g
@@ -1,741 +1,741 @@
 header
 {
-package org.hibernate.hql.antlr;
+package org.hibernate.hql.internal.antlr;
 
 import org.hibernate.internal.CoreMessageLogger;
 import org.jboss.logging.Logger;
 }
 
 /**
  * Hibernate Query Language to SQL Tree Transform.<br>
  * This is a tree grammar that transforms an HQL AST into a intermediate SQL AST
  * with bindings to Hibernate interfaces (Queryable, etc.).  The Hibernate specific methods
  * are all implemented in the HqlSqlWalker subclass, allowing the ANTLR-generated class
  * to have only the minimum dependencies on the Hibernate code base.   This will also allow
  * the sub-class to be easily edited using an IDE (most IDE's don't support ANTLR).
  * <br>
  * <i>NOTE:</i> The java class is generated from hql-sql.g by ANTLR.
  * <i>DO NOT EDIT THE GENERATED JAVA SOURCE CODE.</i>
  * @author Joshua Davis (joshua@hibernate.org)
  */
 class HqlSqlBaseWalker extends TreeParser;
 
 options
 {
 	// Note: importVocab and exportVocab cause ANTLR to share the token type numbers between the
 	// two grammars.  This means that the token type constants from the source tree are the same
 	// as those in the target tree.  If this is not the case, tree translation can result in
 	// token types from the *source* tree being present in the target tree.
 	importVocab=Hql;        // import definitions from "Hql"
 	exportVocab=HqlSql;     // Call the resulting definitions "HqlSql"
 	buildAST=true;
 }
 
 tokens
 {
 	FROM_FRAGMENT;	// A fragment of SQL that represents a table reference in a FROM clause.
 	IMPLIED_FROM;	// An implied FROM element.
 	JOIN_FRAGMENT;	// A JOIN fragment.
 	SELECT_CLAUSE;
 	LEFT_OUTER;
 	RIGHT_OUTER;
 	ALIAS_REF;      // An IDENT that is a reference to an entity via it's alias.
 	PROPERTY_REF;   // A DOT that is a reference to a property in an entity.
 	SQL_TOKEN;      // A chunk of SQL that is 'rendered' already.
 	SELECT_COLUMNS; // A chunk of SQL representing a bunch of select columns.
 	SELECT_EXPR;    // A select expression, generated from a FROM element.
 	THETA_JOINS;	// Root of theta join condition subtree.
 	FILTERS;		// Root of the filters condition subtree.
 	METHOD_NAME;    // An IDENT that is a method name.
 	NAMED_PARAM;    // A named parameter (:foo).
 	BOGUS;          // Used for error state detection, etc.
 	RESULT_VARIABLE_REF;   // An IDENT that refers to result variable
 	                       // (i.e, an alias for a select expression) 
 }
 
 // -- Declarations --
 {
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, HqlSqlBaseWalker.class.getName());
 
 	private int level = 0;
 	private boolean inSelect = false;
 	private boolean inFunctionCall = false;
 	private boolean inCase = false;
 	private boolean inFrom = false;
 	private int statementType;
 	private String statementTypeName;
 	// Note: currentClauseType tracks the current clause within the current
 	// statement, regardless of level; currentTopLevelClauseType, on the other
 	// hand, tracks the current clause within the top (or primary) statement.
 	// Thus, currentTopLevelClauseType ignores the clauses from any subqueries.
 	private int currentClauseType;
 	private int currentTopLevelClauseType;
 	private int currentStatementType;
 
 	public final boolean isSubQuery() {
 		return level > 1;
 	}
 
 	public final boolean isInFrom() {
 		return inFrom;
 	}
 
 	public final boolean isInFunctionCall() {
 		return inFunctionCall;
 	}
 	
 	public final boolean isInSelect() {
 		return inSelect;
 	}
 
 	public final boolean isInCase() {
 		return inCase;
 	}
 
 	public final int getStatementType() {
 		return statementType;
 	}
 
 	public final int getCurrentClauseType() {
 		return currentClauseType;
 	}
 
 	public final int getCurrentTopLevelClauseType() {
 		return currentTopLevelClauseType;
 	}
 
 	public final int getCurrentStatementType() {
 		return currentStatementType;
 	}
 
 	public final boolean isComparativeExpressionClause() {
 		// Note: once we add support for "JOIN ... ON ...",
 		// the ON clause needs to get included here
 	    return getCurrentClauseType() == WHERE ||
 	            getCurrentClauseType() == WITH ||
 	            isInCase();
 	}
 
 	public final boolean isSelectStatement() {
 		return statementType == SELECT;
 	}
 
 	private void beforeStatement(String statementName, int statementType) {
 		inFunctionCall = false;
 		level++;
 		if ( level == 1 ) {
 			this.statementTypeName = statementName;
 			this.statementType = statementType;
 		}
 		currentStatementType = statementType;
 		LOG.debugf("%s << begin [level=%s, statement=%s]", statementName, level, this.statementTypeName);
 	}
 
 	private void beforeStatementCompletion(String statementName) {
         LOG.debugf("%s : finishing up [level=%s, statement=%s]", statementName, level, this.statementTypeName);
 	}
 
 	private void afterStatementCompletion(String statementName) {
         LOG.debugf("%s >> end [level=%s, statement=%s]", statementName, level, this.statementTypeName);
 		level--;
 	}
 
 	private void handleClauseStart(int clauseType) {
 		currentClauseType = clauseType;
 		if ( level == 1 ) {
 			currentTopLevelClauseType = clauseType;
 		}
 	}
 
 	///////////////////////////////////////////////////////////////////////////
 	// NOTE: The real implementations for the following are in the subclass.
 
 	protected void evaluateAssignment(AST eq) throws SemanticException { }
 	
 	/** Pre-process the from clause input tree. **/
 	protected void prepareFromClauseInputTree(AST fromClauseInput) {}
 
 	/** Sets the current 'FROM' context. **/
 	protected void pushFromClause(AST fromClause,AST inputFromNode) {}
 
 	protected AST createFromElement(String path,AST alias,AST propertyFetch) throws SemanticException {
 		return null;
 	}
 
 	protected void createFromJoinElement(AST path,AST alias,int joinType,AST fetch,AST propertyFetch,AST with) throws SemanticException {}
 
 	protected AST createFromFilterElement(AST filterEntity,AST alias) throws SemanticException	{
 		return null;
 	}
 
 	protected void processQuery(AST select,AST query) throws SemanticException { }
 
 	protected void postProcessUpdate(AST update) throws SemanticException { }
 
 	protected void postProcessDelete(AST delete) throws SemanticException { }
 
 	protected void postProcessInsert(AST insert) throws SemanticException { }
 
 	protected void beforeSelectClause() throws SemanticException { }
 
 	protected void processIndex(AST indexOp) throws SemanticException { }
 
 	protected void processConstant(AST constant) throws SemanticException { }
 
 	protected void processBoolean(AST constant) throws SemanticException { }
 
 	protected void processNumericLiteral(AST literal) throws SemanticException { }
 
 	protected void resolve(AST node) throws SemanticException { }
 
 	protected void resolveSelectExpression(AST dotNode) throws SemanticException { }
 
 	protected void processFunction(AST functionCall,boolean inSelect) throws SemanticException { }
 
 	protected void processAggregation(AST node, boolean inSelect) throws SemanticException { }
 
 	protected void processConstructor(AST constructor) throws SemanticException { }
 
 	protected AST generateNamedParameter(AST delimiterNode, AST nameNode) throws SemanticException {
 		return #( [NAMED_PARAM, nameNode.getText()] );
 	}
 
 	protected AST generatePositionalParameter(AST inputNode) throws SemanticException {
 		return #( [PARAM, "?"] );
 	}
 
 	protected void lookupAlias(AST ident) throws SemanticException { }
 
 	protected void setAlias(AST selectExpr, AST ident) { }
 
 	protected boolean isOrderExpressionResultVariableRef(AST ident) throws SemanticException {
 		return false;
 	}
 
 	protected void handleResultVariableRef(AST resultVariableRef) throws SemanticException {
 	}
 
 	protected AST lookupProperty(AST dot,boolean root,boolean inSelect) throws SemanticException {
 		return dot;
 	}
 
 	protected boolean isNonQualifiedPropertyRef(AST ident) { return false; }
 
 	protected AST lookupNonQualifiedProperty(AST property) throws SemanticException { return property; }
 
 	protected void setImpliedJoinType(int joinType) { }
 
 	protected AST createIntoClause(String path, AST propertySpec) throws SemanticException {
 		return null;
 	};
 
 	protected void prepareVersioned(AST updateNode, AST versionedNode) throws SemanticException {}
 
 	protected void prepareLogicOperator(AST operator) throws SemanticException { }
 
 	protected void prepareArithmeticOperator(AST operator) throws SemanticException { }
 
     protected void processMapComponentReference(AST node) throws SemanticException { }
 
 	protected void validateMapPropertyExpression(AST node) throws SemanticException { }
 }
 
 // The main statement rule.
 statement
 	: selectStatement | updateStatement | deleteStatement | insertStatement
 	;
 
 selectStatement
 	: query
 	;
 
 // Cannot use just the fromElement rule here in the update and delete queries
 // because fromElement essentially relies on a FromClause already having been
 // built :(
 updateStatement!
 	: #( u:UPDATE { beforeStatement( "update", UPDATE ); } (v:VERSIONED)? f:fromClause s:setClause (w:whereClause)? ) {
 		#updateStatement = #(#u, #f, #s, #w);
 		beforeStatementCompletion( "update" );
 		prepareVersioned( #updateStatement, #v );
 		postProcessUpdate( #updateStatement );
 		afterStatementCompletion( "update" );
 	}
 	;
 
 deleteStatement
 	: #( DELETE { beforeStatement( "delete", DELETE ); } fromClause (whereClause)? ) {
 		beforeStatementCompletion( "delete" );
 		postProcessDelete( #deleteStatement );
 		afterStatementCompletion( "delete" );
 	}
 	;
 
 insertStatement
 	// currently only "INSERT ... SELECT ..." statements supported;
 	// do we also need support for "INSERT ... VALUES ..."?
 	//
 	: #( INSERT { beforeStatement( "insert", INSERT ); } intoClause query ) {
 		beforeStatementCompletion( "insert" );
 		postProcessInsert( #insertStatement );
 		afterStatementCompletion( "insert" );
 	}
 	;
 
 intoClause! {
 		String p = null;
 	}
 	: #( INTO { handleClauseStart( INTO ); } (p=path) ps:insertablePropertySpec ) {
 		#intoClause = createIntoClause(p, ps);
 	}
 	;
 
 insertablePropertySpec
 	: #( RANGE (IDENT)+ )
 	;
 
 setClause
 	: #( SET { handleClauseStart( SET ); } (assignment)* )
 	;
 
 assignment
 	// Note: the propertyRef here needs to be resolved
 	// *before* we evaluate the newValue rule...
 	: #( EQ (p:propertyRef) { resolve(#p); } (newValue) ) {
 		evaluateAssignment( #assignment );
 	}
 	;
 
 // For now, just use expr.  Revisit after ejb3 solidifies this.
 newValue
 	: expr | query
 	;
 
 // The query / subquery rule. Pops the current 'from node' context 
 // (list of aliases).
 query!
 	: #( QUERY { beforeStatement( "select", SELECT ); }
 			// The first phase places the FROM first to make processing the SELECT simpler.
 			#(SELECT_FROM
 				f:fromClause
 				(s:selectClause)?
 			)
 			(w:whereClause)?
 			(g:groupClause)?
 			(o:orderClause)?
 		) {
 		// Antlr note: #x_in refers to the input AST, #x refers to the output AST
 		#query = #([SELECT,"SELECT"], #s, #f, #w, #g, #o);
 		beforeStatementCompletion( "select" );
 		processQuery( #s, #query );
 		afterStatementCompletion( "select" );
 	}
 	;
 
 orderClause
 	: #(ORDER { handleClauseStart( ORDER ); } orderExprs)
 	;
 
 orderExprs
 	: orderExpr ( ASCENDING | DESCENDING )? (orderExprs)?
 	;
 
 orderExpr
 	: { isOrderExpressionResultVariableRef( _t ) }? resultVariableRef
 	| expr
 	;
 
 resultVariableRef!
 	: i:identifier {
 		// Create a RESULT_VARIABLE_REF node instead of an IDENT node.
 		#resultVariableRef = #([RESULT_VARIABLE_REF, i.getText()]);
 		handleResultVariableRef(#resultVariableRef);
 	}
 	;
 
 groupClause
 	: #(GROUP { handleClauseStart( GROUP ); } (expr)+ ( #(HAVING logicalExpr) )? )
 	;
 
 selectClause!
 	: #(SELECT { handleClauseStart( SELECT ); beforeSelectClause(); } (d:DISTINCT)? x:selectExprList ) {
 		#selectClause = #([SELECT_CLAUSE,"{select clause}"], #d, #x);
 	}
 	;
 
 selectExprList {
 		boolean oldInSelect = inSelect;
 		inSelect = true;
 	}
 	: ( selectExpr | aliasedSelectExpr )+ {
 		inSelect = oldInSelect;
 	}
 	;
 
 aliasedSelectExpr!
 	: #(AS se:selectExpr i:identifier) {
 		setAlias(#se,#i);
 		#aliasedSelectExpr = #se;
 	}
 	;
 
 selectExpr
 	: p:propertyRef					{ resolveSelectExpression(#p); }
 	| #(ALL ar2:aliasRef) 			{ resolveSelectExpression(#ar2); #selectExpr = #ar2; }
 	| #(OBJECT ar3:aliasRef)		{ resolveSelectExpression(#ar3); #selectExpr = #ar3; }
 	| con:constructor 				{ processConstructor(#con); }
 	| functionCall
 	| count
 	| collectionFunction			// elements() or indices()
 	| literal
 	| arithmeticExpr
 	| query
 	;
 
 count
 	: #(COUNT ( DISTINCT | ALL )? ( aggregateExpr | ROW_STAR ) )
 	;
 
 constructor
 	{ String className = null; }
 	: #(CONSTRUCTOR className=path ( selectExpr | aliasedSelectExpr )* )
 	;
 
 aggregateExpr
 	: expr //p:propertyRef { resolve(#p); }
 	| collectionFunction
 	;
 
 // Establishes the list of aliases being used by this query.
 fromClause {
 		// NOTE: This references the INPUT AST! (see http://www.antlr.org/doc/trees.html#Action%20Translation)
 		// the ouput AST (#fromClause) has not been built yet.
 		prepareFromClauseInputTree(#fromClause_in);
 	}
 	: #(f:FROM { pushFromClause(#fromClause,f); handleClauseStart( FROM ); } fromElementList )
 	;
 
 fromElementList {
 		boolean oldInFrom = inFrom;
 		inFrom = true;
 		}
 	: (fromElement)+ {
 		inFrom = oldInFrom;
 		}
 	;
 
 fromElement! {
 	String p = null;
 	}
 	// A simple class name, alias element.
 	: #(RANGE p=path (a:ALIAS)? (pf:FETCH)? ) {
 		#fromElement = createFromElement(p,a, pf);
 	}
 	| je:joinElement {
 		#fromElement = #je;
 	}
 	// A from element created due to filter compilation
 	| fe:FILTER_ENTITY a3:ALIAS {
 		#fromElement = createFromFilterElement(fe,a3);
 	}
 	;
 
 joinElement! {
 		int j = INNER;
 	}
 	// A from element with a join.  This time, the 'path' should be treated as an AST
 	// and resolved (like any path in a WHERE clause).   Make sure all implied joins
 	// generated by the property ref use the join type, if it was specified.
 	: #(JOIN (j=joinType { setImpliedJoinType(j); } )? (f:FETCH)? ref:propertyRef (a:ALIAS)? (pf:FETCH)? (with:WITH)? ) {
 		//createFromJoinElement(#ref,a,j,f, pf);
 		createFromJoinElement(#ref,a,j,f, pf, with);
 		setImpliedJoinType(INNER);	// Reset the implied join type.
 	}
 	;
 
 // Returns an node type integer that represents the join type
 // tokens.
 joinType returns [int j] {
 	j = INNER;
 	}
 	: ( (left:LEFT | right:RIGHT) (outer:OUTER)? ) {
 		if (left != null)       j = LEFT_OUTER;
 		else if (right != null) j = RIGHT_OUTER;
 		else if (outer != null) j = RIGHT_OUTER;
 	}
 	| FULL {
 		j = FULL;
 	}
 	| INNER {
 		j = INNER;
 	}
 	;
 
 // Matches a path and returns the normalized string for the path (usually
 // fully qualified a class name).
 path returns [String p] {
 	p = "???";
 	String x = "?x?";
 	}
 	: a:identifier { p = a.getText(); }
 	| #(DOT x=path y:identifier) {
 			StringBuffer buf = new StringBuffer();
 			buf.append(x).append(".").append(y.getText());
 			p = buf.toString();
 		}
 	;
 
 // Returns a path as a single identifier node.
 pathAsIdent {
     String text = "?text?";
     }
     : text=path {
         #pathAsIdent = #([IDENT,text]);
     }
     ;
 
 withClause
 	// Note : this is used internally from the HqlSqlWalker to
 	// parse the node recognized with the with keyword earlier.
 	// Done this way because it relies on the join it "qualifies"
 	// already having been processed, which would not be the case
 	// if withClause was simply referenced from the joinElement
 	// rule during recognition...
 	: #(w:WITH { handleClauseStart( WITH ); } b:logicalExpr ) {
 		#withClause = #(w , #b);
 	}
 	;
 
 whereClause
 	: #(w:WHERE { handleClauseStart( WHERE ); } b:logicalExpr ) {
 		// Use the *output* AST for the boolean expression!
 		#whereClause = #(w , #b);
 	}
 	;
 
 logicalExpr
 	: #(AND logicalExpr logicalExpr)
 	| #(OR logicalExpr logicalExpr)
 	| #(NOT logicalExpr)
 	| comparisonExpr
 	;
 
 // TODO: Add any other comparison operators here.
 comparisonExpr
 	:
 	( #(EQ exprOrSubquery exprOrSubquery)
 	| #(NE exprOrSubquery exprOrSubquery)
 	| #(LT exprOrSubquery exprOrSubquery)
 	| #(GT exprOrSubquery exprOrSubquery)
 	| #(LE exprOrSubquery exprOrSubquery)
 	| #(GE exprOrSubquery exprOrSubquery)
 	| #(LIKE exprOrSubquery expr ( #(ESCAPE expr) )? )
 	| #(NOT_LIKE exprOrSubquery expr ( #(ESCAPE expr) )? )
 	| #(BETWEEN exprOrSubquery exprOrSubquery exprOrSubquery)
 	| #(NOT_BETWEEN exprOrSubquery exprOrSubquery exprOrSubquery)
 	| #(IN exprOrSubquery inRhs )
 	| #(NOT_IN exprOrSubquery inRhs )
 	| #(IS_NULL exprOrSubquery)
 	| #(IS_NOT_NULL exprOrSubquery)
 //	| #(IS_TRUE expr)
 //	| #(IS_FALSE expr)
 	| #(EXISTS ( expr | collectionFunctionOrSubselect ) )
 	) {
 	    prepareLogicOperator( #comparisonExpr );
 	}
 	;
 
 inRhs
 	: #(IN_LIST ( collectionFunctionOrSubselect | ( (expr)* ) ) )
 	;
 
 exprOrSubquery
 	: expr
 	| query
 	| #(ANY collectionFunctionOrSubselect)
 	| #(ALL collectionFunctionOrSubselect)
 	| #(SOME collectionFunctionOrSubselect)
 	;
 	
 collectionFunctionOrSubselect
 	: collectionFunction
 	| query
 	;
 	
 expr
 	: ae:addrExpr [ true ] { resolve(#ae); }	// Resolve the top level 'address expression'
 	| #( VECTOR_EXPR (expr)* )
 	| constant
 	| arithmeticExpr
 	| functionCall							// Function call, not in the SELECT clause.
 	| parameter
 	| count										// Count, not in the SELECT clause.
 	;
 
 arithmeticExpr
     : #(PLUS exprOrSubquery exprOrSubquery)         { prepareArithmeticOperator( #arithmeticExpr ); }
     | #(MINUS exprOrSubquery exprOrSubquery)        { prepareArithmeticOperator( #arithmeticExpr ); }
     | #(DIV exprOrSubquery exprOrSubquery)          { prepareArithmeticOperator( #arithmeticExpr ); }
     | #(MOD exprOrSubquery exprOrSubquery)          { prepareArithmeticOperator( #arithmeticExpr ); }
     | #(STAR exprOrSubquery exprOrSubquery)         { prepareArithmeticOperator( #arithmeticExpr ); }
 //	| #(CONCAT expr (expr)+ )   { prepareArithmeticOperator( #arithmeticExpr ); }
 	| #(UNARY_MINUS expr)       { prepareArithmeticOperator( #arithmeticExpr ); }
 	| caseExpr
 	;
 
 caseExpr
 	: #(CASE { inCase = true; } (#(WHEN logicalExpr expr))+ (#(ELSE expr))?) { inCase = false; }
 	| #(CASE2 { inCase = true; } expr (#(WHEN expr expr))+ (#(ELSE expr))?) { inCase = false; }
 	;
 
 //TODO: I don't think we need this anymore .. how is it different to 
 //      maxelements, etc, which are handled by functionCall
 collectionFunction
 	: #(e:ELEMENTS {inFunctionCall=true;} p1:propertyRef { resolve(#p1); } ) 
 		{ processFunction(#e,inSelect); } {inFunctionCall=false;}
 	| #(i:INDICES {inFunctionCall=true;} p2:propertyRef { resolve(#p2); } ) 
 		{ processFunction(#i,inSelect); } {inFunctionCall=false;}
 	;
 
 functionCall
 	: #(METHOD_CALL  {inFunctionCall=true;} pathAsIdent ( #(EXPR_LIST (exprOrSubquery)* ) )? ) {
         processFunction( #functionCall, inSelect );
         inFunctionCall=false;
     }
 	| #(AGGREGATE aggregateExpr )
 	;
 
 constant
 	: literal
 	| NULL
 	| TRUE { processBoolean(#constant); } 
 	| FALSE { processBoolean(#constant); }
 	| JAVA_CONSTANT
 	;
 
 literal
 	: NUM_INT { processNumericLiteral( #literal ); }
 	| NUM_LONG { processNumericLiteral( #literal ); }
 	| NUM_FLOAT { processNumericLiteral( #literal ); }
 	| NUM_DOUBLE { processNumericLiteral( #literal ); }
 	| NUM_BIG_INTEGER { processNumericLiteral( #literal ); }
 	| NUM_BIG_DECIMAL { processNumericLiteral( #literal ); }
 	| QUOTED_STRING
 	;
 
 identifier
 	: (IDENT | WEIRD_IDENT)
 	;
 
 addrExpr! [ boolean root ]
 	: #(d:DOT lhs:addrExprLhs rhs:propertyName )	{
 		// This gives lookupProperty() a chance to transform the tree 
 		// to process collection properties (.elements, etc).
 		#addrExpr = #(#d, #lhs, #rhs);
 		#addrExpr = lookupProperty(#addrExpr,root,false);
 	}
 	| #(i:INDEX_OP lhs2:addrExprLhs rhs2:expr)	{
 		#addrExpr = #(#i, #lhs2, #rhs2);
 		processIndex(#addrExpr);
 	}
 	| p:identifier {
 //		#addrExpr = #p;
 //		resolve(#addrExpr);
 		// In many cases, things other than property-refs are recognized
 		// by this addrExpr rule.  Some of those I have seen:
 		//  1) select-clause from-aliases
 		//  2) sql-functions
 		if ( isNonQualifiedPropertyRef(#p) ) {
 			#addrExpr = lookupNonQualifiedProperty(#p);
 		}
 		else {
 			resolve(#p);
 			#addrExpr = #p;
 		}
 	}
 	;
 
 addrExprLhs
 	: addrExpr [ false ]
 	;
 
 propertyName
 	: identifier
 	| CLASS
 	| ELEMENTS
 	| INDICES
 	;
 
 propertyRef!
 	: mcr:mapComponentReference {
 	    resolve( #mcr );
 	    #propertyRef = #mcr;
 	}
 	| #(d:DOT lhs:propertyRefLhs rhs:propertyName )	{
 		// This gives lookupProperty() a chance to transform the tree to process collection properties (.elements, etc).
 		#propertyRef = #(#d, #lhs, #rhs);
 		#propertyRef = lookupProperty(#propertyRef,false,true);
 	}
 	|
 	p:identifier {
 		// In many cases, things other than property-refs are recognized
 		// by this propertyRef rule.  Some of those I have seen:
 		//  1) select-clause from-aliases
 		//  2) sql-functions
 		if ( isNonQualifiedPropertyRef(#p) ) {
 			#propertyRef = lookupNonQualifiedProperty(#p);
 		}
 		else {
 			resolve(#p);
 			#propertyRef = #p;
 		}
 	}
 	;
 
 propertyRefLhs
 	: propertyRef
 	;
 
 aliasRef!
 	: i:identifier {
 		#aliasRef = #([ALIAS_REF,i.getText()]);	// Create an ALIAS_REF node instead of an IDENT node.
 		lookupAlias(#aliasRef);
 		}
 	;
 
 mapComponentReference
     : #( KEY mapPropertyExpression )
     | #( VALUE mapPropertyExpression )
     | #( ENTRY mapPropertyExpression )
     ;
 
 mapPropertyExpression
     : e:expr {
         validateMapPropertyExpression( #e );
     }
     ;
 
 parameter!
 	: #(c:COLON a:identifier) {
 			// Create a NAMED_PARAM node instead of (COLON IDENT).
 			#parameter = generateNamedParameter( c, a );
 //			#parameter = #([NAMED_PARAM,a.getText()]);
 //			namedParameter(#parameter);
 		}
 	| #(p:PARAM (n:NUM_INT)?) {
 			if ( n != null ) {
 				// An ejb3-style "positional parameter", which we handle internally as a named-param
 				#parameter = generateNamedParameter( p, n );
 //				#parameter = #([NAMED_PARAM,n.getText()]);
 //				namedParameter(#parameter);
 			}
 			else {
 				#parameter = generatePositionalParameter( p );
 //				#parameter = #([PARAM,"?"]);
 //				positionalParameter(#parameter);
 			}
 		}
 	;
 
 numericInteger
 	: NUM_INT
 	;
diff --git a/hibernate-core/src/main/antlr/hql.g b/hibernate-core/src/main/antlr/hql.g
index 5fe8917b39..f6ed120684 100644
--- a/hibernate-core/src/main/antlr/hql.g
+++ b/hibernate-core/src/main/antlr/hql.g
@@ -1,904 +1,902 @@
 header
 {
-//   $Id: hql.g 10163 2006-07-26 15:07:50Z steve.ebersole@jboss.com $
+package org.hibernate.hql.internal.antlr;
 
-package org.hibernate.hql.antlr;
-
-import org.hibernate.hql.ast.*;
-import org.hibernate.hql.ast.util.*;
+import org.hibernate.hql.internal.ast.*;
+import org.hibernate.hql.internal.ast.util.*;
 
 }
 /**
  * Hibernate Query Language Grammar
  * <br>
  * This grammar parses the query language for Hibernate (an Open Source, Object-Relational
  * mapping library).  A partial BNF grammar description is available for reference here:
  * http://www.hibernate.org/Documentation/HQLBNF
  *
  * Text from the original reference BNF is prefixed with '//##'.
  * @author Joshua Davis (pgmjsd@sourceforge.net)
  */
 class HqlBaseParser extends Parser;
 
 options
 {
 	exportVocab=Hql;
 	buildAST=true;
 	k=3;    // For 'not like', 'not in', etc.
 }
 
 tokens
 {
 	// -- HQL Keyword tokens --
 	ALL="all";
 	ANY="any";
 	AND="and";
 	AS="as";
 	ASCENDING="asc";
 	AVG="avg";
 	BETWEEN="between";
 	CLASS="class";
 	COUNT="count";
 	DELETE="delete";
 	DESCENDING="desc";
 	DOT;
 	DISTINCT="distinct";
 	ELEMENTS="elements";
 	ESCAPE="escape";
 	EXISTS="exists";
 	FALSE="false";
 	FETCH="fetch";
 	FROM="from";
 	FULL="full";
 	GROUP="group";
 	HAVING="having";
 	IN="in";
 	INDICES="indices";
 	INNER="inner";
 	INSERT="insert";
 	INTO="into";
 	IS="is";
 	JOIN="join";
 	LEFT="left";
 	LIKE="like";
 	MAX="max";
 	MIN="min";
 	NEW="new";
 	NOT="not";
 	NULL="null";
 	OR="or";
 	ORDER="order";
 	OUTER="outer";
 	PROPERTIES="properties";
 	RIGHT="right";
 	SELECT="select";
 	SET="set";
 	SOME="some";
 	SUM="sum";
 	TRUE="true";
 	UNION="union";
 	UPDATE="update";
 	VERSIONED="versioned";
 	WHERE="where";
 
 	// -- SQL tokens --
 	// These aren't part of HQL, but the SQL fragment parser uses the HQL lexer, so they need to be declared here.
 	CASE="case";
 	END="end";
 	ELSE="else";
 	THEN="then";
 	WHEN="when";
 	ON="on";
 	WITH="with";
 
 	// -- EJBQL tokens --
 	BOTH="both";
 	EMPTY="empty";
 	LEADING="leading";
 	MEMBER="member";
 	OBJECT="object";
 	OF="of";
 	TRAILING="trailing";
 	KEY;
 	VALUE;
 	ENTRY;
 
 	// -- Synthetic token types --
 	AGGREGATE;		// One of the aggregate functions (e.g. min, max, avg)
 	ALIAS;
 	CONSTRUCTOR;
 	CASE2;
 	EXPR_LIST;
 	FILTER_ENTITY;		// FROM element injected because of a filter expression (happens during compilation phase 2)
 	IN_LIST;
 	INDEX_OP;
 	IS_NOT_NULL;
 	IS_NULL;			// Unary 'is null' operator.
 	METHOD_CALL;
 	NOT_BETWEEN;
 	NOT_IN;
 	NOT_LIKE;
 	ORDER_ELEMENT;
 	QUERY;
 	RANGE;
 	ROW_STAR;
 	SELECT_FROM;
 	UNARY_MINUS;
 	UNARY_PLUS;
 	VECTOR_EXPR;		// ( x, y, z )
 	WEIRD_IDENT;		// Identifiers that were keywords when they came in.
 
 	// Literal tokens.
 	CONSTANT;
 	NUM_DOUBLE;
 	NUM_FLOAT;
 	NUM_LONG;
 	NUM_BIG_INTEGER;
 	NUM_BIG_DECIMAL;
 	JAVA_CONSTANT;
 }
 
 {
     /** True if this is a filter query (allow no FROM clause). **/
 	private boolean filter = false;
 
 	/**
 	 * Sets the filter flag.
 	 * @param f True for a filter query, false for a normal query.
 	 */
 	public void setFilter(boolean f) {
 		filter = f;
 	}
 
 	/**
 	 * Returns true if this is a filter query, false if not.
 	 * @return true if this is a filter query, false if not.
 	 */
 	public boolean isFilter() {
 		return filter;
 	}
 
 	/**
 	 * This method is overriden in the sub class in order to provide the
 	 * 'keyword as identifier' hack.
 	 * @param token The token to retry as an identifier.
 	 * @param ex The exception to throw if it cannot be retried as an identifier.
 	 */
 	public AST handleIdentifierError(Token token,RecognitionException ex) throws RecognitionException, TokenStreamException {
 		// Base implementation: Just re-throw the exception.
 		throw ex;
 	}
 
     /**
      * This method looks ahead and converts . <token> into . IDENT when
      * appropriate.
      */
     public void handleDotIdent() throws TokenStreamException {
     }
 
 	/**
 	 * Returns the negated equivalent of the expression.
 	 * @param x The expression to negate.
 	 */
 	public AST negateNode(AST x) {
 		// Just create a 'not' parent for the default behavior.
 		return ASTUtil.createParent(astFactory, NOT, "not", x);
 	}
 
 	/**
 	 * Returns the 'cleaned up' version of a comparison operator sub-tree.
 	 * @param x The comparison operator to clean up.
 	 */
 	public AST processEqualityExpression(AST x) throws RecognitionException {
 		return x;
 	}
 
 	public void weakKeywords() throws TokenStreamException { }
 
 	public void processMemberOf(Token n,AST p,ASTPair currentAST) { }
 
 }
 
 statement
 	: ( updateStatement | deleteStatement | selectStatement | insertStatement )
 	;
 
 updateStatement
 	: UPDATE^ (VERSIONED)?
 		optionalFromTokenFromClause
 		setClause
 		(whereClause)?
 	;
 
 setClause
 	: (SET^ assignment (COMMA! assignment)*)
 	;
 
 assignment
 	: stateField EQ^ newValue
 	;
 
 // "state_field" is the term used in the EJB3 sample grammar; used here for easy reference.
 // it is basically a property ref
 stateField
 	: path
 	;
 
 // this still needs to be defined in the ejb3 spec; additiveExpression is currently just a best guess,
 // although it is highly likely I would think that the spec may limit this even more tightly.
 newValue
 	: concatenation
 	;
 
 deleteStatement
 	: DELETE^
 		(optionalFromTokenFromClause)
 		(whereClause)?
 	;
 
 optionalFromTokenFromClause!
 	: (FROM!)? f:path (a:asAlias)? {
 		AST #range = #([RANGE, "RANGE"], #f, #a);
 		#optionalFromTokenFromClause = #([FROM, "FROM"], #range);
 	}
 	;
 
 selectStatement
 	: queryRule {
 		#selectStatement = #([QUERY,"query"], #selectStatement);
 	}
 	;
 
 insertStatement
 	// Would be nice if we could abstract the FromClause/FromElement logic
 	// out such that it could be reused here; something analogous to
 	// a "table" rule in sql-grammars
 	: INSERT^ intoClause selectStatement
 	;
 
 intoClause
 	: INTO^ path { weakKeywords(); } insertablePropertySpec
 	;
 
 insertablePropertySpec
 	: OPEN! primaryExpression ( COMMA! primaryExpression )* CLOSE! {
 		// Just need *something* to distinguish this on the hql-sql.g side
 		#insertablePropertySpec = #([RANGE, "column-spec"], #insertablePropertySpec);
 	}
 	;
 
 union
 	: queryRule (UNION queryRule)*
 	;
 
 //## query:
 //##     [selectClause] fromClause [whereClause] [groupByClause] [havingClause] [orderByClause];
 
 queryRule
 	: selectFrom
 		(whereClause)?
 		(groupByClause)?
 		(orderByClause)?
 		;
 
 selectFrom!
 	:  (s:selectClause)? (f:fromClause)? {
 		// If there was no FROM clause and this is a filter query, create a from clause.  Otherwise, throw
 		// an exception because non-filter queries must have a FROM clause.
 		if (#f == null) {
 			if (filter) {
 				#f = #([FROM,"{filter-implied FROM}"]);
 			}
 			else
 				throw new SemanticException("FROM expected (non-filter queries must contain a FROM clause)");
 		}
 			
 		// Create an artificial token so the 'FROM' can be placed
 		// before the SELECT in the tree to make tree processing
 		// simpler.
 		#selectFrom = #([SELECT_FROM,"SELECT_FROM"],f,s);
 	}
 	;
 
 //## selectClause:
 //##     SELECT DISTINCT? selectedPropertiesList | ( NEW className OPEN selectedPropertiesList CLOSE );
 
 selectClause
 	: SELECT^	// NOTE: The '^' after a token causes the corresponding AST node to be the root of the sub-tree.
 		{ weakKeywords(); }	// Weak keywords can appear immediately after a SELECT token.
 		(DISTINCT)? ( selectedPropertiesList | newExpression | selectObject )
 	;
 
 newExpression
 	: (NEW! path) op:OPEN^ {#op.setType(CONSTRUCTOR);} selectedPropertiesList CLOSE!
 	;
 
 selectObject
    : OBJECT^ OPEN! identifier CLOSE!
    ;
 
 //## fromClause:
 //##    FROM className AS? identifier (  ( COMMA className AS? identifier ) | ( joinType path AS? identifier ) )*;
 
 // NOTE: This *must* begin with the "FROM" token, otherwise the sub-query rule will be ambiguous
 // with the expression rule.
 // Also note: after a comma weak keywords are allowed and should be treated as identifiers.
 
 fromClause
 	: FROM^ { weakKeywords(); } fromRange ( fromJoin | COMMA! { weakKeywords(); } fromRange )*
 	;
 
 //## joinType:
 //##     ( ( 'left'|'right' 'outer'? ) | 'full' | 'inner' )? JOIN FETCH?;
 
 fromJoin
 	: ( ( ( LEFT | RIGHT ) (OUTER)? ) | FULL | INNER )? JOIN^ (FETCH)? 
 	  path (asAlias)? (propertyFetch)? (withClause)?
 	;
 
 withClause
 	: WITH^ logicalExpression
 	;
 
 fromRange
 	: fromClassOrOuterQueryPath
 	| inClassDeclaration
 	| inCollectionDeclaration
 	| inCollectionElementsDeclaration
 	;
 	
 fromClassOrOuterQueryPath!
 	: c:path { weakKeywords(); } (a:asAlias)? (p:propertyFetch)? {
 		#fromClassOrOuterQueryPath = #([RANGE, "RANGE"], #c, #a, #p);
 	}
 	;
 
 inClassDeclaration!
 	: a:alias IN! CLASS! c:path {
 		#inClassDeclaration = #([RANGE, "RANGE"], #c, #a);
 	}
 	;
 
 inCollectionDeclaration!
     : IN! OPEN! p:path CLOSE! a:asAlias {
         #inCollectionDeclaration = #([JOIN, "join"], [INNER, "inner"], #p, #a);
 	}
     ;
 
 inCollectionElementsDeclaration!
 	: a:alias IN! ELEMENTS! OPEN! p:path CLOSE! {
         #inCollectionElementsDeclaration = #([JOIN, "join"], [INNER, "inner"], #p, #a);
 	}
     ;
 
 // Alias rule - Parses the optional 'as' token and forces an AST identifier node.
 asAlias
 	: (AS!)? alias
 	;
 
 alias
 	: a:identifier { #a.setType(ALIAS); }
     ;
     
 propertyFetch
 	: FETCH ALL! PROPERTIES!
 	;
 
 //## groupByClause:
 //##     GROUP_BY path ( COMMA path )*;
 
 groupByClause
 	: GROUP^ 
 		"by"! expression ( COMMA! expression )*
 		(havingClause)?
 	;
 
 //## orderByClause:
 //##     ORDER_BY selectedPropertiesList;
 
 orderByClause
 	: ORDER^ "by"! orderElement ( COMMA! orderElement )*
 	;
 
 orderElement
 	: expression ( ascendingOrDescending )?
 	;
 
 ascendingOrDescending
 	: ( "asc" | "ascending" )	{ #ascendingOrDescending.setType(ASCENDING); }
 	| ( "desc" | "descending") 	{ #ascendingOrDescending.setType(DESCENDING); }
 	;
 
 //## havingClause:
 //##     HAVING logicalExpression;
 
 havingClause
 	: HAVING^ logicalExpression
 	;
 
 //## whereClause:
 //##     WHERE logicalExpression;
 
 whereClause
 	: WHERE^ logicalExpression
 	;
 
 //## selectedPropertiesList:
 //##     ( path | aggregate ) ( COMMA path | aggregate )*;
 
 selectedPropertiesList
 	: aliasedExpression ( COMMA! aliasedExpression )*
 	;
 	
 aliasedExpression
 	: expression ( AS^ identifier )?
 	;
 
 // expressions
 // Note that most of these expressions follow the pattern
 //   thisLevelExpression :
 //       nextHigherPrecedenceExpression
 //           (OPERATOR nextHigherPrecedenceExpression)*
 // which is a standard recursive definition for a parsing an expression.
 //
 // Operator precedence in HQL
 // lowest  --> ( 7)  OR
 //             ( 6)  AND, NOT
 //             ( 5)  equality: ==, <>, !=, is
 //             ( 4)  relational: <, <=, >, >=,
 //                   LIKE, NOT LIKE, BETWEEN, NOT BETWEEN, IN, NOT IN
 //             ( 3)  addition and subtraction: +(binary) -(binary)
 //             ( 2)  multiplication: * / %, concatenate: ||
 // highest --> ( 1)  +(unary) -(unary)
 //                   []   () (method call)  . (dot -- identifier qualification)
 //                   aggregate function
 //                   ()  (explicit parenthesis)
 //
 // Note that the above precedence levels map to the rules below...
 // Once you have a precedence chart, writing the appropriate rules as below
 // is usually very straightfoward
 
 logicalExpression
 	: expression
 	;
 
 // Main expression rule
 expression
 	: logicalOrExpression
 	;
 
 // level 7 - OR
 logicalOrExpression
 	: logicalAndExpression ( OR^ logicalAndExpression )*
 	;
 
 // level 6 - AND, NOT
 logicalAndExpression
 	: negatedExpression ( AND^ negatedExpression )*
 	;
 
 // NOT nodes aren't generated.  Instead, the operator in the sub-tree will be
 // negated, if possible.   Expressions without a NOT parent are passed through.
 negatedExpression!
 { weakKeywords(); } // Weak keywords can appear in an expression, so look ahead.
 	: NOT^ x:negatedExpression { #negatedExpression = negateNode(#x); }
 	| y:equalityExpression { #negatedExpression = #y; }
 	;
 
 //## OP: EQ | LT | GT | LE | GE | NE | SQL_NE | LIKE;
 
 // level 5 - EQ, NE
 equalityExpression
 	: x:relationalExpression (
 		( EQ^
 		| is:IS^	{ #is.setType(EQ); } (NOT! { #is.setType(NE); } )?
 		| NE^
 		| ne:SQL_NE^	{ #ne.setType(NE); }
 		) y:relationalExpression)* {
 			// Post process the equality expression to clean up 'is null', etc.
 			#equalityExpression = processEqualityExpression(#equalityExpression);
 		}
 	;
 
 // level 4 - LT, GT, LE, GE, LIKE, NOT LIKE, BETWEEN, NOT BETWEEN
 // NOTE: The NOT prefix for LIKE and BETWEEN will be represented in the
 // token type.  When traversing the AST, use the token type, and not the
 // token text to interpret the semantics of these nodes.
 relationalExpression
 	: concatenation (
 		( ( ( LT^ | GT^ | LE^ | GE^ ) additiveExpression )* )
 		// Disable node production for the optional 'not'.
 		| (n:NOT!)? (
 			// Represent the optional NOT prefix using the token type by
 			// testing 'n' and setting the token type accordingly.
 			(i:IN^ {
 					#i.setType( (n == null) ? IN : NOT_IN);
 					#i.setText( (n == null) ? "in" : "not in");
 				}
 				inList)
 			| (b:BETWEEN^ {
 					#b.setType( (n == null) ? BETWEEN : NOT_BETWEEN);
 					#b.setText( (n == null) ? "between" : "not between");
 				}
 				betweenList )
 			| (l:LIKE^ {
 					#l.setType( (n == null) ? LIKE : NOT_LIKE);
 					#l.setText( (n == null) ? "like" : "not like");
 				}
 				concatenation likeEscape)
 			| (MEMBER! (OF!)? p:path! {
 				processMemberOf(n,#p,currentAST);
 			  } ) )
 		)
 	;
 
 likeEscape
 	: (ESCAPE^ concatenation)?
 	;
 
 inList
 	: x:compoundExpr
 	{ #inList = #([IN_LIST,"inList"], #inList); }
 	;
 
 betweenList
 	: concatenation AND! concatenation
 	;
 
 //level 4 - string concatenation
 concatenation
 	: additiveExpression 
 	( c:CONCAT^ { #c.setType(EXPR_LIST); #c.setText("concatList"); } 
 	  additiveExpression
 	  ( CONCAT! additiveExpression )* 
 	  { #concatenation = #([METHOD_CALL, "||"], #([IDENT, "concat"]), #c ); } )?
 	;
 
 // level 3 - binary plus and minus
 additiveExpression
 	: multiplyExpression ( ( PLUS^ | MINUS^ ) multiplyExpression )*
 	;
 
 // level 2 - binary multiply and divide
 multiplyExpression
 	: unaryExpression ( ( STAR^ | DIV^ | MOD^ ) unaryExpression )*
 	;
 	
 // level 1 - unary minus, unary plus, not
 unaryExpression
 	: MINUS^ {#MINUS.setType(UNARY_MINUS);} unaryExpression
 	| PLUS^ {#PLUS.setType(UNARY_PLUS);} unaryExpression
 	| caseExpression
 	| quantifiedExpression
 	| atom
 	;
 	
 caseExpression
 	: CASE^ (whenClause)+ (elseClause)? END! 
 	| CASE^ { #CASE.setType(CASE2); } unaryExpression (altWhenClause)+ (elseClause)? END!
 	;
 	
 whenClause
 	: (WHEN^ logicalExpression THEN! unaryExpression)
 	;
 	
 altWhenClause
 	: (WHEN^ unaryExpression THEN! unaryExpression)
 	;
 	
 elseClause
 	: (ELSE^ unaryExpression)
 	;
 	
 quantifiedExpression
 	: ( SOME^ | EXISTS^ | ALL^ | ANY^ ) 
 	( identifier | collectionExpr | (OPEN! ( subQuery ) CLOSE!) )
 	;
 
 // level 0 - expression atom
 // ident qualifier ('.' ident ), array index ( [ expr ] ),
 // method call ( '.' ident '(' exprList ') )
 atom
 	 : primaryExpression
 		(
 			DOT^ identifier
 				( options { greedy=true; } :
 					( op:OPEN^ {#op.setType(METHOD_CALL);} exprList CLOSE! ) )?
 		|	lb:OPEN_BRACKET^ {#lb.setType(INDEX_OP);} expression CLOSE_BRACKET!
 		)*
 	;
 
 // level 0 - the basic element of an expression
 primaryExpression
 	:   identPrimary ( options {greedy=true;} : DOT^ "class" )?
 	|   constant
 	|   parameter
 	// TODO: Add parens to the tree so the user can control the operator evaluation order.
 	|   OPEN! (expressionOrVector | subQuery) CLOSE!
 	;
 
 parameter
 	: COLON^ identifier
 	| PARAM^ (NUM_INT)?
 	;
 
 // This parses normal expression and a list of expressions separated by commas.  If a comma is encountered
 // a parent VECTOR_EXPR node will be created for the list.
 expressionOrVector!
 	: e:expression ( v:vectorExpr )? {
 		// If this is a vector expression, create a parent node for it.
 		if (#v != null)
 			#expressionOrVector = #([VECTOR_EXPR,"{vector}"], #e, #v);
 		else
 			#expressionOrVector = #e;
 	}
 	;
 
 vectorExpr
 	: COMMA! expression (COMMA! expression)*
 	;
 
 // identifier, followed by member refs (dot ident), or method calls.
 // NOTE: handleDotIdent() is called immediately after the first IDENT is recognized because
 // the method looks a head to find keywords after DOT and turns them into identifiers.
 identPrimary
     : i:identifier { handleDotIdent(); }
 			( options { greedy=true; } : DOT^ ( identifier | ELEMENTS | o:OBJECT { #o.setType(IDENT); } ) )*
 			( options { greedy=true; } :
 				( op:OPEN^ { #op.setType(METHOD_CALL);} e:exprList CLOSE! ) {
 				    AST path = #e.getFirstChild();
 				    if ( #i.getText().equals( "key" ) ) {
 				        #identPrimary = #( [KEY], path );
 				    }
 				    else if ( #i.getText().equals( "value" ) ) {
 				        #identPrimary = #( [VALUE], path );
 				    }
 				    else if ( #i.getText().equals( "entry" ) ) {
 				        #identPrimary = #( [ENTRY], path );
 				    }
 				}
 			)?
 	// Also allow special 'aggregate functions' such as count(), avg(), etc.
 	| aggregate
 	;
 
 aggregate
 	: ( SUM^ | AVG^ | MAX^ | MIN^ ) OPEN! additiveExpression CLOSE! { #aggregate.setType(AGGREGATE); }
 	// Special case for count - It's 'parameters' can be keywords.
 	|  COUNT^ OPEN! ( STAR { #STAR.setType(ROW_STAR); } | ( ( DISTINCT | ALL )? ( path | collectionExpr ) ) ) CLOSE!
 	|  collectionExpr
 	;
 
 //## collection: ( OPEN query CLOSE ) | ( 'elements'|'indices' OPEN path CLOSE );
 
 collectionExpr
 	: (ELEMENTS^ | INDICES^) OPEN! path CLOSE!
 	;
                                            
 // NOTE: compoundExpr can be a 'path' where the last token in the path is '.elements' or '.indicies'
 compoundExpr
 	: collectionExpr
 	| path
 	| (OPEN! ( (expression (COMMA! expression)*) | subQuery ) CLOSE!)
 	| parameter
 	;
 
 subQuery
 	: union
 	{ #subQuery = #([QUERY,"query"], #subQuery); }
 	;
 
 exprList
 {
    AST trimSpec = null;
 }
 	: (t:TRAILING {#trimSpec = #t;} | l:LEADING {#trimSpec = #l;} | b:BOTH {#trimSpec = #b;})?
 	  		{ if(#trimSpec != null) #trimSpec.setType(IDENT); }
 	  ( 
 	  		expression ( (COMMA! expression)+ | FROM { #FROM.setType(IDENT); } expression | AS! identifier )? 
 	  		| FROM { #FROM.setType(IDENT); } expression
 	  )?
 			{ #exprList = #([EXPR_LIST,"exprList"], #exprList); }
 	;
 
 constant
 	: NUM_INT
 	| NUM_FLOAT
 	| NUM_LONG
 	| NUM_DOUBLE
 	| NUM_BIG_INTEGER
 	| NUM_BIG_DECIMAL
 	| QUOTED_STRING
 	| NULL
 	| TRUE
 	| FALSE
 	| EMPTY
 	;
 
 //## quantifiedExpression: 'exists' | ( expression 'in' ) | ( expression OP 'any' | 'some' ) collection;
 
 //## compoundPath: path ( OPEN_BRACKET expression CLOSE_BRACKET ( '.' path )? )*;
 
 //## path: identifier ( '.' identifier )*;
 
 path
 	: identifier ( DOT^ { weakKeywords(); } identifier )*
 	;
 
 // Wraps the IDENT token from the lexer, in order to provide
 // 'keyword as identifier' trickery.
 identifier
 	: IDENT
 	exception
 	catch [RecognitionException ex]
 	{
 		identifier_AST = handleIdentifierError(LT(1),ex);
 	}
 	;
 
 // **** LEXER ******************************************************************
 
 /**
  * Hibernate Query Language Lexer
  * <br>
  * This lexer provides the HQL parser with tokens.
  * @author Joshua Davis (pgmjsd@sourceforge.net)
  */
 class HqlBaseLexer extends Lexer;
 
 options {
 	exportVocab=Hql;      // call the vocabulary "Hql"
 	testLiterals = false;
 	k=2; // needed for newline, and to distinguish '>' from '>='.
 	// HHH-241 : Quoted strings don't allow unicode chars - This should fix it.
 	charVocabulary='\u0000'..'\uFFFE';	// Allow any char but \uFFFF (16 bit -1, ANTLR's EOF character)
 	caseSensitive = false;
 	caseSensitiveLiterals = false;
 }
 
 // -- Declarations --
 {
 	// NOTE: The real implementations are in the subclass.
 	protected void setPossibleID(boolean possibleID) {}
 }
 
 // -- Keywords --
 
 EQ: '=';
 LT: '<';
 GT: '>';
 SQL_NE: "<>";
 NE: "!=" | "^=";
 LE: "<=";
 GE: ">=";
 
 COMMA: ',';
 
 OPEN: '(';
 CLOSE: ')';
 OPEN_BRACKET: '[';
 CLOSE_BRACKET: ']';
 
 CONCAT: "||";
 PLUS: '+';
 MINUS: '-';
 STAR: '*';
 DIV: '/';
 MOD: '%';
 COLON: ':';
 PARAM: '?';
 
 IDENT options { testLiterals=true; }
 	: ID_START_LETTER ( ID_LETTER )*
 		{
     		// Setting this flag allows the grammar to use keywords as identifiers, if necessary.
 			setPossibleID(true);
 		}
 	;
 
 protected
 ID_START_LETTER
     :    '_'
     |    '$'
     |    'a'..'z'
     |    '\u0080'..'\ufffe'       // HHH-558 : Allow unicode chars in identifiers
     ;
 
 protected
 ID_LETTER
     :    ID_START_LETTER
     |    '0'..'9'
     ;
 
 QUOTED_STRING
 	  : '\'' ( (ESCqs)=> ESCqs | ~'\'' )* '\''
 	;
 
 protected
 ESCqs
 	:
 		'\'' '\''
 	;
 
 WS  :   (   ' '
 		|   '\t'
 		|   '\r' '\n' { newline(); }
 		|   '\n'      { newline(); }
 		|   '\r'      { newline(); }
 		)
 		{$setType(Token.SKIP);} //ignore this token
 	;
 
 //--- From the Java example grammar ---
 // a numeric literal
 NUM_INT
 	{boolean isDecimal=false; Token t=null;}
 	:   '.' {_ttype = DOT;}
 			(	('0'..'9')+ (EXPONENT)? (f1:FLOAT_SUFFIX {t=f1;})?
 				{
 					if ( t != null && t.getText().toUpperCase().indexOf("BD")>=0) {
 						_ttype = NUM_BIG_DECIMAL;
 					}
 					else if (t != null && t.getText().toUpperCase().indexOf('F')>=0) {
 						_ttype = NUM_FLOAT;
 					}
 					else {
 						_ttype = NUM_DOUBLE; // assume double
 					}
 				}
 			)?
 	|	(	'0' {isDecimal = true;} // special case for just '0'
 			(	('x')
 				(											// hex
 					// the 'e'|'E' and float suffix stuff look
 					// like hex digits, hence the (...)+ doesn't
 					// know when to stop: ambig.  ANTLR resolves
 					// it correctly by matching immediately.  It
 					// is therefore ok to hush warning.
 					options { warnWhenFollowAmbig=false; }
 				:	HEX_DIGIT
 				)+
 			|	('0'..'7')+									// octal
 			)?
 		|	('1'..'9') ('0'..'9')*  {isDecimal=true;}		// non-zero decimal
 		)
 		(	('l') { _ttype = NUM_LONG; }
 		|	('b''i') { _ttype = NUM_BIG_INTEGER; }
 
 		// only check to see if it's a float if looks like decimal so far
 		|	{isDecimal}?
 			(   '.' ('0'..'9')* (EXPONENT)? (f2:FLOAT_SUFFIX {t=f2;})?
 			|   EXPONENT (f3:FLOAT_SUFFIX {t=f3;})?
 			|   f4:FLOAT_SUFFIX {t=f4;}
 			)
 			{
 				if ( t != null && t.getText().toUpperCase().indexOf("BD")>=0) {
 					_ttype = NUM_BIG_DECIMAL;
 				}
 				else if (t != null && t.getText().toUpperCase() .indexOf('F') >= 0) {
 					_ttype = NUM_FLOAT;
 				}
 				else {
 					_ttype = NUM_DOUBLE; // assume double
 				}
 			}
 		)?
 	;
 
 // hexadecimal digit (again, note it's protected!)
 protected
 HEX_DIGIT
 	:	('0'..'9'|'a'..'f')
 	;
 
 // a couple protected methods to assist in matching floating point numbers
 protected
 EXPONENT
 	:	('e') ('+'|'-')? ('0'..'9')+
 	;
 
 protected
 FLOAT_SUFFIX
 	:	'f'|'d'|'b''d'
 	;
 
diff --git a/hibernate-core/src/main/antlr/sql-gen.g b/hibernate-core/src/main/antlr/sql-gen.g
index 8def60e6b5..d60561e449 100644
--- a/hibernate-core/src/main/antlr/sql-gen.g
+++ b/hibernate-core/src/main/antlr/sql-gen.g
@@ -1,437 +1,435 @@
 header
 {
-//   $Id: sql-gen.g 10001 2006-06-08 21:08:04Z steve.ebersole@jboss.com $
-package org.hibernate.hql.antlr;
-
+package org.hibernate.hql.internal.antlr;
 }
 /**
  * SQL Generator Tree Parser, providing SQL rendering of SQL ASTs produced by the previous phase, HqlSqlWalker.  All
  * syntax decoration such as extra spaces, lack of spaces, extra parens, etc. should be added by this class.
  * <br>
  * This grammar processes the HQL/SQL AST and produces an SQL string.  The intent is to move dialect-specific
  * code into a sub-class that will override some of the methods, just like the other two grammars in this system.
  * @author Joshua Davis (joshua@hibernate.org)
  */
 class SqlGeneratorBase extends TreeParser;
 
 options {
 	// Note: importVocab and exportVocab cause ANTLR to share the token type numbers between the
 	// two grammars.  This means that the token type constants from the source tree are the same
 	// as those in the target tree.  If this is not the case, tree translation can result in
 	// token types from the *source* tree being present in the target tree.
 	importVocab=HqlSql;         // import definitions from "HqlSql"
 	exportVocab=Sql;            // Call the resulting definitions "Sql"
 	buildAST=false;             // Don't build an AST.
 }
 
 {
 
    /** the buffer resulting SQL statement is written to */
 	private StringBuffer buf = new StringBuffer();
 
 	protected void out(String s) {
 		buf.append(s);
 	}
 
 	/**
 	 * Returns the last character written to the output, or -1 if there isn't one.
 	 */
 	protected int getLastChar() {
 		int len = buf.length();
 		if ( len == 0 )
 			return -1;
 		else
 			return buf.charAt( len - 1 );
 	}
 
 	/**
 	 * Add a aspace if the previous token was not a space or a parenthesis.
 	 */
 	protected void optionalSpace() {
 		// Implemented in the sub-class.
 	}
 
 	protected void out(AST n) {
 		out(n.getText());
 	}
 
 	protected void separator(AST n, String sep) {
 		if (n.getNextSibling() != null)
 			out(sep);
 	}
 
 	protected boolean hasText(AST a) {
 		String t = a.getText();
 		return t != null && t.length() > 0;
 	}
 
 	protected void fromFragmentSeparator(AST a) {
 		// moved this impl into the subclass...
 	}
 
 	protected void nestedFromFragment(AST d,AST parent) {
 		// moved this impl into the subclass...
 	}
 
 	protected StringBuffer getStringBuffer() {
 		return buf;
 	}
 
 	protected void nyi(AST n) {
 		throw new UnsupportedOperationException("Unsupported node: " + n);
 	}
 
 	protected void beginFunctionTemplate(AST m,AST i) {
 		// if template is null we just write the function out as it appears in the hql statement
 		out(i);
 		out("(");
 	}
 
 	protected void endFunctionTemplate(AST m) {
 	      out(")");
 	}
 
 	protected void commaBetweenParameters(String comma) {
 		out(comma);
 	}
 }
 
 statement
 	: selectStatement
 	| updateStatement
 	| deleteStatement
 	| insertStatement
 	;
 
 selectStatement
 	: #(SELECT { out("select "); }
 		selectClause
 		from
 		( #(WHERE { out(" where "); } whereExpr ) )?
 		( #(GROUP { out(" group by "); } groupExprs ( #(HAVING { out(" having "); } booleanExpr[false]) )? ) )?
 		( #(ORDER { out(" order by "); } orderExprs ) )?
 	)
 	;
 
 // Note: eats the FROM token node, as it is not valid in an update statement.
 // It's outlived its usefulness after analysis phase :)
 // TODO : needed to use conditionList directly here and deleteStatement, as whereExprs no longer works for this stuff
 updateStatement
 	: #(UPDATE { out("update "); }
 		#( FROM fromTable )
 		setClause
 		(whereClause)?
 	)
 	;
 
 deleteStatement
 	// Note: not space needed at end of "delete" because the from rule included one before the "from" it outputs
 	: #(DELETE { out("delete"); }
 		from
 		(whereClause)?
 	)
 	;
 
 insertStatement
 	: #(INSERT { out( "insert " ); }
 		i:INTO { out( i ); out( " " ); }
 		selectStatement
 	)
 	;
 
 setClause
 	// Simply re-use comparisionExpr, because it already correctly defines the EQ rule the
 	// way it is needed here; not the most aptly named, but ah
 	: #( SET { out(" set "); } comparisonExpr[false] ( { out(", "); } comparisonExpr[false] )* )
 	;
 
 whereClause
 	: #(WHERE { out(" where "); } whereClauseExpr )
 	;
 
 whereClauseExpr
 	: (SQL_TOKEN) => conditionList
 	| booleanExpr[ false ]
 	;
 
 orderExprs
 	// TODO: remove goofy space before the comma when we don't have to regression test anymore.
 	: ( expr ) (dir:orderDirection { out(" "); out(dir); })? ( {out(", "); } orderExprs)?
 	;
 
 groupExprs
 	// TODO: remove goofy space before the comma when we don't have to regression test anymore.
 	: expr ( {out(" , "); } groupExprs)?
 	;
 
 orderDirection
 	: ASCENDING
 	| DESCENDING
 	;
 
 whereExpr
 	// Expect the filter subtree, followed by the theta join subtree, followed by the HQL condition subtree.
 	// Might need parens around the HQL condition if there is more than one subtree.
 	// Put 'and' between each subtree.
 	: filters
 		( { out(" and "); } thetaJoins )?
 		( { out(" and "); } booleanExpr [ true ] )?
 	| thetaJoins
 		( { out(" and "); } booleanExpr [ true ] )? 
 	| booleanExpr[false]
 	;
 
 filters
 	: #(FILTERS conditionList )
 	;
 
 thetaJoins
 	: #(THETA_JOINS conditionList )
 	;
 
 conditionList
 	: sqlToken ( { out(" and "); } conditionList )?
 	;
 
 selectClause
 	: #(SELECT_CLAUSE (distinctOrAll)? ( selectColumn )+ )
 	;
 
 selectColumn
 	: p:selectExpr (sc:SELECT_COLUMNS { out(sc); } )? { separator( (sc != null) ? sc : p,", "); }
 	;
 
 selectExpr
 	: e:selectAtom { out(e); }
 	| mcr:mapComponentReference { out(mcr); }
 	| count
 	| #(CONSTRUCTOR (DOT | IDENT) ( selectColumn )+ )
 	| methodCall
 	| aggregate
 	| c:constant { out(c); }
 	| arithmeticExpr
 	| param:PARAM { out(param); }
 	| sn:SQL_NODE { out(sn); }
 	| { out("("); } selectStatement { out(")"); }
 	;
 
 count
 	: #(COUNT { out("count("); }  ( distinctOrAll ) ? countExpr { out(")"); } )
 	;
 
 distinctOrAll
 	: DISTINCT { out("distinct "); }
 	| ALL { out("all "); }
 	;
 
 countExpr
 	// Syntacitic predicate resolves star all by itself, avoiding a conflict with STAR in expr.
 	: ROW_STAR { out("*"); }
 	| simpleExpr
 	;
 
 selectAtom
 	: DOT
 	| SQL_TOKEN
 	| ALIAS_REF
 	| SELECT_EXPR
 	;
 
 mapComponentReference
     : KEY
     | VALUE
     | ENTRY
     ;
 
 // The from-clause piece is all goofed up.  Currently, nodes of type FROM_FRAGMENT
 // and JOIN_FRAGMENT can occur at any level in the FromClause sub-tree. We really
 // should come back and clean this up at some point; which I think will require
 // a post-HqlSqlWalker phase to "re-align" the FromElements in a more sensible
 // manner.
 from
 	: #(f:FROM { out(" from "); }
 		(fromTable)* )
 	;
 
 fromTable
 	// Write the table node (from fragment) and all the join fragments associated with it.
 	: #( a:FROM_FRAGMENT  { out(a); } (tableJoin [ a ])* { fromFragmentSeparator(a); } )
 	| #( b:JOIN_FRAGMENT  { out(b); } (tableJoin [ b ])* { fromFragmentSeparator(b); } )
 	;
 
 tableJoin [ AST parent ]
 	: #( c:JOIN_FRAGMENT { out(" "); out(c); } (tableJoin [ c ] )* )
 	| #( d:FROM_FRAGMENT { nestedFromFragment(d,parent); } (tableJoin [ d ] )* )
 	;
 
 booleanOp[ boolean parens ]
 	: #(AND booleanExpr[true] { out(" and "); } booleanExpr[true])
 	| #(OR { if (parens) out("("); } booleanExpr[false] { out(" or "); } booleanExpr[false] { if (parens) out(")"); })
 	| #(NOT { out(" not ("); } booleanExpr[false] { out(")"); } )
 	;
 
 booleanExpr[ boolean parens ]
 	: booleanOp [ parens ]
 	| comparisonExpr [ parens ]
 	| st:SQL_TOKEN { out(st); } // solely for the purpose of mapping-defined where-fragments
 	;
 	
 comparisonExpr[ boolean parens ]
 	: binaryComparisonExpression
 	| { if (parens) out("("); } exoticComparisonExpression { if (parens) out(")"); }
 	;
 	
 binaryComparisonExpression
 	: #(EQ expr { out("="); } expr)
 	| #(NE expr { out("<>"); } expr)
 	| #(GT expr { out(">"); } expr)
 	| #(GE expr { out(">="); } expr)
 	| #(LT expr { out("<"); } expr)
 	| #(LE expr { out("<="); } expr)
 	;
 	
 exoticComparisonExpression
 	: #(LIKE expr { out(" like "); } expr likeEscape )
 	| #(NOT_LIKE expr { out(" not like "); } expr likeEscape)
 	| #(BETWEEN expr { out(" between "); } expr { out(" and "); } expr)
 	| #(NOT_BETWEEN expr { out(" not between "); } expr { out(" and "); } expr)
 	| #(IN expr { out(" in"); } inList )
 	| #(NOT_IN expr { out(" not in "); } inList )
 	| #(EXISTS { optionalSpace(); out("exists "); } quantified )
 	| #(IS_NULL expr) { out(" is null"); }
 	| #(IS_NOT_NULL expr) { out(" is not null"); }
 	;
 
 likeEscape
 	: ( #(ESCAPE { out(" escape "); } expr) )?
 	;
 
 inList
 	: #(IN_LIST { out(" "); } ( parenSelect | simpleExprList ) )
 	;
 	
 simpleExprList
 	: { out("("); } (e:simpleExpr { separator(e," , "); } )* { out(")"); }
 	;
 
 // A simple expression, or a sub-select with parens around it.
 expr
 	: simpleExpr
 	| #( VECTOR_EXPR { out("("); } (e:expr { separator(e," , "); } )*  { out(")"); } )
 	| parenSelect
 	| #(ANY { out("any "); } quantified )
 	| #(ALL { out("all "); } quantified )
 	| #(SOME { out("some "); } quantified )
 	;
 	
 quantified
 	: { out("("); } ( sqlToken | selectStatement ) { out(")"); } 
 	;
 	
 parenSelect
 	: { out("("); } selectStatement { out(")"); }
 	;
 	
 simpleExpr
 	: c:constant { out(c); }
 	| NULL { out("null"); }
 	| addrExpr
 	| sqlToken
 	| aggregate
 	| methodCall
 	| count
 	| parameter
 	| arithmeticExpr
 	;
 	
 constant
 	: NUM_DOUBLE
 	| NUM_FLOAT
 	| NUM_INT
 	| NUM_LONG
 	| NUM_BIG_INTEGER
 	| NUM_BIG_DECIMAL
 	| QUOTED_STRING
 	| CONSTANT
 	| JAVA_CONSTANT
 	| TRUE
 	| FALSE
 	| IDENT
 	;
 	
 arithmeticExpr
 	: additiveExpr
 	| multiplicativeExpr
 //	| #(CONCAT { out("("); } expr ( { out("||"); } expr )+ { out(")"); } )
 	| #(UNARY_MINUS { out("-"); } expr)
 	| caseExpr
 	;
 
 additiveExpr
 	: #(PLUS expr { out("+"); } expr)
 	| #(MINUS expr { out("-"); } nestedExprAfterMinusDiv)
 	;
 
 multiplicativeExpr
 	: #(STAR nestedExpr { out("*"); } nestedExpr)
 	| #(DIV nestedExpr { out("/"); } nestedExprAfterMinusDiv)
 	| #(MOD nestedExpr { out(" % "); } nestedExprAfterMinusDiv)
 	;
 
 nestedExpr
 	// Generate parens around nested additive expressions, use a syntactic predicate to avoid conflicts with 'expr'.
 	: (additiveExpr) => { out("("); } additiveExpr { out(")"); }
 	| expr
 	;
 	
 nestedExprAfterMinusDiv
 	// Generate parens around nested arithmetic expressions, use a syntactic predicate to avoid conflicts with 'expr'.
 	: (arithmeticExpr) => { out("("); } arithmeticExpr { out(")"); }
 	| expr
 	;
 
 caseExpr
 	: #(CASE { out("case"); } 
 		( #(WHEN { out( " when "); } booleanExpr[false] { out(" then "); } expr) )+ 
 		( #(ELSE { out(" else "); } expr) )?
 		{ out(" end"); } )
 	| #(CASE2 { out("case "); } expr
 		( #(WHEN { out( " when "); } expr { out(" then "); } expr) )+ 
 		( #(ELSE { out(" else "); } expr) )?
 		{ out(" end"); } )
 	;
 
 aggregate
 	: #(
 	    a:AGGREGATE { beginFunctionTemplate( a, a ); }
 	    expr
 	    { endFunctionTemplate( a ); }
 	)
 	;
 
 methodCall
 	: #(m:METHOD_CALL i:METHOD_NAME { beginFunctionTemplate(m,i); }
 	 ( #(EXPR_LIST (arguments)? ) )?
 	 { endFunctionTemplate(m); } )
 	;
 
 arguments
 	: expr ( { commaBetweenParameters(", "); } expr )*
 	;
 
 parameter
 	: n:NAMED_PARAM { out(n); }
 	| p:PARAM { out(p); }
 	;
 
 addrExpr
 	: #(r:DOT . .) { out(r); }
 	| i:ALIAS_REF { out(i); }
 	| j:INDEX_OP { out(j); }
 	| v:RESULT_VARIABLE_REF { out(v); }
 	;
 
 sqlToken
 	: t:SQL_TOKEN { out(t); }
 	;
 
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/Settings.java b/hibernate-core/src/main/java/org/hibernate/cfg/Settings.java
index dc5664e8da..0a6a11d993 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/Settings.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/Settings.java
@@ -1,451 +1,451 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 import java.util.Map;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.EntityMode;
 import org.hibernate.MultiTenancyStrategy;
 import org.hibernate.cache.spi.QueryCacheFactory;
 import org.hibernate.cache.spi.RegionFactory;
-import org.hibernate.hql.QueryTranslatorFactory;
+import org.hibernate.hql.spi.QueryTranslatorFactory;
 import org.hibernate.service.jta.platform.spi.JtaPlatform;
 import org.hibernate.tuple.entity.EntityTuplizerFactory;
 
 /**
  * Settings that affect the behaviour of Hibernate at runtime.
  *
  * @author Gavin King
  */
 public final class Settings {
 
 	private Integer maximumFetchDepth;
 	private Map querySubstitutions;
 	private int jdbcBatchSize;
 	private int defaultBatchFetchSize;
 	private boolean scrollableResultSetsEnabled;
 	private boolean getGeneratedKeysEnabled;
 	private String defaultSchemaName;
 	private String defaultCatalogName;
 	private Integer jdbcFetchSize;
 	private String sessionFactoryName;
 	private boolean autoCreateSchema;
 	private boolean autoDropSchema;
 	private boolean autoUpdateSchema;
 	private boolean autoValidateSchema;
 	private boolean queryCacheEnabled;
 	private boolean structuredCacheEntriesEnabled;
 	private boolean secondLevelCacheEnabled;
 	private String cacheRegionPrefix;
 	private boolean minimalPutsEnabled;
 	private boolean commentsEnabled;
 	private boolean statisticsEnabled;
 	private boolean jdbcBatchVersionedData;
 	private boolean identifierRollbackEnabled;
 	private boolean flushBeforeCompletionEnabled;
 	private boolean autoCloseSessionEnabled;
 	private ConnectionReleaseMode connectionReleaseMode;
 	private RegionFactory regionFactory;
 	private QueryCacheFactory queryCacheFactory;
 	private QueryTranslatorFactory queryTranslatorFactory;
 	private boolean wrapResultSetsEnabled;
 	private boolean orderUpdatesEnabled;
 	private boolean orderInsertsEnabled;
 	private EntityMode defaultEntityMode;
 	private boolean dataDefinitionImplicitCommit;
 	private boolean dataDefinitionInTransactionSupported;
 	private boolean strictJPAQLCompliance;
 	private boolean namedQueryStartupCheckingEnabled;
 	private EntityTuplizerFactory entityTuplizerFactory;
 	private boolean checkNullability;
 //	private ComponentTuplizerFactory componentTuplizerFactory; todo : HHH-3517 and HHH-1907
 //	private BytecodeProvider bytecodeProvider;
 	private String importFiles;
 	private MultiTenancyStrategy multiTenancyStrategy;
 
 	private JtaPlatform jtaPlatform;
 
 	/**
 	 * Package protected constructor
 	 */
 	Settings() {
 	}
 
 	// public getters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public String getImportFiles() {
 		return importFiles;
 	}
 
 	public void setImportFiles(String importFiles) {
 		this.importFiles = importFiles;
 	}
 
 	public String getDefaultSchemaName() {
 		return defaultSchemaName;
 	}
 
 	public String getDefaultCatalogName() {
 		return defaultCatalogName;
 	}
 
 	public int getJdbcBatchSize() {
 		return jdbcBatchSize;
 	}
 
 	public int getDefaultBatchFetchSize() {
 		return defaultBatchFetchSize;
 	}
 
 	public Map getQuerySubstitutions() {
 		return querySubstitutions;
 	}
 
 	public boolean isIdentifierRollbackEnabled() {
 		return identifierRollbackEnabled;
 	}
 
 	public boolean isScrollableResultSetsEnabled() {
 		return scrollableResultSetsEnabled;
 	}
 
 	public boolean isGetGeneratedKeysEnabled() {
 		return getGeneratedKeysEnabled;
 	}
 
 	public boolean isMinimalPutsEnabled() {
 		return minimalPutsEnabled;
 	}
 
 	public Integer getJdbcFetchSize() {
 		return jdbcFetchSize;
 	}
 
 	public String getSessionFactoryName() {
 		return sessionFactoryName;
 	}
 
 	public boolean isAutoCreateSchema() {
 		return autoCreateSchema;
 	}
 
 	public boolean isAutoDropSchema() {
 		return autoDropSchema;
 	}
 
 	public boolean isAutoUpdateSchema() {
 		return autoUpdateSchema;
 	}
 
 	public Integer getMaximumFetchDepth() {
 		return maximumFetchDepth;
 	}
 
 	public RegionFactory getRegionFactory() {
 		return regionFactory;
 	}
 
 	public boolean isQueryCacheEnabled() {
 		return queryCacheEnabled;
 	}
 
 	public boolean isCommentsEnabled() {
 		return commentsEnabled;
 	}
 
 	public boolean isSecondLevelCacheEnabled() {
 		return secondLevelCacheEnabled;
 	}
 
 	public String getCacheRegionPrefix() {
 		return cacheRegionPrefix;
 	}
 
 	public QueryCacheFactory getQueryCacheFactory() {
 		return queryCacheFactory;
 	}
 
 	public boolean isStatisticsEnabled() {
 		return statisticsEnabled;
 	}
 
 	public boolean isJdbcBatchVersionedData() {
 		return jdbcBatchVersionedData;
 	}
 
 	public boolean isFlushBeforeCompletionEnabled() {
 		return flushBeforeCompletionEnabled;
 	}
 
 	public boolean isAutoCloseSessionEnabled() {
 		return autoCloseSessionEnabled;
 	}
 
 	public ConnectionReleaseMode getConnectionReleaseMode() {
 		return connectionReleaseMode;
 	}
 
 	public QueryTranslatorFactory getQueryTranslatorFactory() {
 		return queryTranslatorFactory;
 	}
 
 	public boolean isWrapResultSetsEnabled() {
 		return wrapResultSetsEnabled;
 	}
 
 	public boolean isOrderUpdatesEnabled() {
 		return orderUpdatesEnabled;
 	}
 
 	public boolean isOrderInsertsEnabled() {
 		return orderInsertsEnabled;
 	}
 
 	public boolean isStructuredCacheEntriesEnabled() {
 		return structuredCacheEntriesEnabled;
 	}
 
 	public EntityMode getDefaultEntityMode() {
 		return defaultEntityMode;
 	}
 
 	public boolean isAutoValidateSchema() {
 		return autoValidateSchema;
 	}
 
 	public boolean isDataDefinitionImplicitCommit() {
 		return dataDefinitionImplicitCommit;
 	}
 
 	public boolean isDataDefinitionInTransactionSupported() {
 		return dataDefinitionInTransactionSupported;
 	}
 
 	public boolean isStrictJPAQLCompliance() {
 		return strictJPAQLCompliance;
 	}
 
 	public boolean isNamedQueryStartupCheckingEnabled() {
 		return namedQueryStartupCheckingEnabled;
 	}
 
 	public EntityTuplizerFactory getEntityTuplizerFactory() {
 		return entityTuplizerFactory;
 	}
 
 //	public ComponentTuplizerFactory getComponentTuplizerFactory() {
 //		return componentTuplizerFactory;
 //	}
 
 	// package protected setters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	void setDefaultSchemaName(String string) {
 		defaultSchemaName = string;
 	}
 
 	void setDefaultCatalogName(String string) {
 		defaultCatalogName = string;
 	}
 
 	void setJdbcBatchSize(int i) {
 		jdbcBatchSize = i;
 	}
 
 	void setDefaultBatchFetchSize(int i) {
 		defaultBatchFetchSize = i;
 	}
 
 	void setQuerySubstitutions(Map map) {
 		querySubstitutions = map;
 	}
 
 	void setIdentifierRollbackEnabled(boolean b) {
 		identifierRollbackEnabled = b;
 	}
 
 	void setMinimalPutsEnabled(boolean b) {
 		minimalPutsEnabled = b;
 	}
 
 	void setScrollableResultSetsEnabled(boolean b) {
 		scrollableResultSetsEnabled = b;
 	}
 
 	void setGetGeneratedKeysEnabled(boolean b) {
 		getGeneratedKeysEnabled = b;
 	}
 
 	void setJdbcFetchSize(Integer integer) {
 		jdbcFetchSize = integer;
 	}
 
 	void setSessionFactoryName(String string) {
 		sessionFactoryName = string;
 	}
 
 	void setAutoCreateSchema(boolean b) {
 		autoCreateSchema = b;
 	}
 
 	void setAutoDropSchema(boolean b) {
 		autoDropSchema = b;
 	}
 
 	void setAutoUpdateSchema(boolean b) {
 		autoUpdateSchema = b;
 	}
 
 	void setMaximumFetchDepth(Integer i) {
 		maximumFetchDepth = i;
 	}
 
 	void setRegionFactory(RegionFactory regionFactory) {
 		this.regionFactory = regionFactory;
 	}
 
 	void setQueryCacheEnabled(boolean b) {
 		queryCacheEnabled = b;
 	}
 
 	void setCommentsEnabled(boolean commentsEnabled) {
 		this.commentsEnabled = commentsEnabled;
 	}
 
 	void setSecondLevelCacheEnabled(boolean secondLevelCacheEnabled) {
 		this.secondLevelCacheEnabled = secondLevelCacheEnabled;
 	}
 
 	void setCacheRegionPrefix(String cacheRegionPrefix) {
 		this.cacheRegionPrefix = cacheRegionPrefix;
 	}
 
 	void setQueryCacheFactory(QueryCacheFactory queryCacheFactory) {
 		this.queryCacheFactory = queryCacheFactory;
 	}
 
 	void setStatisticsEnabled(boolean statisticsEnabled) {
 		this.statisticsEnabled = statisticsEnabled;
 	}
 
 	void setJdbcBatchVersionedData(boolean jdbcBatchVersionedData) {
 		this.jdbcBatchVersionedData = jdbcBatchVersionedData;
 	}
 
 	void setFlushBeforeCompletionEnabled(boolean flushBeforeCompletionEnabled) {
 		this.flushBeforeCompletionEnabled = flushBeforeCompletionEnabled;
 	}
 
 	void setAutoCloseSessionEnabled(boolean autoCloseSessionEnabled) {
 		this.autoCloseSessionEnabled = autoCloseSessionEnabled;
 	}
 
 	void setConnectionReleaseMode(ConnectionReleaseMode connectionReleaseMode) {
 		this.connectionReleaseMode = connectionReleaseMode;
 	}
 
 	void setQueryTranslatorFactory(QueryTranslatorFactory queryTranslatorFactory) {
 		this.queryTranslatorFactory = queryTranslatorFactory;
 	}
 
 	void setWrapResultSetsEnabled(boolean wrapResultSetsEnabled) {
 		this.wrapResultSetsEnabled = wrapResultSetsEnabled;
 	}
 
 	void setOrderUpdatesEnabled(boolean orderUpdatesEnabled) {
 		this.orderUpdatesEnabled = orderUpdatesEnabled;
 	}
 
 	void setOrderInsertsEnabled(boolean orderInsertsEnabled) {
 		this.orderInsertsEnabled = orderInsertsEnabled;
 	}
 
 	void setStructuredCacheEntriesEnabled(boolean structuredCacheEntriesEnabled) {
 		this.structuredCacheEntriesEnabled = structuredCacheEntriesEnabled;
 	}
 
 	void setDefaultEntityMode(EntityMode defaultEntityMode) {
 		this.defaultEntityMode = defaultEntityMode;
 	}
 
 	void setAutoValidateSchema(boolean autoValidateSchema) {
 		this.autoValidateSchema = autoValidateSchema;
 	}
 
 	void setDataDefinitionImplicitCommit(boolean dataDefinitionImplicitCommit) {
 		this.dataDefinitionImplicitCommit = dataDefinitionImplicitCommit;
 	}
 
 	void setDataDefinitionInTransactionSupported(boolean dataDefinitionInTransactionSupported) {
 		this.dataDefinitionInTransactionSupported = dataDefinitionInTransactionSupported;
 	}
 
 	void setStrictJPAQLCompliance(boolean strictJPAQLCompliance) {
 		this.strictJPAQLCompliance = strictJPAQLCompliance;
 	}
 
 	void setNamedQueryStartupCheckingEnabled(boolean namedQueryStartupCheckingEnabled) {
 		this.namedQueryStartupCheckingEnabled = namedQueryStartupCheckingEnabled;
 	}
 
 	void setEntityTuplizerFactory(EntityTuplizerFactory entityTuplizerFactory) {
 		this.entityTuplizerFactory = entityTuplizerFactory;
 	}
 
 	public boolean isCheckNullability() {
 		return checkNullability;
 	}
 
 	public void setCheckNullability(boolean checkNullability) {
 		this.checkNullability = checkNullability;
 	}
 
 	//	void setComponentTuplizerFactory(ComponentTuplizerFactory componentTuplizerFactory) {
 //		this.componentTuplizerFactory = componentTuplizerFactory;
 //	}
 
 	//	public BytecodeProvider getBytecodeProvider() {
 //		return bytecodeProvider;
 //	}
 //
 //	void setBytecodeProvider(BytecodeProvider bytecodeProvider) {
 //		this.bytecodeProvider = bytecodeProvider;
 //	}
 
 
 	public JtaPlatform getJtaPlatform() {
 		return jtaPlatform;
 	}
 
 	void setJtaPlatform(JtaPlatform jtaPlatform) {
 		this.jtaPlatform = jtaPlatform;
 	}
 
 	public MultiTenancyStrategy getMultiTenancyStrategy() {
 		return multiTenancyStrategy;
 	}
 
 	void setMultiTenancyStrategy(MultiTenancyStrategy multiTenancyStrategy) {
 		this.multiTenancyStrategy = multiTenancyStrategy;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/SettingsFactory.java b/hibernate-core/src/main/java/org/hibernate/cfg/SettingsFactory.java
index 1240b36824..7b88455ecb 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/SettingsFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/SettingsFactory.java
@@ -1,410 +1,410 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 import java.io.Serializable;
 import java.util.Map;
 import java.util.Properties;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.MultiTenancyStrategy;
 import org.hibernate.cache.internal.NoCachingRegionFactory;
 import org.hibernate.cache.spi.QueryCacheFactory;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cache.internal.bridge.RegionFactoryCacheProviderBridge;
 import org.hibernate.engine.jdbc.spi.ExtractedDatabaseMetaData;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.transaction.spi.TransactionFactory;
-import org.hibernate.hql.QueryTranslatorFactory;
+import org.hibernate.hql.spi.QueryTranslatorFactory;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.service.jta.platform.spi.JtaPlatform;
 
 /**
  * Reads configuration properties and builds a {@link Settings} instance.
  *
  * @author Gavin King
  */
 public class SettingsFactory implements Serializable {
 
     private static final long serialVersionUID = -1194386144994524825L;
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, SettingsFactory.class.getName());
 
 	public static final String DEF_CACHE_REG_FACTORY = NoCachingRegionFactory.class.getName();
 
 	protected SettingsFactory() {
 	}
 
 	public Settings buildSettings(Properties props, ServiceRegistry serviceRegistry) {
 		final JdbcServices jdbcServices = serviceRegistry.getService( JdbcServices.class );
 		Settings settings = new Settings();
 
 		//SessionFactory name:
 
 		String sessionFactoryName = props.getProperty(Environment.SESSION_FACTORY_NAME);
 		settings.setSessionFactoryName(sessionFactoryName);
 
 		//JDBC and connection settings:
 
 		//Interrogate JDBC metadata
 		ExtractedDatabaseMetaData meta = jdbcServices.getExtractedMetaDataSupport();
 
 		settings.setDataDefinitionImplicitCommit( meta.doesDataDefinitionCauseTransactionCommit() );
 		settings.setDataDefinitionInTransactionSupported( meta.supportsDataDefinitionInTransaction() );
 
 		//use dialect default properties
 		final Properties properties = new Properties();
 		properties.putAll( jdbcServices.getDialect().getDefaultProperties() );
 		properties.putAll( props );
 
 		// Transaction settings:
 		settings.setJtaPlatform( serviceRegistry.getService( JtaPlatform.class ) );
 
 		boolean flushBeforeCompletion = ConfigurationHelper.getBoolean(Environment.FLUSH_BEFORE_COMPLETION, properties);
         LOG.debugf( "Automatic flush during beforeCompletion(): %s", enabledDisabled(flushBeforeCompletion) );
 		settings.setFlushBeforeCompletionEnabled(flushBeforeCompletion);
 
 		boolean autoCloseSession = ConfigurationHelper.getBoolean(Environment.AUTO_CLOSE_SESSION, properties);
         LOG.debugf( "Automatic session close at end of transaction: %s", enabledDisabled(autoCloseSession) );
 		settings.setAutoCloseSessionEnabled(autoCloseSession);
 
 		//JDBC and connection settings:
 
 		int batchSize = ConfigurationHelper.getInt(Environment.STATEMENT_BATCH_SIZE, properties, 0);
 		if ( !meta.supportsBatchUpdates() ) {
 			batchSize = 0;
 		}
 		if ( batchSize > 0 ) {
 			LOG.debugf( "JDBC batch size: %s", batchSize );
 		}
 		settings.setJdbcBatchSize(batchSize);
 
 		boolean jdbcBatchVersionedData = ConfigurationHelper.getBoolean(Environment.BATCH_VERSIONED_DATA, properties, false);
         if ( batchSize > 0 ) {
 			LOG.debugf( "JDBC batch updates for versioned data: %s", enabledDisabled(jdbcBatchVersionedData) );
 		}
 		settings.setJdbcBatchVersionedData(jdbcBatchVersionedData);
 
 		boolean useScrollableResultSets = ConfigurationHelper.getBoolean(
 				Environment.USE_SCROLLABLE_RESULTSET,
 				properties,
 				meta.supportsScrollableResults()
 		);
         LOG.debugf( "Scrollable result sets: %s", enabledDisabled(useScrollableResultSets) );
 		settings.setScrollableResultSetsEnabled(useScrollableResultSets);
 
 		boolean wrapResultSets = ConfigurationHelper.getBoolean(Environment.WRAP_RESULT_SETS, properties, false);
         LOG.debugf( "Wrap result sets: %s", enabledDisabled(wrapResultSets) );
 		settings.setWrapResultSetsEnabled(wrapResultSets);
 
 		boolean useGetGeneratedKeys = ConfigurationHelper.getBoolean(Environment.USE_GET_GENERATED_KEYS, properties, meta.supportsGetGeneratedKeys());
         LOG.debugf( "JDBC3 getGeneratedKeys(): %s", enabledDisabled(useGetGeneratedKeys) );
 		settings.setGetGeneratedKeysEnabled(useGetGeneratedKeys);
 
 		Integer statementFetchSize = ConfigurationHelper.getInteger(Environment.STATEMENT_FETCH_SIZE, properties);
         if (statementFetchSize != null) {
 			LOG.debugf( "JDBC result set fetch size: %s", statementFetchSize );
 		}
 		settings.setJdbcFetchSize(statementFetchSize);
 
 		String releaseModeName = ConfigurationHelper.getString( Environment.RELEASE_CONNECTIONS, properties, "auto" );
         LOG.debugf( "Connection release mode: %s", releaseModeName );
 		ConnectionReleaseMode releaseMode;
 		if ( "auto".equals(releaseModeName) ) {
 			releaseMode = serviceRegistry.getService( TransactionFactory.class ).getDefaultReleaseMode();
 		}
 		else {
 			releaseMode = ConnectionReleaseMode.parse( releaseModeName );
 			if ( releaseMode == ConnectionReleaseMode.AFTER_STATEMENT &&
 					! jdbcServices.getConnectionProvider().supportsAggressiveRelease() ) {
                 LOG.unsupportedAfterStatement();
 				releaseMode = ConnectionReleaseMode.AFTER_TRANSACTION;
 			}
 		}
 		settings.setConnectionReleaseMode( releaseMode );
 
 		//SQL Generation settings:
 
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
         if ( defaultSchema != null ) {
 			LOG.debugf( "Default schema: %s", defaultSchema );
 		}
         if (defaultCatalog != null) {
 			LOG.debugf( "Default catalog: %s", defaultCatalog );
 		}
 		settings.setDefaultSchemaName( defaultSchema );
 		settings.setDefaultCatalogName( defaultCatalog );
 
 		Integer maxFetchDepth = ConfigurationHelper.getInteger( Environment.MAX_FETCH_DEPTH, properties );
         if ( maxFetchDepth != null ) {
 			LOG.debugf( "Maximum outer join fetch depth: %s", maxFetchDepth );
 		}
 		settings.setMaximumFetchDepth( maxFetchDepth );
 
 		int batchFetchSize = ConfigurationHelper.getInt(Environment.DEFAULT_BATCH_FETCH_SIZE, properties, 1);
         LOG.debugf( "Default batch fetch size: %s", batchFetchSize );
 		settings.setDefaultBatchFetchSize( batchFetchSize );
 
 		boolean comments = ConfigurationHelper.getBoolean( Environment.USE_SQL_COMMENTS, properties );
         LOG.debugf( "Generate SQL with comments: %s", enabledDisabled(comments) );
 		settings.setCommentsEnabled( comments );
 
 		boolean orderUpdates = ConfigurationHelper.getBoolean( Environment.ORDER_UPDATES, properties );
         LOG.debugf( "Order SQL updates by primary key: %s", enabledDisabled(orderUpdates) );
 		settings.setOrderUpdatesEnabled( orderUpdates );
 
 		boolean orderInserts = ConfigurationHelper.getBoolean(Environment.ORDER_INSERTS, properties);
         LOG.debugf( "Order SQL inserts for batching: %s", enabledDisabled(orderInserts) );
 		settings.setOrderInsertsEnabled( orderInserts );
 
 		//Query parser settings:
 
 		settings.setQueryTranslatorFactory( createQueryTranslatorFactory( properties, serviceRegistry ) );
 
         Map querySubstitutions = ConfigurationHelper.toMap( Environment.QUERY_SUBSTITUTIONS, " ,=;:\n\t\r\f", properties );
         LOG.debugf( "Query language substitutions: %s", querySubstitutions );
 		settings.setQuerySubstitutions( querySubstitutions );
 
 		boolean jpaqlCompliance = ConfigurationHelper.getBoolean( Environment.JPAQL_STRICT_COMPLIANCE, properties, false );
 		LOG.debugf( "JPA-QL strict compliance: %s", enabledDisabled(jpaqlCompliance) );
 		settings.setStrictJPAQLCompliance( jpaqlCompliance );
 
 		// Second-level / query cache:
 
 		boolean useSecondLevelCache = ConfigurationHelper.getBoolean( Environment.USE_SECOND_LEVEL_CACHE, properties, true );
         LOG.debugf( "Second-level cache: %s", enabledDisabled(useSecondLevelCache) );
 		settings.setSecondLevelCacheEnabled( useSecondLevelCache );
 
 		boolean useQueryCache = ConfigurationHelper.getBoolean(Environment.USE_QUERY_CACHE, properties);
         LOG.debugf( "Query cache: %s", enabledDisabled(useQueryCache) );
 		settings.setQueryCacheEnabled( useQueryCache );
 		if (useQueryCache) {
 			settings.setQueryCacheFactory( createQueryCacheFactory( properties, serviceRegistry ) );
 		}
 
 		// The cache provider is needed when we either have second-level cache enabled
 		// or query cache enabled.  Note that useSecondLevelCache is enabled by default
 		settings.setRegionFactory( createRegionFactory( properties, ( useSecondLevelCache || useQueryCache ), serviceRegistry ) );
 
 		boolean useMinimalPuts = ConfigurationHelper.getBoolean(
 				Environment.USE_MINIMAL_PUTS, properties, settings.getRegionFactory().isMinimalPutsEnabledByDefault()
 		);
         LOG.debugf( "Optimize cache for minimal puts: %s", enabledDisabled(useMinimalPuts) );
 		settings.setMinimalPutsEnabled( useMinimalPuts );
 
 		String prefix = properties.getProperty( Environment.CACHE_REGION_PREFIX );
 		if ( StringHelper.isEmpty(prefix) ) {
 			prefix=null;
 		}
         if (prefix != null) {
 			LOG.debugf( "Cache region prefix: %s", prefix );
 		}
 		settings.setCacheRegionPrefix( prefix );
 
 		boolean useStructuredCacheEntries = ConfigurationHelper.getBoolean( Environment.USE_STRUCTURED_CACHE, properties, false );
         LOG.debugf( "Structured second-level cache entries: %s", enabledDisabled(useStructuredCacheEntries) );
 		settings.setStructuredCacheEntriesEnabled( useStructuredCacheEntries );
 
 
 		//Statistics and logging:
 
 		boolean useStatistics = ConfigurationHelper.getBoolean( Environment.GENERATE_STATISTICS, properties );
 		LOG.debugf( "Statistics: %s", enabledDisabled(useStatistics) );
 		settings.setStatisticsEnabled( useStatistics );
 
 		boolean useIdentifierRollback = ConfigurationHelper.getBoolean( Environment.USE_IDENTIFIER_ROLLBACK, properties );
         LOG.debugf( "Deleted entity synthetic identifier rollback: %s", enabledDisabled(useIdentifierRollback) );
 		settings.setIdentifierRollbackEnabled( useIdentifierRollback );
 
 		//Schema export:
 
 		String autoSchemaExport = properties.getProperty( Environment.HBM2DDL_AUTO );
 		if ( "validate".equals(autoSchemaExport) ) {
 			settings.setAutoValidateSchema( true );
 		}
 		if ( "update".equals(autoSchemaExport) ) {
 			settings.setAutoUpdateSchema( true );
 		}
 		if ( "create".equals(autoSchemaExport) ) {
 			settings.setAutoCreateSchema( true );
 		}
 		if ( "create-drop".equals( autoSchemaExport ) ) {
 			settings.setAutoCreateSchema( true );
 			settings.setAutoDropSchema( true );
 		}
 		settings.setImportFiles( properties.getProperty( Environment.HBM2DDL_IMPORT_FILES ) );
 
 		EntityMode defaultEntityMode = EntityMode.parse( properties.getProperty( Environment.DEFAULT_ENTITY_MODE ) );
         LOG.debugf( "Default entity-mode: %s", defaultEntityMode );
 		settings.setDefaultEntityMode( defaultEntityMode );
 
 		boolean namedQueryChecking = ConfigurationHelper.getBoolean( Environment.QUERY_STARTUP_CHECKING, properties, true );
         LOG.debugf( "Named query checking : %s", enabledDisabled(namedQueryChecking) );
 		settings.setNamedQueryStartupCheckingEnabled( namedQueryChecking );
 
 		boolean checkNullability = ConfigurationHelper.getBoolean(Environment.CHECK_NULLABILITY, properties, true);
         LOG.debugf( "Check Nullability in Core (should be disabled when Bean Validation is on): %s", enabledDisabled(checkNullability) );
 		settings.setCheckNullability(checkNullability);
 
 		MultiTenancyStrategy multiTenancyStrategy = MultiTenancyStrategy.determineMultiTenancyStrategy( properties );
 		LOG.debugf( "multi-tenancy strategy : %s", multiTenancyStrategy );
 		settings.setMultiTenancyStrategy( multiTenancyStrategy );
 
 //		String provider = properties.getProperty( Environment.BYTECODE_PROVIDER );
 //		log.info( "Bytecode provider name : " + provider );
 //		BytecodeProvider bytecodeProvider = buildBytecodeProvider( provider );
 //		settings.setBytecodeProvider( bytecodeProvider );
 
 		return settings;
 
 	}
 
 //	protected BytecodeProvider buildBytecodeProvider(String providerName) {
 //		if ( "javassist".equals( providerName ) ) {
 //			return new org.hibernate.bytecode.internal.javassist.BytecodeProviderImpl();
 //		}
 //		else {
 //            LOG.debugf("Using javassist as bytecode provider by default");
 //			return new org.hibernate.bytecode.internal.javassist.BytecodeProviderImpl();
 //		}
 //	}
 
 	private static String enabledDisabled(boolean value) {
 		return value ? "enabled" : "disabled";
 	}
 
 	protected QueryCacheFactory createQueryCacheFactory(Properties properties, ServiceRegistry serviceRegistry) {
 		String queryCacheFactoryClassName = ConfigurationHelper.getString(
 				Environment.QUERY_CACHE_FACTORY, properties, "org.hibernate.cache.internal.StandardQueryCacheFactory"
 		);
         LOG.debugf( "Query cache factory: %s", queryCacheFactoryClassName );
 		try {
 			return (QueryCacheFactory) serviceRegistry.getService( ClassLoaderService.class )
 					.classForName( queryCacheFactoryClassName )
 					.newInstance();
 		}
 		catch (Exception e) {
 			throw new HibernateException( "could not instantiate QueryCacheFactory: " + queryCacheFactoryClassName, e );
 		}
 	}
 
 	public static RegionFactory createRegionFactory(Properties properties, boolean cachingEnabled, ServiceRegistry serviceRegistry) {
 		String regionFactoryClassName = ConfigurationHelper.getString(
 				Environment.CACHE_REGION_FACTORY, properties, null
 		);
 		if ( regionFactoryClassName == null && cachingEnabled ) {
 			String providerClassName = ConfigurationHelper.getString( Environment.CACHE_PROVIDER, properties, null );
 			if ( providerClassName != null ) {
 				// legacy behavior, apply the bridge...
 				regionFactoryClassName = RegionFactoryCacheProviderBridge.class.getName();
 			}
 		}
 		if ( regionFactoryClassName == null ) {
 			regionFactoryClassName = DEF_CACHE_REG_FACTORY;
 		}
         LOG.debugf( "Cache region factory : %s", regionFactoryClassName );
 		try {
 			try {
 				return (RegionFactory) serviceRegistry.getService( ClassLoaderService.class )
 						.classForName( regionFactoryClassName )
 						.getConstructor( Properties.class )
 						.newInstance( properties );
 			}
 			catch ( NoSuchMethodException e ) {
 				// no constructor accepting Properties found, try no arg constructor
                 LOG.debugf(
 						"%s did not provide constructor accepting java.util.Properties; attempting no-arg constructor.",
 						regionFactoryClassName
 				);
 				return (RegionFactory) serviceRegistry.getService( ClassLoaderService.class )
 						.classForName( regionFactoryClassName )
 						.newInstance();
 			}
 		}
 		catch ( Exception e ) {
 			throw new HibernateException( "could not instantiate RegionFactory [" + regionFactoryClassName + "]", e );
 		}
 	}
 
 	protected QueryTranslatorFactory createQueryTranslatorFactory(Properties properties, ServiceRegistry serviceRegistry) {
 		String className = ConfigurationHelper.getString(
-				Environment.QUERY_TRANSLATOR, properties, "org.hibernate.hql.ast.ASTQueryTranslatorFactory"
+				Environment.QUERY_TRANSLATOR, properties, "org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory"
 		);
         LOG.debugf( "Query translator: %s", className );
 		try {
 			return (QueryTranslatorFactory) serviceRegistry.getService( ClassLoaderService.class )
 					.classForName( className )
 					.newInstance();
 		}
 		catch (Exception e) {
 			throw new HibernateException( "could not instantiate QueryTranslatorFactory: " + className, e );
 		}
 	}
 
 	public static RegionFactory createRegionFactory(Properties properties, boolean cachingEnabled) {
 		// todo : REMOVE!  THIS IS TOTALLY A TEMPORARY HACK FOR org.hibernate.cfg.AnnotationBinder which will be going away
 		String regionFactoryClassName = ConfigurationHelper.getString(
 				Environment.CACHE_REGION_FACTORY, properties, null
 		);
 		if ( regionFactoryClassName == null && cachingEnabled ) {
 			String providerClassName = ConfigurationHelper.getString( Environment.CACHE_PROVIDER, properties, null );
 			if ( providerClassName != null ) {
 				// legacy behavior, apply the bridge...
 				regionFactoryClassName = RegionFactoryCacheProviderBridge.class.getName();
 			}
 		}
 		if ( regionFactoryClassName == null ) {
 			regionFactoryClassName = DEF_CACHE_REG_FACTORY;
 		}
         LOG.debugf( "Cache region factory : %s", regionFactoryClassName );
 		try {
 			try {
 				return (RegionFactory) org.hibernate.internal.util.ReflectHelper.classForName( regionFactoryClassName )
 						.getConstructor( Properties.class )
 						.newInstance( properties );
 			}
 			catch ( NoSuchMethodException e ) {
 				// no constructor accepting Properties found, try no arg constructor
                 LOG.debugf(
 						"%s did not provide constructor accepting java.util.Properties; attempting no-arg constructor.",
 						regionFactoryClassName
 				);
 				return (RegionFactory) org.hibernate.internal.util.ReflectHelper.classForName( regionFactoryClassName )
 						.newInstance();
 			}
 		}
 		catch ( Exception e ) {
 			throw new HibernateException( "could not instantiate RegionFactory [" + regionFactoryClassName + "]", e );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/HQLQueryPlan.java b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/HQLQueryPlan.java
index fbd1a1616e..26ab241489 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/HQLQueryPlan.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/HQLQueryPlan.java
@@ -1,339 +1,339 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.query.spi;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.hql.internal.QuerySplitter;
+import org.hibernate.hql.spi.ParameterTranslations;
+import org.hibernate.hql.spi.QueryTranslator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.event.spi.EventSource;
-import org.hibernate.hql.FilterTranslator;
-import org.hibernate.hql.ParameterTranslations;
-import org.hibernate.hql.QuerySplitter;
-import org.hibernate.hql.QueryTranslator;
+import org.hibernate.hql.spi.FilterTranslator;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.internal.util.collections.EmptyIterator;
 import org.hibernate.internal.util.collections.IdentitySet;
 import org.hibernate.internal.util.collections.JoinedIterator;
 import org.hibernate.type.Type;
 
 /**
  * Defines a query execution plan for an HQL query (or filter).
  *
  * @author Steve Ebersole
  */
 public class HQLQueryPlan implements Serializable {
 
     // TODO : keep separate notions of QT[] here for shallow/non-shallow queries...
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, HQLQueryPlan.class.getName());
 
 	private final String sourceQuery;
 	private final QueryTranslator[] translators;
 	private final String[] sqlStrings;
 
 	private final ParameterMetadata parameterMetadata;
 	private final ReturnMetadata returnMetadata;
 	private final Set querySpaces;
 
 	private final Set enabledFilterNames;
 	private final boolean shallow;
 
 
 	public HQLQueryPlan(String hql, boolean shallow, Map enabledFilters, SessionFactoryImplementor factory) {
 		this( hql, null, shallow, enabledFilters, factory );
 	}
 
 	protected HQLQueryPlan(String hql, String collectionRole, boolean shallow, Map enabledFilters, SessionFactoryImplementor factory) {
 		this.sourceQuery = hql;
 		this.shallow = shallow;
 
 		Set copy = new HashSet();
 		copy.addAll( enabledFilters.keySet() );
 		this.enabledFilterNames = java.util.Collections.unmodifiableSet( copy );
 
 		Set combinedQuerySpaces = new HashSet();
 		String[] concreteQueryStrings = QuerySplitter.concreteQueries( hql, factory );
 		final int length = concreteQueryStrings.length;
 		translators = new QueryTranslator[length];
 		List sqlStringList = new ArrayList();
 		for ( int i=0; i<length; i++ ) {
 			if ( collectionRole == null ) {
 				translators[i] = factory.getSettings()
 						.getQueryTranslatorFactory()
 						.createQueryTranslator( hql, concreteQueryStrings[i], enabledFilters, factory );
 				translators[i].compile( factory.getSettings().getQuerySubstitutions(), shallow );
 			}
 			else {
 				translators[i] = factory.getSettings()
 						.getQueryTranslatorFactory()
 						.createFilterTranslator( hql, concreteQueryStrings[i], enabledFilters, factory );
 				( ( FilterTranslator ) translators[i] ).compile( collectionRole, factory.getSettings().getQuerySubstitutions(), shallow );
 			}
 			combinedQuerySpaces.addAll( translators[i].getQuerySpaces() );
 			sqlStringList.addAll( translators[i].collectSqlStrings() );
 		}
 
 		this.sqlStrings = ArrayHelper.toStringArray( sqlStringList );
 		this.querySpaces = combinedQuerySpaces;
 
 		if ( length == 0 ) {
 			parameterMetadata = new ParameterMetadata( null, null );
 			returnMetadata = null;
 		}
 		else {
 			this.parameterMetadata = buildParameterMetadata( translators[0].getParameterTranslations(), hql );
 			if ( translators[0].isManipulationStatement() ) {
 				returnMetadata = null;
 			}
 			else {
 				if ( length > 1 ) {
 					final int returns = translators[0].getReturnTypes().length;
 					returnMetadata = new ReturnMetadata( translators[0].getReturnAliases(), new Type[returns] );
 				}
 				else {
 					returnMetadata = new ReturnMetadata( translators[0].getReturnAliases(), translators[0].getReturnTypes() );
 				}
 			}
 		}
 	}
 
 	public String getSourceQuery() {
 		return sourceQuery;
 	}
 
 	public Set getQuerySpaces() {
 		return querySpaces;
 	}
 
 	public ParameterMetadata getParameterMetadata() {
 		return parameterMetadata;
 	}
 
 	public ReturnMetadata getReturnMetadata() {
 		return returnMetadata;
 	}
 
 	public Set getEnabledFilterNames() {
 		return enabledFilterNames;
 	}
 
 	public String[] getSqlStrings() {
 		return sqlStrings;
 	}
 
 	public Set getUtilizedFilterNames() {
 		// TODO : add this info to the translator and aggregate it here...
 		return null;
 	}
 
 	public boolean isShallow() {
 		return shallow;
 	}
 
 	public List performList(
 			QueryParameters queryParameters,
 	        SessionImplementor session) throws HibernateException {
         if (LOG.isTraceEnabled()) {
             LOG.trace("Find: " + getSourceQuery());
 			queryParameters.traceParameters( session.getFactory() );
 		}
 		boolean hasLimit = queryParameters.getRowSelection() != null &&
 		                   queryParameters.getRowSelection().definesLimits();
 		boolean needsLimit = hasLimit && translators.length > 1;
 		QueryParameters queryParametersToUse;
 		if ( needsLimit ) {
             LOG.needsLimit();
 			RowSelection selection = new RowSelection();
 			selection.setFetchSize( queryParameters.getRowSelection().getFetchSize() );
 			selection.setTimeout( queryParameters.getRowSelection().getTimeout() );
 			queryParametersToUse = queryParameters.createCopyUsing( selection );
 		}
 		else {
 			queryParametersToUse = queryParameters;
 		}
 
 		List combinedResults = new ArrayList();
 		IdentitySet distinction = new IdentitySet();
 		int includedCount = -1;
 		translator_loop: for ( int i = 0; i < translators.length; i++ ) {
 			List tmp = translators[i].list( session, queryParametersToUse );
 			if ( needsLimit ) {
 				// NOTE : firstRow is zero-based
 				int first = queryParameters.getRowSelection().getFirstRow() == null
 				            ? 0
 			                : queryParameters.getRowSelection().getFirstRow().intValue();
 				int max = queryParameters.getRowSelection().getMaxRows() == null
 				            ? -1
 			                : queryParameters.getRowSelection().getMaxRows().intValue();
 				final int size = tmp.size();
 				for ( int x = 0; x < size; x++ ) {
 					final Object result = tmp.get( x );
 					if ( ! distinction.add( result ) ) {
 						continue;
 					}
 					includedCount++;
 					if ( includedCount < first ) {
 						continue;
 					}
 					combinedResults.add( result );
 					if ( max >= 0 && includedCount > max ) {
 						// break the outer loop !!!
 						break translator_loop;
 					}
 				}
 			}
 			else {
 				combinedResults.addAll( tmp );
 			}
 		}
 		return combinedResults;
 	}
 
 	public Iterator performIterate(
 			QueryParameters queryParameters,
 	        EventSource session) throws HibernateException {
         if (LOG.isTraceEnabled()) {
             LOG.trace("Iterate: " + getSourceQuery());
 			queryParameters.traceParameters( session.getFactory() );
 		}
 		if ( translators.length == 0 ) {
 			return EmptyIterator.INSTANCE;
 		}
 
 		Iterator[] results = null;
 		boolean many = translators.length > 1;
 		if (many) {
 			results = new Iterator[translators.length];
 		}
 
 		Iterator result = null;
 		for ( int i = 0; i < translators.length; i++ ) {
 			result = translators[i].iterate( queryParameters, session );
 			if (many) results[i] = result;
 		}
 
 		return many ? new JoinedIterator(results) : result;
 	}
 
 	public ScrollableResults performScroll(
 			QueryParameters queryParameters,
 	        SessionImplementor session) throws HibernateException {
         if (LOG.isTraceEnabled()) {
             LOG.trace("Iterate: " + getSourceQuery());
 			queryParameters.traceParameters( session.getFactory() );
 		}
 		if ( translators.length != 1 ) {
 			throw new QueryException( "implicit polymorphism not supported for scroll() queries" );
 		}
 		if ( queryParameters.getRowSelection().definesLimits() && translators[0].containsCollectionFetches() ) {
 			throw new QueryException( "firstResult/maxResults not supported in conjunction with scroll() of a query containing collection fetches" );
 		}
 
 		return translators[0].scroll( queryParameters, session );
 	}
 
 	public int performExecuteUpdate(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException {
         if (LOG.isTraceEnabled()) {
             LOG.trace("Execute update: " + getSourceQuery());
 			queryParameters.traceParameters( session.getFactory() );
 		}
         if (translators.length != 1) LOG.splitQueries(getSourceQuery(), translators.length);
 		int result = 0;
 		for ( int i = 0; i < translators.length; i++ ) {
 			result += translators[i].executeUpdate( queryParameters, session );
 		}
 		return result;
 	}
 
 	private ParameterMetadata buildParameterMetadata(ParameterTranslations parameterTranslations, String hql) {
 		long start = System.currentTimeMillis();
 		ParamLocationRecognizer recognizer = ParamLocationRecognizer.parseLocations( hql );
 		long end = System.currentTimeMillis();
         LOG.trace("HQL param location recognition took " + (end - start) + " mills (" + hql + ")");
 
 		int ordinalParamCount = parameterTranslations.getOrdinalParameterCount();
 		int[] locations = ArrayHelper.toIntArray( recognizer.getOrdinalParameterLocationList() );
 		if ( parameterTranslations.supportsOrdinalParameterMetadata() && locations.length != ordinalParamCount ) {
 			throw new HibernateException( "ordinal parameter mismatch" );
 		}
 		ordinalParamCount = locations.length;
 		OrdinalParameterDescriptor[] ordinalParamDescriptors = new OrdinalParameterDescriptor[ordinalParamCount];
 		for ( int i = 1; i <= ordinalParamCount; i++ ) {
 			ordinalParamDescriptors[ i - 1 ] = new OrdinalParameterDescriptor(
 					i,
 			        parameterTranslations.supportsOrdinalParameterMetadata()
 		                    ? parameterTranslations.getOrdinalParameterExpectedType( i )
 		                    : null,
 			        locations[ i - 1 ]
 			);
 		}
 
 		Iterator itr = recognizer.getNamedParameterDescriptionMap().entrySet().iterator();
 		Map namedParamDescriptorMap = new HashMap();
 		while( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			final String name = ( String ) entry.getKey();
 			final ParamLocationRecognizer.NamedParameterDescription description =
 					( ParamLocationRecognizer.NamedParameterDescription ) entry.getValue();
 			namedParamDescriptorMap.put(
 					name,
 					new NamedParameterDescriptor(
 							name,
 					        parameterTranslations.getNamedParameterExpectedType( name ),
 					        description.buildPositionsArray(),
 					        description.isJpaStyle()
 					)
 			);
 		}
 
 		return new ParameterMetadata( ordinalParamDescriptors, namedParamDescriptorMap );
 	}
 
 	public QueryTranslator[] getTranslators() {
 		QueryTranslator[] copy = new QueryTranslator[translators.length];
 		System.arraycopy(translators, 0, copy, 0, copy.length);
 		return copy;
 	}
 
 	public Class getDynamicInstantiationResultType() {
 		return translators[0].getDynamicInstantiationResultType();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/ParameterParser.java b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/ParameterParser.java
index 2a87fcf6bb..b970591afe 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/ParameterParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/ParameterParser.java
@@ -1,162 +1,162 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.engine.query.spi;
 import org.hibernate.QueryException;
-import org.hibernate.hql.classic.ParserHelper;
+import org.hibernate.hql.internal.classic.ParserHelper;
 import org.hibernate.internal.util.StringHelper;
 
 /**
  * The single available method {@link #parse} is responsible for parsing a
  * query string and recognizing tokens in relation to parameters (either
  * named, JPA-style, or ordinal) and providing callbacks about such
  * recognitions.
  *
  * @author Steve Ebersole
  */
 public class ParameterParser {
 
 	public static interface Recognizer {
 		public void outParameter(int position);
 		public void ordinalParameter(int position);
 		public void namedParameter(String name, int position);
 		public void jpaPositionalParameter(String name, int position);
 		public void other(char character);
 	}
 
 	/**
 	 * Direct instantiation of ParameterParser disallowed.
 	 */
 	private ParameterParser() {
 	}
 
 	/**
 	 * Performs the actual parsing and tokenizing of the query string making appropriate
 	 * callbacks to the given recognizer upon recognition of the various tokens.
 	 * <p/>
 	 * Note that currently, this only knows how to deal with a single output
 	 * parameter (for callable statements).  If we later add support for
 	 * multiple output params, this, obviously, needs to change.
 	 *
 	 * @param sqlString The string to be parsed/tokenized.
 	 * @param recognizer The thing which handles recognition events.
 	 * @throws QueryException Indicates unexpected parameter conditions.
 	 */
 	public static void parse(String sqlString, Recognizer recognizer) throws QueryException {
 		boolean hasMainOutputParameter = startsWithEscapeCallTemplate( sqlString );
 		boolean foundMainOutputParam = false;
 
 		int stringLength = sqlString.length();
 		boolean inQuote = false;
 		for ( int indx = 0; indx < stringLength; indx++ ) {
 			char c = sqlString.charAt( indx );
 			if ( inQuote ) {
 				if ( '\'' == c ) {
 					inQuote = false;
 				}
 				recognizer.other( c );
 			}
 			else if ( '\'' == c ) {
 				inQuote = true;
 				recognizer.other( c );
 			}
 			else {
 				if ( c == ':' ) {
 					// named parameter
 					int right = StringHelper.firstIndexOfChar( sqlString, ParserHelper.HQL_SEPARATORS, indx + 1 );
 					int chopLocation = right < 0 ? sqlString.length() : right;
 					String param = sqlString.substring( indx + 1, chopLocation );
 					if ( StringHelper.isEmpty( param ) ) {
 						throw new QueryException(
 								"Space is not allowed after parameter prefix ':' [" + sqlString + "]"
 						);
 					}
 					recognizer.namedParameter( param, indx );
 					indx = chopLocation - 1;
 				}
 				else if ( c == '?' ) {
 					// could be either an ordinal or JPA-positional parameter
 					if ( indx < stringLength - 1 && Character.isDigit( sqlString.charAt( indx + 1 ) ) ) {
 						// a peek ahead showed this as an JPA-positional parameter
 						int right = StringHelper.firstIndexOfChar( sqlString, ParserHelper.HQL_SEPARATORS, indx + 1 );
 						int chopLocation = right < 0 ? sqlString.length() : right;
 						String param = sqlString.substring( indx + 1, chopLocation );
 						// make sure this "name" is an integral
 						try {
 							new Integer( param );
 						}
 						catch( NumberFormatException e ) {
 							throw new QueryException( "JPA-style positional param was not an integral ordinal" );
 						}
 						recognizer.jpaPositionalParameter( param, indx );
 						indx = chopLocation - 1;
 					}
 					else {
 						if ( hasMainOutputParameter && !foundMainOutputParam ) {
 							foundMainOutputParam = true;
 							recognizer.outParameter( indx );
 						}
 						else {
 							recognizer.ordinalParameter( indx );
 						}
 					}
 				}
 				else {
 					recognizer.other( c );
 				}
 			}
 		}
 	}
 
 	public static boolean startsWithEscapeCallTemplate(String sqlString) {
 		if ( ! ( sqlString.startsWith( "{" ) && sqlString.endsWith( "}" ) ) ) {
 			return false;
 		}
 
 		int chopLocation = sqlString.indexOf( "call" );
 		if ( chopLocation <= 0 ) {
 			return false;
 		}
 
 		final String checkString = sqlString.substring( 1, chopLocation + 4 );
 		final String fixture = "?=call";
 		int fixturePosition = 0;
 		boolean matches = true;
 		for ( int i = 0, max = checkString.length(); i < max; i++ ) {
 			final char c = Character.toLowerCase( checkString.charAt( i ) );
 			if ( Character.isWhitespace( c ) ) {
 				continue;
 			}
 			if ( c == fixture.charAt( fixturePosition ) ) {
 				fixturePosition++;
 				continue;
 			}
 			matches = false;
 			break;
 		}
 
 		return matches;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/QueryParameters.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/QueryParameters.java
index 93fe188ad2..876d43d21f 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/QueryParameters.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/QueryParameters.java
@@ -1,563 +1,563 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.StringTokenizer;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.LockOptions;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollMode;
 import org.hibernate.dialect.Dialect;
-import org.hibernate.hql.classic.ParserHelper;
+import org.hibernate.hql.internal.classic.ParserHelper;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.FilterImpl;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.pretty.Printer;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.Type;
 
 /**
  * @author Gavin King
  */
 public final class QueryParameters {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, QueryParameters.class.getName());
 
 	private Type[] positionalParameterTypes;
 	private Object[] positionalParameterValues;
 	private Map namedParameters;
 	private LockOptions lockOptions;
 	private RowSelection rowSelection;
 	private boolean cacheable;
 	private String cacheRegion;
 	private String comment;
 	private ScrollMode scrollMode;
 	private Serializable[] collectionKeys;
 	private Object optionalObject;
 	private String optionalEntityName;
 	private Serializable optionalId;
 	private boolean isReadOnlyInitialized;
 	private boolean readOnly;
 	private boolean callable = false;
 	private boolean autodiscovertypes = false;
 	private boolean isNaturalKeyLookup;
 
 	private final ResultTransformer resultTransformer; // why is all others non final ?
 
 	private String processedSQL;
 	private Type[] processedPositionalParameterTypes;
 	private Object[] processedPositionalParameterValues;
 
 	public QueryParameters() {
 		this( ArrayHelper.EMPTY_TYPE_ARRAY, ArrayHelper.EMPTY_OBJECT_ARRAY );
 	}
 
 	public QueryParameters(Type type, Object value) {
 		this( new Type[] { type }, new Object[] { value } );
 	}
 
 	public QueryParameters(
 			final Type[] positionalParameterTypes,
 			final Object[] postionalParameterValues,
 			final Object optionalObject,
 			final String optionalEntityName,
 			final Serializable optionalObjectId) {
 		this( positionalParameterTypes, postionalParameterValues );
 		this.optionalObject = optionalObject;
 		this.optionalId = optionalObjectId;
 		this.optionalEntityName = optionalEntityName;
 
 	}
 
 	public QueryParameters(
 			final Type[] positionalParameterTypes,
 			final Object[] postionalParameterValues) {
 		this( positionalParameterTypes, postionalParameterValues, null, null, false, false, false, null, null, false, null );
 	}
 
 	public QueryParameters(
 			final Type[] positionalParameterTypes,
 			final Object[] postionalParameterValues,
 			final Serializable[] collectionKeys) {
 		this( positionalParameterTypes, postionalParameterValues, null, collectionKeys );
 	}
 
 	public QueryParameters(
 			final Type[] positionalParameterTypes,
 			final Object[] postionalParameterValues,
 			final Map namedParameters,
 			final Serializable[] collectionKeys) {
 		this(
 				positionalParameterTypes,
 				postionalParameterValues,
 				namedParameters,
 				null,
 				null,
 				false,
 				false,
 				false,
 				null,
 				null,
 				collectionKeys,
 				null
 		);
 	}
 
 	public QueryParameters(
 			final Type[] positionalParameterTypes,
 			final Object[] positionalParameterValues,
 			final LockOptions lockOptions,
 			final RowSelection rowSelection,
 			final boolean isReadOnlyInitialized,
 			final boolean readOnly,
 			final boolean cacheable,
 			final String cacheRegion,
 			//final boolean forceCacheRefresh,
 			final String comment,
 			final boolean isLookupByNaturalKey,
 			final ResultTransformer transformer) {
 		this(
 				positionalParameterTypes,
 				positionalParameterValues,
 				null,
 				lockOptions,
 				rowSelection,
 				isReadOnlyInitialized,
 				readOnly,
 				cacheable,
 				cacheRegion,
 				comment,
 				null,
 				transformer
 		);
 		isNaturalKeyLookup = isLookupByNaturalKey;
 	}
 
 	public QueryParameters(
 			final Type[] positionalParameterTypes,
 			final Object[] positionalParameterValues,
 			final Map namedParameters,
 			final LockOptions lockOptions,
 			final RowSelection rowSelection,
 			final boolean isReadOnlyInitialized,
 			final boolean readOnly,
 			final boolean cacheable,
 			final String cacheRegion,
 			//final boolean forceCacheRefresh,
 			final String comment,
 			final Serializable[] collectionKeys,
 			ResultTransformer transformer) {
 		this.positionalParameterTypes = positionalParameterTypes;
 		this.positionalParameterValues = positionalParameterValues;
 		this.namedParameters = namedParameters;
 		this.lockOptions = lockOptions;
 		this.rowSelection = rowSelection;
 		this.cacheable = cacheable;
 		this.cacheRegion = cacheRegion;
 		//this.forceCacheRefresh = forceCacheRefresh;
 		this.comment = comment;
 		this.collectionKeys = collectionKeys;
 		this.isReadOnlyInitialized = isReadOnlyInitialized;
 		this.readOnly = readOnly;
 		this.resultTransformer = transformer;
 	}
 
 	public QueryParameters(
 			final Type[] positionalParameterTypes,
 			final Object[] positionalParameterValues,
 			final Map namedParameters,
 			final LockOptions lockOptions,
 			final RowSelection rowSelection,
 			final boolean isReadOnlyInitialized,
 			final boolean readOnly,
 			final boolean cacheable,
 			final String cacheRegion,
 			//final boolean forceCacheRefresh,
 			final String comment,
 			final Serializable[] collectionKeys,
 			final Object optionalObject,
 			final String optionalEntityName,
 			final Serializable optionalId,
 			final ResultTransformer transformer) {
 		this(
 				positionalParameterTypes,
 				positionalParameterValues,
 				namedParameters,
 				lockOptions,
 				rowSelection,
 				isReadOnlyInitialized,
 				readOnly,
 				cacheable,
 				cacheRegion,
 				comment,
 				collectionKeys,
 				transformer
 		);
 		this.optionalEntityName = optionalEntityName;
 		this.optionalId = optionalId;
 		this.optionalObject = optionalObject;
 	}
 
 	public boolean hasRowSelection() {
 		return rowSelection != null;
 	}
 
 	public Map getNamedParameters() {
 		return namedParameters;
 	}
 
 	public Type[] getPositionalParameterTypes() {
 		return positionalParameterTypes;
 	}
 
 	public Object[] getPositionalParameterValues() {
 		return positionalParameterValues;
 	}
 
 	public RowSelection getRowSelection() {
 		return rowSelection;
 	}
 
 	public ResultTransformer getResultTransformer() {
 		return resultTransformer;
 	}
 
 	public void setNamedParameters(Map map) {
 		namedParameters = map;
 	}
 
 	public void setPositionalParameterTypes(Type[] types) {
 		positionalParameterTypes = types;
 	}
 
 	public void setPositionalParameterValues(Object[] objects) {
 		positionalParameterValues = objects;
 	}
 
 	public void setRowSelection(RowSelection selection) {
 		rowSelection = selection;
 	}
 
 	public LockOptions getLockOptions() {
 		return lockOptions;
 	}
 
 	public void setLockOptions(LockOptions lockOptions) {
 		this.lockOptions = lockOptions;
 	}
 
 	public void traceParameters(SessionFactoryImplementor factory) throws HibernateException {
 		Printer print = new Printer( factory );
         if (positionalParameterValues.length != 0) LOG.trace("Parameters: "
                                                              + print.toString(positionalParameterTypes, positionalParameterValues));
         if (namedParameters != null) LOG.trace("Named parameters: " + print.toString(namedParameters));
 	}
 
 	public boolean isCacheable() {
 		return cacheable;
 	}
 
 	public void setCacheable(boolean b) {
 		cacheable = b;
 	}
 
 	public String getCacheRegion() {
 		return cacheRegion;
 	}
 
 	public void setCacheRegion(String cacheRegion) {
 		this.cacheRegion = cacheRegion;
 	}
 
 	public void validateParameters() throws QueryException {
 		int types = positionalParameterTypes == null ? 0 : positionalParameterTypes.length;
 		int values = positionalParameterValues == null ? 0 : positionalParameterValues.length;
 		if ( types != values ) {
 			throw new QueryException(
 					"Number of positional parameter types:" + types +
 							" does not match number of positional parameters: " + values
 			);
 		}
 	}
 
 	public String getComment() {
 		return comment;
 	}
 
 	public void setComment(String comment) {
 		this.comment = comment;
 	}
 
 	public ScrollMode getScrollMode() {
 		return scrollMode;
 	}
 
 	public void setScrollMode(ScrollMode scrollMode) {
 		this.scrollMode = scrollMode;
 	}
 
 	public Serializable[] getCollectionKeys() {
 		return collectionKeys;
 	}
 
 	public void setCollectionKeys(Serializable[] collectionKeys) {
 		this.collectionKeys = collectionKeys;
 	}
 
 	public String getOptionalEntityName() {
 		return optionalEntityName;
 	}
 
 	public void setOptionalEntityName(String optionalEntityName) {
 		this.optionalEntityName = optionalEntityName;
 	}
 
 	public Serializable getOptionalId() {
 		return optionalId;
 	}
 
 	public void setOptionalId(Serializable optionalId) {
 		this.optionalId = optionalId;
 	}
 
 	public Object getOptionalObject() {
 		return optionalObject;
 	}
 
 	public void setOptionalObject(Object optionalObject) {
 		this.optionalObject = optionalObject;
 	}
 
 	/**
 	 * Has the read-only/modifiable mode been explicitly set?
 	 * @see QueryParameters#setReadOnly(boolean)
 	 * @see QueryParameters#isReadOnly(org.hibernate.engine.spi.SessionImplementor)
 	 *
 	 * @return true, the read-only/modifiable mode was explicitly set
 	 *         false, the read-only/modifiable mode was not explicitly set
 	 */
 	public boolean isReadOnlyInitialized() {
 		return isReadOnlyInitialized;
 	}
 
 	/**
 	 * Should entities and proxies loaded by the Query be put in read-only mode? The
 	 * read-only/modifiable setting must be initialized via QueryParameters#setReadOnly(boolean)
 	 * before calling this method.
 	 *
 	 * @see QueryParameters#isReadOnlyInitialized()
 	 * @see QueryParameters#isReadOnly(org.hibernate.engine.spi.SessionImplementor)
 	 * @see QueryParameters#setReadOnly(boolean)
 	 *
 	 * The read-only/modifiable setting has no impact on entities/proxies returned by the
 	 * query that existed in the session before the query was executed.
 	 *
 	 * @return true, entities and proxies loaded by the Query will be put in read-only mode
 	 *         false, entities and proxies loaded by the Query will be put in modifiable mode
 	 * @throws IllegalStateException if the read-only/modifiable setting has not been
 	 * initialized (i.e., isReadOnlyInitialized() == false).
 	 */
 	public boolean isReadOnly() {
 		if ( ! isReadOnlyInitialized() ) {
 			throw new IllegalStateException( "cannot call isReadOnly() when isReadOnlyInitialized() returns false" );
 		}
 		return readOnly;
 	}
 
 	/**
 	 * Should entities and proxies loaded by the Query be put in read-only mode? If the
 	 * read-only/modifiable setting was not initialized
 	 * (i.e., QueryParameters#isReadOnlyInitialized() == false), then the default
 	 * read-only/modifiable setting for the persistence context is returned instead.
 	 *
 	 * @see QueryParameters#isReadOnlyInitialized()
 	 * @see QueryParameters#setReadOnly(boolean)
 	 * @see org.hibernate.engine.spi.PersistenceContext#isDefaultReadOnly()
 	 *
 	 * The read-only/modifiable setting has no impact on entities/proxies returned by the
 	 * query that existed in the session before the query was executed.
 	 *
 	 * @return true, entities and proxies loaded by the query will be put in read-only mode
 	 *         false, entities and proxies loaded by the query will be put in modifiable mode
 	 */
 	public boolean isReadOnly(SessionImplementor session) {
 		return ( isReadOnlyInitialized ?
 				isReadOnly() :
 				session.getPersistenceContext().isDefaultReadOnly()
 		);
 	}
 
 	/**
 	 * Set the read-only/modifiable mode for entities and proxies loaded by the query.
 	 * 	 *
 	 * @see QueryParameters#isReadOnlyInitialized()
 	 * @see QueryParameters#isReadOnly(org.hibernate.engine.spi.SessionImplementor)
 	 * @see QueryParameters#setReadOnly(boolean)
 	 * @see org.hibernate.engine.spi.PersistenceContext#isDefaultReadOnly()
 	 *
 	 * The read-only/modifiable setting has no impact on entities/proxies returned by the
 	 * query that existed in the session before the query was executed.
 	 *
 	 * @return true, entities and proxies loaded by the query will be put in read-only mode
 	 *         false, entities and proxies loaded by the query will be put in modifiable mode
 	 */
 	public void setReadOnly(boolean readOnly) {
 		this.readOnly = readOnly;
 		this.isReadOnlyInitialized = true;
 	}
 
 	public void setCallable(boolean callable) {
 		this.callable = callable;
 	}
 
 	public boolean isCallable() {
 		return callable;
 	}
 
 	public boolean hasAutoDiscoverScalarTypes() {
 		return autodiscovertypes;
 	}
 
 	public void processFilters(String sql, SessionImplementor session) {
 		processFilters( sql, session.getLoadQueryInfluencers().getEnabledFilters(), session.getFactory() );
 	}
 
 	public void processFilters(String sql, Map filters, SessionFactoryImplementor factory) {
 		if ( filters.size() == 0 || sql.indexOf( ParserHelper.HQL_VARIABLE_PREFIX ) < 0 ) {
 			// HELLA IMPORTANT OPTIMIZATION!!!
 			processedPositionalParameterValues = getPositionalParameterValues();
 			processedPositionalParameterTypes = getPositionalParameterTypes();
 			processedSQL = sql;
 		}
 		else {
 			final Dialect dialect = factory.getDialect();
 			String symbols = new StringBuffer().append( ParserHelper.HQL_SEPARATORS )
 					.append( dialect.openQuote() )
 					.append( dialect.closeQuote() )
 					.toString();
 			StringTokenizer tokens = new StringTokenizer( sql, symbols, true );
 			StringBuffer result = new StringBuffer();
 
 			List parameters = new ArrayList();
 			List parameterTypes = new ArrayList();
 
 			int positionalIndex = 0;
 			while ( tokens.hasMoreTokens() ) {
 				final String token = tokens.nextToken();
 				if ( token.startsWith( ParserHelper.HQL_VARIABLE_PREFIX ) ) {
 					final String filterParameterName = token.substring( 1 );
 					final String[] parts = LoadQueryInfluencers.parseFilterParameterName( filterParameterName );
 					final FilterImpl filter = ( FilterImpl ) filters.get( parts[0] );
 					final Object value = filter.getParameter( parts[1] );
 					final Type type = filter.getFilterDefinition().getParameterType( parts[1] );
 					if ( value != null && Collection.class.isAssignableFrom( value.getClass() ) ) {
 						Iterator itr = ( ( Collection ) value ).iterator();
 						while ( itr.hasNext() ) {
 							Object elementValue = itr.next();
 							result.append( '?' );
 							parameters.add( elementValue );
 							parameterTypes.add( type );
 							if ( itr.hasNext() ) {
 								result.append( ", " );
 							}
 						}
 					}
 					else {
 						result.append( '?' );
 						parameters.add( value );
 						parameterTypes.add( type );
 					}
 				}
 				else {
 					if ( "?".equals( token ) && positionalIndex < getPositionalParameterValues().length ) {
 						parameters.add( getPositionalParameterValues()[positionalIndex] );
 						parameterTypes.add( getPositionalParameterTypes()[positionalIndex] );
 						positionalIndex++;
 					}
 					result.append( token );
 				}
 			}
 			processedPositionalParameterValues = parameters.toArray();
 			processedPositionalParameterTypes = ( Type[] ) parameterTypes.toArray( new Type[parameterTypes.size()] );
 			processedSQL = result.toString();
 		}
 	}
 
 	public String getFilteredSQL() {
 		return processedSQL;
 	}
 
 	public Object[] getFilteredPositionalParameterValues() {
 		return processedPositionalParameterValues;
 	}
 
 	public Type[] getFilteredPositionalParameterTypes() {
 		return processedPositionalParameterTypes;
 	}
 
 	public boolean isNaturalKeyLookup() {
 		return isNaturalKeyLookup;
 	}
 
 	public void setNaturalKeyLookup(boolean isNaturalKeyLookup) {
 		this.isNaturalKeyLookup = isNaturalKeyLookup;
 	}
 
 	public void setAutoDiscoverScalarTypes(boolean autodiscovertypes) {
 		this.autodiscovertypes = autodiscovertypes;
 	}
 
 	public QueryParameters createCopyUsing(RowSelection selection) {
 		QueryParameters copy = new QueryParameters(
 				this.positionalParameterTypes,
 				this.positionalParameterValues,
 				this.namedParameters,
 				this.lockOptions,
 				selection,
 				this.isReadOnlyInitialized,
 				this.readOnly,
 				this.cacheable,
 				this.cacheRegion,
 				this.comment,
 				this.collectionKeys,
 				this.optionalObject,
 				this.optionalEntityName,
 				this.optionalId,
 				this.resultTransformer
 		);
 		copy.processedSQL = this.processedSQL;
 		copy.processedPositionalParameterTypes = this.processedPositionalParameterTypes;
 		copy.processedPositionalParameterValues = this.processedPositionalParameterValues;
 		return copy;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/CollectionProperties.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/CollectionProperties.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/CollectionProperties.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/CollectionProperties.java
index 5506e93078..b47fffcc43 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/CollectionProperties.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/CollectionProperties.java
@@ -1,74 +1,74 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql;
+package org.hibernate.hql.internal;
 import java.util.HashMap;
 import java.util.Map;
 import org.hibernate.persister.collection.CollectionPropertyNames;
 
 /**
  * Provides a map of collection function names to the corresponding property names.
  *
  * @author josh
  */
 public final class CollectionProperties {
 	public static final Map HQL_COLLECTION_PROPERTIES;
 
 	private static final String COLLECTION_INDEX_LOWER = CollectionPropertyNames.COLLECTION_INDEX.toLowerCase();
 
 	static {
 		HQL_COLLECTION_PROPERTIES = new HashMap();
 		HQL_COLLECTION_PROPERTIES.put( CollectionPropertyNames.COLLECTION_ELEMENTS.toLowerCase(), CollectionPropertyNames.COLLECTION_ELEMENTS );
 		HQL_COLLECTION_PROPERTIES.put( CollectionPropertyNames.COLLECTION_INDICES.toLowerCase(), CollectionPropertyNames.COLLECTION_INDICES );
 		HQL_COLLECTION_PROPERTIES.put( CollectionPropertyNames.COLLECTION_SIZE.toLowerCase(), CollectionPropertyNames.COLLECTION_SIZE );
 		HQL_COLLECTION_PROPERTIES.put( CollectionPropertyNames.COLLECTION_MAX_INDEX.toLowerCase(), CollectionPropertyNames.COLLECTION_MAX_INDEX );
 		HQL_COLLECTION_PROPERTIES.put( CollectionPropertyNames.COLLECTION_MIN_INDEX.toLowerCase(), CollectionPropertyNames.COLLECTION_MIN_INDEX );
 		HQL_COLLECTION_PROPERTIES.put( CollectionPropertyNames.COLLECTION_MAX_ELEMENT.toLowerCase(), CollectionPropertyNames.COLLECTION_MAX_ELEMENT );
 		HQL_COLLECTION_PROPERTIES.put( CollectionPropertyNames.COLLECTION_MIN_ELEMENT.toLowerCase(), CollectionPropertyNames.COLLECTION_MIN_ELEMENT );
 		HQL_COLLECTION_PROPERTIES.put( COLLECTION_INDEX_LOWER, CollectionPropertyNames.COLLECTION_INDEX );
 	}
 
 	private CollectionProperties() {
 	}
 
 	public static boolean isCollectionProperty(String name) {
 		String key = name.toLowerCase();
 		// CollectionPropertyMapping processes everything except 'index'.
 		if ( COLLECTION_INDEX_LOWER.equals( key ) ) {
 			return false;
 		}
 		else {
 			return HQL_COLLECTION_PROPERTIES.containsKey( key );
 		}
 	}
 
 	public static String getNormalizedPropertyName(String name) {
 		return ( String ) HQL_COLLECTION_PROPERTIES.get( name );
 	}
 
 	public static boolean isAnyCollectionProperty(String name) {
 		String key = name.toLowerCase();
 		return HQL_COLLECTION_PROPERTIES.containsKey( key );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/CollectionSubqueryFactory.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/CollectionSubqueryFactory.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/CollectionSubqueryFactory.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/CollectionSubqueryFactory.java
index f2646cd306..337d8d6c92 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/CollectionSubqueryFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/CollectionSubqueryFactory.java
@@ -1,66 +1,66 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql;
+package org.hibernate.hql.internal;
 
 import java.util.Map;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.engine.internal.JoinSequence;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.sql.JoinFragment;
 
 /**
  * Provides the SQL for collection subqueries.
  * <br>
  * Moved here from PathExpressionParser to make it re-useable.
  *
  * @author josh
  */
 public final class CollectionSubqueryFactory {
 
 	//TODO: refactor to .sql package
 
 	private CollectionSubqueryFactory() {
 	}
 
 	public static String createCollectionSubquery(
 			JoinSequence joinSequence,
 	        Map enabledFilters,
 	        String[] columns) {
 		try {
 			JoinFragment join = joinSequence.toJoinFragment( enabledFilters, true );
 			return new StringBuffer( "select " )
 					.append( StringHelper.join( ", ", columns ) )
 					.append( " from " )
 					.append( join.toFromFragmentString().substring( 2 ) )// remove initial ", "
 					.append( " where " )
 					.append( join.toWhereFragmentString().substring( 5 ) )// remove initial " and "
 					.toString();
 		}
 		catch ( MappingException me ) {
 			throw new QueryException( me );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/HolderInstantiator.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/HolderInstantiator.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/HolderInstantiator.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/HolderInstantiator.java
index ce65e3997a..06e419e454 100755
--- a/hibernate-core/src/main/java/org/hibernate/hql/HolderInstantiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/HolderInstantiator.java
@@ -1,106 +1,106 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql;
+package org.hibernate.hql.internal;
 import java.lang.reflect.Constructor;
 import org.hibernate.transform.AliasToBeanConstructorResultTransformer;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.transform.Transformers;
 
 /**
  * @author Gavin King
  */
 public final class HolderInstantiator {
 		
 	public static final HolderInstantiator NOOP_INSTANTIATOR = new HolderInstantiator(null,null);
 	
 	private final ResultTransformer transformer;
 	private final String[] queryReturnAliases;
 	
 	public static HolderInstantiator getHolderInstantiator(ResultTransformer selectNewTransformer, ResultTransformer customTransformer, String[] queryReturnAliases) {
 		return new HolderInstantiator(
 				resolveResultTransformer( selectNewTransformer, customTransformer ),
 				queryReturnAliases
 		);
 	}
 
 	public static ResultTransformer resolveResultTransformer(ResultTransformer selectNewTransformer, ResultTransformer customTransformer) {
 		return selectNewTransformer != null ? selectNewTransformer : customTransformer;
 	}	
 
 	public static ResultTransformer createSelectNewTransformer(Constructor constructor, boolean returnMaps, boolean returnLists) {
 		if ( constructor != null ) {
 			return new AliasToBeanConstructorResultTransformer(constructor);
 		}
 		else if ( returnMaps ) {
 			return Transformers.ALIAS_TO_ENTITY_MAP;			
 		}
 		else if ( returnLists ) {
 			return Transformers.TO_LIST;
 		}		
 		else {
 			return null;
 		}
 	}
 	
 	static public HolderInstantiator createClassicHolderInstantiator(Constructor constructor, 
 			ResultTransformer transformer) {
 		return new HolderInstantiator( resolveClassicResultTransformer( constructor, transformer ), null );
 	}
 
 	static public ResultTransformer resolveClassicResultTransformer(
 			Constructor constructor,
 			ResultTransformer transformer) {
 		return constructor != null ? new AliasToBeanConstructorResultTransformer( constructor ) : transformer;
 	}	
 
 	public HolderInstantiator( 
 			ResultTransformer transformer,
 			String[] queryReturnAliases
 	) {
 		this.transformer = transformer;		
 		this.queryReturnAliases = queryReturnAliases;
 	}
 	
 	public boolean isRequired() {
 		return transformer!=null;
 	}
 	
 	public Object instantiate(Object[] row) {
 		if(transformer==null) {
 			return row;
 		} else {
 			return transformer.transformTuple(row, queryReturnAliases);
 		}
 	}	
 	
 	public String[] getQueryReturnAliases() {
 		return queryReturnAliases;
 	}
 
 	public ResultTransformer getResultTransformer() {
 		return transformer;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/NameGenerator.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/NameGenerator.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/NameGenerator.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/NameGenerator.java
index 78bd153bb9..532ea2caa2 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/NameGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/NameGenerator.java
@@ -1,63 +1,63 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql;
+package org.hibernate.hql.internal;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.type.Type;
 
 /**
  * Provides utility methods for generating HQL / SQL names.   Shared by both the 'classic' and 'new' query translators.
  *
  * @author josh
  */
 public final class NameGenerator {
 	/**
 	 * Private empty constructor (checkstyle says utility classes should not have default constructors).
 	 */
 	private NameGenerator() {
 	}
 
 	public static String[][] generateColumnNames(Type[] types, SessionFactoryImplementor f) throws MappingException {
 		String[][] columnNames = new String[types.length][];
 		for ( int i = 0; i < types.length; i++ ) {
 			int span = types[i].getColumnSpan( f );
 			columnNames[i] = new String[span];
 			for ( int j = 0; j < span; j++ ) {
 				columnNames[i][j] = NameGenerator.scalarName( i, j );
 			}
 		}
 		return columnNames;
 	}
 
 	public static String scalarName(int x, int y) {
 		return new StringBuffer()
 				.append( "col_" )
 				.append( x )
 				.append( '_' )
 				.append( y )
 				.append( '_' )
 				.toString();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/QueryExecutionRequestException.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/QueryExecutionRequestException.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/hql/QueryExecutionRequestException.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/QueryExecutionRequestException.java
index dc7503b544..f29a1650f5 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/QueryExecutionRequestException.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/QueryExecutionRequestException.java
@@ -1,38 +1,38 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.hql;
-import org.hibernate.QueryException;
-
-/**
- * Expecting to execute an illegal operation regarding the query type
- *
- * @author Emmanuel Bernard
- */
-public class QueryExecutionRequestException extends QueryException {
-
-	public QueryExecutionRequestException(String message, String queryString) {
-		super( message, queryString );
-	}
-}
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Middleware LLC.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ *
+ */
+package org.hibernate.hql.internal;
+import org.hibernate.QueryException;
+
+/**
+ * Expecting to execute an illegal operation regarding the query type
+ *
+ * @author Emmanuel Bernard
+ */
+public class QueryExecutionRequestException extends QueryException {
+
+	public QueryExecutionRequestException(String message, String queryString) {
+		super( message, queryString );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/QuerySplitter.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/QuerySplitter.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/QuerySplitter.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/QuerySplitter.java
index ad46f43bed..fa35676060 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/QuerySplitter.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/QuerySplitter.java
@@ -1,157 +1,157 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql;
+package org.hibernate.hql.internal;
 
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Set;
 
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.MappingException;
-import org.hibernate.hql.classic.ParserHelper;
+import org.hibernate.hql.internal.classic.ParserHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.jboss.logging.Logger;
 
 /**
  * Provides query splitting methods, which were originally in QueryTranslator.
  * <br>
  * TODO: This will need to be refactored at some point.
  *
  * @author josh
  */
 public final class QuerySplitter {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, QuerySplitter.class.getName());
 
 	private static final Set BEFORE_CLASS_TOKENS = new HashSet();
 	private static final Set NOT_AFTER_CLASS_TOKENS = new HashSet();
 
 	static {
 		BEFORE_CLASS_TOKENS.add( "from" );
 		BEFORE_CLASS_TOKENS.add( "delete" );
 		BEFORE_CLASS_TOKENS.add( "update" );
 		//beforeClassTokens.add("new"); DEFINITELY DON'T HAVE THIS!!
 		BEFORE_CLASS_TOKENS.add( "," );
 		NOT_AFTER_CLASS_TOKENS.add( "in" );
 		//notAfterClassTokens.add(",");
 		NOT_AFTER_CLASS_TOKENS.add( "from" );
 		NOT_AFTER_CLASS_TOKENS.add( ")" );
 	}
 
 	/**
 	 * Private empty constructor.
 	 * (or else checkstyle says: 'warning: Utility classes should not have a public or default constructor.')
 	 */
 	private QuerySplitter() {
 	}
 
 	/**
 	 * Handle Hibernate "implicit" polymorphism, by translating the query string into
 	 * several "concrete" queries against mapped classes.
 	 */
 	public static String[] concreteQueries(String query, SessionFactoryImplementor factory) throws MappingException {
 
 		//scan the query string for class names appearing in the from clause and replace
 		//with all persistent implementors of the class/interface, returning multiple
 		//query strings (make sure we don't pick up a class in the select clause!)
 
 		//TODO: this is one of the ugliest and most fragile pieces of code in Hibernate....
 
 		String[] tokens = StringHelper.split( StringHelper.WHITESPACE + "(),", query, true );
 		if ( tokens.length == 0 ) return new String[]{query}; // just especially for the trivial collection filter
 		ArrayList placeholders = new ArrayList();
 		ArrayList replacements = new ArrayList();
 		StringBuffer templateQuery = new StringBuffer( 40 );
 		int count = 0;
 		String last = null;
 		int nextIndex = 0;
 		String next = null;
 		boolean isSelectClause = false;
 
 		templateQuery.append( tokens[0] );
 		if ( "select".equals( tokens[0].toLowerCase() ) ) isSelectClause = true;
 
 		for ( int i = 1; i < tokens.length; i++ ) {
 
 			//update last non-whitespace token, if necessary
 			if ( !ParserHelper.isWhitespace( tokens[i - 1] ) ) last = tokens[i - 1].toLowerCase();
 
 			// select-range is terminated by declaration of "from"
 			if ( "from".equals( tokens[i].toLowerCase() ) ) isSelectClause = false;
 
 			String token = tokens[i];
 			if ( !ParserHelper.isWhitespace( token ) || last == null ) {
 
 				//scan for next non-whitespace token
 				if ( nextIndex <= i ) {
 					for ( nextIndex = i + 1; nextIndex < tokens.length; nextIndex++ ) {
 						next = tokens[nextIndex].toLowerCase();
 						if ( !ParserHelper.isWhitespace( next ) ) break;
 					}
 				}
 
 				boolean process = !isSelectClause &&
 						isJavaIdentifier( token ) &&
 						isPossiblyClassName( last, next );
 
 				if (process) {
 					String importedClassName = getImportedClass( token, factory );
 					if ( importedClassName != null ) {
 						String[] implementors = factory.getImplementors( importedClassName );
 						String placeholder = "$clazz" + count++ + "$";
 						if ( implementors != null ) {
 							placeholders.add( placeholder );
 							replacements.add( implementors );
 						}
 						token = placeholder; // Note this!!
 					}
 				}
 
 			}
 
 			templateQuery.append( token );
 
 		}
 		String[] results = StringHelper.multiply( templateQuery.toString(), placeholders.iterator(), replacements.iterator() );
         if (results.length == 0) LOG.noPersistentClassesFound(query);
 		return results;
 	}
 
 	private static boolean isPossiblyClassName(String last, String next) {
 		return "class".equals( last ) || (
 				BEFORE_CLASS_TOKENS.contains( last ) &&
 				!NOT_AFTER_CLASS_TOKENS.contains( next )
 			);
 	}
 
 	private static boolean isJavaIdentifier(String token) {
 		return Character.isJavaIdentifierStart( token.charAt( 0 ) );
 	}
 
 	public static String getImportedClass(String name, SessionFactoryImplementor factory) {
 		return factory.getImportedClassName( name );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/antlr/package.html b/hibernate-core/src/main/java/org/hibernate/hql/internal/antlr/package.html
similarity index 100%
rename from hibernate-core/src/main/java/org/hibernate/hql/antlr/package.html
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/antlr/package.html
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/ASTQueryTranslatorFactory.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ASTQueryTranslatorFactory.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/ASTQueryTranslatorFactory.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ASTQueryTranslatorFactory.java
index dc7ac0a031..de111472a8 100755
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/ASTQueryTranslatorFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ASTQueryTranslatorFactory.java
@@ -1,72 +1,72 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 import java.util.Map;
 
 import org.hibernate.engine.spi.SessionFactoryImplementor;
+import org.hibernate.hql.spi.QueryTranslator;
+import org.hibernate.hql.spi.QueryTranslatorFactory;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.hql.FilterTranslator;
-import org.hibernate.hql.QueryTranslator;
-import org.hibernate.hql.QueryTranslatorFactory;
+import org.hibernate.hql.spi.FilterTranslator;
 
 import org.jboss.logging.Logger;
 
 /**
  * Generates translators which uses the Antlr-based parser to perform
  * the translation.
  *
  * @author Gavin King
  */
 public class ASTQueryTranslatorFactory implements QueryTranslatorFactory {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        ASTQueryTranslatorFactory.class.getName());
 
 	public ASTQueryTranslatorFactory() {
         LOG.usingAstQueryTranslatorFactory();
 	}
 
 	/**
-	 * @see QueryTranslatorFactory#createQueryTranslator
+	 * @see org.hibernate.hql.spi.QueryTranslatorFactory#createQueryTranslator
 	 */
 	public QueryTranslator createQueryTranslator(
 			String queryIdentifier,
 	        String queryString,
 	        Map filters,
 	        SessionFactoryImplementor factory) {
 		return new QueryTranslatorImpl( queryIdentifier, queryString, filters, factory );
 	}
 
 	/**
 	 * @see QueryTranslatorFactory#createFilterTranslator
 	 */
 	public FilterTranslator createFilterTranslator(
 			String queryIdentifier,
 	        String queryString,
 	        Map filters,
 	        SessionFactoryImplementor factory) {
 		return new QueryTranslatorImpl( queryIdentifier, queryString, filters, factory );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/DetailedSemanticException.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/DetailedSemanticException.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/DetailedSemanticException.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/DetailedSemanticException.java
index 9362fe0a1b..ab6e89f261 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/DetailedSemanticException.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/DetailedSemanticException.java
@@ -1,98 +1,98 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 import java.io.PrintStream;
 import java.io.PrintWriter;
 import antlr.SemanticException;
 
 /**
  * Thrown when a call to the underlying Hibernate engine fails, indicating
  * some form of semantic exception (e.g. a class name was not found in the
  * current mappings, etc.).
  */
 public class DetailedSemanticException extends SemanticException {
 	private Throwable cause;
 	private boolean showCauseMessage = true;
 
 	public DetailedSemanticException(String message) {
 		super( message );
 	}
 
 	public DetailedSemanticException(String s, Throwable e) {
 		super( s );
 		cause = e;
 	}
 
 	/**
 	 * Converts everything to a string.
 	 *
 	 * @return a string.
 	 */
 	public String toString() {
 		if ( cause == null || ( !showCauseMessage ) ) {
 			return super.toString();
 		}
 		else {
 			return super.toString() + "\n[cause=" + cause.toString() + "]";
 		}
 	}
 
 	/**
 	 * Prints a stack trace.
 	 */
 	public void printStackTrace() {
 		super.printStackTrace();
 		if ( cause != null ) {
 			cause.printStackTrace();
 		}
 	}
 
 	/**
 	 * Prints a stack trace to the specified print stream.
 	 *
 	 * @param s the print stream.
 	 */
 	public void printStackTrace(PrintStream s) {
 		super.printStackTrace( s );
 		if ( cause != null ) {
 			s.println( "Cause:" );
 			cause.printStackTrace( s );
 		}
 	}
 
 	/**
 	 * Prints this throwable and its backtrace to the specified print writer.
 	 *
 	 * @param w the print writer.s
 	 */
 	public void printStackTrace(PrintWriter w) {
 		super.printStackTrace( w );
 		if ( cause != null ) {
 			w.println( "Cause:" );
 			cause.printStackTrace( w );
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/ErrorCounter.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ErrorCounter.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/ErrorCounter.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ErrorCounter.java
index fd4ac0b3f4..fb880f8647 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/ErrorCounter.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ErrorCounter.java
@@ -1,84 +1,84 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.QueryException;
 
 import org.jboss.logging.Logger;
 import antlr.RecognitionException;
 
 /**
  * An error handler that counts parsing errors and warnings.
  */
 public class ErrorCounter implements ParseErrorHandler {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, ErrorCounter.class.getName());
 
 	private List errorList = new ArrayList();
 	private List warningList = new ArrayList();
 	private List recognitionExceptions = new ArrayList();
 
 	public void reportError(RecognitionException e) {
 		reportError( e.toString() );
 		recognitionExceptions.add( e );
         LOG.error(e.toString(), e);
 	}
 
 	public void reportError(String message) {
         LOG.error(message);
 		errorList.add( message );
 	}
 
 	public int getErrorCount() {
 		return errorList.size();
 	}
 
 	public void reportWarning(String message) {
         LOG.debugf(message);
 		warningList.add( message );
 	}
 
 	private String getErrorString() {
 		StringBuffer buf = new StringBuffer();
 		for ( Iterator iterator = errorList.iterator(); iterator.hasNext(); ) {
 			buf.append( ( String ) iterator.next() );
 			if ( iterator.hasNext() ) buf.append( "\n" );
 
 		}
 		return buf.toString();
 	}
 
 	public void throwQueryException() throws QueryException {
 		if ( getErrorCount() > 0 ) {
             if (recognitionExceptions.size() > 0) throw QuerySyntaxException.convert((RecognitionException)recognitionExceptions.get(0));
             throw new QueryException(getErrorString());
         }
         LOG.debugf("throwQueryException() : no errors");
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/ErrorReporter.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ErrorReporter.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/ErrorReporter.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ErrorReporter.java
index 31a898f380..6856c217ba 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/ErrorReporter.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ErrorReporter.java
@@ -1,39 +1,39 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 import antlr.RecognitionException;
 
 /**
  * Implementations will report or handle errors invoked by an ANTLR base parser.
  *
  * @author josh
  */
 public interface ErrorReporter {
 	void reportError(RecognitionException e);
 
 	void reportError(String s);
 
 	void reportWarning(String s);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/HqlASTFactory.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlASTFactory.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/HqlASTFactory.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlASTFactory.java
index 59ba88fa73..55d78d2b4a 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/HqlASTFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlASTFactory.java
@@ -1,45 +1,45 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
-import org.hibernate.hql.ast.tree.Node;
+package org.hibernate.hql.internal.ast;
+import org.hibernate.hql.internal.ast.tree.Node;
 import antlr.ASTFactory;
 
 /**
  * User: Joshua Davis<br>
  * Date: Sep 23, 2005<br>
  * Time: 12:30:01 PM<br>
  */
 public class HqlASTFactory extends ASTFactory {
 
 	/**
 	 * Returns the class for a given token type (a.k.a. AST node type).
 	 *
 	 * @param tokenType The token type.
 	 * @return Class - The AST node class to instantiate.
 	 */
 	public Class getASTNodeType(int tokenType) {
 		return Node.class;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/HqlLexer.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlLexer.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/HqlLexer.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlLexer.java
index d5d932a0b8..fb7bb0c3c2 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/HqlLexer.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlLexer.java
@@ -1,80 +1,80 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 import java.io.InputStream;
 import java.io.Reader;
 import org.hibernate.QueryException;
-import org.hibernate.hql.antlr.HqlBaseLexer;
+import org.hibernate.hql.internal.antlr.HqlBaseLexer;
 import antlr.Token;
 
 /**
  * Custom lexer for the HQL grammar.  Extends the base lexer generated by ANTLR
  * in order to keep the grammar source file clean.
  */
 class HqlLexer extends HqlBaseLexer {
 	/**
 	 * A logger for this class. *
 	 */
 	private boolean possibleID = false;
 
 	public HqlLexer(InputStream in) {
 		super( in );
 	}
 
     public HqlLexer(Reader in) {
         super(in);
     }
 
 	public void setTokenObjectClass(String cl) {
 		// Ignore the token class name parameter, and use a specific token class.
 		super.setTokenObjectClass( HqlToken.class.getName() );
 	}
 
 	protected void setPossibleID(boolean possibleID) {
 		this.possibleID = possibleID;
 	}
 
 	protected Token makeToken(int i) {
 		HqlToken token = ( HqlToken ) super.makeToken( i );
 		token.setPossibleID( possibleID );
 		possibleID = false;
 		return token;
 	}
 
 	public int testLiteralsTable(int i) {
 		int ttype = super.testLiteralsTable( i );
 		return ttype;
 	}
 
 	public void panic() {
 		//overriden to avoid System.exit
 		panic("CharScanner: panic");
 	}
 
 	public void panic(String s) {
 		//overriden to avoid System.exit
 		throw new QueryException(s);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/HqlParser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlParser.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/HqlParser.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlParser.java
index d338027218..ff3e8e7525 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/HqlParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlParser.java
@@ -1,385 +1,385 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 
 import java.io.PrintStream;
 import java.io.PrintWriter;
 import java.io.StringReader;
 
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.QueryException;
-import org.hibernate.hql.antlr.HqlBaseParser;
-import org.hibernate.hql.antlr.HqlTokenTypes;
-import org.hibernate.hql.ast.util.ASTPrinter;
-import org.hibernate.hql.ast.util.ASTUtil;
+import org.hibernate.hql.internal.antlr.HqlBaseParser;
+import org.hibernate.hql.internal.antlr.HqlTokenTypes;
+import org.hibernate.hql.internal.ast.util.ASTPrinter;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
 import org.hibernate.internal.util.StringHelper;
 
 import org.jboss.logging.Logger;
 import antlr.ASTPair;
 import antlr.MismatchedTokenException;
 import antlr.RecognitionException;
 import antlr.Token;
 import antlr.TokenStream;
 import antlr.TokenStreamException;
 import antlr.collections.AST;
 
 /**
  * Implements the semantic action methods defined in the HQL base parser to keep the grammar
  * source file a little cleaner.  Extends the parser class generated by ANTLR.
  *
  * @author Joshua Davis (pgmjsd@sourceforge.net)
  */
 public final class HqlParser extends HqlBaseParser {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, HqlParser.class.getName());
 
 	private ParseErrorHandler parseErrorHandler;
 	private ASTPrinter printer = getASTPrinter();
 
 	private static ASTPrinter getASTPrinter() {
-		return new ASTPrinter( org.hibernate.hql.antlr.HqlTokenTypes.class );
+		return new ASTPrinter( org.hibernate.hql.internal.antlr.HqlTokenTypes.class );
 	}
 
 	public static HqlParser getInstance(String hql) {
         // [jsd] The fix for HHH-558...
         HqlLexer lexer = new HqlLexer( new StringReader( hql ) );
 		return new HqlParser( lexer );
 	}
 
 	private HqlParser(TokenStream lexer) {
 		super( lexer );
 		initialize();
 	}
 
 
 	// handle trace logging ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	private int traceDepth = 0;
 
 	@Override
     public void traceIn(String ruleName) {
         if (!LOG.isTraceEnabled()) return;
         if (inputState.guessing > 0) return;
 		String prefix = StringHelper.repeat( '-', (traceDepth++ * 2) ) + "-> ";
         LOG.trace(prefix + ruleName);
 	}
 
 	@Override
     public void traceOut(String ruleName) {
         if (!LOG.isTraceEnabled()) return;
         if (inputState.guessing > 0) return;
 		String prefix = "<-" + StringHelper.repeat( '-', (--traceDepth * 2) ) + " ";
         LOG.trace(prefix + ruleName);
 	}
 
 	@Override
     public void reportError(RecognitionException e) {
 		parseErrorHandler.reportError( e ); // Use the delegate.
 	}
 
 	@Override
     public void reportError(String s) {
 		parseErrorHandler.reportError( s ); // Use the delegate.
 	}
 
 	@Override
     public void reportWarning(String s) {
 		parseErrorHandler.reportWarning( s );
 	}
 
 	public ParseErrorHandler getParseErrorHandler() {
 		return parseErrorHandler;
 	}
 
 	/**
 	 * Overrides the base behavior to retry keywords as identifiers.
 	 *
 	 * @param token The token.
 	 * @param ex    The recognition exception.
 	 * @return AST - The new AST.
 	 * @throws antlr.RecognitionException if the substitution was not possible.
 	 * @throws antlr.TokenStreamException if the substitution was not possible.
 	 */
 	@Override
     public AST handleIdentifierError(Token token, RecognitionException ex) throws RecognitionException, TokenStreamException {
 		// If the token can tell us if it could be an identifier...
 		if ( token instanceof HqlToken ) {
 			HqlToken hqlToken = ( HqlToken ) token;
 			// ... and the token could be an identifer and the error is
 			// a mismatched token error ...
 			if ( hqlToken.isPossibleID() && ( ex instanceof MismatchedTokenException ) ) {
 				MismatchedTokenException mte = ( MismatchedTokenException ) ex;
 				// ... and the expected token type was an identifier, then:
 				if ( mte.expecting == HqlTokenTypes.IDENT ) {
 					// Use the token as an identifier.
 					reportWarning( "Keyword  '"
 							+ token.getText()
 							+ "' is being interpreted as an identifier due to: " + mte.getMessage() );
 					// Add the token to the AST.
 					ASTPair currentAST = new ASTPair();
 					token.setType( HqlTokenTypes.WEIRD_IDENT );
 					astFactory.addASTChild( currentAST, astFactory.create( token ) );
 					consume();
 					AST identifierAST = currentAST.root;
 					return identifierAST;
 				}
 			} // if
 		} // if
 		// Otherwise, handle the error normally.
 		return super.handleIdentifierError( token, ex );
 	}
 
 	/**
 	 * Returns an equivalent tree for (NOT (a relop b) ), for example:<pre>
 	 * (NOT (GT a b) ) => (LE a b)
 	 * </pre>
 	 *
 	 * @param x The sub tree to transform, the parent is assumed to be NOT.
 	 * @return AST - The equivalent sub-tree.
 	 */
 	@Override
     public AST negateNode(AST x) {
 		//TODO: switch statements are always evil! We already had bugs because
 		//      of forgotten token types. Use polymorphism for this!
 		switch ( x.getType() ) {
 			case OR:
 				x.setType(AND);
 				x.setText("{and}");
 				negateNode( x.getFirstChild() );
 				negateNode( x.getFirstChild().getNextSibling() );
 				return x;
 			case AND:
 				x.setType(OR);
 				x.setText("{or}");
 				negateNode( x.getFirstChild() );
 				negateNode( x.getFirstChild().getNextSibling() );
 				return x;
 			case EQ:
 				x.setType( NE );
 				x.setText( "{not}" + x.getText() );
 				return x;	// (NOT (EQ a b) ) => (NE a b)
 			case NE:
 				x.setType( EQ );
 				x.setText( "{not}" + x.getText() );
 				return x;	// (NOT (NE a b) ) => (EQ a b)
 			case GT:
 				x.setType( LE );
 				x.setText( "{not}" + x.getText() );
 				return x;	// (NOT (GT a b) ) => (LE a b)
 			case LT:
 				x.setType( GE );
 				x.setText( "{not}" + x.getText() );
 				return x;	// (NOT (LT a b) ) => (GE a b)
 			case GE:
 				x.setType( LT );
 				x.setText( "{not}" + x.getText() );
 				return x;	// (NOT (GE a b) ) => (LT a b)
 			case LE:
 				x.setType( GT );
 				x.setText( "{not}" + x.getText() );
 				return x;	// (NOT (LE a b) ) => (GT a b)
 			case LIKE:
 				x.setType( NOT_LIKE );
 				x.setText( "{not}" + x.getText() );
 				return x;	// (NOT (LIKE a b) ) => (NOT_LIKE a b)
 			case NOT_LIKE:
 				x.setType( LIKE );
 				x.setText( "{not}" + x.getText() );
 				return x;	// (NOT (NOT_LIKE a b) ) => (LIKE a b)
 			case IN:
 				x.setType( NOT_IN );
 				x.setText( "{not}" + x.getText() );
 				return x;
 			case NOT_IN:
 				x.setType( IN );
 				x.setText( "{not}" + x.getText() );
 				return x;
 			case IS_NULL:
 				x.setType( IS_NOT_NULL );
 				x.setText( "{not}" + x.getText() );
 				return x;	// (NOT (IS_NULL a b) ) => (IS_NOT_NULL a b)
 			case IS_NOT_NULL:
 				x.setType( IS_NULL );
 				x.setText( "{not}" + x.getText() );
 				return x;	// (NOT (IS_NOT_NULL a b) ) => (IS_NULL a b)
 			case BETWEEN:
 				x.setType( NOT_BETWEEN );
 				x.setText( "{not}" + x.getText() );
 				return x;	// (NOT (BETWEEN a b) ) => (NOT_BETWEEN a b)
 			case NOT_BETWEEN:
 				x.setType( BETWEEN );
 				x.setText( "{not}" + x.getText() );
 				return x;	// (NOT (NOT_BETWEEN a b) ) => (BETWEEN a b)
 /* This can never happen because this rule will always eliminate the child NOT.
 			case NOT:
 				return x.getFirstChild();			// (NOT (NOT x) ) => (x)
 */
 			default:
 				return super.negateNode( x );		// Just add a 'not' parent.
 		}
 	}
 
 	/**
 	 * Post process equality expressions, clean up the subtree.
 	 *
 	 * @param x The equality expression.
 	 * @return AST - The clean sub-tree.
 	 */
 	@Override
     public AST processEqualityExpression(AST x) {
 		if ( x == null ) {
             LOG.processEqualityExpression();
 			return null;
 		}
 
 		int type = x.getType();
 		if ( type == EQ || type == NE ) {
 			boolean negated = type == NE;
 			if ( x.getNumberOfChildren() == 2 ) {
 				AST a = x.getFirstChild();
 				AST b = a.getNextSibling();
 				// (EQ NULL b) => (IS_NULL b)
 				if ( a.getType() == NULL && b.getType() != NULL ) {
 					return createIsNullParent( b, negated );
 				}
 				// (EQ a NULL) => (IS_NULL a)
 				else if ( b.getType() == NULL && a.getType() != NULL ) {
 					return createIsNullParent( a, negated );
 				}
 				else if ( b.getType() == EMPTY ) {
 					return processIsEmpty( a, negated );
 				}
 				else {
 					return x;
 				}
 			}
 			else {
 				return x;
 			}
 		}
 		else {
 			return x;
 		}
 	}
 
 	private AST createIsNullParent(AST node, boolean negated) {
 		node.setNextSibling( null );
 		int type = negated ? IS_NOT_NULL : IS_NULL;
 		String text = negated ? "is not null" : "is null";
 		return ASTUtil.createParent( astFactory, type, text, node );
 	}
 
 	private AST processIsEmpty(AST node, boolean negated) {
 		node.setNextSibling( null );
 		// NOTE: Because we're using ASTUtil.createParent(), the tree must be created from the bottom up.
 		// IS EMPTY x => (EXISTS (QUERY (SELECT_FROM (FROM x) ) ) )
 		AST ast = createSubquery( node );
 		ast = ASTUtil.createParent( astFactory, EXISTS, "exists", ast );
 		// Add NOT if it's negated.
 		if ( !negated ) {
 			ast = ASTUtil.createParent( astFactory, NOT, "not", ast );
 		}
 		return ast;
 	}
 
 	private AST createSubquery(AST node) {
 		AST ast = ASTUtil.createParent( astFactory, RANGE, "RANGE", node );
 		ast = ASTUtil.createParent( astFactory, FROM, "from", ast );
 		ast = ASTUtil.createParent( astFactory, SELECT_FROM, "SELECT_FROM", ast );
 		ast = ASTUtil.createParent( astFactory, QUERY, "QUERY", ast );
 		return ast;
 	}
 
 	public void showAst(AST ast, PrintStream out) {
 		showAst( ast, new PrintWriter( out ) );
 	}
 
 	private void showAst(AST ast, PrintWriter pw) {
 		printer.showAst( ast, pw );
 	}
 
 	private void initialize() {
 		// Initialize the error handling delegate.
 		parseErrorHandler = new ErrorCounter();
 		setASTFactory(new HqlASTFactory());	// Create nodes that track line and column number.
 	}
 
 	@Override
     public void weakKeywords() throws TokenStreamException {
 
 		int t = LA( 1 );
 		switch ( t ) {
 			case ORDER:
 			case GROUP:
                 // Case 1: Multi token keywords GROUP BY and ORDER BY
 				// The next token ( LT(2) ) should be 'by'... otherwise, this is just an ident.
 				if ( LA( 2 ) != LITERAL_by ) {
 					LT( 1 ).setType( IDENT );
                     LOG.debugf("weakKeywords() : new LT(1) token - %s", LT(1));
 				}
 				break;
 			default:
                 // Case 2: The current token is after FROM and before '.'.
                 if (LA(0) == FROM && t != IDENT && LA(2) == DOT) {
                     HqlToken hqlToken = (HqlToken)LT(1);
                     if (hqlToken.isPossibleID()) {
                         hqlToken.setType(IDENT);
                         LOG.debugf("weakKeywords() : new LT(1) token - %s", LT(1));
                     }
                 }
 				break;
 		}
 	}
 
     @Override
     public void handleDotIdent() throws TokenStreamException {
         // This handles HHH-354, where there is a strange property name in a where clause.
         // If the lookahead contains a DOT then something that isn't an IDENT...
         if (LA(1) == DOT && LA(2) != IDENT) {
             // See if the second lookahead token can be an identifier.
             HqlToken t = (HqlToken)LT(2);
             if (t.isPossibleID())
             {
                 // Set it!
                 LT( 2 ).setType( IDENT );
                 LOG.debugf("handleDotIdent() : new LT(2) token - %s", LT(1));
             }
         }
     }
 
 	@Override
     public void processMemberOf(Token n, AST p, ASTPair currentAST) {
 		AST inAst = n == null ? astFactory.create( IN, "in" ) : astFactory.create( NOT_IN, "not in" );
 		astFactory.makeASTRoot( currentAST, inAst );
 		AST ast = createSubquery( p );
 		ast = ASTUtil.createParent( astFactory, IN_LIST, "inList", ast );
 		inAst.addChild( ast );
 	}
 
 	static public void panic() {
 		//overriden to avoid System.exit
 		throw new QueryException("Parser: panic");
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/HqlSqlWalker.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlSqlWalker.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/HqlSqlWalker.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlSqlWalker.java
index 7fff90f719..31a07adeb7 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/HqlSqlWalker.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlSqlWalker.java
@@ -1,1081 +1,1081 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
+import org.hibernate.hql.spi.QueryTranslator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.QueryException;
 import org.hibernate.engine.internal.JoinSequence;
 import org.hibernate.engine.internal.ParameterBinder;
-import org.hibernate.hql.QueryTranslator;
-import org.hibernate.hql.antlr.HqlSqlBaseWalker;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.antlr.HqlTokenTypes;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.tree.AggregateNode;
-import org.hibernate.hql.ast.tree.AssignmentSpecification;
-import org.hibernate.hql.ast.tree.CollectionFunction;
-import org.hibernate.hql.ast.tree.ConstructorNode;
-import org.hibernate.hql.ast.tree.DeleteStatement;
-import org.hibernate.hql.ast.tree.DotNode;
-import org.hibernate.hql.ast.tree.FromClause;
-import org.hibernate.hql.ast.tree.FromElement;
-import org.hibernate.hql.ast.tree.FromElementFactory;
-import org.hibernate.hql.ast.tree.FromReferenceNode;
-import org.hibernate.hql.ast.tree.IdentNode;
-import org.hibernate.hql.ast.tree.IndexNode;
-import org.hibernate.hql.ast.tree.InsertStatement;
-import org.hibernate.hql.ast.tree.IntoClause;
-import org.hibernate.hql.ast.tree.MethodNode;
-import org.hibernate.hql.ast.tree.OperatorNode;
-import org.hibernate.hql.ast.tree.ParameterContainer;
-import org.hibernate.hql.ast.tree.ParameterNode;
-import org.hibernate.hql.ast.tree.QueryNode;
-import org.hibernate.hql.ast.tree.ResolvableNode;
-import org.hibernate.hql.ast.tree.RestrictableStatement;
-import org.hibernate.hql.ast.tree.ResultVariableRefNode;
-import org.hibernate.hql.ast.tree.SelectClause;
-import org.hibernate.hql.ast.tree.SelectExpression;
-import org.hibernate.hql.ast.tree.UpdateStatement;
-import org.hibernate.hql.ast.util.ASTPrinter;
-import org.hibernate.hql.ast.util.ASTUtil;
-import org.hibernate.hql.ast.util.AliasGenerator;
-import org.hibernate.hql.ast.util.JoinProcessor;
-import org.hibernate.hql.ast.util.LiteralProcessor;
-import org.hibernate.hql.ast.util.NodeTraverser;
-import org.hibernate.hql.ast.util.SessionFactoryHelper;
-import org.hibernate.hql.ast.util.SyntheticAndFactory;
+import org.hibernate.hql.internal.antlr.HqlSqlBaseWalker;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.antlr.HqlTokenTypes;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.tree.AggregateNode;
+import org.hibernate.hql.internal.ast.tree.AssignmentSpecification;
+import org.hibernate.hql.internal.ast.tree.CollectionFunction;
+import org.hibernate.hql.internal.ast.tree.ConstructorNode;
+import org.hibernate.hql.internal.ast.tree.DeleteStatement;
+import org.hibernate.hql.internal.ast.tree.DotNode;
+import org.hibernate.hql.internal.ast.tree.FromClause;
+import org.hibernate.hql.internal.ast.tree.FromElement;
+import org.hibernate.hql.internal.ast.tree.FromElementFactory;
+import org.hibernate.hql.internal.ast.tree.FromReferenceNode;
+import org.hibernate.hql.internal.ast.tree.IdentNode;
+import org.hibernate.hql.internal.ast.tree.IndexNode;
+import org.hibernate.hql.internal.ast.tree.InsertStatement;
+import org.hibernate.hql.internal.ast.tree.IntoClause;
+import org.hibernate.hql.internal.ast.tree.MethodNode;
+import org.hibernate.hql.internal.ast.tree.OperatorNode;
+import org.hibernate.hql.internal.ast.tree.ParameterContainer;
+import org.hibernate.hql.internal.ast.tree.ParameterNode;
+import org.hibernate.hql.internal.ast.tree.QueryNode;
+import org.hibernate.hql.internal.ast.tree.ResolvableNode;
+import org.hibernate.hql.internal.ast.tree.RestrictableStatement;
+import org.hibernate.hql.internal.ast.tree.ResultVariableRefNode;
+import org.hibernate.hql.internal.ast.tree.SelectClause;
+import org.hibernate.hql.internal.ast.tree.SelectExpression;
+import org.hibernate.hql.internal.ast.tree.UpdateStatement;
+import org.hibernate.hql.internal.ast.util.ASTPrinter;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
+import org.hibernate.hql.internal.ast.util.AliasGenerator;
+import org.hibernate.hql.internal.ast.util.JoinProcessor;
+import org.hibernate.hql.internal.ast.util.LiteralProcessor;
+import org.hibernate.hql.internal.ast.util.NodeTraverser;
+import org.hibernate.hql.internal.ast.util.SessionFactoryHelper;
+import org.hibernate.hql.internal.ast.util.SyntheticAndFactory;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.PostInsertIdentifierGenerator;
 import org.hibernate.id.SequenceGenerator;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.param.CollectionFilterKeyParameterSpecification;
 import org.hibernate.param.NamedParameterSpecification;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.param.PositionalParameterSpecification;
 import org.hibernate.param.VersionTypeSeedParameterSpecification;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.ComponentType;
 import org.hibernate.type.DbTimestampType;
 import org.hibernate.type.Type;
 import org.hibernate.type.VersionType;
 import org.hibernate.usertype.UserVersionType;
 import org.jboss.logging.Logger;
 import antlr.ASTFactory;
 import antlr.RecognitionException;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * Implements methods used by the HQL->SQL tree transform grammar (a.k.a. the second phase).
  * <ul>
  * <li>Isolates the Hibernate API-specific code from the ANTLR generated code.</li>
  * <li>Handles the SQL fragments generated by the persisters in order to create the SELECT and FROM clauses,
  * taking into account the joins and projections that are implied by the mappings (persister/queryable).</li>
  * <li>Uses SqlASTFactory to create customized AST nodes.</li>
  * </ul>
  *
  * @see SqlASTFactory
  */
 public class HqlSqlWalker extends HqlSqlBaseWalker implements ErrorReporter, ParameterBinder.NamedParameterSource {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, HqlSqlWalker.class.getName());
 
 	private final QueryTranslatorImpl queryTranslatorImpl;
 	private final HqlParser hqlParser;
 	private final SessionFactoryHelper sessionFactoryHelper;
 	private final Map tokenReplacements;
 	private final AliasGenerator aliasGenerator = new AliasGenerator();
 	private final LiteralProcessor literalProcessor;
 	private final ParseErrorHandler parseErrorHandler;
 	private final ASTPrinter printer;
 	private final String collectionFilterRole;
 
 	private FromClause currentFromClause = null;
 	private SelectClause selectClause;
 
 	/**
 	 * Maps each top-level result variable to its SelectExpression;
 	 * (excludes result variables defined in subqueries)
 	 **/
 	private Map<String, SelectExpression> selectExpressionsByResultVariable = new HashMap();
 
 	private Set querySpaces = new HashSet();
 
 	private int parameterCount;
 	private Map namedParameters = new HashMap();
 	private ArrayList parameters = new ArrayList();
 	private int numberOfParametersInSetClause;
 	private int positionalParameterCount;
 
 	private ArrayList assignmentSpecifications = new ArrayList();
 
 	private int impliedJoinType;
 
 	/**
 	 * Create a new tree transformer.
 	 *
 	 * @param qti Back pointer to the query translator implementation that is using this tree transform.
 	 * @param sfi The session factory implementor where the Hibernate mappings can be found.
 	 * @param parser A reference to the phase-1 parser
 	 * @param tokenReplacements Registers the token replacement map with the walker.  This map will
 	 * be used to substitute function names and constants.
 	 * @param collectionRole The collection role name of the collection used as the basis for the
 	 * filter, NULL if this is not a collection filter compilation.
 	 */
 	public HqlSqlWalker(
 			QueryTranslatorImpl qti,
 			SessionFactoryImplementor sfi,
 			HqlParser parser,
 			Map tokenReplacements,
 			String collectionRole) {
 		setASTFactory( new SqlASTFactory( this ) );
 		// Initialize the error handling delegate.
 		this.parseErrorHandler = new ErrorCounter();
 		this.queryTranslatorImpl = qti;
 		this.sessionFactoryHelper = new SessionFactoryHelper( sfi );
 		this.literalProcessor = new LiteralProcessor( this );
 		this.tokenReplacements = tokenReplacements;
 		this.collectionFilterRole = collectionRole;
 		this.hqlParser = parser;
 		this.printer = new ASTPrinter( SqlTokenTypes.class );
 	}
 
 
 	// handle trace logging ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	private int traceDepth = 0;
 
 	@Override
     public void traceIn(String ruleName, AST tree) {
         if (!LOG.isTraceEnabled()) return;
         if (inputState.guessing > 0) return;
 		String prefix = StringHelper.repeat( '-', (traceDepth++ * 2) ) + "-> ";
 		String traceText = ruleName + " (" + buildTraceNodeName(tree) + ")";
         LOG.trace(prefix + traceText);
 	}
 
 	private String buildTraceNodeName(AST tree) {
 		return tree == null
 				? "???"
 				: tree.getText() + " [" + printer.getTokenTypeName( tree.getType() ) + "]";
 	}
 
 	@Override
     public void traceOut(String ruleName, AST tree) {
         if (!LOG.isTraceEnabled()) return;
         if (inputState.guessing > 0) return;
 		String prefix = "<-" + StringHelper.repeat( '-', (--traceDepth * 2) ) + " ";
         LOG.trace(prefix + ruleName);
 	}
 
 
 	@Override
     protected void prepareFromClauseInputTree(AST fromClauseInput) {
 		if ( !isSubQuery() ) {
 //			// inject param specifications to account for dynamic filter param values
 //			if ( ! getEnabledFilters().isEmpty() ) {
 //				Iterator filterItr = getEnabledFilters().values().iterator();
 //				while ( filterItr.hasNext() ) {
 //					FilterImpl filter = ( FilterImpl ) filterItr.next();
 //					if ( ! filter.getFilterDefinition().getParameterNames().isEmpty() ) {
 //						Iterator paramItr = filter.getFilterDefinition().getParameterNames().iterator();
 //						while ( paramItr.hasNext() ) {
 //							String parameterName = ( String ) paramItr.next();
 //							// currently param filters *only* work with single-column parameter types;
 //							// if that limitation is ever lifted, this logic will need to change to account for that
 //							ParameterNode collectionFilterKeyParameter = ( ParameterNode ) astFactory.create( PARAM, "?" );
 //							DynamicFilterParameterSpecification paramSpec = new DynamicFilterParameterSpecification(
 //									filter.getName(),
 //									parameterName,
 //									filter.getFilterDefinition().getParameterType( parameterName ),
 //									 positionalParameterCount++
 //							);
 //							collectionFilterKeyParameter.setHqlParameterSpecification( paramSpec );
 //							parameters.add( paramSpec );
 //						}
 //					}
 //				}
 //			}
 
 			if ( isFilter() ) {
                 // Handle collection-filter compilation.
 				// IMPORTANT NOTE: This is modifying the INPUT (HQL) tree, not the output tree!
 				QueryableCollection persister = sessionFactoryHelper.getCollectionPersister( collectionFilterRole );
 				Type collectionElementType = persister.getElementType();
 				if ( !collectionElementType.isEntityType() ) {
 					throw new QueryException( "collection of values in filter: this" );
 				}
 
 				String collectionElementEntityName = persister.getElementPersister().getEntityName();
 				ASTFactory inputAstFactory = hqlParser.getASTFactory();
 				AST fromElement = ASTUtil.create( inputAstFactory, HqlTokenTypes.FILTER_ENTITY, collectionElementEntityName );
 				ASTUtil.createSibling( inputAstFactory, HqlTokenTypes.ALIAS, "this", fromElement );
 				fromClauseInput.addChild( fromElement );
 				// Show the modified AST.
                 LOG.debugf("prepareFromClauseInputTree() : Filter - Added 'this' as a from element...");
 				queryTranslatorImpl.showHqlAst( hqlParser.getAST() );
 
 				// Create a parameter specification for the collection filter...
 				Type collectionFilterKeyType = sessionFactoryHelper.requireQueryableCollection( collectionFilterRole ).getKeyType();
 				ParameterNode collectionFilterKeyParameter = ( ParameterNode ) astFactory.create( PARAM, "?" );
 				CollectionFilterKeyParameterSpecification collectionFilterKeyParameterSpec = new CollectionFilterKeyParameterSpecification(
 						collectionFilterRole, collectionFilterKeyType, positionalParameterCount++
 				);
 				collectionFilterKeyParameter.setHqlParameterSpecification( collectionFilterKeyParameterSpec );
 				parameters.add( collectionFilterKeyParameterSpec );
 			}
 		}
 	}
 
 	public boolean isFilter() {
 		return collectionFilterRole != null;
 	}
 
 	public String getCollectionFilterRole() {
 		return collectionFilterRole;
 	}
 
 	public SessionFactoryHelper getSessionFactoryHelper() {
 		return sessionFactoryHelper;
 	}
 
 	public Map getTokenReplacements() {
 		return tokenReplacements;
 	}
 
 	public AliasGenerator getAliasGenerator() {
 		return aliasGenerator;
 	}
 
 	public FromClause getCurrentFromClause() {
 		return currentFromClause;
 	}
 
 	public ParseErrorHandler getParseErrorHandler() {
 		return parseErrorHandler;
 	}
 
 	@Override
     public void reportError(RecognitionException e) {
 		parseErrorHandler.reportError( e ); // Use the delegate.
 	}
 
 	@Override
     public void reportError(String s) {
 		parseErrorHandler.reportError( s ); // Use the delegate.
 	}
 
 	@Override
     public void reportWarning(String s) {
 		parseErrorHandler.reportWarning( s );
 	}
 
 	/**
 	 * Returns the set of unique query spaces (a.k.a.
 	 * table names) that occurred in the query.
 	 *
 	 * @return A set of table names (Strings).
 	 */
 	public Set getQuerySpaces() {
 		return querySpaces;
 	}
 
 	@Override
     protected AST createFromElement(String path, AST alias, AST propertyFetch) throws SemanticException {
 		FromElement fromElement = currentFromClause.addFromElement( path, alias );
 		fromElement.setAllPropertyFetch(propertyFetch!=null);
 		return fromElement;
 	}
 
 	@Override
     protected AST createFromFilterElement(AST filterEntity, AST alias) throws SemanticException {
 		FromElement fromElement = currentFromClause.addFromElement( filterEntity.getText(), alias );
 		FromClause fromClause = fromElement.getFromClause();
 		QueryableCollection persister = sessionFactoryHelper.getCollectionPersister( collectionFilterRole );
 		// Get the names of the columns used to link between the collection
 		// owner and the collection elements.
 		String[] keyColumnNames = persister.getKeyColumnNames();
 		String fkTableAlias = persister.isOneToMany()
 				? fromElement.getTableAlias()
 				: fromClause.getAliasGenerator().createName( collectionFilterRole );
 		JoinSequence join = sessionFactoryHelper.createJoinSequence();
 		join.setRoot( persister, fkTableAlias );
 		if ( !persister.isOneToMany() ) {
 			join.addJoin( ( AssociationType ) persister.getElementType(),
 					fromElement.getTableAlias(),
 					JoinFragment.INNER_JOIN,
 					persister.getElementColumnNames( fkTableAlias ) );
 		}
 		join.addCondition( fkTableAlias, keyColumnNames, " = ?" );
 		fromElement.setJoinSequence( join );
 		fromElement.setFilter( true );
         LOG.debugf("createFromFilterElement() : processed filter FROM element.");
 		return fromElement;
 	}
 
 	@Override
     protected void createFromJoinElement(
 	        AST path,
 	        AST alias,
 	        int joinType,
 	        AST fetchNode,
 	        AST propertyFetch,
 	        AST with) throws SemanticException {
 		boolean fetch = fetchNode != null;
 		if ( fetch && isSubQuery() ) {
 			throw new QueryException( "fetch not allowed in subquery from-elements" );
 		}
 		// The path AST should be a DotNode, and it should have been evaluated already.
 		if ( path.getType() != SqlTokenTypes.DOT ) {
 			throw new SemanticException( "Path expected for join!" );
 		}
 		DotNode dot = ( DotNode ) path;
 		int hibernateJoinType = JoinProcessor.toHibernateJoinType( joinType );
 		dot.setJoinType( hibernateJoinType );	// Tell the dot node about the join type.
 		dot.setFetch( fetch );
 		// Generate an explicit join for the root dot node.   The implied joins will be collected and passed up
 		// to the root dot node.
 		dot.resolve( true, false, alias == null ? null : alias.getText() );
 
 		final FromElement fromElement;
 		if ( dot.getDataType() != null && dot.getDataType().isComponentType() ) {
 			FromElementFactory factory = new FromElementFactory(
 					getCurrentFromClause(),
 					dot.getLhs().getFromElement(),
 					dot.getPropertyPath(),
 					alias == null ? null : alias.getText(),
 					null,
 					false
 			);
 			fromElement = factory.createComponentJoin( (ComponentType) dot.getDataType() );
 		}
 		else {
 			fromElement = dot.getImpliedJoin();
 			fromElement.setAllPropertyFetch( propertyFetch != null );
 
 			if ( with != null ) {
 				if ( fetch ) {
 					throw new SemanticException( "with-clause not allowed on fetched associations; use filters" );
 				}
 				handleWithFragment( fromElement, with );
 			}
 		}
 
         if (LOG.isDebugEnabled()) LOG.debugf("createFromJoinElement() : %s",
                                              getASTPrinter().showAsString(fromElement, "-- join tree --"));
 	}
 
 	private void handleWithFragment(FromElement fromElement, AST hqlWithNode) throws SemanticException {
 		try {
 			withClause( hqlWithNode );
 			AST hqlSqlWithNode = returnAST;
             if (LOG.isDebugEnabled()) LOG.debugf("handleWithFragment() : %s",
                                                  getASTPrinter().showAsString(hqlSqlWithNode, "-- with clause --"));
 			WithClauseVisitor visitor = new WithClauseVisitor( fromElement );
 			NodeTraverser traverser = new NodeTraverser( visitor );
 			traverser.traverseDepthFirst( hqlSqlWithNode );
 
 			String withClauseJoinAlias = visitor.getJoinAlias();
 			if ( withClauseJoinAlias == null ) {
 				withClauseJoinAlias = fromElement.getCollectionTableAlias();
 			}
 			else {
 				FromElement referencedFromElement = visitor.getReferencedFromElement();
 				if ( referencedFromElement != fromElement ) {
 					throw new InvalidWithClauseException( "with-clause expressions did not reference from-clause element to which the with-clause was associated" );
 				}
 			}
 
 			SqlGenerator sql = new SqlGenerator( getSessionFactoryHelper().getFactory() );
 			sql.whereExpr( hqlSqlWithNode.getFirstChild() );
 
 			fromElement.setWithClauseFragment( withClauseJoinAlias, "(" + sql.getSQL() + ")" );
 		}
 		catch( SemanticException e ) {
 			throw e;
 		}
 		catch( InvalidWithClauseException e ) {
 			throw e;
 		}
 		catch ( Exception e) {
 			throw new SemanticException( e.getMessage() );
 		}
 	}
 
 	private static class WithClauseVisitor implements NodeTraverser.VisitationStrategy {
 		private final FromElement joinFragment;
 		private FromElement referencedFromElement;
 		private String joinAlias;
 
 		public WithClauseVisitor(FromElement fromElement) {
 			this.joinFragment = fromElement;
 		}
 
 		public void visit(AST node) {
             // TODO : currently expects that the individual with expressions apply to the same sql table join.
 			//      This may not be the case for joined-subclass where the property values
 			//      might be coming from different tables in the joined hierarchy.  At some
 			//      point we should expand this to support that capability.  However, that has
 			//      some difficulties:
 			//          1) the biggest is how to handle ORs when the individual comparisons are
 			//              linked to different sql joins.
 			//          2) here we would need to track each comparison individually, along with
 			//              the join alias to which it applies and then pass that information
 			//              back to the FromElement so it can pass it along to the JoinSequence
 			if ( node instanceof DotNode ) {
 				DotNode dotNode = ( DotNode ) node;
 				FromElement fromElement = dotNode.getFromElement();
 				if ( referencedFromElement != null ) {
 					if ( fromElement != referencedFromElement ) {
 						throw new HibernateException( "with-clause referenced two different from-clause elements" );
 					}
 				}
 				else {
 					referencedFromElement = fromElement;
 					joinAlias = extractAppliedAlias( dotNode );
                     // TODO : temporary
 					//      needed because currently persister is the one that
                     // creates and renders the join fragments for inheritance
 					//      hierarchies...
 					if ( !joinAlias.equals( referencedFromElement.getTableAlias() ) ) {
 						throw new InvalidWithClauseException( "with clause can only reference columns in the driving table" );
 					}
 				}
 			}
 			else if ( node instanceof ParameterNode ) {
 				applyParameterSpecification( ( ( ParameterNode ) node ).getHqlParameterSpecification() );
 			}
 			else if ( node instanceof ParameterContainer ) {
 				applyParameterSpecifications( ( ParameterContainer ) node );
 			}
 		}
 
 		private void applyParameterSpecifications(ParameterContainer parameterContainer) {
 			if ( parameterContainer.hasEmbeddedParameters() ) {
 				ParameterSpecification[] specs = parameterContainer.getEmbeddedParameters();
 				for ( int i = 0; i < specs.length; i++ ) {
 					applyParameterSpecification( specs[i] );
 				}
 			}
 		}
 
 		private void applyParameterSpecification(ParameterSpecification paramSpec) {
 			joinFragment.addEmbeddedParameter( paramSpec );
 		}
 
 		private String extractAppliedAlias(DotNode dotNode) {
 			return dotNode.getText().substring( 0, dotNode.getText().indexOf( '.' ) );
 		}
 
 		public FromElement getReferencedFromElement() {
 			return referencedFromElement;
 		}
 
 		public String getJoinAlias() {
 			return joinAlias;
 		}
 	}
 
 	/**
 	 * Sets the current 'FROM' context.
 	 *
 	 * @param fromNode      The new 'FROM' context.
 	 * @param inputFromNode The from node from the input AST.
 	 */
 	@Override
     protected void pushFromClause(AST fromNode, AST inputFromNode) {
 		FromClause newFromClause = ( FromClause ) fromNode;
 		newFromClause.setParentFromClause( currentFromClause );
 		currentFromClause = newFromClause;
 	}
 
 	/**
 	 * Returns to the previous 'FROM' context.
 	 */
 	private void popFromClause() {
 		currentFromClause = currentFromClause.getParentFromClause();
 	}
 
 	@Override
     protected void lookupAlias(AST aliasRef)
 			throws SemanticException {
 		FromElement alias = currentFromClause.getFromElement( aliasRef.getText() );
 		FromReferenceNode aliasRefNode = ( FromReferenceNode ) aliasRef;
 		aliasRefNode.setFromElement( alias );
 	}
 
 	@Override
     protected void setImpliedJoinType(int joinType) {
 		impliedJoinType = JoinProcessor.toHibernateJoinType( joinType );
 	}
 
 	public int getImpliedJoinType() {
 		return impliedJoinType;
 	}
 
 	@Override
     protected AST lookupProperty(AST dot, boolean root, boolean inSelect) throws SemanticException {
 		DotNode dotNode = ( DotNode ) dot;
 		FromReferenceNode lhs = dotNode.getLhs();
 		AST rhs = lhs.getNextSibling();
 		switch ( rhs.getType() ) {
 			case SqlTokenTypes.ELEMENTS:
 			case SqlTokenTypes.INDICES:
                 if (LOG.isDebugEnabled()) LOG.debugf("lookupProperty() %s => %s(%s)",
                                                      dotNode.getPath(),
                                                      rhs.getText(),
                                                      lhs.getPath());
 				CollectionFunction f = ( CollectionFunction ) rhs;
 				// Re-arrange the tree so that the collection function is the root and the lhs is the path.
 				f.setFirstChild( lhs );
 				lhs.setNextSibling( null );
 				dotNode.setFirstChild( f );
 				resolve( lhs );			// Don't forget to resolve the argument!
 				f.resolve( inSelect );	// Resolve the collection function now.
 				return f;
 			default:
 				// Resolve everything up to this dot, but don't resolve the placeholders yet.
 				dotNode.resolveFirstChild();
 				return dotNode;
 		}
 	}
 
 	@Override
     protected boolean isNonQualifiedPropertyRef(AST ident) {
 		final String identText = ident.getText();
 		if ( currentFromClause.isFromElementAlias( identText ) ) {
 			return false;
 		}
 
 		List fromElements = currentFromClause.getExplicitFromElements();
 		if ( fromElements.size() == 1 ) {
 			final FromElement fromElement = ( FromElement ) fromElements.get( 0 );
 			try {
                 LOG.trace("Attempting to resolve property [" + identText + "] as a non-qualified ref");
 				return fromElement.getPropertyMapping( identText ).toType( identText ) != null;
 			}
 			catch( QueryException e ) {
 				// Should mean that no such property was found
 			}
 		}
 
 		return false;
 	}
 
 	@Override
     protected AST lookupNonQualifiedProperty(AST property) throws SemanticException {
 		final FromElement fromElement = ( FromElement ) currentFromClause.getExplicitFromElements().get( 0 );
 		AST syntheticDotNode = generateSyntheticDotNodeForNonQualifiedPropertyRef( property, fromElement );
 		return lookupProperty( syntheticDotNode, false, getCurrentClauseType() == HqlSqlTokenTypes.SELECT );
 	}
 
 	private AST generateSyntheticDotNodeForNonQualifiedPropertyRef(AST property, FromElement fromElement) {
 		AST dot = getASTFactory().create( DOT, "{non-qualified-property-ref}" );
 		// TODO : better way?!?
 		( ( DotNode ) dot ).setPropertyPath( ( ( FromReferenceNode ) property ).getPath() );
 
 		IdentNode syntheticAlias = ( IdentNode ) getASTFactory().create( IDENT, "{synthetic-alias}" );
 		syntheticAlias.setFromElement( fromElement );
 		syntheticAlias.setResolved();
 
 		dot.setFirstChild( syntheticAlias );
 		dot.addChild( property );
 
 		return dot;
 	}
 
 	@Override
     protected void processQuery(AST select, AST query) throws SemanticException {
         LOG.debugf("processQuery() : %s", query.toStringTree());
 
 		try {
 			QueryNode qn = ( QueryNode ) query;
 
 			// Was there an explicit select expression?
 			boolean explicitSelect = select != null && select.getNumberOfChildren() > 0;
 
 			if ( !explicitSelect ) {
 				// No explicit select expression; render the id and properties
 				// projection lists for every persister in the from clause into
 				// a single 'token node'.
 				//TODO: the only reason we need this stuff now is collection filters,
 				//      we should get rid of derived select clause completely!
 				createSelectClauseFromFromClause( qn );
 			}
 			else {
 				// Use the explicitly declared select expression; determine the
 				// return types indicated by each select token
 				useSelectClause( select );
 			}
 
 			// After that, process the JOINs.
 			// Invoke a delegate to do the work, as this is farily complex.
 			JoinProcessor joinProcessor = new JoinProcessor( this );
 			joinProcessor.processJoins( qn );
 
 			// Attach any mapping-defined "ORDER BY" fragments
 			Iterator itr = qn.getFromClause().getProjectionList().iterator();
 			while ( itr.hasNext() ) {
 				final FromElement fromElement = ( FromElement ) itr.next();
 //			if ( fromElement.isFetch() && fromElement.isCollectionJoin() ) {
 				if ( fromElement.isFetch() && fromElement.getQueryableCollection() != null ) {
 					// Does the collection referenced by this FromElement
 					// specify an order-by attribute?  If so, attach it to
 					// the query's order-by
 					if ( fromElement.getQueryableCollection().hasOrdering() ) {
 						String orderByFragment = fromElement
 								.getQueryableCollection()
 								.getSQLOrderByString( fromElement.getCollectionTableAlias() );
 						qn.getOrderByClause().addOrderFragment( orderByFragment );
 					}
 					if ( fromElement.getQueryableCollection().hasManyToManyOrdering() ) {
 						String orderByFragment = fromElement.getQueryableCollection()
 								.getManyToManyOrderByString( fromElement.getTableAlias() );
 						qn.getOrderByClause().addOrderFragment( orderByFragment );
 					}
 				}
 			}
 		}
 		finally {
 			popFromClause();
 		}
 	}
 
 	protected void postProcessDML(RestrictableStatement statement) throws SemanticException {
 		statement.getFromClause().resolve();
 
 		FromElement fromElement = ( FromElement ) statement.getFromClause().getFromElements().get( 0 );
 		Queryable persister = fromElement.getQueryable();
 		// Make #@%$^#^&# sure no alias is applied to the table name
 		fromElement.setText( persister.getTableName() );
 
 //		// append any filter fragments; the EMPTY_MAP is used under the assumption that
 //		// currently enabled filters should not affect this process
 //		if ( persister.getDiscriminatorType() != null ) {
 //			new SyntheticAndFactory( getASTFactory() ).addDiscriminatorWhereFragment(
 //			        statement,
 //			        persister,
 //			        java.util.Collections.EMPTY_MAP,
 //			        fromElement.getTableAlias()
 //			);
 //		}
 		if ( persister.getDiscriminatorType() != null || ! queryTranslatorImpl.getEnabledFilters().isEmpty() ) {
 			new SyntheticAndFactory( this ).addDiscriminatorWhereFragment(
 			        statement,
 			        persister,
 			        queryTranslatorImpl.getEnabledFilters(),
 			        fromElement.getTableAlias()
 			);
 		}
 
 	}
 
 	@Override
     protected void postProcessUpdate(AST update) throws SemanticException {
 		UpdateStatement updateStatement = ( UpdateStatement ) update;
 
 		postProcessDML( updateStatement );
 	}
 
 	@Override
     protected void postProcessDelete(AST delete) throws SemanticException {
 		postProcessDML( ( DeleteStatement ) delete );
 	}
 
 	public static boolean supportsIdGenWithBulkInsertion(IdentifierGenerator generator) {
 		return SequenceGenerator.class.isAssignableFrom( generator.getClass() )
 		        || PostInsertIdentifierGenerator.class.isAssignableFrom( generator.getClass() );
 	}
 
 	@Override
     protected void postProcessInsert(AST insert) throws SemanticException, QueryException {
 		InsertStatement insertStatement = ( InsertStatement ) insert;
 		insertStatement.validate();
 
 		SelectClause selectClause = insertStatement.getSelectClause();
 		Queryable persister = insertStatement.getIntoClause().getQueryable();
 
 		if ( !insertStatement.getIntoClause().isExplicitIdInsertion() ) {
 			// We need to generate ids as part of this bulk insert.
 			//
 			// Note that this is only supported for sequence-style generators and
 			// post-insert-style generators; basically, only in-db generators
 			IdentifierGenerator generator = persister.getIdentifierGenerator();
 			if ( !supportsIdGenWithBulkInsertion( generator ) ) {
 				throw new QueryException( "can only generate ids as part of bulk insert with either sequence or post-insert style generators" );
 			}
 
 			AST idSelectExprNode = null;
 
 			if ( SequenceGenerator.class.isAssignableFrom( generator.getClass() ) ) {
 				String seqName = ( String ) ( ( SequenceGenerator ) generator ).generatorKey();
 				String nextval = sessionFactoryHelper.getFactory().getDialect().getSelectSequenceNextValString( seqName );
 				idSelectExprNode = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, nextval );
 			}
 			else {
 				//Don't need this, because we should never ever be selecting no columns in an insert ... select...
 				//and because it causes a bug on DB2
 				/*String idInsertString = sessionFactoryHelper.getFactory().getDialect().getIdentityInsertString();
 				if ( idInsertString != null ) {
 					idSelectExprNode = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, idInsertString );
 				}*/
 			}
 
 			if ( idSelectExprNode != null ) {
 				AST currentFirstSelectExprNode = selectClause.getFirstChild();
 				selectClause.setFirstChild( idSelectExprNode );
 				idSelectExprNode.setNextSibling( currentFirstSelectExprNode );
 
 				insertStatement.getIntoClause().prependIdColumnSpec();
 			}
 		}
 
 		final boolean includeVersionProperty = persister.isVersioned() &&
 				!insertStatement.getIntoClause().isExplicitVersionInsertion() &&
 				persister.isVersionPropertyInsertable();
 		if ( includeVersionProperty ) {
 			// We need to seed the version value as part of this bulk insert
 			VersionType versionType = persister.getVersionType();
 			AST versionValueNode = null;
 
 			if ( sessionFactoryHelper.getFactory().getDialect().supportsParametersInInsertSelect() ) {
 				int sqlTypes[] = versionType.sqlTypes( sessionFactoryHelper.getFactory() );
 				if ( sqlTypes == null || sqlTypes.length == 0 ) {
 					throw new IllegalStateException( versionType.getClass() + ".sqlTypes() returns null or empty array" );
 				}
 				if ( sqlTypes.length > 1 ) {
 					throw new IllegalStateException(
 							versionType.getClass() +
 									".sqlTypes() returns > 1 element; only single-valued versions are allowed."
 					);
 				}
 				versionValueNode = getASTFactory().create( HqlSqlTokenTypes.PARAM, "?" );
 				ParameterSpecification paramSpec = new VersionTypeSeedParameterSpecification( versionType );
 				( ( ParameterNode ) versionValueNode ).setHqlParameterSpecification( paramSpec );
 				parameters.add( 0, paramSpec );
 
 				if ( sessionFactoryHelper.getFactory().getDialect().requiresCastingOfParametersInSelectClause() ) {
 					// we need to wrtap the param in a cast()
 					MethodNode versionMethodNode = ( MethodNode ) getASTFactory().create( HqlSqlTokenTypes.METHOD_CALL, "(" );
 					AST methodIdentNode = getASTFactory().create( HqlSqlTokenTypes.IDENT, "cast" );
 					versionMethodNode.addChild( methodIdentNode );
 					versionMethodNode.initializeMethodNode(methodIdentNode, true );
 					AST castExprListNode = getASTFactory().create( HqlSqlTokenTypes.EXPR_LIST, "exprList" );
 					methodIdentNode.setNextSibling( castExprListNode );
 					castExprListNode.addChild( versionValueNode );
 					versionValueNode.setNextSibling(
 							getASTFactory().create(
 									HqlSqlTokenTypes.IDENT,
 									sessionFactoryHelper.getFactory().getDialect().getTypeName( sqlTypes[0] ) )
 					);
 					processFunction( versionMethodNode, true );
 					versionValueNode = versionMethodNode;
 				}
 			}
 			else {
 				if ( isIntegral( versionType ) ) {
 					try {
 						Object seedValue = versionType.seed( null );
 						versionValueNode = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, seedValue.toString() );
 					}
 					catch( Throwable t ) {
 						throw new QueryException( "could not determine seed value for version on bulk insert [" + versionType + "]" );
 					}
 				}
 				else if ( isDatabaseGeneratedTimestamp( versionType ) ) {
 					String functionName = sessionFactoryHelper.getFactory().getDialect().getCurrentTimestampSQLFunctionName();
 					versionValueNode = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, functionName );
 				}
 				else {
 					throw new QueryException( "cannot handle version type [" + versionType + "] on bulk inserts with dialects not supporting parameters in insert-select statements" );
 				}
 			}
 
 			AST currentFirstSelectExprNode = selectClause.getFirstChild();
 			selectClause.setFirstChild( versionValueNode );
 			versionValueNode.setNextSibling( currentFirstSelectExprNode );
 
 			insertStatement.getIntoClause().prependVersionColumnSpec();
 		}
 
 		if ( insertStatement.getIntoClause().isDiscriminated() ) {
 			String sqlValue = insertStatement.getIntoClause().getQueryable().getDiscriminatorSQLValue();
 			AST discrimValue = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, sqlValue );
 			insertStatement.getSelectClause().addChild( discrimValue );
 		}
 
 	}
 
 	private boolean isDatabaseGeneratedTimestamp(Type type) {
 		// currently only the Hibernate-supplied DbTimestampType is supported here
 		return DbTimestampType.class.isAssignableFrom( type.getClass() );
 	}
 
 	private boolean isIntegral(Type type) {
 		return Long.class.isAssignableFrom( type.getReturnedClass() )
 		       || Integer.class.isAssignableFrom( type.getReturnedClass() )
 		       || long.class.isAssignableFrom( type.getReturnedClass() )
 		       || int.class.isAssignableFrom( type.getReturnedClass() );
 	}
 
 	private void useSelectClause(AST select) throws SemanticException {
 		selectClause = ( SelectClause ) select;
 		selectClause.initializeExplicitSelectClause( currentFromClause );
 	}
 
 	private void createSelectClauseFromFromClause(QueryNode qn) throws SemanticException {
 		AST select = astFactory.create( SELECT_CLAUSE, "{derived select clause}" );
 		AST sibling = qn.getFromClause();
 		qn.setFirstChild( select );
 		select.setNextSibling( sibling );
 		selectClause = ( SelectClause ) select;
 		selectClause.initializeDerivedSelectClause( currentFromClause );
         LOG.debugf("Derived SELECT clause created.");
 	}
 
 	@Override
     protected void resolve(AST node) throws SemanticException {
 		if ( node != null ) {
 			// This is called when it's time to fully resolve a path expression.
 			ResolvableNode r = ( ResolvableNode ) node;
 			if ( isInFunctionCall() ) {
 				r.resolveInFunctionCall( false, true );
 			}
 			else {
 				r.resolve( false, true );	// Generate implicit joins, only if necessary.
 			}
 		}
 	}
 
 	@Override
     protected void resolveSelectExpression(AST node) throws SemanticException {
 		// This is called when it's time to fully resolve a path expression.
 		int type = node.getType();
 		switch ( type ) {
 			case DOT: {
 				DotNode dot = ( DotNode ) node;
 				dot.resolveSelectExpression();
 				break;
 			}
 			case ALIAS_REF: {
 				// Notify the FROM element that it is being referenced by the select.
 				FromReferenceNode aliasRefNode = ( FromReferenceNode ) node;
 				//aliasRefNode.resolve( false, false, aliasRefNode.getText() ); //TODO: is it kosher to do it here?
 				aliasRefNode.resolve( false, false ); //TODO: is it kosher to do it here?
 				FromElement fromElement = aliasRefNode.getFromElement();
 				if ( fromElement != null ) {
 					fromElement.setIncludeSubclasses( true );
 				}
 				break;
 			}
 			default: {
 				break;
 			}
 		}
 	}
 
 	@Override
     protected void beforeSelectClause() throws SemanticException {
 		// Turn off includeSubclasses on all FromElements.
 		FromClause from = getCurrentFromClause();
 		List fromElements = from.getFromElements();
 		for ( Iterator iterator = fromElements.iterator(); iterator.hasNext(); ) {
 			FromElement fromElement = ( FromElement ) iterator.next();
 			fromElement.setIncludeSubclasses( false );
 		}
 	}
 
 	@Override
     protected AST generatePositionalParameter(AST inputNode) throws SemanticException {
 		if ( namedParameters.size() > 0 ) {
 			throw new SemanticException( "cannot define positional parameter after any named parameters have been defined" );
 		}
 		ParameterNode parameter = ( ParameterNode ) astFactory.create( PARAM, "?" );
 		PositionalParameterSpecification paramSpec = new PositionalParameterSpecification(
 				inputNode.getLine(),
 		        inputNode.getColumn(),
 				positionalParameterCount++
 		);
 		parameter.setHqlParameterSpecification( paramSpec );
 		parameters.add( paramSpec );
 		return parameter;
 	}
 
 	@Override
     protected AST generateNamedParameter(AST delimiterNode, AST nameNode) throws SemanticException {
 		String name = nameNode.getText();
 		trackNamedParameterPositions( name );
 
 		// create the node initially with the param name so that it shows
 		// appropriately in the "original text" attribute
 		ParameterNode parameter = ( ParameterNode ) astFactory.create( NAMED_PARAM, name );
 		parameter.setText( "?" );
 
 		NamedParameterSpecification paramSpec = new NamedParameterSpecification(
 				delimiterNode.getLine(),
 		        delimiterNode.getColumn(),
 				name
 		);
 		parameter.setHqlParameterSpecification( paramSpec );
 		parameters.add( paramSpec );
 		return parameter;
 	}
 
 	private void trackNamedParameterPositions(String name) {
 		Integer loc = new Integer( parameterCount++ );
 		Object o = namedParameters.get( name );
 		if ( o == null ) {
 			namedParameters.put( name, loc );
 		}
 		else if ( o instanceof Integer ) {
 			ArrayList list = new ArrayList( 4 );
 			list.add( o );
 			list.add( loc );
 			namedParameters.put( name, list );
 		}
 		else {
 			( ( ArrayList ) o ).add( loc );
 		}
 	}
 
 	@Override
     protected void processConstant(AST constant) throws SemanticException {
 		literalProcessor.processConstant( constant, true );  // Use the delegate, resolve identifiers as FROM element aliases.
 	}
 
 	@Override
     protected void processBoolean(AST constant) throws SemanticException {
 		literalProcessor.processBoolean( constant );  // Use the delegate.
 	}
 
 	@Override
     protected void processNumericLiteral(AST literal) {
 		literalProcessor.processNumeric( literal );
 	}
 
 	@Override
     protected void processIndex(AST indexOp) throws SemanticException {
 		IndexNode indexNode = ( IndexNode ) indexOp;
 		indexNode.resolve( true, true );
 	}
 
 	@Override
     protected void processFunction(AST functionCall, boolean inSelect) throws SemanticException {
 		MethodNode methodNode = ( MethodNode ) functionCall;
 		methodNode.resolve( inSelect );
 	}
 
 	@Override
     protected void processAggregation(AST node, boolean inSelect) throws SemanticException {
 		AggregateNode aggregateNode = ( AggregateNode ) node;
 		aggregateNode.resolve();
 	}
 
 	@Override
     protected void processConstructor(AST constructor) throws SemanticException {
 		ConstructorNode constructorNode = ( ConstructorNode ) constructor;
 		constructorNode.prepare();
 	}
 
     @Override
     protected void setAlias(AST selectExpr, AST ident) {
         ((SelectExpression) selectExpr).setAlias(ident.getText());
 		// only put the alias (i.e., result variable) in selectExpressionsByResultVariable
 		// if is not defined in a subquery.
 		if ( ! isSubQuery() ) {
 			selectExpressionsByResultVariable.put( ident.getText(), ( SelectExpression ) selectExpr );
 		}
     }
 
 	@Override
     protected boolean isOrderExpressionResultVariableRef(AST orderExpressionNode) throws SemanticException {
 		// ORDER BY is not supported in a subquery
 		// TODO: should an exception be thrown if an ORDER BY is in a subquery?
 		if ( ! isSubQuery() &&
 				orderExpressionNode.getType() == IDENT &&
 				selectExpressionsByResultVariable.containsKey( orderExpressionNode.getText() ) ) {
 			return true;
 		}
 		return false;
 	}
 
 	@Override
     protected void handleResultVariableRef(AST resultVariableRef) throws SemanticException {
 		if ( isSubQuery() ) {
 			throw new SemanticException(
 					"References to result variables in subqueries are not supported."
 			);
 		}
 		( ( ResultVariableRefNode ) resultVariableRef ).setSelectExpression(
 				selectExpressionsByResultVariable.get( resultVariableRef.getText() )
 		);
 	}
 
 	/**
 	 * Returns the locations of all occurrences of the named parameter.
 	 */
 	public int[] getNamedParameterLocations(String name) throws QueryException {
 		Object o = namedParameters.get( name );
 		if ( o == null ) {
 			QueryException qe = new QueryException( QueryTranslator.ERROR_NAMED_PARAMETER_DOES_NOT_APPEAR + name );
 			qe.setQueryString( queryTranslatorImpl.getQueryString() );
 			throw qe;
 		}
 		if ( o instanceof Integer ) {
 			return new int[]{( ( Integer ) o ).intValue()};
 		}
 		else {
 			return ArrayHelper.toIntArray( (ArrayList) o );
 		}
 	}
 
 	public void addQuerySpaces(Serializable[] spaces) {
 		querySpaces.addAll( Arrays.asList( spaces ) );
 	}
 
 	public Type[] getReturnTypes() {
 		return selectClause.getQueryReturnTypes();
 	}
 
 	public String[] getReturnAliases() {
 		return selectClause.getQueryReturnAliases();
 	}
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/HqlToken.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlToken.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/HqlToken.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlToken.java
index d0675396f9..0fb1483c95 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/HqlToken.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlToken.java
@@ -1,95 +1,95 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 
 
 /**
  * A custom token class for the HQL grammar.
  * <p><i>NOTE:<i> This class must be public becuase it is instantiated by the ANTLR library.  Ignore any suggestions
  * by various code 'analyzers' about this class being package local.</p>
  */
 public class HqlToken extends antlr.CommonToken {
 	/**
 	 * True if this token could be an identifier. *
 	 */
 	private boolean possibleID = false;
 	/**
 	 * The previous token type. *
 	 */
 	private int tokenType;
 
 	/**
 	 * Returns true if the token could be an identifier.
 	 *
 	 * @return True if the token could be interpreted as in identifier,
 	 *         false if not.
 	 */
 	public boolean isPossibleID() {
 		return possibleID;
 	}
 
 	/**
 	 * Sets the type of the token, remembering the previous type.
 	 *
 	 * @param t The new token type.
 	 */
 	public void setType(int t) {
 		this.tokenType = getType();
 		super.setType( t );
 	}
 
 	/**
 	 * Returns the previous token type.
 	 *
 	 * @return int - The old token type.
 	 */
 	private int getPreviousType() {
 		return tokenType;
 	}
 
 	/**
 	 * Set to true if this token can be interpreted as an identifier,
 	 * false if not.
 	 *
 	 * @param possibleID True if this is a keyword/identifier, false if not.
 	 */
 	public void setPossibleID(boolean possibleID) {
 		this.possibleID = possibleID;
 	}
 
 	/**
 	 * Returns a string representation of the object.
 	 *
 	 * @return String - The debug string.
 	 */
 	public String toString() {
 		return "[\""
 				+ getText()
 				+ "\",<" + getType() + "> previously: <" + getPreviousType() + ">,line="
 				+ line + ",col="
 				+ col + ",possibleID=" + possibleID + "]";
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/InvalidPathException.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/InvalidPathException.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/InvalidPathException.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/InvalidPathException.java
index 669a92a812..7eaf731378 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/InvalidPathException.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/InvalidPathException.java
@@ -1,37 +1,37 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 import antlr.SemanticException;
 
 /**
  * Exception thrown when an invalid path is found in a query.
  *
  * @author josh
  */
 public class InvalidPathException extends SemanticException {
 	public InvalidPathException(String s) {
 		super( s );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/InvalidWithClauseException.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/InvalidWithClauseException.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/InvalidWithClauseException.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/InvalidWithClauseException.java
index ba5f4a50d7..bb407afa44 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/InvalidWithClauseException.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/InvalidWithClauseException.java
@@ -1,41 +1,41 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.hql.ast;
-
-
-/**
- * {@inheritDoc}
- *
- * @author Steve Ebersole
- */
-public class InvalidWithClauseException extends QuerySyntaxException {
-	public InvalidWithClauseException(String message) {
-		super( message );
-	}
-
-	public InvalidWithClauseException(String message, String queryString) {
-		super( message, queryString );
-	}
-}
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Middleware LLC.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ *
+ */
+package org.hibernate.hql.internal.ast;
+
+
+/**
+ * {@inheritDoc}
+ *
+ * @author Steve Ebersole
+ */
+public class InvalidWithClauseException extends QuerySyntaxException {
+	public InvalidWithClauseException(String message) {
+		super( message );
+	}
+
+	public InvalidWithClauseException(String message, String queryString) {
+		super( message, queryString );
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/ParameterTranslationsImpl.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ParameterTranslationsImpl.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/ParameterTranslationsImpl.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ParameterTranslationsImpl.java
index 552740a399..b7967d10bd 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/ParameterTranslationsImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ParameterTranslationsImpl.java
@@ -1,172 +1,172 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import org.hibernate.hql.ParameterTranslations;
+import org.hibernate.hql.spi.ParameterTranslations;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.param.NamedParameterSpecification;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.param.PositionalParameterSpecification;
 import org.hibernate.type.Type;
 
 /**
  * Defines the information available for parameters encountered during
  * query translation through the antlr-based parser.
  *
  * @author Steve Ebersole
  */
 public class ParameterTranslationsImpl implements ParameterTranslations {
 
 	private final Map namedParameters;
 	private final ParameterInfo[] ordinalParameters;
 
 	public boolean supportsOrdinalParameterMetadata() {
 		return true;
 	}
 
 	public int getOrdinalParameterCount() {
 		return ordinalParameters.length;
 	}
 
 	public ParameterInfo getOrdinalParameterInfo(int ordinalPosition) {
 		// remember that ordinal parameters numbers are 1-based!!!
 		return ordinalParameters[ordinalPosition - 1];
 	}
 
 	public int getOrdinalParameterSqlLocation(int ordinalPosition) {
 		return getOrdinalParameterInfo( ordinalPosition ).getSqlLocations()[0];
 	}
 
 	public Type getOrdinalParameterExpectedType(int ordinalPosition) {
 		return getOrdinalParameterInfo( ordinalPosition ).getExpectedType();
 	}
 
 	public Set getNamedParameterNames() {
 		return namedParameters.keySet();
 	}
 
 	public ParameterInfo getNamedParameterInfo(String name) {
 		return ( ParameterInfo ) namedParameters.get( name );
 	}
 
 	public int[] getNamedParameterSqlLocations(String name) {
 		return getNamedParameterInfo( name ).getSqlLocations();
 	}
 
 	public Type getNamedParameterExpectedType(String name) {
 		return getNamedParameterInfo( name ).getExpectedType();
 	}
 
 	/**
 	 * Constructs a parameter metadata object given a list of parameter
 	 * specifications.
 	 * </p>
 	 * Note: the order in the incoming list denotes the parameter's
 	 * psudeo-position within the resulting sql statement.
 	 *
 	 * @param parameterSpecifications
 	 */
 	public ParameterTranslationsImpl(List parameterSpecifications) {
 
 		class NamedParamTempHolder {
 			String name;
 			Type type;
 			List positions = new ArrayList();
 		}
 
 		int size = parameterSpecifications.size();
 		List ordinalParameterList = new ArrayList();
 		Map namedParameterMap = new HashMap();
 		for ( int i = 0; i < size; i++ ) {
 			final ParameterSpecification spec = ( ParameterSpecification ) parameterSpecifications.get( i );
 			if ( PositionalParameterSpecification.class.isAssignableFrom( spec.getClass() ) ) {
 				PositionalParameterSpecification ordinalSpec = ( PositionalParameterSpecification ) spec;
 				ordinalParameterList.add( new ParameterInfo( i, ordinalSpec.getExpectedType() ) );
 			}
 			else if ( NamedParameterSpecification.class.isAssignableFrom( spec.getClass() ) ) {
 				NamedParameterSpecification namedSpec = ( NamedParameterSpecification ) spec;
 				NamedParamTempHolder paramHolder = ( NamedParamTempHolder ) namedParameterMap.get( namedSpec.getName() );
 				if ( paramHolder == null ) {
 					paramHolder = new NamedParamTempHolder();
 					paramHolder.name = namedSpec.getName();
 					paramHolder.type = namedSpec.getExpectedType();
 					namedParameterMap.put( namedSpec.getName(), paramHolder );
 				}
 				paramHolder.positions.add( new Integer( i ) );
 			}
 			else {
 				// don't care about other param types here, just those explicitly user-defined...
 			}
 		}
 
 		ordinalParameters = ( ParameterInfo[] ) ordinalParameterList.toArray( new ParameterInfo[ordinalParameterList.size()] );
 
 		if ( namedParameterMap.isEmpty() ) {
 			namedParameters = java.util.Collections.EMPTY_MAP;
 		}
 		else {
 			Map namedParametersBacking = new HashMap( namedParameterMap.size() );
 			Iterator itr = namedParameterMap.values().iterator();
 			while( itr.hasNext() ) {
 				final NamedParamTempHolder holder = ( NamedParamTempHolder ) itr.next();
 				namedParametersBacking.put(
 						holder.name,
 				        new ParameterInfo( ArrayHelper.toIntArray( holder.positions ), holder.type )
 				);
 			}
 			namedParameters = java.util.Collections.unmodifiableMap( namedParametersBacking );
 		}
 	}
 
 	public static class ParameterInfo implements Serializable {
 		private final int[] sqlLocations;
 		private final Type expectedType;
 
 		public ParameterInfo(int[] sqlPositions, Type expectedType) {
 			this.sqlLocations = sqlPositions;
 			this.expectedType = expectedType;
 		}
 
 		public ParameterInfo(int sqlPosition, Type expectedType) {
 			this.sqlLocations = new int[] { sqlPosition };
 			this.expectedType = expectedType;
 		}
 
 		public int[] getSqlLocations() {
 			return sqlLocations;
 		}
 
 		public Type getExpectedType() {
 			return expectedType;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/ParseErrorHandler.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ParseErrorHandler.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/ParseErrorHandler.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ParseErrorHandler.java
index 9583aa37df..016755da62 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/ParseErrorHandler.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/ParseErrorHandler.java
@@ -1,42 +1,42 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 import org.hibernate.QueryException;
 
 
 /**
  * Defines the behavior of an error handler for the HQL parsers.
  * User: josh
  * Date: Dec 6, 2003
  * Time: 12:20:43 PM
  */
 public interface ParseErrorHandler extends ErrorReporter {
 
 	int getErrorCount();
 
 	// --Commented out by Inspection (12/11/04 10:56 AM): int getWarningCount();
 
 	void throwQueryException() throws QueryException;
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/QuerySyntaxException.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/QuerySyntaxException.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/QuerySyntaxException.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/QuerySyntaxException.java
index 7f01204d48..7b103c3393 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/QuerySyntaxException.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/QuerySyntaxException.java
@@ -1,56 +1,56 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 import org.hibernate.QueryException;
 import antlr.RecognitionException;
 
 /**
  * Exception thrown when there is a syntax error in the HQL.
  *
  * @author josh
  */
 public class QuerySyntaxException extends QueryException {
 
 	public QuerySyntaxException(String message) {
 		super( message );
 	}
 
 	public QuerySyntaxException(String message, String hql) {
 		this( message );
 		setQueryString( hql );
 	}
 
 	public static QuerySyntaxException convert(RecognitionException e) {
 		return convert( e, null );
 	}
 
 	public static QuerySyntaxException convert(RecognitionException e, String hql) {
 		String positionInfo = e.getLine() > 0 && e.getColumn() > 0
 				? " near line " + e.getLine() + ", column " + e.getColumn()
 				: "";
 		return new QuerySyntaxException( e.getMessage() + positionInfo, hql );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/QueryTranslatorImpl.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/QueryTranslatorImpl.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/QueryTranslatorImpl.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/QueryTranslatorImpl.java
index de43b6e5dd..bc64eedf17 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/QueryTranslatorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/QueryTranslatorImpl.java
@@ -1,600 +1,600 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import antlr.ANTLRException;
 import antlr.RecognitionException;
 import antlr.TokenStreamException;
 import antlr.collections.AST;
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.hql.internal.QueryExecutionRequestException;
+import org.hibernate.hql.spi.ParameterTranslations;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.spi.EventSource;
-import org.hibernate.hql.FilterTranslator;
-import org.hibernate.hql.ParameterTranslations;
-import org.hibernate.hql.QueryExecutionRequestException;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.antlr.HqlTokenTypes;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.exec.BasicExecutor;
-import org.hibernate.hql.ast.exec.MultiTableDeleteExecutor;
-import org.hibernate.hql.ast.exec.MultiTableUpdateExecutor;
-import org.hibernate.hql.ast.exec.StatementExecutor;
-import org.hibernate.hql.ast.tree.AggregatedSelectExpression;
-import org.hibernate.hql.ast.tree.FromElement;
-import org.hibernate.hql.ast.tree.InsertStatement;
-import org.hibernate.hql.ast.tree.QueryNode;
-import org.hibernate.hql.ast.tree.Statement;
-import org.hibernate.hql.ast.util.ASTPrinter;
-import org.hibernate.hql.ast.util.ASTUtil;
-import org.hibernate.hql.ast.util.NodeTraverser;
+import org.hibernate.hql.spi.FilterTranslator;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.antlr.HqlTokenTypes;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.exec.BasicExecutor;
+import org.hibernate.hql.internal.ast.exec.MultiTableDeleteExecutor;
+import org.hibernate.hql.internal.ast.exec.MultiTableUpdateExecutor;
+import org.hibernate.hql.internal.ast.exec.StatementExecutor;
+import org.hibernate.hql.internal.ast.tree.AggregatedSelectExpression;
+import org.hibernate.hql.internal.ast.tree.FromElement;
+import org.hibernate.hql.internal.ast.tree.InsertStatement;
+import org.hibernate.hql.internal.ast.tree.QueryNode;
+import org.hibernate.hql.internal.ast.tree.Statement;
+import org.hibernate.hql.internal.ast.util.ASTPrinter;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
+import org.hibernate.hql.internal.ast.util.NodeTraverser;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.IdentitySet;
 import org.hibernate.loader.hql.QueryLoader;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.type.Type;
 
 /**
  * A QueryTranslator that uses an Antlr-based parser.
  *
  * @author Joshua Davis (pgmjsd@sourceforge.net)
  */
 public class QueryTranslatorImpl implements FilterTranslator {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, QueryTranslatorImpl.class.getName());
 
 	private SessionFactoryImplementor factory;
 
 	private final String queryIdentifier;
 	private String hql;
 	private boolean shallowQuery;
 	private Map tokenReplacements;
 
 	private Map enabledFilters; //TODO:this is only needed during compilation .. can we eliminate the instvar?
 
 	private boolean compiled;
 	private QueryLoader queryLoader;
 	private StatementExecutor statementExecutor;
 
 	private Statement sqlAst;
 	private String sql;
 
 	private ParameterTranslations paramTranslations;
 	private List collectedParameterSpecifications;
 
 
 	/**
 	 * Creates a new AST-based query translator.
 	 *
 	 * @param queryIdentifier The query-identifier (used in stats collection)
 	 * @param query The hql query to translate
 	 * @param enabledFilters Currently enabled filters
 	 * @param factory The session factory constructing this translator instance.
 	 */
 	public QueryTranslatorImpl(
 			String queryIdentifier,
 	        String query,
 	        Map enabledFilters,
 	        SessionFactoryImplementor factory) {
 		this.queryIdentifier = queryIdentifier;
 		this.hql = query;
 		this.compiled = false;
 		this.shallowQuery = false;
 		this.enabledFilters = enabledFilters;
 		this.factory = factory;
 	}
 
 	/**
 	 * Compile a "normal" query. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 *
 	 * @param replacements Defined query substitutions.
 	 * @param shallow      Does this represent a shallow (scalar or entity-id) select?
 	 * @throws QueryException   There was a problem parsing the query string.
 	 * @throws MappingException There was a problem querying defined mappings.
 	 */
 	public void compile(
 	        Map replacements,
 	        boolean shallow) throws QueryException, MappingException {
 		doCompile( replacements, shallow, null );
 	}
 
 	/**
 	 * Compile a filter. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 *
 	 * @param collectionRole the role name of the collection used as the basis for the filter.
 	 * @param replacements   Defined query substitutions.
 	 * @param shallow        Does this represent a shallow (scalar or entity-id) select?
 	 * @throws QueryException   There was a problem parsing the query string.
 	 * @throws MappingException There was a problem querying defined mappings.
 	 */
 	public void compile(
 	        String collectionRole,
 	        Map replacements,
 	        boolean shallow) throws QueryException, MappingException {
 		doCompile( replacements, shallow, collectionRole );
 	}
 
 	/**
 	 * Performs both filter and non-filter compiling.
 	 *
 	 * @param replacements   Defined query substitutions.
 	 * @param shallow        Does this represent a shallow (scalar or entity-id) select?
 	 * @param collectionRole the role name of the collection used as the basis for the filter, NULL if this
 	 *                       is not a filter.
 	 */
 	private synchronized void doCompile(Map replacements, boolean shallow, String collectionRole) {
 		// If the query is already compiled, skip the compilation.
 		if ( compiled ) {
             LOG.debugf("compile() : The query is already compiled, skipping...");
 			return;
 		}
 
 		// Remember the parameters for the compilation.
 		this.tokenReplacements = replacements;
 		if ( tokenReplacements == null ) {
 			tokenReplacements = new HashMap();
 		}
 		this.shallowQuery = shallow;
 
 		try {
 			// PHASE 1 : Parse the HQL into an AST.
 			HqlParser parser = parse( true );
 
 			// PHASE 2 : Analyze the HQL AST, and produce an SQL AST.
 			HqlSqlWalker w = analyze( parser, collectionRole );
 
 			sqlAst = ( Statement ) w.getAST();
 
 			// at some point the generate phase needs to be moved out of here,
 			// because a single object-level DML might spawn multiple SQL DML
 			// command executions.
 			//
 			// Possible to just move the sql generation for dml stuff, but for
 			// consistency-sake probably best to just move responsiblity for
 			// the generation phase completely into the delegates
 			// (QueryLoader/StatementExecutor) themselves.  Also, not sure why
 			// QueryLoader currently even has a dependency on this at all; does
 			// it need it?  Ideally like to see the walker itself given to the delegates directly...
 
 			if ( sqlAst.needsExecutor() ) {
 				statementExecutor = buildAppropriateStatementExecutor( w );
 			}
 			else {
 				// PHASE 3 : Generate the SQL.
 				generate( ( QueryNode ) sqlAst );
 				queryLoader = new QueryLoader( this, factory, w.getSelectClause() );
 			}
 
 			compiled = true;
 		}
 		catch ( QueryException qe ) {
 			qe.setQueryString( hql );
 			throw qe;
 		}
 		catch ( RecognitionException e ) {
             // we do not actually propagate ANTLRExceptions as a cause, so
 			// log it here for diagnostic purposes
             LOG.trace("Converted antlr.RecognitionException", e);
 			throw QuerySyntaxException.convert( e, hql );
 		}
 		catch ( ANTLRException e ) {
             // we do not actually propagate ANTLRExceptions as a cause, so
 			// log it here for diagnostic purposes
             LOG.trace("Converted antlr.ANTLRException", e);
 			throw new QueryException( e.getMessage(), hql );
 		}
 
 		this.enabledFilters = null; //only needed during compilation phase...
 	}
 
 	private void generate(AST sqlAst) throws QueryException, RecognitionException {
 		if ( sql == null ) {
 			SqlGenerator gen = new SqlGenerator(factory);
 			gen.statement( sqlAst );
 			sql = gen.getSQL();
             if (LOG.isDebugEnabled()) {
                 LOG.debugf("HQL: %s", hql);
                 LOG.debugf("SQL: %s", sql);
 			}
 			gen.getParseErrorHandler().throwQueryException();
 			collectedParameterSpecifications = gen.getCollectedParameters();
 		}
 	}
 
 	private HqlSqlWalker analyze(HqlParser parser, String collectionRole) throws QueryException, RecognitionException {
 		HqlSqlWalker w = new HqlSqlWalker( this, factory, parser, tokenReplacements, collectionRole );
 		AST hqlAst = parser.getAST();
 
 		// Transform the tree.
 		w.statement( hqlAst );
 
         if (LOG.isDebugEnabled()) {
 			ASTPrinter printer = new ASTPrinter( SqlTokenTypes.class );
             LOG.debug( printer.showAsString( w.getAST(), "--- SQL AST ---" ) );
 		}
 
 		w.getParseErrorHandler().throwQueryException();
 
 		return w;
 	}
 
 	private HqlParser parse(boolean filter) throws TokenStreamException, RecognitionException {
 		// Parse the query string into an HQL AST.
 		HqlParser parser = HqlParser.getInstance( hql );
 		parser.setFilter( filter );
 
         LOG.debugf("parse() - HQL: %s", hql);
 		parser.statement();
 
 		AST hqlAst = parser.getAST();
 
 		JavaConstantConverter converter = new JavaConstantConverter();
 		NodeTraverser walker = new NodeTraverser( converter );
 		walker.traverseDepthFirst( hqlAst );
 
 		showHqlAst( hqlAst );
 
 		parser.getParseErrorHandler().throwQueryException();
 		return parser;
 	}
 
 	void showHqlAst(AST hqlAst) {
         if (LOG.isDebugEnabled()) {
 			ASTPrinter printer = new ASTPrinter( HqlTokenTypes.class );
             LOG.debug( printer.showAsString( hqlAst, "--- HQL AST ---" ) );
 		}
 	}
 
 	private void errorIfDML() throws HibernateException {
 		if ( sqlAst.needsExecutor() ) {
 			throw new QueryExecutionRequestException( "Not supported for DML operations", hql );
 		}
 	}
 
 	private void errorIfSelect() throws HibernateException {
 		if ( !sqlAst.needsExecutor() ) {
 			throw new QueryExecutionRequestException( "Not supported for select queries", hql );
 		}
 	}
 
 	public String getQueryIdentifier() {
 		return queryIdentifier;
 	}
 
 	public Statement getSqlAST() {
 		return sqlAst;
 	}
 
 	private HqlSqlWalker getWalker() {
 		return sqlAst.getWalker();
 	}
 
 	/**
 	 * Types of the return values of an <tt>iterate()</tt> style query.
 	 *
 	 * @return an array of <tt>Type</tt>s.
 	 */
 	public Type[] getReturnTypes() {
 		errorIfDML();
 		return getWalker().getReturnTypes();
 	}
 
 	public String[] getReturnAliases() {
 		errorIfDML();
 		return getWalker().getReturnAliases();
 	}
 
 	public String[][] getColumnNames() {
 		errorIfDML();
 		return getWalker().getSelectClause().getColumnNames();
 	}
 
 	public Set getQuerySpaces() {
 		return getWalker().getQuerySpaces();
 	}
 
 	public List list(SessionImplementor session, QueryParameters queryParameters)
 			throws HibernateException {
 		// Delegate to the QueryLoader...
 		errorIfDML();
 		QueryNode query = ( QueryNode ) sqlAst;
 		boolean hasLimit = queryParameters.getRowSelection() != null && queryParameters.getRowSelection().definesLimits();
 		boolean needsDistincting = ( query.getSelectClause().isDistinct() || hasLimit ) && containsCollectionFetches();
 
 		QueryParameters queryParametersToUse;
 		if ( hasLimit && containsCollectionFetches() ) {
             LOG.firstOrMaxResultsSpecifiedWithCollectionFetch();
 			RowSelection selection = new RowSelection();
 			selection.setFetchSize( queryParameters.getRowSelection().getFetchSize() );
 			selection.setTimeout( queryParameters.getRowSelection().getTimeout() );
 			queryParametersToUse = queryParameters.createCopyUsing( selection );
 		}
 		else {
 			queryParametersToUse = queryParameters;
 		}
 
 		List results = queryLoader.list( session, queryParametersToUse );
 
 		if ( needsDistincting ) {
 			int includedCount = -1;
 			// NOTE : firstRow is zero-based
 			int first = !hasLimit || queryParameters.getRowSelection().getFirstRow() == null
 						? 0
 						: queryParameters.getRowSelection().getFirstRow().intValue();
 			int max = !hasLimit || queryParameters.getRowSelection().getMaxRows() == null
 						? -1
 						: queryParameters.getRowSelection().getMaxRows().intValue();
 			int size = results.size();
 			List tmp = new ArrayList();
 			IdentitySet distinction = new IdentitySet();
 			for ( int i = 0; i < size; i++ ) {
 				final Object result = results.get( i );
 				if ( !distinction.add( result ) ) {
 					continue;
 				}
 				includedCount++;
 				if ( includedCount < first ) {
 					continue;
 				}
 				tmp.add( result );
 				// NOTE : ( max - 1 ) because first is zero-based while max is not...
 				if ( max >= 0 && ( includedCount - first ) >= ( max - 1 ) ) {
 					break;
 				}
 			}
 			results = tmp;
 		}
 
 		return results;
 	}
 
 	/**
 	 * Return the query results as an iterator
 	 */
 	public Iterator iterate(QueryParameters queryParameters, EventSource session)
 			throws HibernateException {
 		// Delegate to the QueryLoader...
 		errorIfDML();
 		return queryLoader.iterate( queryParameters, session );
 	}
 
 	/**
 	 * Return the query results, as an instance of <tt>ScrollableResults</tt>
 	 */
 	public ScrollableResults scroll(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException {
 		// Delegate to the QueryLoader...
 		errorIfDML();
 		return queryLoader.scroll( queryParameters, session );
 	}
 
 	public int executeUpdate(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException {
 		errorIfSelect();
 		return statementExecutor.execute( queryParameters, session );
 	}
 
 	/**
 	 * The SQL query string to be called; implemented by all subclasses
 	 */
 	public String getSQLString() {
 		return sql;
 	}
 
 	public List collectSqlStrings() {
 		ArrayList list = new ArrayList();
 		if ( isManipulationStatement() ) {
 			String[] sqlStatements = statementExecutor.getSqlStatements();
 			for ( int i = 0; i < sqlStatements.length; i++ ) {
 				list.add( sqlStatements[i] );
 			}
 		}
 		else {
 			list.add( sql );
 		}
 		return list;
 	}
 
 	// -- Package local methods for the QueryLoader delegate --
 
 	public boolean isShallowQuery() {
 		return shallowQuery;
 	}
 
 	public String getQueryString() {
 		return hql;
 	}
 
 	public Map getEnabledFilters() {
 		return enabledFilters;
 	}
 
 	public int[] getNamedParameterLocs(String name) {
 		return getWalker().getNamedParameterLocations( name );
 	}
 
 	public boolean containsCollectionFetches() {
 		errorIfDML();
 		List collectionFetches = ( ( QueryNode ) sqlAst ).getFromClause().getCollectionFetches();
 		return collectionFetches != null && collectionFetches.size() > 0;
 	}
 
 	public boolean isManipulationStatement() {
 		return sqlAst.needsExecutor();
 	}
 
 	public void validateScrollability() throws HibernateException {
 		// Impl Note: allows multiple collection fetches as long as the
 		// entire fecthed graph still "points back" to a single
 		// root entity for return
 
 		errorIfDML();
 
 		QueryNode query = ( QueryNode ) sqlAst;
 
 		// If there are no collection fetches, then no further checks are needed
 		List collectionFetches = query.getFromClause().getCollectionFetches();
 		if ( collectionFetches.isEmpty() ) {
 			return;
 		}
 
 		// A shallow query is ok (although technically there should be no fetching here...)
 		if ( isShallowQuery() ) {
 			return;
 		}
 
 		// Otherwise, we have a non-scalar select with defined collection fetch(es).
 		// Make sure that there is only a single root entity in the return (no tuples)
 		if ( getReturnTypes().length > 1 ) {
 			throw new HibernateException( "cannot scroll with collection fetches and returned tuples" );
 		}
 
 		FromElement owner = null;
 		Iterator itr = query.getSelectClause().getFromElementsForLoad().iterator();
 		while ( itr.hasNext() ) {
 			// should be the first, but just to be safe...
 			final FromElement fromElement = ( FromElement ) itr.next();
 			if ( fromElement.getOrigin() == null ) {
 				owner = fromElement;
 				break;
 			}
 		}
 
 		if ( owner == null ) {
 			throw new HibernateException( "unable to locate collection fetch(es) owner for scrollability checks" );
 		}
 
 		// This is not strictly true.  We actually just need to make sure that
 		// it is ordered by root-entity PK and that that order-by comes before
 		// any non-root-entity ordering...
 
 		AST primaryOrdering = query.getOrderByClause().getFirstChild();
 		if ( primaryOrdering != null ) {
 			// TODO : this is a bit dodgy, come up with a better way to check this (plus see above comment)
 			String [] idColNames = owner.getQueryable().getIdentifierColumnNames();
 			String expectedPrimaryOrderSeq = StringHelper.join(
 			        ", ",
 			        StringHelper.qualify( owner.getTableAlias(), idColNames )
 			);
 			if (  !primaryOrdering.getText().startsWith( expectedPrimaryOrderSeq ) ) {
 				throw new HibernateException( "cannot scroll results with collection fetches which are not ordered primarily by the root entity's PK" );
 			}
 		}
 	}
 
 	private StatementExecutor buildAppropriateStatementExecutor(HqlSqlWalker walker) {
 		Statement statement = ( Statement ) walker.getAST();
 		if ( walker.getStatementType() == HqlSqlTokenTypes.DELETE ) {
 			FromElement fromElement = walker.getFinalFromClause().getFromElement();
 			Queryable persister = fromElement.getQueryable();
 			if ( persister.isMultiTable() ) {
 				return new MultiTableDeleteExecutor( walker );
 			}
 			else {
 				return new BasicExecutor( walker, persister );
 			}
 		}
 		else if ( walker.getStatementType() == HqlSqlTokenTypes.UPDATE ) {
 			FromElement fromElement = walker.getFinalFromClause().getFromElement();
 			Queryable persister = fromElement.getQueryable();
 			if ( persister.isMultiTable() ) {
 				// even here, if only properties mapped to the "base table" are referenced
 				// in the set and where clauses, this could be handled by the BasicDelegate.
 				// TODO : decide if it is better performance-wise to doAfterTransactionCompletion that check, or to simply use the MultiTableUpdateDelegate
 				return new MultiTableUpdateExecutor( walker );
 			}
 			else {
 				return new BasicExecutor( walker, persister );
 			}
 		}
 		else if ( walker.getStatementType() == HqlSqlTokenTypes.INSERT ) {
 			return new BasicExecutor( walker, ( ( InsertStatement ) statement ).getIntoClause().getQueryable() );
 		}
 		else {
 			throw new QueryException( "Unexpected statement type" );
 		}
 	}
 
 	public ParameterTranslations getParameterTranslations() {
 		if ( paramTranslations == null ) {
 			paramTranslations = new ParameterTranslationsImpl( getWalker().getParameters() );
 //			paramTranslations = new ParameterTranslationsImpl( collectedParameterSpecifications );
 		}
 		return paramTranslations;
 	}
 
 	public List getCollectedParameterSpecifications() {
 		return collectedParameterSpecifications;
 	}
 
 	@Override
 	public Class getDynamicInstantiationResultType() {
 		AggregatedSelectExpression aggregation = queryLoader.getAggregatedSelectExpression();
 		return aggregation == null ? null : aggregation.getAggregationResultType();
 	}
 
 	public static class JavaConstantConverter implements NodeTraverser.VisitationStrategy {
 		private AST dotRoot;
 		public void visit(AST node) {
 			if ( dotRoot != null ) {
 				// we are already processing a dot-structure
                 if (ASTUtil.isSubtreeChild(dotRoot, node)) return;
                 // we are now at a new tree level
                 dotRoot = null;
 			}
 
 			if ( dotRoot == null && node.getType() == HqlTokenTypes.DOT ) {
 				dotRoot = node;
 				handleDotStructure( dotRoot );
 			}
 		}
 		private void handleDotStructure(AST dotStructureRoot) {
 			String expression = ASTUtil.getPathText( dotStructureRoot );
 			Object constant = ReflectHelper.getConstantValue( expression );
 			if ( constant != null ) {
 				dotStructureRoot.setFirstChild( null );
 				dotStructureRoot.setType( HqlTokenTypes.JAVA_CONSTANT );
 				dotStructureRoot.setText( expression );
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/SqlASTFactory.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/SqlASTFactory.java
similarity index 70%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/SqlASTFactory.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/SqlASTFactory.java
index 0bdd7ab930..54a28d4128 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/SqlASTFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/SqlASTFactory.java
@@ -1,264 +1,264 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 import java.lang.reflect.Constructor;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.ast.tree.AggregateNode;
-import org.hibernate.hql.ast.tree.BetweenOperatorNode;
-import org.hibernate.hql.ast.tree.BinaryArithmeticOperatorNode;
-import org.hibernate.hql.ast.tree.BinaryLogicOperatorNode;
-import org.hibernate.hql.ast.tree.BooleanLiteralNode;
-import org.hibernate.hql.ast.tree.Case2Node;
-import org.hibernate.hql.ast.tree.CaseNode;
-import org.hibernate.hql.ast.tree.CollectionFunction;
-import org.hibernate.hql.ast.tree.ConstructorNode;
-import org.hibernate.hql.ast.tree.CountNode;
-import org.hibernate.hql.ast.tree.DeleteStatement;
-import org.hibernate.hql.ast.tree.DotNode;
-import org.hibernate.hql.ast.tree.FromClause;
-import org.hibernate.hql.ast.tree.FromElement;
-import org.hibernate.hql.ast.tree.IdentNode;
-import org.hibernate.hql.ast.tree.ImpliedFromElement;
-import org.hibernate.hql.ast.tree.InLogicOperatorNode;
-import org.hibernate.hql.ast.tree.IndexNode;
-import org.hibernate.hql.ast.tree.InitializeableNode;
-import org.hibernate.hql.ast.tree.InsertStatement;
-import org.hibernate.hql.ast.tree.IntoClause;
-import org.hibernate.hql.ast.tree.IsNotNullLogicOperatorNode;
-import org.hibernate.hql.ast.tree.IsNullLogicOperatorNode;
-import org.hibernate.hql.ast.tree.JavaConstantNode;
-import org.hibernate.hql.ast.tree.LiteralNode;
-import org.hibernate.hql.ast.tree.MapEntryNode;
-import org.hibernate.hql.ast.tree.MapKeyNode;
-import org.hibernate.hql.ast.tree.MapValueNode;
-import org.hibernate.hql.ast.tree.MethodNode;
-import org.hibernate.hql.ast.tree.OrderByClause;
-import org.hibernate.hql.ast.tree.ParameterNode;
-import org.hibernate.hql.ast.tree.QueryNode;
-import org.hibernate.hql.ast.tree.ResultVariableRefNode;
-import org.hibernate.hql.ast.tree.SelectClause;
-import org.hibernate.hql.ast.tree.SelectExpressionImpl;
-import org.hibernate.hql.ast.tree.SessionFactoryAwareNode;
-import org.hibernate.hql.ast.tree.SqlFragment;
-import org.hibernate.hql.ast.tree.SqlNode;
-import org.hibernate.hql.ast.tree.UnaryArithmeticNode;
-import org.hibernate.hql.ast.tree.UnaryLogicOperatorNode;
-import org.hibernate.hql.ast.tree.UpdateStatement;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.ast.tree.AggregateNode;
+import org.hibernate.hql.internal.ast.tree.BetweenOperatorNode;
+import org.hibernate.hql.internal.ast.tree.BinaryArithmeticOperatorNode;
+import org.hibernate.hql.internal.ast.tree.BinaryLogicOperatorNode;
+import org.hibernate.hql.internal.ast.tree.BooleanLiteralNode;
+import org.hibernate.hql.internal.ast.tree.Case2Node;
+import org.hibernate.hql.internal.ast.tree.CaseNode;
+import org.hibernate.hql.internal.ast.tree.CollectionFunction;
+import org.hibernate.hql.internal.ast.tree.ConstructorNode;
+import org.hibernate.hql.internal.ast.tree.CountNode;
+import org.hibernate.hql.internal.ast.tree.DeleteStatement;
+import org.hibernate.hql.internal.ast.tree.DotNode;
+import org.hibernate.hql.internal.ast.tree.FromClause;
+import org.hibernate.hql.internal.ast.tree.FromElement;
+import org.hibernate.hql.internal.ast.tree.IdentNode;
+import org.hibernate.hql.internal.ast.tree.ImpliedFromElement;
+import org.hibernate.hql.internal.ast.tree.InLogicOperatorNode;
+import org.hibernate.hql.internal.ast.tree.IndexNode;
+import org.hibernate.hql.internal.ast.tree.InitializeableNode;
+import org.hibernate.hql.internal.ast.tree.InsertStatement;
+import org.hibernate.hql.internal.ast.tree.IntoClause;
+import org.hibernate.hql.internal.ast.tree.IsNotNullLogicOperatorNode;
+import org.hibernate.hql.internal.ast.tree.IsNullLogicOperatorNode;
+import org.hibernate.hql.internal.ast.tree.JavaConstantNode;
+import org.hibernate.hql.internal.ast.tree.LiteralNode;
+import org.hibernate.hql.internal.ast.tree.MapEntryNode;
+import org.hibernate.hql.internal.ast.tree.MapKeyNode;
+import org.hibernate.hql.internal.ast.tree.MapValueNode;
+import org.hibernate.hql.internal.ast.tree.MethodNode;
+import org.hibernate.hql.internal.ast.tree.OrderByClause;
+import org.hibernate.hql.internal.ast.tree.ParameterNode;
+import org.hibernate.hql.internal.ast.tree.QueryNode;
+import org.hibernate.hql.internal.ast.tree.ResultVariableRefNode;
+import org.hibernate.hql.internal.ast.tree.SelectClause;
+import org.hibernate.hql.internal.ast.tree.SelectExpressionImpl;
+import org.hibernate.hql.internal.ast.tree.SessionFactoryAwareNode;
+import org.hibernate.hql.internal.ast.tree.SqlFragment;
+import org.hibernate.hql.internal.ast.tree.SqlNode;
+import org.hibernate.hql.internal.ast.tree.UnaryArithmeticNode;
+import org.hibernate.hql.internal.ast.tree.UnaryLogicOperatorNode;
+import org.hibernate.hql.internal.ast.tree.UpdateStatement;
 import antlr.ASTFactory;
 import antlr.Token;
 import antlr.collections.AST;
 
 /**
  * Custom AST factory the intermediate tree that causes ANTLR to create specialized
  * AST nodes, given the AST node type (from HqlSqlTokenTypes).   HqlSqlWalker registers
  * this factory with itself when it is initialized.
  *
  * @author Joshua
  */
 public class SqlASTFactory extends ASTFactory implements HqlSqlTokenTypes {
 	private HqlSqlWalker walker;
 
 	/**
 	 * Create factory with a specific mapping from token type
 	 * to Java AST node type.  Your subclasses of ASTFactory
 	 * can override and reuse the map stuff.
 	 */
 	public SqlASTFactory(HqlSqlWalker walker) {
 		super();
 		this.walker = walker;
 	}
 
 	/**
 	 * Returns the class for a given token type (a.k.a. AST node type).
 	 *
 	 * @param tokenType The token type.
 	 * @return Class - The AST node class to instantiate.
 	 */
 	public Class getASTNodeType(int tokenType) {
 		switch ( tokenType ) {
 			case SELECT:
 			case QUERY:
 				return QueryNode.class;
 			case UPDATE:
 				return UpdateStatement.class;
 			case DELETE:
 				return DeleteStatement.class;
 			case INSERT:
 				return InsertStatement.class;
 			case INTO:
 				return IntoClause.class;
 			case FROM:
 				return FromClause.class;
 			case FROM_FRAGMENT:
 				return FromElement.class;
 			case IMPLIED_FROM:
 				return ImpliedFromElement.class;
 			case DOT:
 				return DotNode.class;
 			case INDEX_OP:
 				return IndexNode.class;
 				// Alias references and identifiers use the same node class.
 			case ALIAS_REF:
 			case IDENT:
 				return IdentNode.class;
 			case RESULT_VARIABLE_REF:
 				return ResultVariableRefNode.class;
 			case SQL_TOKEN:
 				return SqlFragment.class;
 			case METHOD_CALL:
 				return MethodNode.class;
 			case ELEMENTS:
 			case INDICES:
 				return CollectionFunction.class;
 			case SELECT_CLAUSE:
 				return SelectClause.class;
 			case SELECT_EXPR:
 				return SelectExpressionImpl.class;
 			case AGGREGATE:
 				return AggregateNode.class;
 			case COUNT:
 				return CountNode.class;
 			case CONSTRUCTOR:
 				return ConstructorNode.class;
 			case NUM_INT:
 			case NUM_FLOAT:
 			case NUM_LONG:
 			case NUM_DOUBLE:
 			case NUM_BIG_INTEGER:
 			case NUM_BIG_DECIMAL:
 			case QUOTED_STRING:
 				return LiteralNode.class;
 			case TRUE:
 			case FALSE:
 				return BooleanLiteralNode.class;
 			case JAVA_CONSTANT:
 				return JavaConstantNode.class;
 			case ORDER:
 				return OrderByClause.class;
 			case PLUS:
 			case MINUS:
 			case STAR:
 			case DIV:
 			case MOD:
 				return BinaryArithmeticOperatorNode.class;
 			case UNARY_MINUS:
 			case UNARY_PLUS:
 				return UnaryArithmeticNode.class;
 			case CASE2:
 				return Case2Node.class;
 			case CASE:
 				return CaseNode.class;
 			case PARAM:
 			case NAMED_PARAM:
 				return ParameterNode.class;
 			case EQ:
 			case NE:
 			case LT:
 			case GT:
 			case LE:
 			case GE:
 			case LIKE:
 			case NOT_LIKE:
 				return BinaryLogicOperatorNode.class;
 			case IN:
 			case NOT_IN:
 				return InLogicOperatorNode.class;
 			case BETWEEN:
 			case NOT_BETWEEN:
 				return BetweenOperatorNode.class;
 			case IS_NULL:
 				return IsNullLogicOperatorNode.class;
 			case IS_NOT_NULL:
 				return IsNotNullLogicOperatorNode.class;
 			case EXISTS:
 				return UnaryLogicOperatorNode.class;
 			case KEY: {
 				return MapKeyNode.class;
 			}
 			case VALUE: {
 				return MapValueNode.class;
 			}
 			case ENTRY: {
 				return MapEntryNode.class;
 			}
 			default:
 				return SqlNode.class;
 		} // switch
 	}
 
 	protected AST createUsingCtor(Token token, String className) {
 		Class c;
 		AST t;
 		try {
 			c = Class.forName( className );
 			Class[] tokenArgType = new Class[]{antlr.Token.class};
 			Constructor ctor = c.getConstructor( tokenArgType );
 			if ( ctor != null ) {
 				t = ( AST ) ctor.newInstance( new Object[]{token} ); // make a new one
 				initializeSqlNode( t );
 			}
 			else {
 				// just do the regular thing if you can't find the ctor
 				// Your AST must have default ctor to use this.
 				t = create( c );
 			}
 		}
 		catch ( Exception e ) {
 			throw new IllegalArgumentException( "Invalid class or can't make instance, " + className );
 		}
 		return t;
 	}
 
 	private void initializeSqlNode(AST t) {
 		// Initialize SQL nodes here.
 		if ( t instanceof InitializeableNode ) {
 			InitializeableNode initializeableNode = ( InitializeableNode ) t;
 			initializeableNode.initialize( walker );
 		}
 		if ( t instanceof SessionFactoryAwareNode ) {
 			( ( SessionFactoryAwareNode ) t ).setSessionFactory( walker.getSessionFactoryHelper().getFactory() );
 		}
 	}
 
 	/**
 	 * Actually instantiate the AST node.
 	 *
 	 * @param c The class to instantiate.
 	 * @return The instantiated and initialized node.
 	 */
 	protected AST create(Class c) {
 		AST t;
 		try {
 			t = ( AST ) c.newInstance(); // make a new one
 			initializeSqlNode( t );
 		}
 		catch ( Exception e ) {
 			error( "Can't create AST Node " + c.getName() );
 			return null;
 		}
 		return t;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/SqlGenerator.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/SqlGenerator.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/SqlGenerator.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/SqlGenerator.java
index c2e7fed50f..214509e90b 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/SqlGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/SqlGenerator.java
@@ -1,368 +1,368 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.LinkedList;
 import java.util.List;
 
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.QueryException;
 import org.hibernate.dialect.function.SQLFunction;
-import org.hibernate.hql.antlr.SqlGeneratorBase;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.tree.FromElement;
-import org.hibernate.hql.ast.tree.FunctionNode;
-import org.hibernate.hql.ast.tree.Node;
-import org.hibernate.hql.ast.tree.ParameterContainer;
-import org.hibernate.hql.ast.tree.ParameterNode;
-import org.hibernate.hql.ast.util.ASTPrinter;
+import org.hibernate.hql.internal.antlr.SqlGeneratorBase;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.tree.FromElement;
+import org.hibernate.hql.internal.ast.tree.FunctionNode;
+import org.hibernate.hql.internal.ast.tree.Node;
+import org.hibernate.hql.internal.ast.tree.ParameterContainer;
+import org.hibernate.hql.internal.ast.tree.ParameterNode;
+import org.hibernate.hql.internal.ast.util.ASTPrinter;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 import antlr.RecognitionException;
 import antlr.collections.AST;
 
 /**
  * Generates SQL by overriding callback methods in the base class, which does
  * the actual SQL AST walking.
  *
  * @author Joshua Davis
  * @author Steve Ebersole
  */
 public class SqlGenerator extends SqlGeneratorBase implements ErrorReporter {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, SqlGenerator.class.getName());
 
 	public static boolean REGRESSION_STYLE_CROSS_JOINS = false;
 
 	/**
 	 * all append invocations on the buf should go through this Output instance variable.
 	 * The value of this variable may be temporarily substituted by sql function processing code
 	 * to catch generated arguments.
 	 * This is because sql function templates need arguments as separate string chunks
 	 * that will be assembled into the target dialect-specific function call.
 	 */
 	private SqlWriter writer = new DefaultWriter();
 
 	private ParseErrorHandler parseErrorHandler;
 	private SessionFactoryImplementor sessionFactory;
 	private LinkedList<SqlWriter> outputStack = new LinkedList<SqlWriter>();
 	private final ASTPrinter printer = new ASTPrinter( SqlTokenTypes.class );
 	private List collectedParameters = new ArrayList();
 
 
 	// handle trace logging ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	private int traceDepth = 0;
 
 	@Override
     public void traceIn(String ruleName, AST tree) {
         if (!LOG.isTraceEnabled()) return;
         if (inputState.guessing > 0) return;
 		String prefix = StringHelper.repeat( '-', (traceDepth++ * 2) ) + "-> ";
 		String traceText = ruleName + " (" + buildTraceNodeName(tree) + ")";
         LOG.trace(prefix + traceText);
 	}
 
 	private String buildTraceNodeName(AST tree) {
 		return tree == null
 				? "???"
 				: tree.getText() + " [" + printer.getTokenTypeName( tree.getType() ) + "]";
 	}
 
 	@Override
     public void traceOut(String ruleName, AST tree) {
         if (!LOG.isTraceEnabled()) return;
         if (inputState.guessing > 0) return;
 		String prefix = "<-" + StringHelper.repeat( '-', (--traceDepth * 2) ) + " ";
         LOG.trace(prefix + ruleName);
 	}
 
 	public List getCollectedParameters() {
 		return collectedParameters;
 	}
 
 	@Override
     protected void out(String s) {
 		writer.clause( s );
 	}
 
 	@Override
     protected void out(AST n) {
 		if ( n instanceof Node ) {
 			out( ( ( Node ) n ).getRenderText( sessionFactory ) );
 		}
 		else {
 			super.out( n );
 		}
 
 		if ( n instanceof ParameterNode ) {
 			collectedParameters.add( ( ( ParameterNode ) n ).getHqlParameterSpecification() );
 		}
 		else if ( n instanceof ParameterContainer ) {
 			if ( ( ( ParameterContainer ) n ).hasEmbeddedParameters() ) {
 				ParameterSpecification[] specifications = ( ( ParameterContainer ) n ).getEmbeddedParameters();
 				if ( specifications != null ) {
 					collectedParameters.addAll( Arrays.asList( specifications ) );
 				}
 			}
 		}
 	}
 
 	@Override
     protected void commaBetweenParameters(String comma) {
 		writer.commaBetweenParameters( comma );
 	}
 
 	@Override
     public void reportError(RecognitionException e) {
 		parseErrorHandler.reportError( e ); // Use the delegate.
 	}
 
 	@Override
     public void reportError(String s) {
 		parseErrorHandler.reportError( s ); // Use the delegate.
 	}
 
 	@Override
     public void reportWarning(String s) {
 		parseErrorHandler.reportWarning( s );
 	}
 
 	public ParseErrorHandler getParseErrorHandler() {
 		return parseErrorHandler;
 	}
 
 	public SqlGenerator(SessionFactoryImplementor sfi) {
 		super();
 		parseErrorHandler = new ErrorCounter();
 		sessionFactory = sfi;
 	}
 
 	public String getSQL() {
 		return getStringBuffer().toString();
 	}
 
 	@Override
     protected void optionalSpace() {
 		int c = getLastChar();
 		switch ( c ) {
 			case -1:
 				return;
 			case ' ':
 				return;
 			case ')':
 				return;
 			case '(':
 				return;
 			default:
 				out( " " );
 		}
 	}
 
 	@Override
     protected void beginFunctionTemplate(AST node, AST nameNode) {
 		// NOTE for AGGREGATE both nodes are the same; for METHOD the first is the METHOD, the second is the
 		// 		METHOD_NAME
 		FunctionNode functionNode = ( FunctionNode ) node;
 		SQLFunction sqlFunction = functionNode.getSQLFunction();
 		if ( sqlFunction == null ) {
 			// if SQLFunction is null we just write the function out as it appears in the hql statement
 			super.beginFunctionTemplate( node, nameNode );
 		}
 		else {
 			// this function has a registered SQLFunction -> redirect output and catch the arguments
 			outputStack.addFirst( writer );
 			writer = new FunctionArguments();
 		}
 	}
 
 	@Override
     protected void endFunctionTemplate(AST node) {
 		FunctionNode functionNode = ( FunctionNode ) node;
 		SQLFunction sqlFunction = functionNode.getSQLFunction();
 		if ( sqlFunction == null ) {
 			super.endFunctionTemplate( node );
 		}
 		else {
 			final Type functionType = functionNode.getFirstArgumentType();
 			// this function has a registered SQLFunction -> redirect output and catch the arguments
 			FunctionArguments functionArguments = ( FunctionArguments ) writer;
 			writer = outputStack.removeFirst();
 			out( sqlFunction.render( functionType, functionArguments.getArgs(), sessionFactory ) );
 		}
 	}
 
 	// --- Inner classes (moved here from sql-gen.g) ---
 
 	/**
 	 * Writes SQL fragments.
 	 */
 	interface SqlWriter {
 		void clause(String clause);
 
 		/**
 		 * todo remove this hack
 		 * The parameter is either ", " or " , ". This is needed to pass sql generating tests as the old
 		 * sql generator uses " , " in the WHERE and ", " in SELECT.
 		 *
 		 * @param comma either " , " or ", "
 		 */
 		void commaBetweenParameters(String comma);
 	}
 
 	/**
 	 * SQL function processing code redirects generated SQL output to an instance of this class
 	 * which catches function arguments.
 	 */
 	class FunctionArguments implements SqlWriter {
 		private int argInd;
 		private final List<String> args = new ArrayList<String>(3);
 
 		public void clause(String clause) {
 			if ( argInd == args.size() ) {
 				args.add( clause );
 			}
 			else {
 				args.set( argInd, args.get( argInd ) + clause );
 			}
 		}
 
 		public void commaBetweenParameters(String comma) {
 			++argInd;
 		}
 
 		public List getArgs() {
 			return args;
 		}
 	}
 
 	/**
 	 * The default SQL writer.
 	 */
 	class DefaultWriter implements SqlWriter {
 		public void clause(String clause) {
 			getStringBuffer().append( clause );
 		}
 
 		public void commaBetweenParameters(String comma) {
 			getStringBuffer().append( comma );
 		}
 	}
 
     public static void panic() {
 		throw new QueryException( "TreeWalker: panic" );
 	}
 
 	@Override
     protected void fromFragmentSeparator(AST a) {
 		// check two "adjecent" nodes at the top of the from-clause tree
 		AST next = a.getNextSibling();
 		if ( next == null || !hasText( a ) ) {
 			return;
 		}
 
 		FromElement left = ( FromElement ) a;
 		FromElement right = ( FromElement ) next;
 
 		///////////////////////////////////////////////////////////////////////
 		// HACK ALERT !!!!!!!!!!!!!!!!!!!!!!!!!!!!
 		// Attempt to work around "ghost" ImpliedFromElements that occasionally
 		// show up between the actual things being joined.  This consistently
 		// occurs from index nodes (at least against many-to-many).  Not sure
 		// if there are other conditions
 		//
 		// Essentially, look-ahead to the next FromElement that actually
 		// writes something to the SQL
 		while ( right != null && !hasText( right ) ) {
 			right = ( FromElement ) right.getNextSibling();
 		}
 		if ( right == null ) {
 			return;
 		}
 		///////////////////////////////////////////////////////////////////////
 
 		if ( !hasText( right ) ) {
 			return;
 		}
 
 		if ( right.getRealOrigin() == left ||
 		     ( right.getRealOrigin() != null && right.getRealOrigin() == left.getRealOrigin() ) ) {
 			// right represents a joins originating from left; or
 			// both right and left reprersent joins originating from the same FromElement
 			if ( right.getJoinSequence() != null && right.getJoinSequence().isThetaStyle() ) {
 				writeCrossJoinSeparator();
 			}
 			else {
 				out( " " );
 			}
 		}
 		else {
 			// these are just two unrelated table references
 			writeCrossJoinSeparator();
 		}
 	}
 
 	private void writeCrossJoinSeparator() {
 		if ( REGRESSION_STYLE_CROSS_JOINS ) {
 			out( ", " );
 		}
 		else {
 			out( sessionFactory.getDialect().getCrossJoinSeparator() );
 		}
 	}
 
 	@Override
     protected void nestedFromFragment(AST d, AST parent) {
 		// check a set of parent/child nodes in the from-clause tree
 		// to determine if a comma is required between them
 		if ( d != null && hasText( d ) ) {
 			if ( parent != null && hasText( parent ) ) {
 				// again, both should be FromElements
 				FromElement left = ( FromElement ) parent;
 				FromElement right = ( FromElement ) d;
 				if ( right.getRealOrigin() == left ) {
 					// right represents a joins originating from left...
 					if ( right.getJoinSequence() != null && right.getJoinSequence().isThetaStyle() ) {
 						out( ", " );
 					}
 					else {
 						out( " " );
 					}
 				}
 				else {
 					// not so sure this is even valid subtree.  but if it was, it'd
 					// represent two unrelated table references...
 					out( ", " );
 				}
 			}
 			out( d );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/TypeDiscriminatorMetadata.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/TypeDiscriminatorMetadata.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/TypeDiscriminatorMetadata.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/TypeDiscriminatorMetadata.java
index 3226a181da..6d8f78db16 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/TypeDiscriminatorMetadata.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/TypeDiscriminatorMetadata.java
@@ -1,48 +1,48 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast;
+package org.hibernate.hql.internal.ast;
 import org.hibernate.type.Type;
 
 /**
  * Essentially a wrapper around a {@link org.hibernate.persister.entity.DiscriminatorMetadata}
  * and the proper sql alias to use.
  *
  * @author Steve Ebersole
  */
 public interface TypeDiscriminatorMetadata {
 	/**
 	 * Get the sql fragment that is used to determine the actual discriminator value for a row.
 	 *
 	 * @return The fragment
 	 */
 	public String getSqlFragment();
 
 	/**
 	 * Get the type used to resolve the actual discriminator value resulting from
 	 * {@link #getSqlFragment} back into a {@link Class} reference.
 	 *
 	 * @return The resolution type.
 	 */
 	public Type getResolutionType();
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/AbstractStatementExecutor.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/AbstractStatementExecutor.java
index 5b22a1bdb3..a3d8cdfcbe 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/AbstractStatementExecutor.java
@@ -1,308 +1,308 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.exec;
+package org.hibernate.hql.internal.ast.exec;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.SQLWarning;
 import java.sql.Statement;
 import java.util.Collections;
 import java.util.List;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.action.internal.BulkOperationCleanupAction;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.event.spi.EventSource;
-import org.hibernate.hql.ast.HqlSqlWalker;
-import org.hibernate.hql.ast.SqlGenerator;
+import org.hibernate.hql.internal.ast.HqlSqlWalker;
+import org.hibernate.hql.internal.ast.SqlGenerator;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.jdbc.AbstractWork;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.InsertSelect;
 import org.hibernate.sql.Select;
 import org.hibernate.sql.SelectFragment;
 import org.jboss.logging.Logger;
 import antlr.RecognitionException;
 import antlr.collections.AST;
 
 /**
  * Implementation of AbstractStatementExecutor.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractStatementExecutor implements StatementExecutor {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        AbstractStatementExecutor.class.getName());
 
 	private final HqlSqlWalker walker;
 	private List idSelectParameterSpecifications = Collections.EMPTY_LIST;
 
     public AbstractStatementExecutor( HqlSqlWalker walker,
                                       CoreMessageLogger log ) {
 		this.walker = walker;
 	}
 
 	protected HqlSqlWalker getWalker() {
 		return walker;
 	}
 
 	protected SessionFactoryImplementor getFactory() {
 		return walker.getSessionFactoryHelper().getFactory();
 	}
 
 	protected List getIdSelectParameterSpecifications() {
 		return idSelectParameterSpecifications;
 	}
 
 	protected abstract Queryable[] getAffectedQueryables();
 
 	protected String generateIdInsertSelect(Queryable persister, String tableAlias, AST whereClause) {
 		Select select = new Select( getFactory().getDialect() );
 		SelectFragment selectFragment = new SelectFragment()
 				.addColumns( tableAlias, persister.getIdentifierColumnNames(), persister.getIdentifierColumnNames() );
 		select.setSelectClause( selectFragment.toFragmentString().substring( 2 ) );
 
 		String rootTableName = persister.getTableName();
 		String fromJoinFragment = persister.fromJoinFragment( tableAlias, true, false );
 		String whereJoinFragment = persister.whereJoinFragment( tableAlias, true, false );
 
 		select.setFromClause( rootTableName + ' ' + tableAlias + fromJoinFragment );
 
 		if ( whereJoinFragment == null ) {
 			whereJoinFragment = "";
 		}
 		else {
 			whereJoinFragment = whereJoinFragment.trim();
 			if ( whereJoinFragment.startsWith( "and" ) ) {
 				whereJoinFragment = whereJoinFragment.substring( 4 );
 			}
 		}
 
 		String userWhereClause = "";
 		if ( whereClause.getNumberOfChildren() != 0 ) {
 			// If a where clause was specified in the update/delete query, use it to limit the
 			// returned ids here...
 			try {
 				SqlGenerator sqlGenerator = new SqlGenerator( getFactory() );
 				sqlGenerator.whereClause( whereClause );
 				userWhereClause = sqlGenerator.getSQL().substring( 7 );  // strip the " where "
 				idSelectParameterSpecifications = sqlGenerator.getCollectedParameters();
 			}
 			catch ( RecognitionException e ) {
 				throw new HibernateException( "Unable to generate id select for DML operation", e );
 			}
 			if ( whereJoinFragment.length() > 0 ) {
 				whereJoinFragment += " and ";
 			}
 		}
 
 		select.setWhereClause( whereJoinFragment + userWhereClause );
 
 		InsertSelect insert = new InsertSelect( getFactory().getDialect() );
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			insert.setComment( "insert-select for " + persister.getEntityName() + " ids" );
 		}
 		insert.setTableName( persister.getTemporaryIdTableName() );
 		insert.setSelect( select );
 		return insert.toStatementString();
 	}
 
 	protected String generateIdSubselect(Queryable persister) {
 		return "select " + StringHelper.join( ", ", persister.getIdentifierColumnNames() ) +
 			        " from " + persister.getTemporaryIdTableName();
 	}
 
 	private static class TemporaryTableCreationWork extends AbstractWork {
 		private final Queryable persister;
 
 		private TemporaryTableCreationWork(Queryable persister) {
 			this.persister = persister;
 		}
 
 		@Override
 		public void execute(Connection connection) {
 			try {
 				Statement statement = connection.createStatement();
 				try {
 					statement.executeUpdate( persister.getTemporaryIdTableDDL() );
 					persister.getFactory()
 							.getServiceRegistry()
 							.getService( JdbcServices.class )
 							.getSqlExceptionHelper()
 							.handleAndClearWarnings( statement, CREATION_WARNING_HANDLER );
 				}
 				finally {
 					try {
 						statement.close();
 					}
 					catch( Throwable ignore ) {
 						// ignore
 					}
 				}
 			}
 			catch( Exception e ) {
 				LOG.debug( "unable to create temporary id table [" + e.getMessage() + "]" );
 			}
 		}
 	}
 	protected void createTemporaryTableIfNecessary(final Queryable persister, final SessionImplementor session) {
 		// Don't really know all the codes required to adequately decipher returned jdbc exceptions here.
 		// simply allow the failure to be eaten and the subsequent insert-selects/deletes should fail
 		TemporaryTableCreationWork work = new TemporaryTableCreationWork( persister );
 		if ( shouldIsolateTemporaryTableDDL() ) {
 			session.getTransactionCoordinator()
 					.getTransaction()
 					.createIsolationDelegate()
 					.delegateWork( work, getFactory().getSettings().isDataDefinitionInTransactionSupported() );
 		}
 		else {
 			final Connection connection = session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getLogicalConnection()
 					.getShareableConnectionProxy();
 			work.execute( connection );
 			session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getLogicalConnection()
 					.afterStatementExecution();
 		}
 	}
 
 	private static SqlExceptionHelper.WarningHandler CREATION_WARNING_HANDLER = new SqlExceptionHelper.WarningHandlerLoggingSupport() {
 		public boolean doProcess() {
 			return LOG.isDebugEnabled();
 		}
 
 		public void prepare(SQLWarning warning) {
             LOG.warningsCreatingTempTable(warning);
 		}
 
 		@Override
 		protected void logWarning(String description, String message) {
             LOG.debugf(description);
             LOG.debugf(message);
 		}
 	};
 
 	private static class TemporaryTableDropWork extends AbstractWork {
 		private final Queryable persister;
 		private final SessionImplementor session;
 
 		private TemporaryTableDropWork(Queryable persister, SessionImplementor session) {
 			this.persister = persister;
 			this.session = session;
 		}
 
 		@Override
 		public void execute(Connection connection) {
 			final String command = session.getFactory().getDialect().getDropTemporaryTableString()
 					+ ' ' + persister.getTemporaryIdTableName();
 			try {
 				Statement statement = connection.createStatement();
 				try {
 					statement = connection.createStatement();
 					statement.executeUpdate( command );
 				}
 				finally {
 					try {
 						statement.close();
 					}
 					catch( Throwable ignore ) {
 						// ignore
 					}
 				}
 			}
 			catch( Exception e ) {
 				LOG.warn( "unable to drop temporary id table after use [" + e.getMessage() + "]" );
 			}
 		}
 	}
 
 	protected void dropTemporaryTableIfNecessary(final Queryable persister, final SessionImplementor session) {
 		if ( getFactory().getDialect().dropTemporaryTableAfterUse() ) {
 			TemporaryTableDropWork work = new TemporaryTableDropWork( persister, session );
 			if ( shouldIsolateTemporaryTableDDL() ) {
 				session.getTransactionCoordinator()
 						.getTransaction()
 						.createIsolationDelegate()
 						.delegateWork( work, getFactory().getSettings().isDataDefinitionInTransactionSupported() );
 			}
 			else {
 				final Connection connection = session.getTransactionCoordinator()
 						.getJdbcCoordinator()
 						.getLogicalConnection()
 						.getShareableConnectionProxy();
 				work.execute( connection );
 				session.getTransactionCoordinator()
 						.getJdbcCoordinator()
 						.getLogicalConnection()
 						.afterStatementExecution();
 			}
 		}
 		else {
 			// at the very least cleanup the data :)
 			PreparedStatement ps = null;
 			try {
 				final String sql = "delete from " + persister.getTemporaryIdTableName();
 				ps = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql, false );
 				ps.executeUpdate();
 			}
 			catch( Throwable t ) {
                 LOG.unableToCleanupTemporaryIdTable(t);
 			}
 			finally {
 				if ( ps != null ) {
 					try {
 						ps.close();
 					}
 					catch( Throwable ignore ) {
 						// ignore
 					}
 				}
 			}
 		}
 	}
 
 	protected void coordinateSharedCacheCleanup(SessionImplementor session) {
 		BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getAffectedQueryables() );
 
 		if ( session.isEventSource() ) {
 			( ( EventSource ) session ).getActionQueue().addAction( action );
 		}
 		else {
 			action.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session );
 		}
 	}
 
 	@SuppressWarnings({ "UnnecessaryUnboxing" })
 	protected boolean shouldIsolateTemporaryTableDDL() {
 		Boolean dialectVote = getFactory().getDialect().performTemporaryTableDDLInIsolation();
         if (dialectVote != null) return dialectVote.booleanValue();
         return getFactory().getSettings().isDataDefinitionImplicitCommit();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/BasicExecutor.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/BasicExecutor.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/exec/BasicExecutor.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/BasicExecutor.java
index be0ea1a9f3..f8ad986d4c 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/BasicExecutor.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/BasicExecutor.java
@@ -1,114 +1,114 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.exec;
+package org.hibernate.hql.internal.ast.exec;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.Iterator;
 import java.util.List;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.hql.ast.HqlSqlWalker;
-import org.hibernate.hql.ast.QuerySyntaxException;
-import org.hibernate.hql.ast.SqlGenerator;
+import org.hibernate.hql.internal.ast.HqlSqlWalker;
+import org.hibernate.hql.internal.ast.QuerySyntaxException;
+import org.hibernate.hql.internal.ast.SqlGenerator;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.persister.entity.Queryable;
 import antlr.RecognitionException;
 
 /**
  * Implementation of BasicExecutor.
  *
  * @author Steve Ebersole
  */
 public class BasicExecutor extends AbstractStatementExecutor {
 
 	private final Queryable persister;
 	private final String sql;
 	private final List parameterSpecifications;
 
 	public BasicExecutor(HqlSqlWalker walker, Queryable persister) {
         super(walker, null);
 		this.persister = persister;
 		try {
 			SqlGenerator gen = new SqlGenerator( getFactory() );
 			gen.statement( walker.getAST() );
 			sql = gen.getSQL();
 			gen.getParseErrorHandler().throwQueryException();
 			parameterSpecifications = gen.getCollectedParameters();
 		}
 		catch ( RecognitionException e ) {
 			throw QuerySyntaxException.convert( e );
 		}
 	}
 
 	public String[] getSqlStatements() {
 		return new String[] { sql };
 	}
 
 	public int execute(QueryParameters parameters, SessionImplementor session) throws HibernateException {
 
 		coordinateSharedCacheCleanup( session );
 
 		PreparedStatement st = null;
 		RowSelection selection = parameters.getRowSelection();
 
 		try {
 			try {
 				st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql, false );
 				Iterator parameterSpecifications = this.parameterSpecifications.iterator();
 				int pos = 1;
 				while ( parameterSpecifications.hasNext() ) {
 					final ParameterSpecification paramSpec = ( ParameterSpecification ) parameterSpecifications.next();
 					pos += paramSpec.bind( st, parameters, session, pos );
 				}
 				if ( selection != null ) {
 					if ( selection.getTimeout() != null ) {
 						st.setQueryTimeout( selection.getTimeout().intValue() );
 					}
 				}
 
 				return st.executeUpdate();
 			}
 			finally {
 				if ( st != null ) {
 					st.close();
 				}
 			}
 		}
 		catch( SQLException sqle ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not execute update query",
 			        sql
 				);
 		}
 	}
 
 	@Override
     protected Queryable[] getAffectedQueryables() {
 		return new Queryable[] { persister };
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/MultiTableDeleteExecutor.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/MultiTableDeleteExecutor.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/exec/MultiTableDeleteExecutor.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/MultiTableDeleteExecutor.java
index 8fd1043de6..294b30163e 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/MultiTableDeleteExecutor.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/MultiTableDeleteExecutor.java
@@ -1,164 +1,164 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.exec;
+package org.hibernate.hql.internal.ast.exec;
 
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.Iterator;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.engine.spi.QueryParameters;
-import org.hibernate.hql.ast.HqlSqlWalker;
-import org.hibernate.hql.ast.tree.DeleteStatement;
-import org.hibernate.hql.ast.tree.FromElement;
+import org.hibernate.hql.internal.ast.HqlSqlWalker;
+import org.hibernate.hql.internal.ast.tree.DeleteStatement;
+import org.hibernate.hql.internal.ast.tree.FromElement;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.Delete;
 import org.jboss.logging.Logger;
 
 /**
  * Implementation of MultiTableDeleteExecutor.
  *
  * @author Steve Ebersole
  */
 public class MultiTableDeleteExecutor extends AbstractStatementExecutor {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        MultiTableDeleteExecutor.class.getName());
 
 	private final Queryable persister;
 	private final String idInsertSelect;
 	private final String[] deletes;
 
 	public MultiTableDeleteExecutor(HqlSqlWalker walker) {
         super(walker, null);
 
 		if ( !walker.getSessionFactoryHelper().getFactory().getDialect().supportsTemporaryTables() ) {
 			throw new HibernateException( "cannot doAfterTransactionCompletion multi-table deletes using dialect not supporting temp tables" );
 		}
 
 		DeleteStatement deleteStatement = ( DeleteStatement ) walker.getAST();
 		FromElement fromElement = deleteStatement.getFromClause().getFromElement();
 		String bulkTargetAlias = fromElement.getTableAlias();
 		this.persister = fromElement.getQueryable();
 
 		this.idInsertSelect = generateIdInsertSelect( persister, bulkTargetAlias, deleteStatement.getWhereClause() );
         LOG.trace("Generated ID-INSERT-SELECT SQL (multi-table delete) : " + idInsertSelect);
 
 		String[] tableNames = persister.getConstraintOrderedTableNameClosure();
 		String[][] columnNames = persister.getContraintOrderedTableKeyColumnClosure();
 		String idSubselect = generateIdSubselect( persister );
 
 		deletes = new String[tableNames.length];
 		for ( int i = tableNames.length - 1; i >= 0; i-- ) {
 			// TODO : an optimization here would be to consider cascade deletes and not gen those delete statements;
 			//      the difficulty is the ordering of the tables here vs the cascade attributes on the persisters ->
 			//          the table info gotten here should really be self-contained (i.e., a class representation
 			//          defining all the needed attributes), then we could then get an array of those
 			final Delete delete = new Delete()
 					.setTableName( tableNames[i] )
 					.setWhere( "(" + StringHelper.join( ", ", columnNames[i] ) + ") IN (" + idSubselect + ")" );
 			if ( getFactory().getSettings().isCommentsEnabled() ) {
 				delete.setComment( "bulk delete" );
 			}
 
 			deletes[i] = delete.toStatementString();
 		}
 	}
 
 	public String[] getSqlStatements() {
 		return deletes;
 	}
 
 	public int execute(QueryParameters parameters, SessionImplementor session) throws HibernateException {
 		coordinateSharedCacheCleanup( session );
 
 		createTemporaryTableIfNecessary( persister, session );
 
 		try {
 			// First, save off the pertinent ids, saving the number of pertinent ids for return
 			PreparedStatement ps = null;
 			int resultCount = 0;
 			try {
 				try {
 					ps = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( idInsertSelect, false );
 					Iterator paramSpecifications = getIdSelectParameterSpecifications().iterator();
 					int pos = 1;
 					while ( paramSpecifications.hasNext() ) {
 						final ParameterSpecification paramSpec = ( ParameterSpecification ) paramSpecifications.next();
 						pos += paramSpec.bind( ps, parameters, session, pos );
 					}
 					resultCount = ps.executeUpdate();
 				}
 				finally {
 					if ( ps != null ) {
 						ps.close();
 					}
 				}
 			}
 			catch( SQLException e ) {
 				throw getFactory().getSQLExceptionHelper().convert(
 				        e,
 				        "could not insert/select ids for bulk delete",
 				        idInsertSelect
 					);
 			}
 
 			// Start performing the deletes
 			for ( int i = 0; i < deletes.length; i++ ) {
 				try {
 					try {
 						ps = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( deletes[i], false );
 						ps.executeUpdate();
 					}
 					finally {
 						if ( ps != null ) {
 							ps.close();
 						}
 					}
 				}
 				catch( SQLException e ) {
 					throw getFactory().getSQLExceptionHelper().convert(
 					        e,
 					        "error performing bulk delete",
 					        deletes[i]
 						);
 				}
 			}
 
 			return resultCount;
 		}
 		finally {
 			dropTemporaryTableIfNecessary( persister, session );
 		}
 	}
 
 	@Override
     protected Queryable[] getAffectedQueryables() {
 		return new Queryable[] { persister };
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/MultiTableUpdateExecutor.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/MultiTableUpdateExecutor.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/exec/MultiTableUpdateExecutor.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/MultiTableUpdateExecutor.java
index 79088ed153..c44434c079 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/MultiTableUpdateExecutor.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/MultiTableUpdateExecutor.java
@@ -1,199 +1,199 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.exec;
+package org.hibernate.hql.internal.ast.exec;
 
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.hql.ast.HqlSqlWalker;
-import org.hibernate.hql.ast.tree.AssignmentSpecification;
-import org.hibernate.hql.ast.tree.FromElement;
-import org.hibernate.hql.ast.tree.UpdateStatement;
+import org.hibernate.hql.internal.ast.HqlSqlWalker;
+import org.hibernate.hql.internal.ast.tree.AssignmentSpecification;
+import org.hibernate.hql.internal.ast.tree.FromElement;
+import org.hibernate.hql.internal.ast.tree.UpdateStatement;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.Update;
 import org.jboss.logging.Logger;
 
 /**
  * Implementation of MultiTableUpdateExecutor.
  *
  * @author Steve Ebersole
  */
 public class MultiTableUpdateExecutor extends AbstractStatementExecutor {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        MultiTableUpdateExecutor.class.getName());
 
 	private final Queryable persister;
 	private final String idInsertSelect;
 	private final String[] updates;
 	private final ParameterSpecification[][] hqlParameters;
 
 	public MultiTableUpdateExecutor(HqlSqlWalker walker) {
         super(walker, null);
 
 		if ( !walker.getSessionFactoryHelper().getFactory().getDialect().supportsTemporaryTables() ) {
 			throw new HibernateException( "cannot doAfterTransactionCompletion multi-table updates using dialect not supporting temp tables" );
 		}
 
 		UpdateStatement updateStatement = ( UpdateStatement ) walker.getAST();
 		FromElement fromElement = updateStatement.getFromClause().getFromElement();
 		String bulkTargetAlias = fromElement.getTableAlias();
 		this.persister = fromElement.getQueryable();
 
 		this.idInsertSelect = generateIdInsertSelect( persister, bulkTargetAlias, updateStatement.getWhereClause() );
         LOG.trace("Generated ID-INSERT-SELECT SQL (multi-table update) : " + idInsertSelect);
 
 		String[] tableNames = persister.getConstraintOrderedTableNameClosure();
 		String[][] columnNames = persister.getContraintOrderedTableKeyColumnClosure();
 
 		String idSubselect = generateIdSubselect( persister );
 		List assignmentSpecifications = walker.getAssignmentSpecifications();
 
 		updates = new String[tableNames.length];
 		hqlParameters = new ParameterSpecification[tableNames.length][];
 		for ( int tableIndex = 0; tableIndex < tableNames.length; tableIndex++ ) {
 			boolean affected = false;
 			List parameterList = new ArrayList();
 			Update update = new Update( getFactory().getDialect() )
 					.setTableName( tableNames[tableIndex] )
 					.setWhere( "(" + StringHelper.join( ", ", columnNames[tableIndex] ) + ") IN (" + idSubselect + ")" );
 			if ( getFactory().getSettings().isCommentsEnabled() ) {
 				update.setComment( "bulk update" );
 			}
 			final Iterator itr = assignmentSpecifications.iterator();
 			while ( itr.hasNext() ) {
 				final AssignmentSpecification specification = ( AssignmentSpecification ) itr.next();
 				if ( specification.affectsTable( tableNames[tableIndex] ) ) {
 					affected = true;
 					update.appendAssignmentFragment( specification.getSqlAssignmentFragment() );
 					if ( specification.getParameters() != null ) {
 						for ( int paramIndex = 0; paramIndex < specification.getParameters().length; paramIndex++ ) {
 							parameterList.add( specification.getParameters()[paramIndex] );
 						}
 					}
 				}
 			}
 			if ( affected ) {
 				updates[tableIndex] = update.toStatementString();
 				hqlParameters[tableIndex] = ( ParameterSpecification[] ) parameterList.toArray( new ParameterSpecification[0] );
 			}
 		}
 	}
 
 	public Queryable getAffectedQueryable() {
 		return persister;
 	}
 
 	public String[] getSqlStatements() {
 		return updates;
 	}
 
 	public int execute(QueryParameters parameters, SessionImplementor session) throws HibernateException {
 		coordinateSharedCacheCleanup( session );
 
 		createTemporaryTableIfNecessary( persister, session );
 
 		try {
 			// First, save off the pertinent ids, as the return value
 			PreparedStatement ps = null;
 			int resultCount = 0;
 			try {
 				try {
 					ps = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( idInsertSelect, false );
 //					int parameterStart = getWalker().getNumberOfParametersInSetClause();
 //					List allParams = getIdSelectParameterSpecifications();
 //					Iterator whereParams = allParams.subList( parameterStart, allParams.size() ).iterator();
 					Iterator whereParams = getIdSelectParameterSpecifications().iterator();
 					int sum = 1; // jdbc params are 1-based
 					while ( whereParams.hasNext() ) {
 						sum += ( ( ParameterSpecification ) whereParams.next() ).bind( ps, parameters, session, sum );
 					}
 					resultCount = ps.executeUpdate();
 				}
 				finally {
 					if ( ps != null ) {
 						ps.close();
 					}
 				}
 			}
 			catch( SQLException e ) {
 				throw getFactory().getSQLExceptionHelper().convert(
 				        e,
 				        "could not insert/select ids for bulk update",
 				        idInsertSelect
 					);
 			}
 
 			// Start performing the updates
 			for ( int i = 0; i < updates.length; i++ ) {
 				if ( updates[i] == null ) {
 					continue;
 				}
 				try {
 					try {
 						ps = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( updates[i], false );
 						if ( hqlParameters[i] != null ) {
 							int position = 1; // jdbc params are 1-based
 							for ( int x = 0; x < hqlParameters[i].length; x++ ) {
 								position += hqlParameters[i][x].bind( ps, parameters, session, position );
 							}
 						}
 						ps.executeUpdate();
 					}
 					finally {
 						if ( ps != null ) {
 							ps.close();
 						}
 					}
 				}
 				catch( SQLException e ) {
 					throw getFactory().getSQLExceptionHelper().convert(
 					        e,
 					        "error performing bulk update",
 					        updates[i]
 						);
 				}
 			}
 
 			return resultCount;
 		}
 		finally {
 			dropTemporaryTableIfNecessary( persister, session );
 		}
 	}
 
 	@Override
     protected Queryable[] getAffectedQueryables() {
 		return new Queryable[] { persister };
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/StatementExecutor.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/StatementExecutor.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/exec/StatementExecutor.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/StatementExecutor.java
index d5b8b5c634..e7b27bd6a3 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/StatementExecutor.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/exec/StatementExecutor.java
@@ -1,50 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.exec;
+package org.hibernate.hql.internal.ast.exec;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionImplementor;
 
 /**
  * Encapsulates the strategy required to execute various types of update, delete,
  * and insert statements issued through HQL.
  *
  * @author Steve Ebersole
  */
 public interface StatementExecutor {
 
 	public String[] getSqlStatements();
 
 	/**
 	 * Execute the sql managed by this executor using the given parameters.
 	 *
 	 * @param parameters Essentially bind information for this processing.
 	 * @param session The session originating the request.
 	 * @return The number of entities updated/deleted.
 	 * @throws HibernateException
 	 */
 	public int execute(QueryParameters parameters, SessionImplementor session) throws HibernateException;
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/package.html b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/package.html
similarity index 100%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/package.html
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/package.html
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractMapComponentNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractMapComponentNode.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractMapComponentNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractMapComponentNode.java
index 2b7a3ef476..ff993c0794 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractMapComponentNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractMapComponentNode.java
@@ -1,104 +1,104 @@
 /*
  * Copyright (c) 2009, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import java.util.Map;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.ast.util.ColumnHelper;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.ast.util.ColumnHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.Type;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractMapComponentNode extends FromReferenceNode implements HqlSqlTokenTypes {
 	private String[] columns;
 
 	public FromReferenceNode getMapReference() {
 		return ( FromReferenceNode ) getFirstChild();
 	}
 
 	public String[] getColumns() {
 		return columns;
 	}
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		ColumnHelper.generateScalarColumns( this, getColumns(), i );
 	}
 
 	public void resolve(
 			boolean generateJoin,
 			boolean implicitJoin,
 			String classAlias,
 			AST parent) throws SemanticException {
 		if ( parent != null ) {
 			throw attemptedDereference();
 		}
 
 		FromReferenceNode mapReference = getMapReference();
 		mapReference.resolve( true, true );
 		if ( mapReference.getDataType().isCollectionType() ) {
 			CollectionType collectionType = (CollectionType) mapReference.getDataType();
 			if ( Map.class.isAssignableFrom( collectionType.getReturnedClass() ) ) {
 				FromElement sourceFromElement = mapReference.getFromElement();
 				setFromElement( sourceFromElement );
 				setDataType( resolveType( sourceFromElement.getQueryableCollection() ) );
 				this.columns = resolveColumns( sourceFromElement.getQueryableCollection() );
 				initText( this.columns );
 				setFirstChild( null );
 				return;
 			}
 		}
 
 		throw nonMap();
 	}
 
 	private void initText(String[] columns) {
 		String text = StringHelper.join( ", ", columns );
 		if ( columns.length > 1 && getWalker().isComparativeExpressionClause() ) {
 			text = "(" + text + ")";
 		}
 		setText( text );
 	}
 
 	protected abstract String expressionDescription();
 	protected abstract String[] resolveColumns(QueryableCollection collectionPersister);
 	protected abstract Type resolveType(QueryableCollection collectionPersister);
 
 	protected SemanticException attemptedDereference() {
 		return new SemanticException( expressionDescription() + " expression cannot be further de-referenced" );
 	}
 
 	protected SemanticException nonMap() {
 		return new SemanticException( expressionDescription() + " expression did not reference map property" );
 	}
 
 	public void resolveIndex(AST parent) throws SemanticException {
 		throw new UnsupportedOperationException( expressionDescription() + " expression cannot be the source for an index operation" );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractNullnessCheckNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractNullnessCheckNode.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractNullnessCheckNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractNullnessCheckNode.java
index 03b171bc5d..c9b4e42f30 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractNullnessCheckNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractNullnessCheckNode.java
@@ -1,161 +1,161 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.type.Type;
 import antlr.collections.AST;
 
 /**
  * Base class for nodes dealing 'is null' and 'is not null' operators.
  * <p/>
  * todo : a good deal of this is copied from BinaryLogicOperatorNode; look at consolidating these code fragments
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractNullnessCheckNode extends UnaryLogicOperatorNode {
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public void initialize() {
 		// TODO : this really needs to be delayed unitl after we definitively know the operand node type;
 		// where this is currently a problem is parameters for which where we cannot unequivocally
 		// resolve an expected type
 		Type operandType = extractDataType( getOperand() );
 		if ( operandType == null ) {
 			return;
 		}
 		SessionFactoryImplementor sessionFactory = getSessionFactoryHelper().getFactory();
 		int operandColumnSpan = operandType.getColumnSpan( sessionFactory );
 		if ( operandColumnSpan > 1 ) {
 			mutateRowValueConstructorSyntax( operandColumnSpan );
 		}
 	}
 
 	/**
 	 * When (if) we need to expand a row value constructor, what is the type of connector to use between the
 	 * expansion fragments.
 	 *
 	 * @return The expansion connector type.
 	 */
 	protected abstract int getExpansionConnectorType();
 
 	/**
 	 * When (if) we need to expand a row value constructor, what is the text of the connector to use between the
 	 * expansion fragments.
 	 *
 	 * @return The expansion connector text.
 	 */
 	protected abstract String getExpansionConnectorText();
 
 	private void mutateRowValueConstructorSyntax(int operandColumnSpan) {
 		final int comparisonType = getType();
 		final String comparisonText = getText();
 
 		final int expansionConnectorType = getExpansionConnectorType();
 		final String expansionConnectorText = getExpansionConnectorText();
 
 		setType( expansionConnectorType );
 		setText( expansionConnectorText );
 
 		String[] mutationTexts = extractMutationTexts( getOperand(), operandColumnSpan );
 
 		AST container = this;
 		for ( int i = operandColumnSpan - 1; i > 0; i-- ) {
 			if ( i == 1 ) {
 				AST op1 = getASTFactory().create( comparisonType, comparisonText );
 				AST operand1 = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, mutationTexts[0] );
 				op1.setFirstChild( operand1 );
 				container.setFirstChild( op1 );
 				AST op2 = getASTFactory().create( comparisonType, comparisonText );
 				AST operand2 = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, mutationTexts[1] );
 				op2.setFirstChild( operand2 );
 				op1.setNextSibling( op2 );
 			}
 			else {
 				AST op = getASTFactory().create( comparisonType, comparisonText );
 				AST operand = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, mutationTexts[i] );
 				op.setFirstChild( operand );
 				AST newContainer = getASTFactory().create( expansionConnectorType, expansionConnectorText );
 				container.setFirstChild( newContainer );
 				newContainer.setNextSibling( op );
 				container = newContainer;
 			}
 		}
 	}
 
 	private static Type extractDataType(Node operand) {
 		Type type = null;
 		if ( operand instanceof SqlNode ) {
 			type = ( ( SqlNode ) operand ).getDataType();
 		}
 		if ( type == null && operand instanceof ExpectedTypeAwareNode ) {
 			type = ( ( ExpectedTypeAwareNode ) operand ).getExpectedType();
 		}
 		return type;
 	}
 
 	private static String[] extractMutationTexts(Node operand, int count) {
 		if ( operand instanceof ParameterNode ) {
 			String[] rtn = new String[count];
 			for ( int i = 0; i < count; i++ ) {
 				rtn[i] = "?";
 			}
 			return rtn;
 		}
 		else if ( operand.getType() == HqlSqlTokenTypes.VECTOR_EXPR ) {
 			String[] rtn = new String[ operand.getNumberOfChildren() ];
 			int x = 0;
 			AST node = operand.getFirstChild();
 			while ( node != null ) {
 				rtn[ x++ ] = node.getText();
 				node = node.getNextSibling();
 			}
 			return rtn;
 		}
 		else if ( operand instanceof SqlNode ) {
 			String nodeText = operand.getText();
 			if ( nodeText.startsWith( "(" ) ) {
 				nodeText = nodeText.substring( 1 );
 			}
 			if ( nodeText.endsWith( ")" ) ) {
 				nodeText = nodeText.substring( 0, nodeText.length() - 1 );
 			}
 			String[] splits = StringHelper.split( ", ", nodeText );
 			if ( count != splits.length ) {
 				throw new HibernateException( "SqlNode's text did not reference expected number of columns" );
 			}
 			return splits;
 		}
 		else {
 			throw new HibernateException( "dont know how to extract row value elements from node : " + operand );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractRestrictableStatement.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractRestrictableStatement.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractRestrictableStatement.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractRestrictableStatement.java
index a23eabadaf..e90cb6de6b 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractRestrictableStatement.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractRestrictableStatement.java
@@ -1,86 +1,86 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.ast.util.ASTUtil;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
 import antlr.collections.AST;
 
 /**
  * Convenience implementation of {@link RestrictableStatement}
  * to centralize common functionality.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractRestrictableStatement extends AbstractStatement implements RestrictableStatement {
 
 	private FromClause fromClause;
 	private AST whereClause;
 
 	protected abstract int getWhereClauseParentTokenType();
 
     protected abstract CoreMessageLogger getLog();
 
 	/**
-	 * @see org.hibernate.hql.ast.tree.RestrictableStatement#getFromClause
+	 * @see org.hibernate.hql.internal.ast.tree.RestrictableStatement#getFromClause
 	 */
 	public final FromClause getFromClause() {
 		if ( fromClause == null ) {
 			fromClause = ( FromClause ) ASTUtil.findTypeInChildren( this, HqlSqlTokenTypes.FROM );
 		}
 		return fromClause;
 	}
 
 	/**
 	 * @see RestrictableStatement#hasWhereClause
 	 */
 	public final boolean hasWhereClause() {
 		AST whereClause = locateWhereClause();
 		return whereClause != null && whereClause.getNumberOfChildren() > 0;
 	}
 
 	/**
-	 * @see org.hibernate.hql.ast.tree.RestrictableStatement#getWhereClause
+	 * @see org.hibernate.hql.internal.ast.tree.RestrictableStatement#getWhereClause
 	 */
 	public final AST getWhereClause() {
 		if ( whereClause == null ) {
 			whereClause = locateWhereClause();
 			// If there is no WHERE node, make one.
 			if ( whereClause == null ) {
 				getLog().debug( "getWhereClause() : Creating a new WHERE clause..." );
 				whereClause = ASTUtil.create( getWalker().getASTFactory(), HqlSqlTokenTypes.WHERE, "WHERE" );
 				// inject the WHERE after the parent
 				AST parent = ASTUtil.findTypeInChildren( this, getWhereClauseParentTokenType() );
 				whereClause.setNextSibling( parent.getNextSibling() );
 				parent.setNextSibling( whereClause );
 			}
 		}
 		return whereClause;
 	}
 
 	protected AST locateWhereClause() {
 		return ASTUtil.findTypeInChildren( this, HqlSqlTokenTypes.WHERE );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractSelectExpression.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractSelectExpression.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractSelectExpression.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractSelectExpression.java
index 440e399a4a..ae32b8d35b 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractSelectExpression.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractSelectExpression.java
@@ -1,74 +1,74 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.type.Type;
 import antlr.SemanticException;
 
 /**
  * Partial implementation of SelectExpression for all the nodes that aren't constructors.
  *
  * @author Joshua Davis
  */
 public abstract class AbstractSelectExpression extends HqlSqlWalkerNode implements SelectExpression {
 	
 	private String alias;
 	private int scalarColumnIndex = -1;
 	
 	public final void setAlias(String alias) {
 		this.alias = alias;
 	}
 	
 	public final String getAlias() {
 		return alias;
 	}
 
 	public boolean isConstructor() {
 		return false;
 	}
 
 	public boolean isReturnableEntity() throws SemanticException {
 		return false;
 	}
 
 	public FromElement getFromElement() {
 		return null;
 	}
 
 	public boolean isScalar() throws SemanticException {
 		// Default implementation:
 		// If this node has a data type, and that data type is not an association, then this is scalar.
 		Type type = getDataType();
 		return type != null && !type.isAssociationType();	// Moved here from SelectClause [jsd]
 	}
 
 	public void setScalarColumn(int i) throws SemanticException {
 		this.scalarColumnIndex = i;
 		setScalarColumnText( i );
 	}
 
 	public int getScalarColumnIndex() {
 		return scalarColumnIndex;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractStatement.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractStatement.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractStatement.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractStatement.java
index fd66f31212..abadefe6da 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AbstractStatement.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AbstractStatement.java
@@ -1,54 +1,54 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import java.util.Iterator;
 
 /**
  * Convenience implementation of Statement to centralize common functionality.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractStatement extends HqlSqlWalkerNode implements DisplayableNode, Statement {
 
 	/**
 	 * Returns additional display text for the AST node.
 	 *
 	 * @return String - The additional display text.
 	 */
 	public String getDisplayText() {
 		StringBuffer buf = new StringBuffer();
 		if ( getWalker().getQuerySpaces().size() > 0 ) {
 			buf.append( " querySpaces (" );
 			for ( Iterator iterator = getWalker().getQuerySpaces().iterator(); iterator.hasNext(); ) {
 				buf.append( iterator.next() );
 				if ( iterator.hasNext() ) {
 					buf.append( "," );
 				}
 			}
 			buf.append( ")" );
 		}
 		return buf.toString();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AggregateNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AggregateNode.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AggregateNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AggregateNode.java
index 0fc0e60828..5473fc4bff 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AggregateNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AggregateNode.java
@@ -1,94 +1,94 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.dialect.function.StandardSQLFunction;
-import org.hibernate.hql.ast.util.ColumnHelper;
+import org.hibernate.hql.internal.ast.util.ColumnHelper;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * Represents an aggregate function i.e. min, max, sum, avg.
  *
  * @author Joshua Davis
  */
 public class AggregateNode extends AbstractSelectExpression implements SelectExpression, FunctionNode {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, AggregateNode.class.getName());
 
 	private SQLFunction sqlFunction;
 
 	public SQLFunction getSQLFunction() {
 		return sqlFunction;
 	}
 
 	public void resolve() {
 		resolveFunction();
 	}
 
 	private SQLFunction resolveFunction() {
 		if ( sqlFunction == null ) {
 			final String name = getText();
 			sqlFunction = getSessionFactoryHelper().findSQLFunction( getText() );
 			if ( sqlFunction == null ) {
                 LOG.unableToResolveAggregateFunction(name);
 				sqlFunction = new StandardSQLFunction( name );
 			}
 		}
 		return sqlFunction;
 	}
 
 	public Type getFirstArgumentType() {
 		AST argument = getFirstChild();
 		while ( argument != null ) {
 			if ( argument instanceof SqlNode ) {
 				final Type type = ( (SqlNode) argument ).getDataType();
 				if ( type != null ) {
 					return type;
 				}
 				argument = argument.getNextSibling();
 			}
 		}
 		return null;
 	}
 
 	@Override
     public Type getDataType() {
 		// Get the function return value type, based on the type of the first argument.
 		return getSessionFactoryHelper().findFunctionReturnType( getText(), resolveFunction(), getFirstChild() );
 	}
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		ColumnHelper.generateSingleScalarColumn( this, i );
 	}
 
 	@Override
     public boolean isScalar() throws SemanticException {
 		// functions in a SELECT should always be considered scalar.
 		return true;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AggregatedSelectExpression.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AggregatedSelectExpression.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AggregatedSelectExpression.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AggregatedSelectExpression.java
index c43ca11474..cd3af226f4 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AggregatedSelectExpression.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AggregatedSelectExpression.java
@@ -1,64 +1,64 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import java.util.List;
 
 import org.hibernate.transform.ResultTransformer;
 
 /**
  * Contract for a select expression which aggregates other select expressions together into a single return
  *
  * @author Steve Ebersole
  */
 public interface AggregatedSelectExpression extends SelectExpression {
 	/**
 	 * Retrieves a list of the selection {@link org.hibernate.type.Type types} being aggregated
 	 *
 	 * @return The list of types.
 	 */
 	public List getAggregatedSelectionTypeList();
 
 	/**
 	 * Retrieve the aliases for the columns aggregated here.
 	 *
 	 * @return The column aliases.
 	 */
 	public String[] getAggregatedAliases();
 
 	/**
 	 * Retrieve the {@link ResultTransformer} responsible for building aggregated select expression results into their
 	 * aggregated form.
 	 *
 	 * @return The appropriate transformer
 	 */
 	public ResultTransformer getResultTransformer();
 
 	/**
 	 * Obtain the java type of the aggregation
 	 *
 	 * @return The java type.
 	 */
 	public Class getAggregationResultType();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AssignmentSpecification.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AssignmentSpecification.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AssignmentSpecification.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AssignmentSpecification.java
index f77a39bc62..b73705fb74 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/AssignmentSpecification.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/AssignmentSpecification.java
@@ -1,163 +1,163 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 import org.hibernate.QueryException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.ast.SqlGenerator;
-import org.hibernate.hql.ast.util.ASTUtil;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.ast.SqlGenerator;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.persister.entity.UnionSubclassEntityPersister;
 import antlr.collections.AST;
 
 /**
  * Encapsulates the information relating to an individual assignment within the
  * set clause of an HQL update statement.  This information is used during execution
  * of the update statements when the updates occur against "multi-table" stuff.
  *
  * @author Steve Ebersole
  */
 public class AssignmentSpecification {
 
 	private final Set tableNames;
 	private final ParameterSpecification[] hqlParameters;
 	private final AST eq;
 	private final SessionFactoryImplementor factory;
 
 	private String sqlAssignmentString;
 
 	public AssignmentSpecification(AST eq, Queryable persister) {
 		if ( eq.getType() != HqlSqlTokenTypes.EQ ) {
 			throw new QueryException( "assignment in set-clause not associated with equals" );
 		}
 
 		this.eq = eq;
 		this.factory = persister.getFactory();
 
 		// Needed to bump this up to DotNode, because that is the only thing which currently
 		// knows about the property-ref path in the correct format; it is either this, or
 		// recurse over the DotNodes constructing the property path just like DotNode does
 		// internally
 		DotNode lhs = ( DotNode ) eq.getFirstChild();
 		SqlNode rhs = ( SqlNode ) lhs.getNextSibling();
 
 		validateLhs( lhs );
 
 		final String propertyPath = lhs.getPropertyPath();
 		Set temp = new HashSet();
 		// yuck!
 		if ( persister instanceof UnionSubclassEntityPersister ) {
 			UnionSubclassEntityPersister usep = ( UnionSubclassEntityPersister ) persister;
 			String[] tables = persister.getConstraintOrderedTableNameClosure();
 			int size = tables.length;
 			for ( int i = 0; i < size; i ++ ) {
 				temp.add( tables[i] );
 			}
 		}
 		else {
 			temp.add(
 					persister.getSubclassTableName( persister.getSubclassPropertyTableNumber( propertyPath ) )
 			);
 		}
 		this.tableNames = Collections.unmodifiableSet( temp );
 
 		if (rhs==null) {
 			hqlParameters = new ParameterSpecification[0];
 		}
 		else if ( isParam( rhs ) ) {
 			hqlParameters = new ParameterSpecification[] { ( ( ParameterNode ) rhs ).getHqlParameterSpecification() };
 		}
 		else {
 			List parameterList = ASTUtil.collectChildren(
 			        rhs,
 			        new ASTUtil.IncludePredicate() {
 				        public boolean include(AST node) {
 					        return isParam( node );
 			            }
 			        }
 			);
 			hqlParameters = new ParameterSpecification[ parameterList.size() ];
 			Iterator itr = parameterList.iterator();
 			int i = 0;
 			while( itr.hasNext() ) {
 				hqlParameters[i++] = ( ( ParameterNode ) itr.next() ).getHqlParameterSpecification();
 			}
 		}
 	}
 
 	public boolean affectsTable(String tableName) {
 		return this.tableNames.contains( tableName );
 	}
 
 	public ParameterSpecification[] getParameters() {
 		return hqlParameters;
 	}
 
 	public String getSqlAssignmentFragment() {
 		if ( sqlAssignmentString == null ) {
 			try {
 				SqlGenerator sqlGenerator = new SqlGenerator( factory );
 				sqlGenerator.comparisonExpr( eq, false );  // false indicates to not generate parens around the assignment
 				sqlAssignmentString = sqlGenerator.getSQL();
 			}
 			catch( Throwable t ) {
 				throw new QueryException( "cannot interpret set-clause assignment" );
 			}
 		}
 		return sqlAssignmentString;
 	}
 
 	private static boolean isParam(AST node) {
 		return node.getType() == HqlSqlTokenTypes.PARAM || node.getType() == HqlSqlTokenTypes.NAMED_PARAM;
 	}
 
 	private void validateLhs(FromReferenceNode lhs) {
 		// make sure the lhs is "assignable"...
 		if ( !lhs.isResolved() ) {
 			throw new UnsupportedOperationException( "cannot validate assignablity of unresolved node" );
 		}
 
 		if ( lhs.getDataType().isCollectionType() ) {
 			throw new QueryException( "collections not assignable in update statements" );
 		}
 		else if ( lhs.getDataType().isComponentType() ) {
 			throw new QueryException( "Components currently not assignable in update statements" );
 		}
 		else if ( lhs.getDataType().isEntityType() ) {
 			// currently allowed...
 		}
 
 		// TODO : why aren't these the same?
 		if ( lhs.getImpliedJoin() != null || lhs.getFromElement().isImplied() ) {
 			throw new QueryException( "Implied join paths are not assignable in update statements" );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BetweenOperatorNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BetweenOperatorNode.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BetweenOperatorNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BetweenOperatorNode.java
index b6c9f65553..e6a4bc65d8 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BetweenOperatorNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BetweenOperatorNode.java
@@ -1,85 +1,85 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import antlr.SemanticException;
 
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.Type;
 
 /**
  * Contract for nodes representing logical BETWEEN (ternary) operators.
  *
  * @author Steve Ebersole
  */
 public class BetweenOperatorNode extends SqlNode implements OperatorNode {
 
 	public void initialize() throws SemanticException {
 		Node fixture = getFixtureOperand();
 		if ( fixture == null ) {
 			throw new SemanticException( "fixture operand of a between operator was null" );
 		}
 		Node low = getLowOperand();
 		if ( low == null ) {
 			throw new SemanticException( "low operand of a between operator was null" );
 		}
 		Node high = getHighOperand();
 		if ( high == null ) {
 			throw new SemanticException( "high operand of a between operator was null" );
 		}
 		check( fixture, low, high );
 		check( low, high, fixture );
 		check( high, fixture, low );
 	}
 
 	public Type getDataType() {
 		// logic operators by definition resolve to boolean.
 		return StandardBasicTypes.BOOLEAN;
 	}
 
 	public Node getFixtureOperand() {
 		return ( Node ) getFirstChild();
 	}
 
 	public Node getLowOperand() {
 		return ( Node ) getFirstChild().getNextSibling();
 	}
 
 	public Node getHighOperand() {
 		return ( Node ) getFirstChild().getNextSibling().getNextSibling();
 	}
 
 	private void check(Node check, Node first, Node second) {
 		if ( ExpectedTypeAwareNode.class.isAssignableFrom( check.getClass() ) ) {
 			Type expectedType = null;
 			if ( SqlNode.class.isAssignableFrom( first.getClass() ) ) {
 				expectedType = ( ( SqlNode ) first ).getDataType();
 			}
 			if ( expectedType == null && SqlNode.class.isAssignableFrom( second.getClass() ) ) {
 				expectedType = ( ( SqlNode ) second ).getDataType();
 			}
 			( ( ExpectedTypeAwareNode ) check ).setExpectedType( expectedType );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BinaryArithmeticOperatorNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BinaryArithmeticOperatorNode.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BinaryArithmeticOperatorNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BinaryArithmeticOperatorNode.java
index 5cfcc15446..e5127a4b1c 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BinaryArithmeticOperatorNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BinaryArithmeticOperatorNode.java
@@ -1,225 +1,225 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import antlr.SemanticException;
 
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.ast.util.ColumnHelper;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.ast.util.ColumnHelper;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.Type;
 
 /**
  * Nodes which represent binary arithmetic operators.
  *
  * @author Gavin King
  */
 public class BinaryArithmeticOperatorNode extends AbstractSelectExpression implements BinaryOperatorNode, DisplayableNode {
 
 	public void initialize() throws SemanticException {
 		Node lhs = getLeftHandOperand();
 		Node rhs = getRightHandOperand();
 		if ( lhs == null ) {
 			throw new SemanticException( "left-hand operand of a binary operator was null" );
 		}
 		if ( rhs == null ) {
 			throw new SemanticException( "right-hand operand of a binary operator was null" );
 		}
 
 		Type lhType = ( lhs instanceof SqlNode ) ? ( ( SqlNode ) lhs ).getDataType() : null;
 		Type rhType = ( rhs instanceof SqlNode ) ? ( ( SqlNode ) rhs ).getDataType() : null;
 
 		if ( ExpectedTypeAwareNode.class.isAssignableFrom( lhs.getClass() ) && rhType != null ) {
 			Type expectedType = null;
 			// we have something like : "? [op] rhs"
 			if ( isDateTimeType( rhType ) ) {
 				// more specifically : "? [op] datetime"
 				//      1) if the operator is MINUS, the param needs to be of
 				//          some datetime type
 				//      2) if the operator is PLUS, the param needs to be of
 				//          some numeric type
 				expectedType = getType() == HqlSqlTokenTypes.PLUS ? StandardBasicTypes.DOUBLE : rhType;
 			}
 			else {
 				expectedType = rhType;
 			}
 			( ( ExpectedTypeAwareNode ) lhs ).setExpectedType( expectedType );
 		}
 		else if ( ParameterNode.class.isAssignableFrom( rhs.getClass() ) && lhType != null ) {
 			Type expectedType = null;
 			// we have something like : "lhs [op] ?"
 			if ( isDateTimeType( lhType ) ) {
 				// more specifically : "datetime [op] ?"
 				//      1) if the operator is MINUS, we really cannot determine
 				//          the expected type as either another datetime or
 				//          numeric would be valid
 				//      2) if the operator is PLUS, the param needs to be of
 				//          some numeric type
 				if ( getType() == HqlSqlTokenTypes.PLUS ) {
 					expectedType = StandardBasicTypes.DOUBLE;
 				}
 			}
 			else {
 				expectedType = lhType;
 			}
 			( ( ExpectedTypeAwareNode ) rhs ).setExpectedType( expectedType );
 		}
 	}
 
 	/**
 	 * Figure out the type of the binary expression by looking at
 	 * the types of the operands. Sometimes we don't know both types,
 	 * if, for example, one is a parameter.
 	 */
 	public Type getDataType() {
 		if ( super.getDataType() == null ) {
 			super.setDataType( resolveDataType() );
 		}
 		return super.getDataType();
 	}
 
 	private Type resolveDataType() {
 		// TODO : we may also want to check that the types here map to exactly one column/JDBC-type
 		//      can't think of a situation where arithmetic expression between multi-column mappings
 		//      makes any sense.
 		Node lhs = getLeftHandOperand();
 		Node rhs = getRightHandOperand();
 		Type lhType = ( lhs instanceof SqlNode ) ? ( ( SqlNode ) lhs ).getDataType() : null;
 		Type rhType = ( rhs instanceof SqlNode ) ? ( ( SqlNode ) rhs ).getDataType() : null;
 		if ( isDateTimeType( lhType ) || isDateTimeType( rhType ) ) {
 			return resolveDateTimeArithmeticResultType( lhType, rhType );
 		}
 		else {
 			if ( lhType == null ) {
 				if ( rhType == null ) {
 					// we do not know either type
 					return StandardBasicTypes.DOUBLE; //BLIND GUESS!
 				}
 				else {
 					// we know only the rhs-hand type, so use that
 					return rhType;
 				}
 			}
 			else {
 				if ( rhType == null ) {
 					// we know only the lhs-hand type, so use that
 					return lhType;
 				}
 				else {
 					if ( lhType== StandardBasicTypes.DOUBLE || rhType==StandardBasicTypes.DOUBLE ) {
 						return StandardBasicTypes.DOUBLE;
 					}
 					if ( lhType==StandardBasicTypes.FLOAT || rhType==StandardBasicTypes.FLOAT ) {
 						return StandardBasicTypes.FLOAT;
 					}
 					if ( lhType==StandardBasicTypes.BIG_DECIMAL || rhType==StandardBasicTypes.BIG_DECIMAL ) {
 						return StandardBasicTypes.BIG_DECIMAL;
 					}
 					if ( lhType==StandardBasicTypes.BIG_INTEGER || rhType==StandardBasicTypes.BIG_INTEGER ) {
 						return StandardBasicTypes.BIG_INTEGER;
 					}
 					if ( lhType==StandardBasicTypes.LONG || rhType==StandardBasicTypes.LONG ) {
 						return StandardBasicTypes.LONG;
 					}
 					if ( lhType==StandardBasicTypes.INTEGER || rhType==StandardBasicTypes.INTEGER ) {
 						return StandardBasicTypes.INTEGER;
 					}
 					return lhType;
 				}
 			}
 		}
 	}
 
 	private boolean isDateTimeType(Type type) {
 		if ( type == null ) {
 			return false;
 		}
 		return java.util.Date.class.isAssignableFrom( type.getReturnedClass() ) ||
 	           java.util.Calendar.class.isAssignableFrom( type.getReturnedClass() );
 	}
 
 	private Type resolveDateTimeArithmeticResultType(Type lhType, Type rhType) {
 		// here, we work under the following assumptions:
 		//      ------------ valid cases --------------------------------------
 		//      1) datetime + {something other than datetime} : always results
 		//              in a datetime ( db will catch invalid conversions )
 		//      2) datetime - datetime : always results in a DOUBLE
 		//      3) datetime - {something other than datetime} : always results
 		//              in a datetime ( db will catch invalid conversions )
 		//      ------------ invalid cases ------------------------------------
 		//      4) datetime + datetime
 		//      5) {something other than datetime} - datetime
 		//      6) datetime * {any type}
 		//      7) datetime / {any type}
 		//      8) {any type} / datetime
 		// doing so allows us to properly handle parameters as either the left
 		// or right side here in the majority of cases
 		boolean lhsIsDateTime = isDateTimeType( lhType );
 		boolean rhsIsDateTime = isDateTimeType( rhType );
 
 		// handle the (assumed) valid cases:
 		// #1 - the only valid datetime addition synatx is one or the other is a datetime (but not both)
 		if ( getType() == HqlSqlTokenTypes.PLUS ) {
 			// one or the other needs to be a datetime for us to get into this method in the first place...
 			return lhsIsDateTime ? lhType : rhType;
 		}
 		else if ( getType() == HqlSqlTokenTypes.MINUS ) {
 			// #3 - note that this is also true of "datetime - :param"...
 			if ( lhsIsDateTime && !rhsIsDateTime ) {
 				return lhType;
 			}
 			// #2
 			if ( lhsIsDateTime && rhsIsDateTime ) {
 				return StandardBasicTypes.DOUBLE;
 			}
 		}
 		return null;
 	}
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		ColumnHelper.generateSingleScalarColumn( this, i );
 	}
 
 	/**
 	 * Retrieves the left-hand operand of the operator.
 	 *
 	 * @return The left-hand operand
 	 */
 	public Node getLeftHandOperand() {
 		return ( Node ) getFirstChild();
 	}
 
 	/**
 	 * Retrieves the right-hand operand of the operator.
 	 *
 	 * @return The right-hand operand
 	 */
 	public Node getRightHandOperand() {
 		return ( Node ) getFirstChild().getNextSibling();
 	}
 
 	public String getDisplayText() {
 		return "{dataType=" + getDataType() + "}";
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BinaryLogicOperatorNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BinaryLogicOperatorNode.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BinaryLogicOperatorNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BinaryLogicOperatorNode.java
index 303407dd61..152eedfb80 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BinaryLogicOperatorNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BinaryLogicOperatorNode.java
@@ -1,262 +1,262 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 import org.hibernate.HibernateException;
 import org.hibernate.TypeMismatchException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.type.OneToOneType;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.Type;
 
 /**
  * Contract for nodes representing binary operators.
  *
  * @author Steve Ebersole
  */
 public class BinaryLogicOperatorNode extends HqlSqlWalkerNode implements BinaryOperatorNode {
 	/**
 	 * Performs the operator node initialization by seeking out any parameter
 	 * nodes and setting their expected type, if possible.
 	 */
 	public void initialize() throws SemanticException {
 		Node lhs = getLeftHandOperand();
 		if ( lhs == null ) {
 			throw new SemanticException( "left-hand operand of a binary operator was null" );
 		}
 		Node rhs = getRightHandOperand();
 		if ( rhs == null ) {
 			throw new SemanticException( "right-hand operand of a binary operator was null" );
 		}
 
 		Type lhsType = extractDataType( lhs );
 		Type rhsType = extractDataType( rhs );
 
 		if ( lhsType == null ) {
 			lhsType = rhsType;
 		}
 		if ( rhsType == null ) {
 			rhsType = lhsType;
 		}
 
 		if ( ExpectedTypeAwareNode.class.isAssignableFrom( lhs.getClass() ) ) {
 			( ( ExpectedTypeAwareNode ) lhs ).setExpectedType( rhsType );
 		}
 		if ( ExpectedTypeAwareNode.class.isAssignableFrom( rhs.getClass() ) ) {
 			( ( ExpectedTypeAwareNode ) rhs ).setExpectedType( lhsType );
 		}
 
 		mutateRowValueConstructorSyntaxesIfNecessary( lhsType, rhsType );
 	}
 
 	protected final void mutateRowValueConstructorSyntaxesIfNecessary(Type lhsType, Type rhsType) {
 		// TODO : this really needs to be delayed until after we definitively know all node types
 		// where this is currently a problem is parameters for which where we cannot unequivocally
 		// resolve an expected type
 		SessionFactoryImplementor sessionFactory = getSessionFactoryHelper().getFactory();
 		if ( lhsType != null && rhsType != null ) {
 			int lhsColumnSpan = getColumnSpan( lhsType, sessionFactory );
 			if ( lhsColumnSpan != getColumnSpan( rhsType, sessionFactory ) ) {
 				throw new TypeMismatchException(
 						"left and right hand sides of a binary logic operator were incompatibile [" +
 						lhsType.getName() + " : "+ rhsType.getName() + "]"
 				);
 			}
 			if ( lhsColumnSpan > 1 ) {
 				// for dialects which are known to not support ANSI-SQL row-value-constructor syntax,
 				// we should mutate the tree.
 				if ( !sessionFactory.getDialect().supportsRowValueConstructorSyntax() ) {
 					mutateRowValueConstructorSyntax( lhsColumnSpan );
 				}
 			}
 		}
 	}
 
 	private int getColumnSpan(Type type, SessionFactoryImplementor sfi) {
 		int columnSpan = type.getColumnSpan( sfi );
 		if ( columnSpan == 0 && type instanceof OneToOneType ) {
 			columnSpan = ( ( OneToOneType ) type ).getIdentifierOrUniqueKeyType( sfi ).getColumnSpan( sfi );
 		}
 		return columnSpan;
 	}
 
 	/**
 	 * Mutate the subtree relating to a row-value-constructor to instead use
 	 * a series of ANDed predicates.  This allows multi-column type comparisons
 	 * and explicit row-value-constructor syntax even on databases which do
 	 * not support row-value-constructor.
 	 * <p/>
 	 * For example, here we'd mutate "... where (col1, col2) = ('val1', 'val2) ..." to
 	 * "... where col1 = 'val1' and col2 = 'val2' ..."
 	 *
 	 * @param valueElements The number of elements in the row value constructor list.
 	 */
 	private void mutateRowValueConstructorSyntax(int valueElements) {
 		// mutation depends on the types of nodes involved...
 		int comparisonType = getType();
 		String comparisonText = getText();
 		setType( HqlSqlTokenTypes.AND );
 		setText( "AND" );
 		String[] lhsElementTexts = extractMutationTexts( getLeftHandOperand(), valueElements );
 		String[] rhsElementTexts = extractMutationTexts( getRightHandOperand(), valueElements );
 
 		ParameterSpecification lhsEmbeddedCompositeParameterSpecification =
 				getLeftHandOperand() == null || ( !ParameterNode.class.isInstance( getLeftHandOperand() ) )
 						? null
 						: ( ( ParameterNode ) getLeftHandOperand() ).getHqlParameterSpecification();
 
 		ParameterSpecification rhsEmbeddedCompositeParameterSpecification =
 				getRightHandOperand() == null || ( !ParameterNode.class.isInstance( getRightHandOperand() ) )
 						? null
 						: ( ( ParameterNode ) getRightHandOperand() ).getHqlParameterSpecification();
 
 		translate( valueElements, comparisonType, comparisonText,
                 lhsElementTexts, rhsElementTexts,
                 lhsEmbeddedCompositeParameterSpecification,
                 rhsEmbeddedCompositeParameterSpecification, this );
 	}
 
     protected void translate( int valueElements, int comparisonType,
             String comparisonText, String[] lhsElementTexts,
             String[] rhsElementTexts,
             ParameterSpecification lhsEmbeddedCompositeParameterSpecification,
             ParameterSpecification rhsEmbeddedCompositeParameterSpecification,
             AST container ) {
         for ( int i = valueElements - 1; i > 0; i-- ) {
 			if ( i == 1 ) {
 				AST op1 = getASTFactory().create( comparisonType, comparisonText );
 				AST lhs1 = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, lhsElementTexts[0] );
 				AST rhs1 = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, rhsElementTexts[0] );
 				op1.setFirstChild( lhs1 );
 				lhs1.setNextSibling( rhs1 );
 				container.setFirstChild( op1 );
 				AST op2 = getASTFactory().create( comparisonType, comparisonText );
 				AST lhs2 = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, lhsElementTexts[1] );
 				AST rhs2 = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, rhsElementTexts[1] );
 				op2.setFirstChild( lhs2 );
 				lhs2.setNextSibling( rhs2 );
 				op1.setNextSibling( op2 );
 
 				// "pass along" our initial embedded parameter node(s) to the first generated
 				// sql fragment so that it can be handled later for parameter binding...
 				SqlFragment fragment = ( SqlFragment ) lhs1;
 				if ( lhsEmbeddedCompositeParameterSpecification != null ) {
 					fragment.addEmbeddedParameter( lhsEmbeddedCompositeParameterSpecification );
 				}
 				if ( rhsEmbeddedCompositeParameterSpecification != null ) {
 					fragment.addEmbeddedParameter( rhsEmbeddedCompositeParameterSpecification );
 				}
 			}
 			else {
 				AST op = getASTFactory().create( comparisonType, comparisonText );
 				AST lhs = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, lhsElementTexts[i] );
 				AST rhs = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, rhsElementTexts[i] );
 				op.setFirstChild( lhs );
 				lhs.setNextSibling( rhs );
 				AST newContainer = getASTFactory().create( HqlSqlTokenTypes.AND, "AND" );
 				container.setFirstChild( newContainer );
 				newContainer.setNextSibling( op );
 				container = newContainer;
 			}
 		}
     }
 
 	protected static String[] extractMutationTexts(Node operand, int count) {
 		if ( operand instanceof ParameterNode ) {
 			String[] rtn = new String[count];
 			for ( int i = 0; i < count; i++ ) {
 				rtn[i] = "?";
 			}
 			return rtn;
 		}
 		else if ( operand.getType() == HqlSqlTokenTypes.VECTOR_EXPR ) {
 			String[] rtn = new String[ operand.getNumberOfChildren() ];
 			int x = 0;
 			AST node = operand.getFirstChild();
 			while ( node != null ) {
 				rtn[ x++ ] = node.getText();
 				node = node.getNextSibling();
 			}
 			return rtn;
 		}
 		else if ( operand instanceof SqlNode ) {
 			String nodeText = operand.getText();
 			if ( nodeText.startsWith( "(" ) ) {
 				nodeText = nodeText.substring( 1 );
 			}
 			if ( nodeText.endsWith( ")" ) ) {
 				nodeText = nodeText.substring( 0, nodeText.length() - 1 );
 			}
 			String[] splits = StringHelper.split( ", ", nodeText );
 			if ( count != splits.length ) {
 				throw new HibernateException( "SqlNode's text did not reference expected number of columns" );
 			}
 			return splits;
 		}
 		else {
 			throw new HibernateException( "dont know how to extract row value elements from node : " + operand );
 		}
 	}
 
 	protected Type extractDataType(Node operand) {
 		Type type = null;
 		if ( operand instanceof SqlNode ) {
 			type = ( ( SqlNode ) operand ).getDataType();
 		}
 		if ( type == null && operand instanceof ExpectedTypeAwareNode ) {
 			type = ( ( ExpectedTypeAwareNode ) operand ).getExpectedType();
 		}
 		return type;
 	}
 
 	@Override
     public Type getDataType() {
 		// logic operators by definition resolve to booleans
 		return StandardBasicTypes.BOOLEAN;
 	}
 
 	/**
 	 * Retrieves the left-hand operand of the operator.
 	 *
 	 * @return The left-hand operand
 	 */
 	public Node getLeftHandOperand() {
 		return ( Node ) getFirstChild();
 	}
 
 	/**
 	 * Retrieves the right-hand operand of the operator.
 	 *
 	 * @return The right-hand operand
 	 */
 	public Node getRightHandOperand() {
 		return ( Node ) getFirstChild().getNextSibling();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BinaryOperatorNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BinaryOperatorNode.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BinaryOperatorNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BinaryOperatorNode.java
index 662a379d3c..dc47b1bc5b 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BinaryOperatorNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BinaryOperatorNode.java
@@ -1,47 +1,47 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 
 /**
  * Contract for nodes representing binary operators.
  *
  * @author Steve Ebersole
  */
 public interface BinaryOperatorNode extends OperatorNode {
 	/**
 	 * Retrieves the left-hand operand of the operator.
 	 *
 	 * @return The left-hand operand
 	 */
 	public Node getLeftHandOperand();
 
 	/**
 	 * Retrieves the right-hand operand of the operator.
 	 *
 	 * @return The right-hand operand
 	 */
 	public Node getRightHandOperand();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BooleanLiteralNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BooleanLiteralNode.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BooleanLiteralNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BooleanLiteralNode.java
index 43b733d251..abf8caf7e5 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/BooleanLiteralNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/BooleanLiteralNode.java
@@ -1,73 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import org.hibernate.QueryException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.type.LiteralType;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.Type;
 
 /**
  * Represents a boolean literal within a query.
  *
  * @author Steve Ebersole
  */
 public class BooleanLiteralNode extends LiteralNode implements ExpectedTypeAwareNode {
 	private Type expectedType;
 
 	public Type getDataType() {
 		return expectedType == null ? StandardBasicTypes.BOOLEAN : expectedType;
 	}
 
 	public Boolean getValue() {
 		return getType() == TRUE ? Boolean.TRUE : Boolean.FALSE;
 	}
 
 	@Override
 	public void setExpectedType(Type expectedType) {
 		this.expectedType = expectedType;
 	}
 
 	@Override
 	public Type getExpectedType() {
 		return expectedType;
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public String getRenderText(SessionFactoryImplementor sessionFactory) {
 		try {
 			return typeAsLiteralType().objectToSQLString( getValue(), sessionFactory.getDialect() );
 		}
 		catch( Throwable t ) {
 			throw new QueryException( "Unable to render boolean literal value", t );
 		}
 	}
 
 	private LiteralType typeAsLiteralType() {
 		return (LiteralType) getDataType();
 
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/Case2Node.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/Case2Node.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/Case2Node.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/Case2Node.java
index 619bc76699..825cf22cfb 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/Case2Node.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/Case2Node.java
@@ -1,49 +1,49 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
-import org.hibernate.hql.ast.util.ColumnHelper;
+package org.hibernate.hql.internal.ast.tree;
+import org.hibernate.hql.internal.ast.util.ColumnHelper;
 import org.hibernate.type.Type;
 import antlr.SemanticException;
 
 /**
  * Represents a case ... when .. then ... else ... end expression in a select.
  *
  * @author Gavin King
  */
 public class Case2Node extends AbstractSelectExpression implements SelectExpression {
 	
 	public Type getDataType() {
 		return getFirstThenNode().getDataType();
 	}
 
 	private SelectExpression getFirstThenNode() {
 		return (SelectExpression) getFirstChild().getNextSibling().getFirstChild().getNextSibling();
 	}
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		ColumnHelper.generateSingleScalarColumn( this, i );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/CaseNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/CaseNode.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/CaseNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/CaseNode.java
index 74c3920c89..260a4822c9 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/CaseNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/CaseNode.java
@@ -1,49 +1,49 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
-import org.hibernate.hql.ast.util.ColumnHelper;
+package org.hibernate.hql.internal.ast.tree;
+import org.hibernate.hql.internal.ast.util.ColumnHelper;
 import org.hibernate.type.Type;
 import antlr.SemanticException;
 
 /**
  * Represents a case ... when .. then ... else ... end expression in a select.
  *
  * @author Gavin King
  */
 public class CaseNode extends AbstractSelectExpression implements SelectExpression {
 	
 	public Type getDataType() {
 		return getFirstThenNode().getDataType();
 	}
 
 	private SelectExpression getFirstThenNode() {
 		return (SelectExpression) getFirstChild().getFirstChild().getNextSibling();
 	}
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		ColumnHelper.generateSingleScalarColumn( this, i );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/CollectionFunction.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/CollectionFunction.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/CollectionFunction.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/CollectionFunction.java
index f2e2298d77..8c06782653 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/CollectionFunction.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/CollectionFunction.java
@@ -1,55 +1,55 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * Represents 'elements()' or 'indices()'.
  *
  * @author josh
  */
 public class CollectionFunction extends MethodNode implements DisplayableNode {
 	public void resolve(boolean inSelect) throws SemanticException {
 		initializeMethodNode( this, inSelect );
 		if ( !isCollectionPropertyMethod() ) {
 			throw new SemanticException( this.getText() + " is not a collection property name!" );
 		}
 		AST expr = getFirstChild();
 		if ( expr == null ) {
 			throw new SemanticException( this.getText() + " requires a path!" );
 		}
 		resolveCollectionProperty( expr );
 	}
 
 	protected void prepareSelectColumns(String[] selectColumns) {
 		// we need to strip off the embedded parens so that sql-gen does not double these up
 		String subselect = selectColumns[0].trim();
 		if ( subselect.startsWith( "(") && subselect.endsWith( ")" ) ) {
 			subselect = subselect.substring( 1, subselect.length() -1 );
 		}
 		selectColumns[0] = subselect;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ComponentJoin.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ComponentJoin.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ComponentJoin.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ComponentJoin.java
index 33ecf66b08..a639507c79 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ComponentJoin.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ComponentJoin.java
@@ -1,188 +1,188 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009 by Red Hat Inc and/or its affiliates or by
  * third-party contributors as indicated by either @author tags or express
  * copyright attribution statements applied by the authors.  All
  * third-party contributions are distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import org.hibernate.QueryException;
-import org.hibernate.hql.NameGenerator;
+import org.hibernate.hql.internal.NameGenerator;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.PropertyMapping;
 import org.hibernate.type.ComponentType;
 import org.hibernate.type.Type;
 
 /**
  * Models an explicit join terminating at a component value (e.g. <tt>... from Person p join p.name as n ...</tt>)
  *
  * @author Steve Ebersole
  */
 public class ComponentJoin extends FromElement {
 	private final String componentPath;
 	private final ComponentType componentType;
 
 	private final String componentProperty;
 	private final String columns;
 
 	public ComponentJoin(
 			FromClause fromClause,
 			FromElement origin,
 			String alias,
 			String componentPath,
 			ComponentType componentType) {
 		super( fromClause, origin, alias );
 		this.componentPath = componentPath;
 		this.componentType = componentType;
 		this.componentProperty = StringHelper.unqualify( componentPath );
 		fromClause.addJoinByPathMap( componentPath, this );
 		initializeComponentJoin( new ComponentFromElementType( this ) );
 
 		final String[] cols = origin.getPropertyMapping( "" ).toColumns( getTableAlias(), componentProperty );
 		StringBuffer buf = new StringBuffer();
 		for ( int j = 0; j < cols.length; j++ ) {
 			final String column = cols[j];
 			if ( j > 0 ) {
 				buf.append( ", " );
 			}
 			buf.append( column );
 		}
 		this.columns = buf.toString();
 	}
 
 	public String getComponentPath() {
 		return componentPath;
 	}
 
 	public String getComponentProperty() {
 		return componentProperty;
 	}
 
 	public ComponentType getComponentType() {
 		return componentType;
 	}
 
 
 	@Override
     public Type getDataType() {
 		return getComponentType();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public String getIdentityColumn() {
 		// used to "resolve" the IdentNode when our alias is encountered *by itself* in the query; so
 		//		here we use the component
 		// NOTE : ^^ is true *except for* when encountered by itself in the SELECT clause.  That gets
-		// 		routed through org.hibernate.hql.ast.tree.ComponentJoin.ComponentFromElementType.renderScalarIdentifierSelect()
+		// 		routed through org.hibernate.hql.internal.ast.tree.ComponentJoin.ComponentFromElementType.renderScalarIdentifierSelect()
 		//		which we also override to account for
 		return columns;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public String getDisplayText() {
 		return "ComponentJoin{path=" + getComponentPath() + ", type=" + componentType.getReturnedClass() + "}";
 	}
 
 	public class ComponentFromElementType extends FromElementType {
 		private final PropertyMapping propertyMapping = new ComponentPropertyMapping();
 
 		public ComponentFromElementType(FromElement fromElement) {
 			super( fromElement );
 		}
 
 		@Override
         public Type getDataType() {
 			return getComponentType();
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		@Override
         public QueryableCollection getQueryableCollection() {
 			return null;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		@Override
         public PropertyMapping getPropertyMapping(String propertyName) {
 			return propertyMapping;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		@Override
         public Type getPropertyType(String propertyName, String propertyPath) {
 			int index = getComponentType().getPropertyIndex( propertyName );
 			return getComponentType().getSubtypes()[index];
 		}
 
 		@Override
         public String renderScalarIdentifierSelect(int i) {
 			String[] cols = getBasePropertyMapping().toColumns( getTableAlias(), getComponentProperty() );
 			StringBuffer buf = new StringBuffer();
 			// For property references generate <tablealias>.<columnname> as <projectionalias>
 			for ( int j = 0; j < cols.length; j++ ) {
 				final String column = cols[j];
 				if ( j > 0 ) {
 					buf.append( ", " );
 				}
 				buf.append( column ).append( " as " ).append( NameGenerator.scalarName( i, j ) );
 			}
 			return buf.toString();
 		}
 	}
 
 	protected PropertyMapping getBasePropertyMapping() {
 		return getOrigin().getPropertyMapping( "" );
 	}
 
 	private final class ComponentPropertyMapping implements PropertyMapping {
 		public Type getType() {
 			return getComponentType();
 		}
 
 		public Type toType(String propertyName) throws QueryException {
 			return getBasePropertyMapping().toType( getPropertyPath( propertyName ) );
 		}
 
 		protected String getPropertyPath(String propertyName) {
 			return getComponentPath() + '.' + propertyName;
 		}
 
 		public String[] toColumns(String alias, String propertyName) throws QueryException {
 			return getBasePropertyMapping().toColumns( alias, getPropertyPath( propertyName ) );
 		}
 
 		public String[] toColumns(String propertyName) throws QueryException, UnsupportedOperationException {
 			return getBasePropertyMapping().toColumns( getPropertyPath( propertyName ) );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ConstructorNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ConstructorNode.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ConstructorNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ConstructorNode.java
index c8f5f302ec..a277b31ddd 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ConstructorNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ConstructorNode.java
@@ -1,227 +1,227 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import java.lang.reflect.Constructor;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 import org.hibernate.PropertyNotFoundException;
 import org.hibernate.QueryException;
-import org.hibernate.hql.ast.DetailedSemanticException;
+import org.hibernate.hql.internal.ast.DetailedSemanticException;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.transform.AliasToBeanConstructorResultTransformer;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.transform.Transformers;
 import org.hibernate.type.Type;
 
 /**
  * Represents a constructor (new) in a SELECT.
  *
  * @author josh
  */
 public class ConstructorNode extends SelectExpressionList implements AggregatedSelectExpression {
 	private Class resultType;
 	private Constructor constructor;
 	private Type[] constructorArgumentTypes;
 	private boolean isMap;
 	private boolean isList;
 
 	public ResultTransformer getResultTransformer() {
 		if ( constructor != null ) {
 			return new AliasToBeanConstructorResultTransformer( constructor );
 		}
 		else if ( isMap ) {
 			return Transformers.ALIAS_TO_ENTITY_MAP;
 		}
 		else if ( isList ) {
 			return Transformers.TO_LIST;
 		}
 		throw new QueryException( "Unable to determine proper dynamic-instantiation tranformer to use." );
 	}
 
 	private String[] aggregatedAliases;
 
 	public String[] getAggregatedAliases() {
 		if ( aggregatedAliases == null ) {
 			aggregatedAliases = buildAggregatedAliases();
 		}
 		return aggregatedAliases;
 	}
 
 	private String[] buildAggregatedAliases() {
 		SelectExpression[] selectExpressions = collectSelectExpressions();
 		String[] aliases = new String[selectExpressions.length] ;
 		for ( int i=0; i<selectExpressions.length; i++ ) {
 			String alias = selectExpressions[i].getAlias();
 			aliases[i] = alias==null ? Integer.toString(i) : alias;
 		}
 		return aliases;
 	}
 
 	public void setScalarColumn(int i) throws SemanticException {
 		SelectExpression[] selectExpressions = collectSelectExpressions();
 		// Invoke setScalarColumnText on each constructor argument.
 		for ( int j = 0; j < selectExpressions.length; j++ ) {
 			SelectExpression selectExpression = selectExpressions[j];
 			selectExpression.setScalarColumn( j );
 		}
 	}
 
 	public int getScalarColumnIndex() {
 		return -1;
 	}
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		SelectExpression[] selectExpressions = collectSelectExpressions();
 		// Invoke setScalarColumnText on each constructor argument.
 		for ( int j = 0; j < selectExpressions.length; j++ ) {
 			SelectExpression selectExpression = selectExpressions[j];
 			selectExpression.setScalarColumnText( j );
 		}
 	}
 
 	@Override
     protected AST getFirstSelectExpression() {
 		// Collect the select expressions, skip the first child because it is the class name.
 		return getFirstChild().getNextSibling();
 	}
 
 	@Override
 	public Class getAggregationResultType() {
 		return resultType;
 	}
 
 	/**
 	 * @deprecated (tell clover to ignore this method)
 	 */
 	@Deprecated
     @Override
     public Type getDataType() {
 /*
 		// Return the type of the object created by the constructor.
 		AST firstChild = getFirstChild();
 		String text = firstChild.getText();
 		if ( firstChild.getType() == SqlTokenTypes.DOT ) {
 			DotNode dot = ( DotNode ) firstChild;
 			text = dot.getPath();
 		}
 		return getSessionFactoryHelper().requireEntityType( text );
 */
 		throw new UnsupportedOperationException( "getDataType() is not supported by ConstructorNode!" );
 	}
 
 	public void prepare() throws SemanticException {
 		constructorArgumentTypes = resolveConstructorArgumentTypes();
 		String path = ( ( PathNode ) getFirstChild() ).getPath();
 		if ( "map".equals( path.toLowerCase() ) ) {
 			isMap = true;
 			resultType = Map.class;
 		}
 		else if ( "list".equals( path.toLowerCase() ) ) {
 			isList = true;
 			resultType = List.class;
 		}
 		else {
 			constructor = resolveConstructor( path );
 			resultType = constructor.getDeclaringClass();
 		}
 	}
 
 	private Type[] resolveConstructorArgumentTypes() throws SemanticException {
 		SelectExpression[] argumentExpressions = collectSelectExpressions();
 		if ( argumentExpressions == null ) {
 			// return an empty Type array
 			return new Type[]{};
 		}
 
 		Type[] types = new Type[argumentExpressions.length];
 		for ( int x = 0; x < argumentExpressions.length; x++ ) {
 			types[x] = argumentExpressions[x].getDataType();
 		}
 		return types;
 	}
 
 	private Constructor resolveConstructor(String path) throws SemanticException {
 		String importedClassName = getSessionFactoryHelper().getImportedClassName( path );
 		String className = StringHelper.isEmpty( importedClassName ) ? path : importedClassName;
 		if ( className == null ) {
 			throw new SemanticException( "Unable to locate class [" + path + "]" );
 		}
 		try {
 			Class holderClass = ReflectHelper.classForName( className );
 			return ReflectHelper.getConstructor( holderClass, constructorArgumentTypes );
 		}
 		catch ( ClassNotFoundException e ) {
 			throw new DetailedSemanticException( "Unable to locate class [" + className + "]", e );
 		}
 		catch ( PropertyNotFoundException e ) {
 			// this is the exception returned by ReflectHelper.getConstructor() if it cannot
 			// locate an appropriate constructor
 			throw new DetailedSemanticException( "Unable to locate appropriate constructor on class [" + className + "]", e );
 		}
 	}
 
 	public Constructor getConstructor() {
 		return constructor;
 	}
 
 	public List getConstructorArgumentTypeList() {
 		return Arrays.asList( constructorArgumentTypes );
 	}
 
 	public List getAggregatedSelectionTypeList() {
 		return getConstructorArgumentTypeList();
 	}
 
 	public FromElement getFromElement() {
 		return null;
 	}
 
 	public boolean isConstructor() {
 		return true;
 	}
 
 	public boolean isReturnableEntity() throws SemanticException {
 		return false;
 	}
 
 	public boolean isScalar() {
 		// Constructors are always considered scalar results.
 		return true;
 	}
 
 	public void setAlias(String alias) {
 		throw new UnsupportedOperationException("constructor may not be aliased");
 	}
 
 	public String getAlias() {
 		throw new UnsupportedOperationException("constructor may not be aliased");
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/CountNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/CountNode.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/CountNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/CountNode.java
index ece1a2a3ce..f416d2c459 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/CountNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/CountNode.java
@@ -1,45 +1,45 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
-import org.hibernate.hql.ast.util.ColumnHelper;
+package org.hibernate.hql.internal.ast.tree;
+import org.hibernate.hql.internal.ast.util.ColumnHelper;
 import org.hibernate.type.Type;
 import antlr.SemanticException;
 
 /**
  * Represents a COUNT expression in a select.
  *
  * @author josh
  */
 public class CountNode extends AbstractSelectExpression implements SelectExpression {
 	
 	public Type getDataType() {
 		return getSessionFactoryHelper().findFunctionReturnType( getText(), null );
 	}
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		ColumnHelper.generateSingleScalarColumn( this, i );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/DeleteStatement.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/DeleteStatement.java
similarity index 85%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/DeleteStatement.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/DeleteStatement.java
index 9cf021b8ab..b7e0a06283 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/DeleteStatement.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/DeleteStatement.java
@@ -1,64 +1,64 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
 
 import org.jboss.logging.Logger;
 
 /**
  * Defines a top-level AST node representing an HQL delete statement.
  *
  * @author Steve Ebersole
  */
 public class DeleteStatement extends AbstractRestrictableStatement {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, DeleteStatement.class.getName());
 
 	/**
-	 * @see org.hibernate.hql.ast.tree.Statement#getStatementType()
+	 * @see org.hibernate.hql.internal.ast.tree.Statement#getStatementType()
 	 */
 	public int getStatementType() {
 		return HqlSqlTokenTypes.DELETE;
 	}
 
 	/**
-	 * @see org.hibernate.hql.ast.tree.Statement#needsExecutor()
+	 * @see org.hibernate.hql.internal.ast.tree.Statement#needsExecutor()
 	 */
 	public boolean needsExecutor() {
 		return true;
 	}
 
 	@Override
     protected int getWhereClauseParentTokenType() {
 		return SqlTokenTypes.FROM;
 	}
 
     @Override
     protected CoreMessageLogger getLog() {
         return LOG;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/DisplayableNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/DisplayableNode.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/DisplayableNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/DisplayableNode.java
index 6a7558898d..09a4b0f18d 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/DisplayableNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/DisplayableNode.java
@@ -1,40 +1,40 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 
 /**
  * Implementors will return additional display text, which will be used
  * by the ASTPrinter to display information (besides the node type and node
  * text).
  */
 public interface DisplayableNode {
 	/**
 	 * Returns additional display text for the AST node.
 	 *
 	 * @return String - The additional display text.
 	 */
 	String getDisplayText();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/DotNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/DotNode.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/DotNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/DotNode.java
index d0b8049deb..5a965ccfd7 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/DotNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/DotNode.java
@@ -1,689 +1,689 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import org.hibernate.engine.internal.JoinSequence;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.QueryException;
-import org.hibernate.hql.CollectionProperties;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.util.ASTUtil;
-import org.hibernate.hql.ast.util.ColumnHelper;
+import org.hibernate.hql.internal.CollectionProperties;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
+import org.hibernate.hql.internal.ast.util.ColumnHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * Represents a reference to a property or alias expression.  This should duplicate the relevant behaviors in
  * PathExpressionParser.
  *
  * @author Joshua Davis
  */
 public class DotNode extends FromReferenceNode implements DisplayableNode, SelectExpression {
 
 	///////////////////////////////////////////////////////////////////////////
 	// USED ONLY FOR REGRESSION TESTING!!!!
 	//
 	// todo : obviously get rid of all this junk ;)
 	///////////////////////////////////////////////////////////////////////////
 	public static boolean useThetaStyleImplicitJoins = false;
 	public static boolean REGRESSION_STYLE_JOIN_SUPPRESSION = false;
 	public static interface IllegalCollectionDereferenceExceptionBuilder {
 		public QueryException buildIllegalCollectionDereferenceException(String collectionPropertyName, FromReferenceNode lhs);
 	}
 	public static final IllegalCollectionDereferenceExceptionBuilder DEF_ILLEGAL_COLL_DEREF_EXCP_BUILDER = new IllegalCollectionDereferenceExceptionBuilder() {
 		public QueryException buildIllegalCollectionDereferenceException(String propertyName, FromReferenceNode lhs) {
 			String lhsPath = ASTUtil.getPathText( lhs );
 			return new QueryException( "illegal attempt to dereference collection [" + lhsPath + "] with element property reference [" + propertyName + "]" );
 		}
 	};
 	public static IllegalCollectionDereferenceExceptionBuilder ILLEGAL_COLL_DEREF_EXCP_BUILDER = DEF_ILLEGAL_COLL_DEREF_EXCP_BUILDER;
 	///////////////////////////////////////////////////////////////////////////
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, DotNode.class.getName());
 
 	private static final int DEREF_UNKNOWN = 0;
 	private static final int DEREF_ENTITY = 1;
 	private static final int DEREF_COMPONENT = 2;
 	private static final int DEREF_COLLECTION = 3;
 	private static final int DEREF_PRIMITIVE = 4;
 	private static final int DEREF_IDENTIFIER = 5;
 	private static final int DEREF_JAVA_CONSTANT = 6;
 
 	/**
 	 * The identifier that is the name of the property.
 	 */
 	private String propertyName;
 	/**
 	 * The full path, to the root alias of this dot node.
 	 */
 	private String path;
 	/**
 	 * The unresolved property path relative to this dot node.
 	 */
 	private String propertyPath;
 
 	/**
 	 * The column names that this resolves to.
 	 */
 	private String[] columns;
 
 	/**
 	 * The type of join to create.   Default is an inner join.
 	 */
 	private int joinType = JoinFragment.INNER_JOIN;
 
 	/**
 	 * Fetch join or not.
 	 */
 	private boolean fetch = false;
 
 	/**
 	 * The type of dereference that hapened (DEREF_xxx).
 	 */
 	private int dereferenceType = DEREF_UNKNOWN;
 
 	private FromElement impliedJoin;
 
 	/**
 	 * Sets the join type for this '.' node structure.
 	 *
 	 * @param joinType The type of join to use.
 	 * @see JoinFragment
 	 */
 	public void setJoinType(int joinType) {
 		this.joinType = joinType;
 	}
 
 	private String[] getColumns() throws QueryException {
 		if ( columns == null ) {
 			// Use the table fromElement and the property name to get the array of column names.
 			String tableAlias = getLhs().getFromElement().getTableAlias();
 			columns = getFromElement().toColumns( tableAlias, propertyPath, false );
 		}
 		return columns;
 	}
 
 	@Override
     public String getDisplayText() {
 		StringBuffer buf = new StringBuffer();
 		FromElement fromElement = getFromElement();
 		buf.append( "{propertyName=" ).append( propertyName );
 		buf.append( ",dereferenceType=" ).append( getWalker().getASTPrinter().getTokenTypeName( dereferenceType ) );
 		buf.append( ",propertyPath=" ).append( propertyPath );
 		buf.append( ",path=" ).append( getPath() );
 		if ( fromElement != null ) {
 			buf.append( ",tableAlias=" ).append( fromElement.getTableAlias() );
 			buf.append( ",className=" ).append( fromElement.getClassName() );
 			buf.append( ",classAlias=" ).append( fromElement.getClassAlias() );
 		}
 		else {
 			buf.append( ",no from element" );
 		}
 		buf.append( '}' );
 		return buf.toString();
 	}
 
 	/**
 	 * Resolves the left hand side of the DOT.
 	 *
 	 * @throws SemanticException
 	 */
 	@Override
     public void resolveFirstChild() throws SemanticException {
 		FromReferenceNode lhs = ( FromReferenceNode ) getFirstChild();
 		SqlNode property = ( SqlNode ) lhs.getNextSibling();
 
 		// Set the attributes of the property reference expression.
 		String propName = property.getText();
 		propertyName = propName;
 		// If the uresolved property path isn't set yet, just use the property name.
 		if ( propertyPath == null ) {
 			propertyPath = propName;
 		}
 		// Resolve the LHS fully, generate implicit joins.  Pass in the property name so that the resolver can
 		// discover foreign key (id) properties.
 		lhs.resolve( true, true, null, this );
 		setFromElement( lhs.getFromElement() );			// The 'from element' that the property is in.
 
 		checkSubclassOrSuperclassPropertyReference( lhs, propName );
 	}
 
 	@Override
     public void resolveInFunctionCall(boolean generateJoin, boolean implicitJoin) throws SemanticException {
 		if ( isResolved() ) {
 			return;
 		}
 		Type propertyType = prepareLhs();			// Prepare the left hand side and get the data type.
 		if ( propertyType!=null && propertyType.isCollectionType() ) {
 			resolveIndex(null);
 		}
 		else {
 			resolveFirstChild();
 			super.resolve(generateJoin, implicitJoin);
 		}
 	}
 
 
 	public void resolveIndex(AST parent) throws SemanticException {
 		if ( isResolved() ) {
 			return;
 		}
 		Type propertyType = prepareLhs();			// Prepare the left hand side and get the data type.
 		dereferenceCollection( ( CollectionType ) propertyType, true, true, null, parent );
 	}
 
 	public void resolve(boolean generateJoin, boolean implicitJoin, String classAlias, AST parent)
 	throws SemanticException {
 		// If this dot has already been resolved, stop now.
 		if ( isResolved() ) {
 			return;
 		}
 		Type propertyType = prepareLhs(); // Prepare the left hand side and get the data type.
 
 		// If there is no data type for this node, and we're at the end of the path (top most dot node), then
 		// this might be a Java constant.
 		if ( propertyType == null ) {
 			if ( parent == null ) {
 				getWalker().getLiteralProcessor().lookupConstant( this );
 			}
 			// If the propertyType is null and there isn't a parent, just
 			// stop now... there was a problem resolving the node anyway.
 			return;
 		}
 
 		if ( propertyType.isComponentType() ) {
 			// The property is a component...
 			checkLhsIsNotCollection();
 			dereferenceComponent( parent );
 			initText();
 		}
 		else if ( propertyType.isEntityType() ) {
 			// The property is another class..
 			checkLhsIsNotCollection();
 			dereferenceEntity( ( EntityType ) propertyType, implicitJoin, classAlias, generateJoin, parent );
 			initText();
 		}
 		else if ( propertyType.isCollectionType() ) {
 			// The property is a collection...
 			checkLhsIsNotCollection();
 			dereferenceCollection( ( CollectionType ) propertyType, implicitJoin, false, classAlias, parent );
 		}
 		else {
 			// Otherwise, this is a primitive type.
 			if ( ! CollectionProperties.isAnyCollectionProperty( propertyName ) ) {
 				checkLhsIsNotCollection();
 			}
 			dereferenceType = DEREF_PRIMITIVE;
 			initText();
 		}
 		setResolved();
 	}
 
 	private void initText() {
 		String[] cols = getColumns();
 		String text = StringHelper.join( ", ", cols );
 		if ( cols.length > 1 && getWalker().isComparativeExpressionClause() ) {
 			text = "(" + text + ")";
 		}
 		setText( text );
 	}
 
 	private Type prepareLhs() throws SemanticException {
 		FromReferenceNode lhs = getLhs();
 		lhs.prepareForDot( propertyName );
 		return getDataType();
 	}
 
 	private void dereferenceCollection(CollectionType collectionType, boolean implicitJoin, boolean indexed, String classAlias, AST parent)
 	throws SemanticException {
 
 		dereferenceType = DEREF_COLLECTION;
 		String role = collectionType.getRole();
 
 		//foo.bars.size (also handles deprecated stuff like foo.bars.maxelement for backwardness)
 		boolean isSizeProperty = getNextSibling()!=null &&
 			CollectionProperties.isAnyCollectionProperty( getNextSibling().getText() );
 
 		if ( isSizeProperty ) indexed = true; //yuck!
 
 		QueryableCollection queryableCollection = getSessionFactoryHelper().requireQueryableCollection( role );
 		String propName = getPath();
 		FromClause currentFromClause = getWalker().getCurrentFromClause();
 
 		if ( getWalker().getStatementType() != SqlTokenTypes.SELECT && indexed && classAlias == null ) {
 			// should indicate that we are processing an INSERT/UPDATE/DELETE
 			// query with a subquery implied via a collection property
 			// function. Here, we need to use the table name itself as the
 			// qualification alias.
 			// TODO : verify this works for all databases...
 			// TODO : is this also the case in non-"indexed" scenarios?
 			String alias = getLhs().getFromElement().getQueryable().getTableName();
 			columns = getFromElement().toColumns( alias, propertyPath, false, true );
 		}
 
 		//We do not look for an existing join on the same path, because
 		//it makes sense to join twice on the same collection role
 		FromElementFactory factory = new FromElementFactory(
 		        currentFromClause,
 		        getLhs().getFromElement(),
 		        propName,
 				classAlias,
 		        getColumns(),
 		        implicitJoin
 		);
 		FromElement elem = factory.createCollection( queryableCollection, role, joinType, fetch, indexed );
 
         LOG.debugf("dereferenceCollection() : Created new FROM element for %s : %s", propName, elem);
 
 		setImpliedJoin( elem );
 		setFromElement( elem );	// This 'dot' expression now refers to the resulting from element.
 
 		if ( isSizeProperty ) {
 			elem.setText("");
 			elem.setUseWhereFragment(false);
 		}
 
 		if ( !implicitJoin ) {
 			EntityPersister entityPersister = elem.getEntityPersister();
 			if ( entityPersister != null ) {
 				getWalker().addQuerySpaces( entityPersister.getQuerySpaces() );
 			}
 		}
 		getWalker().addQuerySpaces( queryableCollection.getCollectionSpaces() );	// Always add the collection's query spaces.
 	}
 
 	private void dereferenceEntity(EntityType entityType, boolean implicitJoin, String classAlias, boolean generateJoin, AST parent) throws SemanticException {
 		checkForCorrelatedSubquery( "dereferenceEntity" );
 		// three general cases we check here as to whether to render a physical SQL join:
 		// 1) is our parent a DotNode as well?  If so, our property reference is
 		// 		being further de-referenced...
 		// 2) is this a DML statement
 		// 3) we were asked to generate any needed joins (generateJoins==true) *OR*
 		//		we are currently processing a select or from clause
 		// (an additional check is the REGRESSION_STYLE_JOIN_SUPPRESSION check solely intended for the test suite)
 		//
 		// The REGRESSION_STYLE_JOIN_SUPPRESSION is an additional check
 		// intended solely for use within the test suite.  This forces the
 		// implicit join resolution to behave more like the classic parser.
 		// The underlying issue is that classic translator is simply wrong
 		// about its decisions on whether or not to render an implicit join
 		// into a physical SQL join in a lot of cases.  The piece it generally
 		// tends to miss is that INNER joins effect the results by further
 		// restricting the data set!  A particular manifestation of this is
 		// the fact that the classic translator will skip the physical join
 		// for ToOne implicit joins *if the query is shallow*; the result
 		// being that Query.list() and Query.iterate() could return
 		// different number of results!
 		DotNode parentAsDotNode = null;
 		String property = propertyName;
 		final boolean joinIsNeeded;
 
 		if ( isDotNode( parent ) ) {
 			// our parent is another dot node, meaning we are being further dereferenced.
 			// thus we need to generate a join unless the parent refers to the associated
 			// entity's PK (because 'our' table would know the FK).
 			parentAsDotNode = ( DotNode ) parent;
 			property = parentAsDotNode.propertyName;
 			joinIsNeeded = generateJoin && !isReferenceToPrimaryKey( parentAsDotNode.propertyName, entityType );
 		}
 		else if ( ! getWalker().isSelectStatement() ) {
 			// in non-select queries, the only time we should need to join is if we are in a subquery from clause
 			joinIsNeeded = getWalker().getCurrentStatementType() == SqlTokenTypes.SELECT && getWalker().isInFrom();
 		}
 		else if ( REGRESSION_STYLE_JOIN_SUPPRESSION ) {
 			// this is the regression style determination which matches the logic of the classic translator
 			joinIsNeeded = generateJoin && ( !getWalker().isInSelect() || !getWalker().isShallowQuery() );
 		}
 		else {
 			joinIsNeeded = generateJoin || ( getWalker().isInSelect() || getWalker().isInFrom() );
 		}
 
 		if ( joinIsNeeded ) {
 			dereferenceEntityJoin( classAlias, entityType, implicitJoin, parent );
 		}
 		else {
 			dereferenceEntityIdentifier( property, parentAsDotNode );
 		}
 
 	}
 
 	private boolean isDotNode(AST n) {
 		return n != null && n.getType() == SqlTokenTypes.DOT;
 	}
 
 	private void dereferenceEntityJoin(String classAlias, EntityType propertyType, boolean impliedJoin, AST parent)
 	throws SemanticException {
 		dereferenceType = DEREF_ENTITY;
         if (LOG.isDebugEnabled()) LOG.debugf("dereferenceEntityJoin() : generating join for %s in %s (%s) parent = %s",
                                              propertyName,
                                              getFromElement().getClassName(),
                                              classAlias == null ? "<no alias>" : classAlias,
                                              ASTUtil.getDebugString(parent));
 		// Create a new FROM node for the referenced class.
 		String associatedEntityName = propertyType.getAssociatedEntityName();
 		String tableAlias = getAliasGenerator().createName( associatedEntityName );
 
 		String[] joinColumns = getColumns();
 		String joinPath = getPath();
 
 		if ( impliedJoin && getWalker().isInFrom() ) {
 			joinType = getWalker().getImpliedJoinType();
 		}
 
 		FromClause currentFromClause = getWalker().getCurrentFromClause();
 		FromElement elem = currentFromClause.findJoinByPath( joinPath );
 
 ///////////////////////////////////////////////////////////////////////////////
 //
 // This is the piece which recognizes the condition where an implicit join path
 // resolved earlier in a correlated subquery is now being referenced in the
 // outer query.  For 3.0final, we just let this generate a second join (which
 // is exactly how the old parser handles this).  Eventually we need to add this
 // logic back in and complete the logic in FromClause.promoteJoin; however,
 // FromClause.promoteJoin has its own difficulties (see the comments in
 // FromClause.promoteJoin).
 //
 //		if ( elem == null ) {
 //			// see if this joinPath has been used in a "child" FromClause, and if so
 //			// promote that element to the outer query
 //			FromClause currentNodeOwner = getFromElement().getFromClause();
 //			FromClause currentJoinOwner = currentNodeOwner.locateChildFromClauseWithJoinByPath( joinPath );
 //			if ( currentJoinOwner != null && currentNodeOwner != currentJoinOwner ) {
 //				elem = currentJoinOwner.findJoinByPathLocal( joinPath );
 //				if ( elem != null ) {
 //					currentFromClause.promoteJoin( elem );
 //					// EARLY EXIT!!!
 //					return;
 //				}
 //			}
 //		}
 //
 ///////////////////////////////////////////////////////////////////////////////
 
 		boolean found = elem != null;
 		// even though we might find a pre-existing element by join path, for FromElements originating in a from-clause
 		// we should only ever use the found element if the aliases match (null != null here).  Implied joins are
 		// always (?) ok to reuse.
 		boolean useFoundFromElement = found && ( elem.isImplied() || areSame( classAlias, elem.getClassAlias() ) );
 
 		if ( ! useFoundFromElement ) {
 			// If this is an implied join in a from element, then use the impled join type which is part of the
 			// tree parser's state (set by the gramamar actions).
 			JoinSequence joinSequence = getSessionFactoryHelper()
 				.createJoinSequence( impliedJoin, propertyType, tableAlias, joinType, joinColumns );
 
 			// If the lhs of the join is a "component join", we need to go back to the
 			// first non-component-join as the origin to properly link aliases and
 			// join columns
 			FromElement lhsFromElement = getLhs().getFromElement();
 			while ( lhsFromElement != null &&  ComponentJoin.class.isInstance( lhsFromElement ) ) {
 				lhsFromElement = lhsFromElement.getOrigin();
 			}
 			if ( lhsFromElement == null ) {
 				throw new QueryException( "Unable to locate appropriate lhs" );
 			}
 
 			FromElementFactory factory = new FromElementFactory(
 			        currentFromClause,
 					lhsFromElement,
 					joinPath,
 					classAlias,
 					joinColumns,
 					impliedJoin
 			);
 			elem = factory.createEntityJoin(
 					associatedEntityName,
 					tableAlias,
 					joinSequence,
 					fetch,
 					getWalker().isInFrom(),
 					propertyType
 			);
 		}
 		else {
 			// NOTE : addDuplicateAlias() already performs nullness checks on the alias.
 			currentFromClause.addDuplicateAlias( classAlias, elem );
 		}
 		setImpliedJoin( elem );
 		getWalker().addQuerySpaces( elem.getEntityPersister().getQuerySpaces() );
 		setFromElement( elem );	// This 'dot' expression now refers to the resulting from element.
 	}
 
 	private boolean areSame(String alias1, String alias2) {
 		// again, null != null here
 		return !StringHelper.isEmpty( alias1 ) && !StringHelper.isEmpty( alias2 ) && alias1.equals( alias2 );
 	}
 
 	private void setImpliedJoin(FromElement elem) {
 		this.impliedJoin = elem;
 		if ( getFirstChild().getType() == SqlTokenTypes.DOT ) {
 			DotNode dotLhs = ( DotNode ) getFirstChild();
 			if ( dotLhs.getImpliedJoin() != null ) {
 				this.impliedJoin = dotLhs.getImpliedJoin();
 			}
 		}
 	}
 
 	@Override
     public FromElement getImpliedJoin() {
 		return impliedJoin;
 	}
 
 	/**
 	 * Is the given property name a reference to the primary key of the associated
 	 * entity construed by the given entity type?
 	 * <p/>
 	 * For example, consider a fragment like order.customer.id
 	 * (where order is a from-element alias).  Here, we'd have:
 	 * propertyName = "id" AND
 	 * owningType = ManyToOneType(Customer)
 	 * and are being asked to determine whether "customer.id" is a reference
 	 * to customer's PK...
 	 *
 	 * @param propertyName The name of the property to check.
 	 * @param owningType The type represeting the entity "owning" the property
 	 * @return True if propertyName references the entity's (owningType->associatedEntity)
 	 * primary key; false otherwise.
 	 */
 	private boolean isReferenceToPrimaryKey(String propertyName, EntityType owningType) {
 		EntityPersister persister = getSessionFactoryHelper()
 				.getFactory()
 				.getEntityPersister( owningType.getAssociatedEntityName() );
 		if ( persister.getEntityMetamodel().hasNonIdentifierPropertyNamedId() ) {
 			// only the identifier property field name can be a reference to the associated entity's PK...
 			return propertyName.equals( persister.getIdentifierPropertyName() ) && owningType.isReferenceToPrimaryKey();
 		}
         // here, we have two possibilities:
         // 1) the property-name matches the explicitly identifier property name
         // 2) the property-name matches the implicit 'id' property name
         // the referenced node text is the special 'id'
         if (EntityPersister.ENTITY_ID.equals(propertyName)) return owningType.isReferenceToPrimaryKey();
         String keyPropertyName = getSessionFactoryHelper().getIdentifierOrUniqueKeyPropertyName(owningType);
         return keyPropertyName != null && keyPropertyName.equals(propertyName) && owningType.isReferenceToPrimaryKey();
 	}
 
 	private void checkForCorrelatedSubquery(String methodName) {
         if (isCorrelatedSubselect()) LOG.debugf("%s() : correlated subquery", methodName);
 	}
 
 	private boolean isCorrelatedSubselect() {
 		return getWalker().isSubQuery() &&
 			getFromElement().getFromClause() != getWalker().getCurrentFromClause();
 	}
 
 	private void checkLhsIsNotCollection() throws SemanticException {
 		if ( getLhs().getDataType() != null && getLhs().getDataType().isCollectionType() ) {
 			throw ILLEGAL_COLL_DEREF_EXCP_BUILDER.buildIllegalCollectionDereferenceException( propertyName, getLhs() );
 		}
 	}
 	private void dereferenceComponent(AST parent) {
 		dereferenceType = DEREF_COMPONENT;
 		setPropertyNameAndPath( parent );
 	}
 
 	private void dereferenceEntityIdentifier(String propertyName, DotNode dotParent) {
 		// special shortcut for id properties, skip the join!
 		// this must only occur at the _end_ of a path expression
         LOG.debugf("dereferenceShortcut() : property %s in %s does not require a join.",
                    propertyName,
                    getFromElement().getClassName());
 
 		initText();
 		setPropertyNameAndPath( dotParent ); // Set the unresolved path in this node and the parent.
 		// Set the text for the parent.
 		if ( dotParent != null ) {
 			dotParent.dereferenceType = DEREF_IDENTIFIER;
 			dotParent.setText( getText() );
 			dotParent.columns = getColumns();
 		}
 	}
 
 	private void setPropertyNameAndPath(AST parent) {
 		if ( isDotNode( parent ) ) {
 			DotNode dotNode = ( DotNode ) parent;
 			AST lhs = dotNode.getFirstChild();
 			AST rhs = lhs.getNextSibling();
 			propertyName = rhs.getText();
 			propertyPath = propertyPath + "." + propertyName; // Append the new property name onto the unresolved path.
 			dotNode.propertyPath = propertyPath;
             LOG.debugf("Unresolved property path is now '%s'", dotNode.propertyPath);
         } else LOG.debugf("Terminal propertyPath = [%s]", propertyPath);
 	}
 
 	@Override
     public Type getDataType() {
 		if ( super.getDataType() == null ) {
 			FromElement fromElement = getLhs().getFromElement();
             if (fromElement == null) return null;
 			// If the lhs is a collection, use CollectionPropertyMapping
 			Type propertyType = fromElement.getPropertyType( propertyName, propertyPath );
             LOG.debugf("getDataType() : %s -> %s", propertyPath, propertyType);
 			super.setDataType( propertyType );
 		}
 		return super.getDataType();
 	}
 
 	public void setPropertyPath(String propertyPath) {
 		this.propertyPath = propertyPath;
 	}
 
 	public String getPropertyPath() {
 		return propertyPath;
 	}
 
 	public FromReferenceNode getLhs() {
 		FromReferenceNode lhs = ( ( FromReferenceNode ) getFirstChild() );
 		if ( lhs == null ) {
 			throw new IllegalStateException( "DOT node with no left-hand-side!" );
 		}
 		return lhs;
 	}
 
 	/**
 	 * Returns the full path of the node.
 	 *
 	 * @return the full path of the node.
 	 */
 	@Override
     public String getPath() {
 		if ( path == null ) {
 			FromReferenceNode lhs = getLhs();
 			if ( lhs == null ) {
 				path = getText();
 			}
 			else {
 				SqlNode rhs = ( SqlNode ) lhs.getNextSibling();
 				path = lhs.getPath() + "." + rhs.getOriginalText();
 			}
 		}
 		return path;
 	}
 
 	public void setFetch(boolean fetch) {
 		this.fetch = fetch;
 	}
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		String[] sqlColumns = getColumns();
 		ColumnHelper.generateScalarColumns( this, sqlColumns, i );
 	}
 
 	/**
 	 * Special method to resolve expressions in the SELECT list.
 	 *
 	 * @throws SemanticException if this cannot be resolved.
 	 */
 	public void resolveSelectExpression() throws SemanticException {
 		if ( getWalker().isShallowQuery() || getWalker().getCurrentFromClause().isSubQuery() ) {
 			resolve(false, true);
 		}
 		else {
 			resolve(true, false);
 			Type type = getDataType();
 			if ( type.isEntityType() ) {
 				FromElement fromElement = getFromElement();
 				fromElement.setIncludeSubclasses( true ); // Tell the destination fromElement to 'includeSubclasses'.
 				if ( useThetaStyleImplicitJoins ) {
 					fromElement.getJoinSequence().setUseThetaStyle( true );	// Use theta style (for regression)
 					// Move the node up, after the origin node.
 					FromElement origin = fromElement.getOrigin();
 					if ( origin != null ) {
 						ASTUtil.makeSiblingOfParent( origin, fromElement );
 					}
 				}
 			}
 		}
 
 		FromReferenceNode lhs = getLhs();
 		while ( lhs != null ) {
 			checkSubclassOrSuperclassPropertyReference( lhs, lhs.getNextSibling().getText() );
 			lhs = ( FromReferenceNode ) lhs.getFirstChild();
 		}
 	}
 
 	public void setResolvedConstant(String text) {
 		path = text;
 		dereferenceType = DEREF_JAVA_CONSTANT;
 		setResolved(); // Don't resolve the node again.
 	}
 
 	private boolean checkSubclassOrSuperclassPropertyReference(FromReferenceNode lhs, String propertyName) {
 		if ( lhs != null && !( lhs instanceof IndexNode ) ) {
 			final FromElement source = lhs.getFromElement();
 			if ( source != null ) {
 				source.handlePropertyBeingDereferenced( lhs.getDataType(), propertyName );
 			}
 		}
 		return false;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ExpectedTypeAwareNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ExpectedTypeAwareNode.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ExpectedTypeAwareNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ExpectedTypeAwareNode.java
index f6d749a3bc..1c0df9eb90 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ExpectedTypeAwareNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ExpectedTypeAwareNode.java
@@ -1,37 +1,37 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Middleware LLC.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- *
- */
-package org.hibernate.hql.ast.tree;
-import org.hibernate.type.Type;
-
-/**
- * Interface for nodes which wish to be made aware of any determined "expected
- * type" based on the context within they appear in the query.
- *
- * @author Steve Ebersole
- */
-public interface ExpectedTypeAwareNode {
-	public void setExpectedType(Type expectedType);
-	public Type getExpectedType();
-}
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Middleware LLC.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ *
+ */
+package org.hibernate.hql.internal.ast.tree;
+import org.hibernate.type.Type;
+
+/**
+ * Interface for nodes which wish to be made aware of any determined "expected
+ * type" based on the context within they appear in the query.
+ *
+ * @author Steve Ebersole
+ */
+public interface ExpectedTypeAwareNode {
+	public void setExpectedType(Type expectedType);
+	public Type getExpectedType();
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromClause.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromClause.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromClause.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromClause.java
index ab28190c74..6df0eda8c7 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromClause.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromClause.java
@@ -1,407 +1,407 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.ast.util.ASTIterator;
-import org.hibernate.hql.ast.util.ASTUtil;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.ast.util.ASTIterator;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
 import org.jboss.logging.Logger;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * Represents the 'FROM' part of a query or subquery, containing all mapped class references.
  *
  * @author josh
  */
 public class FromClause extends HqlSqlWalkerNode implements HqlSqlTokenTypes, DisplayableNode {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, FromClause.class.getName());
 	public static final int ROOT_LEVEL = 1;
 
 	private int level = ROOT_LEVEL;
 	private Set fromElements = new HashSet();
 	private Map fromElementByClassAlias = new HashMap();
 	private Map fromElementByTableAlias = new HashMap();
 	private Map fromElementsByPath = new HashMap();
 
 	/**
 	 * All of the implicit FROM xxx JOIN yyy elements that are the destination of a collection.  These are created from
 	 * index operators on collection property references.
 	 */
 	private Map collectionJoinFromElementsByPath = new HashMap();
 	/**
 	 * Pointer to the parent FROM clause, if there is one.
 	 */
 	private FromClause parentFromClause;
 	/**
 	 * Collection of FROM clauses of which this is the parent.
 	 */
 	private Set childFromClauses;
 	/**
 	 * Counts the from elements as they are added.
 	 */
 	private int fromElementCounter = 0;
 	/**
 	 * Implied FROM elements to add onto the end of the FROM clause.
 	 */
 	private List impliedElements = new LinkedList();
 
 	/**
 	 * Adds a new from element to the from node.
 	 *
 	 * @param path  The reference to the class.
 	 * @param alias The alias AST.
 	 * @return FromElement - The new FROM element.
 	 */
 	public FromElement addFromElement(String path, AST alias) throws SemanticException {
 		// The path may be a reference to an alias defined in the parent query.
 		String classAlias = ( alias == null ) ? null : alias.getText();
 		checkForDuplicateClassAlias( classAlias );
 		FromElementFactory factory = new FromElementFactory( this, null, path, classAlias, null, false );
 		return factory.addFromElement();
 	}
 
 	void registerFromElement(FromElement element) {
 		fromElements.add( element );
 		String classAlias = element.getClassAlias();
 		if ( classAlias != null ) {
 			// The HQL class alias refers to the class name.
 			fromElementByClassAlias.put( classAlias, element );
 		}
 		// Associate the table alias with the element.
 		String tableAlias = element.getTableAlias();
 		if ( tableAlias != null ) {
 			fromElementByTableAlias.put( tableAlias, element );
 		}
 	}
 
 	void addDuplicateAlias(String alias, FromElement element) {
 		if ( alias != null ) {
 			fromElementByClassAlias.put( alias, element );
 		}
 	}
 
 	private void checkForDuplicateClassAlias(String classAlias) throws SemanticException {
 		if ( classAlias != null && fromElementByClassAlias.containsKey( classAlias ) ) {
 			throw new SemanticException( "Duplicate definition of alias '" + classAlias + "'" );
 		}
 	}
 
 	/**
 	 * Retreives the from-element represented by the given alias.
 	 *
 	 * @param aliasOrClassName The alias by which to locate the from-element.
 	 * @return The from-element assigned the given alias, or null if none.
 	 */
 	public FromElement getFromElement(String aliasOrClassName) {
 		FromElement fromElement = ( FromElement ) fromElementByClassAlias.get( aliasOrClassName );
 		if ( fromElement == null && getSessionFactoryHelper().isStrictJPAQLComplianceEnabled() ) {
 			fromElement = findIntendedAliasedFromElementBasedOnCrazyJPARequirements( aliasOrClassName );
 		}
 		if ( fromElement == null && parentFromClause != null ) {
 			fromElement = parentFromClause.getFromElement( aliasOrClassName );
 		}
 		return fromElement;
 	}
 
 	public FromElement findFromElementBySqlAlias(String sqlAlias) {
 		FromElement fromElement = ( FromElement ) fromElementByTableAlias.get( sqlAlias );
 		if ( fromElement == null && parentFromClause != null ) {
 			fromElement = parentFromClause.getFromElement( sqlAlias );
 		}
 		return fromElement;
 	}
 
 	public FromElement findFromElementByUserOrSqlAlias(String userAlias, String sqlAlias) {
 		FromElement fromElement = null;
 		if ( userAlias != null ) {
 			fromElement = getFromElement( userAlias );
 		}
 
 		if ( fromElement == null ) {
 			fromElement = findFromElementBySqlAlias( sqlAlias );
 		}
 
 		return fromElement;
 	}
 
 	private FromElement findIntendedAliasedFromElementBasedOnCrazyJPARequirements(String specifiedAlias) {
 		Iterator itr = fromElementByClassAlias.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			Map.Entry entry = ( Map.Entry ) itr.next();
 			String alias = ( String ) entry.getKey();
 			if ( alias.equalsIgnoreCase( specifiedAlias ) ) {
 				return ( FromElement ) entry.getValue();
 			}
 		}
 		return null;
 	}
 
 	/**
 	 * Convenience method to check whether a given token represents a from-element alias.
 	 *
 	 * @param possibleAlias The potential from-element alias to check.
 	 * @return True if the possibleAlias is an alias to a from-element visible
 	 *         from this point in the query graph.
 	 */
 	public boolean isFromElementAlias(String possibleAlias) {
 		boolean isAlias = containsClassAlias( possibleAlias );
 		if ( !isAlias && parentFromClause != null ) {
 			// try the parent FromClause...
 			isAlias = parentFromClause.isFromElementAlias( possibleAlias );
 		}
 		return isAlias;
 	}
 
 	/**
 	 * Returns the list of from elements in order.
 	 *
 	 * @return the list of from elements (instances of FromElement).
 	 */
 	public List getFromElements() {
 		return ASTUtil.collectChildren( this, fromElementPredicate );
 	}
 
 	public FromElement getFromElement() {
 		// TODO: not sure about this one
 //		List fromElements = getFromElements();
 //		if ( fromElements == null || fromElements.isEmpty() ) {
 //			throw new QueryException( "Unable to locate from element" );
 //		}
 		return (FromElement) getFromElements().get(0);
 	}
 
 	/**
 	 * Returns the list of from elements that will be part of the result set.
 	 *
 	 * @return the list of from elements that will be part of the result set.
 	 */
 	public List getProjectionList() {
 		return ASTUtil.collectChildren( this, projectionListPredicate );
 	}
 
 	public List getCollectionFetches() {
 		return ASTUtil.collectChildren( this, collectionFetchPredicate );
 	}
 
 	public boolean hasCollectionFecthes() {
 		return getCollectionFetches().size() > 0;
 	}
 
 	public List getExplicitFromElements() {
 		return ASTUtil.collectChildren( this, explicitFromPredicate );
 	}
 
 	private static ASTUtil.FilterPredicate fromElementPredicate = new ASTUtil.IncludePredicate() {
 		@Override
         public boolean include(AST node) {
 			FromElement fromElement = ( FromElement ) node;
 			return fromElement.isFromOrJoinFragment();
 		}
 	};
 
 	private static ASTUtil.FilterPredicate projectionListPredicate = new ASTUtil.IncludePredicate() {
 		@Override
         public boolean include(AST node) {
 			FromElement fromElement = ( FromElement ) node;
 			return fromElement.inProjectionList();
 		}
 	};
 
 	private static ASTUtil.FilterPredicate collectionFetchPredicate = new ASTUtil.IncludePredicate() {
 		@Override
         public boolean include(AST node) {
 			FromElement fromElement = ( FromElement ) node;
 			return fromElement.isFetch() && fromElement.getQueryableCollection() != null;
 		}
 	};
 
 	private static ASTUtil.FilterPredicate explicitFromPredicate = new ASTUtil.IncludePredicate() {
 		@Override
         public boolean include(AST node) {
 			final FromElement fromElement = ( FromElement ) node;
 			return !fromElement.isImplied();
 		}
 	};
 
 	FromElement findCollectionJoin(String path) {
 		return ( FromElement ) collectionJoinFromElementsByPath.get( path );
 	}
 
 	/**
 	 * Look for an existing implicit or explicit join by the
 	 * given path.
 	 */
 	FromElement findJoinByPath(String path) {
 		FromElement elem = findJoinByPathLocal( path );
 		if ( elem == null && parentFromClause != null ) {
 			elem = parentFromClause.findJoinByPath( path );
 		}
 		return elem;
 	}
 
 	FromElement findJoinByPathLocal(String path) {
 		Map joinsByPath = fromElementsByPath;
 		return ( FromElement ) joinsByPath.get( path );
 	}
 
 	void addJoinByPathMap(String path, FromElement destination) {
         LOG.debugf("addJoinByPathMap() : %s -> %s", path, destination.getDisplayText());
 		fromElementsByPath.put( path, destination );
 	}
 
 	/**
 	 * Returns true if the from node contains the class alias name.
 	 *
 	 * @param alias The HQL class alias name.
 	 * @return true if the from node contains the class alias name.
 	 */
 	public boolean containsClassAlias(String alias) {
 		boolean isAlias = fromElementByClassAlias.containsKey( alias );
 		if ( !isAlias && getSessionFactoryHelper().isStrictJPAQLComplianceEnabled() ) {
 			isAlias = findIntendedAliasedFromElementBasedOnCrazyJPARequirements( alias ) != null;
 		}
 		return isAlias;
 	}
 
 	/**
 	 * Returns true if the from node contains the table alias name.
 	 *
 	 * @param alias The SQL table alias name.
 	 * @return true if the from node contains the table alias name.
 	 */
 	public boolean containsTableAlias(String alias) {
 		return fromElementByTableAlias.keySet().contains( alias );
 	}
 
 	public String getDisplayText() {
 		return "FromClause{" +
 				"level=" + level +
 				", fromElementCounter=" + fromElementCounter +
 				", fromElements=" + fromElements.size() +
 				", fromElementByClassAlias=" + fromElementByClassAlias.keySet() +
 				", fromElementByTableAlias=" + fromElementByTableAlias.keySet() +
 				", fromElementsByPath=" + fromElementsByPath.keySet() +
 				", collectionJoinFromElementsByPath=" + collectionJoinFromElementsByPath.keySet() +
 				", impliedElements=" + impliedElements +
 				"}";
 	}
 
 	public void setParentFromClause(FromClause parentFromClause) {
 		this.parentFromClause = parentFromClause;
 		if ( parentFromClause != null ) {
 			level = parentFromClause.getLevel() + 1;
 			parentFromClause.addChild( this );
 		}
 	}
 
 	private void addChild(FromClause fromClause) {
 		if ( childFromClauses == null ) {
 			childFromClauses = new HashSet();
 		}
 		childFromClauses.add( fromClause );
 	}
 
 	public FromClause locateChildFromClauseWithJoinByPath(String path) {
 		if ( childFromClauses != null && !childFromClauses.isEmpty() ) {
 			Iterator children = childFromClauses.iterator();
 			while ( children.hasNext() ) {
 				FromClause child = ( FromClause ) children.next();
 				if ( child.findJoinByPathLocal( path ) != null ) {
 					return child;
 				}
 			}
 		}
 		return null;
 	}
 
 	public void promoteJoin(FromElement elem) {
         LOG.debugf("Promoting [%s] to [%s]", elem, this);
 		//TODO: implement functionality
 		//  this might be painful to do here, as the "join post processing" for
 		//  the subquery has already been performed (meaning that for
 		//  theta-join dialects, the join conditions have already been moved
 		//  over to the where clause).  A "simple" solution here might to
 		//  doAfterTransactionCompletion "join post processing" once for the entire query (including
 		//  any subqueries) at one fell swoop
 	}
 
 	public boolean isSubQuery() {
 		// TODO : this is broke for subqueries in statements other than selects...
 		return parentFromClause != null;
 	}
 
 	void addCollectionJoinFromElementByPath(String path, FromElement destination) {
         LOG.debugf("addCollectionJoinFromElementByPath() : %s -> %s", path, destination);
 		collectionJoinFromElementsByPath.put( path, destination );	// Add the new node to the map so that we don't create it twice.
 	}
 
 	public FromClause getParentFromClause() {
 		return parentFromClause;
 	}
 
 	public int getLevel() {
 		return level;
 	}
 
 	public int nextFromElementCounter() {
 		return fromElementCounter++;
 	}
 
 	public void resolve() {
 		// Make sure that all from elements registered with this FROM clause are actually in the AST.
 		ASTIterator iter = new ASTIterator( this.getFirstChild() );
 		Set childrenInTree = new HashSet();
 		while ( iter.hasNext() ) {
 			childrenInTree.add( iter.next() );
 		}
 		for ( Iterator iterator = fromElements.iterator(); iterator.hasNext(); ) {
 			FromElement fromElement = ( FromElement ) iterator.next();
 			if ( !childrenInTree.contains( fromElement ) ) {
 				throw new IllegalStateException( "Element not in AST: " + fromElement );
 			}
 		}
 	}
 
 	public void addImpliedFromElement(FromElement element) {
 		impliedElements.add( element );
 	}
 
 	@Override
     public String toString() {
 		return "FromClause{" +
 				"level=" + level +
 				"}";
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromElement.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromElement.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromElement.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromElement.java
index 43e86f7ddd..dd590e7fac 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromElement.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromElement.java
@@ -1,685 +1,685 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
 
 import org.hibernate.engine.internal.JoinSequence;
+import org.hibernate.hql.spi.QueryTranslator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.QueryException;
-import org.hibernate.hql.CollectionProperties;
-import org.hibernate.hql.QueryTranslator;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.TypeDiscriminatorMetadata;
-import org.hibernate.hql.ast.util.ASTUtil;
+import org.hibernate.hql.internal.CollectionProperties;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.TypeDiscriminatorMetadata;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.DiscriminatorMetadata;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.PropertyMapping;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 
 /**
  * Represents a single mapped class mentioned in an HQL FROM clause.  Each
  * class reference will have the following symbols:
  * <ul>
  * <li>A class name - This is the name of the Java class that is mapped by Hibernate.</li>
  * <li>[optional] an HQL alias for the mapped class.</li>
  * <li>A table name - The name of the table that is mapped to the Java class.</li>
  * <li>A table alias - The alias for the table that will be used in the resulting SQL.</li>
  * </ul>
  *
  * @author josh
  */
 public class FromElement extends HqlSqlWalkerNode implements DisplayableNode, ParameterContainer {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, FromElement.class.getName());
 
 	private String className;
 	private String classAlias;
 	private String tableAlias;
 	private String collectionTableAlias;
 	private FromClause fromClause;
 	private boolean includeSubclasses = true;
 	private boolean collectionJoin = false;
 	private FromElement origin;
 	private String[] columns;
 	private String role;
 	private boolean fetch;
 	private boolean isAllPropertyFetch;
 	private boolean filter = false;
 	private int sequence = -1;
 	private boolean useFromFragment = false;
 	private boolean initialized = false;
 	private FromElementType elementType;
 	private boolean useWhereFragment = true;
 	private List destinations = new LinkedList();
 	private boolean manyToMany = false;
 	private String withClauseFragment = null;
 	private String withClauseJoinAlias;
 	private boolean dereferencedBySuperclassProperty;
 	private boolean dereferencedBySubclassProperty;
 
 	public FromElement() {
 	}
 
 	/**
 	 * Constructor form used to initialize {@link ComponentJoin}
 	 *
 	 * @param fromClause The FROM clause to which this element belongs
 	 * @param origin The origin (LHS) of this element
 	 * @param alias The alias applied to this element
 	 */
 	protected FromElement(
 			FromClause fromClause,
 			FromElement origin,
 			String alias) {
 		this.fromClause = fromClause;
 		this.origin = origin;
 		this.classAlias = alias;
 		this.tableAlias = origin.getTableAlias();
 		super.initialize( fromClause.getWalker() );
 	}
 
 	protected void initializeComponentJoin(FromElementType elementType) {
 		this.elementType = elementType;
 		fromClause.registerFromElement( this );
 		initialized = true;
 	}
 
 	public String getCollectionSuffix() {
 		return elementType.getCollectionSuffix();
 	}
 
 	public void setCollectionSuffix(String suffix) {
 		elementType.setCollectionSuffix(suffix);
 	}
 
 	public void initializeCollection(FromClause fromClause, String classAlias, String tableAlias) {
 		doInitialize( fromClause, tableAlias, null, classAlias, null, null );
 		initialized = true;
 	}
 
 	public void initializeEntity(
 	        FromClause fromClause,
 	        String className,
 	        EntityPersister persister,
 	        EntityType type,
 	        String classAlias,
 	        String tableAlias) {
 		doInitialize( fromClause, tableAlias, className, classAlias, persister, type );
 		this.sequence = fromClause.nextFromElementCounter();
 		initialized = true;
 	}
 
 	private void doInitialize(FromClause fromClause, String tableAlias, String className, String classAlias,
 							  EntityPersister persister, EntityType type) {
 		if ( initialized ) {
 			throw new IllegalStateException( "Already initialized!!" );
 		}
 		this.fromClause = fromClause;
 		this.tableAlias = tableAlias;
 		this.className = className;
 		this.classAlias = classAlias;
 		this.elementType = new FromElementType( this, persister, type );
 		// Register the FromElement with the FROM clause, now that we have the names and aliases.
 		fromClause.registerFromElement( this );
         LOG.debugf("%s : %s (%s) -> %s", fromClause, className, classAlias == null ? "<no alias>" : classAlias, tableAlias);
 	}
 
 	public EntityPersister getEntityPersister() {
 		return elementType.getEntityPersister();
 	}
 
 	@Override
     public Type getDataType() {
 		return elementType.getDataType();
 	}
 
 	public Type getSelectType() {
 		return elementType.getSelectType();
 	}
 
 	public Queryable getQueryable() {
 		return elementType.getQueryable();
 	}
 
 	public String getClassName() {
 		return className;
 	}
 
 	public String getClassAlias() {
 		return classAlias;
 		//return classAlias == null ? className : classAlias;
 	}
 
 	private String getTableName() {
 		Queryable queryable = getQueryable();
 		return ( queryable != null ) ? queryable.getTableName() : "{none}";
 	}
 
 	public String getTableAlias() {
 		return tableAlias;
 	}
 
 	/**
 	 * Render the identifier select, but in a 'scalar' context (i.e. generate the column alias).
 	 *
 	 * @param i the sequence of the returned type
 	 * @return the identifier select with the column alias.
 	 */
 	String renderScalarIdentifierSelect(int i) {
 		return elementType.renderScalarIdentifierSelect( i );
 	}
 
 	void checkInitialized() {
 		if ( !initialized ) {
 			throw new IllegalStateException( "FromElement has not been initialized!" );
 		}
 	}
 
 	/**
 	 * Returns the identifier select SQL fragment.
 	 *
 	 * @param size The total number of returned types.
 	 * @param k    The sequence of the current returned type.
 	 * @return the identifier select SQL fragment.
 	 */
 	String renderIdentifierSelect(int size, int k) {
 		return elementType.renderIdentifierSelect( size, k );
 	}
 
 	/**
 	 * Returns the property select SQL fragment.
 	 *
 	 * @param size The total number of returned types.
 	 * @param k    The sequence of the current returned type.
 	 * @return the property select SQL fragment.
 	 */
 	String renderPropertySelect(int size, int k) {
 		return elementType.renderPropertySelect( size, k, isAllPropertyFetch );
 	}
 
 	String renderCollectionSelectFragment(int size, int k) {
 		return elementType.renderCollectionSelectFragment( size, k );
 	}
 
 	String renderValueCollectionSelectFragment(int size, int k) {
 		return elementType.renderValueCollectionSelectFragment( size, k );
 	}
 
 	public FromClause getFromClause() {
 		return fromClause;
 	}
 
 	/**
 	 * Returns true if this FromElement was implied by a path, or false if this FROM element is explicitly declared in
 	 * the FROM clause.
 	 *
 	 * @return true if this FromElement was implied by a path, or false if this FROM element is explicitly declared
 	 */
 	public boolean isImplied() {
 		return false;	// This is an explicit FROM element.
 	}
 
 	/**
 	 * Returns additional display text for the AST node.
 	 *
 	 * @return String - The additional display text.
 	 */
 	public String getDisplayText() {
 		StringBuffer buf = new StringBuffer();
 		buf.append( "FromElement{" );
 		appendDisplayText( buf );
 		buf.append( "}" );
 		return buf.toString();
 	}
 
 	protected void appendDisplayText(StringBuffer buf) {
 		buf.append( isImplied() ? (
 				isImpliedInFromClause() ? "implied in FROM clause" : "implied" )
 				: "explicit" );
 		buf.append( "," ).append( isCollectionJoin() ? "collection join" : "not a collection join" );
 		buf.append( "," ).append( fetch ? "fetch join" : "not a fetch join" );
 		buf.append( "," ).append( isAllPropertyFetch ? "fetch all properties" : "fetch non-lazy properties" );
 		buf.append( ",classAlias=" ).append( getClassAlias() );
 		buf.append( ",role=" ).append( role );
 		buf.append( ",tableName=" ).append( getTableName() );
 		buf.append( ",tableAlias=" ).append( getTableAlias() );
 		FromElement origin = getRealOrigin();
 		buf.append( ",origin=" ).append( origin == null ? "null" : origin.getText() );
 		buf.append( ",columns={" );
 		if ( columns != null ) {
 			for ( int i = 0; i < columns.length; i++ ) {
 				buf.append( columns[i] );
 				if ( i < columns.length ) {
 					buf.append( " " );
 				}
 			}
 		}
 		buf.append( ",className=" ).append( className );
 		buf.append( "}" );
 	}
 
 	@Override
     public int hashCode() {
 		return super.hashCode();
 	}
 
 	@Override
     public boolean equals(Object obj) {
 		return super.equals( obj );
 	}
 
 
 	public void setJoinSequence(JoinSequence joinSequence) {
 		elementType.setJoinSequence( joinSequence );
 	}
 
 	public JoinSequence getJoinSequence() {
 		return elementType.getJoinSequence();
 	}
 
 	public void setIncludeSubclasses(boolean includeSubclasses) {
         if (LOG.isTraceEnabled() && isDereferencedBySuperclassOrSubclassProperty() && !includeSubclasses) LOG.trace("Attempt to disable subclass-inclusions : "
                                                                                                                     + new Exception(
                                                                                                                                     "Stack-trace source"));
 		this.includeSubclasses = includeSubclasses;
 	}
 
 	public boolean isIncludeSubclasses() {
 		return includeSubclasses;
 	}
 
 	public boolean isDereferencedBySuperclassOrSubclassProperty() {
 		return dereferencedBySubclassProperty || dereferencedBySuperclassProperty;
 	}
 
 	public String getIdentityColumn() {
 		checkInitialized();
 		String table = getTableAlias();
 		if ( table == null ) {
 			throw new IllegalStateException( "No table alias for node " + this );
 		}
 		String[] cols;
 		String propertyName;
 		if ( getEntityPersister() != null && getEntityPersister().getEntityMetamodel() != null
 				&& getEntityPersister().getEntityMetamodel().hasNonIdentifierPropertyNamedId() ) {
 			propertyName = getEntityPersister().getIdentifierPropertyName();
 		}
 		else {
 			propertyName = EntityPersister.ENTITY_ID;
 		}
 		if ( getWalker().getStatementType() == HqlSqlTokenTypes.SELECT ) {
 			cols = getPropertyMapping( propertyName ).toColumns( table, propertyName );
 		}
 		else {
 			cols = getPropertyMapping( propertyName ).toColumns( propertyName );
 		}
 		String result = StringHelper.join( ", ", cols );
 		return  cols.length == 1 ? result : "(" + result + ")";
 	}
 
 	public void setCollectionJoin(boolean collectionJoin) {
 		this.collectionJoin = collectionJoin;
 	}
 
 	public boolean isCollectionJoin() {
 		return collectionJoin;
 	}
 
 	public void setRole(String role) {
 		this.role = role;
 	}
 
 	public void setQueryableCollection(QueryableCollection queryableCollection) {
 		elementType.setQueryableCollection( queryableCollection );
 	}
 
 	public QueryableCollection getQueryableCollection() {
 		return elementType.getQueryableCollection();
 	}
 
 	public void setColumns(String[] columns) {
 		this.columns = columns;
 	}
 
 	public void setOrigin(FromElement origin, boolean manyToMany) {
 		this.origin = origin;
 		this.manyToMany = manyToMany;
 		origin.addDestination( this );
 		if ( origin.getFromClause() == this.getFromClause() ) {
 			// TODO: Figure out a better way to get the FROM elements in a proper tree structure.
 			// If this is not the destination of a many-to-many, add it as a child of the origin.
 			if ( manyToMany ) {
 				ASTUtil.appendSibling( origin, this );
 			}
 			else {
 				if ( !getWalker().isInFrom() && !getWalker().isInSelect() ) {
 					getFromClause().addChild( this );
 				}
 				else {
 					origin.addChild( this );
 				}
 			}
 		}
 		else if ( !getWalker().isInFrom() ) {
 			// HHH-276 : implied joins in a subselect where clause - The destination needs to be added
 			// to the destination's from clause.
 			getFromClause().addChild( this );	// Not sure if this is will fix everything, but it works.
 		}
 		else {
 			// Otherwise, the destination node was implied by the FROM clause and the FROM clause processor
 			// will automatically add it in the right place.
 		}
 	}
 
 	public boolean isManyToMany() {
 		return manyToMany;
 	}
 
 	private void addDestination(FromElement fromElement) {
 		destinations.add( fromElement );
 	}
 
 	public List getDestinations() {
 		return destinations;
 	}
 
 	public FromElement getOrigin() {
 		return origin;
 	}
 
 	public FromElement getRealOrigin() {
 		if ( origin == null ) {
 			return null;
 		}
 		if ( origin.getText() == null || "".equals( origin.getText() ) ) {
 			return origin.getRealOrigin();
 		}
 		return origin;
 	}
 
 	public static final String DISCRIMINATOR_PROPERTY_NAME = "class";
 	private TypeDiscriminatorMetadata typeDiscriminatorMetadata;
 
 	private static class TypeDiscriminatorMetadataImpl implements TypeDiscriminatorMetadata {
 		private final DiscriminatorMetadata persisterDiscriminatorMetadata;
 		private final String alias;
 
 		private TypeDiscriminatorMetadataImpl(
 				DiscriminatorMetadata persisterDiscriminatorMetadata,
 				String alias) {
 			this.persisterDiscriminatorMetadata = persisterDiscriminatorMetadata;
 			this.alias = alias;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public String getSqlFragment() {
 			return persisterDiscriminatorMetadata.getSqlFragment( alias );
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Type getResolutionType() {
 			return persisterDiscriminatorMetadata.getResolutionType();
 		}
 	}
 
 	public TypeDiscriminatorMetadata getTypeDiscriminatorMetadata() {
 		if ( typeDiscriminatorMetadata == null ) {
 			typeDiscriminatorMetadata = buildTypeDiscriminatorMetadata();
 		}
 		return typeDiscriminatorMetadata;
 	}
 
 	private TypeDiscriminatorMetadata buildTypeDiscriminatorMetadata() {
 		final String aliasToUse = getTableAlias();
 		Queryable queryable = getQueryable();
 		if ( queryable == null ) {
 			QueryableCollection collection = getQueryableCollection();
 			if ( ! collection.getElementType().isEntityType() ) {
 				throw new QueryException( "type discrimination cannot be applied to value collection [" + collection.getRole() + "]" );
 			}
 			queryable = (Queryable) collection.getElementPersister();
 		}
 
 		handlePropertyBeingDereferenced( getDataType(), DISCRIMINATOR_PROPERTY_NAME );
 
 		return new TypeDiscriminatorMetadataImpl( queryable.getTypeDiscriminatorMetadata(), aliasToUse );
 	}
 
 	public Type getPropertyType(String propertyName, String propertyPath) {
 		return elementType.getPropertyType( propertyName, propertyPath );
 	}
 
 	public String[] toColumns(String tableAlias, String path, boolean inSelect) {
 		return elementType.toColumns( tableAlias, path, inSelect );
 	}
 
 	public String[] toColumns(String tableAlias, String path, boolean inSelect, boolean forceAlias) {
 		return elementType.toColumns( tableAlias, path, inSelect, forceAlias );
 	}
 
 	public PropertyMapping getPropertyMapping(String propertyName) {
 		return elementType.getPropertyMapping( propertyName );
 	}
 
 	public void setFetch(boolean fetch) {
 		this.fetch = fetch;
 		// Fetch can't be used with scroll() or iterate().
 		if ( fetch && getWalker().isShallowQuery() ) {
 			throw new QueryException( QueryTranslator.ERROR_CANNOT_FETCH_WITH_ITERATE );
 		}
 	}
 
 	public boolean isFetch() {
 		return fetch;
 	}
 
 	public int getSequence() {
 		return sequence;
 	}
 
 	public void setFilter(boolean b) {
 		filter = b;
 	}
 
 	public boolean isFilter() {
 		return filter;
 	}
 
 	public boolean useFromFragment() {
 		checkInitialized();
 		// If it's not implied or it is implied and it's a many to many join where the target wasn't found.
 		return !isImplied() || this.useFromFragment;
 	}
 
 	public void setUseFromFragment(boolean useFromFragment) {
 		this.useFromFragment = useFromFragment;
 	}
 
 	public boolean useWhereFragment() {
 		return useWhereFragment;
 	}
 
 	public void setUseWhereFragment(boolean b) {
 		useWhereFragment = b;
 	}
 
 
 	public void setCollectionTableAlias(String collectionTableAlias) {
 		this.collectionTableAlias = collectionTableAlias;
 	}
 
 	public String getCollectionTableAlias() {
 		return collectionTableAlias;
 	}
 
 	public boolean isCollectionOfValuesOrComponents() {
 		return elementType.isCollectionOfValuesOrComponents();
 	}
 
 	public boolean isEntity() {
 		return elementType.isEntity();
 	}
 
 	public void setImpliedInFromClause(boolean flag) {
 		throw new UnsupportedOperationException( "Explicit FROM elements can't be implied in the FROM clause!" );
 	}
 
 	public boolean isImpliedInFromClause() {
 		return false;	// Since this is an explicit FROM element, it can't be implied in the FROM clause.
 	}
 
 	public void setInProjectionList(boolean inProjectionList) {
 		// Do nothing, eplicit from elements are *always* in the projection list.
 	}
 
 	public boolean inProjectionList() {
 		return !isImplied() && isFromOrJoinFragment();
 	}
 
 	public boolean isFromOrJoinFragment() {
 		return getType() == SqlTokenTypes.FROM_FRAGMENT || getType() == SqlTokenTypes.JOIN_FRAGMENT;
 	}
 
 	public boolean isAllPropertyFetch() {
 		return isAllPropertyFetch;
 	}
 
 	public void setAllPropertyFetch(boolean fetch) {
 		isAllPropertyFetch = fetch;
 	}
 
 	public String getWithClauseFragment() {
 		return withClauseFragment;
 	}
 
 	public String getWithClauseJoinAlias() {
 		return withClauseJoinAlias;
 	}
 
 	public void setWithClauseFragment(String withClauseJoinAlias, String withClauseFragment) {
 		this.withClauseJoinAlias = withClauseJoinAlias;
 		this.withClauseFragment = withClauseFragment;
 	}
 
 	public boolean hasCacheablePersister() {
 		if ( getQueryableCollection() != null ) {
 			return getQueryableCollection().hasCache();
 		}
 		else {
 			return getQueryable().hasCache();
 		}
 	}
 
 	public void handlePropertyBeingDereferenced(Type propertySource, String propertyName) {
 		if ( getQueryableCollection() != null && CollectionProperties.isCollectionProperty( propertyName ) ) {
 			// propertyName refers to something like collection.size...
 			return;
 		}
 		if ( propertySource.isComponentType() ) {
 			// property name is a sub-path of a component...
 			return;
 		}
 
 		Queryable persister = getQueryable();
 		if ( persister != null ) {
 			try {
 				Queryable.Declarer propertyDeclarer = persister.getSubclassPropertyDeclarer( propertyName );
                 LOG.trace("Handling property dereference [" + persister.getEntityName() + " (" + getClassAlias() + ") -> "
                           + propertyName + " (" + propertyDeclarer + ")]");
 				if ( propertyDeclarer == Queryable.Declarer.SUBCLASS ) {
 					dereferencedBySubclassProperty = true;
 					includeSubclasses = true;
 				}
 				else if ( propertyDeclarer == Queryable.Declarer.SUPERCLASS ) {
 					dereferencedBySuperclassProperty = true;
 				}
 			}
 			catch( QueryException ignore ) {
 				// ignore it; the incoming property could not be found so we
 				// cannot be sure what to do here.  At the very least, the
 				// safest is to simply not apply any dereference toggling...
 
 			}
 		}
 	}
 
 	public boolean isDereferencedBySuperclassProperty() {
 		return dereferencedBySuperclassProperty;
 	}
 
 	public boolean isDereferencedBySubclassProperty() {
 		return dereferencedBySubclassProperty;
 	}
 
 
 	// ParameterContainer impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	private List embeddedParameters;
 
 	public void addEmbeddedParameter(ParameterSpecification specification) {
 		if ( embeddedParameters == null ) {
 			embeddedParameters = new ArrayList();
 		}
 		embeddedParameters.add( specification );
 	}
 
 	public boolean hasEmbeddedParameters() {
 		return embeddedParameters != null && ! embeddedParameters.isEmpty();
 	}
 
 	public ParameterSpecification[] getEmbeddedParameters() {
 		return ( ParameterSpecification[] ) embeddedParameters.toArray( new ParameterSpecification[ embeddedParameters.size() ] );
 	}
 
 	public ParameterSpecification getIndexCollectionSelectorParamSpec() {
 		return elementType.getIndexCollectionSelectorParamSpec();
 	}
 
 	public void setIndexCollectionSelectorParamSpec(ParameterSpecification indexCollectionSelectorParamSpec) {
 		if ( indexCollectionSelectorParamSpec == null ) {
 			if ( elementType.getIndexCollectionSelectorParamSpec() != null ) {
 				embeddedParameters.remove( elementType.getIndexCollectionSelectorParamSpec() );
 				elementType.setIndexCollectionSelectorParamSpec( null );
 			}
 		}
 		else {
 			elementType.setIndexCollectionSelectorParamSpec( indexCollectionSelectorParamSpec );
 			addEmbeddedParameter( indexCollectionSelectorParamSpec );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromElementFactory.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromElementFactory.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromElementFactory.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromElementFactory.java
index 8b457aec5c..c486a38db8 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromElementFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromElementFactory.java
@@ -1,515 +1,515 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import org.hibernate.engine.internal.JoinSequence;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.util.ASTUtil;
-import org.hibernate.hql.ast.util.AliasGenerator;
-import org.hibernate.hql.ast.util.PathHelper;
-import org.hibernate.hql.ast.util.SessionFactoryHelper;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
+import org.hibernate.hql.internal.ast.util.AliasGenerator;
+import org.hibernate.hql.internal.ast.util.PathHelper;
+import org.hibernate.hql.internal.ast.util.SessionFactoryHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.Joinable;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.ComponentType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 import antlr.ASTFactory;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * Encapsulates the creation of FromElements and JoinSequences.
  *
  * @author josh
  */
 public class FromElementFactory implements SqlTokenTypes {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, FromElementFactory.class.getName());
 
 	private FromClause fromClause;
 	private FromElement origin;
 	private String path;
 
 	private String classAlias;
 	private String[] columns;
 	private boolean implied;
 	private boolean inElementsFunction;
 	private boolean collection;
 	private QueryableCollection queryableCollection;
 	private CollectionType collectionType;
 
 	/**
 	 * Creates entity from elements.
 	 */
 	public FromElementFactory(FromClause fromClause, FromElement origin, String path) {
 		this.fromClause = fromClause;
 		this.origin = origin;
 		this.path = path;
 		collection = false;
 	}
 
 	/**
 	 * Creates collection from elements.
 	 */
 	public FromElementFactory(
 	        FromClause fromClause,
 	        FromElement origin,
 	        String path,
 	        String classAlias,
 	        String[] columns,
 	        boolean implied) {
 		this( fromClause, origin, path );
 		this.classAlias = classAlias;
 		this.columns = columns;
 		this.implied = implied;
 		collection = true;
 	}
 
 	FromElement addFromElement() throws SemanticException {
 		FromClause parentFromClause = fromClause.getParentFromClause();
 		if ( parentFromClause != null ) {
 			// Look up class name using the first identifier in the path.
 			String pathAlias = PathHelper.getAlias( path );
 			FromElement parentFromElement = parentFromClause.getFromElement( pathAlias );
 			if ( parentFromElement != null ) {
 				return createFromElementInSubselect( path, pathAlias, parentFromElement, classAlias );
 			}
 		}
 
 		EntityPersister entityPersister = fromClause.getSessionFactoryHelper().requireClassPersister( path );
 
 		FromElement elem = createAndAddFromElement( path,
 				classAlias,
 				entityPersister,
 				( EntityType ) ( ( Queryable ) entityPersister ).getType(),
 				null );
 
 		// Add to the query spaces.
 		fromClause.getWalker().addQuerySpaces( entityPersister.getQuerySpaces() );
 
 		return elem;
 	}
 
 	private FromElement createFromElementInSubselect(
 	        String path,
 	        String pathAlias,
 	        FromElement parentFromElement,
 	        String classAlias) throws SemanticException {
         LOG.debugf("createFromElementInSubselect() : path = %s", path);
 		// Create an DotNode AST for the path and resolve it.
 		FromElement fromElement = evaluateFromElementPath( path, classAlias );
 		EntityPersister entityPersister = fromElement.getEntityPersister();
 
         // If the first identifier in the path refers to the class alias (not the class name), then this
 		// is a correlated subselect.  If it's a correlated sub-select, use the existing table alias.  Otherwise
 		// generate a new one.
 		String tableAlias = null;
 		boolean correlatedSubselect = pathAlias.equals( parentFromElement.getClassAlias() );
 		if ( correlatedSubselect ) {
 			tableAlias = fromElement.getTableAlias();
 		}
 		else {
 			tableAlias = null;
 		}
 
 		// If the from element isn't in the same clause, create a new from element.
 		if ( fromElement.getFromClause() != fromClause ) {
             LOG.debugf("createFromElementInSubselect() : creating a new FROM element...");
 			fromElement = createFromElement( entityPersister );
 			initializeAndAddFromElement( fromElement,
 					path,
 					classAlias,
 					entityPersister,
 					( EntityType ) ( ( Queryable ) entityPersister ).getType(),
 					tableAlias
 			);
 		}
         LOG.debugf("createFromElementInSubselect() : %s -> %s", path, fromElement);
 		return fromElement;
 	}
 
 	private FromElement evaluateFromElementPath(String path, String classAlias) throws SemanticException {
 		ASTFactory factory = fromClause.getASTFactory();
 		FromReferenceNode pathNode = ( FromReferenceNode ) PathHelper.parsePath( path, factory );
 		pathNode.recursiveResolve( FromReferenceNode.ROOT_LEVEL, // This is the root level node.
 				false, // Generate an explicit from clause at the root.
 				classAlias,
 		        null
 		);
         if (pathNode.getImpliedJoin() != null) return pathNode.getImpliedJoin();
         return pathNode.getFromElement();
 	}
 
 	FromElement createCollectionElementsJoin(
 	        QueryableCollection queryableCollection,
 	        String collectionName) throws SemanticException {
 		JoinSequence collectionJoinSequence = fromClause.getSessionFactoryHelper()
 		        .createCollectionJoinSequence( queryableCollection, collectionName );
 		this.queryableCollection = queryableCollection;
 		return createCollectionJoin( collectionJoinSequence, null );
 	}
 
 	FromElement createCollection(
 	        QueryableCollection queryableCollection,
 	        String role,
 	        int joinType,
 	        boolean fetchFlag,
 	        boolean indexed)
 			throws SemanticException {
 		if ( !collection ) {
 			throw new IllegalStateException( "FromElementFactory not initialized for collections!" );
 		}
 		this.inElementsFunction = indexed;
 		FromElement elem;
 		this.queryableCollection = queryableCollection;
 		collectionType = queryableCollection.getCollectionType();
 		String roleAlias = fromClause.getAliasGenerator().createName( role );
 
 		// Correlated subqueries create 'special' implied from nodes
 		// because correlated subselects can't use an ANSI-style join
 		boolean explicitSubqueryFromElement = fromClause.isSubQuery() && !implied;
 		if ( explicitSubqueryFromElement ) {
 			String pathRoot = StringHelper.root( path );
 			FromElement origin = fromClause.getFromElement( pathRoot );
 			if ( origin == null || origin.getFromClause() != fromClause ) {
 				implied = true;
 			}
 		}
 
 		// super-duper-classic-parser-regression-testing-mojo-magic...
 		if ( explicitSubqueryFromElement && DotNode.useThetaStyleImplicitJoins ) {
 			implied = true;
 		}
 
 		Type elementType = queryableCollection.getElementType();
 		if ( elementType.isEntityType() ) { 			// A collection of entities...
 			elem = createEntityAssociation( role, roleAlias, joinType );
 		}
 		else if ( elementType.isComponentType() ) {		// A collection of components...
 			JoinSequence joinSequence = createJoinSequence( roleAlias, joinType );
 			elem = createCollectionJoin( joinSequence, roleAlias );
 		}
 		else {											// A collection of scalar elements...
 			JoinSequence joinSequence = createJoinSequence( roleAlias, joinType );
 			elem = createCollectionJoin( joinSequence, roleAlias );
 		}
 
 		elem.setRole( role );
 		elem.setQueryableCollection( queryableCollection );
 		// Don't include sub-classes for implied collection joins or subquery joins.
 		if ( implied ) {
 			elem.setIncludeSubclasses( false );
 		}
 
 		if ( explicitSubqueryFromElement ) {
 			elem.setInProjectionList( true );	// Treat explict from elements in sub-queries properly.
 		}
 
 		if ( fetchFlag ) {
 			elem.setFetch( true );
 		}
 		return elem;
 	}
 
 	FromElement createEntityJoin(
 	        String entityClass,
 	        String tableAlias,
 	        JoinSequence joinSequence,
 	        boolean fetchFlag,
 	        boolean inFrom,
 	        EntityType type) throws SemanticException {
 		FromElement elem = createJoin( entityClass, tableAlias, joinSequence, type, false );
 		elem.setFetch( fetchFlag );
 		EntityPersister entityPersister = elem.getEntityPersister();
 		int numberOfTables = entityPersister.getQuerySpaces().length;
 		if ( numberOfTables > 1 && implied && !elem.useFromFragment() ) {
             LOG.debugf("createEntityJoin() : Implied multi-table entity join");
 			elem.setUseFromFragment( true );
 		}
 
 		// If this is an implied join in a FROM clause, then use ANSI-style joining, and set the
 		// flag on the FromElement that indicates that it was implied in the FROM clause itself.
 		if ( implied && inFrom ) {
 			joinSequence.setUseThetaStyle( false );
 			elem.setUseFromFragment( true );
 			elem.setImpliedInFromClause( true );
 		}
 		if ( elem.getWalker().isSubQuery() ) {
 			// two conditions where we need to transform this to a theta-join syntax:
 			//      1) 'elem' is the "root from-element" in correlated subqueries
 			//      2) The DotNode.useThetaStyleImplicitJoins has been set to true
 			//          and 'elem' represents an implicit join
 			if ( elem.getFromClause() != elem.getOrigin().getFromClause() ||
 //			        ( implied && DotNode.useThetaStyleImplicitJoins ) ) {
 			        DotNode.useThetaStyleImplicitJoins ) {
 				// the "root from-element" in correlated subqueries do need this piece
 				elem.setType( FROM_FRAGMENT );
 				joinSequence.setUseThetaStyle( true );
 				elem.setUseFromFragment( false );
 			}
 		}
 
 		return elem;
 	}
 
 	public FromElement createComponentJoin(ComponentType type) {
 		// need to create a "place holder" from-element that can store the component/alias for this
 		// 		component join
 		return new ComponentJoin( fromClause, origin, classAlias, path, type );
 	}
 
 	FromElement createElementJoin(QueryableCollection queryableCollection) throws SemanticException {
 		FromElement elem;
 
 		implied = true; //TODO: always true for now, but not if we later decide to support elements() in the from clause
 		inElementsFunction = true;
 		Type elementType = queryableCollection.getElementType();
 		if ( !elementType.isEntityType() ) {
 			throw new IllegalArgumentException( "Cannot create element join for a collection of non-entities!" );
 		}
 		this.queryableCollection = queryableCollection;
 		SessionFactoryHelper sfh = fromClause.getSessionFactoryHelper();
 		FromElement destination = null;
 		String tableAlias = null;
 		EntityPersister entityPersister = queryableCollection.getElementPersister();
 		tableAlias = fromClause.getAliasGenerator().createName( entityPersister.getEntityName() );
 		String associatedEntityName = entityPersister.getEntityName();
 		EntityPersister targetEntityPersister = sfh.requireClassPersister( associatedEntityName );
 		// Create the FROM element for the target (the elements of the collection).
 		destination = createAndAddFromElement(
 				associatedEntityName,
 				classAlias,
 				targetEntityPersister,
 				( EntityType ) queryableCollection.getElementType(),
 				tableAlias
 			);
 		// If the join is implied, then don't include sub-classes on the element.
 		if ( implied ) {
 			destination.setIncludeSubclasses( false );
 		}
 		fromClause.addCollectionJoinFromElementByPath( path, destination );
 //		origin.addDestination(destination);
 		// Add the query spaces.
 		fromClause.getWalker().addQuerySpaces( entityPersister.getQuerySpaces() );
 
 		CollectionType type = queryableCollection.getCollectionType();
 		String role = type.getRole();
 		String roleAlias = origin.getTableAlias();
 
 		String[] targetColumns = sfh.getCollectionElementColumns( role, roleAlias );
 		AssociationType elementAssociationType = sfh.getElementAssociationType( type );
 
 		// Create the join element under the from element.
 		int joinType = JoinFragment.INNER_JOIN;
 		JoinSequence joinSequence = sfh.createJoinSequence( implied, elementAssociationType, tableAlias, joinType, targetColumns );
 		elem = initializeJoin( path, destination, joinSequence, targetColumns, origin, false );
 		elem.setUseFromFragment( true );	// The associated entity is implied, but it must be included in the FROM.
 		elem.setCollectionTableAlias( roleAlias );	// The collection alias is the role.
 		return elem;
 	}
 
 	private FromElement createCollectionJoin(JoinSequence collectionJoinSequence, String tableAlias) throws SemanticException {
 		String text = queryableCollection.getTableName();
 		AST ast = createFromElement( text );
 		FromElement destination = ( FromElement ) ast;
 		Type elementType = queryableCollection.getElementType();
 		if ( elementType.isCollectionType() ) {
 			throw new SemanticException( "Collections of collections are not supported!" );
 		}
 		destination.initializeCollection( fromClause, classAlias, tableAlias );
 		destination.setType( JOIN_FRAGMENT );		// Tag this node as a JOIN.
 		destination.setIncludeSubclasses( false );	// Don't include subclasses in the join.
 		destination.setCollectionJoin( true );		// This is a clollection join.
 		destination.setJoinSequence( collectionJoinSequence );
 		destination.setOrigin( origin, false );
 		destination.setCollectionTableAlias(tableAlias);
 //		origin.addDestination( destination );
 // This was the cause of HHH-242
 //		origin.setType( FROM_FRAGMENT );			// Set the parent node type so that the AST is properly formed.
 		origin.setText( "" );						// The destination node will have all the FROM text.
 		origin.setCollectionJoin( true );			// The parent node is a collection join too (voodoo - see JoinProcessor)
 		fromClause.addCollectionJoinFromElementByPath( path, destination );
 		fromClause.getWalker().addQuerySpaces( queryableCollection.getCollectionSpaces() );
 		return destination;
 	}
 
 	private FromElement createEntityAssociation(
 	        String role,
 	        String roleAlias,
 	        int joinType) throws SemanticException {
 		FromElement elem;
 		Queryable entityPersister = ( Queryable ) queryableCollection.getElementPersister();
 		String associatedEntityName = entityPersister.getEntityName();
 		// Get the class name of the associated entity.
 		if ( queryableCollection.isOneToMany() ) {
             LOG.debugf("createEntityAssociation() : One to many - path = %s role = %s associatedEntityName = %s",
                        path,
                        role,
                        associatedEntityName);
 			JoinSequence joinSequence = createJoinSequence( roleAlias, joinType );
 
 			elem = createJoin( associatedEntityName, roleAlias, joinSequence, ( EntityType ) queryableCollection.getElementType(), false );
 		}
 		else {
             LOG.debugf("createManyToMany() : path = %s role = %s associatedEntityName = %s", path, role, associatedEntityName);
 			elem = createManyToMany( role, associatedEntityName,
 					roleAlias, entityPersister, ( EntityType ) queryableCollection.getElementType(), joinType );
 			fromClause.getWalker().addQuerySpaces( queryableCollection.getCollectionSpaces() );
 		}
 		elem.setCollectionTableAlias( roleAlias );
 		return elem;
 	}
 
 	private FromElement createJoin(
 	        String entityClass,
 	        String tableAlias,
 	        JoinSequence joinSequence,
 	        EntityType type,
 	        boolean manyToMany) throws SemanticException {
 		//  origin, path, implied, columns, classAlias,
 		EntityPersister entityPersister = fromClause.getSessionFactoryHelper().requireClassPersister( entityClass );
 		FromElement destination = createAndAddFromElement( entityClass,
 				classAlias,
 				entityPersister,
 				type,
 				tableAlias );
 		return initializeJoin( path, destination, joinSequence, getColumns(), origin, manyToMany );
 	}
 
 	private FromElement createManyToMany(
 	        String role,
 	        String associatedEntityName,
 	        String roleAlias,
 	        Queryable entityPersister,
 	        EntityType type,
 	        int joinType) throws SemanticException {
 		FromElement elem;
 		SessionFactoryHelper sfh = fromClause.getSessionFactoryHelper();
 		if ( inElementsFunction /*implied*/ ) {
 			// For implied many-to-many, just add the end join.
 			JoinSequence joinSequence = createJoinSequence( roleAlias, joinType );
 			elem = createJoin( associatedEntityName, roleAlias, joinSequence, type, true );
 		}
 		else {
 			// For an explicit many-to-many relationship, add a second join from the intermediate
 			// (many-to-many) table to the destination table.  Also, make sure that the from element's
 			// idea of the destination is the destination table.
 			String tableAlias = fromClause.getAliasGenerator().createName( entityPersister.getEntityName() );
 			String[] secondJoinColumns = sfh.getCollectionElementColumns( role, roleAlias );
 			// Add the second join, the one that ends in the destination table.
 			JoinSequence joinSequence = createJoinSequence( roleAlias, joinType );
 			joinSequence.addJoin( sfh.getElementAssociationType( collectionType ), tableAlias, joinType, secondJoinColumns );
 			elem = createJoin( associatedEntityName, tableAlias, joinSequence, type, false );
 			elem.setUseFromFragment( true );
 		}
 		return elem;
 	}
 
 	private JoinSequence createJoinSequence(String roleAlias, int joinType) {
 		SessionFactoryHelper sessionFactoryHelper = fromClause.getSessionFactoryHelper();
 		String[] joinColumns = getColumns();
 		if ( collectionType == null ) {
 			throw new IllegalStateException( "collectionType is null!" );
 		}
 		return sessionFactoryHelper.createJoinSequence( implied, collectionType, roleAlias, joinType, joinColumns );
 	}
 
 	private FromElement createAndAddFromElement(
 	        String className,
 	        String classAlias,
 	        EntityPersister entityPersister,
 	        EntityType type,
 	        String tableAlias) {
 		if ( !( entityPersister instanceof Joinable ) ) {
 			throw new IllegalArgumentException( "EntityPersister " + entityPersister + " does not implement Joinable!" );
 		}
 		FromElement element = createFromElement( entityPersister );
 		initializeAndAddFromElement( element, className, classAlias, entityPersister, type, tableAlias );
 		return element;
 	}
 
 	private void initializeAndAddFromElement(
 	        FromElement element,
 	        String className,
 	        String classAlias,
 	        EntityPersister entityPersister,
 	        EntityType type,
 	        String tableAlias) {
 		if ( tableAlias == null ) {
 			AliasGenerator aliasGenerator = fromClause.getAliasGenerator();
 			tableAlias = aliasGenerator.createName( entityPersister.getEntityName() );
 		}
 		element.initializeEntity( fromClause, className, entityPersister, type, classAlias, tableAlias );
 	}
 
 	private FromElement createFromElement(EntityPersister entityPersister) {
 		Joinable joinable = ( Joinable ) entityPersister;
 		String text = joinable.getTableName();
 		AST ast = createFromElement( text );
 		FromElement element = ( FromElement ) ast;
 		return element;
 	}
 
 	private AST createFromElement(String text) {
 		AST ast = ASTUtil.create( fromClause.getASTFactory(),
 				implied ? IMPLIED_FROM : FROM_FRAGMENT, // This causes the factory to instantiate the desired class.
 				text );
 		// Reset the node type, because the rest of the system is expecting FROM_FRAGMENT, all we wanted was
 		// for the factory to create the right sub-class.  This might get reset again later on anyway to make the
 		// SQL generation simpler.
 		ast.setType( FROM_FRAGMENT );
 		return ast;
 	}
 
 	private FromElement initializeJoin(
 	        String path,
 	        FromElement destination,
 	        JoinSequence joinSequence,
 	        String[] columns,
 	        FromElement origin,
 	        boolean manyToMany) {
 		destination.setType( JOIN_FRAGMENT );
 		destination.setJoinSequence( joinSequence );
 		destination.setColumns( columns );
 		destination.setOrigin( origin, manyToMany );
 		fromClause.addJoinByPathMap( path, destination );
 		return destination;
 	}
 
 	private String[] getColumns() {
 		if ( columns == null ) {
 			throw new IllegalStateException( "No foriegn key columns were supplied!" );
 		}
 		return columns;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromElementType.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromElementType.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromElementType.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromElementType.java
index 33ccff60e7..e2f1d6989a 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromElementType.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromElementType.java
@@ -1,518 +1,518 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.engine.internal.JoinSequence;
+import org.hibernate.hql.internal.CollectionProperties;
+import org.hibernate.hql.internal.CollectionSubqueryFactory;
+import org.hibernate.hql.internal.NameGenerator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
-import org.hibernate.hql.CollectionProperties;
-import org.hibernate.hql.CollectionSubqueryFactory;
-import org.hibernate.hql.NameGenerator;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.persister.collection.CollectionPropertyMapping;
 import org.hibernate.persister.collection.CollectionPropertyNames;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.Joinable;
 import org.hibernate.persister.entity.PropertyMapping;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 
 /**
  * Delegate that handles the type and join sequence information for a FromElement.
  *
  * @author josh
  */
 class FromElementType {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, FromElementType.class.getName());
 
 	private FromElement fromElement;
 	private EntityType entityType;
 	private EntityPersister persister;
 	private QueryableCollection queryableCollection;
 	private CollectionPropertyMapping collectionPropertyMapping;
 	private JoinSequence joinSequence;
 	private String collectionSuffix;
 	private ParameterSpecification indexCollectionSelectorParamSpec;
 
 	public FromElementType(FromElement fromElement, EntityPersister persister, EntityType entityType) {
 		this.fromElement = fromElement;
 		this.persister = persister;
 		this.entityType = entityType;
 		if ( persister != null ) {
 			fromElement.setText( ( ( Queryable ) persister ).getTableName() + " " + getTableAlias() );
 		}
 	}
 
 	protected FromElementType(FromElement fromElement) {
 		this.fromElement = fromElement;
 	}
 
 	private String getTableAlias() {
 		return fromElement.getTableAlias();
 	}
 
 	private String getCollectionTableAlias() {
 		return fromElement.getCollectionTableAlias();
 	}
 
 	public String getCollectionSuffix() {
 		return collectionSuffix;
 	}
 
 	public void setCollectionSuffix(String suffix) {
 		collectionSuffix = suffix;
 	}
 
 	public EntityPersister getEntityPersister() {
 		return persister;
 	}
 
 	public Type getDataType() {
 		if ( persister == null ) {
 			if ( queryableCollection == null ) {
 				return null;
 			}
 			return queryableCollection.getType();
 		}
 		else {
 			return entityType;
 		}
 	}
 
 	public Type getSelectType() {
 		if (entityType==null) return null;
 		boolean shallow = fromElement.getFromClause().getWalker().isShallowQuery();
 		return fromElement.getSessionFactoryHelper()
 				.getFactory()
 				.getTypeResolver()
 				.getTypeFactory().manyToOne( entityType.getAssociatedEntityName(), shallow );
 	}
 
 	/**
 	 * Returns the Hibernate queryable implementation for the HQL class.
 	 *
 	 * @return the Hibernate queryable implementation for the HQL class.
 	 */
 	public Queryable getQueryable() {
 		return ( persister instanceof Queryable ) ? ( Queryable ) persister : null;
 	}
 
 	/**
 	 * Render the identifier select, but in a 'scalar' context (i.e. generate the column alias).
 	 *
 	 * @param i the sequence of the returned type
 	 * @return the identifier select with the column alias.
 	 */
 	String renderScalarIdentifierSelect(int i) {
 		checkInitialized();
 		String[] cols = getPropertyMapping( EntityPersister.ENTITY_ID ).toColumns( getTableAlias(), EntityPersister.ENTITY_ID );
 		StringBuffer buf = new StringBuffer();
 		// For property references generate <tablealias>.<columnname> as <projectionalias>
 		for ( int j = 0; j < cols.length; j++ ) {
 			String column = cols[j];
 			if ( j > 0 ) {
 				buf.append( ", " );
 			}
 			buf.append( column ).append( " as " ).append( NameGenerator.scalarName( i, j ) );
 		}
 		return buf.toString();
 	}
 
 	/**
 	 * Returns the identifier select SQL fragment.
 	 *
 	 * @param size The total number of returned types.
 	 * @param k    The sequence of the current returned type.
 	 * @return the identifier select SQL fragment.
 	 */
 	String renderIdentifierSelect(int size, int k) {
 		checkInitialized();
 		// Render the identifier select fragment using the table alias.
 		if ( fromElement.getFromClause().isSubQuery() ) {
 			// TODO: Replace this with a more elegant solution.
 			String[] idColumnNames = ( persister != null ) ?
 					( ( Queryable ) persister ).getIdentifierColumnNames() : new String[0];
 			StringBuffer buf = new StringBuffer();
 			for ( int i = 0; i < idColumnNames.length; i++ ) {
 				buf.append( fromElement.getTableAlias() ).append( '.' ).append( idColumnNames[i] );
 				if ( i != idColumnNames.length - 1 ) buf.append( ", " );
 			}
 			return buf.toString();
 		}
 		else {
 			if (persister==null) {
 				throw new QueryException( "not an entity" );
 			}
 			String fragment = ( ( Queryable ) persister ).identifierSelectFragment( getTableAlias(), getSuffix( size, k ) );
 			return trimLeadingCommaAndSpaces( fragment );
 		}
 	}
 
 	private String getSuffix(int size, int sequence) {
 		return generateSuffix( size, sequence );
 	}
 
 	private static String generateSuffix(int size, int k) {
 		String suffix = size == 1 ? "" : Integer.toString( k ) + '_';
 		return suffix;
 	}
 
 	private void checkInitialized() {
 		fromElement.checkInitialized();
 	}
 
 	/**
 	 * Returns the property select SQL fragment.
 	 * @param size The total number of returned types.
 	 * @param k    The sequence of the current returned type.
 	 * @return the property select SQL fragment.
 	 */
 	String renderPropertySelect(int size, int k, boolean allProperties) {
 		checkInitialized();
 		if ( persister == null ) {
 			return "";
 		}
 		else {
 			String fragment =  ( ( Queryable ) persister ).propertySelectFragment(
 					getTableAlias(),
 					getSuffix( size, k ),
 					allProperties
 				);
 			return trimLeadingCommaAndSpaces( fragment );
 		}
 	}
 
 	String renderCollectionSelectFragment(int size, int k) {
 		if ( queryableCollection == null ) {
 			return "";
 		}
 		else {
 			if ( collectionSuffix == null ) {
 				collectionSuffix = generateSuffix( size, k );
 			}
 			String fragment = queryableCollection.selectFragment( getCollectionTableAlias(), collectionSuffix );
 			return trimLeadingCommaAndSpaces( fragment );
 		}
 	}
 
 	public String renderValueCollectionSelectFragment(int size, int k) {
 		if ( queryableCollection == null ) {
 			return "";
 		}
 		else {
 			if ( collectionSuffix == null ) {
 				collectionSuffix = generateSuffix( size, k );
 			}
 			String fragment =  queryableCollection.selectFragment( getTableAlias(), collectionSuffix );
 			return trimLeadingCommaAndSpaces( fragment );
 		}
 	}
 
 	/**
 	 * This accounts for a quirk in Queryable, where it sometimes generates ',  ' in front of the
 	 * SQL fragment.  :-P
 	 *
 	 * @param fragment An SQL fragment.
 	 * @return The fragment, without the leading comma and spaces.
 	 */
 	private static String trimLeadingCommaAndSpaces(String fragment) {
 		if ( fragment.length() > 0 && fragment.charAt( 0 ) == ',' ) {
 			fragment = fragment.substring( 1 );
 		}
 		fragment = fragment.trim();
 		return fragment.trim();
 	}
 
 	public void setJoinSequence(JoinSequence joinSequence) {
 		this.joinSequence = joinSequence;
 	}
 
 	public JoinSequence getJoinSequence() {
 		if ( joinSequence != null ) {
 			return joinSequence;
 		}
 
 		// Class names in the FROM clause result in a JoinSequence (the old FromParser does this).
 		if ( persister instanceof Joinable ) {
 			Joinable joinable = ( Joinable ) persister;
 			return fromElement.getSessionFactoryHelper().createJoinSequence().setRoot( joinable, getTableAlias() );
 		}
 		else {
 			return null;	// TODO: Should this really return null?  If not, figure out something better to do here.
 		}
 	}
 
 	public void setQueryableCollection(QueryableCollection queryableCollection) {
 		if ( this.queryableCollection != null ) {
 			throw new IllegalStateException( "QueryableCollection is already defined for " + this + "!" );
 		}
 		this.queryableCollection = queryableCollection;
 		if ( !queryableCollection.isOneToMany() ) {
 			// For many-to-many joins, use the tablename from the queryable collection for the default text.
 			fromElement.setText( queryableCollection.getTableName() + " " + getTableAlias() );
 		}
 	}
 
 	public QueryableCollection getQueryableCollection() {
 		return queryableCollection;
 	}
 
 	/**
 	 * Returns the type of a property, given it's name (the last part) and the full path.
 	 *
 	 * @param propertyName The last part of the full path to the property.
 	 * @return The type.
 	 * @0param propertyPath The full property path.
 	 */
 	public Type getPropertyType(String propertyName, String propertyPath) {
 		checkInitialized();
 		Type type = null;
 		// If this is an entity and the property is the identifier property, then use getIdentifierType().
 		//      Note that the propertyName.equals( propertyPath ) checks whether we have a component
 		//      key reference, where the component class property name is the same as the
 		//      entity id property name; if the two are not equal, this is the case and
 		//      we'd need to "fall through" to using the property mapping.
 		if ( persister != null && propertyName.equals( propertyPath ) && propertyName.equals( persister.getIdentifierPropertyName() ) ) {
 			type = persister.getIdentifierType();
 		}
 		else {	// Otherwise, use the property mapping.
 			PropertyMapping mapping = getPropertyMapping( propertyName );
 			type = mapping.toType( propertyPath );
 		}
 		if ( type == null ) {
 			throw new MappingException( "Property " + propertyName + " does not exist in " +
 					( ( queryableCollection == null ) ? "class" : "collection" ) + " "
 					+ ( ( queryableCollection == null ) ? fromElement.getClassName() : queryableCollection.getRole() ) );
 		}
 		return type;
 	}
 
 	String[] toColumns(String tableAlias, String path, boolean inSelect) {
 		return toColumns( tableAlias, path, inSelect, false );
 	}
 
 	String[] toColumns(String tableAlias, String path, boolean inSelect, boolean forceAlias) {
 		checkInitialized();
 		PropertyMapping propertyMapping = getPropertyMapping( path );
 		// If this from element is a collection and the path is a collection property (maxIndex, etc.) then
 		// generate a sub-query.
 		//
 		// NOTE : in the case of this being a collection property in the select, not generating the subquery
 		// will not generally work.  The specific cases I am thinking about are the minIndex, maxIndex
 		// (most likely minElement, maxElement as well) cases.
 		//	todo : if ^^ is the case we should thrown an exception here rather than waiting for the sql error
 		//		if the dialect supports select-clause subqueries we could go ahead and generate the subquery also
 		if ( !inSelect && queryableCollection != null && CollectionProperties.isCollectionProperty( path ) ) {
 			Map enabledFilters = fromElement.getWalker().getEnabledFilters();
 			String subquery = CollectionSubqueryFactory.createCollectionSubquery(
 					joinSequence.copy().setUseThetaStyle( true ),
-			        enabledFilters,
+					enabledFilters,
 					propertyMapping.toColumns( tableAlias, path )
 			);
             LOG.debugf("toColumns(%s,%s) : subquery = %s", tableAlias, path, subquery);
 			return new String[]{"(" + subquery + ")"};
 		}
         if (forceAlias) {
             return propertyMapping.toColumns(tableAlias, path);
         } else if (fromElement.getWalker().getStatementType() == HqlSqlTokenTypes.SELECT) {
             return propertyMapping.toColumns(tableAlias, path);
         } else if (fromElement.getWalker().getCurrentClauseType() == HqlSqlTokenTypes.SELECT) {
             return propertyMapping.toColumns(tableAlias, path);
         } else if (fromElement.getWalker().isSubQuery()) {
             // for a subquery, the alias to use depends on a few things (we
             // already know this is not an overall SELECT):
             // 1) if this FROM_ELEMENT represents a correlation to the
             // outer-most query
             // A) if the outer query represents a multi-table
             // persister, we need to use the given alias
             // in anticipation of one of the multi-table
             // executors being used (as this subquery will
             // actually be used in the "id select" phase
             // of that multi-table executor)
             // B) otherwise, we need to use the persister's
             // table name as the column qualification
             // 2) otherwise (not correlated), use the given alias
             if (isCorrelation()) {
                 if (isMultiTable()) return propertyMapping.toColumns(tableAlias, path);
                 return propertyMapping.toColumns(extractTableName(), path);
 			}
             return propertyMapping.toColumns(tableAlias, path);
         } else {
             String[] columns = propertyMapping.toColumns(path);
             LOG.trace("Using non-qualified column reference [" + path + " -> (" + ArrayHelper.toString(columns) + ")]");
             return columns;
         }
 	}
 
 	private boolean isCorrelation() {
 		FromClause top = fromElement.getWalker().getFinalFromClause();
 		return fromElement.getFromClause() != fromElement.getWalker().getCurrentFromClause() &&
 	           fromElement.getFromClause() == top;
 	}
 
 	private boolean isMultiTable() {
 		// should be safe to only ever expect EntityPersister references here
 		return fromElement.getQueryable() != null &&
 	           fromElement.getQueryable().isMultiTable();
 	}
 
 	private String extractTableName() {
 		// should be safe to only ever expect EntityPersister references here
 		return fromElement.getQueryable().getTableName();
 	}
 
 	private static final List SPECIAL_MANY2MANY_TREATMENT_FUNCTION_NAMES = java.util.Arrays.asList(
 			new String[] {
 					CollectionPropertyNames.COLLECTION_INDEX,
 					CollectionPropertyNames.COLLECTION_MIN_INDEX,
 					CollectionPropertyNames.COLLECTION_MAX_INDEX
 			}
 	);
 
 	PropertyMapping getPropertyMapping(String propertyName) {
 		checkInitialized();
 		if ( queryableCollection == null ) {		// Not a collection?
 			return ( PropertyMapping ) persister;	// Return the entity property mapping.
 		}
 
 		// indexed, many-to-many collections must be treated specially here if the property to
 		// be mapped touches on the index as we must adjust the alias to use the alias from
 		// the association table (which i different than the one passed in
 		if ( queryableCollection.isManyToMany()
 				&& queryableCollection.hasIndex()
 				&& SPECIAL_MANY2MANY_TREATMENT_FUNCTION_NAMES.contains( propertyName ) ) {
 			return new SpecialManyToManyCollectionPropertyMapping();
 		}
 
 		// If the property is a special collection property name, return a CollectionPropertyMapping.
 		if ( CollectionProperties.isCollectionProperty( propertyName ) ) {
 			if ( collectionPropertyMapping == null ) {
 				collectionPropertyMapping = new CollectionPropertyMapping( queryableCollection );
 			}
 			return collectionPropertyMapping;
 		}
 
 		if ( queryableCollection.getElementType().isAnyType() ) {
 			// collection of <many-to-any/> mappings...
 			// used to circumvent the component-collection check below...
 			return queryableCollection;
 
 		}
 
 		if ( queryableCollection.getElementType().isComponentType() ) {
 			// Collection of components.
 			if ( propertyName.equals( EntityPersister.ENTITY_ID ) ) {
 				return ( PropertyMapping ) queryableCollection.getOwnerEntityPersister();
 			}
 		}
 		return queryableCollection;
 	}
 
 	public boolean isCollectionOfValuesOrComponents() {
 		return persister == null
 				&& queryableCollection != null
 				&& !queryableCollection.getElementType().isEntityType();
 	}
 
 	public boolean isEntity() {
 		return persister != null;
 	}
 
 	public ParameterSpecification getIndexCollectionSelectorParamSpec() {
 		return indexCollectionSelectorParamSpec;
 	}
 
 	public void setIndexCollectionSelectorParamSpec(ParameterSpecification indexCollectionSelectorParamSpec) {
 		this.indexCollectionSelectorParamSpec = indexCollectionSelectorParamSpec;
 	}
 
 	private class SpecialManyToManyCollectionPropertyMapping implements PropertyMapping {
 		/**
 		 * {@inheritDoc}
 		 */
 		public Type getType() {
 			return queryableCollection.getCollectionType();
 		}
 
 		private void validate(String propertyName) {
 			if ( ! ( CollectionPropertyNames.COLLECTION_INDEX.equals( propertyName )
 					|| CollectionPropertyNames.COLLECTION_MAX_INDEX.equals( propertyName )
 					|| CollectionPropertyNames.COLLECTION_MIN_INDEX.equals( propertyName ) ) ) {
 				throw new IllegalArgumentException( "Expecting index-related function call" );
 			}
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Type toType(String propertyName) throws QueryException {
 			validate( propertyName );
 			return queryableCollection.getIndexType();
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public String[] toColumns(String alias, String propertyName) throws QueryException {
 			validate( propertyName );
 			final String joinTableAlias = joinSequence.getFirstJoin().getAlias();
 			if ( CollectionPropertyNames.COLLECTION_INDEX.equals( propertyName ) ) {
 				return queryableCollection.toColumns( joinTableAlias, propertyName );
 			}
 
 			final String[] cols = queryableCollection.getIndexColumnNames( joinTableAlias );
 			if ( CollectionPropertyNames.COLLECTION_MIN_INDEX.equals( propertyName ) ) {
 				if ( cols.length != 1 ) {
 					throw new QueryException( "composite collection index in minIndex()" );
 				}
 				return new String[] { "min(" + cols[0] + ')' };
 			}
 			else {
 				if ( cols.length != 1 ) {
 					throw new QueryException( "composite collection index in maxIndex()" );
 				}
 				return new String[] { "max(" + cols[0] + ')' };
 			}
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public String[] toColumns(String propertyName) throws QueryException, UnsupportedOperationException {
 			validate( propertyName );
 			return queryableCollection.toColumns( propertyName );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromReferenceNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromReferenceNode.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromReferenceNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromReferenceNode.java
index fc1a2c7de8..ef0ef02167 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FromReferenceNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FromReferenceNode.java
@@ -1,131 +1,131 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.internal.CoreMessageLogger;
 
 import org.jboss.logging.Logger;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * Represents a reference to a FROM element, for example a class alias in a WHERE clause.
  *
  * @author josh
  */
 public abstract class FromReferenceNode extends AbstractSelectExpression
         implements ResolvableNode, DisplayableNode, InitializeableNode, PathNode {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, FromReferenceNode.class.getName());
 
 	private FromElement fromElement;
 	private boolean resolved = false;
 	public static final int ROOT_LEVEL = 0;
 
 	@Override
     public FromElement getFromElement() {
 		return fromElement;
 	}
 
 	public void setFromElement(FromElement fromElement) {
 		this.fromElement = fromElement;
 	}
 
 	/**
 	 * Resolves the left hand side of the DOT.
 	 *
 	 * @throws SemanticException
 	 */
 	public void resolveFirstChild() throws SemanticException {
 	}
 
 	public String getPath() {
 		return getOriginalText();
 	}
 
 	public boolean isResolved() {
 		return resolved;
 	}
 
 	public void setResolved() {
 		this.resolved = true;
         LOG.debugf("Resolved : %s -> %s", this.getPath(), this.getText());
 	}
 
 	public String getDisplayText() {
 		StringBuffer buf = new StringBuffer();
 		buf.append( "{" ).append( ( fromElement == null ) ? "no fromElement" : fromElement.getDisplayText() );
 		buf.append( "}" );
 		return buf.toString();
 	}
 
 	public void recursiveResolve(int level, boolean impliedAtRoot, String classAlias) throws SemanticException {
 		recursiveResolve( level, impliedAtRoot, classAlias, this );
 	}
 
 	public void recursiveResolve(int level, boolean impliedAtRoot, String classAlias, AST parent) throws SemanticException {
 		AST lhs = getFirstChild();
 		int nextLevel = level + 1;
 		if ( lhs != null ) {
 			FromReferenceNode n = ( FromReferenceNode ) lhs;
 			n.recursiveResolve( nextLevel, impliedAtRoot, null, this );
 		}
 		resolveFirstChild();
 		boolean impliedJoin = true;
 		if ( level == ROOT_LEVEL && !impliedAtRoot ) {
 			impliedJoin = false;
 		}
 		resolve( true, impliedJoin, classAlias, parent );
 	}
 
 	@Override
     public boolean isReturnableEntity() throws SemanticException {
 		return !isScalar() && fromElement.isEntity();
 	}
 
 	public void resolveInFunctionCall(boolean generateJoin, boolean implicitJoin) throws SemanticException {
 		resolve( generateJoin, implicitJoin );
 	}
 
 	public void resolve(boolean generateJoin, boolean implicitJoin) throws SemanticException {
 		resolve( generateJoin, implicitJoin, null );
 	}
 
 	public void resolve(boolean generateJoin, boolean implicitJoin, String classAlias) throws SemanticException {
 		resolve( generateJoin, implicitJoin, classAlias, null );
 	}
 
 	public void prepareForDot(String propertyName) throws SemanticException {
 	}
 
 	/**
 	 * Sub-classes can override this method if they produce implied joins (e.g. DotNode).
 	 *
 	 * @return an implied join created by this from reference.
 	 */
 	public FromElement getImpliedJoin() {
 		return null;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FunctionNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FunctionNode.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FunctionNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FunctionNode.java
index 8821a7ee13..4807bd43e1 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/FunctionNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/FunctionNode.java
@@ -1,36 +1,36 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.type.Type;
 
 /**
  * Identifies a node which models a SQL function.
  *
  * @author Steve Ebersole
  */
 public interface FunctionNode {
 	public SQLFunction getSQLFunction();
 	public Type getFirstArgumentType();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/HqlSqlWalkerNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/HqlSqlWalkerNode.java
similarity index 88%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/HqlSqlWalkerNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/HqlSqlWalkerNode.java
index 1472fcc4f2..5f3fba4f11 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/HqlSqlWalkerNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/HqlSqlWalkerNode.java
@@ -1,61 +1,61 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
-import org.hibernate.hql.ast.HqlSqlWalker;
-import org.hibernate.hql.ast.util.AliasGenerator;
-import org.hibernate.hql.ast.util.SessionFactoryHelper;
+package org.hibernate.hql.internal.ast.tree;
+import org.hibernate.hql.internal.ast.HqlSqlWalker;
+import org.hibernate.hql.internal.ast.util.AliasGenerator;
+import org.hibernate.hql.internal.ast.util.SessionFactoryHelper;
 import antlr.ASTFactory;
 
 /**
  * A semantic analysis node, that points back to the main analyzer.
  *
  * @author josh
  */
 public class HqlSqlWalkerNode extends SqlNode implements InitializeableNode {
 	/**
 	 * A pointer back to the phase 2 processor.
 	 */
 	private HqlSqlWalker walker;
 
 	public void initialize(Object param) {
 		walker = ( HqlSqlWalker ) param;
 	}
 
 	public HqlSqlWalker getWalker() {
 		return walker;
 	}
 
 	public SessionFactoryHelper getSessionFactoryHelper() {
 		return walker.getSessionFactoryHelper();
 	}
 
 	public ASTFactory getASTFactory() {
 		return walker.getASTFactory();
 	}
 
 	public AliasGenerator getAliasGenerator() {
 		return walker.getAliasGenerator();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IdentNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IdentNode.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IdentNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IdentNode.java
index 25569e15ac..fe75e4d726 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IdentNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IdentNode.java
@@ -1,338 +1,338 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import java.util.List;
 import org.hibernate.QueryException;
 import org.hibernate.dialect.function.SQLFunction;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.util.ColumnHelper;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.util.ColumnHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.Type;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * Represents an identifier all by itself, which may be a function name,
  * a class alias, or a form of naked property-ref depending on the
  * context.
  *
  * @author josh
  */
 public class IdentNode extends FromReferenceNode implements SelectExpression {
 
 	private static final int UNKNOWN = 0;
 	private static final int PROPERTY_REF = 1;
 	private static final int COMPONENT_REF = 2;
 
 	private boolean nakedPropertyRef = false;
 
 	public void resolveIndex(AST parent) throws SemanticException {
 		// An ident node can represent an index expression if the ident
 		// represents a naked property ref
 		//      *Note: this makes the assumption (which is currently the case
 		//      in the hql-sql grammar) that the ident is first resolved
 		//      itself (addrExpr -> resolve()).  The other option, if that
 		//      changes, is to call resolve from here; but it is
 		//      currently un-needed overhead.
 		if (!(isResolved() && nakedPropertyRef)) {
 			throw new UnsupportedOperationException();
 		}
 
 		String propertyName = getOriginalText();
 		if (!getDataType().isCollectionType()) {
 			throw new SemanticException("Collection expected; [" + propertyName + "] does not refer to a collection property");
 		}
 
 		// TODO : most of below was taken verbatim from DotNode; should either delegate this logic or super-type it
 		CollectionType type = (CollectionType) getDataType();
 		String role = type.getRole();
 		QueryableCollection queryableCollection = getSessionFactoryHelper().requireQueryableCollection(role);
 
 		String alias = null;  // DotNode uses null here...
 		String columnTableAlias = getFromElement().getTableAlias();
 		int joinType = JoinFragment.INNER_JOIN;
 		boolean fetch = false;
 
 		FromElementFactory factory = new FromElementFactory(
 				getWalker().getCurrentFromClause(),
 				getFromElement(),
 				propertyName,
 				alias,
 				getFromElement().toColumns(columnTableAlias, propertyName, false),
 				true
 		);
 		FromElement elem = factory.createCollection(queryableCollection, role, joinType, fetch, true);
 		setFromElement(elem);
 		getWalker().addQuerySpaces(queryableCollection.getCollectionSpaces());	// Always add the collection's query spaces.
 	}
 
 	public void resolve(boolean generateJoin, boolean implicitJoin, String classAlias, AST parent) {
 		if (!isResolved()) {
 			if (getWalker().getCurrentFromClause().isFromElementAlias(getText())) {
 				if (resolveAsAlias()) {
 					setResolved();
 					// We represent a from-clause alias
 				}
 			}
 			else if (parent != null && parent.getType() == SqlTokenTypes.DOT) {
 				DotNode dot = (DotNode) parent;
 				if (parent.getFirstChild() == this) {
 					if (resolveAsNakedComponentPropertyRefLHS(dot)) {
 						// we are the LHS of the DOT representing a naked comp-prop-ref
 						setResolved();
 					}
 				}
 				else {
 					if (resolveAsNakedComponentPropertyRefRHS(dot)) {
 						// we are the RHS of the DOT representing a naked comp-prop-ref
 						setResolved();
 					}
 				}
 			}
 			else {
 				int result = resolveAsNakedPropertyRef();
 				if (result == PROPERTY_REF) {
 					// we represent a naked (simple) prop-ref
 					setResolved();
 				}
 				else if (result == COMPONENT_REF) {
 					// EARLY EXIT!!!  return so the resolve call explicitly coming from DotNode can
 					// resolve this...
 					return;
 				}
 			}
 
 			// if we are still not resolved, we might represent a constant.
 			//      needed to add this here because the allowance of
 			//      naked-prop-refs in the grammar collides with the
 			//      definition of literals/constants ("nondeterminism").
 			//      TODO: cleanup the grammar so that "processConstants" is always just handled from here
 			if (!isResolved()) {
 				try {
 					getWalker().getLiteralProcessor().processConstant(this, false);
 				}
 				catch (Throwable ignore) {
 					// just ignore it for now, it'll get resolved later...
 				}
 			}
 		}
 	}
 
 	private boolean resolveAsAlias() {
 		// This is not actually a constant, but a reference to FROM element.
 		FromElement element = getWalker().getCurrentFromClause().getFromElement(getText());
 		if (element != null) {
 			setFromElement(element);
 			setText(element.getIdentityColumn());
 			setType(SqlTokenTypes.ALIAS_REF);
 			return true;
 		}
 		return false;
 	}
 
 	private Type getNakedPropertyType(FromElement fromElement)
 	{
 		if (fromElement == null) {
 			return null;
 		}
 		String property = getOriginalText();
 		Type propertyType = null;
 		try {
 			propertyType = fromElement.getPropertyType(property, property);
 		}
 		catch (Throwable t) {
 		}
 		return propertyType;
 	}
 
 	private int resolveAsNakedPropertyRef() {
 		FromElement fromElement = locateSingleFromElement();
 		if (fromElement == null) {
 			return UNKNOWN;
 		}
 		Queryable persister = fromElement.getQueryable();
 		if (persister == null) {
 			return UNKNOWN;
 		}
 		Type propertyType = getNakedPropertyType(fromElement);
 		if (propertyType == null) {
 			// assume this ident's text does *not* refer to a property on the given persister
 			return UNKNOWN;
 		}
 
 		if ((propertyType.isComponentType() || propertyType.isAssociationType() )) {
 			return COMPONENT_REF;
 		}
 
 		setFromElement(fromElement);
 		String property = getText();
 		String[] columns = getWalker().isSelectStatement()
 				? persister.toColumns(fromElement.getTableAlias(), property)
 				: persister.toColumns(property);
 		String text = StringHelper.join(", ", columns);
 		setText(columns.length == 1 ? text : "(" + text + ")");
 		setType(SqlTokenTypes.SQL_TOKEN);
 
 		// these pieces are needed for usage in select clause
 		super.setDataType(propertyType);
 		nakedPropertyRef = true;
 
 		return PROPERTY_REF;
 	}
 
 	private boolean resolveAsNakedComponentPropertyRefLHS(DotNode parent) {
 		FromElement fromElement = locateSingleFromElement();
 		if (fromElement == null) {
 			return false;
 		}
 
 		Type componentType = getNakedPropertyType(fromElement);
 		if ( componentType == null ) {
 			throw new QueryException( "Unable to resolve path [" + parent.getPath() + "], unexpected token [" + getOriginalText() + "]" );
 		}
 		if (!componentType.isComponentType()) {
 			throw new QueryException("Property '" + getOriginalText() + "' is not a component.  Use an alias to reference associations or collections.");
 		}
 
 		Type propertyType = null;  // used to set the type of the parent dot node
 		String propertyPath = getText() + "." + getNextSibling().getText();
 		try {
 			// check to see if our "propPath" actually
 			// represents a property on the persister
 			propertyType = fromElement.getPropertyType(getText(), propertyPath);
 		}
 		catch (Throwable t) {
 			// assume we do *not* refer to a property on the given persister
 			return false;
 		}
 
 		setFromElement(fromElement);
 		parent.setPropertyPath(propertyPath);
 		parent.setDataType(propertyType);
 
 		return true;
 	}
 
 	private boolean resolveAsNakedComponentPropertyRefRHS(DotNode parent) {
 		FromElement fromElement = locateSingleFromElement();
 		if (fromElement == null) {
 			return false;
 		}
 
 		Type propertyType = null;
 		String propertyPath = parent.getLhs().getText() + "." + getText();
 		try {
 			// check to see if our "propPath" actually
 			// represents a property on the persister
 			propertyType = fromElement.getPropertyType(getText(), propertyPath);
 		}
 		catch (Throwable t) {
 			// assume we do *not* refer to a property on the given persister
 			return false;
 		}
 
 		setFromElement(fromElement);
 		// this piece is needed for usage in select clause
 		super.setDataType(propertyType);
 		nakedPropertyRef = true;
 
 		return true;
 	}
 
 	private FromElement locateSingleFromElement() {
 		List fromElements = getWalker().getCurrentFromClause().getFromElements();
 		if (fromElements == null || fromElements.size() != 1) {
 			// TODO : should this be an error?
 			return null;
 		}
 		FromElement element = (FromElement) fromElements.get(0);
 		if (element.getClassAlias() != null) {
 			// naked property-refs cannot be used with an aliased from element
 			return null;
 		}
 		return element;
 	}
 
 	@Override
     public Type getDataType() {
 		Type type = super.getDataType();
 		if ( type != null ) {
 			return type;
 		}
 		FromElement fe = getFromElement();
 		if ( fe != null ) {
 			return fe.getDataType();
 		}
 		SQLFunction sf = getWalker().getSessionFactoryHelper().findSQLFunction( getText() );
 		if ( sf != null ) {
 			return sf.getReturnType( null, getWalker().getSessionFactoryHelper().getFactory() );
 		}
 		return null;
 	}
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		if (nakedPropertyRef) {
 			// do *not* over-write the column text, as that has already been
 			// "rendered" during resolve
 			ColumnHelper.generateSingleScalarColumn(this, i);
 		}
 		else {
 			FromElement fe = getFromElement();
 			if (fe != null) {
 				setText(fe.renderScalarIdentifierSelect(i));
 			}
 			else {
 				ColumnHelper.generateSingleScalarColumn(this, i);
 			}
 		}
 	}
 
 	@Override
     public String getDisplayText() {
 		StringBuffer buf = new StringBuffer();
 
 		if (getType() == SqlTokenTypes.ALIAS_REF) {
 			buf.append("{alias=").append(getOriginalText());
 			if (getFromElement() == null) {
 				buf.append(", no from element");
 			}
 			else {
 				buf.append(", className=").append(getFromElement().getClassName());
 				buf.append(", tableAlias=").append(getFromElement().getTableAlias());
 			}
 			buf.append("}");
 		}
 		else {
 			buf.append("{originalText=" + getOriginalText()).append("}");
 		}
 		return buf.toString();
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ImpliedFromElement.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ImpliedFromElement.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ImpliedFromElement.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ImpliedFromElement.java
index 5b3255f166..050ec3392a 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ImpliedFromElement.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ImpliedFromElement.java
@@ -1,81 +1,81 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 
 /**
  * Represents a FROM element implied by a path expression or a collection reference.
  *
  * @author josh
  */
 public class ImpliedFromElement extends FromElement {
 	/**
 	 * True if this from element was implied from a path in the FROM clause, but not
 	 * explicitly declard in the from clause.
 	 */
 	private boolean impliedInFromClause = false;
 
 	/**
 	 * True if this implied from element should be included in the projection list.
 	 */
 	private boolean inProjectionList = false;
 
 	public boolean isImplied() {
 		return true;
 	}
 
 	public void setImpliedInFromClause(boolean flag) {
 		impliedInFromClause = flag;
 	}
 
 	public boolean isImpliedInFromClause() {
 		return impliedInFromClause;
 	}
 
 	public void setInProjectionList(boolean inProjectionList) {
 		this.inProjectionList = inProjectionList;
 	}
 
 	public boolean inProjectionList() {
 		return inProjectionList && isFromOrJoinFragment();
 	}
 
 	public boolean isIncludeSubclasses() {
 		return false;	// Never include subclasses for implied from elements.
 	}
 
 	/**
 	 * Returns additional display text for the AST node.
 	 *
 	 * @return String - The additional display text.
 	 */
 	public String getDisplayText() {
 		StringBuffer buf = new StringBuffer();
 		buf.append( "ImpliedFromElement{" );
 		appendDisplayText( buf );
 		buf.append( "}" );
 		return buf.toString();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/InLogicOperatorNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/InLogicOperatorNode.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/InLogicOperatorNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/InLogicOperatorNode.java
index 13a35893a3..d887490d96 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/InLogicOperatorNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/InLogicOperatorNode.java
@@ -1,173 +1,173 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import java.util.ArrayList;
 import java.util.List;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.antlr.HqlTokenTypes;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.antlr.HqlTokenTypes;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.type.Type;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * @author Steve Ebersole
  */
 public class InLogicOperatorNode extends BinaryLogicOperatorNode implements BinaryOperatorNode {
 
 	public Node getInList() {
 		return getRightHandOperand();
 	}
 
 	public void initialize() throws SemanticException {
 		Node lhs = getLeftHandOperand();
 		if ( lhs == null ) {
 			throw new SemanticException( "left-hand operand of in operator was null" );
 		}
 		Node inList = getInList();
 		if ( inList == null ) {
 			throw new SemanticException( "right-hand operand of in operator was null" );
 		}
 
 		// for expected parameter type injection, we expect that the lhs represents
 		// some form of property ref and that the children of the in-list represent
 		// one-or-more params.
 		if ( SqlNode.class.isAssignableFrom( lhs.getClass() ) ) {
 			Type lhsType = ( ( SqlNode ) lhs ).getDataType();
 			AST inListChild = inList.getFirstChild();
 			while ( inListChild != null ) {
 				if ( ExpectedTypeAwareNode.class.isAssignableFrom( inListChild.getClass() ) ) {
 					( ( ExpectedTypeAwareNode ) inListChild ).setExpectedType( lhsType );
 				}
 				inListChild = inListChild.getNextSibling();
 			}
 		}
 		SessionFactoryImplementor sessionFactory = getSessionFactoryHelper().getFactory();
 		if ( sessionFactory.getDialect().supportsRowValueConstructorSyntaxInInList() )
 			return;
         
         Type lhsType = extractDataType( lhs );
         if ( lhsType == null )
             return;
         int lhsColumnSpan = lhsType.getColumnSpan( sessionFactory );
         Node rhsNode = (Node) inList.getFirstChild();
         if ( !isNodeAcceptable( rhsNode ) )
             return;
         int rhsColumnSpan = 0;
         if ( rhsNode.getType() == HqlTokenTypes.VECTOR_EXPR ) {
             rhsColumnSpan = rhsNode.getNumberOfChildren();
         } else {
             Type rhsType = extractDataType( rhsNode );
             if ( rhsType == null )
                 return;
             rhsColumnSpan = rhsType.getColumnSpan( sessionFactory );
         }
 		if ( lhsColumnSpan > 1 && rhsColumnSpan > 1 ) {
 			mutateRowValueConstructorSyntaxInInListSyntax( lhsColumnSpan, rhsColumnSpan );
 		}
 	}
 	
 	/**
 	 * this is possible for parameter lists and explicit lists. It is completely unreasonable for sub-queries.
 	 */
     private boolean isNodeAcceptable( Node rhsNode ) {
         return rhsNode instanceof LiteralNode
                 || rhsNode instanceof ParameterNode
                 || rhsNode.getType() == HqlTokenTypes.VECTOR_EXPR;
     }
     /**
      * Mutate the subtree relating to a row-value-constructor in "in" list to instead use
      * a series of ORen and ANDed predicates.  This allows multi-column type comparisons
      * and explicit row-value-constructor in "in" list syntax even on databases which do
      * not support row-value-constructor in "in" list.
      * <p/>
      * For example, here we'd mutate "... where (col1, col2) in ( ('val1', 'val2'), ('val3', 'val4') ) ..." to
      * "... where (col1 = 'val1' and col2 = 'val2') or (col1 = 'val3' and val2 = 'val4') ..."
      *
      * @param lhsColumnSpan The number of elements in the row value constructor list.
      */
     private void mutateRowValueConstructorSyntaxInInListSyntax(
             int lhsColumnSpan, int rhsColumnSpan ) {
         String[] lhsElementTexts = extractMutationTexts( getLeftHandOperand(),
                 lhsColumnSpan );
         Node rhsNode = (Node) getInList().getFirstChild();
 
         ParameterSpecification lhsEmbeddedCompositeParameterSpecification = getLeftHandOperand() == null
                 || ( !ParameterNode.class.isInstance( getLeftHandOperand() ) ) ? null
                 : ( (ParameterNode) getLeftHandOperand() )
                         .getHqlParameterSpecification();
         /**
          * only one element in "in" cluster, e.g.
          * <code> where (a,b) in ( (1,2) ) </code> this will be mutated to
          * <code>where a=1 and b=2 </code>
          */
         if ( rhsNode != null && rhsNode.getNextSibling() == null ) {
             String[] rhsElementTexts = extractMutationTexts( rhsNode,
                     rhsColumnSpan );
             setType( HqlSqlTokenTypes.AND );
             setText( "AND" );
             ParameterSpecification rhsEmbeddedCompositeParameterSpecification = rhsNode == null
                     || ( !ParameterNode.class.isInstance( rhsNode ) ) ? null
                     : ( (ParameterNode) rhsNode )
                             .getHqlParameterSpecification();
             translate( lhsColumnSpan, HqlSqlTokenTypes.EQ, "=", lhsElementTexts,
                     rhsElementTexts,
                     lhsEmbeddedCompositeParameterSpecification,
                     rhsEmbeddedCompositeParameterSpecification, this );
         } else {
             List andElementsNodeList = new ArrayList();
             while ( rhsNode != null ) {
                 String[] rhsElementTexts = extractMutationTexts( rhsNode,
                         rhsColumnSpan );
                 AST and = getASTFactory().create( HqlSqlTokenTypes.AND, "AND" );
                 ParameterSpecification rhsEmbeddedCompositeParameterSpecification = rhsNode == null
                         || ( !ParameterNode.class.isInstance( rhsNode ) ) ? null
                         : ( (ParameterNode) rhsNode )
                                 .getHqlParameterSpecification();
                 translate( lhsColumnSpan, HqlSqlTokenTypes.EQ, "=",
                         lhsElementTexts, rhsElementTexts,
                         lhsEmbeddedCompositeParameterSpecification,
                         rhsEmbeddedCompositeParameterSpecification, and );
                 andElementsNodeList.add( and );
                 rhsNode = (Node) rhsNode.getNextSibling();
             }
             setType( HqlSqlTokenTypes.OR );
             setText( "OR" );
             AST curNode = this;
             for ( int i = andElementsNodeList.size() - 1; i > 1; i-- ) {
                 AST or = getASTFactory().create( HqlSqlTokenTypes.OR, "OR" );
                 curNode.setFirstChild( or );
                 curNode = or;
                 AST and = (AST) andElementsNodeList.get( i );
                 or.setNextSibling( and );
             }
             AST node0 = (AST) andElementsNodeList.get( 0 );
             AST node1 = (AST) andElementsNodeList.get( 1 );
             node0.setNextSibling( node1 );
             curNode.setFirstChild( node0 );
         }
     }
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IndexNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IndexNode.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IndexNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IndexNode.java
index 3b43693fd8..6e30eb88ef 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IndexNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IndexNode.java
@@ -1,212 +1,212 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.Iterator;
 import java.util.List;
 
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.QueryException;
 import org.hibernate.engine.internal.JoinSequence;
 import org.hibernate.engine.spi.QueryParameters;
-import org.hibernate.hql.ast.SqlGenerator;
-import org.hibernate.hql.ast.util.SessionFactoryHelper;
+import org.hibernate.hql.internal.ast.SqlGenerator;
+import org.hibernate.hql.internal.ast.util.SessionFactoryHelper;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 import antlr.RecognitionException;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * Represents the [] operator and provides it's semantics.
  *
  * @author josh
  */
 public class IndexNode extends FromReferenceNode {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, IndexNode.class.getName());
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		throw new UnsupportedOperationException( "An IndexNode cannot generate column text!" );
 	}
 
 	@Override
     public void prepareForDot(String propertyName) throws SemanticException {
 		FromElement fromElement = getFromElement();
 		if ( fromElement == null ) {
 			throw new IllegalStateException( "No FROM element for index operator!" );
 		}
 		QueryableCollection queryableCollection = fromElement.getQueryableCollection();
 		if ( queryableCollection != null && !queryableCollection.isOneToMany() ) {
 
 			FromReferenceNode collectionNode = ( FromReferenceNode ) getFirstChild();
 			String path = collectionNode.getPath() + "[]." + propertyName;
             LOG.debugf("Creating join for many-to-many elements for %s", path);
 			FromElementFactory factory = new FromElementFactory( fromElement.getFromClause(), fromElement, path );
 			// This will add the new from element to the origin.
 			FromElement elementJoin = factory.createElementJoin( queryableCollection );
 			setFromElement( elementJoin );
 		}
 	}
 
 	public void resolveIndex(AST parent) throws SemanticException {
 		throw new UnsupportedOperationException();
 	}
 
 	public void resolve(boolean generateJoin, boolean implicitJoin, String classAlias, AST parent)
 	throws SemanticException {
 		if ( isResolved() ) {
 			return;
 		}
 		FromReferenceNode collectionNode = ( FromReferenceNode ) getFirstChild();
 		SessionFactoryHelper sessionFactoryHelper = getSessionFactoryHelper();
 		collectionNode.resolveIndex( this );		// Fully resolve the map reference, create implicit joins.
 
 		Type type = collectionNode.getDataType();
 		if ( !type.isCollectionType() ) {
 			throw new SemanticException( "The [] operator cannot be applied to type " + type.toString() );
 		}
 		String collectionRole = ( ( CollectionType ) type ).getRole();
 		QueryableCollection queryableCollection = sessionFactoryHelper.requireQueryableCollection( collectionRole );
 		if ( !queryableCollection.hasIndex() ) {
 			throw new QueryException( "unindexed fromElement before []: " + collectionNode.getPath() );
 		}
 
 		// Generate the inner join -- The elements need to be joined to the collection they are in.
 		FromElement fromElement = collectionNode.getFromElement();
 		String elementTable = fromElement.getTableAlias();
 		FromClause fromClause = fromElement.getFromClause();
 		String path = collectionNode.getPath();
 
 		FromElement elem = fromClause.findCollectionJoin( path );
 		if ( elem == null ) {
 			FromElementFactory factory = new FromElementFactory( fromClause, fromElement, path );
 			elem = factory.createCollectionElementsJoin( queryableCollection, elementTable );
             LOG.debugf("No FROM element found for the elements of collection join path %s, created %s", path, elem);
         } else LOG.debugf("FROM element found for collection join path %s", path);
 
 		// The 'from element' that represents the elements of the collection.
 		setFromElement( fromElement );
 
 		// Add the condition to the join sequence that qualifies the indexed element.
 		AST selector = collectionNode.getNextSibling();
 		if ( selector == null ) {
 			throw new QueryException( "No index value!" );
 		}
 
 		// Sometimes use the element table alias, sometimes use the... umm... collection table alias (many to many)
 		String collectionTableAlias = elementTable;
 		if ( elem.getCollectionTableAlias() != null ) {
 			collectionTableAlias = elem.getCollectionTableAlias();
 		}
 
 		// TODO: get SQL rendering out of here, create an AST for the join expressions.
 		// Use the SQL generator grammar to generate the SQL text for the index expression.
 		JoinSequence joinSequence = fromElement.getJoinSequence();
 		String[] indexCols = queryableCollection.getIndexColumnNames();
 		if ( indexCols.length != 1 ) {
 			throw new QueryException( "composite-index appears in []: " + collectionNode.getPath() );
 		}
 		SqlGenerator gen = new SqlGenerator( getSessionFactoryHelper().getFactory() );
 		try {
 			gen.simpleExpr( selector ); //TODO: used to be exprNoParens! was this needed?
 		}
 		catch ( RecognitionException e ) {
 			throw new QueryException( e.getMessage(), e );
 		}
 		String selectorExpression = gen.getSQL();
 		joinSequence.addCondition( collectionTableAlias + '.' + indexCols[0] + " = " + selectorExpression );
 		List paramSpecs = gen.getCollectedParameters();
 		if ( paramSpecs != null ) {
 			switch ( paramSpecs.size() ) {
 				case 0 :
 					// nothing to do
 					break;
 				case 1 :
 					ParameterSpecification paramSpec = ( ParameterSpecification ) paramSpecs.get( 0 );
 					paramSpec.setExpectedType( queryableCollection.getIndexType() );
 					fromElement.setIndexCollectionSelectorParamSpec( paramSpec );
 					break;
 				default:
 					fromElement.setIndexCollectionSelectorParamSpec(
 							new AggregatedIndexCollectionSelectorParameterSpecifications( paramSpecs )
 					);
 					break;
 			}
 		}
 
 		// Now, set the text for this node.  It should be the element columns.
 		String[] elementColumns = queryableCollection.getElementColumnNames( elementTable );
 		setText( elementColumns[0] );
 		setResolved();
 	}
 
 	/**
 	 * In the (rare?) case where the index selector contains multiple parameters...
 	 */
 	private static class AggregatedIndexCollectionSelectorParameterSpecifications implements ParameterSpecification {
 		private final List paramSpecs;
 
 		public AggregatedIndexCollectionSelectorParameterSpecifications(List paramSpecs) {
 			this.paramSpecs = paramSpecs;
 		}
 
 		public int bind(PreparedStatement statement, QueryParameters qp, SessionImplementor session, int position)
 		throws SQLException {
 			int bindCount = 0;
 			Iterator itr = paramSpecs.iterator();
 			while ( itr.hasNext() ) {
 				final ParameterSpecification paramSpec = ( ParameterSpecification ) itr.next();
 				bindCount += paramSpec.bind( statement, qp, session, position + bindCount );
 			}
 			return bindCount;
 		}
 
 		public Type getExpectedType() {
 			return null;
 		}
 
 		public void setExpectedType(Type expectedType) {
 		}
 
 		public String renderDisplayInfo() {
 			return "index-selector [" + collectDisplayInfo() + "]" ;
 		}
 
 		private String collectDisplayInfo() {
 			StringBuffer buffer = new StringBuffer();
 			Iterator itr = paramSpecs.iterator();
 			while ( itr.hasNext() ) {
 				buffer.append( ( ( ParameterSpecification ) itr.next() ).renderDisplayInfo() );
 			}
 			return buffer.toString();
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/InitializeableNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/InitializeableNode.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/InitializeableNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/InitializeableNode.java
index c10604e5ba..9bc01d1667 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/InitializeableNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/InitializeableNode.java
@@ -1,38 +1,38 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 
 /**
  * An interface for initializeable AST nodes.
  */
 public interface InitializeableNode {
 	/**
 	 * Initializes the node with the parameter.
 	 *
 	 * @param param the initialization parameter.
 	 */
 	void initialize(Object param);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/InsertStatement.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/InsertStatement.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/InsertStatement.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/InsertStatement.java
index 7c89c581f4..5ed90ac2fc 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/InsertStatement.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/InsertStatement.java
@@ -1,77 +1,77 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.QueryException;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
 
 /**
  * Defines a top-level AST node representing an HQL "insert select" statement.
  *
  * @author Steve Ebersole
  */
 public class InsertStatement extends AbstractStatement {
 
 	/**
 	 * @see Statement#getStatementType()
 	 */
 	public int getStatementType() {
 		return HqlSqlTokenTypes.INSERT;
 	}
 
 	/**
 	 * @see Statement#needsExecutor()
 	 */
 	public boolean needsExecutor() {
 		return true;
 	}
 
 	/**
 	 * Performs detailed semantic validation on this insert statement tree.
 	 *
 	 * @throws QueryException Indicates validation failure.
 	 */
 	public void validate() throws QueryException {
 		getIntoClause().validateTypes( getSelectClause() );
 	}
 
 	/**
 	 * Retreive this insert statement's into-clause.
 	 *
 	 * @return The into-clause
 	 */
 	public IntoClause getIntoClause() {
 		return ( IntoClause ) getFirstChild();
 	}
 
 	/**
 	 * Retreive this insert statement's select-clause.
 	 *
 	 * @return The select-clause.
 	 */
 	public SelectClause getSelectClause() {
 		return ( ( QueryNode ) getIntoClause().getNextSibling() ).getSelectClause();
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IntoClause.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IntoClause.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IntoClause.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IntoClause.java
index 227fa298de..6219d124c7 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IntoClause.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IntoClause.java
@@ -1,255 +1,255 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import java.sql.Types;
 import java.util.ArrayList;
 import java.util.List;
 import org.hibernate.QueryException;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.type.Type;
 import antlr.collections.AST;
 
 /**
  * Represents an entity referenced in the INTO clause of an HQL
  * INSERT statement.
  *
  * @author Steve Ebersole
  */
 public class IntoClause extends HqlSqlWalkerNode implements DisplayableNode {
 
 	private Queryable persister;
 	private String columnSpec = "";
 	private Type[] types;
 
 	private boolean discriminated;
 	private boolean explicitIdInsertion;
 	private boolean explicitVersionInsertion;
 
 
 	public void initialize(Queryable persister) {
 		if ( persister.isAbstract() ) {
 			throw new QueryException( "cannot insert into abstract class (no table)" );
 		}
 		this.persister = persister;
 		initializeColumns();
 
 		if ( getWalker().getSessionFactoryHelper().hasPhysicalDiscriminatorColumn( persister ) ) {
 			discriminated = true;
 			columnSpec += ", " + persister.getDiscriminatorColumnName();
 		}
 
 		resetText();
 	}
 
 	private void resetText() {
 		setText( "into " + getTableName() + " ( " + columnSpec + " )" );
 	}
 
 	public String getTableName() {
 		return persister.getSubclassTableName( 0 );
 	}
 
 	public Queryable getQueryable() {
 		return persister;
 	}
 
 	public String getEntityName() {
 		return persister.getEntityName();
 	}
 
 	public Type[] getInsertionTypes() {
 		return types;
 	}
 
 	public boolean isDiscriminated() {
 		return discriminated;
 	}
 
 	public boolean isExplicitIdInsertion() {
 		return explicitIdInsertion;
 	}
 
 	public boolean isExplicitVersionInsertion() {
 		return explicitVersionInsertion;
 	}
 
 	public void prependIdColumnSpec() {
 		columnSpec = persister.getIdentifierColumnNames()[0] + ", " + columnSpec;
 		resetText();
 	}
 
 	public void prependVersionColumnSpec() {
 		columnSpec = persister.getPropertyColumnNames( persister.getVersionProperty() )[0] + ", " + columnSpec;
 		resetText();
 	}
 
 	public void validateTypes(SelectClause selectClause) throws QueryException {
 		Type[] selectTypes = selectClause.getQueryReturnTypes();
 		if ( selectTypes.length != types.length ) {
 			throw new QueryException( "number of select types did not match those for insert" );
 		}
 
 		for ( int i = 0; i < types.length; i++ ) {
 			if ( !areCompatible( types[i], selectTypes[i] ) ) {
 				throw new QueryException(
 				        "insertion type [" + types[i] + "] and selection type [" +
 				        selectTypes[i] + "] at position " + i + " are not compatible"
 				);
 			}
 		}
 
 		// otherwise, everything ok.
 	}
 
 	/**
 	 * Returns additional display text for the AST node.
 	 *
 	 * @return String - The additional display text.
 	 */
 	public String getDisplayText() {
 		StringBuffer buf = new StringBuffer();
 		buf.append( "IntoClause{" );
 		buf.append( "entityName=" ).append( getEntityName() );
 		buf.append( ",tableName=" ).append( getTableName() );
 		buf.append( ",columns={" ).append( columnSpec ).append( "}" );
 		buf.append( "}" );
 		return buf.toString();
 	}
 
 	private void initializeColumns() {
 		AST propertySpec = getFirstChild();
 		List types = new ArrayList();
 		visitPropertySpecNodes( propertySpec.getFirstChild(), types );
 		this.types = ArrayHelper.toTypeArray( types );
 		columnSpec = columnSpec.substring( 0, columnSpec.length() - 2 );
 	}
 
 	private void visitPropertySpecNodes(AST propertyNode, List types) {
 		if ( propertyNode == null ) {
 			return;
 		}
 		// TODO : we really need to be able to deal with component paths here also;
 		// this is difficult because the hql-sql grammar expects all those node types
 		// to be FromReferenceNodes.  One potential fix here would be to convert the
 		// IntoClause to just use a FromClause/FromElement combo (as a child of the
 		// InsertStatement) and move all this logic into the InsertStatement.  That's
 		// probably the easiest approach (read: least amount of changes to the grammar
 		// and code), but just doesn't feel right as then an insert would contain
 		// 2 from-clauses
 		String name = propertyNode.getText();
 		if ( isSuperclassProperty( name ) ) {
 			throw new QueryException( "INSERT statements cannot refer to superclass/joined properties [" + name + "]" );
 		}
 
 		if ( name.equals( persister.getIdentifierPropertyName() ) ) {
 			explicitIdInsertion = true;
 		}
 
 		if ( persister.isVersioned() ) {
 			if ( name.equals( persister.getPropertyNames()[ persister.getVersionProperty() ] ) ) {
 				explicitVersionInsertion = true;
 			}
 		}
 
 		String[] columnNames = persister.toColumns( name );
 		renderColumns( columnNames );
 		types.add( persister.toType( name ) );
 
 		// visit width-first, then depth
 		visitPropertySpecNodes( propertyNode.getNextSibling(), types );
 		visitPropertySpecNodes( propertyNode.getFirstChild(), types );
 	}
 
 	private void renderColumns(String[] columnNames) {
 		for ( int i = 0; i < columnNames.length; i++ ) {
 			columnSpec += columnNames[i] + ", ";
 		}
 	}
 
 	private boolean isSuperclassProperty(String propertyName) {
 		// really there are two situations where it should be ok to allow the insertion
 		// into properties defined on a superclass:
 		//      1) union-subclass with an abstract root entity
 		//      2) discrim-subclass
 		//
 		// #1 is handled already because of the fact that
 		// UnionSubclassPersister alreay always returns 0
 		// for this call...
 		//
 		// we may want to disallow it for discrim-subclass just for
 		// consistency-sake (currently does not work anyway)...
 		return persister.getSubclassPropertyTableNumber( propertyName ) != 0;
 	}
 
 	/**
 	 * Determine whether the two types are "assignment compatible".
 	 *
 	 * @param target The type defined in the into-clause.
 	 * @param source The type defined in the select clause.
 	 * @return True if they are assignment compatible.
 	 */
 	private boolean areCompatible(Type target, Type source) {
 		if ( target.equals( source ) ) {
 			// if the types report logical equivalence, return true...
 			return true;
 		}
 
 		// otherwise, doAfterTransactionCompletion a "deep equivalence" check...
 
 		if ( !target.getReturnedClass().isAssignableFrom( source.getReturnedClass() ) ) {
 			return false;
 		}
 
 		int[] targetDatatypes = target.sqlTypes( getSessionFactoryHelper().getFactory() );
 		int[] sourceDatatypes = source.sqlTypes( getSessionFactoryHelper().getFactory() );
 
 		if ( targetDatatypes.length != sourceDatatypes.length ) {
 			return false;
 		}
 
 		for ( int i = 0; i < targetDatatypes.length; i++ ) {
 			if ( !areSqlTypesCompatible( targetDatatypes[i], sourceDatatypes[i] ) ) {
 				return false;
 			}
 		}
 
 		return true;
 	}
 
 	private boolean areSqlTypesCompatible(int target, int source) {
 		switch ( target ) {
 			case Types.TIMESTAMP:
 				return source == Types.DATE || source == Types.TIME || source == Types.TIMESTAMP;
 			case Types.DATE:
 				return source == Types.DATE || source == Types.TIMESTAMP;
 			case Types.TIME:
 				return source == Types.TIME || source == Types.TIMESTAMP;
 			default:
 				return target == source;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IsNotNullLogicOperatorNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IsNotNullLogicOperatorNode.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IsNotNullLogicOperatorNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IsNotNullLogicOperatorNode.java
index eaa1e021a1..5f9e8aeae6 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IsNotNullLogicOperatorNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IsNotNullLogicOperatorNode.java
@@ -1,41 +1,41 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
+package org.hibernate.hql.internal.ast.tree;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
 
 /**
  * IsNotNullLogicOperatorNode implementation
  *
  * @author Steve Ebersole
  */
 public class IsNotNullLogicOperatorNode extends AbstractNullnessCheckNode {
 	protected int getExpansionConnectorType() {
 		return HqlSqlTokenTypes.OR;
 	}
 
 	protected String getExpansionConnectorText() {
 		return "OR";
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IsNullLogicOperatorNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IsNullLogicOperatorNode.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IsNullLogicOperatorNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IsNullLogicOperatorNode.java
index fa85713754..55e94d5fb1 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/IsNullLogicOperatorNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/IsNullLogicOperatorNode.java
@@ -1,41 +1,41 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
+package org.hibernate.hql.internal.ast.tree;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
 
 /**
  * Represents a 'is null' check.
  *
  * @author Steve Ebersole
  */
 public class IsNullLogicOperatorNode extends AbstractNullnessCheckNode {
 	protected int getExpansionConnectorType() {
 		return HqlSqlTokenTypes.AND;
 	}
 
 	protected String getExpansionConnectorText() {
 		return "AND";
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/JavaConstantNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/JavaConstantNode.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/JavaConstantNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/JavaConstantNode.java
index 9f0944b8b4..82fb6ba00a 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/JavaConstantNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/JavaConstantNode.java
@@ -1,91 +1,91 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import org.hibernate.QueryException;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.hql.QueryTranslator;
+import org.hibernate.hql.spi.QueryTranslator;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.type.LiteralType;
 import org.hibernate.type.Type;
 
 /**
  * A node representing a static Java constant.
  *
  * @author Steve Ebersole
  */
 public class JavaConstantNode extends Node implements ExpectedTypeAwareNode, SessionFactoryAwareNode {
 
 	private SessionFactoryImplementor factory;
 
 	private String constantExpression;
 	private Object constantValue;
 	private Type heuristicType;
 
 	private Type expectedType;
 
 	@Override
     public void setText(String s) {
 		// for some reason the antlr.CommonAST initialization routines force
 		// this method to get called twice.  The first time with an empty string
 		if ( StringHelper.isNotEmpty( s ) ) {
 			constantExpression = s;
 			constantValue = ReflectHelper.getConstantValue( s );
 			heuristicType = factory.getTypeResolver().heuristicType( constantValue.getClass().getName() );
 			super.setText( s );
 		}
 	}
 
 	public void setExpectedType(Type expectedType) {
 		this.expectedType = expectedType;
 	}
 
 	public Type getExpectedType() {
 		return expectedType;
 	}
 
 	public void setSessionFactory(SessionFactoryImplementor factory) {
 		this.factory = factory;
 	}
 
 	@Override
     public String getRenderText(SessionFactoryImplementor sessionFactory) {
 		Type type = expectedType == null
 				? heuristicType
 				: Number.class.isAssignableFrom( heuristicType.getReturnedClass() )
 						? heuristicType
 						: expectedType;
 		try {
 			LiteralType literalType = ( LiteralType ) type;
 			Dialect dialect = factory.getDialect();
 			return literalType.objectToSQLString( constantValue, dialect );
 		}
 		catch ( Throwable t ) {
 			throw new QueryException( QueryTranslator.ERROR_CANNOT_FORMAT_LITERAL + constantExpression, t );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/LiteralNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/LiteralNode.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/LiteralNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/LiteralNode.java
index 3f04744cfd..6ad942b7c4 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/LiteralNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/LiteralNode.java
@@ -1,67 +1,67 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import antlr.SemanticException;
 
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.ast.util.ColumnHelper;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.ast.util.ColumnHelper;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.Type;
 
 /**
  * Represents a literal.
  *
  * @author josh
  */
 public class LiteralNode extends AbstractSelectExpression implements HqlSqlTokenTypes {
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		ColumnHelper.generateSingleScalarColumn( this, i );
 	}
 
 	public Type getDataType() {
 		switch ( getType() ) {
 			case NUM_INT:
 				return StandardBasicTypes.INTEGER;
 			case NUM_FLOAT:
 				return StandardBasicTypes.FLOAT;
 			case NUM_LONG:
 				return StandardBasicTypes.LONG;
 			case NUM_DOUBLE:
 				return StandardBasicTypes.DOUBLE;
 			case NUM_BIG_INTEGER:
 				return StandardBasicTypes.BIG_INTEGER;
 			case NUM_BIG_DECIMAL:
 				return StandardBasicTypes.BIG_DECIMAL;
 			case QUOTED_STRING:
 				return StandardBasicTypes.STRING;
 			case TRUE:
 			case FALSE:
 				return StandardBasicTypes.BOOLEAN;
 			default:
 				return null;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/MapEntryNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/MapEntryNode.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/MapEntryNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/MapEntryNode.java
index 046b333d28..737e6ff9ad 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/MapEntryNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/MapEntryNode.java
@@ -1,285 +1,285 @@
 /*
  * Copyright (c) 2009, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.hql.NameGenerator;
+import org.hibernate.hql.internal.NameGenerator;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.AliasGenerator;
 import org.hibernate.sql.SelectExpression;
 import org.hibernate.sql.SelectFragment;
 import org.hibernate.transform.BasicTransformerAdapter;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import antlr.SemanticException;
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class MapEntryNode extends AbstractMapComponentNode implements AggregatedSelectExpression {
 	private static class LocalAliasGenerator implements AliasGenerator {
 		private final int base;
 		private int counter = 0;
 
 		private LocalAliasGenerator(int base) {
 			this.base = base;
 		}
 
 		public String generateAlias(String sqlExpression) {
 			return NameGenerator.scalarName( base, counter++ );
 		}
 	}
 
 	private int scalarColumnIndex = -1;
 
 	protected String expressionDescription() {
 		return "entry(*)";
 	}
 
 	@Override
 	public Class getAggregationResultType() {
 		return Map.Entry.class;
 	}
 
 	protected Type resolveType(QueryableCollection collectionPersister) {
 		Type keyType = collectionPersister.getIndexType();
 		Type valueType = collectionPersister.getElementType();
 		types.add( keyType );
 		types.add( valueType );
 		mapEntryBuilder = new MapEntryBuilder();
 
 		// an entry (as an aggregated select expression) does not have a type...
 		return null;
 	}
 
 	protected String[] resolveColumns(QueryableCollection collectionPersister) {
 		List selections = new ArrayList();
 		determineKeySelectExpressions( collectionPersister, selections );
 		determineValueSelectExpressions( collectionPersister, selections );
 
 		String text = "";
 		String[] columns = new String[selections.size()];
 		for ( int i = 0; i < selections.size(); i++ ) {
 			SelectExpression selectExpression = (SelectExpression) selections.get(i);
 			text += ( ", " + selectExpression.getExpression() + " as " + selectExpression.getAlias() );
 			columns[i] = selectExpression.getExpression();
 		}
 
 		text = text.substring( 2 ); //strip leading ", "
 		setText( text );
 		setResolved();
 		return columns;
 	}
 
 	private void determineKeySelectExpressions(QueryableCollection collectionPersister, List selections) {
 		AliasGenerator aliasGenerator = new LocalAliasGenerator( 0 );
 		appendSelectExpressions( collectionPersister.getIndexColumnNames(), selections, aliasGenerator );
 		Type keyType = collectionPersister.getIndexType();
 		if ( keyType.isAssociationType() ) {
 			EntityType entityType = (EntityType) keyType;
 			Queryable keyEntityPersister = ( Queryable ) sfi().getEntityPersister(
 					entityType.getAssociatedEntityName( sfi() )
 			);
 			SelectFragment fragment = keyEntityPersister.propertySelectFragmentFragment(
 					collectionTableAlias(),
 					null,
 					false
 			);
 			appendSelectExpressions( fragment, selections, aliasGenerator );
 		}
 	}
 
 	private void appendSelectExpressions(String[] columnNames, List selections, AliasGenerator aliasGenerator) {
 		for ( int i = 0; i < columnNames.length; i++ ) {
 			selections.add(
 					new BasicSelectExpression(
 							collectionTableAlias() + '.' + columnNames[i],
 							aliasGenerator.generateAlias( columnNames[i] )
 					)
 			);
 		}
 	}
 
 	private void appendSelectExpressions(SelectFragment fragment, List selections, AliasGenerator aliasGenerator) {
 		Iterator itr = fragment.getColumns().iterator();
 		while ( itr.hasNext() ) {
 			final String column = (String) itr.next();
 			selections.add(
 					new BasicSelectExpression( column, aliasGenerator.generateAlias( column ) )
 			);
 		}
 	}
 
 	private void determineValueSelectExpressions(QueryableCollection collectionPersister, List selections) {
 		AliasGenerator aliasGenerator = new LocalAliasGenerator( 1 );
 		appendSelectExpressions( collectionPersister.getElementColumnNames(), selections, aliasGenerator );
 		Type valueType = collectionPersister.getElementType();
 		if ( valueType.isAssociationType() ) {
 			EntityType valueEntityType = (EntityType) valueType;
 			Queryable valueEntityPersister = ( Queryable ) sfi().getEntityPersister(
 					valueEntityType.getAssociatedEntityName( sfi() )
 			);
 			SelectFragment fragment = valueEntityPersister.propertySelectFragmentFragment(
 					elementTableAlias(),
 					null,
 					false
 			);
 			appendSelectExpressions( fragment, selections, aliasGenerator );
 		}
 	}
 
 	private String collectionTableAlias() {
 		return getFromElement().getCollectionTableAlias() != null
 				? getFromElement().getCollectionTableAlias()
 				: getFromElement().getTableAlias();
 	}
 
 	private String elementTableAlias() {
 		return getFromElement().getTableAlias();
 	}
 
 	private static class BasicSelectExpression implements SelectExpression {
 		private final String expression;
 		private final String alias;
 
 		private BasicSelectExpression(String expression, String alias) {
 			this.expression = expression;
 			this.alias = alias;
 		}
 
 		public String getExpression() {
 			return expression;
 		}
 
 		public String getAlias() {
 			return alias;
 		}
 	}
 
 	public SessionFactoryImplementor sfi() {
 		return getSessionFactoryHelper().getFactory();
 	}
 
 	public void setText(String s) {
 		if ( isResolved() ) {
 			return;
 		}
 		super.setText( s );
 	}
 
 	public void setScalarColumn(int i) throws SemanticException {
 		this.scalarColumnIndex = i;
 	}
 
 	public int getScalarColumnIndex() {
 		return scalarColumnIndex;
 	}
 
 	public void setScalarColumnText(int i) throws SemanticException {
 	}
 
 	public boolean isScalar() {
 		// Constructors are always considered scalar results.
 		return true;
 	}
 
 	private List types = new ArrayList(4); // size=4 to prevent resizing
 
 	public List getAggregatedSelectionTypeList() {
 		return types;
 	}
 
 	private static final String[] ALIASES = { null, null };
 
 	public String[] getAggregatedAliases() {
 		return ALIASES;
 	}
 
 	private MapEntryBuilder mapEntryBuilder;
 
 	public ResultTransformer getResultTransformer() {
 		return mapEntryBuilder;
 	}
 
 	private static class MapEntryBuilder extends BasicTransformerAdapter {
 		public Object transformTuple(Object[] tuple, String[] aliases) {
 			if ( tuple.length != 2 ) {
 				throw new HibernateException( "Expecting exactly 2 tuples to transform into Map.Entry" );
 			}
 			return new EntryAdapter( tuple[0], tuple[1] );
 		}
 	}
 
 	private static class EntryAdapter implements Map.Entry {
 		private final Object key;
 		private Object value;
 
 		private EntryAdapter(Object key, Object value) {
 			this.key = key;
 			this.value = value;
 		}
 
 		public Object getValue() {
 			return value;
 		}
 
 		public Object getKey() {
 			return key;
 		}
 
 		public Object setValue(Object value) {
 			Object old = this.value;
 			this.value = value;
 			return old;
 		}
 
 		public boolean equals(Object o) {
 			// IMPL NOTE : nulls are considered equal for keys and values according to Map.Entry contract
 			if ( this == o ) {
 				return true;
 			}
 			if ( o == null || getClass() != o.getClass() ) {
 				return false;
 			}
 			EntryAdapter that = ( EntryAdapter ) o;
 
 			// make sure we have the same types...
 			return ( key == null ? that.key == null : key.equals( that.key ) )
 					&& ( value == null ? that.value == null : value.equals( that.value ) );
 
 		}
 
 		public int hashCode() {
 			int keyHash = key == null ? 0 : key.hashCode();
 			int valueHash = value == null ? 0 : value.hashCode();
 			return keyHash ^ valueHash;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/MapKeyNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/MapKeyNode.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/MapKeyNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/MapKeyNode.java
index 547540813b..966af6d391 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/MapKeyNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/MapKeyNode.java
@@ -1,43 +1,43 @@
 /*
  * Copyright (c) 2009, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.type.Type;
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class MapKeyNode extends AbstractMapComponentNode {
 	protected String expressionDescription() {
 		return "key(*)";
 	}
 
 	protected String[] resolveColumns(QueryableCollection collectionPersister) {
 		return collectionPersister.getIndexColumnNames();
 	}
 
 	protected Type resolveType(QueryableCollection collectionPersister) {
 		return collectionPersister.getIndexType();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/MapValueNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/MapValueNode.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/MapValueNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/MapValueNode.java
index 280a1d7478..d674137504 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/MapValueNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/MapValueNode.java
@@ -1,43 +1,43 @@
 /*
  * Copyright (c) 2009, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.type.Type;
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class MapValueNode extends AbstractMapComponentNode {
 	protected String expressionDescription() {
 		return "value(*)";
 	}
 
 	protected String[] resolveColumns(QueryableCollection collectionPersister) {
 		return collectionPersister.getElementColumnNames();
 	}
 
 	protected Type resolveType(QueryableCollection collectionPersister) {
 		return collectionPersister.getElementType();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/MethodNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/MethodNode.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/MethodNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/MethodNode.java
index 2a4a41fc34..1142161ca9 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/MethodNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/MethodNode.java
@@ -1,244 +1,244 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import java.util.Arrays;
 
+import org.hibernate.hql.internal.CollectionProperties;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.dialect.function.SQLFunction;
-import org.hibernate.hql.CollectionProperties;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.TypeDiscriminatorMetadata;
-import org.hibernate.hql.ast.util.ASTUtil;
-import org.hibernate.hql.ast.util.ColumnHelper;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.TypeDiscriminatorMetadata;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
+import org.hibernate.hql.internal.ast.util.ColumnHelper;
 import org.hibernate.persister.collection.CollectionPropertyNames;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * Represents a method call.
  *
  * @author josh
  */
 public class MethodNode extends AbstractSelectExpression implements FunctionNode {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, MethodNode.class.getName());
 
 	private String methodName;
 	private FromElement fromElement;
 	private String[] selectColumns;
 	private SQLFunction function;
 	private boolean inSelect;
 
 	public void resolve(boolean inSelect) throws SemanticException {
 		// Get the function name node.
 		AST name = getFirstChild();
 		initializeMethodNode( name, inSelect );
 		AST exprList = name.getNextSibling();
 		// If the expression list has exactly one expression, and the type of the expression is a collection
 		// then this might be a collection function, such as index(c) or size(c).
 		if ( ASTUtil.hasExactlyOneChild( exprList ) ) {
 			if ( "type".equals( methodName ) ) {
 				typeDiscriminator( exprList.getFirstChild() );
 				return;
 			}
 			if ( isCollectionPropertyMethod() ) {
 				collectionProperty( exprList.getFirstChild(), name );
 				return;
 			}
 		}
 
 		dialectFunction( exprList );
 	}
 
 	private void typeDiscriminator(AST path) throws SemanticException {
 		if ( path == null ) {
 			throw new SemanticException( "type() discriminator reference has no path!" );
 		}
 
 		FromReferenceNode pathAsFromReferenceNode = (FromReferenceNode) path;
 		FromElement fromElement = pathAsFromReferenceNode.getFromElement();
 		TypeDiscriminatorMetadata typeDiscriminatorMetadata = fromElement.getTypeDiscriminatorMetadata();
 
 		setDataType( typeDiscriminatorMetadata.getResolutionType() );
 		setText( typeDiscriminatorMetadata.getSqlFragment() );
 		setType( SqlTokenTypes.SQL_TOKEN );
 	}
 
 	public SQLFunction getSQLFunction() {
 		return function;
 	}
 
 	public Type getFirstArgumentType() {
 		AST argument = getFirstChild();
 		while ( argument != null ) {
 			if ( argument instanceof SqlNode ) {
 				final Type type = ( (SqlNode) argument ).getDataType();
 				if ( type != null ) {
 					return type;
 				}
 				argument = argument.getNextSibling();
 			}
 		}
 		return null;
 	}
 
 	private void dialectFunction(AST exprList) {
 		function = getSessionFactoryHelper().findSQLFunction( methodName );
 		if ( function != null ) {
 			AST firstChild = exprList != null ? exprList.getFirstChild() : null;
 			Type functionReturnType = getSessionFactoryHelper()
 					.findFunctionReturnType( methodName, firstChild );
 			setDataType( functionReturnType );
 		}
 		//TODO:
 		/*else {
 			methodName = (String) getWalker().getTokenReplacements().get( methodName );
 		}*/
 	}
 
 	public boolean isCollectionPropertyMethod() {
 		return CollectionProperties.isAnyCollectionProperty( methodName );
 	}
 
 	public void initializeMethodNode(AST name, boolean inSelect) {
 		name.setType( SqlTokenTypes.METHOD_NAME );
 		String text = name.getText();
 		methodName = text.toLowerCase();	// Use the lower case function name.
 		this.inSelect = inSelect;			// Remember whether we're in a SELECT clause or not.
 	}
 
 	private String getMethodName() {
 		return methodName;
 	}
 
 	private void collectionProperty(AST path, AST name) throws SemanticException {
 		if ( path == null ) {
 			throw new SemanticException( "Collection function " + name.getText() + " has no path!" );
 		}
 
 		SqlNode expr = ( SqlNode ) path;
 		Type type = expr.getDataType();
         LOG.debugf("collectionProperty() :  name=%s type=%s", name, type);
 
 		resolveCollectionProperty( expr );
 	}
 
 	@Override
     public boolean isScalar() throws SemanticException {
 		// Method expressions in a SELECT should always be considered scalar.
 		return true;
 	}
 
 	public void resolveCollectionProperty(AST expr) throws SemanticException {
 		String propertyName = CollectionProperties.getNormalizedPropertyName( getMethodName() );
 		if ( expr instanceof FromReferenceNode ) {
 			FromReferenceNode collectionNode = ( FromReferenceNode ) expr;
 			// If this is 'elements' then create a new FROM element.
 			if ( CollectionPropertyNames.COLLECTION_ELEMENTS.equals( propertyName ) ) {
 				handleElements( collectionNode, propertyName );
 			}
 			else {
 				// Not elements(x)
 				fromElement = collectionNode.getFromElement();
 				setDataType( fromElement.getPropertyType( propertyName, propertyName ) );
 				selectColumns = fromElement.toColumns( fromElement.getTableAlias(), propertyName, inSelect );
 			}
 			if ( collectionNode instanceof DotNode ) {
 				prepareAnyImplicitJoins( ( DotNode ) collectionNode );
 			}
 			if ( !inSelect ) {
 				fromElement.setText( "" );
 				fromElement.setUseWhereFragment( false );
 			}
 			prepareSelectColumns( selectColumns );
 			setText( selectColumns[0] );
 			setType( SqlTokenTypes.SQL_TOKEN );
 		}
 		else {
 			throw new SemanticException(
 					"Unexpected expression " + expr +
 					" found for collection function " + propertyName
 				);
 		}
 	}
 
 	private void prepareAnyImplicitJoins(DotNode dotNode) throws SemanticException {
 		if ( dotNode.getLhs() instanceof DotNode ) {
 			DotNode lhs = ( DotNode ) dotNode.getLhs();
 			FromElement lhsOrigin = lhs.getFromElement();
 			if ( lhsOrigin != null && "".equals( lhsOrigin.getText() ) ) {
 				String lhsOriginText = lhsOrigin.getQueryable().getTableName() +
 				        " " + lhsOrigin.getTableAlias();
 				lhsOrigin.setText( lhsOriginText );
 			}
 			prepareAnyImplicitJoins( lhs );
 		}
 	}
 
 	private void handleElements(FromReferenceNode collectionNode, String propertyName) {
 		FromElement collectionFromElement = collectionNode.getFromElement();
 		QueryableCollection queryableCollection = collectionFromElement.getQueryableCollection();
 
 		String path = collectionNode.getPath() + "[]." + propertyName;
         LOG.debugf("Creating elements for %s", path);
 
 		fromElement = collectionFromElement;
 		if ( !collectionFromElement.isCollectionOfValuesOrComponents() ) {
 			getWalker().addQuerySpaces( queryableCollection.getElementPersister().getQuerySpaces() );
 		}
 
 		setDataType( queryableCollection.getElementType() );
 		selectColumns = collectionFromElement.toColumns( fromElement.getTableAlias(), propertyName, inSelect );
 	}
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		if ( selectColumns == null ) { 	// Dialect function
 			ColumnHelper.generateSingleScalarColumn( this, i );
 		}
 		else {	// Collection 'property function'
 			ColumnHelper.generateScalarColumns( this, selectColumns, i );
 		}
 	}
 
 	protected void prepareSelectColumns(String[] columns) {
 	}
 
 	@Override
     public FromElement getFromElement() {
 		return fromElement;
 	}
 
 	public String getDisplayText() {
 		return "{" +
 				"method=" + getMethodName() +
 				",selectColumns=" + ( selectColumns == null ?
 						null : Arrays.asList( selectColumns ) ) +
 				",fromElement=" + fromElement.getTableAlias() +
 				"}";
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/Node.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/Node.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/Node.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/Node.java
index b60ce9fa0c..ac9768e09b 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/Node.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/Node.java
@@ -1,102 +1,102 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.util.StringHelper;
 import antlr.Token;
 import antlr.collections.AST;
 
 /**
  * Base node class for use by Hibernate within its AST trees.
  *
  * @author Joshua Davis
  * @author Steve Ebersole
  */
 public class Node extends antlr.CommonAST {
 	private String filename;
 	private int line;
 	private int column;
 	private int textLength;
 
 	public Node() {
 		super();
 	}
 
 	public Node(Token tok) {
 		super(tok);  // This will call initialize(tok)!
 	}
 
 	/**
 	 * Retrieve the text to be used for rendering this particular node.
 	 *
 	 * @param sessionFactory The session factory
 	 * @return The text to use for rendering
 	 */
 	public String getRenderText(SessionFactoryImplementor sessionFactory) {
 		// The basic implementation is to simply use the node's text
 		return getText();
 	}
 
 	@Override
     public void initialize(Token tok) {
 		super.initialize(tok);
 		filename = tok.getFilename();
 		line = tok.getLine();
 		column = tok.getColumn();
 		String text = tok.getText();
 		textLength = StringHelper.isEmpty(text) ? 0 : text.length();
 	}
 
 	@Override
     public void initialize(AST t) {
 		super.initialize( t );
 		if ( t instanceof Node ) {
 			Node n = (Node)t;
 			filename = n.filename;
 			line = n.line;
 			column = n.column;
 			textLength = n.textLength;
 		}
 	}
 
 	public String getFilename() {
 		return filename;
 	}
 
 	@Override
     public int getLine() {
 		return line;
 	}
 
 	@Override
     public int getColumn() {
 		return column;
 	}
 
 	public int getTextLength() {
 		return textLength;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/OperatorNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/OperatorNode.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/OperatorNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/OperatorNode.java
index 8cae87f43a..6ac5bef6bd 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/OperatorNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/OperatorNode.java
@@ -1,47 +1,47 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.type.Type;
 import antlr.SemanticException;
 
 /**
  * Contract for nodes representing operators (logic or arithmetic).
  *
  * @author Steve Ebersole
  */
 public interface OperatorNode {
 	/**
 	 * Called by the tree walker during hql-sql semantic analysis
 	 * after the operator sub-tree is completely built.
 	 */
 	public abstract void initialize() throws SemanticException;
 
 	/**
 	 * Retrieves the data type for the overall operator expression.
 	 *
 	 * @return The expression's data type.
 	 */
 	public Type getDataType();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/OrderByClause.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/OrderByClause.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/OrderByClause.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/OrderByClause.java
index 9265e0de5a..3dcd1e8dab 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/OrderByClause.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/OrderByClause.java
@@ -1,47 +1,47 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.ast.util.ASTUtil;
+package org.hibernate.hql.internal.ast.tree;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
 import antlr.collections.AST;
 
 /**
  * Implementation of OrderByClause.
  *
  * @author Steve Ebersole
  */
 public class OrderByClause extends HqlSqlWalkerNode implements HqlSqlTokenTypes {
 
 	public void addOrderFragment(String orderByFragment) {
 		AST fragment = ASTUtil.create( getASTFactory(), SQL_TOKEN, orderByFragment );
 		if ( getFirstChild() == null ) {
             setFirstChild( fragment );
 		}
 		else {
 			addChild( fragment );
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ParameterContainer.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ParameterContainer.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ParameterContainer.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ParameterContainer.java
index 397e45fb3e..f75443b470 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ParameterContainer.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ParameterContainer.java
@@ -1,76 +1,76 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.param.ParameterSpecification;
 
 /**
  * Currently this is needed in order to deal with {@link FromElement FromElements} which
  * contain "hidden" JDBC parameters from applying filters.
  * <p/>
  * Would love for this to go away, but that would require that Hibernate's
  * internal {@link org.hibernate.engine.internal.JoinSequence join handling} be able to either:<ul>
  * <li>render the same AST structures</li>
  * <li>render structures capable of being converted to these AST structures</li>
  * </ul>
  * <p/>
  * In the interim, this allows us to at least treat these "hidden" parameters properly which is
  * the most pressing need.
  *
  * @deprecated
  * @author Steve Ebersole
  */
 public interface ParameterContainer {
 	/**
 	 * Set the renderable text of this node.
 	 *
 	 * @param text The renderable text
 	 */
 	public void setText(String text);
 
 	/**
 	 * Adds a parameter specification for a parameter encountered within this node.  We use the term 'embedded' here
 	 * because of the fact that the parameter was simply encountered as part of the node's text; it does not exist
 	 * as part of a subtree as it might in a true AST.
 	 *
 	 * @param specification The generated specification.
 	 */
 	public void addEmbeddedParameter(ParameterSpecification specification);
 
 	/**
 	 * Determine whether this node contains embedded parameters.  The implication is that
 	 * {@link #getEmbeddedParameters()} is allowed to return null if this method returns false.
 	 *
 	 * @return True if this node contains embedded parameters; false otherwise.
 	 */
 	public boolean hasEmbeddedParameters();
 
 	/**
 	 * Retrieve all embedded parameter specifications.
 	 *
 	 * @return All embedded parameter specifications; may return null.
 	 * @see #hasEmbeddedParameters()
 	 */
 	public ParameterSpecification[] getEmbeddedParameters();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ParameterNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ParameterNode.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ParameterNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ParameterNode.java
index fa4123647a..d18cd03de0 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ParameterNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ParameterNode.java
@@ -1,74 +1,74 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.type.Type;
 
 /**
  * Implementation of ParameterNode.
  *
  * @author Steve Ebersole
  */
 public class ParameterNode extends HqlSqlWalkerNode implements DisplayableNode, ExpectedTypeAwareNode {
 	private ParameterSpecification parameterSpecification;
 
 	public ParameterSpecification getHqlParameterSpecification() {
 		return parameterSpecification;
 	}
 
 	public void setHqlParameterSpecification(ParameterSpecification parameterSpecification) {
 		this.parameterSpecification = parameterSpecification;
 	}
 
 	public String getDisplayText() {
 		return "{" + ( parameterSpecification == null ? "???" : parameterSpecification.renderDisplayInfo() ) + "}";
 	}
 
 	public void setExpectedType(Type expectedType) {
 		getHqlParameterSpecification().setExpectedType( expectedType );
 		setDataType( expectedType );
 	}
 
 	public Type getExpectedType() {
 		return getHqlParameterSpecification() == null ? null : getHqlParameterSpecification().getExpectedType();
 	}
 
 	public String getRenderText(SessionFactoryImplementor sessionFactory) {
 		int count = 0;
 		if ( getExpectedType() != null && ( count = getExpectedType().getColumnSpan( sessionFactory ) ) > 1 ) {
 			StringBuffer buffer = new StringBuffer();
 			buffer.append( "(?" );
 			for ( int i = 1; i < count; i++ ) {
 				buffer.append( ", ?" );
 			}
 			buffer.append( ")" );
 			return buffer.toString();
 		}
 		else {
 			return "?";
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/PathNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/PathNode.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/PathNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/PathNode.java
index 38400d3a6d..b77d1202dc 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/PathNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/PathNode.java
@@ -1,40 +1,40 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 
 /**
  * An AST node with a path property.  This path property will be the fully qualified name.
  *
  * @author josh
  */
 public interface PathNode {
 	/**
 	 * Returns the full path name represented by the node.
 	 *
 	 * @return the full path name represented by the node.
 	 */
 	String getPath();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/QueryNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/QueryNode.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/QueryNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/QueryNode.java
index 514ca04d0d..7ec6b8d80d 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/QueryNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/QueryNode.java
@@ -1,166 +1,166 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.util.ASTUtil;
-import org.hibernate.hql.ast.util.ColumnHelper;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
+import org.hibernate.hql.internal.ast.util.ColumnHelper;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * Defines a top-level AST node representing an HQL select statement.
  *
  * @author Joshua Davis
  */
 public class QueryNode extends AbstractRestrictableStatement implements SelectExpression {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, QueryNode.class.getName());
 
 	private OrderByClause orderByClause;
 	private int scalarColumnIndex = -1;
 
 	/**
 	 * @see Statement#getStatementType()
 	 */
 	public int getStatementType() {
 		return HqlSqlTokenTypes.QUERY;
 	}
 
 	/**
 	 * @see Statement#needsExecutor()
 	 */
 	public boolean needsExecutor() {
 		return false;
 	}
 
 	@Override
     protected int getWhereClauseParentTokenType() {
 		return SqlTokenTypes.FROM;
 	}
 
 	@Override
     protected CoreMessageLogger getLog() {
         return LOG;
 	}
 
 	/**
 	 * Locate the select clause that is part of this select statement.
 	 * </p>
 	 * Note, that this might return null as derived select clauses (i.e., no
 	 * select clause at the HQL-level) get generated much later than when we
 	 * get created; thus it depends upon lifecycle.
 	 *
 	 * @return Our select clause, or null.
 	 */
 	public final SelectClause getSelectClause() {
 		// Due to the complexity in initializing the SelectClause, do not generate one here.
 		// If it is not found; simply return null...
 		//
 		// Also, do not cache since it gets generated well after we are created.
 		return ( SelectClause ) ASTUtil.findTypeInChildren( this, SqlTokenTypes.SELECT_CLAUSE );
 	}
 
 	public final boolean hasOrderByClause() {
 		OrderByClause orderByClause = locateOrderByClause();
 		return orderByClause != null && orderByClause.getNumberOfChildren() > 0;
 	}
 
 	public final OrderByClause getOrderByClause() {
 		if ( orderByClause == null ) {
 			orderByClause = locateOrderByClause();
 
 			// if there is no order by, make one
 			if ( orderByClause == null ) {
                 LOG.debugf("getOrderByClause() : Creating a new ORDER BY clause");
 				orderByClause = ( OrderByClause ) ASTUtil.create( getWalker().getASTFactory(), SqlTokenTypes.ORDER, "ORDER" );
 
 				// Find the WHERE; if there is no WHERE, find the FROM...
 				AST prevSibling = ASTUtil.findTypeInChildren( this, SqlTokenTypes.WHERE );
 				if ( prevSibling == null ) {
 					prevSibling = ASTUtil.findTypeInChildren( this, SqlTokenTypes.FROM );
 				}
 
 				// Now, inject the newly built ORDER BY into the tree
 				orderByClause.setNextSibling( prevSibling.getNextSibling() );
 				prevSibling.setNextSibling( orderByClause );
 			}
 		}
 		return orderByClause;
 	}
 
 	private OrderByClause locateOrderByClause() {
 		return ( OrderByClause ) ASTUtil.findTypeInChildren( this, SqlTokenTypes.ORDER );
 	}
 
 
 	private String alias;
 
 	public String getAlias() {
 		return alias;
 	}
 
 	public FromElement getFromElement() {
 		return null;
 	}
 
 	public boolean isConstructor() {
 		return false;
 	}
 
 	public boolean isReturnableEntity() throws SemanticException {
 		return false;
 	}
 
 	public boolean isScalar() throws SemanticException {
 		return true;
 	}
 
 	public void setAlias(String alias) {
 		this.alias = alias;
 	}
 
 	public void setScalarColumn(int i) throws SemanticException {
 		scalarColumnIndex = i;
 		setScalarColumnText( i );
 	}
 
 	public int getScalarColumnIndex() {
 		return scalarColumnIndex;
 	}
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		ColumnHelper.generateSingleScalarColumn( this, i );
 	}
 
 	@Override
     public Type getDataType() {
 		return ( (SelectExpression) getSelectClause().getFirstSelectExpression() ).getDataType();
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ResolvableNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ResolvableNode.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ResolvableNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ResolvableNode.java
index 12d9d28b14..51f59ac4c1 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ResolvableNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ResolvableNode.java
@@ -1,60 +1,60 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * The contract for expression sub-trees that can resolve themselves.
  *
  * @author josh
  */
 public interface ResolvableNode {
 	/**
 	 * Does the work of resolving an identifier or a dot
 	 */
 	void resolve(boolean generateJoin, boolean implicitJoin, String classAlias, AST parent) throws SemanticException;
 
 	/**
 	 * Does the work of resolving an identifier or a dot, but without a parent node
 	 */
 	void resolve(boolean generateJoin, boolean implicitJoin, String classAlias) throws SemanticException;
 
 	/**
 	 * Does the work of resolving an identifier or a dot, but without a parent node or alias
 	 */
 	void resolve(boolean generateJoin, boolean implicitJoin) throws SemanticException;
 
 	/**
 	 * Does the work of resolving inside of the scope of a function call
 	 */
 	void resolveInFunctionCall(boolean generateJoin, boolean implicitJoin) throws SemanticException;
 
 	/**
 	 * Does the work of resolving an an index [].
 	 */
 	void resolveIndex(AST parent) throws SemanticException;
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/RestrictableStatement.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/RestrictableStatement.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/RestrictableStatement.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/RestrictableStatement.java
index e7e0c8e876..2724d222e0 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/RestrictableStatement.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/RestrictableStatement.java
@@ -1,63 +1,63 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import antlr.collections.AST;
 
 /**
  * Type definition for Statements which are restrictable via a where-clause (and
  * thus also having a from-clause).
  *
  * @author Steve Ebersole
  */
 public interface RestrictableStatement extends Statement {
 	/**
 	 * Retreives the from-clause in effect for this statement.
 	 *
 	 * @return The from-clause for this statement; could be null if the from-clause
 	 * has not yet been parsed/generated.
 	 */
 	public FromClause getFromClause();
 
 	/**
 	 * Does this statement tree currently contain a where clause?
 	 *
 	 * @return True if a where-clause is found in the statement tree and
 	 * that where clause actually defines restrictions; false otherwise.
 	 */
 	public boolean hasWhereClause();
 
 	/**
 	 * Retreives the where-clause defining the restriction(s) in effect for
 	 * this statement.
 	 * <p/>
 	 * Note that this will generate a where-clause if one was not found, so caution
 	 * needs to taken prior to calling this that restrictions will actually exist
 	 * in the resulting statement tree (otherwise "unexpected end of subtree" errors
 	 * might occur during rendering).
 	 *
 	 * @return The where clause.
 	 */
 	public AST getWhereClause();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ResultVariableRefNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ResultVariableRefNode.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ResultVariableRefNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ResultVariableRefNode.java
index 047f6485f2..ccee13196e 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/ResultVariableRefNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/ResultVariableRefNode.java
@@ -1,93 +1,93 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.util.StringHelper;
 import antlr.SemanticException;
 
 /**
  * Represents a reference to a result_variable as defined in the JPA 2 spec.
  * For example:
  * <code>
  * select v as value from tab1 order by value
  * </code>
  * <p/>
  * "value" used in the order by clause is a reference to the
  * result_variable, "value", defined in the select clause.
  *
  * @author Gail Badner
  */
 public class ResultVariableRefNode extends HqlSqlWalkerNode {
 	private SelectExpression selectExpression;
 
 	/**
 	 * Set the select expression that defines the result variable.
 	 *
 	 * @param selectExpression the select expression;
 	 *        selectExpression.getAlias() must be non-null
 	 * @throws SemanticException if selectExpression or
 	 *         selectExpression.getAlias() is null.
 	 */
 	public void setSelectExpression(SelectExpression selectExpression) throws SemanticException {
 		if ( selectExpression == null || selectExpression.getAlias() == null ) {
 			throw new SemanticException( "A ResultVariableRefNode must refer to a non-null alias." );
 		}
 		this.selectExpression = selectExpression;
 	}
 
 	/**
 	 *  {@inheritDoc}
 	 */
 	@Override
     public String getRenderText(SessionFactoryImplementor sessionFactory) {
 		int scalarColumnIndex = selectExpression.getScalarColumnIndex();
 		if ( scalarColumnIndex < 0 ) {
 			throw new IllegalStateException(
 					"selectExpression.getScalarColumnIndex() must be >= 0; actual = " + scalarColumnIndex
 			);
 		}
 		return sessionFactory.getDialect().replaceResultVariableInOrderByClauseWithPosition() ?
 			getColumnPositionsString( scalarColumnIndex ) :
 			getColumnNamesString( scalarColumnIndex );
 
 	}
 
 	private String getColumnPositionsString(int scalarColumnIndex ) {
 		int startPosition = getWalker().getSelectClause().getColumnNamesStartPosition( scalarColumnIndex );
 		StringBuffer buf = new StringBuffer();
 		int nColumns = getWalker().getSelectClause().getColumnNames()[ scalarColumnIndex ].length;
 		for ( int i = startPosition; i < startPosition + nColumns; i++ ) {
 			if ( i > startPosition ) {
 				buf.append( ", " );
 			}
 			buf.append( i );
 		}
 		return buf.toString();
 	}
 
 	private String getColumnNamesString(int scalarColumnIndex) {
 		return StringHelper.join( ", ", getWalker().getSelectClause().getColumnNames()[scalarColumnIndex] );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SelectClause.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SelectClause.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SelectClause.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SelectClause.java
index 9d710b4512..33591a9694 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SelectClause.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SelectClause.java
@@ -1,456 +1,456 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import org.hibernate.QueryException;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.util.ASTAppender;
-import org.hibernate.hql.ast.util.ASTIterator;
-import org.hibernate.hql.ast.util.ASTPrinter;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.util.ASTAppender;
+import org.hibernate.hql.internal.ast.util.ASTIterator;
+import org.hibernate.hql.internal.ast.util.ASTPrinter;
 import org.hibernate.type.Type;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * Represents the list of expressions in a SELECT clause.
  *
  * @author josh
  */
 public class SelectClause extends SelectExpressionList {
 
 	private boolean prepared = false;
 	private boolean scalarSelect;
 
 	private List fromElementsForLoad = new ArrayList();
 	//private Type[] sqlResultTypes;
 	private Type[] queryReturnTypes;
 	private String[][] columnNames;
 	private List collectionFromElements;
 	private String[] aliases;
 	private int[] columnNamesStartPositions;
 
 	// Currently we can only have one...
 	private AggregatedSelectExpression aggregatedSelectExpression;
 
 	/**
 	 * Does this SelectClause represent a scalar query
 	 *
 	 * @return True if this is a scalara select clause; false otherwise.
 	 */
 	public boolean isScalarSelect() {
 		return scalarSelect;
 	}
 
 	public boolean isDistinct() {
 		return getFirstChild() != null && getFirstChild().getType() == SqlTokenTypes.DISTINCT;
 	}
 
 	/**
 	 * FromElements which need to be accounted for in the load phase (either for return or for fetch).
 	 *
 	 * @return List of appropriate FromElements.
 	 */
 	public List getFromElementsForLoad() {
 		return fromElementsForLoad;
 	}
 
 	/*
 	 * The types represented in the SQL result set.
 	 *
 	 * @return The types represented in the SQL result set.
 	 */
 	/*public Type[] getSqlResultTypes() {
 		return sqlResultTypes;
 	}*/
 
 	/**
 	 * The types actually being returned from this query at the "object level".
 	 *
 	 * @return The query return types.
 	 */
 	public Type[] getQueryReturnTypes() {
 		return queryReturnTypes;
 	}
 	
 	/**
 	 * The HQL aliases, or generated aliases
 	 *
 	 * @return the aliases
 	 */
 	public String[] getQueryReturnAliases() {
 		return aliases;
 	}
 
 	/**
 	 * The column alias names being used in the generated SQL.
 	 *
 	 * @return The SQL column aliases.
 	 */
 	public String[][] getColumnNames() {
 		return columnNames;
 	}
 
 	public AggregatedSelectExpression getAggregatedSelectExpression() {
 		return aggregatedSelectExpression;
 	}
 
 	/**
 	 * Prepares an explicitly defined select clause.
 	 *
 	 * @param fromClause The from clause linked to this select clause.
 	 * @throws SemanticException indicates a semntic issue with the explicit select clause.
 	 */
 	public void initializeExplicitSelectClause(FromClause fromClause) throws SemanticException {
 		if ( prepared ) {
 			throw new IllegalStateException( "SelectClause was already prepared!" );
 		}
 
 		//explicit = true;	// This is an explict Select.
 		//ArrayList sqlResultTypeList = new ArrayList();
 		ArrayList queryReturnTypeList = new ArrayList();
 
 		// First, collect all of the select expressions.
 		// NOTE: This must be done *before* invoking setScalarColumnText() because setScalarColumnText()
 		// changes the AST!!!
 		SelectExpression[] selectExpressions = collectSelectExpressions();
 		
 		for ( int i = 0; i < selectExpressions.length; i++ ) {
 			SelectExpression selectExpression = selectExpressions[i];
 
 			if ( AggregatedSelectExpression.class.isInstance( selectExpression ) ) {
 				aggregatedSelectExpression = (AggregatedSelectExpression) selectExpression;
 				queryReturnTypeList.addAll( aggregatedSelectExpression.getAggregatedSelectionTypeList() );
 				scalarSelect = true;
 			}
 			else {
 				Type type = selectExpression.getDataType();
 				if ( type == null ) {
 					throw new IllegalStateException( "No data type for node: " + selectExpression.getClass().getName() + " "
 							+ new ASTPrinter( SqlTokenTypes.class ).showAsString( ( AST ) selectExpression, "" ) );
 				}
 				//sqlResultTypeList.add( type );
 
 				// If the data type is not an association type, it could not have been in the FROM clause.
 				if ( selectExpression.isScalar() ) {
 					scalarSelect = true;
 				}
 
 				if ( isReturnableEntity( selectExpression ) ) {
 					fromElementsForLoad.add( selectExpression.getFromElement() );
 				}
 
 				// Always add the type to the return type list.
 				queryReturnTypeList.add( type );
 			}
 		}
 
 		//init the aliases, after initing the constructornode
 		initAliases(selectExpressions);
 
 		if ( !getWalker().isShallowQuery() ) {
 			// add the fetched entities
 			List fromElements = fromClause.getProjectionList();
 	
 			ASTAppender appender = new ASTAppender( getASTFactory(), this );	// Get ready to start adding nodes.
 			int size = fromElements.size();
 	
 			Iterator iterator = fromElements.iterator();
 			for ( int k = 0; iterator.hasNext(); k++ ) {
 				FromElement fromElement = ( FromElement ) iterator.next();
 	
 				if ( fromElement.isFetch() ) {
 					FromElement origin = null;
 					if ( fromElement.getRealOrigin() == null ) {
 						// work around that crazy issue where the tree contains
 						// "empty" FromElements (no text); afaict, this is caused
 						// by FromElementFactory.createCollectionJoin()
 						if ( fromElement.getOrigin() == null ) {
 							throw new QueryException( "Unable to determine origin of join fetch [" + fromElement.getDisplayText() + "]" );
 						}
 						else {
 							origin = fromElement.getOrigin();
 						}
 					}
 					else {
 						origin = fromElement.getRealOrigin();
 					}
 					if ( !fromElementsForLoad.contains( origin ) ) {
 						throw new QueryException(
 								"query specified join fetching, but the owner " +
 								"of the fetched association was not present in the select list " +
 								"[" + fromElement.getDisplayText() + "]"
 						);
 					}
 					Type type = fromElement.getSelectType();
 					addCollectionFromElement( fromElement );
 					if ( type != null ) {
 						boolean collectionOfElements = fromElement.isCollectionOfValuesOrComponents();
 						if ( !collectionOfElements ) {
 							// Add the type to the list of returned sqlResultTypes.
 							fromElement.setIncludeSubclasses( true );
 							fromElementsForLoad.add( fromElement );
 							//sqlResultTypeList.add( type );
 							// Generate the select expression.
 							String text = fromElement.renderIdentifierSelect( size, k );
 							SelectExpressionImpl generatedExpr = ( SelectExpressionImpl ) appender.append( SqlTokenTypes.SELECT_EXPR, text, false );
 							if ( generatedExpr != null ) {
 								generatedExpr.setFromElement( fromElement );
 							}
 						}
 					}
 				}
 			}
 	
 			// generate id select fragment and then property select fragment for
 			// each expression, just like generateSelectFragments().
 			renderNonScalarSelects( collectSelectExpressions(), fromClause );
 		}
 
 		if ( scalarSelect || getWalker().isShallowQuery() ) {
 			// If there are any scalars (non-entities) selected, render the select column aliases.
 			renderScalarSelects( selectExpressions, fromClause );
 		}
 
 		finishInitialization( /*sqlResultTypeList,*/ queryReturnTypeList );
 	}
 
 	private void finishInitialization(ArrayList queryReturnTypeList) {
 		queryReturnTypes = ( Type[] ) queryReturnTypeList.toArray( new Type[queryReturnTypeList.size()] );
 		initializeColumnNames();
 		prepared = true;
 	}
 
 	private void initializeColumnNames() {
 		// Generate an 2d array of column names, the first dimension is parallel with the
 		// return types array.  The second dimension is the list of column names for each
 		// type.
 
 		// todo: we should really just collect these from the various SelectExpressions, rather than regenerating here
 		columnNames = getSessionFactoryHelper().generateColumnNames( queryReturnTypes );
 		columnNamesStartPositions = new int[ columnNames.length ];
 		int startPosition = 1;
 		for ( int i = 0 ; i < columnNames.length ; i ++ ) {
 			columnNamesStartPositions[ i ] = startPosition;
 			startPosition += columnNames[ i ].length;
 		}
 	}
 
 	public int getColumnNamesStartPosition(int i) {
 		return columnNamesStartPositions[ i ];
 	}
 
 	/**
 	 * Prepares a derived (i.e., not explicitly defined in the query) select clause.
 	 *
 	 * @param fromClause The from clause to which this select clause is linked.
 	 */
 	public void initializeDerivedSelectClause(FromClause fromClause) throws SemanticException {
 		if ( prepared ) {
 			throw new IllegalStateException( "SelectClause was already prepared!" );
 		}
 		//Used to be tested by the TCK but the test is no longer here
 //		if ( getSessionFactoryHelper().isStrictJPAQLComplianceEnabled() && !getWalker().isSubQuery() ) {
 //			// NOTE : the isSubQuery() bit is a temporary hack...
 //			throw new QuerySyntaxException( "JPA-QL compliance requires select clause" );
 //		}
 		List fromElements = fromClause.getProjectionList();
 
 		ASTAppender appender = new ASTAppender( getASTFactory(), this );	// Get ready to start adding nodes.
 		int size = fromElements.size();
 		ArrayList queryReturnTypeList = new ArrayList( size );
 
 		Iterator iterator = fromElements.iterator();
 		for ( int k = 0; iterator.hasNext(); k++ ) {
 			FromElement fromElement = ( FromElement ) iterator.next();
 			Type type = fromElement.getSelectType();
 
 			addCollectionFromElement( fromElement );
 
 			if ( type != null ) {
 				boolean collectionOfElements = fromElement.isCollectionOfValuesOrComponents();
 				if ( !collectionOfElements ) {
 					if ( !fromElement.isFetch() ) {
 						// Add the type to the list of returned sqlResultTypes.
 						queryReturnTypeList.add( type );
 					}
 					fromElementsForLoad.add( fromElement );
 					// Generate the select expression.
 					String text = fromElement.renderIdentifierSelect( size, k );
 					SelectExpressionImpl generatedExpr = ( SelectExpressionImpl ) appender.append( SqlTokenTypes.SELECT_EXPR, text, false );
 					if ( generatedExpr != null ) {
 						generatedExpr.setFromElement( fromElement );
 					}
 				}
 			}
 		}
 
 		// Get all the select expressions (that we just generated) and render the select.
 		SelectExpression[] selectExpressions = collectSelectExpressions();
 
 		if ( getWalker().isShallowQuery() ) {
 			renderScalarSelects( selectExpressions, fromClause );
 		}
 		else {
 			renderNonScalarSelects( selectExpressions, fromClause );
 		}
 		finishInitialization( queryReturnTypeList );
 	}
 	
 	public static boolean VERSION2_SQL = false;
 
 	private void addCollectionFromElement(FromElement fromElement) {
 		if ( fromElement.isFetch() ) {
 			if ( fromElement.isCollectionJoin() || fromElement.getQueryableCollection() != null ) {
 				String suffix;
 				if (collectionFromElements==null) {
 					collectionFromElements = new ArrayList();
 					suffix = VERSION2_SQL ? "__" : "0__";
 				}
 				else {
 					suffix = Integer.toString( collectionFromElements.size() ) + "__";
 				}
 				collectionFromElements.add( fromElement );
 				fromElement.setCollectionSuffix( suffix );
 			}
 		}
 	}
 
 	protected AST getFirstSelectExpression() {
 		AST n = getFirstChild();
 		// Skip 'DISTINCT' and 'ALL', so we return the first expression node.
 		while ( n != null && ( n.getType() == SqlTokenTypes.DISTINCT || n.getType() == SqlTokenTypes.ALL ) ) {
 			n = n.getNextSibling();
 		}
 		return n;
 	}
 
 	private boolean isReturnableEntity(SelectExpression selectExpression) throws SemanticException {
 		FromElement fromElement = selectExpression.getFromElement();
 		boolean isFetchOrValueCollection = fromElement != null && 
 				( fromElement.isFetch() || fromElement.isCollectionOfValuesOrComponents() );
 		if ( isFetchOrValueCollection ) {
 			return false;
 		}
 		else {
 			return selectExpression.isReturnableEntity();
 		}
 	}
 
 	private void renderScalarSelects(SelectExpression[] se, FromClause currentFromClause) throws SemanticException {
 		if ( !currentFromClause.isSubQuery() ) {
 			for ( int i = 0; i < se.length; i++ ) {
 				SelectExpression expr = se[i];
 				expr.setScalarColumn( i );	// Create SQL_TOKEN nodes for the columns.
 			}
 		}
 	}
 	
 	private void initAliases(SelectExpression[] selectExpressions) {
 		if ( aggregatedSelectExpression == null ) {
 			aliases = new String[selectExpressions.length];
 			for ( int i=0; i<selectExpressions.length; i++ ) {
 				String alias = selectExpressions[i].getAlias();
 				aliases[i] = alias==null ? Integer.toString(i) : alias;
 			}
 		}
 		else {
 			aliases = aggregatedSelectExpression.getAggregatedAliases();
 		}
 	}
 
 	private void renderNonScalarSelects(SelectExpression[] selectExpressions, FromClause currentFromClause) 
 	throws SemanticException {
 		ASTAppender appender = new ASTAppender( getASTFactory(), this );
 		final int size = selectExpressions.length;
 		int nonscalarSize = 0;
 		for ( int i = 0; i < size; i++ ) {
 			if ( !selectExpressions[i].isScalar() ) nonscalarSize++;
 		}
 
 		int j = 0;
 		for ( int i = 0; i < size; i++ ) {
 			if ( !selectExpressions[i].isScalar() ) {
 				SelectExpression expr = selectExpressions[i];
 				FromElement fromElement = expr.getFromElement();
 				if ( fromElement != null ) {
 					renderNonScalarIdentifiers( fromElement, nonscalarSize, j, expr, appender );
 					j++;
 				}
 			}
 		}
 
 		if ( !currentFromClause.isSubQuery() ) {
 			// Generate the property select tokens.
 			int k = 0;
 			for ( int i = 0; i < size; i++ ) {
 				if ( !selectExpressions[i].isScalar() ) {
 					FromElement fromElement = selectExpressions[i].getFromElement();
 					if ( fromElement != null ) {
 						renderNonScalarProperties( appender, fromElement, nonscalarSize, k );
 						k++;
 					}
 				}
 			}
 		}
 	}
 
 	private void renderNonScalarIdentifiers(FromElement fromElement, int nonscalarSize, int j, SelectExpression expr, ASTAppender appender) {
 		String text = fromElement.renderIdentifierSelect( nonscalarSize, j );
 		if ( !fromElement.getFromClause().isSubQuery() ) {
 			if ( !scalarSelect && !getWalker().isShallowQuery() ) {
 				//TODO: is this a bit ugly?
 				expr.setText( text );
 			}
 			else {
 				appender.append( SqlTokenTypes.SQL_TOKEN, text, false );
 			}
 		}
 	}
 
 	private void renderNonScalarProperties(ASTAppender appender, FromElement fromElement, int nonscalarSize, int k) {
 		String text = fromElement.renderPropertySelect( nonscalarSize, k );
 		appender.append( SqlTokenTypes.SQL_TOKEN, text, false );
 		if ( fromElement.getQueryableCollection() != null && fromElement.isFetch() ) {
 			text = fromElement.renderCollectionSelectFragment( nonscalarSize, k );
 			appender.append( SqlTokenTypes.SQL_TOKEN, text, false );
 		}
 		// Look through the FromElement's children to find any collections of values that should be fetched...
 		ASTIterator iter = new ASTIterator( fromElement );
 		while ( iter.hasNext() ) {
 			FromElement child = ( FromElement ) iter.next();
 			if ( child.isCollectionOfValuesOrComponents() && child.isFetch() ) {
 				// Need a better way to define the suffixes here...
 				text = child.renderValueCollectionSelectFragment( nonscalarSize, nonscalarSize + k );
 				appender.append( SqlTokenTypes.SQL_TOKEN, text, false );
 			}
 		}
 	}
 
 	public List getCollectionFromElements() {
 		return collectionFromElements;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SelectExpression.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SelectExpression.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SelectExpression.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SelectExpression.java
index 0bb0cbf1bd..187b8f2c0b 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SelectExpression.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SelectExpression.java
@@ -1,97 +1,97 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.type.Type;
 import antlr.SemanticException;
 
 /**
  * Represents an element of a projection list, i.e. a select expression.
  *
  * @author josh
  */
 public interface SelectExpression {
 	/**
 	 * Returns the data type of the select expression.
 	 *
 	 * @return The data type of the select expression.
 	 */
 	Type getDataType();
 
 	/**
 	 * Appends AST nodes that represent the columns after the current AST node.
 	 * (e.g. 'as col0_O_')
 	 *
 	 * @param i The index of the select expression in the projection list.
 	 */
 	void setScalarColumnText(int i) throws SemanticException;
 
 	/**
 	 * Sets the index and text for select expression in the projection list.
 	 *  
 	 * @param i The index of the select expression in the projection list.
 	 * @throws SemanticException
 	 */
 	void setScalarColumn(int i) throws SemanticException;
 
 	/**
 	 * Gets index of the select expression in the projection list.
 	 *
 	 * @returns The index of the select expression in the projection list.
 	 */
 	int getScalarColumnIndex();
 	
 	/**
 	 * Returns the FROM element that this expression refers to.
 	 *
 	 * @return The FROM element.
 	 */
 	FromElement getFromElement();
 
 	/**
 	 * Returns true if the element is a constructor (e.g. new Foo).
 	 *
 	 * @return true if the element is a constructor (e.g. new Foo).
 	 */
 	boolean isConstructor();
 
 	/**
 	 * Returns true if this select expression represents an entity that can be returned.
 	 *
 	 * @return true if this select expression represents an entity that can be returned.
 	 */
 	boolean isReturnableEntity() throws SemanticException;
 
 	/**
 	 * Sets the text of the node.
 	 *
 	 * @param text the new node text.
 	 */
 	void setText(String text);
 
 	boolean isScalar() throws SemanticException;
 	
 	void setAlias(String alias);
 	String getAlias();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SelectExpressionImpl.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SelectExpressionImpl.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SelectExpressionImpl.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SelectExpressionImpl.java
index 612fbb792a..8e26d3fcc5 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SelectExpressionImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SelectExpressionImpl.java
@@ -1,49 +1,49 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * A select expression that was generated by a FROM element.
  *
  * @author josh
  */
 public class SelectExpressionImpl extends FromReferenceNode implements SelectExpression {
 
 	public void resolveIndex(AST parent) throws SemanticException {
 		throw new UnsupportedOperationException();
 	}
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		String text = getFromElement().renderScalarIdentifierSelect( i );
 		setText( text );
 	}
 
 	public void resolve(boolean generateJoin, boolean implicitJoin, String classAlias, AST parent) throws SemanticException {
 		// Generated select expressions are already resolved, nothing to do.
 		return;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SelectExpressionList.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SelectExpressionList.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SelectExpressionList.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SelectExpressionList.java
index d7079cabf7..0a164b4cc0 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SelectExpressionList.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SelectExpressionList.java
@@ -1,68 +1,68 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import java.util.ArrayList;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.util.ASTPrinter;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.util.ASTPrinter;
 import antlr.collections.AST;
 
 /**
  * Common behavior - a node that contains a list of select expressions.
  *
  * @author josh
  */
 public abstract class SelectExpressionList extends HqlSqlWalkerNode {
 	/**
 	 * Returns an array of SelectExpressions gathered from the children of the given parent AST node.
 	 *
 	 * @return an array of SelectExpressions gathered from the children of the given parent AST node.
 	 */
 	public SelectExpression[] collectSelectExpressions() {
 		// Get the first child to be considered.  Sub-classes may do this differently in order to skip nodes that
 		// are not select expressions (e.g. DISTINCT).
 		AST firstChild = getFirstSelectExpression();
 		AST parent = this;
 		ArrayList list = new ArrayList( parent.getNumberOfChildren() );
 		for ( AST n = firstChild; n != null; n = n.getNextSibling() ) {
 			if ( n instanceof SelectExpression ) {
 				list.add( n );
 			}
 			else {
 				throw new IllegalStateException( "Unexpected AST: " + n.getClass().getName() + " " + new ASTPrinter( SqlTokenTypes.class ).showAsString( n, "" ) );
 			}
 		}
 		return ( SelectExpression[] ) list.toArray( new SelectExpression[list.size()] );
 	}
 
 	/**
 	 * Returns the first select expression node that should be considered when building the array of select
 	 * expressions.
 	 *
 	 * @return the first select expression node that should be considered when building the array of select
 	 *         expressions
 	 */
 	protected abstract AST getFirstSelectExpression();
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SessionFactoryAwareNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SessionFactoryAwareNode.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SessionFactoryAwareNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SessionFactoryAwareNode.java
index b2d47a577b..1e6c8c1c2e 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SessionFactoryAwareNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SessionFactoryAwareNode.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 
 /**
  * Interface for nodes which require access to the SessionFactory
  *
  * @author Steve Ebersole
  */
 public interface SessionFactoryAwareNode {
 	public void setSessionFactory(SessionFactoryImplementor sessionFactory);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SqlFragment.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SqlFragment.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SqlFragment.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SqlFragment.java
index 60474f68f1..1143753c2c 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SqlFragment.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SqlFragment.java
@@ -1,74 +1,74 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import java.util.ArrayList;
 import java.util.List;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.sql.JoinFragment;
 
 /**
  * Represents an SQL fragment in the AST.
  *
  * @author josh
  */
 public class SqlFragment extends Node implements ParameterContainer {
 	private JoinFragment joinFragment;
 	private FromElement fromElement;
 
 	public void setJoinFragment(JoinFragment joinFragment) {
 		this.joinFragment = joinFragment;
 	}
 
 	public boolean hasFilterCondition() {
 		return joinFragment.hasFilterCondition();
 	}
 
 	public void setFromElement(FromElement fromElement) {
 		this.fromElement = fromElement;
 	}
 
 	public FromElement getFromElement() {
 		return fromElement;
 	}
 
 
 	// ParameterContainer impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	private List embeddedParameters;
 
 	public void addEmbeddedParameter(ParameterSpecification specification) {
 		if ( embeddedParameters == null ) {
 			embeddedParameters = new ArrayList();
 		}
 		embeddedParameters.add( specification );
 	}
 
 	public boolean hasEmbeddedParameters() {
 		return embeddedParameters != null && ! embeddedParameters.isEmpty();
 	}
 
 	public ParameterSpecification[] getEmbeddedParameters() {
 		return ( ParameterSpecification[] ) embeddedParameters.toArray( new ParameterSpecification[ embeddedParameters.size() ] );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SqlNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SqlNode.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SqlNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SqlNode.java
index a2a3a0a78c..02caed801d 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/SqlNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/SqlNode.java
@@ -1,63 +1,63 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.type.Type;
 
 /**
  * A base AST node for the intermediate tree.
  * User: josh
  * Date: Dec 6, 2003
  * Time: 10:29:14 AM
  */
 public class SqlNode extends Node {
 	/**
 	 * The original text for the node, mostly for debugging.
 	 */
 	private String originalText;
 	/**
 	 * The data type of this node.  Null for 'no type'.
 	 */
 	private Type dataType;
 
 	public void setText(String s) {
 		super.setText( s );
 		if ( s != null && s.length() > 0 && originalText == null ) {
 			originalText = s;
 		}
 	}
 
 	public String getOriginalText() {
 		return originalText;
 	}
 
 	public Type getDataType() {
 		return dataType;
 	}
 
 	public void setDataType(Type dataType) {
 		this.dataType = dataType;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/Statement.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/Statement.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/Statement.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/Statement.java
index fa60622d71..eff6950e10 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/Statement.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/Statement.java
@@ -1,58 +1,58 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
-import org.hibernate.hql.ast.HqlSqlWalker;
+package org.hibernate.hql.internal.ast.tree;
+import org.hibernate.hql.internal.ast.HqlSqlWalker;
 
 /**
  * Common interface modeling the different HQL statements (i.e., INSERT, UPDATE, DELETE, SELECT).
  *
  * @author Steve Ebersole
  */
 public interface Statement {
 
 	/**
 	 * Retreive the "phase 2" walker which generated this statement tree.
 	 *
 	 * @return The HqlSqlWalker instance which generated this statement tree.
 	 */
 	public HqlSqlWalker getWalker();
 
 	/**
 	 * Return the main token type representing the type of this statement.
 	 *
 	 * @return The corresponding token type.
 	 */
 	public int getStatementType();
 
 	/**
 	 * Does this statement require the StatementExecutor?
 	 * </p>
 	 * Essentially, at the JDBC level, does this require an executeUpdate()?
 	 *
 	 * @return True if this statement should be handed off to the
 	 * StatementExecutor to be executed; false otherwise.
 	 */
 	public boolean needsExecutor();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/UnaryArithmeticNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/UnaryArithmeticNode.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/UnaryArithmeticNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/UnaryArithmeticNode.java
index 3458e11dd8..b564de1441 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/UnaryArithmeticNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/UnaryArithmeticNode.java
@@ -1,50 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 
 //$Id: UnaryArithmeticNode.java 8407 2005-10-14 17:23:18Z steveebersole $
-package org.hibernate.hql.ast.tree;
-import org.hibernate.hql.ast.util.ColumnHelper;
+package org.hibernate.hql.internal.ast.tree;
+import org.hibernate.hql.internal.ast.util.ColumnHelper;
 import org.hibernate.type.Type;
 import antlr.SemanticException;
 
 public class UnaryArithmeticNode extends AbstractSelectExpression implements UnaryOperatorNode {
 
 	public Type getDataType() {
 		return ( ( SqlNode ) getOperand() ).getDataType();
 	}
 
 	public void setScalarColumnText(int i) throws SemanticException {
 		ColumnHelper.generateSingleScalarColumn( this, i );
 	}
 
 	public void initialize() {
 		// nothing to do; even if the operand is a parameter, no way we could
 		// infer an appropriate expected type here
 	}
 
 	public Node getOperand() {
 		return ( Node ) getFirstChild();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/UnaryLogicOperatorNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/UnaryLogicOperatorNode.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/UnaryLogicOperatorNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/UnaryLogicOperatorNode.java
index 0240795cd4..7e7a3bebc0 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/UnaryLogicOperatorNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/UnaryLogicOperatorNode.java
@@ -1,48 +1,48 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.Type;
 
 /**
  * Represents a unary operator node.
  *
  * @author Steve Ebersole
  */
 public class UnaryLogicOperatorNode extends HqlSqlWalkerNode implements UnaryOperatorNode {
 	public Node getOperand() {
 		return ( Node ) getFirstChild();
 	}
 
 	public void initialize() {
 		// nothing to do; even if the operand is a parameter, no way we could
 		// infer an appropriate expected type here
 	}
 
 	public Type getDataType() {
 		// logic operators by definition resolve to booleans
 		return StandardBasicTypes.BOOLEAN;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/UnaryOperatorNode.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/UnaryOperatorNode.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/UnaryOperatorNode.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/UnaryOperatorNode.java
index 74f309b4f1..30b53d3788 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/UnaryOperatorNode.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/UnaryOperatorNode.java
@@ -1,40 +1,40 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 
 
 /**
  * Contract for nodes representing unary operators.
  *
  * @author Steve Ebersole
  */
 public interface UnaryOperatorNode extends OperatorNode {
 	/**
 	 * Retrievs the node representing the operator's single operand.
 	 * 
 	 * @return The operator's single operand.
 	 */
 	public Node getOperand();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/UpdateStatement.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/UpdateStatement.java
similarity index 84%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/tree/UpdateStatement.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/UpdateStatement.java
index a226034ffd..38a142ee9a 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/tree/UpdateStatement.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/tree/UpdateStatement.java
@@ -1,70 +1,70 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.tree;
+package org.hibernate.hql.internal.ast.tree;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.util.ASTUtil;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
 
 import org.jboss.logging.Logger;
 import antlr.collections.AST;
 
 /**
  * Defines a top-level AST node representing an HQL update statement.
  *
  * @author Steve Ebersole
  */
 public class UpdateStatement extends AbstractRestrictableStatement {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, UpdateStatement.class.getName());
 
 	/**
-	 * @see org.hibernate.hql.ast.tree.Statement#getStatementType()
+	 * @see org.hibernate.hql.internal.ast.tree.Statement#getStatementType()
 	 */
 	public int getStatementType() {
 		return SqlTokenTypes.UPDATE;
 	}
 
 	/**
-	 * @see org.hibernate.hql.ast.tree.Statement#needsExecutor()
+	 * @see org.hibernate.hql.internal.ast.tree.Statement#needsExecutor()
 	 */
 	public boolean needsExecutor() {
 		return true;
 	}
 
 	@Override
     protected int getWhereClauseParentTokenType() {
 		return SqlTokenTypes.SET;
 	}
 
 	@Override
     protected CoreMessageLogger getLog() {
         return LOG;
 	}
 
 	public AST getSetClause() {
 		return ASTUtil.findTypeInChildren( this, HqlSqlTokenTypes.SET );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTAppender.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTAppender.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTAppender.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTAppender.java
index c4933480fd..83cdf48b19 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTAppender.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTAppender.java
@@ -1,68 +1,68 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.util;
+package org.hibernate.hql.internal.ast.util;
 import antlr.ASTFactory;
 import antlr.collections.AST;
 
 /**
  * Appends child nodes to a parent efficiently.
  *
  * @author Joshua Davis
  */
 public class ASTAppender {
 	private AST parent;
 	private AST last;
 	private ASTFactory factory;
 
 	public ASTAppender(ASTFactory factory, AST parent) {
 		this( parent );
 		this.factory = factory;
 	}
 
 	public ASTAppender(AST parent) {
 		this.parent = parent;
 		this.last = ASTUtil.getLastChild( parent );
 	}
 
 	public AST append(int type, String text, boolean appendIfEmpty) {
 		if ( text != null && ( appendIfEmpty || text.length() > 0 ) ) {
 			return append( factory.create( type, text ) );
 		}
 		else {
 			return null;
 		}
 	}
 
 	public AST append(AST child) {
 		if ( last == null ) {
 			parent.setFirstChild( child );
 		}
 		else {
 			last.setNextSibling( child );
 		}
 		last = child;
 		return last;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTIterator.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTIterator.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTIterator.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTIterator.java
index b42fb4f5b4..c948071faa 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTIterator.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTIterator.java
@@ -1,91 +1,91 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.util;
+package org.hibernate.hql.internal.ast.util;
 import java.util.Iterator;
 import java.util.LinkedList;
 import antlr.collections.AST;
 
 /**
  * Depth first iteration of an ANTLR AST.
  *
  * @author josh
  */
 public class ASTIterator implements Iterator {
 	private AST next, current;
 	private LinkedList parents = new LinkedList();
 
 	public void remove() {
 		throw new UnsupportedOperationException( "remove() is not supported" );
 	}
 
 	public boolean hasNext() {
 		return next != null;
 	}
 
 	public Object next() {
 		return nextNode();
 	}
 
 	public ASTIterator(AST tree) {
 		next = tree;
 		down();
 	}
 
 	public AST nextNode() {
 		current = next;
 		if ( next != null ) {
 			AST nextSibling = next.getNextSibling();
 			if ( nextSibling == null ) {
 				next = pop();
 			}
 			else {
 				next = nextSibling;
 				down();
 			}
 		}
 		return current;
 	}
 
 	private void down() {
 		while ( next != null && next.getFirstChild() != null ) {
 			push( next );
 			next = next.getFirstChild();
 		}
 	}
 
 	private void push(AST parent) {
 		parents.addFirst( parent );
 	}
 
 	private AST pop() {
 		if ( parents.size() == 0 ) {
 			return null;
 		}
 		else {
 			return ( AST ) parents.removeFirst();
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTParentsFirstIterator.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTParentsFirstIterator.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTParentsFirstIterator.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTParentsFirstIterator.java
index 5f70e033dd..84ed792dd2 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTParentsFirstIterator.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTParentsFirstIterator.java
@@ -1,94 +1,94 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.util;
+package org.hibernate.hql.internal.ast.util;
 import java.util.Iterator;
 import java.util.LinkedList;
 import antlr.collections.AST;
 
 /**
  * Depth first iteration of an ANTLR AST.
  *
  * @author josh
  */
 public class ASTParentsFirstIterator implements Iterator {
 	private AST next, current, tree;
 	private LinkedList parents = new LinkedList();
 
 	public void remove() {
 		throw new UnsupportedOperationException( "remove() is not supported" );
 	}
 
 	public boolean hasNext() {
 		return next != null;
 	}
 
 	public Object next() {
 		return nextNode();
 	}
 
 	public ASTParentsFirstIterator(AST tree) {
 		this.tree = next = tree;
 	}
 
 	public AST nextNode() {
 		current = next;
 		if ( next != null ) {
 			AST child = next.getFirstChild();
 			if ( child == null ) {
 				AST sibling = next.getNextSibling();
 				if ( sibling == null ) {
 					AST parent = pop();
 					while ( parent != null && parent.getNextSibling() == null )
 						parent = pop();
 					next = ( parent != null ) ? parent.getNextSibling() : null;
 				}
 				else {
 					next = sibling;
 				}
 			}
 			else {
 				if ( next != tree ) {
 					push( next );
 				}
 				next = child;
 			}
 		}
 		return current;
 	}
 
 	private void push(AST parent) {
 		parents.addFirst( parent );
 	}
 
 	private AST pop() {
 		if ( parents.size() == 0 ) {
 			return null;
 		}
 		else {
 			return ( AST ) parents.removeFirst();
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTPrinter.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTPrinter.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTPrinter.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTPrinter.java
index 5531aa7021..2daaa190ec 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTPrinter.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTPrinter.java
@@ -1,227 +1,227 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.util;
+package org.hibernate.hql.internal.ast.util;
 
 import java.io.ByteArrayOutputStream;
 import java.io.PrintStream;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Map;
-import org.hibernate.hql.ast.tree.DisplayableNode;
+import org.hibernate.hql.internal.ast.tree.DisplayableNode;
 import org.hibernate.internal.util.StringHelper;
 import antlr.collections.AST;
 
 /**
  * Utility for generating pretty "ASCII art" representations of syntax trees.
  *
  * @author Joshua Davis
  * @author Steve Ebersole
  */
 public class ASTPrinter {
 	private final Map tokenTypeNameCache;
 	private final boolean showClassNames;
 
 	/**
 	 * Constructs a printer.
 	 * <p/>
 	 * Delegates to {@link #ASTPrinter(Class, boolean)} with {@link #isShowClassNames showClassNames} as <tt>true</tt>
 	 *
 	 * @param tokenTypeConstants The token types to use during printing; typically the {vocabulary}TokenTypes.java
 	 * interface generated by ANTLR.
 	 */
 	public ASTPrinter(Class tokenTypeConstants) {
 		this( ASTUtil.generateTokenNameCache( tokenTypeConstants ), true );
 	}
 
 	public ASTPrinter(boolean showClassNames) {
 		this( ( Map ) null, showClassNames );
 	}
 
 	/**
 	 * Constructs a printer.
 	 *
 	 * @param tokenTypeConstants The token types to use during printing; typically the {vocabulary}TokenTypes.java
 	 * interface generated by ANTLR.
 	 * @param showClassNames Should the AST class names be shown.
 	 */
 	public ASTPrinter(Class tokenTypeConstants, boolean showClassNames) {
 		this( ASTUtil.generateTokenNameCache( tokenTypeConstants ), showClassNames );
 	}
 
 	private ASTPrinter(Map tokenTypeNameCache, boolean showClassNames) {
 		this.tokenTypeNameCache = tokenTypeNameCache;
 		this.showClassNames = showClassNames;
 	}
 
 	/**
 	 * Getter for property 'showClassNames'.
 	 *
 	 * @return Value for property 'showClassNames'.
 	 */
 	public boolean isShowClassNames() {
 		return showClassNames;
 	}
 
 	/**
 	 * Renders the AST into 'ASCII art' form and returns that string representation.
 	 *
 	 * @param ast The AST to display.
 	 * @param header The header for the display.
 	 *
 	 * @return The AST in 'ASCII art' form, as a string.
 	 */
 	public String showAsString(AST ast, String header) {
 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
 		PrintStream ps = new PrintStream( baos );
 		ps.println( header );
 		showAst( ast, ps );
 		ps.flush();
 		return new String( baos.toByteArray() );
 	}
 
 	/**
 	 * Prints the AST in 'ASCII art' form to the specified print stream.
 	 *
 	 * @param ast The AST to print.
 	 * @param out The print stream to which the AST should be printed.
 	 */
 	public void showAst(AST ast, PrintStream out) {
 		showAst( ast, new PrintWriter( out ) );
 	}
 
 	/**
 	 * Prints the AST in 'ASCII art' tree form to the specified print writer.
 	 *
 	 * @param ast The AST to print.
 	 * @param pw The print writer to which the AST should be written.
 	 */
 	public void showAst(AST ast, PrintWriter pw) {
 		ArrayList parents = new ArrayList();
 		showAst( parents, pw, ast );
 		pw.flush();
 	}
 
 	/**
 	 * Returns the token type name for the given token type.
 	 *
 	 * @param type The token type.
 	 * @return String - The token type name from the token type constant class,
 	 *         or just the integer as a string if none exists.
 	 */
 	public String getTokenTypeName(int type) {
 		final Integer typeInteger = new Integer( type );
 		String value = null;
 		if ( tokenTypeNameCache != null ) {
 			value = ( String ) tokenTypeNameCache.get( typeInteger );
 		}
 		if ( value == null ) {
 			value = typeInteger.toString();
 		}
 		return value;
 	}
 
 	private void showAst(ArrayList parents, PrintWriter pw, AST ast) {
 		if ( ast == null ) {
 			pw.println( "AST is null!" );
 			return;
 		}
 
 		for ( int i = 0; i < parents.size(); i++ ) {
 			AST parent = ( AST ) parents.get( i );
 			if ( parent.getNextSibling() == null ) {
 
 				pw.print( "   " );
 			}
 			else {
 				pw.print( " | " );
 			}
 		}
 
 		if ( ast.getNextSibling() == null ) {
 			pw.print( " \\-" );
 		}
 		else {
 			pw.print( " +-" );
 		}
 
 		showNode( pw, ast );
 
 		ArrayList newParents = new ArrayList( parents );
 		newParents.add( ast );
 		for ( AST child = ast.getFirstChild(); child != null; child = child.getNextSibling() ) {
 			showAst( newParents, pw, child );
 		}
 		newParents.clear();
 	}
 
 	private void showNode(PrintWriter pw, AST ast) {
 		String s = nodeToString( ast, isShowClassNames() );
 		pw.println( s );
 	}
 
 	public String nodeToString(AST ast, boolean showClassName) {
 		if ( ast == null ) {
 			return "{node:null}";
 		}
 		StringBuffer buf = new StringBuffer();
 		buf.append( "[" ).append( getTokenTypeName( ast.getType() ) ).append( "] " );
 		if ( showClassName ) {
 			buf.append( StringHelper.unqualify( ast.getClass().getName() ) ).append( ": " );
 		}
 
         buf.append( "'" );
         String text = ast.getText();
 		if ( text == null ) {
 			text = "{text:null}";
 		}
 		appendEscapedMultibyteChars(text, buf);
         buf.append( "'" );
 		if ( ast instanceof DisplayableNode ) {
 			DisplayableNode displayableNode = ( DisplayableNode ) ast;
 			// Add a space before the display text.
 			buf.append( " " ).append( displayableNode.getDisplayText() );
 		}
 		return buf.toString();
 	}
 
     public static void appendEscapedMultibyteChars(String text, StringBuffer buf) {
         char[] chars = text.toCharArray();
         for (int i = 0; i < chars.length; i++) {
             char aChar = chars[i];
             if (aChar > 256) {
                 buf.append("\\u");
                 buf.append(Integer.toHexString(aChar));
             }
             else
                 buf.append(aChar);
         }
     }
 
     public static String escapeMultibyteChars(String text) {
         StringBuffer buf = new StringBuffer();
         appendEscapedMultibyteChars(text,buf);
         return buf.toString();
     }
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTUtil.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTUtil.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTUtil.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTUtil.java
index 2b9c5ea384..97d3f6e191 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/ASTUtil.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTUtil.java
@@ -1,462 +1,462 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.util;
+package org.hibernate.hql.internal.ast.util;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import antlr.ASTFactory;
 import antlr.collections.AST;
 import antlr.collections.impl.ASTArray;
 
 /**
  * Provides utility methods for AST traversal and manipulation.
  *
  * @author Joshua Davis
  * @author Steve Ebersole
  */
 public final class ASTUtil {
 	/**
 	 * Disallow instantiation.
 	 *
 	 * @deprecated (tellclovertoignorethis)
 	 */
 	private ASTUtil() {
 	}
 
 	/**
 	 * Creates a single node AST.
 	 * <p/>
 	 * TODO : this is silly, remove it...
 	 *
 	 * @param astFactory The factory.
 	 * @param type The node type.
 	 * @param text The node text.
 	 *
 	 * @return AST - A single node tree.
 	 *
 	 * @deprecated silly
 	 */
 	public static AST create(ASTFactory astFactory, int type, String text) {
 		return astFactory.create( type, text );
 	}
 
 	/**
 	 * Creates a single node AST as a sibling of the passed prevSibling,
 	 * taking care to reorganize the tree correctly to account for this
 	 * newly created node.
 	 *
 	 * @param astFactory The factory.
 	 * @param type The node type.
 	 * @param text The node text.
 	 * @param prevSibling The previous sibling.
 	 *
 	 * @return The created AST node.
 	 */
 	public static AST createSibling(ASTFactory astFactory, int type, String text, AST prevSibling) {
 		AST node = astFactory.create( type, text );
 		return insertSibling( node, prevSibling );
 	}
 
 	/**
 	 * Inserts a node into a child subtree as a particularly positioned
 	 * sibling taking care to properly reorganize the tree to account for this
 	 * new addition.
 	 *
 	 * @param node The node to insert
 	 * @param prevSibling The previous node at the sibling position
 	 * where we want this node inserted.
 	 *
 	 * @return The return is the same as the node parameter passed in.
 	 */
 	public static AST insertSibling(AST node, AST prevSibling) {
 		node.setNextSibling( prevSibling.getNextSibling() );
 		prevSibling.setNextSibling( node );
 		return node;
 	}
 
 	/**
 	 * Creates a 'binary operator' subtree, given the information about the
 	 * parent and the two child nodex.
 	 *
 	 * @param factory The AST factory.
 	 * @param parentType The type of the parent node.
 	 * @param parentText The text of the parent node.
 	 * @param child1 The first child.
 	 * @param child2 The second child.
 	 *
 	 * @return AST - A new sub-tree of the form "(parent child1 child2)"
 	 */
 	public static AST createBinarySubtree(ASTFactory factory, int parentType, String parentText, AST child1, AST child2) {
 		ASTArray array = createAstArray( factory, 3, parentType, parentText, child1 );
 		array.add( child2 );
 		return factory.make( array );
 	}
 
 	/**
 	 * Creates a single parent of the specified child (i.e. a 'unary operator'
 	 * subtree).
 	 *
 	 * @param factory The AST factory.
 	 * @param parentType The type of the parent node.
 	 * @param parentText The text of the parent node.
 	 * @param child The child.
 	 *
 	 * @return AST - A new sub-tree of the form "(parent child)"
 	 */
 	public static AST createParent(ASTFactory factory, int parentType, String parentText, AST child) {
 		ASTArray array = createAstArray( factory, 2, parentType, parentText, child );
 		return factory.make( array );
 	}
 
 	public static AST createTree(ASTFactory factory, AST[] nestedChildren) {
 		AST[] array = new AST[2];
 		int limit = nestedChildren.length - 1;
 		for ( int i = limit; i >= 0; i-- ) {
 			if ( i != limit ) {
 				array[1] = nestedChildren[i + 1];
 				array[0] = nestedChildren[i];
 				factory.make( array );
 			}
 		}
 		return array[0];
 	}
 
 	/**
 	 * Determine if a given node (test) is contained anywhere in the subtree
 	 * of another given node (fixture).
 	 *
 	 * @param fixture The node against which to testto be checked for children.
 	 * @param test The node to be tested as being a subtree child of the parent.
 	 * @return True if child is contained in the parent's collection of children.
 	 */
 	public static boolean isSubtreeChild(AST fixture, AST test) {
 		AST n = fixture.getFirstChild();
 		while ( n != null ) {
 			if ( n == test ) {
 				return true;
 			}
 			if ( n.getFirstChild() != null && isSubtreeChild( n, test ) ) {
 				return true;
 			}
 			n = n.getNextSibling();
 		}
 		return false;
 	}
 
 	/**
 	 * Finds the first node of the specified type in the chain of children.
 	 *
 	 * @param parent The parent
 	 * @param type The type to find.
 	 *
 	 * @return The first node of the specified type, or null if not found.
 	 */
 	public static AST findTypeInChildren(AST parent, int type) {
 		AST n = parent.getFirstChild();
 		while ( n != null && n.getType() != type ) {
 			n = n.getNextSibling();
 		}
 		return n;
 	}
 
 	/**
 	 * Returns the last direct child of 'n'.
 	 *
 	 * @param n The parent
 	 *
 	 * @return The last direct child of 'n'.
 	 */
 	public static AST getLastChild(AST n) {
 		return getLastSibling( n.getFirstChild() );
 	}
 
 	/**
 	 * Returns the last sibling of 'a'.
 	 *
 	 * @param a The sibling.
 	 *
 	 * @return The last sibling of 'a'.
 	 */
 	private static AST getLastSibling(AST a) {
 		AST last = null;
 		while ( a != null ) {
 			last = a;
 			a = a.getNextSibling();
 		}
 		return last;
 	}
 
 	/**
 	 * Returns the 'list' representation with some brackets around it for debugging.
 	 *
 	 * @param n The tree.
 	 *
 	 * @return The list representation of the tree.
 	 */
 	public static String getDebugString(AST n) {
 		StringBuffer buf = new StringBuffer();
 		buf.append( "[ " );
 		buf.append( ( n == null ) ? "{null}" : n.toStringTree() );
 		buf.append( " ]" );
 		return buf.toString();
 	}
 
 	/**
 	 * Find the previous sibling in the parent for the given child.
 	 *
 	 * @param parent the parent node
 	 * @param child the child to find the previous sibling of
 	 *
 	 * @return the previous sibling of the child
 	 */
 	public static AST findPreviousSibling(AST parent, AST child) {
 		AST prev = null;
 		AST n = parent.getFirstChild();
 		while ( n != null ) {
 			if ( n == child ) {
 				return prev;
 			}
 			prev = n;
 			n = n.getNextSibling();
 		}
 		throw new IllegalArgumentException( "Child not found in parent!" );
 	}
 
 	/**
 	 * Makes the child node a sibling of the parent, reconnecting all siblings.
 	 *
 	 * @param parent the parent
 	 * @param child the child
 	 */
 	public static void makeSiblingOfParent(AST parent, AST child) {
 		AST prev = findPreviousSibling( parent, child );
 		if ( prev != null ) {
 			prev.setNextSibling( child.getNextSibling() );
 		}
 		else { // child == parent.getFirstChild()
 			parent.setFirstChild( child.getNextSibling() );
 		}
 		child.setNextSibling( parent.getNextSibling() );
 		parent.setNextSibling( child );
 	}
 
 	public static String getPathText(AST n) {
 		StringBuffer buf = new StringBuffer();
 		getPathText( buf, n );
 		return buf.toString();
 	}
 
 	private static void getPathText(StringBuffer buf, AST n) {
 		AST firstChild = n.getFirstChild();
 		// If the node has a first child, recurse into the first child.
 		if ( firstChild != null ) {
 			getPathText( buf, firstChild );
 		}
 		// Append the text of the current node.
 		buf.append( n.getText() );
 		// If there is a second child (RHS), recurse into that child.
 		if ( firstChild != null && firstChild.getNextSibling() != null ) {
 			getPathText( buf, firstChild.getNextSibling() );
 		}
 	}
 
 	public static boolean hasExactlyOneChild(AST n) {
 		return n != null && n.getFirstChild() != null && n.getFirstChild().getNextSibling() == null;
 	}
 
 	public static void appendSibling(AST n, AST s) {
 		while ( n.getNextSibling() != null ) {
 			n = n.getNextSibling();
 		}
 		n.setNextSibling( s );
 	}
 
 	/**
 	 * Inserts the child as the first child of the parent, all other children are shifted over to the 'right'.
 	 *
 	 * @param parent the parent
 	 * @param child the new first child
 	 */
 	public static void insertChild(AST parent, AST child) {
 		if ( parent.getFirstChild() == null ) {
 			parent.setFirstChild( child );
 		}
 		else {
 			AST n = parent.getFirstChild();
 			parent.setFirstChild( child );
 			child.setNextSibling( n );
 		}
 	}
 
 	private static ASTArray createAstArray(ASTFactory factory, int size, int parentType, String parentText, AST child1) {
 		ASTArray array = new ASTArray( size );
 		array.add( factory.create( parentType, parentText ) );
 		array.add( child1 );
 		return array;
 	}
 
 	/**
 	 * Filters nodes out of a tree.
 	 */
 	public static interface FilterPredicate {
 		/**
 		 * Returns true if the node should be filtered out.
 		 *
 		 * @param n The node.
 		 *
 		 * @return true if the node should be filtered out, false to keep the node.
 		 */
 		boolean exclude(AST n);
 	}
 
 	/**
 	 * A predicate that uses inclusion, rather than exclusion semantics.
 	 */
 	public abstract static class IncludePredicate implements FilterPredicate {
 		public final boolean exclude(AST node) {
 			return !include( node );
 		}
 
 		public abstract boolean include(AST node);
 	}
 
 	public static List collectChildren(AST root, FilterPredicate predicate) {
 		return new CollectingNodeVisitor( predicate ).collect( root );
 	}
 
 	private static class CollectingNodeVisitor implements NodeTraverser.VisitationStrategy {
 		private final FilterPredicate predicate;
 		private final List collectedNodes = new ArrayList();
 
 		public CollectingNodeVisitor(FilterPredicate predicate) {
 			this.predicate = predicate;
 		}
 
 		public void visit(AST node) {
 			if ( predicate == null || !predicate.exclude( node ) ) {
 				collectedNodes.add( node );
 			}
 		}
 
 		public List getCollectedNodes() {
 			return collectedNodes;
 		}
 
 		public List collect(AST root) {
 			NodeTraverser traverser = new NodeTraverser( this );
 			traverser.traverseDepthFirst( root );
 			return collectedNodes;
 		}
 	}
 
 	/**
 	 * Method to generate a map of token type names, keyed by their token type values.
 	 *
 	 * @param tokenTypeInterface The *TokenTypes interface (or implementor of said interface).
 	 * @return The generated map.
 	 */
 	public static Map generateTokenNameCache(Class tokenTypeInterface) {
 		final Field[] fields = tokenTypeInterface.getFields();
 		Map cache = new HashMap( (int)( fields.length * .75 ) + 1 );
 		for ( int i = 0; i < fields.length; i++ ) {
 			final Field field = fields[i];
 			if ( Modifier.isStatic( field.getModifiers() ) ) {
 				try {
 					cache.put( field.get( null ), field.getName() );
 				}
 				catch ( Throwable ignore ) {
 				}
 			}
 		}
 		return cache;
 	}
 
 	/**
 	 * Get the name of a constant defined on the given class which has the given value.
 	 * <p/>
 	 * Note, if multiple constants have this value, the first will be returned which is known to be different
 	 * on different JVM implementations.
 	 *
 	 * @param owner The class which defines the constant
 	 * @param value The value of the constant.
 	 *
 	 * @return The token type name, *or* the integer value if the name could not be found.
 	 *
 	 * @deprecated Use #getTokenTypeName instead
 	 */
 	public static String getConstantName(Class owner, int value) {
 		return getTokenTypeName( owner, value );
 	}
 
 	/**
 	 * Intended to retrieve the name of an AST token type based on the token type interface.  However, this
 	 * method can be used to look up the name of any constant defined on a class/interface based on the constant value.
 	 * Note that if multiple constants have this value, the first will be returned which is known to be different
 	 * on different JVM implementations.
 	 *
 	 * @param tokenTypeInterface The *TokenTypes interface (or one of its implementors).
 	 * @param tokenType The token type value.
 	 *
 	 * @return The corresponding name.
 	 */
 	public static String getTokenTypeName(Class tokenTypeInterface, int tokenType) {
 		String tokenTypeName = Integer.toString( tokenType );
 		if ( tokenTypeInterface != null ) {
 			Field[] fields = tokenTypeInterface.getFields();
 			for ( int i = 0; i < fields.length; i++ ) {
 				final Integer fieldValue = extractIntegerValue( fields[i] );
 				if ( fieldValue != null && fieldValue.intValue() == tokenType ) {
 					tokenTypeName = fields[i].getName();
 					break;
 				}
 			}
 		}
 		return tokenTypeName;
 	}
 
 	private static Integer extractIntegerValue(Field field) {
 		Integer rtn = null;
 		try {
 			Object value = field.get( null );
 			if ( value instanceof Integer ) {
 				rtn = ( Integer ) value;
 			}
 			else if ( value instanceof Short ) {
 				rtn = new Integer( ( ( Short ) value ).intValue() );
 			}
 			else if ( value instanceof Long ) {
 				if ( ( ( Long ) value ).longValue() <= Integer.MAX_VALUE ) {
 					rtn = new Integer( ( ( Long ) value ).intValue() );
 				}
 			}
 		}
 		catch ( IllegalAccessException ignore ) {
 		}
 		return rtn;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/AliasGenerator.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/AliasGenerator.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/util/AliasGenerator.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/AliasGenerator.java
index 8d41eeed0a..a49ba89bc9 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/AliasGenerator.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/AliasGenerator.java
@@ -1,45 +1,45 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.util;
+package org.hibernate.hql.internal.ast.util;
 
 import org.hibernate.internal.util.StringHelper;
 
 /**
  * Generates class/table/column aliases during semantic analysis and SQL rendering.
  * <p/>
  * Its essential purpose is to keep an internal counter to ensure that the
  * generated aliases are unique.
  */
 public class AliasGenerator {
 	private int next = 0;
 
 	private int nextCount() {
 		return next++;
 	}
 
 	public String createName(String name) {
 		return StringHelper.generateAlias( name, nextCount() );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/ColumnHelper.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ColumnHelper.java
similarity index 91%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/util/ColumnHelper.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ColumnHelper.java
index 42ffe9c426..2be142c92a 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/ColumnHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ColumnHelper.java
@@ -1,70 +1,70 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.util;
-import org.hibernate.hql.NameGenerator;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.tree.HqlSqlWalkerNode;
+package org.hibernate.hql.internal.ast.util;
+import org.hibernate.hql.internal.NameGenerator;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.tree.HqlSqlWalkerNode;
 import antlr.ASTFactory;
 import antlr.collections.AST;
 
 /**
  * Provides utility methods for dealing with arrays of SQL column names.
  *
  * @author josh
  */
 public final class ColumnHelper {
 
 	/**
 	 * @deprecated (tell clover to filter this out)
 	 */
 	private ColumnHelper() {
 	}
 
 	public static void generateSingleScalarColumn(HqlSqlWalkerNode node, int i) {
 		ASTFactory factory = node.getASTFactory();
 		ASTUtil.createSibling( factory, SqlTokenTypes.SELECT_COLUMNS, " as " + NameGenerator.scalarName( i, 0 ), node );
 	}
 
 	/**
 	 * Generates the scalar column AST nodes for a given array of SQL columns
 	 */
 	public static void generateScalarColumns(HqlSqlWalkerNode node, String sqlColumns[], int i) {
 		if ( sqlColumns.length == 1 ) {
 			generateSingleScalarColumn( node, i );
 		}
 		else {
 			ASTFactory factory = node.getASTFactory();
 			AST n = node;
 			n.setText( sqlColumns[0] );	// Use the DOT node to emit the first column name.
 			// Create the column names, folled by the column aliases.
 			for ( int j = 0; j < sqlColumns.length; j++ ) {
 				if ( j > 0 ) {
 					n = ASTUtil.createSibling( factory, SqlTokenTypes.SQL_TOKEN, sqlColumns[j], n );
 				}
 				n = ASTUtil.createSibling( factory, SqlTokenTypes.SELECT_COLUMNS, " as " + NameGenerator.scalarName( i, j ), n );
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/JoinProcessor.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/JoinProcessor.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/util/JoinProcessor.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/JoinProcessor.java
index 77f6b8f4d1..7d5c7842aa 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/JoinProcessor.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/JoinProcessor.java
@@ -1,254 +1,254 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.util;
+package org.hibernate.hql.internal.ast.util;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.StringTokenizer;
 import org.hibernate.AssertionFailure;
 import org.hibernate.engine.internal.JoinSequence;
 import org.hibernate.engine.spi.LoadQueryInfluencers;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.dialect.Dialect;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.HqlSqlWalker;
-import org.hibernate.hql.ast.tree.DotNode;
-import org.hibernate.hql.ast.tree.FromClause;
-import org.hibernate.hql.ast.tree.FromElement;
-import org.hibernate.hql.ast.tree.ParameterContainer;
-import org.hibernate.hql.ast.tree.QueryNode;
-import org.hibernate.hql.classic.ParserHelper;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.HqlSqlWalker;
+import org.hibernate.hql.internal.ast.tree.DotNode;
+import org.hibernate.hql.internal.ast.tree.FromClause;
+import org.hibernate.hql.internal.ast.tree.FromElement;
+import org.hibernate.hql.internal.ast.tree.ParameterContainer;
+import org.hibernate.hql.internal.ast.tree.QueryNode;
+import org.hibernate.hql.internal.classic.ParserHelper;
 import org.hibernate.internal.FilterImpl;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.param.DynamicFilterParameterSpecification;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 
 /**
  * Performs the post-processing of the join information gathered during semantic analysis.
  * The join generating classes are complex, this encapsulates some of the JoinSequence-related
  * code.
  *
  * @author Joshua Davis
  */
 public class JoinProcessor implements SqlTokenTypes {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, JoinProcessor.class.getName());
 
 	private final HqlSqlWalker walker;
 	private final SyntheticAndFactory syntheticAndFactory;
 
 	/**
 	 * Constructs a new JoinProcessor.
 	 *
 	 * @param walker The walker to which we are bound, giving us access to needed resources.
 	 */
 	public JoinProcessor(HqlSqlWalker walker) {
 		this.walker = walker;
 		this.syntheticAndFactory = new SyntheticAndFactory( walker );
 	}
 
 	/**
 	 * Translates an AST join type (i.e., the token type) into a JoinFragment.XXX join type.
 	 *
 	 * @param astJoinType The AST join type (from HqlSqlTokenTypes or SqlTokenTypes)
 	 * @return a JoinFragment.XXX join type.
 	 * @see JoinFragment
 	 * @see SqlTokenTypes
 	 */
 	public static int toHibernateJoinType(int astJoinType) {
 		switch ( astJoinType ) {
 			case LEFT_OUTER:
 				return JoinFragment.LEFT_OUTER_JOIN;
 			case INNER:
 				return JoinFragment.INNER_JOIN;
 			case RIGHT_OUTER:
 				return JoinFragment.RIGHT_OUTER_JOIN;
 			default:
 				throw new AssertionFailure( "undefined join type " + astJoinType );
 		}
 	}
 
 	public void processJoins(QueryNode query) {
 		final FromClause fromClause = query.getFromClause();
 
 		final List fromElements;
 		if ( DotNode.useThetaStyleImplicitJoins ) {
 			// for regression testing against output from the old parser...
 			// found it easiest to simply reorder the FromElements here into ascending order
 			// in terms of injecting them into the resulting sql ast in orders relative to those
 			// expected by the old parser; this is definitely another of those "only needed
 			// for regression purposes".  The SyntheticAndFactory, then, simply injects them as it
 			// encounters them.
 			fromElements = new ArrayList();
 			ListIterator liter = fromClause.getFromElements().listIterator( fromClause.getFromElements().size() );
 			while ( liter.hasPrevious() ) {
 				fromElements.add( liter.previous() );
 			}
 		}
 		else {
 			fromElements = fromClause.getFromElements();
 		}
 
 		// Iterate through the alias,JoinSequence pairs and generate SQL token nodes.
 		Iterator iter = fromElements.iterator();
 		while ( iter.hasNext() ) {
 			final FromElement fromElement = ( FromElement ) iter.next();
 			JoinSequence join = fromElement.getJoinSequence();
             join.setSelector(new JoinSequence.Selector() {
                 public boolean includeSubclasses( String alias ) {
                     // The uber-rule here is that we need to include subclass joins if
                     // the FromElement is in any way dereferenced by a property from
                     // the subclass table; otherwise we end up with column references
                     // qualified by a non-existent table reference in the resulting SQL...
                     boolean containsTableAlias = fromClause.containsTableAlias(alias);
                     if (fromElement.isDereferencedBySubclassProperty()) {
                         // TODO : or should we return 'containsTableAlias'??
                         LOG.trace("Forcing inclusion of extra joins [alias=" + alias + ", containsTableAlias=" + containsTableAlias
                                   + "]");
                         return true;
                     }
                     boolean shallowQuery = walker.isShallowQuery();
                     boolean includeSubclasses = fromElement.isIncludeSubclasses();
                     boolean subQuery = fromClause.isSubQuery();
                     return includeSubclasses && containsTableAlias && !subQuery && !shallowQuery;
 					}
             }
 			);
 			addJoinNodes( query, join, fromElement );
 		}
 
 	}
 
 	private void addJoinNodes(QueryNode query, JoinSequence join, FromElement fromElement) {
 		JoinFragment joinFragment = join.toJoinFragment(
 				walker.getEnabledFilters(),
 				fromElement.useFromFragment() || fromElement.isDereferencedBySuperclassOrSubclassProperty(),
 				fromElement.getWithClauseFragment(),
 				fromElement.getWithClauseJoinAlias()
 		);
 
 		String frag = joinFragment.toFromFragmentString();
 		String whereFrag = joinFragment.toWhereFragmentString();
 
 		// If the from element represents a JOIN_FRAGMENT and it is
 		// a theta-style join, convert its type from JOIN_FRAGMENT
 		// to FROM_FRAGMENT
 		if ( fromElement.getType() == JOIN_FRAGMENT &&
 				( join.isThetaStyle() || StringHelper.isNotEmpty( whereFrag ) ) ) {
 			fromElement.setType( FROM_FRAGMENT );
 			fromElement.getJoinSequence().setUseThetaStyle( true ); // this is used during SqlGenerator processing
 		}
 
 		// If there is a FROM fragment and the FROM element is an explicit, then add the from part.
 		if ( fromElement.useFromFragment() /*&& StringHelper.isNotEmpty( frag )*/ ) {
 			String fromFragment = processFromFragment( frag, join ).trim();
             LOG.debugf("Using FROM fragment [%s]", fromFragment);
 			processDynamicFilterParameters(
 					fromFragment,
 					fromElement,
 					walker
 			);
 		}
 
 		syntheticAndFactory.addWhereFragment(
 				joinFragment,
 				whereFrag,
 				query,
 				fromElement,
 				walker
 		);
 	}
 
 	private String processFromFragment(String frag, JoinSequence join) {
 		String fromFragment = frag.trim();
 		// The FROM fragment will probably begin with ', '.  Remove this if it is present.
 		if ( fromFragment.startsWith( ", " ) ) {
 			fromFragment = fromFragment.substring( 2 );
 		}
 		return fromFragment;
 	}
 
 	public static void processDynamicFilterParameters(
 			final String sqlFragment,
 			final ParameterContainer container,
 			final HqlSqlWalker walker) {
 		if ( walker.getEnabledFilters().isEmpty()
 				&& ( ! hasDynamicFilterParam( sqlFragment ) )
 				&& ( ! ( hasCollectionFilterParam( sqlFragment ) ) ) ) {
 			return;
 		}
 
 		Dialect dialect = walker.getSessionFactoryHelper().getFactory().getDialect();
 		String symbols = new StringBuffer().append( ParserHelper.HQL_SEPARATORS )
 				.append( dialect.openQuote() )
 				.append( dialect.closeQuote() )
 				.toString();
 		StringTokenizer tokens = new StringTokenizer( sqlFragment, symbols, true );
 		StringBuffer result = new StringBuffer();
 
 		while ( tokens.hasMoreTokens() ) {
 			final String token = tokens.nextToken();
 			if ( token.startsWith( ParserHelper.HQL_VARIABLE_PREFIX ) ) {
 				final String filterParameterName = token.substring( 1 );
 				final String[] parts = LoadQueryInfluencers.parseFilterParameterName( filterParameterName );
 				final FilterImpl filter = ( FilterImpl ) walker.getEnabledFilters().get( parts[0] );
 				final Object value = filter.getParameter( parts[1] );
 				final Type type = filter.getFilterDefinition().getParameterType( parts[1] );
 				final String typeBindFragment = StringHelper.join(
 						",",
 						ArrayHelper.fillArray(
 								"?", type.getColumnSpan(
 								walker.getSessionFactoryHelper().getFactory()
 						)
 						)
 				);
 				final String bindFragment = ( value != null && Collection.class.isInstance( value ) )
 						? StringHelper.join( ",", ArrayHelper.fillArray( typeBindFragment, ( ( Collection ) value ).size() ) )
 						: typeBindFragment;
 				result.append( bindFragment );
 				container.addEmbeddedParameter( new DynamicFilterParameterSpecification( parts[0], parts[1], type ) );
 			}
 			else {
 				result.append( token );
 			}
 		}
 
 		container.setText( result.toString() );
 	}
 
 	private static boolean hasDynamicFilterParam(String sqlFragment) {
 		return sqlFragment.indexOf( ParserHelper.HQL_VARIABLE_PREFIX ) < 0;
 	}
 
 	private static boolean hasCollectionFilterParam(String sqlFragment) {
 		return sqlFragment.indexOf( "?" ) < 0;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/LiteralProcessor.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/LiteralProcessor.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/util/LiteralProcessor.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/LiteralProcessor.java
index bd0dc76f1c..b2d8165cb2 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/LiteralProcessor.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/LiteralProcessor.java
@@ -1,319 +1,319 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.util;
+package org.hibernate.hql.internal.ast.util;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.text.DecimalFormat;
 import org.hibernate.HibernateException;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.dialect.Dialect;
-import org.hibernate.hql.QueryTranslator;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.antlr.SqlTokenTypes;
-import org.hibernate.hql.ast.HqlSqlWalker;
-import org.hibernate.hql.ast.InvalidPathException;
-import org.hibernate.hql.ast.tree.DotNode;
-import org.hibernate.hql.ast.tree.FromClause;
-import org.hibernate.hql.ast.tree.IdentNode;
+import org.hibernate.hql.spi.QueryTranslator;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.antlr.SqlTokenTypes;
+import org.hibernate.hql.internal.ast.HqlSqlWalker;
+import org.hibernate.hql.internal.ast.InvalidPathException;
+import org.hibernate.hql.internal.ast.tree.DotNode;
+import org.hibernate.hql.internal.ast.tree.FromClause;
+import org.hibernate.hql.internal.ast.tree.IdentNode;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.InFragment;
 import org.hibernate.type.LiteralType;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * A delegate that handles literals and constants for HqlSqlWalker, performing the token replacement functions and
  * classifying literals.
  *
  * @author josh
  */
 public class LiteralProcessor implements HqlSqlTokenTypes {
 	/**
 	 * Indicates that Float and Double literal values should
 	 * be treated using the SQL "exact" format (i.e., '.001')
 	 */
 	public static final int EXACT = 0;
 	/**
 	 * Indicates that Float and Double literal values should
 	 * be treated using the SQL "approximate" format (i.e., '1E-3')
 	 */
 	public static final int APPROXIMATE = 1;
 	/**
 	 * In what format should Float and Double literal values be sent
 	 * to the database?
 	 * @see #EXACT, #APPROXIMATE
 	 */
 	public static int DECIMAL_LITERAL_FORMAT = EXACT;
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, LiteralProcessor.class.getName());
 
 	private HqlSqlWalker walker;
 
 	public LiteralProcessor(HqlSqlWalker hqlSqlWalker) {
 		this.walker = hqlSqlWalker;
 	}
 
 	public boolean isAlias(String alias) {
 		FromClause from = walker.getCurrentFromClause();
 		while ( from.isSubQuery() ) {
 			if ( from.containsClassAlias(alias) ) {
 				return true;
 			}
 			from = from.getParentFromClause();
 		}
 		return from.containsClassAlias(alias);
 	}
 
 	public void processConstant(AST constant, boolean resolveIdent) throws SemanticException {
 		// If the constant is an IDENT, figure out what it means...
 		boolean isIdent = ( constant.getType() == IDENT || constant.getType() == WEIRD_IDENT );
 		if ( resolveIdent && isIdent && isAlias( constant.getText() ) ) { // IDENT is a class alias in the FROM.
 			IdentNode ident = ( IdentNode ) constant;
 			// Resolve to an identity column.
 			ident.resolve(false, true);
 		}
 		else {	// IDENT might be the name of a class.
 			Queryable queryable = walker.getSessionFactoryHelper().findQueryableUsingImports( constant.getText() );
 			if ( isIdent && queryable != null ) {
 				constant.setText( queryable.getDiscriminatorSQLValue() );
 			}
 			// Otherwise, it's a literal.
 			else {
 				processLiteral( constant );
 			}
 		}
 	}
 
 	public void lookupConstant(DotNode node) throws SemanticException {
 		String text = ASTUtil.getPathText( node );
 		Queryable persister = walker.getSessionFactoryHelper().findQueryableUsingImports( text );
 		if ( persister != null ) {
 			// the name of an entity class
 			final String discrim = persister.getDiscriminatorSQLValue();
 			node.setDataType( persister.getDiscriminatorType() );
             if (InFragment.NULL.equals(discrim) || InFragment.NOT_NULL.equals(discrim)) throw new InvalidPathException(
                                                                                                                        "subclass test not allowed for null or not null discriminator: '"
                                                                                                                        + text + "'");
             setSQLValue(node, text, discrim); // the class discriminator value
 		}
 		else {
 			Object value = ReflectHelper.getConstantValue( text );
             if (value == null) throw new InvalidPathException("Invalid path: '" + text + "'");
             setConstantValue(node, text, value);
 		}
 	}
 
 	private void setSQLValue(DotNode node, String text, String value) {
         LOG.debugf("setSQLValue() %s -> %s", text, value);
 		node.setFirstChild( null );	// Chop off the rest of the tree.
 		node.setType( SqlTokenTypes.SQL_TOKEN );
 		node.setText(value);
 		node.setResolvedConstant( text );
 	}
 
 	private void setConstantValue(DotNode node, String text, Object value) {
         LOG.debugf("setConstantValue() %s -> %s %s", text, value, value.getClass().getName());
 		node.setFirstChild( null );	// Chop off the rest of the tree.
 		if ( value instanceof String ) {
 			node.setType( SqlTokenTypes.QUOTED_STRING );
 		}
 		else if ( value instanceof Character ) {
 			node.setType( SqlTokenTypes.QUOTED_STRING );
 		}
 		else if ( value instanceof Byte ) {
 			node.setType( SqlTokenTypes.NUM_INT );
 		}
 		else if ( value instanceof Short ) {
 			node.setType( SqlTokenTypes.NUM_INT );
 		}
 		else if ( value instanceof Integer ) {
 			node.setType( SqlTokenTypes.NUM_INT );
 		}
 		else if ( value instanceof Long ) {
 			node.setType( SqlTokenTypes.NUM_LONG );
 		}
 		else if ( value instanceof Double ) {
 			node.setType( SqlTokenTypes.NUM_DOUBLE );
 		}
 		else if ( value instanceof Float ) {
 			node.setType( SqlTokenTypes.NUM_FLOAT );
 		}
 		else {
 			node.setType( SqlTokenTypes.CONSTANT );
 		}
 		Type type;
 		try {
 			type = walker.getSessionFactoryHelper().getFactory().getTypeResolver().heuristicType( value.getClass().getName() );
 		}
 		catch ( MappingException me ) {
 			throw new QueryException( me );
 		}
 		if ( type == null ) {
 			throw new QueryException( QueryTranslator.ERROR_CANNOT_DETERMINE_TYPE + node.getText() );
 		}
 		try {
 			LiteralType literalType = ( LiteralType ) type;
 			Dialect dialect = walker.getSessionFactoryHelper().getFactory().getDialect();
 			node.setText( literalType.objectToSQLString( value, dialect ) );
 		}
 		catch ( Exception e ) {
 			throw new QueryException( QueryTranslator.ERROR_CANNOT_FORMAT_LITERAL + node.getText(), e );
 		}
 		node.setDataType( type );
 		node.setResolvedConstant( text );
 	}
 
 	public void processBoolean(AST constant) {
 		// TODO: something much better - look at the type of the other expression!
 		// TODO: Have comparisonExpression and/or arithmeticExpression rules complete the resolution of boolean nodes.
 		String replacement = ( String ) walker.getTokenReplacements().get( constant.getText() );
 		if ( replacement != null ) {
 			constant.setText( replacement );
 		}
 		else {
 			boolean bool = "true".equals( constant.getText().toLowerCase() );
 			Dialect dialect = walker.getSessionFactoryHelper().getFactory().getDialect();
 			constant.setText( dialect.toBooleanValueString(bool) );
 		}
 	}
 
 	private void processLiteral(AST constant) {
 		String replacement = ( String ) walker.getTokenReplacements().get( constant.getText() );
 		if ( replacement != null ) {
             LOG.debugf("processConstant() : Replacing '%s' with '%s'", constant.getText(), replacement);
 			constant.setText( replacement );
 		}
 	}
 
 	public void processNumeric(AST literal) {
 		if ( literal.getType() == NUM_INT
 				|| literal.getType() == NUM_LONG
 				|| literal.getType() == NUM_BIG_INTEGER ) {
 			literal.setText( determineIntegerRepresentation( literal.getText(), literal.getType() ) );
         } else if (literal.getType() == NUM_FLOAT
 				|| literal.getType() == NUM_DOUBLE
 				|| literal.getType() == NUM_BIG_DECIMAL ) {
 			literal.setText( determineDecimalRepresentation( literal.getText(), literal.getType() ) );
         } else LOG.unexpectedLiteralTokenType(literal.getType());
 	}
 
 	private String determineIntegerRepresentation(String text, int type) {
 		try {
 			if ( type == NUM_BIG_INTEGER ) {
 				String literalValue = text;
 				if ( literalValue.endsWith( "bi" ) || literalValue.endsWith( "BI" ) ) {
 					literalValue = literalValue.substring( 0, literalValue.length() - 2 );
 				}
 				return new BigInteger( literalValue ).toString();
 			}
 			if ( type == NUM_INT ) {
 				try {
 					return Integer.valueOf( text ).toString();
 				}
 				catch( NumberFormatException e ) {
                     LOG.trace("Could not format incoming text [" + text
                               + "] as a NUM_INT; assuming numeric overflow and attempting as NUM_LONG");
 				}
 			}
 			String literalValue = text;
 			if ( literalValue.endsWith( "l" ) || literalValue.endsWith( "L" ) ) {
 				literalValue = literalValue.substring( 0, literalValue.length() - 1 );
 			}
 			return Long.valueOf( literalValue ).toString();
 		}
 		catch( Throwable t ) {
 			throw new HibernateException( "Could not parse literal [" + text + "] as integer", t );
 		}
 	}
 
 	public String determineDecimalRepresentation(String text, int type) {
 		String literalValue = text;
 		if ( type == NUM_FLOAT ) {
 			if ( literalValue.endsWith( "f" ) || literalValue.endsWith( "F" ) ) {
 				literalValue = literalValue.substring( 0, literalValue.length() - 1 );
 			}
 		}
 		else if ( type == NUM_DOUBLE ) {
 			if ( literalValue.endsWith( "d" ) || literalValue.endsWith( "D" ) ) {
 				literalValue = literalValue.substring( 0, literalValue.length() - 1 );
 			}
 		}
 		else if ( type == NUM_BIG_DECIMAL ) {
 			if ( literalValue.endsWith( "bd" ) || literalValue.endsWith( "BD" ) ) {
 				literalValue = literalValue.substring( 0, literalValue.length() - 2 );
 			}
 		}
 
 		BigDecimal number = null;
 		try {
 			number = new BigDecimal( literalValue );
 		}
 		catch( Throwable t ) {
 			throw new HibernateException( "Could not parse literal [" + text + "] as big-decimal", t );
 		}
 
 		return formatters[ DECIMAL_LITERAL_FORMAT ].format( number );
 	}
 
 
 	private static interface DecimalFormatter {
 		String format(BigDecimal number);
 	}
 
 	private static class ExactDecimalFormatter implements DecimalFormatter {
 		public String format(BigDecimal number) {
 			return number.toString();
 		}
 	}
 
 	private static class ApproximateDecimalFormatter implements DecimalFormatter {
 		private static final String FORMAT_STRING = "#0.0E0";
 		public String format(BigDecimal number) {
 			try {
 				// TODO : what amount of significant digits need to be supported here?
 				//      - from the DecimalFormat docs:
 				//          [significant digits] = [minimum integer digits] + [maximum fraction digits]
 				DecimalFormat jdkFormatter = new DecimalFormat( FORMAT_STRING );
 				jdkFormatter.setMinimumIntegerDigits( 1 );
 				jdkFormatter.setMaximumFractionDigits( Integer.MAX_VALUE );
 				return jdkFormatter.format( number );
 			}
 			catch( Throwable t ) {
 				throw new HibernateException( "Unable to format decimal literal in approximate format [" + number.toString() + "]", t );
 			}
 		}
 	}
 
 	private static final DecimalFormatter[] formatters = new DecimalFormatter[] {
 			new ExactDecimalFormatter(),
 			new ApproximateDecimalFormatter()
 	};
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/NodeTraverser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/NodeTraverser.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/util/NodeTraverser.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/NodeTraverser.java
index 217bbda144..08d17205b6 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/NodeTraverser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/NodeTraverser.java
@@ -1,87 +1,87 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.util;
+package org.hibernate.hql.internal.ast.util;
 import java.util.Stack;
 import antlr.collections.AST;
 
 /**
  * A visitor for traversing an AST tree.
  * 
  * @author Steve Ebersole
  * @author Philip R. "Pib" Burns.
  * @author Strong Liu
  * 
  */
 
 public class NodeTraverser {
 	public static interface VisitationStrategy {
 		public void visit( AST node );
 	}
 
 	private final VisitationStrategy strategy;
 
 	public NodeTraverser( VisitationStrategy strategy ) {
 		this.strategy = strategy;
 	}
 
 	/**
 	 * Traverse the AST tree depth first.
 	 * 
 	 * @param ast
 	 *            Root node of subtree to traverse.
 	 * 
 	 *            <p>
 	 *            Note that the AST passed in is not visited itself. Visitation
 	 *            starts with its children.
 	 *            </p>
 	 */
 	public void traverseDepthFirst( AST ast ) {
 		if ( ast == null ) {
 			throw new IllegalArgumentException(
 					"node to traverse cannot be null!" );
 		}
 		visitDepthFirst( ast.getFirstChild() );
 	}
 	
 	private void visitDepthFirst(AST ast){
 		if(ast==null){
 			return;
 		}
 		Stack stack = new Stack();
 		if ( ast != null ) {
 			stack.push( ast );
 			while (!stack.empty()) {
 				ast = (AST) stack.pop();
 				strategy.visit( ast );
 				if ( ast.getNextSibling() != null ) 
 					stack.push( ast.getNextSibling() );
 				if ( ast.getFirstChild() != null ) 
 					stack.push( ast.getFirstChild() );
 			}
 		}
 	}
 
 	
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/PathHelper.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/PathHelper.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/util/PathHelper.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/PathHelper.java
index 7bd9276be6..0d2e566607 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/PathHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/PathHelper.java
@@ -1,73 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.util;
+package org.hibernate.hql.internal.ast.util;
 
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
 import org.hibernate.internal.util.StringHelper;
 import org.jboss.logging.Logger;
 import antlr.ASTFactory;
 import antlr.collections.AST;
 
 /**
  * Provides utility methods for paths.
  *
  * @author josh
  */
 public final class PathHelper {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, PathHelper.class.getName());
 
 	private PathHelper() {
 	}
 
 	/**
 	 * Turns a path into an AST.
 	 *
 	 * @param path    The path.
 	 * @param factory The AST factory to use.
 	 * @return An HQL AST representing the path.
 	 */
 	public static AST parsePath(String path, ASTFactory factory) {
 		String[] identifiers = StringHelper.split( ".", path );
 		AST lhs = null;
 		for ( int i = 0; i < identifiers.length; i++ ) {
 			String identifier = identifiers[i];
 			AST child = ASTUtil.create( factory, HqlSqlTokenTypes.IDENT, identifier );
 			if ( i == 0 ) {
 				lhs = child;
 			}
 			else {
 				lhs = ASTUtil.createBinarySubtree( factory, HqlSqlTokenTypes.DOT, ".", lhs, child );
 			}
 		}
         if (LOG.isDebugEnabled()) LOG.debugf("parsePath() : %s -> %s", path, ASTUtil.getDebugString(lhs));
 		return lhs;
 	}
 
 	public static String getAlias(String path) {
 		return StringHelper.root( path );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/SessionFactoryHelper.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/SessionFactoryHelper.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/util/SessionFactoryHelper.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/SessionFactoryHelper.java
index 0dfa001efb..c378f42941 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/SessionFactoryHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/SessionFactoryHelper.java
@@ -1,413 +1,413 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.util;
+package org.hibernate.hql.internal.ast.util;
 import java.util.HashMap;
 import java.util.Map;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.engine.internal.JoinSequence;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.hql.NameGenerator;
-import org.hibernate.hql.ast.DetailedSemanticException;
-import org.hibernate.hql.ast.QuerySyntaxException;
-import org.hibernate.hql.ast.tree.SqlNode;
+import org.hibernate.hql.internal.NameGenerator;
+import org.hibernate.hql.internal.ast.DetailedSemanticException;
+import org.hibernate.hql.internal.ast.QuerySyntaxException;
+import org.hibernate.hql.internal.ast.tree.SqlNode;
 import org.hibernate.persister.collection.CollectionPropertyMapping;
 import org.hibernate.persister.collection.CollectionPropertyNames;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.PropertyMapping;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import antlr.SemanticException;
 import antlr.collections.AST;
 
 /**
  * Helper for performing common and/or complex operations with the
  * {@link SessionFactoryImplementor} during translation of an HQL query.
  *
  * @author Joshua Davis
  */
 public class SessionFactoryHelper {
 
 	private SessionFactoryImplementor sfi;
 	private Map collectionPropertyMappingByRole;
 
 	/**
 	 * Construct a new SessionFactoryHelper instance.
 	 *
 	 * @param sfi The SessionFactory impl to be encapsulated.
 	 */
 	public SessionFactoryHelper(SessionFactoryImplementor sfi) {
 		this.sfi = sfi;
 		collectionPropertyMappingByRole = new HashMap();
 	}
 
 	/**
 	 * Get a handle to the encapsulated SessionFactory.
 	 *
 	 * @return The encapsulated SessionFactory.
 	 */
 	public SessionFactoryImplementor getFactory() {
 		return sfi;
 	}
 
 	/**
 	 * Does the given persister define a physical discriminator column
 	 * for the purpose of inheritance discrimination?
 	 *
 	 * @param persister The persister to be checked.
 	 * @return True if the persister does define an actual discriminator column.
 	 */
 	public boolean hasPhysicalDiscriminatorColumn(Queryable persister) {
 		if ( persister.getDiscriminatorType() != null ) {
 			String discrimColumnName = persister.getDiscriminatorColumnName();
 			// Needed the "clazz_" check to work around union-subclasses
 			// TODO : is there a way to tell whether a persister is truly discrim-column based inheritence?
 			if ( discrimColumnName != null && !"clazz_".equals( discrimColumnName ) ) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	/**
 	 * Given a (potentially unqualified) class name, locate its imported qualified name.
 	 *
 	 * @param className The potentially unqualified class name
 	 * @return The qualified class name.
 	 */
 	public String getImportedClassName(String className) {
 		return sfi.getImportedClassName( className );
 	}
 
 	/**
 	 * Given a (potentially unqualified) class name, locate its persister.
 	 *
 	 * @param className The (potentially unqualified) class name.
 	 * @return The defined persister for this class, or null if none found.
 	 */
 	public Queryable findQueryableUsingImports(String className) {
 		return findQueryableUsingImports( sfi, className );
 	}
 
 
 	/**
 	 * Given a (potentially unqualified) class name, locate its persister.
 	 *
 	 * @param sfi The session factory implementor.
 	 * @param className The (potentially unqualified) class name.
 	 * @return The defined persister for this class, or null if none found.
 	 */
 	public static Queryable findQueryableUsingImports(SessionFactoryImplementor sfi, String className) {
 		final String importedClassName = sfi.getImportedClassName( className );
 		if ( importedClassName == null ) {
 			return null;
 		}
 		try {
 			return ( Queryable ) sfi.getEntityPersister( importedClassName );
 		}
 		catch ( MappingException me ) {
 			return null;
 		}
 	}
 
 	/**
 	 * Locate the persister by class or entity name.
 	 *
 	 * @param name The class or entity name
 	 * @return The defined persister for this entity, or null if none found.
 	 * @throws MappingException
 	 */
 	private EntityPersister findEntityPersisterByName(String name) throws MappingException {
 		// First, try to get the persister using the given name directly.
 		try {
 			return sfi.getEntityPersister( name );
 		}
 		catch ( MappingException ignore ) {
 			// unable to locate it using this name
 		}
 
 		// If that didn't work, try using the 'import' name.
 		String importedClassName = sfi.getImportedClassName( name );
 		if ( importedClassName == null ) {
 			return null;
 		}
 		return sfi.getEntityPersister( importedClassName );
 	}
 
 	/**
 	 * Locate the persister by class or entity name, requiring that such a persister
 	 * exist.
 	 *
 	 * @param name The class or entity name
 	 * @return The defined persister for this entity
 	 * @throws SemanticException Indicates the persister could not be found
 	 */
 	public EntityPersister requireClassPersister(String name) throws SemanticException {
 		EntityPersister cp;
 		try {
 			cp = findEntityPersisterByName( name );
 			if ( cp == null ) {
 				throw new QuerySyntaxException( name + " is not mapped" );
 			}
 		}
 		catch ( MappingException e ) {
 			throw new DetailedSemanticException( e.getMessage(), e );
 		}
 		return cp;
 	}
 
 	/**
 	 * Locate the collection persister by the collection role.
 	 *
 	 * @param role The collection role name.
 	 * @return The defined CollectionPersister for this collection role, or null.
 	 */
 	public QueryableCollection getCollectionPersister(String role) {
 		try {
 			return ( QueryableCollection ) sfi.getCollectionPersister( role );
 		}
 		catch ( ClassCastException cce ) {
 			throw new QueryException( "collection is not queryable: " + role );
 		}
 		catch ( Exception e ) {
 			throw new QueryException( "collection not found: " + role );
 		}
 	}
 
 	/**
 	 * Locate the collection persister by the collection role, requiring that
 	 * such a persister exist.
 	 *
 	 * @param role The collection role name.
 	 * @return The defined CollectionPersister for this collection role.
 	 * @throws QueryException Indicates that the collection persister could not be found.
 	 */
 	public QueryableCollection requireQueryableCollection(String role) throws QueryException {
 		try {
 			QueryableCollection queryableCollection = ( QueryableCollection ) sfi.getCollectionPersister( role );
 			if ( queryableCollection != null ) {
 				collectionPropertyMappingByRole.put( role, new CollectionPropertyMapping( queryableCollection ) );
 			}
 			return queryableCollection;
 		}
 		catch ( ClassCastException cce ) {
 			throw new QueryException( "collection role is not queryable: " + role );
 		}
 		catch ( Exception e ) {
 			throw new QueryException( "collection role not found: " + role );
 		}
 	}
 
 	/**
 	 * Retrieve a PropertyMapping describing the given collection role.
 	 *
 	 * @param role The collection role for which to retrieve the property mapping.
 	 * @return The property mapping.
 	 */
 	public PropertyMapping getCollectionPropertyMapping(String role) {
 		return ( PropertyMapping ) collectionPropertyMappingByRole.get( role );
 	}
 
 	/**
 	 * Retrieves the column names corresponding to the collection elements for the given
 	 * collection role.
 	 *
 	 * @param role The collection role
 	 * @param roleAlias The sql column-qualification alias (i.e., the table alias)
 	 * @return the collection element columns
 	 */
 	public String[] getCollectionElementColumns(String role, String roleAlias) {
 		return getCollectionPropertyMapping( role ).toColumns( roleAlias, CollectionPropertyNames.COLLECTION_ELEMENTS );
 	}
 
 	/**
 	 * Generate an empty join sequence instance.
 	 *
 	 * @return The generate join sequence.
 	 */
 	public JoinSequence createJoinSequence() {
 		return new JoinSequence( sfi );
 	}
 
 	/**
 	 * Generate a join sequence representing the given association type.
 	 *
 	 * @param implicit Should implicit joins (theta-style) or explicit joins (ANSI-style) be rendered
 	 * @param associationType The type representing the thing to be joined into.
 	 * @param tableAlias The table alias to use in qualifying the join conditions
 	 * @param joinType The type of join to render (inner, outer, etc);  see {@link org.hibernate.sql.JoinFragment}
 	 * @param columns The columns making up the condition of the join.
 	 * @return The generated join sequence.
 	 */
 	public JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, int joinType, String[] columns) {
 		JoinSequence joinSequence = createJoinSequence();
 		joinSequence.setUseThetaStyle( implicit );	// Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from)
 		joinSequence.addJoin( associationType, tableAlias, joinType, columns );
 		return joinSequence;
 	}
 
 	/**
 	 * Create a join sequence rooted at the given collection.
 	 *
 	 * @param collPersister The persister for the collection at which the join should be rooted.
 	 * @param collectionName The alias to use for qualifying column references.
 	 * @return The generated join sequence.
 	 */
 	public JoinSequence createCollectionJoinSequence(QueryableCollection collPersister, String collectionName) {
 		JoinSequence joinSequence = createJoinSequence();
 		joinSequence.setRoot( collPersister, collectionName );
 		joinSequence.setUseThetaStyle( true );		// TODO: figure out how this should be set.
 ///////////////////////////////////////////////////////////////////////////////
 // This was the reason for failures regarding INDEX_OP and subclass joins on
 // theta-join dialects; not sure what behavior we were trying to emulate ;)
 //		joinSequence = joinSequence.getFromPart();	// Emulate the old addFromOnly behavior.
 		return joinSequence;
 	}
 
 	/**
 	 * Determine the name of the property for the entity encapsulated by the
 	 * given type which represents the id or unique-key.
 	 *
 	 * @param entityType The type representing the entity.
 	 * @return The corresponding property name
 	 * @throws QueryException Indicates such a property could not be found.
 	 */
 	public String getIdentifierOrUniqueKeyPropertyName(EntityType entityType) {
 		try {
 			return entityType.getIdentifierOrUniqueKeyPropertyName( sfi );
 		}
 		catch ( MappingException me ) {
 			throw new QueryException( me );
 		}
 	}
 
 	/**
 	 * Retrieve the number of columns represented by this type.
 	 *
 	 * @param type The type.
 	 * @return The number of columns.
 	 */
 	public int getColumnSpan(Type type) {
 		return type.getColumnSpan( sfi );
 	}
 
 	/**
 	 * Given a collection type, determine the entity name of the elements
 	 * contained within instance of that collection.
 	 *
 	 * @param collectionType The collection type to check.
 	 * @return The entity name of the elements of this collection.
 	 */
 	public String getAssociatedEntityName(CollectionType collectionType) {
 		return collectionType.getAssociatedEntityName( sfi );
 	}
 
 	/**
 	 * Given a collection type, determine the Type representing elements
 	 * within instances of that collection.
 	 *
 	 * @param collectionType The collection type to be checked.
 	 * @return The Type of the elements of the collection.
 	 */
 	private Type getElementType(CollectionType collectionType) {
 		return collectionType.getElementType( sfi );
 	}
 
 	/**
 	 * Essentially the same as {@link #getElementType}, but requiring that the
 	 * element type be an association type.
 	 *
 	 * @param collectionType The collection type to be checked.
 	 * @return The AssociationType of the elements of the collection.
 	 */
 	public AssociationType getElementAssociationType(CollectionType collectionType) {
 		return ( AssociationType ) getElementType( collectionType );
 	}
 
 	/**
 	 * Locate a registered sql function by name.
 	 *
 	 * @param functionName The name of the function to locate
 	 * @return The sql function, or null if not found.
 	 */
 	public SQLFunction findSQLFunction(String functionName) {
 		return sfi.getSqlFunctionRegistry().findSQLFunction( functionName.toLowerCase() );
 	}
 
 	/**
 	 * Locate a registered sql function by name, requiring that such a registered function exist.
 	 *
 	 * @param functionName The name of the function to locate
 	 * @return The sql function.
 	 * @throws QueryException Indicates no matching sql functions could be found.
 	 */
 	private SQLFunction requireSQLFunction(String functionName) {
 		SQLFunction f = findSQLFunction( functionName );
 		if ( f == null ) {
 			throw new QueryException( "Unable to find SQL function: " + functionName );
 		}
 		return f;
 	}
 
 	/**
 	 * Find the function return type given the function name and the first argument expression node.
 	 *
 	 * @param functionName The function name.
 	 * @param first        The first argument expression.
 	 * @return the function return type given the function name and the first argument expression node.
 	 */
 	public Type findFunctionReturnType(String functionName, AST first) {
 		SQLFunction sqlFunction = requireSQLFunction( functionName );
 		return findFunctionReturnType( functionName, sqlFunction, first );
 	}
 
 	public Type findFunctionReturnType(String functionName, SQLFunction sqlFunction, AST firstArgument) {
 		// determine the type of the first argument...
 		Type argumentType = null;
 		if ( firstArgument != null ) {
 			if ( "cast".equals(functionName) ) {
 				argumentType = sfi.getTypeResolver().heuristicType( firstArgument.getNextSibling().getText() );
 			}
 			else if ( SqlNode.class.isInstance( firstArgument ) ) {
 				argumentType = ( (SqlNode) firstArgument ).getDataType();
 			}
 		}
 
 		return sqlFunction.getReturnType( argumentType, sfi );
 	}
 
 	public String[][] generateColumnNames(Type[] sqlResultTypes) {
 		return NameGenerator.generateColumnNames( sqlResultTypes, sfi );
 	}
 
 	public boolean isStrictJPAQLComplianceEnabled() {
 		return sfi.getSettings().isStrictJPAQLCompliance();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/SyntheticAndFactory.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/SyntheticAndFactory.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/hql/ast/util/SyntheticAndFactory.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/SyntheticAndFactory.java
index 4a82ef96b8..96ed0dcd14 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ast/util/SyntheticAndFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/SyntheticAndFactory.java
@@ -1,204 +1,204 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.ast.util;
+package org.hibernate.hql.internal.ast.util;
 
 import java.util.Map;
 
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.ast.HqlSqlWalker;
-import org.hibernate.hql.ast.tree.FromElement;
-import org.hibernate.hql.ast.tree.Node;
-import org.hibernate.hql.ast.tree.QueryNode;
-import org.hibernate.hql.ast.tree.RestrictableStatement;
-import org.hibernate.hql.ast.tree.SqlFragment;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.ast.HqlSqlWalker;
+import org.hibernate.hql.internal.ast.tree.FromElement;
+import org.hibernate.hql.internal.ast.tree.Node;
+import org.hibernate.hql.internal.ast.tree.QueryNode;
+import org.hibernate.hql.internal.ast.tree.RestrictableStatement;
+import org.hibernate.hql.internal.ast.tree.SqlFragment;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.param.CollectionFilterKeyParameterSpecification;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 import antlr.collections.AST;
 
 /**
  * Creates synthetic and nodes based on the where fragment part of a JoinSequence.
  *
  * @author josh
  */
 public class SyntheticAndFactory implements HqlSqlTokenTypes {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, SyntheticAndFactory.class.getName());
 
 	private HqlSqlWalker hqlSqlWalker;
 	private AST thetaJoins;
 	private AST filters;
 
 	public SyntheticAndFactory(HqlSqlWalker hqlSqlWalker) {
 		this.hqlSqlWalker = hqlSqlWalker;
 	}
 
 	private Node create(int tokenType, String text) {
 		return ( Node ) ASTUtil.create( hqlSqlWalker.getASTFactory(), tokenType, text );
 	}
 
 	public void addWhereFragment(
 			JoinFragment joinFragment,
 			String whereFragment,
 			QueryNode query,
 			FromElement fromElement,
 			HqlSqlWalker hqlSqlWalker) {
 		if ( whereFragment == null ) {
 			return;
 		}
 
 		if ( !fromElement.useWhereFragment() && !joinFragment.hasThetaJoins() ) {
 			return;
 		}
 
 		whereFragment = whereFragment.trim();
 		if ( StringHelper.isEmpty( whereFragment ) ) {
 			return;
 		}
 
 		// Forcefully remove leading ands from where fragments; the grammar will
 		// handle adding them
 		if ( whereFragment.startsWith( "and" ) ) {
 			whereFragment = whereFragment.substring( 4 );
 		}
 
         LOG.debugf("Using unprocessed WHERE-fragment [%s]", whereFragment);
 
 		SqlFragment fragment = ( SqlFragment ) create( SQL_TOKEN, whereFragment );
 		fragment.setJoinFragment( joinFragment );
 		fragment.setFromElement( fromElement );
 
 		if ( fromElement.getIndexCollectionSelectorParamSpec() != null ) {
 			fragment.addEmbeddedParameter( fromElement.getIndexCollectionSelectorParamSpec() );
 			fromElement.setIndexCollectionSelectorParamSpec( null );
 		}
 
 		if ( hqlSqlWalker.isFilter() ) {
 			if ( whereFragment.indexOf( '?' ) >= 0 ) {
 				Type collectionFilterKeyType = hqlSqlWalker.getSessionFactoryHelper()
 						.requireQueryableCollection( hqlSqlWalker.getCollectionFilterRole() )
 						.getKeyType();
 				CollectionFilterKeyParameterSpecification paramSpec = new CollectionFilterKeyParameterSpecification(
 						hqlSqlWalker.getCollectionFilterRole(),
 						collectionFilterKeyType,
 						0
 				);
 				fragment.addEmbeddedParameter( paramSpec );
 			}
 		}
 
 		JoinProcessor.processDynamicFilterParameters(
 				whereFragment,
 				fragment,
 				hqlSqlWalker
 		);
 
         LOG.debugf("Using processed WHERE-fragment [%s]", fragment.getText());
 
 		// Filter conditions need to be inserted before the HQL where condition and the
 		// theta join node.  This is because org.hibernate.loader.Loader binds the filter parameters first,
 		// then it binds all the HQL query parameters, see org.hibernate.loader.Loader.processFilterParameters().
 		if ( fragment.getFromElement().isFilter() || fragment.hasFilterCondition() ) {
 			if ( filters == null ) {
 				// Find or create the WHERE clause
 				AST where = query.getWhereClause();
 				// Create a new FILTERS node as a parent of all filters
 				filters = create( FILTERS, "{filter conditions}" );
 				// Put the FILTERS node before the HQL condition and theta joins
 				ASTUtil.insertChild( where, filters );
 			}
 
 			// add the current fragment to the FILTERS node
 			filters.addChild( fragment );
 		}
 		else {
 			if ( thetaJoins == null ) {
 				// Find or create the WHERE clause
 				AST where = query.getWhereClause();
 				// Create a new THETA_JOINS node as a parent of all filters
 				thetaJoins = create( THETA_JOINS, "{theta joins}" );
 				// Put the THETA_JOINS node before the HQL condition, after the filters.
 				if (filters==null) {
 					ASTUtil.insertChild( where, thetaJoins );
 				}
 				else {
 					ASTUtil.insertSibling( thetaJoins, filters );
 				}
 			}
 
 			// add the current fragment to the THETA_JOINS node
 			thetaJoins.addChild(fragment);
 		}
 
 	}
 
 	public void addDiscriminatorWhereFragment(
 			RestrictableStatement statement,
 			Queryable persister,
 			Map enabledFilters,
 			String alias) {
 		String whereFragment = persister.filterFragment( alias, enabledFilters ).trim();
 		if ( "".equals( whereFragment ) ) {
 			return;
 		}
 		if ( whereFragment.startsWith( "and" ) ) {
 			whereFragment = whereFragment.substring( 4 );
 		}
 
 		// Need to parse off the column qualifiers; this is assuming (which is true as of now)
 		// that this is only used from update and delete HQL statement parsing
 		whereFragment = StringHelper.replace( whereFragment, persister.generateFilterConditionAlias( alias ) + ".", "" );
 
 		// Note: this simply constructs a "raw" SQL_TOKEN representing the
 		// where fragment and injects this into the tree.  This "works";
 		// however it is probably not the best long-term solution.
 		//
 		// At some point we probably want to apply an additional grammar to
 		// properly tokenize this where fragment into constituent parts
 		// focused on the operators embedded within the fragment.
 		SqlFragment discrimNode = ( SqlFragment ) create( SQL_TOKEN, whereFragment );
 
 		JoinProcessor.processDynamicFilterParameters(
 				whereFragment,
 				discrimNode,
 				hqlSqlWalker
 		);
 
 		if ( statement.getWhereClause().getNumberOfChildren() == 0 ) {
 			statement.getWhereClause().setFirstChild( discrimNode );
 		}
 		else {
 			AST and = create( AND, "{and}" );
 			AST currentFirstChild = statement.getWhereClause().getFirstChild();
 			and.setFirstChild( discrimNode );
 			and.addChild( currentFirstChild );
 			statement.getWhereClause().setFirstChild( and );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/ClassicQueryTranslatorFactory.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/ClassicQueryTranslatorFactory.java
similarity index 87%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/ClassicQueryTranslatorFactory.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/ClassicQueryTranslatorFactory.java
index 8cd3d7a651..efa18c6231 100755
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/ClassicQueryTranslatorFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/ClassicQueryTranslatorFactory.java
@@ -1,62 +1,62 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 import java.util.Map;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.hql.FilterTranslator;
-import org.hibernate.hql.QueryTranslator;
-import org.hibernate.hql.QueryTranslatorFactory;
+import org.hibernate.hql.spi.FilterTranslator;
+import org.hibernate.hql.spi.QueryTranslator;
+import org.hibernate.hql.spi.QueryTranslatorFactory;
 
 /**
  * Generates translators which uses the older hand-written parser to perform
  * the translation.
  *
  * @author Gavin King
  */
 public class ClassicQueryTranslatorFactory implements QueryTranslatorFactory {
 
 	/**
 	 * @see QueryTranslatorFactory#createQueryTranslator
 	 */
 	public QueryTranslator createQueryTranslator(
 			String queryIdentifier,
 	        String queryString,
 	        Map filters,
 	        SessionFactoryImplementor factory) {
 		return new QueryTranslatorImpl( queryIdentifier, queryString, filters, factory );
 	}
 
 	/**
-	 * @see QueryTranslatorFactory#createFilterTranslator
+	 * @see org.hibernate.hql.spi.QueryTranslatorFactory#createFilterTranslator
 	 */
 	public FilterTranslator createFilterTranslator(
 			String queryIdentifier,
 			String queryString,
 	        Map filters,
 	        SessionFactoryImplementor factory) {
 		return new QueryTranslatorImpl( queryIdentifier, queryString, filters, factory );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/ClauseParser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/ClauseParser.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/ClauseParser.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/ClauseParser.java
index 5876e633cf..21fbaee392 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/ClauseParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/ClauseParser.java
@@ -1,150 +1,150 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import org.hibernate.QueryException;
 
 /**
  * Parses the Hibernate query into its constituent clauses.
  */
 public class ClauseParser implements Parser {
 
 	private Parser child;
 	private List selectTokens;
 	private boolean cacheSelectTokens = false;
 	private boolean byExpected = false;
 	private int parenCount = 0;
 
 	public void token(String token, QueryTranslatorImpl q) throws QueryException {
 		String lcToken = token.toLowerCase();
 
 		if ( "(".equals( token ) ) {
 			parenCount++;
 		}
 		else if ( ")".equals( token ) ) {
 			parenCount--;
 		}
 
 		if ( byExpected && !lcToken.equals( "by" ) ) {
 			throw new QueryException( "BY expected after GROUP or ORDER: " + token );
 		}
 
 		boolean isClauseStart = parenCount == 0; //ignore subselect keywords
 
 		if ( isClauseStart ) {
 			if ( lcToken.equals( "select" ) ) {
 				selectTokens = new ArrayList();
 				cacheSelectTokens = true;
 			}
 			else if ( lcToken.equals( "from" ) ) {
 				child = new FromParser();
 				child.start( q );
 				cacheSelectTokens = false;
 			}
 			else if ( lcToken.equals( "where" ) ) {
 				endChild( q );
 				child = new WhereParser();
 				child.start( q );
 			}
 			else if ( lcToken.equals( "order" ) ) {
 				endChild( q );
 				child = new OrderByParser();
 				byExpected = true;
 			}
 			else if ( lcToken.equals( "having" ) ) {
 				endChild( q );
 				child = new HavingParser();
 				child.start( q );
 			}
 			else if ( lcToken.equals( "group" ) ) {
 				endChild( q );
 				child = new GroupByParser();
 				byExpected = true;
 			}
 			else if ( lcToken.equals( "by" ) ) {
 				if ( !byExpected ) throw new QueryException( "GROUP or ORDER expected before BY" );
 				child.start( q );
 				byExpected = false;
 			}
 			else {
 				isClauseStart = false;
 			}
 		}
 
 		if ( !isClauseStart ) {
 			if ( cacheSelectTokens ) {
 				selectTokens.add( token );
 			}
 			else {
 				if ( child == null ) {
 					throw new QueryException( "query must begin with SELECT or FROM: " + token );
 				}
 				else {
 					child.token( token, q );
 				}
 			}
 		}
 
 	}
 
 	private void endChild(QueryTranslatorImpl q) throws QueryException {
 		if ( child == null ) {
 			//null child could occur for no from clause in a filter
 			cacheSelectTokens = false;
 		}
 		else {
 			child.end( q );
 		}
 	}
 
 	public void start(QueryTranslatorImpl q) {
 	}
 
 	public void end(QueryTranslatorImpl q) throws QueryException {
 		endChild( q );
 		if ( selectTokens != null ) {
 			child = new SelectParser();
 			child.start( q );
 			Iterator iter = selectTokens.iterator();
 			while ( iter.hasNext() ) {
 				token( ( String ) iter.next(), q );
 			}
 			child.end( q );
 		}
 		byExpected = false;
 		parenCount = 0;
 		cacheSelectTokens = false;
 	}
 
 }
 
 
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/FromParser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/FromParser.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/FromParser.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/FromParser.java
index 20690e7fde..d224a11556 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/FromParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/FromParser.java
@@ -1,303 +1,303 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 import java.util.HashMap;
 import java.util.Map;
 import org.hibernate.QueryException;
-import org.hibernate.hql.QueryTranslator;
+import org.hibernate.hql.spi.QueryTranslator;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.JoinFragment;
 
 /**
  * Parses the from clause of a hibernate query, looking for tables and
  * aliases for the SQL query.
  */
 
 public class FromParser implements Parser {
 
 	private final PathExpressionParser peParser = new FromPathExpressionParser();
 	private String entityName;
 	private String alias;
 	private boolean afterIn;
 	private boolean afterAs;
 	private boolean afterClass;
 	private boolean expectingJoin;
 	private boolean expectingIn;
 	private boolean expectingAs;
 	private boolean afterJoinType;
 	private int joinType;
 	private boolean afterFetch;
 	
 	//support collection member declarations
 	//e.g. "from Customer c, in(c.orders) as o"
 	private boolean memberDeclarations;
 	private boolean expectingPathExpression;
 	private boolean afterMemberDeclarations;
 	private String collectionName;
 
 	private static final int NONE = -666;
 
 	private static final Map JOIN_TYPES = new HashMap();
 
 	static {
 		JOIN_TYPES.put( "left", new Integer( JoinFragment.LEFT_OUTER_JOIN ) );
 		JOIN_TYPES.put( "right", new Integer( JoinFragment.RIGHT_OUTER_JOIN ) );
 		JOIN_TYPES.put( "full", new Integer( JoinFragment.FULL_JOIN ) );
 		JOIN_TYPES.put( "inner", new Integer( JoinFragment.INNER_JOIN ) );
 	}
 
 	public void token(String token, QueryTranslatorImpl q) throws QueryException {
 
 		// start by looking for HQL keywords...
 		String lcToken = token.toLowerCase();
 		if ( lcToken.equals( "," ) ) {
 			if ( !( expectingJoin | expectingAs ) ) throw new QueryException( "unexpected token: ," );
 			expectingJoin = false;
 			expectingAs = false;
 		}
 		else if ( lcToken.equals( "join" ) ) {
 			if ( !afterJoinType ) {
 				if ( !( expectingJoin | expectingAs ) ) throw new QueryException( "unexpected token: join" );
 				// inner joins can be abbreviated to 'join'
 				joinType = JoinFragment.INNER_JOIN;
 				expectingJoin = false;
 				expectingAs = false;
 			}
 			else {
 				afterJoinType = false;
 			}
 		}
 		else if ( lcToken.equals( "fetch" ) ) {
 			if ( q.isShallowQuery() ) throw new QueryException( QueryTranslator.ERROR_CANNOT_FETCH_WITH_ITERATE );
 			if ( joinType == NONE ) throw new QueryException( "unexpected token: fetch" );
 			if ( joinType == JoinFragment.FULL_JOIN || joinType == JoinFragment.RIGHT_OUTER_JOIN ) {
 				throw new QueryException( "fetch may only be used with inner join or left outer join" );
 			}
 			afterFetch = true;
 		}
 		else if ( lcToken.equals( "outer" ) ) {
 			// 'outer' is optional and is ignored
 			if ( !afterJoinType ||
 					( joinType != JoinFragment.LEFT_OUTER_JOIN && joinType != JoinFragment.RIGHT_OUTER_JOIN )
 			) {
 				throw new QueryException( "unexpected token: outer" );
 			}
 		}
 		else if ( JOIN_TYPES.containsKey( lcToken ) ) {
 			if ( !( expectingJoin | expectingAs ) ) throw new QueryException( "unexpected token: " + token );
 			joinType = ( ( Integer ) JOIN_TYPES.get( lcToken ) ).intValue();
 			afterJoinType = true;
 			expectingJoin = false;
 			expectingAs = false;
 		}
 		else if ( lcToken.equals( "class" ) ) {
 			if ( !afterIn ) throw new QueryException( "unexpected token: class" );
 			if ( joinType != NONE ) throw new QueryException( "outer or full join must be followed by path expression" );
 			afterClass = true;
 		}
 		else if ( lcToken.equals( "in" ) ) {
 			if (alias == null ){
 				memberDeclarations = true;
 				afterMemberDeclarations = false;
 			}
 			else if ( !expectingIn ) {
 				throw new QueryException( "unexpected token: in" );
 			} else {
 				afterIn = true;
 				expectingIn = false;
 			}
 		}
 		else if ( lcToken.equals( "as" ) ) {
 			if ( !expectingAs ) throw new QueryException( "unexpected token: as" );
 			afterAs = true;
 			expectingAs = false;
 		}
 		else if ( "(".equals( token ) ){
 			if( !memberDeclarations ) throw new QueryException( "unexpected token: (" );
 			//TODO alias should be null here
 			expectingPathExpression = true;
 			
 		}
 		else if ( ")".equals( token ) ){
 //			memberDeclarations = false;
 //			expectingPathExpression = false;
 			afterMemberDeclarations = true;
 		}
 		else {
 
 			if ( afterJoinType ) throw new QueryException( "join expected: " + token );
 			if ( expectingJoin ) throw new QueryException( "unexpected token: " + token );
 			if ( expectingIn ) throw new QueryException( "in expected: " + token );
 
 			// now anything that is not a HQL keyword
 
 			if ( afterAs || expectingAs ) {
 
 				// (AS is always optional, for consistency with SQL/OQL)
 
 				// process the "new" HQL style where aliases are assigned
 				// _after_ the class name or path expression ie. using
 				// the AS construction
 
 				if ( entityName != null ) {
 					q.setAliasName( token, entityName );
 				}
 				else if ( collectionName != null ) {
 					q.setAliasName( token, collectionName );
 				}
 				else {
 					throw new QueryException( "unexpected: as " + token );
 				}
 				afterAs = false;
 				expectingJoin = true;
 				expectingAs = false;
 				entityName = null;
 				collectionName = null;
 				memberDeclarations = false;
 				expectingPathExpression = false;
 				afterMemberDeclarations = false;
 
 			}
 			else if ( afterIn ) {
 
 				// process the "old" HQL style where aliases appear _first_
 				// ie. using the IN or IN CLASS constructions
 
 				if ( alias == null ) throw new QueryException( "alias not specified for: " + token );
 
 				if ( joinType != NONE ) throw new QueryException( "outer or full join must be followed by path expression" );
 
 				if ( afterClass ) {
 					// treat it as a classname
 					Queryable p = q.getEntityPersisterUsingImports( token );
 					if ( p == null ) throw new QueryException( "persister not found: " + token );
 					q.addFromClass( alias, p );
 				}
 				else {
 					// treat it as a path expression
 					peParser.setJoinType( JoinFragment.INNER_JOIN );
 					peParser.setUseThetaStyleJoin( true );
 					ParserHelper.parse( peParser, q.unalias( token ), ParserHelper.PATH_SEPARATORS, q );
 					if ( !peParser.isCollectionValued() ) throw new QueryException( "path expression did not resolve to collection: " + token );
 					String nm = peParser.addFromCollection( q );
 					q.setAliasName( alias, nm );
 				}
 
 				alias = null;
 				afterIn = false;
 				afterClass = false;
 				expectingJoin = true;
 			}
 			else if( memberDeclarations && expectingPathExpression ){
 				expectingAs = true;
 				peParser.setJoinType( JoinFragment.INNER_JOIN );
 				peParser.setUseThetaStyleJoin( false );
 				ParserHelper.parse( peParser, q.unalias( token ), ParserHelper.PATH_SEPARATORS, q );
 				if ( !peParser.isCollectionValued() ) throw new QueryException( "path expression did not resolve to collection: " + token );
 				collectionName = peParser.addFromCollection( q );
 				expectingPathExpression = false;
 				memberDeclarations = false;
 			}
 			else {
 
 				// handle a path expression or class name that
 				// appears at the start, in the "new" HQL
 				// style or an alias that appears at the start
 				// in the "old" HQL style
 
 				Queryable p = q.getEntityPersisterUsingImports( token );
 				if ( p != null ) {
 					// starts with the name of a mapped class (new style)
 					if ( joinType != NONE ) throw new QueryException( "outer or full join must be followed by path expression" );
 					entityName = q.createNameFor( p.getEntityName() );
 					q.addFromClass( entityName, p );
 					expectingAs = true;
 				}
 				else if ( token.indexOf( '.' ) < 0 ) {
 					// starts with an alias (old style)
 					// semi-bad thing about this: can't re-alias another alias.....
 					alias = token;
 					expectingIn = true;
 				}
 				else {
 
 					// starts with a path expression (new style)
 
 					// force HQL style: from Person p inner join p.cars c
 					//if (joinType==NONE) throw new QueryException("path expression must be preceded by full, left, right or inner join");
 
 					//allow ODMG OQL style: from Person p, p.cars c
 					if ( joinType != NONE ) {
 						peParser.setJoinType( joinType );
 					}
 					else {
 						peParser.setJoinType( JoinFragment.INNER_JOIN );
 					}
 					peParser.setUseThetaStyleJoin( q.isSubquery() );
 
 					ParserHelper.parse( peParser, q.unalias( token ), ParserHelper.PATH_SEPARATORS, q );
 					entityName = peParser.addFromAssociation( q );
 
 					joinType = NONE;
 					peParser.setJoinType( JoinFragment.INNER_JOIN );
 
 					if ( afterFetch ) {
 						peParser.fetch( q, entityName );
 						afterFetch = false;
 					}
 
 					expectingAs = true;
 
 				}
 			}
 		}
 
 	}
 
 	public void start(QueryTranslatorImpl q) {
 		entityName = null;
 		collectionName = null;
 		alias = null;
 		afterIn = false;
 		afterAs = false;
 		afterClass = false;
 		expectingJoin = false;
 		expectingIn = false;
 		expectingAs = false;
 		memberDeclarations = false;
 		expectingPathExpression = false;
 		afterMemberDeclarations = false;
 		joinType = NONE;
 	}
 
 	public void end(QueryTranslatorImpl q) {
 		if( afterMemberDeclarations ){
 			//The exception throwned by the AST query translator contains the error token location, respensent by line and colum, 
 			//but it hard to get that info here.
 			throw new QueryException("alias not specified for IN");
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/FromPathExpressionParser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/FromPathExpressionParser.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/FromPathExpressionParser.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/FromPathExpressionParser.java
index 10039c5a6f..c71fb72fed 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/FromPathExpressionParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/FromPathExpressionParser.java
@@ -1,54 +1,54 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 import org.hibernate.QueryException;
 import org.hibernate.persister.collection.CollectionPropertyNames;
 import org.hibernate.type.Type;
 
 public class FromPathExpressionParser extends PathExpressionParser {
 
 	public void end(QueryTranslatorImpl q) throws QueryException {
 		if ( !isCollectionValued() ) {
 			Type type = getPropertyType();
 			if ( type.isEntityType() ) {
 				// "finish off" the join
 				token( ".", q );
 				token( null, q );
 			}
 			else if ( type.isCollectionType() ) {
 				// default to element set if no elements() specified
 				token( ".", q );
 				token( CollectionPropertyNames.COLLECTION_ELEMENTS, q );
 			}
 		}
 		super.end( q );
 	}
 
 	protected void setExpectingCollectionIndex() throws QueryException {
 		throw new QueryException( "illegal syntax near collection-valued path expression in from: "  + getCollectionName() );
 	}
 
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/GroupByParser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/GroupByParser.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/GroupByParser.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/GroupByParser.java
index 0b57ac6662..b67c6ba1c4 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/GroupByParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/GroupByParser.java
@@ -1,75 +1,75 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 import org.hibernate.QueryException;
 import org.hibernate.internal.util.StringHelper;
 
 /**
  * Parses the GROUP BY clause of an aggregate query
  */
 public class GroupByParser implements Parser {
 
 	//this is basically a copy/paste of OrderByParser ... might be worth refactoring
 
 	// This uses a PathExpressionParser but notice that compound paths are not valid,
 	// only bare names and simple paths:
 
 	// SELECT p FROM p IN CLASS eg.Person GROUP BY p.Name, p.Address, p
 
 	// The reason for this is SQL doesn't let you sort by an expression you are
 	// not returning in the result set.
 
 	private final PathExpressionParser pathExpressionParser;
 
 	{
 		pathExpressionParser = new PathExpressionParser();
 		pathExpressionParser.setUseThetaStyleJoin( true ); //TODO: would be nice to use false, but issues with MS SQL
 	}
 
 	public void token(String token, QueryTranslatorImpl q) throws QueryException {
 
 		if ( q.isName( StringHelper.root( token ) ) ) {
 			ParserHelper.parse( pathExpressionParser, q.unalias( token ), ParserHelper.PATH_SEPARATORS, q );
 			q.appendGroupByToken( pathExpressionParser.getWhereColumn() );
 			pathExpressionParser.addAssociation( q );
 		}
 		else {
 			q.appendGroupByToken( token );
 		}
 	}
 
 	public void start(QueryTranslatorImpl q) throws QueryException {
 	}
 
 	public void end(QueryTranslatorImpl q) throws QueryException {
 	}
 
 
 }
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/HavingParser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/HavingParser.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/HavingParser.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/HavingParser.java
index 1719943f89..5b93fd8520 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/HavingParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/HavingParser.java
@@ -1,38 +1,38 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 
 
 /**
  * Parses the having clause of a hibernate query and translates it to an
  * SQL having clause.
  */
 public class HavingParser extends WhereParser {
 
 	void appendToken(QueryTranslatorImpl q, String token) {
 		q.appendHavingToken( token );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/OrderByParser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/OrderByParser.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/OrderByParser.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/OrderByParser.java
index 021c9fb826..347f83f0a6 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/OrderByParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/OrderByParser.java
@@ -1,72 +1,72 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 import org.hibernate.QueryException;
 import org.hibernate.internal.util.StringHelper;
 
 /**
  * Parses the ORDER BY clause of a query
  */
 
 public class OrderByParser implements Parser {
 
 	// This uses a PathExpressionParser but notice that compound paths are not valid,
 	// only bare names and simple paths:
 
 	// SELECT p FROM p IN CLASS eg.Person ORDER BY p.Name, p.Address, p
 
 	// The reason for this is SQL doesn't let you sort by an expression you are
 	// not returning in the result set.
 
 	private final PathExpressionParser pathExpressionParser;
 
 	{
 		pathExpressionParser = new PathExpressionParser();
 		pathExpressionParser.setUseThetaStyleJoin( true ); //TODO: would be nice to use false, but issues with MS SQL
 	}
 
 	public void token(String token, QueryTranslatorImpl q) throws QueryException {
 
 		if ( q.isName( StringHelper.root( token ) ) ) {
 			ParserHelper.parse( pathExpressionParser, q.unalias( token ), ParserHelper.PATH_SEPARATORS, q );
 			q.appendOrderByToken( pathExpressionParser.getWhereColumn() );
 			pathExpressionParser.addAssociation( q );
 		}
 		else if ( token.startsWith( ParserHelper.HQL_VARIABLE_PREFIX ) ) { //named query parameter
 			q.addNamedParameter( token.substring( 1 ) );
 			q.appendOrderByToken( "?" );
 		}
 		else {
 			q.appendOrderByToken( token );
 		}
 	}
 
 	public void start(QueryTranslatorImpl q) throws QueryException {
 	}
 
 	public void end(QueryTranslatorImpl q) throws QueryException {
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/Parser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/Parser.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/Parser.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/Parser.java
index e096366a29..0643d17a3b 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/Parser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/Parser.java
@@ -1,48 +1,48 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 import org.hibernate.QueryException;
 
 /**
  * A parser is a state machine that accepts a string of tokens,
  * bounded by start() and end() and modifies a QueryTranslator. Parsers
  * are NOT intended to be threadsafe. They SHOULD be reuseable
  * for more than one token stream.
  */
 
 public interface Parser {
 	public void token(String token, QueryTranslatorImpl q) throws QueryException;
 
 	public void start(QueryTranslatorImpl q) throws QueryException;
 
 	public void end(QueryTranslatorImpl q) throws QueryException;
 }
 
 
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/ParserHelper.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/ParserHelper.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/ParserHelper.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/ParserHelper.java
index 62bade6a19..df8ac48e25 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/ParserHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/ParserHelper.java
@@ -1,59 +1,59 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 import java.util.StringTokenizer;
 import org.hibernate.QueryException;
 import org.hibernate.internal.util.StringHelper;
 
 public final class ParserHelper {
 
 	public static final String HQL_VARIABLE_PREFIX = ":";
 
 	public static final String HQL_SEPARATORS = " \n\r\f\t,()=<>&|+-=/*'^![]#~\\";
 	//NOTICE: no " or . since they are part of (compound) identifiers
 	public static final String PATH_SEPARATORS = ".";
 
 	public static boolean isWhitespace(String str) {
 		return StringHelper.WHITESPACE.indexOf( str ) > -1;
 	}
 
 	private ParserHelper() {
 		//cannot instantiate
 	}
 
 	public static void parse(Parser p, String text, String seperators, QueryTranslatorImpl q) throws QueryException {
 		StringTokenizer tokens = new StringTokenizer( text, seperators, true );
 		p.start( q );
 		while ( tokens.hasMoreElements() ) p.token( tokens.nextToken(), q );
 		p.end( q );
 	}
 
 }
 
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/PathExpressionParser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/PathExpressionParser.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/PathExpressionParser.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/PathExpressionParser.java
index 92b210f9b2..d941857e14 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/PathExpressionParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/PathExpressionParser.java
@@ -1,524 +1,524 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 import java.util.LinkedList;
 import java.util.Map;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.engine.internal.JoinSequence;
-import org.hibernate.hql.CollectionSubqueryFactory;
+import org.hibernate.hql.internal.CollectionSubqueryFactory;
 import org.hibernate.persister.collection.CollectionPropertyMapping;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.PropertyMapping;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 /**
  * Parses an expression of the form foo.bar.baz and builds up an expression
  * involving two less table joins than there are path components.
  */
 public class PathExpressionParser implements Parser {
 
 	//TODO: this class does too many things! we need a different
 	//kind of path expression parser for each of the diffferent
 	//ways in which path expressions can occur
 
 	//We should actually rework this class to not implement Parser
 	//and just process path expressions in the most convenient way.
 
 	//The class is now way to complex!
 
 	private int dotcount;
 	private String currentName;
 	private String currentProperty;
 	private String oneToOneOwnerName;
 	private AssociationType ownerAssociationType;
 	private String[] columns;
 	private String collectionName;
 	private String collectionOwnerName;
 	private String collectionRole;
 	private final StringBuffer componentPath = new StringBuffer();
 	private Type type;
 	private final StringBuffer path = new StringBuffer();
 	private boolean ignoreInitialJoin;
 	private boolean continuation;
 	private int joinType = JoinFragment.INNER_JOIN; //default mode
 	private boolean useThetaStyleJoin = true;
 	private PropertyMapping currentPropertyMapping;
 	private JoinSequence joinSequence;
 
 	private boolean expectingCollectionIndex;
 	private LinkedList collectionElements = new LinkedList();
 
 	void setJoinType(int joinType) {
 		this.joinType = joinType;
 	}
 
 	void setUseThetaStyleJoin(boolean useThetaStyleJoin) {
 		this.useThetaStyleJoin = useThetaStyleJoin;
 	}
 
 	private void addJoin(String name, AssociationType joinableType) throws QueryException {
 		try {
 			joinSequence.addJoin( joinableType, name, joinType, currentColumns() );
 		}
 		catch ( MappingException me ) {
 			throw new QueryException( me );
 		}
 	}
 
 	private void addJoin(String name, AssociationType joinableType, String[] foreignKeyColumns) throws QueryException {
 		try {
 			joinSequence.addJoin( joinableType, name, joinType, foreignKeyColumns );
 		}
 		catch ( MappingException me ) {
 			throw new QueryException( me );
 		}
 	}
 
 	String continueFromManyToMany(String entityName, String[] joinColumns, QueryTranslatorImpl q) throws QueryException {
 		start( q );
 		continuation = true;
 		currentName = q.createNameFor( entityName );
 		q.addType( currentName, entityName );
 		Queryable classPersister = q.getEntityPersister( entityName );
 		//QueryJoinFragment join = q.createJoinFragment(useThetaStyleJoin);
 		addJoin( currentName, q.getFactory().getTypeResolver().getTypeFactory().manyToOne( entityName ), joinColumns );
 		currentPropertyMapping = classPersister;
 		return currentName;
 	}
 
 	public void ignoreInitialJoin() {
 		ignoreInitialJoin = true;
 	}
 
 	public void token(String token, QueryTranslatorImpl q) throws QueryException {
 
 		if ( token != null ) path.append( token );
 
 		String alias = q.getPathAlias( path.toString() );
 		if ( alias != null ) {
 			reset( q ); //reset the dotcount (but not the path)
 			currentName = alias; //after reset!
 			currentPropertyMapping = q.getPropertyMapping( currentName );
 			if ( !ignoreInitialJoin ) {
 				JoinSequence ojf = q.getPathJoin( path.toString() );
 				try {
 					joinSequence.addCondition( ojf.toJoinFragment( q.getEnabledFilters(), true ).toWhereFragmentString() ); //after reset!
 				}
 				catch ( MappingException me ) {
 					throw new QueryException( me );
 				}
 				// we don't need to worry about any condition in the ON clause
 				// here (toFromFragmentString), since anything in the ON condition
 				// is already applied to the whole query
 			}
 		}
 		else if ( ".".equals( token ) ) {
 			dotcount++;
 		}
 		else {
 			if ( dotcount == 0 ) {
 				if ( !continuation ) {
 					if ( !q.isName( token ) ) throw new QueryException( "undefined alias: " + token );
 					currentName = token;
 					currentPropertyMapping = q.getPropertyMapping( currentName );
 				}
 			}
 			else if ( dotcount == 1 ) {
 				if ( currentName != null ) {
 					currentProperty = token;
 				}
 				else if ( collectionName != null ) {
 					//processCollectionProperty(token, q.getCollectionPersister(collectionRole), collectionName);
 					continuation = false;
 				}
 				else {
 					throw new QueryException( "unexpected" );
 				}
 			}
 			else { // dotcount>=2
 
 				// Do the corresponding RHS
 				Type propertyType = getPropertyType();
 
 				if ( propertyType == null ) {
 					throw new QueryException( "unresolved property: " + path );
 				}
 
 				if ( propertyType.isComponentType() ) {
 					dereferenceComponent( token );
 				}
 				else if ( propertyType.isEntityType() ) {
 					if ( !isCollectionValued() ) dereferenceEntity( token, ( EntityType ) propertyType, q );
 				}
 				else if ( propertyType.isCollectionType() ) {
 					dereferenceCollection( token, ( ( CollectionType ) propertyType ).getRole(), q );
 
 				}
 				else {
 					if ( token != null ) throw new QueryException( "dereferenced: " + path );
 				}
 
 			}
 		}
 	}
 
 	private void dereferenceEntity(String propertyName, EntityType propertyType, QueryTranslatorImpl q)
 			throws QueryException {
 		//NOTE: we avoid joining to the next table if the named property is just the foreign key value
 
 		//if its "id"
 		boolean isIdShortcut = EntityPersister.ENTITY_ID.equals( propertyName ) &&
 				propertyType.isReferenceToPrimaryKey();
 
 		//or its the id property name
 		final String idPropertyName;
 		try {
 			idPropertyName = propertyType.getIdentifierOrUniqueKeyPropertyName( q.getFactory() );
 		}
 		catch ( MappingException me ) {
 			throw new QueryException( me );
 		}
 		boolean isNamedIdPropertyShortcut = idPropertyName != null
 				&& idPropertyName.equals( propertyName )
 				&& propertyType.isReferenceToPrimaryKey();
 
 
 		if ( isIdShortcut || isNamedIdPropertyShortcut ) {
 			// special shortcut for id properties, skip the join!
 			// this must only occur at the _end_ of a path expression
 			if ( componentPath.length() > 0 ) componentPath.append( '.' );
 			componentPath.append( propertyName );
 		}
 		else {
 			String entityClass = propertyType.getAssociatedEntityName();
 			String name = q.createNameFor( entityClass );
 			q.addType( name, entityClass );
 			addJoin( name, propertyType );
 			if ( propertyType.isOneToOne() ) oneToOneOwnerName = currentName;
 			ownerAssociationType = propertyType;
 			currentName = name;
 			currentProperty = propertyName;
 			q.addPathAliasAndJoin( path.substring( 0, path.toString().lastIndexOf( '.' ) ), name, joinSequence.copy() );
 			componentPath.setLength( 0 );
 			currentPropertyMapping = q.getEntityPersister( entityClass );
 		}
 	}
 
 	private void dereferenceComponent(String propertyName) {
 		if ( propertyName != null ) {
 			if ( componentPath.length() > 0 ) componentPath.append( '.' );
 			componentPath.append( propertyName );
 		}
 	}
 
 	private void dereferenceCollection(String propertyName, String role, QueryTranslatorImpl q) throws QueryException {
 		collectionRole = role;
 		QueryableCollection collPersister = q.getCollectionPersister( role );
 		String name = q.createNameForCollection( role );
 		addJoin( name, collPersister.getCollectionType() );
 		//if ( collPersister.hasWhere() ) join.addCondition( collPersister.getSQLWhereString(name) );
 		collectionName = name;
 		collectionOwnerName = currentName;
 		currentName = name;
 		currentProperty = propertyName;
 		componentPath.setLength( 0 );
 		currentPropertyMapping = new CollectionPropertyMapping( collPersister );
 	}
 
 	private String getPropertyPath() {
 		if ( currentProperty == null ) {
 			return EntityPersister.ENTITY_ID;
 		}
 		else {
 			if ( componentPath.length() > 0 ) {
 				return new StringBuffer()
 						.append( currentProperty )
 						.append( '.' )
 						.append( componentPath.toString() )
 						.toString();
 			}
 			else {
 				return currentProperty;
 			}
 		}
 	}
 
 	private PropertyMapping getPropertyMapping() {
 		return currentPropertyMapping;
 	}
 
 	private void setType() throws QueryException {
 		if ( currentProperty == null ) {
 			type = getPropertyMapping().getType();
 		}
 		else {
 			type = getPropertyType();
 		}
 	}
 
 	protected Type getPropertyType() throws QueryException {
 		String propertyPath = getPropertyPath();
 		Type propertyType = getPropertyMapping().toType( propertyPath );
 		if ( propertyType == null ) {
 			throw new QueryException( "could not resolve property type: " + propertyPath );
 		}
 		return propertyType;
 	}
 
 	protected String[] currentColumns() throws QueryException {
 		String propertyPath = getPropertyPath();
 		String[] propertyColumns = getPropertyMapping().toColumns( currentName, propertyPath );
 		if ( propertyColumns == null ) {
 			throw new QueryException( "could not resolve property columns: " + propertyPath );
 		}
 		return propertyColumns;
 	}
 
 	private void reset(QueryTranslatorImpl q) {
 		//join = q.createJoinFragment(useThetaStyleJoin);
 		dotcount = 0;
 		currentName = null;
 		currentProperty = null;
 		collectionName = null;
 		collectionRole = null;
 		componentPath.setLength( 0 );
 		type = null;
 		collectionName = null;
 		columns = null;
 		expectingCollectionIndex = false;
 		continuation = false;
 		currentPropertyMapping = null;
 	}
 
 	public void start(QueryTranslatorImpl q) {
 		if ( !continuation ) {
 			reset( q );
 			path.setLength( 0 );
 			joinSequence = new JoinSequence( q.getFactory() ).setUseThetaStyle( useThetaStyleJoin );
 		}
 	}
 
 	public void end(QueryTranslatorImpl q) throws QueryException {
 		ignoreInitialJoin = false;
 
 		Type propertyType = getPropertyType();
 		if ( propertyType != null && propertyType.isCollectionType() ) {
 			collectionRole = ( ( CollectionType ) propertyType ).getRole();
 			collectionName = q.createNameForCollection( collectionRole );
 			prepareForIndex( q );
 		}
 		else {
 			columns = currentColumns();
 			setType();
 		}
 
 		//important!!
 		continuation = false;
 
 	}
 
 	private void prepareForIndex(QueryTranslatorImpl q) throws QueryException {
 
 		QueryableCollection collPersister = q.getCollectionPersister( collectionRole );
 
 		if ( !collPersister.hasIndex() ) throw new QueryException( "unindexed collection before []: " + path );
 		String[] indexCols = collPersister.getIndexColumnNames();
 		if ( indexCols.length != 1 ) throw new QueryException( "composite-index appears in []: " + path );
 		//String[] keyCols = collPersister.getKeyColumnNames();
 
 		JoinSequence fromJoins = new JoinSequence( q.getFactory() )
 				.setUseThetaStyle( useThetaStyleJoin )
 				.setRoot( collPersister, collectionName )
 				.setNext( joinSequence.copy() );
 
 		if ( !continuation ) addJoin( collectionName, collPersister.getCollectionType() );
 
 		joinSequence.addCondition( collectionName + '.' + indexCols[0] + " = " ); //TODO: get SQL rendering out of here
 
 		CollectionElement elem = new CollectionElement();
 		elem.elementColumns = collPersister.getElementColumnNames(collectionName);
 		elem.elementType = collPersister.getElementType();
 		elem.isOneToMany = collPersister.isOneToMany();
 		elem.alias = collectionName;
 		elem.joinSequence = joinSequence;
 		collectionElements.addLast( elem );
 		setExpectingCollectionIndex();
 
 		q.addCollection( collectionName, collectionRole );
 		q.addFromJoinOnly( collectionName, fromJoins );
 	}
 
 	static final class CollectionElement {
 		Type elementType;
 		boolean isOneToMany;
 		String alias;
 		String[] elementColumns;
 		JoinSequence joinSequence;
 		StringBuffer indexValue = new StringBuffer();
 	}
 
 	public CollectionElement lastCollectionElement() {
 		return ( CollectionElement ) collectionElements.removeLast();
 	}
 
 	public void setLastCollectionElementIndexValue(String value) {
 		( ( CollectionElement ) collectionElements.getLast() ).indexValue.append( value );
 	}
 
 	public boolean isExpectingCollectionIndex() {
 		return expectingCollectionIndex;
 	}
 
 	protected void setExpectingCollectionIndex() throws QueryException {
 		expectingCollectionIndex = true;
 	}
 
 	public JoinSequence getWhereJoin() {
 		return joinSequence;
 	}
 
 	public String getWhereColumn() throws QueryException {
 		if ( columns.length != 1 ) {
 			throw new QueryException( "path expression ends in a composite value: " + path );
 		}
 		return columns[0];
 	}
 
 	public String[] getWhereColumns() {
 		return columns;
 	}
 
 	public Type getWhereColumnType() {
 		return type;
 	}
 
 	public String getName() {
 		return currentName == null ? collectionName : currentName;
 	}
 
 
 	public String getCollectionSubquery(Map enabledFilters) throws QueryException {
 		return CollectionSubqueryFactory.createCollectionSubquery( joinSequence, enabledFilters, currentColumns() );
 	}
 
 	public boolean isCollectionValued() throws QueryException {
 		//TODO: is there a better way?
 		return collectionName != null && !getPropertyType().isCollectionType();
 	}
 
 	public void addAssociation(QueryTranslatorImpl q) throws QueryException {
 		q.addJoin( getName(), joinSequence );
 	}
 
 	public String addFromAssociation(QueryTranslatorImpl q) throws QueryException {
 		if ( isCollectionValued() ) {
 			return addFromCollection( q );
 		}
 		else {
 			q.addFrom( currentName, joinSequence );
 			return currentName;
 		}
 	}
 
 	public String addFromCollection(QueryTranslatorImpl q) throws QueryException {
 		Type collectionElementType = getPropertyType();
 
 		if ( collectionElementType == null ) {
 			throw new QueryException( "must specify 'elements' for collection valued property in from clause: " + path );
 		}
 
 		if ( collectionElementType.isEntityType() ) {
 			// an association
 			QueryableCollection collectionPersister = q.getCollectionPersister( collectionRole );
 			Queryable entityPersister = ( Queryable ) collectionPersister.getElementPersister();
 			String clazz = entityPersister.getEntityName();
 
 			final String elementName;
 			if ( collectionPersister.isOneToMany() ) {
 				elementName = collectionName;
 				//allow index() function:
 				q.decoratePropertyMapping( elementName, collectionPersister );
 			}
 			else { //many-to-many
 				q.addCollection( collectionName, collectionRole );
 				elementName = q.createNameFor( clazz );
 				addJoin( elementName, ( AssociationType ) collectionElementType );
 			}
 			q.addFrom( elementName, clazz, joinSequence );
 			currentPropertyMapping = new CollectionPropertyMapping( collectionPersister );
 			return elementName;
 		}
 		else {
 			// collections of values
 			q.addFromCollection( collectionName, collectionRole, joinSequence );
 			return collectionName;
 		}
 
 	}
 
 	String getCollectionName() {
 		return collectionName;
 	}
 
 	String getCollectionRole() {
 		return collectionRole;
 	}
 
 	String getCollectionOwnerName() {
 		return collectionOwnerName;
 	}
 
 	String getOneToOneOwnerName() {
 		return oneToOneOwnerName;
 	}
 
 	AssociationType getOwnerAssociationType() {
 		return ownerAssociationType;
 	}
 
 	String getCurrentProperty() {
 		return currentProperty;
 	}
 
 	String getCurrentName() {
 		return currentName;
 	}
 
 	public void fetch(QueryTranslatorImpl q, String entityName) throws QueryException {
 		if ( isCollectionValued() ) {
 			q.setCollectionToFetch( getCollectionRole(), getCollectionName(), getCollectionOwnerName(), entityName );
 		}
 		else {
 			q.addEntityToFetch( entityName, getOneToOneOwnerName(), getOwnerAssociationType() );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/PreprocessingParser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/PreprocessingParser.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/PreprocessingParser.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/PreprocessingParser.java
index 1334107a08..c873c21430 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/PreprocessingParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/PreprocessingParser.java
@@ -1,155 +1,155 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import org.hibernate.QueryException;
-import org.hibernate.hql.CollectionProperties;
+import org.hibernate.hql.internal.CollectionProperties;
 import org.hibernate.internal.util.StringHelper;
 
 /**
  *
  */
 public class PreprocessingParser implements Parser {
 
 	private static final Set HQL_OPERATORS;
 
 	static {
 		HQL_OPERATORS = new HashSet();
 		HQL_OPERATORS.add( "<=" );
 		HQL_OPERATORS.add( ">=" );
 		HQL_OPERATORS.add( "=>" );
 		HQL_OPERATORS.add( "=<" );
 		HQL_OPERATORS.add( "!=" );
 		HQL_OPERATORS.add( "<>" );
 		HQL_OPERATORS.add( "!#" );
 		HQL_OPERATORS.add( "!~" );
 		HQL_OPERATORS.add( "!<" );
 		HQL_OPERATORS.add( "!>" );
 		HQL_OPERATORS.add( "is not" );
 		HQL_OPERATORS.add( "not like" );
 		HQL_OPERATORS.add( "not in" );
 		HQL_OPERATORS.add( "not between" );
 		HQL_OPERATORS.add( "not exists" );
 	}
 
 	private Map replacements;
 	private boolean quoted;
 	private StringBuffer quotedString;
 	private ClauseParser parser = new ClauseParser();
 	private String lastToken;
 	private String currentCollectionProp;
 
 	public PreprocessingParser(Map replacements) {
 		this.replacements = replacements;
 	}
 
 	public void token(String token, QueryTranslatorImpl q) throws QueryException {
 
 		//handle quoted strings
 		if ( quoted ) {
 			quotedString.append( token );
 		}
 		if ( "'".equals( token ) ) {
 			if ( quoted ) {
 				token = quotedString.toString();
 			}
 			else {
 				quotedString = new StringBuffer( 20 ).append( token );
 			}
 			quoted = !quoted;
 		}
 		if ( quoted ) return;
 
 		//ignore whitespace
 		if ( ParserHelper.isWhitespace( token ) ) return;
 
 		//do replacements
 		String substoken = ( String ) replacements.get( token );
 		token = ( substoken == null ) ? token : substoken;
 
 		//handle HQL2 collection syntax
 		if ( currentCollectionProp != null ) {
 			if ( "(".equals( token ) ) {
 				return;
 			}
 			else if ( ")".equals( token ) ) {
 				currentCollectionProp = null;
 				return;
 			}
 			else {
 				token = StringHelper.qualify( token, currentCollectionProp );
 			}
 		}
 		else {
 			String prop = CollectionProperties.getNormalizedPropertyName( token.toLowerCase() );
 			if ( prop != null ) {
 				currentCollectionProp = prop;
 				return;
 			}
 		}
 
 
 		//handle <=, >=, !=, is not, not between, not in
 		if ( lastToken == null ) {
 			lastToken = token;
 		}
 		else {
 			String doubleToken = ( token.length() > 1 ) ?
 					lastToken + ' ' + token :
 					lastToken + token;
 			if ( HQL_OPERATORS.contains( doubleToken.toLowerCase() ) ) {
 				parser.token( doubleToken, q );
 				lastToken = null;
 			}
 			else {
 				parser.token( lastToken, q );
 				lastToken = token;
 			}
 		}
 
 	}
 
 	public void start(QueryTranslatorImpl q) throws QueryException {
 		quoted = false;
 		parser.start( q );
 	}
 
 	public void end(QueryTranslatorImpl q) throws QueryException {
 		if ( lastToken != null ) parser.token( lastToken, q );
 		parser.end( q );
 		lastToken = null;
 		currentCollectionProp = null;
 	}
 
 }
 
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/QueryTranslatorImpl.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/QueryTranslatorImpl.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/QueryTranslatorImpl.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/QueryTranslatorImpl.java
index 0cfa051267..797e0b3273 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/QueryTranslatorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/QueryTranslatorImpl.java
@@ -1,1235 +1,1237 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.internal.JoinSequence;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.hql.internal.HolderInstantiator;
+import org.hibernate.hql.internal.NameGenerator;
+import org.hibernate.hql.spi.FilterTranslator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.spi.EventSource;
-import org.hibernate.hql.FilterTranslator;
-import org.hibernate.hql.HolderInstantiator;
-import org.hibernate.hql.NameGenerator;
-import org.hibernate.hql.ParameterTranslations;
+import org.hibernate.hql.spi.ParameterTranslations;
 import org.hibernate.internal.IteratorImpl;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.loader.BasicLoader;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.PropertyMapping;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.sql.QuerySelect;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 
 /**
  * An instance of <tt>QueryTranslator</tt> translates a Hibernate
  * query string to SQL.
  */
 public class QueryTranslatorImpl extends BasicLoader implements FilterTranslator {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, QueryTranslatorImpl.class.getName());
 
 	private static final String[] NO_RETURN_ALIASES = new String[] {};
 
 	private final String queryIdentifier;
 	private final String queryString;
 
 	private final Map typeMap = new LinkedHashMap();
 	private final Map collections = new LinkedHashMap();
 	private List returnedTypes = new ArrayList();
 	private final List fromTypes = new ArrayList();
 	private final List scalarTypes = new ArrayList();
 	private final Map namedParameters = new HashMap();
 	private final Map aliasNames = new HashMap();
 	private final Map oneToOneOwnerNames = new HashMap();
 	private final Map uniqueKeyOwnerReferences = new HashMap();
 	private final Map decoratedPropertyMappings = new HashMap();
 
 	private final List scalarSelectTokens = new ArrayList();
 	private final List whereTokens = new ArrayList();
 	private final List havingTokens = new ArrayList();
 	private final Map joins = new LinkedHashMap();
 	private final List orderByTokens = new ArrayList();
 	private final List groupByTokens = new ArrayList();
 	private final Set querySpaces = new HashSet();
 	private final Set entitiesToFetch = new HashSet();
 
 	private final Map pathAliases = new HashMap();
 	private final Map pathJoins = new HashMap();
 
 	private Queryable[] persisters;
 	private int[] owners;
 	private EntityType[] ownerAssociationTypes;
 	private String[] names;
 	private boolean[] includeInSelect;
 	private int selectLength;
 	private Type[] returnTypes;
 	private Type[] actualReturnTypes;
 	private String[][] scalarColumnNames;
 	private Map tokenReplacements;
 	private int nameCount = 0;
 	private int parameterCount = 0;
 	private boolean distinct = false;
 	private boolean compiled;
 	private String sqlString;
 	private Class holderClass;
 	private Constructor holderConstructor;
 	private boolean hasScalars;
 	private boolean shallowQuery;
 	private QueryTranslatorImpl superQuery;
 
 	private QueryableCollection collectionPersister;
 	private int collectionOwnerColumn = -1;
 	private String collectionOwnerName;
 	private String fetchName;
 
 	private String[] suffixes;
 
 	private Map enabledFilters;
 
 	/**
 	 * Construct a query translator
 	 *
 	 * @param queryIdentifier A unique identifier for the query of which this
 	 * translation is part; typically this is the original, user-supplied query string.
 	 * @param queryString The "preprocessed" query string; at the very least
-	 * already processed by {@link org.hibernate.hql.QuerySplitter}.
+	 * already processed by {@link org.hibernate.hql.internal.QuerySplitter}.
 	 * @param enabledFilters Any enabled filters.
 	 * @param factory The session factory.
 	 */
 	public QueryTranslatorImpl(
 			String queryIdentifier,
 	        String queryString,
 	        Map enabledFilters,
 	        SessionFactoryImplementor factory) {
 		super( factory );
 		this.queryIdentifier = queryIdentifier;
 		this.queryString = queryString;
 		this.enabledFilters = enabledFilters;
 	}
 
 	/**
 	 * Construct a query translator; this form used internally.
 	 *
 	 * @param queryString The query string to process.
 	 * @param enabledFilters Any enabled filters.
 	 * @param factory The session factory.
 	 */
 	public QueryTranslatorImpl(
 	        String queryString,
 	        Map enabledFilters,
 	        SessionFactoryImplementor factory) {
 		this( queryString, queryString, enabledFilters, factory );
 	}
 
 	/**
 	 * Compile a subquery.
 	 *
 	 * @param superquery The containing query of the query to be compiled.
 	 *
 	 * @throws org.hibernate.MappingException Indicates problems resolving
 	 * things referenced in the query.
 	 * @throws org.hibernate.QueryException Generally some form of syntatic
 	 * failure.
 	 */
 	void compile(QueryTranslatorImpl superquery) throws QueryException, MappingException {
 		this.tokenReplacements = superquery.tokenReplacements;
 		this.superQuery = superquery;
 		this.shallowQuery = true;
 		this.enabledFilters = superquery.getEnabledFilters();
 		compile();
 	}
 
 
 	/**
 	 * Compile a "normal" query. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 */
 	public synchronized void compile(
 			Map replacements,
 			boolean scalar) throws QueryException, MappingException {
 		if ( !compiled ) {
 			this.tokenReplacements = replacements;
 			this.shallowQuery = scalar;
 			compile();
 		}
 	}
 
 	/**
 	 * Compile a filter. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 */
 	public synchronized void compile(
 			String collectionRole,
 			Map replacements,
 			boolean scalar) throws QueryException, MappingException {
 
 		if ( !isCompiled() ) {
 			addFromAssociation( "this", collectionRole );
 			compile( replacements, scalar );
 		}
 	}
 
 	/**
 	 * Compile the query (generate the SQL).
 	 *
 	 * @throws org.hibernate.MappingException Indicates problems resolving
 	 * things referenced in the query.
 	 * @throws org.hibernate.QueryException Generally some form of syntatic
 	 * failure.
 	 */
 	private void compile() throws QueryException, MappingException {
 
         LOG.trace("Compiling query");
 		try {
 			ParserHelper.parse( new PreprocessingParser( tokenReplacements ),
 					queryString,
 					ParserHelper.HQL_SEPARATORS,
 					this );
 			renderSQL();
 		}
 		catch ( QueryException qe ) {
 			qe.setQueryString( queryString );
 			throw qe;
 		}
 		catch ( MappingException me ) {
 			throw me;
 		}
 		catch ( Exception e ) {
             LOG.debug("Unexpected query compilation problem", e);
 			e.printStackTrace();
 			QueryException qe = new QueryException( "Incorrect query syntax", e );
 			qe.setQueryString( queryString );
 			throw qe;
 		}
 
 		postInstantiate();
 
 		compiled = true;
 
 	}
 
 	@Override
     public String getSQLString() {
 		return sqlString;
 	}
 
 	public List collectSqlStrings() {
 		return ArrayHelper.toList( new String[] { sqlString } );
 	}
 
 	public String getQueryString() {
 		return queryString;
 	}
 
 	/**
 	 * Persisters for the return values of a <tt>find()</tt> style query.
 	 *
 	 * @return an array of <tt>EntityPersister</tt>s.
 	 */
 	@Override
     protected Loadable[] getEntityPersisters() {
 		return persisters;
 	}
 
 	/**
 	 * Types of the return values of an <tt>iterate()</tt> style query.
 	 *
 	 * @return an array of <tt>Type</tt>s.
 	 */
 	public Type[] getReturnTypes() {
 		return actualReturnTypes;
 	}
 
 	public String[] getReturnAliases() {
 		// return aliases not supported in classic translator!
 		return NO_RETURN_ALIASES;
 	}
 
 	public String[][] getColumnNames() {
 		return scalarColumnNames;
 	}
 
 	private static void logQuery(String hql, String sql) {
         if (LOG.isDebugEnabled()) {
             LOG.debugf("HQL: %s", hql);
             LOG.debugf("SQL: %s", sql);
 		}
 	}
 
 	void setAliasName(String alias, String name) {
 		aliasNames.put( alias, name );
 	}
 
 	public String getAliasName(String alias) {
 		String name = ( String ) aliasNames.get( alias );
 		if ( name == null ) {
 			if ( superQuery != null ) {
 				name = superQuery.getAliasName( alias );
 			}
 			else {
 				name = alias;
 			}
 		}
 		return name;
 	}
 
 	String unalias(String path) {
 		String alias = StringHelper.root( path );
 		String name = getAliasName( alias );
         if (name != null) return name + path.substring(alias.length());
         return path;
 	}
 
 	void addEntityToFetch(String name, String oneToOneOwnerName, AssociationType ownerAssociationType) {
 		addEntityToFetch( name );
 		if ( oneToOneOwnerName != null ) oneToOneOwnerNames.put( name, oneToOneOwnerName );
 		if ( ownerAssociationType != null ) uniqueKeyOwnerReferences.put( name, ownerAssociationType );
 	}
 
 	private void addEntityToFetch(String name) {
 		entitiesToFetch.add( name );
 	}
 
 	private int nextCount() {
 		return ( superQuery == null ) ? nameCount++ : superQuery.nameCount++;
 	}
 
 	String createNameFor(String type) {
 		return StringHelper.generateAlias( type, nextCount() );
 	}
 
 	String createNameForCollection(String role) {
 		return StringHelper.generateAlias( role, nextCount() );
 	}
 
 	private String getType(String name) {
 		String type = ( String ) typeMap.get( name );
 		if ( type == null && superQuery != null ) {
 			type = superQuery.getType( name );
 		}
 		return type;
 	}
 
 	private String getRole(String name) {
 		String role = ( String ) collections.get( name );
 		if ( role == null && superQuery != null ) {
 			role = superQuery.getRole( name );
 		}
 		return role;
 	}
 
 	boolean isName(String name) {
 		return aliasNames.containsKey( name ) ||
 				typeMap.containsKey( name ) ||
 				collections.containsKey( name ) || (
 				superQuery != null && superQuery.isName( name )
 				);
 	}
 
 	PropertyMapping getPropertyMapping(String name) throws QueryException {
 		PropertyMapping decorator = getDecoratedPropertyMapping( name );
 		if ( decorator != null ) return decorator;
 
 		String type = getType( name );
 		if ( type == null ) {
 			String role = getRole( name );
 			if ( role == null ) {
 				throw new QueryException( "alias not found: " + name );
 			}
 			return getCollectionPersister( role ); //.getElementPropertyMapping();
 		}
 		else {
 			Queryable persister = getEntityPersister( type );
 			if ( persister == null ) throw new QueryException( "persistent class not found: " + type );
 			return persister;
 		}
 	}
 
 	private PropertyMapping getDecoratedPropertyMapping(String name) {
 		return ( PropertyMapping ) decoratedPropertyMappings.get( name );
 	}
 
 	void decoratePropertyMapping(String name, PropertyMapping mapping) {
 		decoratedPropertyMappings.put( name, mapping );
 	}
 
 	private Queryable getEntityPersisterForName(String name) throws QueryException {
 		String type = getType( name );
 		Queryable persister = getEntityPersister( type );
 		if ( persister == null ) throw new QueryException( "persistent class not found: " + type );
 		return persister;
 	}
 
 	Queryable getEntityPersisterUsingImports(String className) {
 		final String importedClassName = getFactory().getImportedClassName( className );
 		if ( importedClassName == null ) {
 			return null;
 		}
 		try {
 			return ( Queryable ) getFactory().getEntityPersister( importedClassName );
 		}
 		catch ( MappingException me ) {
 			return null;
 		}
 	}
 
 	Queryable getEntityPersister(String entityName) throws QueryException {
 		try {
 			return ( Queryable ) getFactory().getEntityPersister( entityName );
 		}
 		catch ( Exception e ) {
 			throw new QueryException( "persistent class not found: " + entityName );
 		}
 	}
 
 	QueryableCollection getCollectionPersister(String role) throws QueryException {
 		try {
 			return ( QueryableCollection ) getFactory().getCollectionPersister( role );
 		}
 		catch ( ClassCastException cce ) {
 			throw new QueryException( "collection role is not queryable: " + role );
 		}
 		catch ( Exception e ) {
 			throw new QueryException( "collection role not found: " + role );
 		}
 	}
 
 	void addType(String name, String type) {
 		typeMap.put( name, type );
 	}
 
 	void addCollection(String name, String role) {
 		collections.put( name, role );
 	}
 
 	void addFrom(String name, String type, JoinSequence joinSequence)
 			throws QueryException {
 		addType( name, type );
 		addFrom( name, joinSequence );
 	}
 
 	void addFromCollection(String name, String collectionRole, JoinSequence joinSequence)
 			throws QueryException {
 		//register collection role
 		addCollection( name, collectionRole );
 		addJoin( name, joinSequence );
 	}
 
 	void addFrom(String name, JoinSequence joinSequence)
 			throws QueryException {
 		fromTypes.add( name );
 		addJoin( name, joinSequence );
 	}
 
 	void addFromClass(String name, Queryable classPersister)
 			throws QueryException {
 		JoinSequence joinSequence = new JoinSequence( getFactory() )
 				.setRoot( classPersister, name );
 		//crossJoins.add(name);
 		addFrom( name, classPersister.getEntityName(), joinSequence );
 	}
 
 	void addSelectClass(String name) {
 		returnedTypes.add( name );
 	}
 
 	void addSelectScalar(Type type) {
 		scalarTypes.add( type );
 	}
 
 	void appendWhereToken(String token) {
 		whereTokens.add( token );
 	}
 
 	void appendHavingToken(String token) {
 		havingTokens.add( token );
 	}
 
 	void appendOrderByToken(String token) {
 		orderByTokens.add( token );
 	}
 
 	void appendGroupByToken(String token) {
 		groupByTokens.add( token );
 	}
 
 	void appendScalarSelectToken(String token) {
 		scalarSelectTokens.add( token );
 	}
 
 	void appendScalarSelectTokens(String[] tokens) {
 		scalarSelectTokens.add( tokens );
 	}
 
 	void addFromJoinOnly(String name, JoinSequence joinSequence) throws QueryException {
 		addJoin( name, joinSequence.getFromPart() );
 	}
 
 	void addJoin(String name, JoinSequence joinSequence) throws QueryException {
 		if ( !joins.containsKey( name ) ) joins.put( name, joinSequence );
 	}
 
 	void addNamedParameter(String name) {
 		if ( superQuery != null ) superQuery.addNamedParameter( name );
 		Integer loc = new Integer( parameterCount++ );
 		Object o = namedParameters.get( name );
 		if ( o == null ) {
 			namedParameters.put( name, loc );
 		}
 		else if ( o instanceof Integer ) {
 			ArrayList list = new ArrayList( 4 );
 			list.add( o );
 			list.add( loc );
 			namedParameters.put( name, list );
 		}
 		else {
 			( ( ArrayList ) o ).add( loc );
 		}
 	}
 
 	@Override
     public int[] getNamedParameterLocs(String name) throws QueryException {
 		Object o = namedParameters.get( name );
 		if ( o == null ) {
 			QueryException qe = new QueryException( ERROR_NAMED_PARAMETER_DOES_NOT_APPEAR + name );
 			qe.setQueryString( queryString );
 			throw qe;
 		}
 		if ( o instanceof Integer ) {
 			return new int[]{ ( ( Integer ) o ).intValue() };
 		}
 		else {
 			return ArrayHelper.toIntArray( ( ArrayList ) o );
 		}
 	}
 
 	private void renderSQL() throws QueryException, MappingException {
 
 		final int rtsize;
 		if ( returnedTypes.size() == 0 && scalarTypes.size() == 0 ) {
 			//ie no select clause in HQL
 			returnedTypes = fromTypes;
 			rtsize = returnedTypes.size();
 		}
 		else {
 			rtsize = returnedTypes.size();
 			Iterator iter = entitiesToFetch.iterator();
 			while ( iter.hasNext() ) {
 				returnedTypes.add( iter.next() );
 			}
 		}
 		int size = returnedTypes.size();
 		persisters = new Queryable[size];
 		names = new String[size];
 		owners = new int[size];
 		ownerAssociationTypes = new EntityType[size];
 		suffixes = new String[size];
 		includeInSelect = new boolean[size];
 		for ( int i = 0; i < size; i++ ) {
 			String name = ( String ) returnedTypes.get( i );
 			//if ( !isName(name) ) throw new QueryException("unknown type: " + name);
 			persisters[i] = getEntityPersisterForName( name );
 			// TODO: cannot use generateSuffixes() - it handles the initial suffix differently.
 			suffixes[i] = ( size == 1 ) ? "" : Integer.toString( i ) + '_';
 			names[i] = name;
 			includeInSelect[i] = !entitiesToFetch.contains( name );
 			if ( includeInSelect[i] ) selectLength++;
 			if ( name.equals( collectionOwnerName ) ) collectionOwnerColumn = i;
 			String oneToOneOwner = ( String ) oneToOneOwnerNames.get( name );
 			owners[i] = ( oneToOneOwner == null ) ? -1 : returnedTypes.indexOf( oneToOneOwner );
 			ownerAssociationTypes[i] = (EntityType) uniqueKeyOwnerReferences.get( name );
 		}
 
 		if ( ArrayHelper.isAllNegative( owners ) ) owners = null;
 
 		String scalarSelect = renderScalarSelect(); //Must be done here because of side-effect! yuck...
 
 		int scalarSize = scalarTypes.size();
 		hasScalars = scalarTypes.size() != rtsize;
 
 		returnTypes = new Type[scalarSize];
 		for ( int i = 0; i < scalarSize; i++ ) {
 			returnTypes[i] = ( Type ) scalarTypes.get( i );
 		}
 
 		QuerySelect sql = new QuerySelect( getFactory().getDialect() );
 		sql.setDistinct( distinct );
 
 		if ( !shallowQuery ) {
 			renderIdentifierSelect( sql );
 			renderPropertiesSelect( sql );
 		}
 
 		if ( collectionPersister != null ) {
 			sql.addSelectFragmentString( collectionPersister.selectFragment( fetchName, "__" ) );
 		}
 
 		if ( hasScalars || shallowQuery ) sql.addSelectFragmentString( scalarSelect );
 
 		//TODO: for some dialects it would be appropriate to add the renderOrderByPropertiesSelect() to other select strings
 		mergeJoins( sql.getJoinFragment() );
 
 		sql.setWhereTokens( whereTokens.iterator() );
 
 		sql.setGroupByTokens( groupByTokens.iterator() );
 		sql.setHavingTokens( havingTokens.iterator() );
 		sql.setOrderByTokens( orderByTokens.iterator() );
 
 		if ( collectionPersister != null && collectionPersister.hasOrdering() ) {
 			sql.addOrderBy( collectionPersister.getSQLOrderByString( fetchName ) );
 		}
 
 		scalarColumnNames = NameGenerator.generateColumnNames( returnTypes, getFactory() );
 
 		// initialize the Set of queried identifier spaces (ie. tables)
 		Iterator iter = collections.values().iterator();
 		while ( iter.hasNext() ) {
 			CollectionPersister p = getCollectionPersister( ( String ) iter.next() );
 			addQuerySpaces( p.getCollectionSpaces() );
 		}
 		iter = typeMap.keySet().iterator();
 		while ( iter.hasNext() ) {
 			Queryable p = getEntityPersisterForName( ( String ) iter.next() );
 			addQuerySpaces( p.getQuerySpaces() );
 		}
 
 		sqlString = sql.toQueryString();
 
 		if ( holderClass != null ) holderConstructor = ReflectHelper.getConstructor( holderClass, returnTypes );
 
 		if ( hasScalars ) {
 			actualReturnTypes = returnTypes;
 		}
 		else {
 			actualReturnTypes = new Type[selectLength];
 			int j = 0;
 			for ( int i = 0; i < persisters.length; i++ ) {
 				if ( includeInSelect[i] ) {
 					actualReturnTypes[j++] = getFactory().getTypeResolver()
 							.getTypeFactory()
 							.manyToOne( persisters[i].getEntityName(), shallowQuery );
 				}
 			}
 		}
 
 	}
 
 	private void renderIdentifierSelect(QuerySelect sql) {
 		int size = returnedTypes.size();
 
 		for ( int k = 0; k < size; k++ ) {
 			String name = ( String ) returnedTypes.get( k );
 			String suffix = size == 1 ? "" : Integer.toString( k ) + '_';
 			sql.addSelectFragmentString( persisters[k].identifierSelectFragment( name, suffix ) );
 		}
 
 	}
 
 	/*private String renderOrderByPropertiesSelect() {
 		StringBuffer buf = new StringBuffer(10);
 
 		//add the columns we are ordering by to the select ID select clause
 		Iterator iter = orderByTokens.iterator();
 		while ( iter.hasNext() ) {
 			String token = (String) iter.next();
 			if ( token.lastIndexOf(".") > 0 ) {
 				//ie. it is of form "foo.bar", not of form "asc" or "desc"
 				buf.append(StringHelper.COMMA_SPACE).append(token);
 			}
 		}
 
 		return buf.toString();
 	}*/
 
 	private void renderPropertiesSelect(QuerySelect sql) {
 		int size = returnedTypes.size();
 		for ( int k = 0; k < size; k++ ) {
 			String suffix = size == 1 ? "" : Integer.toString( k ) + '_';
 			String name = ( String ) returnedTypes.get( k );
 			sql.addSelectFragmentString( persisters[k].propertySelectFragment( name, suffix, false ) );
 		}
 	}
 
 	/**
 	 * WARNING: side-effecty
 	 */
 	private String renderScalarSelect() {
 
 		boolean isSubselect = superQuery != null;
 
 		StringBuffer buf = new StringBuffer( 20 );
 
 		if ( scalarTypes.size() == 0 ) {
 			//ie. no select clause
 			int size = returnedTypes.size();
 			for ( int k = 0; k < size; k++ ) {
 
 				scalarTypes.add(
 						getFactory().getTypeResolver().getTypeFactory().manyToOne( persisters[k].getEntityName(), shallowQuery )
 				);
 
 				String[] idColumnNames = persisters[k].getIdentifierColumnNames();
 				for ( int i = 0; i < idColumnNames.length; i++ ) {
 					buf.append( returnedTypes.get( k ) ).append( '.' ).append( idColumnNames[i] );
 					if ( !isSubselect ) buf.append( " as " ).append( NameGenerator.scalarName( k, i ) );
 					if ( i != idColumnNames.length - 1 || k != size - 1 ) buf.append( ", " );
 				}
 
 			}
 
 		}
 		else {
 			//there _was_ a select clause
 			Iterator iter = scalarSelectTokens.iterator();
 			int c = 0;
 			boolean nolast = false; //real hacky...
 			int parenCount = 0; // used to count the nesting of parentheses
 			while ( iter.hasNext() ) {
 				Object next = iter.next();
 				if ( next instanceof String ) {
 					String token = ( String ) next;
 
 					if ( "(".equals( token ) ) {
 						parenCount++;
 					}
 					else if ( ")".equals( token ) ) {
 						parenCount--;
 					}
 
 					String lc = token.toLowerCase();
 					if ( lc.equals( ", " ) ) {
 						if ( nolast ) {
 							nolast = false;
 						}
 						else {
 							if ( !isSubselect && parenCount == 0 ) {
 								int x = c++;
 								buf.append( " as " )
 										.append( NameGenerator.scalarName( x, 0 ) );
 							}
 						}
 					}
 					buf.append( token );
 					if ( lc.equals( "distinct" ) || lc.equals( "all" ) ) {
 						buf.append( ' ' );
 					}
 				}
 				else {
 					nolast = true;
 					String[] tokens = ( String[] ) next;
 					for ( int i = 0; i < tokens.length; i++ ) {
 						buf.append( tokens[i] );
 						if ( !isSubselect ) {
 							buf.append( " as " )
 									.append( NameGenerator.scalarName( c, i ) );
 						}
 						if ( i != tokens.length - 1 ) buf.append( ", " );
 					}
 					c++;
 				}
 			}
 			if ( !isSubselect && !nolast ) {
 				int x = c++;
 				buf.append( " as " )
 						.append( NameGenerator.scalarName( x, 0 ) );
 			}
 
 		}
 
 		return buf.toString();
 	}
 
 	private void mergeJoins(JoinFragment ojf) throws MappingException, QueryException {
 
 		Iterator iter = joins.entrySet().iterator();
 		while ( iter.hasNext() ) {
 			Map.Entry me = ( Map.Entry ) iter.next();
 			String name = ( String ) me.getKey();
 			JoinSequence join = ( JoinSequence ) me.getValue();
 			join.setSelector( new JoinSequence.Selector() {
 				public boolean includeSubclasses(String alias) {
 					boolean include = returnedTypes.contains( alias ) && !isShallowQuery();
 					return include;
 				}
 			} );
 
 			if ( typeMap.containsKey( name ) ) {
 				ojf.addFragment( join.toJoinFragment( enabledFilters, true ) );
 			}
 			else if ( collections.containsKey( name ) ) {
 				ojf.addFragment( join.toJoinFragment( enabledFilters, true ) );
 			}
 			else {
 				//name from a super query (a bit inelegant that it shows up here)
 			}
 
 		}
 
 	}
 
 	public final Set getQuerySpaces() {
 		return querySpaces;
 	}
 
 	/**
 	 * Is this query called by scroll() or iterate()?
 	 *
 	 * @return true if it is, false if it is called by find() or list()
 	 */
 	boolean isShallowQuery() {
 		return shallowQuery;
 	}
 
 	void addQuerySpaces(Serializable[] spaces) {
 		for ( int i = 0; i < spaces.length; i++ ) {
 			querySpaces.add( spaces[i] );
 		}
 		if ( superQuery != null ) superQuery.addQuerySpaces( spaces );
 	}
 
 	void setDistinct(boolean distinct) {
 		this.distinct = distinct;
 	}
 
 	boolean isSubquery() {
 		return superQuery != null;
 	}
 
 	/**
 	 * Overrides method from Loader
 	 */
 	@Override
     public CollectionPersister[] getCollectionPersisters() {
 		return collectionPersister == null ? null : new CollectionPersister[] { collectionPersister };
 	}
 
 	@Override
     protected String[] getCollectionSuffixes() {
 		return collectionPersister == null ? null : new String[] { "__" };
 	}
 
 	void setCollectionToFetch(String role, String name, String ownerName, String entityName)
 			throws QueryException {
 		fetchName = name;
 		collectionPersister = getCollectionPersister( role );
 		collectionOwnerName = ownerName;
 		if ( collectionPersister.getElementType().isEntityType() ) {
 			addEntityToFetch( entityName );
 		}
 	}
 
 	@Override
     protected String[] getSuffixes() {
 		return suffixes;
 	}
 
 	@Override
     protected String[] getAliases() {
 		return names;
 	}
 
 	/**
 	 * Used for collection filters
 	 */
 	private void addFromAssociation(final String elementName, final String collectionRole)
 			throws QueryException {
 		//q.addCollection(collectionName, collectionRole);
 		QueryableCollection persister = getCollectionPersister( collectionRole );
 		Type collectionElementType = persister.getElementType();
 		if ( !collectionElementType.isEntityType() ) {
 			throw new QueryException( "collection of values in filter: " + elementName );
 		}
 
 		String[] keyColumnNames = persister.getKeyColumnNames();
 		//if (keyColumnNames.length!=1) throw new QueryException("composite-key collection in filter: " + collectionRole);
 
 		String collectionName;
 		JoinSequence join = new JoinSequence( getFactory() );
 		collectionName = persister.isOneToMany() ?
 				elementName :
 				createNameForCollection( collectionRole );
 		join.setRoot( persister, collectionName );
 		if ( !persister.isOneToMany() ) {
 			//many-to-many
 			addCollection( collectionName, collectionRole );
 			try {
 				join.addJoin( ( AssociationType ) persister.getElementType(),
 						elementName,
 						JoinFragment.INNER_JOIN,
 						persister.getElementColumnNames(collectionName) );
 			}
 			catch ( MappingException me ) {
 				throw new QueryException( me );
 			}
 		}
 		join.addCondition( collectionName, keyColumnNames, " = ?" );
 		//if ( persister.hasWhere() ) join.addCondition( persister.getSQLWhereString(collectionName) );
 		EntityType elemType = ( EntityType ) collectionElementType;
 		addFrom( elementName, elemType.getAssociatedEntityName(), join );
 
 	}
 
 	String getPathAlias(String path) {
 		return ( String ) pathAliases.get( path );
 	}
 
 	JoinSequence getPathJoin(String path) {
 		return ( JoinSequence ) pathJoins.get( path );
 	}
 
 	void addPathAliasAndJoin(String path, String alias, JoinSequence joinSequence) {
 		pathAliases.put( path, alias );
 		pathJoins.put( path, joinSequence );
 	}
 
 	public List list(SessionImplementor session, QueryParameters queryParameters)
 			throws HibernateException {
 		return list( session, queryParameters, getQuerySpaces(), actualReturnTypes );
 	}
 
 	/**
 	 * Return the query results as an iterator
 	 */
 	public Iterator iterate(QueryParameters queryParameters, EventSource session)
 			throws HibernateException {
 
 		boolean stats = session.getFactory().getStatistics().isStatisticsEnabled();
 		long startTime = 0;
 		if ( stats ) startTime = System.currentTimeMillis();
 
 		try {
 
 			PreparedStatement st = prepareQueryStatement( queryParameters, false, session );
 			ResultSet rs = getResultSet( st, queryParameters.hasAutoDiscoverScalarTypes(), false, queryParameters.getRowSelection(), session );
 			HolderInstantiator hi = HolderInstantiator.createClassicHolderInstantiator(holderConstructor, queryParameters.getResultTransformer());
 			Iterator result = new IteratorImpl( rs, st, session, queryParameters.isReadOnly( session ), returnTypes, getColumnNames(), hi );
 
 			if ( stats ) {
 				session.getFactory().getStatisticsImplementor().queryExecuted(
 						"HQL: " + queryString,
 						0,
 						System.currentTimeMillis() - startTime
 					);
 			}
 
 			return result;
 
 		}
 		catch ( SQLException sqle ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not execute query using iterate",
 					getSQLString()
 				);
 		}
 
 	}
 
 	public int executeUpdate(QueryParameters queryParameters, SessionImplementor session) throws HibernateException {
 		throw new UnsupportedOperationException( "Not supported!  Use the AST translator...");
 	}
 
 	@Override
     protected boolean[] includeInResultRow() {
 		boolean[] isResultReturned = includeInSelect;
 		if ( hasScalars ) {
 			isResultReturned = new boolean[ returnedTypes.size() ];
 			Arrays.fill( isResultReturned, true );
 		}
 		return isResultReturned;
 	}
 
 
 	@Override
     protected ResultTransformer resolveResultTransformer(ResultTransformer resultTransformer) {
 		return HolderInstantiator.resolveClassicResultTransformer(
 				holderConstructor,
 				resultTransformer
 		);
 	}
 
 	@Override
     protected Object getResultColumnOrRow(Object[] row, ResultTransformer transformer, ResultSet rs, SessionImplementor session)
 			throws SQLException, HibernateException {
 		Object[] resultRow = getResultRow( row, rs, session );
 		return ( holderClass == null && resultRow.length == 1 ?
 				resultRow[ 0 ] :
 				resultRow
 		);
 	}
 
 	@Override
     protected Object[] getResultRow(Object[] row, ResultSet rs, SessionImplementor session)
 			throws SQLException, HibernateException {
 		Object[] resultRow;
 		if ( hasScalars ) {
 			String[][] scalarColumns = getColumnNames();
 			int queryCols = returnTypes.length;
 			resultRow = new Object[queryCols];
 			for ( int i = 0; i < queryCols; i++ ) {
 				resultRow[i] = returnTypes[i].nullSafeGet( rs, scalarColumns[i], session, null );
 			}
 		}
 		else {
 			resultRow = toResultRow( row );
 		}
 		return resultRow;
 	}
 
 	@Override
     protected List getResultList(List results, ResultTransformer resultTransformer) throws QueryException {
 		if ( holderClass != null ) {
 			for ( int i = 0; i < results.size(); i++ ) {
 				Object[] row = ( Object[] ) results.get( i );
 				try {
 					results.set( i, holderConstructor.newInstance( row ) );
 				}
 				catch ( Exception e ) {
 					throw new QueryException( "could not instantiate: " + holderClass, e );
 				}
 			}
 		}
 		return results;
 	}
 
 	private Object[] toResultRow(Object[] row) {
 		if ( selectLength == row.length ) {
 			return row;
 		}
 		else {
 			Object[] result = new Object[selectLength];
 			int j = 0;
 			for ( int i = 0; i < row.length; i++ ) {
 				if ( includeInSelect[i] ) result[j++] = row[i];
 			}
 			return result;
 		}
 	}
 
 	void setHolderClass(Class clazz) {
 		holderClass = clazz;
 	}
 
 	@Override
     protected LockMode[] getLockModes(LockOptions lockOptions) {
 
 		// unfortunately this stuff can't be cached because
 		// it is per-invocation, not constant for the
 		// QueryTranslator instance
 		HashMap nameLockOptions = new HashMap();
 		if ( lockOptions == null) {
 			lockOptions = LockOptions.NONE;
 		}
 
 		if ( lockOptions.getAliasLockCount() > 0 ) {
 			Iterator iter = lockOptions.getAliasLockIterator();
 			while ( iter.hasNext() ) {
 				Map.Entry me = ( Map.Entry ) iter.next();
 				nameLockOptions.put( getAliasName( ( String ) me.getKey() ),
 						me.getValue() );
 			}
 		}
 		LockMode[] lockModesArray = new LockMode[names.length];
 		for ( int i = 0; i < names.length; i++ ) {
 			LockMode lm = ( LockMode ) nameLockOptions.get( names[i] );
 			//if ( lm == null ) lm = LockOptions.NONE;
 			if ( lm == null ) lm = lockOptions.getLockMode();
 			lockModesArray[i] = lm;
 		}
 		return lockModesArray;
 	}
 
 	@Override
     protected String applyLocks(String sql, LockOptions lockOptions, Dialect dialect) throws QueryException {
 		// can't cache this stuff either (per-invocation)
 		final String result;
 		if ( lockOptions == null ||
 			( lockOptions.getLockMode() == LockMode.NONE && lockOptions.getAliasLockCount() == 0 ) ) {
 			return sql;
 		}
 		else {
 			LockOptions locks = new LockOptions();
 			locks.setLockMode(lockOptions.getLockMode());
 			locks.setTimeOut(lockOptions.getTimeOut());
 			locks.setScope(lockOptions.getScope());
 			Iterator iter = lockOptions.getAliasLockIterator();
 			while ( iter.hasNext() ) {
 				Map.Entry me = ( Map.Entry ) iter.next();
 				locks.setAliasSpecificLockMode( getAliasName( ( String ) me.getKey() ), (LockMode) me.getValue() );
 			}
 			Map keyColumnNames = null;
 			if ( dialect.forUpdateOfColumns() ) {
 				keyColumnNames = new HashMap();
 				for ( int i = 0; i < names.length; i++ ) {
 					keyColumnNames.put( names[i], persisters[i].getIdentifierColumnNames() );
 				}
 			}
 			result = dialect.applyLocksToSql( sql, locks, keyColumnNames );
 		}
 		logQuery( queryString, result );
 		return result;
 	}
 
 	@Override
     protected boolean upgradeLocks() {
 		return true;
 	}
 
 	@Override
     protected int[] getCollectionOwners() {
 		return new int[] { collectionOwnerColumn };
 	}
 
 	protected boolean isCompiled() {
 		return compiled;
 	}
 
 	@Override
     public String toString() {
 		return queryString;
 	}
 
 	@Override
     protected int[] getOwners() {
 		return owners;
 	}
 
 	@Override
     protected EntityType[] getOwnerAssociationTypes() {
 		return ownerAssociationTypes;
 	}
 
 	public Class getHolderClass() {
 		return holderClass;
 	}
 
 	public Map getEnabledFilters() {
 		return enabledFilters;
 	}
 
 	public ScrollableResults scroll(final QueryParameters queryParameters,
 									final SessionImplementor session)
 			throws HibernateException {
-		HolderInstantiator hi = HolderInstantiator.createClassicHolderInstantiator(holderConstructor, queryParameters.getResultTransformer());
+		HolderInstantiator hi = HolderInstantiator.createClassicHolderInstantiator(
+				holderConstructor, queryParameters.getResultTransformer()
+		);
 		return scroll( queryParameters, returnTypes, hi, session );
 	}
 
 	@Override
     public String getQueryIdentifier() {
 		return queryIdentifier;
 	}
 
 	@Override
     protected boolean isSubselectLoadingEnabled() {
 		return hasSubselectLoadableCollections();
 	}
 
 	public void validateScrollability() throws HibernateException {
 		// This is the legacy behaviour for HQL queries...
 		if ( getCollectionPersisters() != null ) {
 			throw new HibernateException( "Cannot scroll queries which initialize collections" );
 		}
 	}
 
 	public boolean containsCollectionFetches() {
 		return false;
 	}
 
 	public boolean isManipulationStatement() {
 		// classic parser does not support bulk manipulation statements
 		return false;
 	}
 
 	@Override
 	public Class getDynamicInstantiationResultType() {
 		return holderClass;
 	}
 
 	public ParameterTranslations getParameterTranslations() {
 		return new ParameterTranslations() {
 
 			public boolean supportsOrdinalParameterMetadata() {
 				// classic translator does not support collection of ordinal
 				// param metadata
 				return false;
 			}
 
 			public int getOrdinalParameterCount() {
 				return 0; // not known!
 			}
 
 			public int getOrdinalParameterSqlLocation(int ordinalPosition) {
 				return 0; // not known!
 			}
 
 			public Type getOrdinalParameterExpectedType(int ordinalPosition) {
 				return null; // not known!
 			}
 
 			public Set getNamedParameterNames() {
 				return namedParameters.keySet();
 			}
 
 			public int[] getNamedParameterSqlLocations(String name) {
 				return getNamedParameterLocs( name );
 			}
 
 			public Type getNamedParameterExpectedType(String name) {
 				return null; // not known!
 			}
 		};
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/SelectParser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/SelectParser.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/SelectParser.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/SelectParser.java
index fa1cf3f9ab..f5819addc7 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/SelectParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/SelectParser.java
@@ -1,255 +1,255 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
 
 import org.hibernate.QueryException;
 import org.hibernate.dialect.function.SQLFunction;
-import org.hibernate.hql.QuerySplitter;
+import org.hibernate.hql.internal.QuerySplitter;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.Type;
 
 /**
  * Parsers the select clause of a Hibernate query.
  *
  * @author Gavin King, David Channon
  */
 public class SelectParser implements Parser {
 
 	//TODO: arithmetic expressions, multiple new Foo(...)
 
 	private static final Set COUNT_MODIFIERS = new HashSet();
 
 	static {
 		COUNT_MODIFIERS.add( "distinct" );
 		COUNT_MODIFIERS.add( "all" );
 		COUNT_MODIFIERS.add( "*" );
 	}
 
 	private LinkedList aggregateFuncTokenList = new LinkedList();
 
 	private boolean ready;
 	private boolean aggregate;
 	private boolean first;
 	private boolean afterNew;
 	private boolean insideNew;
 	private boolean aggregateAddSelectScalar;
 	private Class holderClass;
 
 	private final SelectPathExpressionParser pathExpressionParser;
 	private final PathExpressionParser aggregatePathExpressionParser;
 
 	{
 		pathExpressionParser = new SelectPathExpressionParser();
 		aggregatePathExpressionParser = new PathExpressionParser();
 		//TODO: would be nice to use false, but issues with MS SQL
 		pathExpressionParser.setUseThetaStyleJoin( true );
 		aggregatePathExpressionParser.setUseThetaStyleJoin( true );
 	}
 
 	public void token(String token, QueryTranslatorImpl q) throws QueryException {
 
 		String lctoken = token.toLowerCase();
 
 		if ( first ) {
 			first = false;
 			if ( "distinct".equals( lctoken ) ) {
 				q.setDistinct( true );
 				return;
 			}
 			else if ( "all".equals( lctoken ) ) {
 				q.setDistinct( false );
 				return;
 			}
 		}
 
 		if ( afterNew ) {
 			afterNew = false;
 			try {
 				holderClass = ReflectHelper.classForName( QuerySplitter.getImportedClass( token, q.getFactory() ) );
 			}
 			catch ( ClassNotFoundException cnfe ) {
 				throw new QueryException( cnfe );
 			}
 			if ( holderClass == null ) throw new QueryException( "class not found: " + token );
 			q.setHolderClass( holderClass );
 			insideNew = true;
 		}
 		else if ( token.equals( "," ) ) {
 			if ( !aggregate && ready ) throw new QueryException( "alias or expression expected in SELECT" );
 			q.appendScalarSelectToken( ", " );
 			ready = true;
 		}
 		else if ( "new".equals( lctoken ) ) {
 			afterNew = true;
 			ready = false;
 		}
 		else if ( "(".equals( token ) ) {
 			if ( insideNew && !aggregate && !ready ) {
 				//opening paren in new Foo ( ... )
 				ready = true;
 			}
 			else if ( aggregate ) {
 				q.appendScalarSelectToken( token );
 			}
 			else {
 				throw new QueryException( "aggregate function expected before ( in SELECT" );
 			}
 			ready = true;
 		}
 		else if ( ")".equals( token ) ) {
 			if ( insideNew && !aggregate && !ready ) {
 				//if we are inside a new Result(), but not inside a nested function
 				insideNew = false;
 			}
 			else if ( aggregate && ready ) {
 				q.appendScalarSelectToken( token );
 				aggregateFuncTokenList.removeLast();
 				if ( aggregateFuncTokenList.size() < 1 ) {
 					aggregate = false;
 					ready = false;
 				}
 			}
 			else {
 				throw new QueryException( "( expected before ) in select" );
 			}
 		}
 		else if ( COUNT_MODIFIERS.contains( lctoken ) ) {
 			if ( !ready || !aggregate ) {
 				throw new QueryException( token + " only allowed inside aggregate function in SELECT" );
 			}
 			q.appendScalarSelectToken( token );
 			if ( "*".equals( token ) ) {
 				// special case
 				q.addSelectScalar( getFunction( "count", q ).getReturnType( StandardBasicTypes.LONG, q.getFactory() ) );
 			}
 		}
 		else if ( getFunction( lctoken, q ) != null && token.equals( q.unalias( token ) ) ) {
 			// the name of an SQL function
 			if ( !ready ) throw new QueryException( ", expected before aggregate function in SELECT: " + token );
 			aggregate = true;
 			aggregateAddSelectScalar = true;
 			aggregateFuncTokenList.add( lctoken );
 			ready = false;
 			q.appendScalarSelectToken( token );
 			if ( !aggregateHasArgs( lctoken, q ) ) {
 				q.addSelectScalar( aggregateType( aggregateFuncTokenList, null, q ) );
 				if ( !aggregateFuncNoArgsHasParenthesis( lctoken, q ) ) {
 					aggregateFuncTokenList.removeLast();
 					if ( aggregateFuncTokenList.size() < 1 ) {
 						aggregate = false;
 						ready = false;
 					}
 					else {
 						ready = true;
 					}
 				}
 			}
 		}
 		else if ( aggregate ) {
 			boolean constantToken = false;
 			if ( !ready ) throw new QueryException( "( expected after aggregate function in SELECT" );
 			try {
 				ParserHelper.parse( aggregatePathExpressionParser, q.unalias( token ), ParserHelper.PATH_SEPARATORS, q );
 			}
 			catch ( QueryException qex ) {
 				constantToken = true;
 			}
 
 			if ( constantToken ) {
 				q.appendScalarSelectToken( token );
 			}
 			else {
 				if ( aggregatePathExpressionParser.isCollectionValued() ) {
 					q.addCollection( aggregatePathExpressionParser.getCollectionName(),
 							aggregatePathExpressionParser.getCollectionRole() );
 				}
 				q.appendScalarSelectToken( aggregatePathExpressionParser.getWhereColumn() );
 				if ( aggregateAddSelectScalar ) {
 					q.addSelectScalar( aggregateType( aggregateFuncTokenList, aggregatePathExpressionParser.getWhereColumnType(), q ) );
 					aggregateAddSelectScalar = false;
 				}
 				aggregatePathExpressionParser.addAssociation( q );
 			}
 		}
 		else {
 			if ( !ready ) throw new QueryException( ", expected in SELECT" );
 			ParserHelper.parse( pathExpressionParser, q.unalias( token ), ParserHelper.PATH_SEPARATORS, q );
 			if ( pathExpressionParser.isCollectionValued() ) {
 				q.addCollection( pathExpressionParser.getCollectionName(),
 						pathExpressionParser.getCollectionRole() );
 			}
 			else if ( pathExpressionParser.getWhereColumnType().isEntityType() ) {
 				q.addSelectClass( pathExpressionParser.getSelectName() );
 			}
 			q.appendScalarSelectTokens( pathExpressionParser.getWhereColumns() );
 			q.addSelectScalar( pathExpressionParser.getWhereColumnType() );
 			pathExpressionParser.addAssociation( q );
 
 			ready = false;
 		}
 	}
 
 	public boolean aggregateHasArgs(String funcToken, QueryTranslatorImpl q) {
 		return getFunction( funcToken, q ).hasArguments();
 	}
 
 	public boolean aggregateFuncNoArgsHasParenthesis(String funcToken, QueryTranslatorImpl q) {
 		return getFunction( funcToken, q ).hasParenthesesIfNoArguments();
 	}
 
 	public Type aggregateType(List funcTokenList, Type type, QueryTranslatorImpl q) throws QueryException {
 		Type retType = type;
 		Type argType;
 		for ( int i = funcTokenList.size() - 1; i >= 0; i-- ) {
 			argType = retType;
 			String funcToken = ( String ) funcTokenList.get( i );
 			retType = getFunction( funcToken, q ).getReturnType( argType, q.getFactory() );
 		}
 		return retType;
 	}
 
 	private SQLFunction getFunction(String name, QueryTranslatorImpl q) {
 		return q.getFactory().getSqlFunctionRegistry().findSQLFunction( name );
 	}
 
 	public void start(QueryTranslatorImpl q) {
 		ready = true;
 		first = true;
 		aggregate = false;
 		afterNew = false;
 		insideNew = false;
 		holderClass = null;
 		aggregateFuncTokenList.clear();
 	}
 
 	public void end(QueryTranslatorImpl q) {
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/SelectPathExpressionParser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/SelectPathExpressionParser.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/SelectPathExpressionParser.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/SelectPathExpressionParser.java
index f180c63004..b098c35ce5 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/SelectPathExpressionParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/SelectPathExpressionParser.java
@@ -1,53 +1,53 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 import org.hibernate.QueryException;
 
 public class SelectPathExpressionParser extends PathExpressionParser {
 
 	public void end(QueryTranslatorImpl q) throws QueryException {
 		if ( getCurrentProperty() != null && !q.isShallowQuery() ) {
 			// "finish off" the join
 			token( ".", q );
 			token( null, q );
 		}
 		super.end( q );
 	}
 
 	protected void setExpectingCollectionIndex() throws QueryException {
 		throw new QueryException( "illegal syntax near collection-valued path expression in select: "  + getCollectionName() );
 	}
 
 	public String getSelectName() {
 		return getCurrentName();
 	}
 }
 
 
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/WhereParser.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/WhereParser.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/WhereParser.java
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/WhereParser.java
index 740c151f04..4df667c735 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/classic/WhereParser.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/WhereParser.java
@@ -1,514 +1,514 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql.classic;
+package org.hibernate.hql.internal.classic;
 
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.Map;
 import java.util.Set;
 import java.util.StringTokenizer;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.engine.internal.JoinSequence;
-import org.hibernate.hql.QueryTranslator;
+import org.hibernate.hql.spi.QueryTranslator;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.persister.collection.CollectionPropertyNames;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.InFragment;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.LiteralType;
 import org.hibernate.type.Type;
 
 /**
  * Parses the where clause of a hibernate query and translates it to an
  * SQL where clause.
  */
 
 // We should reengineer this class so that, rather than the current ad -
 // hoc linear approach to processing a stream of tokens, we instead
 // build up a tree of expressions.
 
 // We would probably refactor to have LogicParser (builds a tree of simple
 // expressions connected by and, or, not), ExpressionParser (translates
 // from OO terms like foo, foo.Bar, foo.Bar.Baz to SQL terms like
 // FOOS.ID, FOOS.BAR_ID, etc) and PathExpressionParser (which does much
 // the same thing it does now)
 
 public class WhereParser implements Parser {
 
 	private final PathExpressionParser pathExpressionParser;
 
 	{
 		pathExpressionParser = new PathExpressionParser();
 		pathExpressionParser.setUseThetaStyleJoin( true ); //Need this, since join condition can appear inside parens!
 	}
 
 	private static final Set EXPRESSION_TERMINATORS = new HashSet();   //tokens that close a sub expression
 	private static final Set EXPRESSION_OPENERS = new HashSet();       //tokens that open a sub expression
 	private static final Set BOOLEAN_OPERATORS = new HashSet();        //tokens that would indicate a sub expression is a boolean expression
 	private static final Map NEGATIONS = new HashMap();
 
 	static {
 		EXPRESSION_TERMINATORS.add( "and" );
 		EXPRESSION_TERMINATORS.add( "or" );
 		EXPRESSION_TERMINATORS.add( ")" );
 		//expressionTerminators.add(","); // deliberately excluded
 
 		EXPRESSION_OPENERS.add( "and" );
 		EXPRESSION_OPENERS.add( "or" );
 		EXPRESSION_OPENERS.add( "(" );
 		//expressionOpeners.add(","); // deliberately excluded
 
 		BOOLEAN_OPERATORS.add( "<" );
 		BOOLEAN_OPERATORS.add( "=" );
 		BOOLEAN_OPERATORS.add( ">" );
 		BOOLEAN_OPERATORS.add( "#" );
 		BOOLEAN_OPERATORS.add( "~" );
 		BOOLEAN_OPERATORS.add( "like" );
 		BOOLEAN_OPERATORS.add( "ilike" );
 		BOOLEAN_OPERATORS.add( "regexp" );
 		BOOLEAN_OPERATORS.add( "rlike" );
 		BOOLEAN_OPERATORS.add( "is" );
 		BOOLEAN_OPERATORS.add( "in" );
 		BOOLEAN_OPERATORS.add( "any" );
 		BOOLEAN_OPERATORS.add( "some" );
 		BOOLEAN_OPERATORS.add( "all" );
 		BOOLEAN_OPERATORS.add( "exists" );
 		BOOLEAN_OPERATORS.add( "between" );
 		BOOLEAN_OPERATORS.add( "<=" );
 		BOOLEAN_OPERATORS.add( ">=" );
 		BOOLEAN_OPERATORS.add( "=>" );
 		BOOLEAN_OPERATORS.add( "=<" );
 		BOOLEAN_OPERATORS.add( "!=" );
 		BOOLEAN_OPERATORS.add( "<>" );
 		BOOLEAN_OPERATORS.add( "!#" );
 		BOOLEAN_OPERATORS.add( "!~" );
 		BOOLEAN_OPERATORS.add( "!<" );
 		BOOLEAN_OPERATORS.add( "!>" );
 		BOOLEAN_OPERATORS.add( "is not" );
 		BOOLEAN_OPERATORS.add( "not like" );
 		BOOLEAN_OPERATORS.add( "not ilike" );
 		BOOLEAN_OPERATORS.add( "not regexp" );
 		BOOLEAN_OPERATORS.add( "not rlike" );
 		BOOLEAN_OPERATORS.add( "not in" );
 		BOOLEAN_OPERATORS.add( "not between" );
 		BOOLEAN_OPERATORS.add( "not exists" );
 
 		NEGATIONS.put( "and", "or" );
 		NEGATIONS.put( "or", "and" );
 		NEGATIONS.put( "<", ">=" );
 		NEGATIONS.put( "=", "<>" );
 		NEGATIONS.put( ">", "<=" );
 		NEGATIONS.put( "#", "!#" );
 		NEGATIONS.put( "~", "!~" );
 		NEGATIONS.put( "like", "not like" );
 		NEGATIONS.put( "ilike", "not ilike" );
 		NEGATIONS.put( "regexp", "not regexp" );
 		NEGATIONS.put( "rlike", "not rlike" );
 		NEGATIONS.put( "is", "is not" );
 		NEGATIONS.put( "in", "not in" );
 		NEGATIONS.put( "exists", "not exists" );
 		NEGATIONS.put( "between", "not between" );
 		NEGATIONS.put( "<=", ">" );
 		NEGATIONS.put( ">=", "<" );
 		NEGATIONS.put( "=>", "<" );
 		NEGATIONS.put( "=<", ">" );
 		NEGATIONS.put( "!=", "=" );
 		NEGATIONS.put( "<>", "=" );
 		NEGATIONS.put( "!#", "#" );
 		NEGATIONS.put( "!~", "~" );
 		NEGATIONS.put( "!<", "<" );
 		NEGATIONS.put( "!>", ">" );
 		NEGATIONS.put( "is not", "is" );
 		NEGATIONS.put( "not like", "like" );
 		NEGATIONS.put( "not ilike", "ilike" );
 		NEGATIONS.put( "not regexp", "regexp" );
 		NEGATIONS.put( "not rlike", "rlike" );
 		NEGATIONS.put( "not in", "in" );
 		NEGATIONS.put( "not between", "between" );
 		NEGATIONS.put( "not exists", "exists" );
 
 	}
 	// Handles things like:
 	// a and b or c
 	// a and ( b or c )
 	// not a and not b
 	// not ( a and b )
 	// x between y and z            (overloaded "and")
 	// x in ( a, b, c )             (overloaded brackets)
 	// not not a
 	// a is not null                (overloaded "not")
 	// etc......
 	// and expressions like
 	// foo = bar                    (maps to: foo.id = bar.id)
 	// foo.Bar = 'foo'              (maps to: foo.bar = 'foo')
 	// foo.Bar.Baz = 1.0            (maps to: foo.bar = bar.id and bar.baz = 1.0)
 	// 1.0 = foo.Bar.Baz            (maps to: bar.baz = 1.0 and foo.Bar = bar.id)
 	// foo.Bar.Baz = a.B.C          (maps to: bar.Baz = b.C and foo.Bar = bar.id and a.B = b.id)
 	// foo.Bar.Baz + a.B.C          (maps to: bar.Baz + b.C and foo.Bar = bar.id and a.B = b.id)
 	// ( foo.Bar.Baz + 1.0 ) < 2.0  (maps to: ( bar.Baz + 1.0 ) < 2.0 and foo.Bar = bar.id)
 
 	private boolean betweenSpecialCase = false;       //Inside a BETWEEN ... AND ... expression
 	private boolean negated = false;
 
 	private boolean inSubselect = false;
 	private int bracketsSinceSelect = 0;
 	private StringBuffer subselect;
 
 	private boolean expectingPathContinuation = false;
 	private int expectingIndex = 0;
 
 	// The following variables are stacks that keep information about each subexpression
 	// in the list of nested subexpressions we are currently processing.
 
 	private LinkedList nots = new LinkedList();           //were an odd or even number of NOTs encountered
 	private LinkedList joins = new LinkedList();          //the join string built up by compound paths inside this expression
 	private LinkedList booleanTests = new LinkedList();   //a flag indicating if the subexpression is known to be boolean
 
 	private String getElementName(PathExpressionParser.CollectionElement element, QueryTranslatorImpl q) throws QueryException {
 		String name;
 		if ( element.isOneToMany ) {
 			name = element.alias;
 		}
 		else {
 			Type type = element.elementType;
 			if ( type.isEntityType() ) { //ie. a many-to-many
 				String entityName = ( ( EntityType ) type ).getAssociatedEntityName();
 				name = pathExpressionParser.continueFromManyToMany( entityName, element.elementColumns, q );
 			}
 			else {
 				throw new QueryException( "illegally dereferenced collection element" );
 			}
 		}
 		return name;
 	}
 
 	public void token(String token, QueryTranslatorImpl q) throws QueryException {
 
 		String lcToken = token.toLowerCase();
 
 		//Cope with [,]
 		if ( token.equals( "[" ) && !expectingPathContinuation ) {
 			expectingPathContinuation = false;
 			if ( expectingIndex == 0 ) throw new QueryException( "unexpected [" );
 			return;
 		}
 		else if ( token.equals( "]" ) ) {
 			expectingIndex--;
 			expectingPathContinuation = true;
 			return;
 		}
 
 		//Cope with a continued path expression (ie. ].baz)
 		if ( expectingPathContinuation ) {
 			boolean pathExpressionContinuesFurther = continuePathExpression( token, q );
 			if ( pathExpressionContinuesFurther ) return; //NOTE: early return
 		}
 
 		//Cope with a subselect
 		if ( !inSubselect && ( lcToken.equals( "select" ) || lcToken.equals( "from" ) ) ) {
 			inSubselect = true;
 			subselect = new StringBuffer( 20 );
 		}
 		if ( inSubselect && token.equals( ")" ) ) {
 			bracketsSinceSelect--;
 
 			if ( bracketsSinceSelect == -1 ) {
 				QueryTranslatorImpl subq = new QueryTranslatorImpl(
 				        subselect.toString(),
 						q.getEnabledFilters(),
 						q.getFactory()
 				);
 				try {
 					subq.compile( q );
 				}
 				catch ( MappingException me ) {
 					throw new QueryException( "MappingException occurred compiling subquery", me );
 				}
 				appendToken( q, subq.getSQLString() );
 				inSubselect = false;
 				bracketsSinceSelect = 0;
 			}
 		}
 		if ( inSubselect ) {
 			if ( token.equals( "(" ) ) bracketsSinceSelect++;
 			subselect.append( token ).append( ' ' );
 			return;
 		}
 
 		//Cope with special cases of AND, NOT, ()
 		specialCasesBefore( lcToken );
 
 		//Close extra brackets we opened
 		if ( !betweenSpecialCase && EXPRESSION_TERMINATORS.contains( lcToken ) ) {
 			closeExpression( q, lcToken );
 		}
 
 		//take note when this is a boolean expression
 		if ( BOOLEAN_OPERATORS.contains( lcToken ) ) {
 			booleanTests.removeLast();
 			booleanTests.addLast( Boolean.TRUE );
 		}
 
 		if ( lcToken.equals( "not" ) ) {
 			nots.addLast( new Boolean( !( ( Boolean ) nots.removeLast() ).booleanValue() ) );
 			negated = !negated;
 			return; //NOTE: early return
 		}
 
 		//process a token, mapping OO path expressions to SQL expressions
 		doToken( token, q );
 
 		//Open any extra brackets we might need.
 		if ( !betweenSpecialCase && EXPRESSION_OPENERS.contains( lcToken ) ) {
 			openExpression( q, lcToken );
 		}
 
 		//Cope with special cases of AND, NOT, )
 		specialCasesAfter( lcToken );
 
 	}
 
 	public void start(QueryTranslatorImpl q) throws QueryException {
 		token( "(", q );
 	}
 
 	public void end(QueryTranslatorImpl q) throws QueryException {
 		if ( expectingPathContinuation ) {
 			expectingPathContinuation = false;
 			PathExpressionParser.CollectionElement element = pathExpressionParser.lastCollectionElement();
 			if ( element.elementColumns.length != 1 ) throw new QueryException( "path expression ended in composite collection element" );
 			appendToken( q, element.elementColumns[0] );
 			addToCurrentJoin( element );
 		}
 		token( ")", q );
 	}
 
 	private void closeExpression(QueryTranslatorImpl q, String lcToken) {
 		if ( ( ( Boolean ) booleanTests.removeLast() ).booleanValue() ) { //it was a boolean expression
 
 			if ( booleanTests.size() > 0 ) {
 				// the next one up must also be
 				booleanTests.removeLast();
 				booleanTests.addLast( Boolean.TRUE );
 			}
 
 			// Add any joins
 			appendToken( q, ( joins.removeLast() ).toString() );
 
 		}
 		else {
 			StringBuffer join = ( StringBuffer ) joins.removeLast();
 			( ( StringBuffer ) joins.getLast() ).append( join.toString() );
 		}
 
 		if ( ( ( Boolean ) nots.removeLast() ).booleanValue() ) negated = !negated;
 
 		if ( !")".equals( lcToken ) ) appendToken( q, ")" );
 	}
 
 	private void openExpression(QueryTranslatorImpl q, String lcToken) {
 		nots.addLast( Boolean.FALSE );
 		booleanTests.addLast( Boolean.FALSE );
 		joins.addLast( new StringBuffer() );
 		if ( !"(".equals( lcToken ) ) appendToken( q, "(" );
 	}
 
 	private void preprocess(String token, QueryTranslatorImpl q) throws QueryException {
 		// ugly hack for cases like "elements(foo.bar.collection)"
 		// (multi-part path expression ending in elements or indices)
 		String[] tokens = StringHelper.split( ".", token, true );
 		if (
 				tokens.length > 5 &&
 				( CollectionPropertyNames.COLLECTION_ELEMENTS.equals( tokens[tokens.length - 1] )
 				|| CollectionPropertyNames.COLLECTION_INDICES.equals( tokens[tokens.length - 1] ) )
 		) {
 			pathExpressionParser.start( q );
 			for ( int i = 0; i < tokens.length - 3; i++ ) {
 				pathExpressionParser.token( tokens[i], q );
 			}
 			pathExpressionParser.token( null, q );
 			pathExpressionParser.end( q );
 			addJoin( pathExpressionParser.getWhereJoin(), q );
 			pathExpressionParser.ignoreInitialJoin();
 		}
 	}
 
 	private void doPathExpression(String token, QueryTranslatorImpl q) throws QueryException {
 
 		preprocess( token, q );
 
 		StringTokenizer tokens = new StringTokenizer( token, ".", true );
 		pathExpressionParser.start( q );
 		while ( tokens.hasMoreTokens() ) {
 			pathExpressionParser.token( tokens.nextToken(), q );
 		}
 		pathExpressionParser.end( q );
 		if ( pathExpressionParser.isCollectionValued() ) {
 			openExpression( q, "" );
 			appendToken( q, pathExpressionParser.getCollectionSubquery( q.getEnabledFilters() ) );
 			closeExpression( q, "" );
 			// this is ugly here, but needed because its a subquery
 			q.addQuerySpaces( q.getCollectionPersister( pathExpressionParser.getCollectionRole() ).getCollectionSpaces() );
 		}
 		else {
 			if ( pathExpressionParser.isExpectingCollectionIndex() ) {
 				expectingIndex++;
 			}
 			else {
 				addJoin( pathExpressionParser.getWhereJoin(), q );
 				appendToken( q, pathExpressionParser.getWhereColumn() );
 			}
 		}
 	}
 
 	private void addJoin(JoinSequence joinSequence, QueryTranslatorImpl q) throws QueryException {
 		//JoinFragment fromClause = q.createJoinFragment(true);
 		//fromClause.addJoins( join.toJoinFragment().toFromFragmentString(), StringHelper.EMPTY_STRING );
 		q.addFromJoinOnly( pathExpressionParser.getName(), joinSequence );
 		try {
 			addToCurrentJoin( joinSequence.toJoinFragment( q.getEnabledFilters(), true ).toWhereFragmentString() );
 		}
 		catch ( MappingException me ) {
 			throw new QueryException( me );
 		}
 	}
 
 	private void doToken(String token, QueryTranslatorImpl q) throws QueryException {
 		if ( q.isName( StringHelper.root( token ) ) ) { //path expression
 			doPathExpression( q.unalias( token ), q );
 		}
 		else if ( token.startsWith( ParserHelper.HQL_VARIABLE_PREFIX ) ) { //named query parameter
 			q.addNamedParameter( token.substring( 1 ) );
 			appendToken( q, "?" );
 		}
 		else {
 			Queryable persister = q.getEntityPersisterUsingImports( token );
 			if ( persister != null ) { // the name of a class
 				final String discrim = persister.getDiscriminatorSQLValue();
 				if ( InFragment.NULL.equals(discrim) || InFragment.NOT_NULL.equals(discrim) ) {
 					throw new QueryException( "subclass test not allowed for null or not null discriminator" );
 				}
 				else {
 					appendToken( q, discrim );
 				}
 			}
 			else {
 				Object constant;
 				if (
 						token.indexOf( '.' ) > -1 &&
 						( constant = ReflectHelper.getConstantValue( token ) ) != null
 				) {
 					Type type;
 					try {
 						type = q.getFactory().getTypeResolver().heuristicType( constant.getClass().getName() );
 					}
 					catch ( MappingException me ) {
 						throw new QueryException( me );
 					}
 					if ( type == null ) throw new QueryException( QueryTranslator.ERROR_CANNOT_DETERMINE_TYPE + token );
 					try {
 						appendToken( q, ( ( LiteralType ) type ).objectToSQLString( constant, q.getFactory().getDialect() ) );
 					}
 					catch ( Exception e ) {
 						throw new QueryException( QueryTranslator.ERROR_CANNOT_FORMAT_LITERAL + token, e );
 					}
 				}
 				else { //anything else
 
 					String negatedToken = negated ? ( String ) NEGATIONS.get( token.toLowerCase() ) : null;
 					if ( negatedToken != null && ( !betweenSpecialCase || !"or".equals( negatedToken ) ) ) {
 						appendToken( q, negatedToken );
 					}
 					else {
 						appendToken( q, token );
 					}
 				}
 			}
 		}
 	}
 
 	private void addToCurrentJoin(String sql) {
 		( ( StringBuffer ) joins.getLast() ).append( sql );
 	}
 
 	private void addToCurrentJoin(PathExpressionParser.CollectionElement ce)
 			throws QueryException {
 		try {
 			addToCurrentJoin( ce.joinSequence.toJoinFragment().toWhereFragmentString() + ce.indexValue.toString() );
 		}
 		catch ( MappingException me ) {
 			throw new QueryException( me );
 		}
 	}
 
 	private void specialCasesBefore(String lcToken) {
 		if ( lcToken.equals( "between" ) || lcToken.equals( "not between" ) ) {
 			betweenSpecialCase = true;
 		}
 	}
 
 	private void specialCasesAfter(String lcToken) {
 		if ( betweenSpecialCase && lcToken.equals( "and" ) ) {
 			betweenSpecialCase = false;
 		}
 	}
 
 	void appendToken(QueryTranslatorImpl q, String token) {
 		if ( expectingIndex > 0 ) {
 			pathExpressionParser.setLastCollectionElementIndexValue( token );
 		}
 		else {
 			q.appendWhereToken( token );
 		}
 	}
 
 	private boolean continuePathExpression(String token, QueryTranslatorImpl q) throws QueryException {
 
 		expectingPathContinuation = false;
 
 		PathExpressionParser.CollectionElement element = pathExpressionParser.lastCollectionElement();
 
 		if ( token.startsWith( "." ) ) { // the path expression continues after a ]
 
 			doPathExpression( getElementName( element, q ) + token, q ); // careful with this!
 
 			addToCurrentJoin( element );
 			return true; //NOTE: EARLY EXIT!
 
 		}
 
 		else { // the path expression ends at the ]
 			if ( element.elementColumns.length != 1 ) {
 				throw new QueryException( "path expression ended in composite collection element" );
 			}
 			appendToken( q, element.elementColumns[0] );
 			addToCurrentJoin( element );
 			return false;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/classic/package.html b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/package.html
similarity index 100%
rename from hibernate-core/src/main/java/org/hibernate/hql/classic/package.html
rename to hibernate-core/src/main/java/org/hibernate/hql/internal/classic/package.html
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/FilterTranslator.java b/hibernate-core/src/main/java/org/hibernate/hql/spi/FilterTranslator.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/FilterTranslator.java
rename to hibernate-core/src/main/java/org/hibernate/hql/spi/FilterTranslator.java
index af6caca86a..effe00b4ce 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/FilterTranslator.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/spi/FilterTranslator.java
@@ -1,49 +1,49 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql;
+package org.hibernate.hql.spi;
 import java.util.Map;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 
 
 /**
  * Specialized interface for filters.
  *
  * @author josh
  */
 public interface FilterTranslator extends QueryTranslator {
 	/**
 	 * Compile a filter. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 *
 	 * @param collectionRole the role name of the collection used as the basis for the filter.
 	 * @param replacements   Defined query substitutions.
 	 * @param shallow        Does this represent a shallow (scalar or entity-id) select?
 	 * @throws QueryException   There was a problem parsing the query string.
 	 * @throws MappingException There was a problem querying defined mappings.
 	 */
 	void compile(String collectionRole, Map replacements, boolean shallow)
 			throws QueryException, MappingException;
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/ParameterTranslations.java b/hibernate-core/src/main/java/org/hibernate/hql/spi/ParameterTranslations.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/ParameterTranslations.java
rename to hibernate-core/src/main/java/org/hibernate/hql/spi/ParameterTranslations.java
index 43a5fc8a48..aaa51f7e91 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/ParameterTranslations.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/spi/ParameterTranslations.java
@@ -1,50 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql;
+package org.hibernate.hql.spi;
 import java.util.Set;
 import org.hibernate.type.Type;
 
 /**
  * Defines available information about the parameters encountered during
  * query translation.
  *
  * @author Steve Ebersole
  */
 public interface ParameterTranslations {
 
 	public boolean supportsOrdinalParameterMetadata();
 
 	public int getOrdinalParameterCount();
 
 	public int getOrdinalParameterSqlLocation(int ordinalPosition);
 
 	public Type getOrdinalParameterExpectedType(int ordinalPosition);
 
 	public Set getNamedParameterNames();
 
 	public int[] getNamedParameterSqlLocations(String name);
 
 	public Type getNamedParameterExpectedType(String name);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/QueryTranslator.java b/hibernate-core/src/main/java/org/hibernate/hql/spi/QueryTranslator.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/hql/QueryTranslator.java
rename to hibernate-core/src/main/java/org/hibernate/hql/spi/QueryTranslator.java
index 11efcfea82..0c81ccebf2 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/QueryTranslator.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/spi/QueryTranslator.java
@@ -1,191 +1,191 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.hql;
+package org.hibernate.hql.spi;
 
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.event.spi.EventSource;
 import org.hibernate.type.Type;
 
 /**
  * Defines the contract of an HQL->SQL translator.
  *
  * @author josh
  */
 public interface QueryTranslator {
 
 	// Error message constants.
 	public static final String ERROR_CANNOT_FETCH_WITH_ITERATE = "fetch may not be used with scroll() or iterate()";
 	public static final String ERROR_NAMED_PARAMETER_DOES_NOT_APPEAR = "Named parameter does not appear in Query: ";
     public static final String ERROR_CANNOT_DETERMINE_TYPE = "Could not determine type of: ";
 	public static final String ERROR_CANNOT_FORMAT_LITERAL =  "Could not format constant value to SQL literal: ";
 
 	/**
 	 * Compile a "normal" query. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 *
 	 * @param replacements Defined query substitutions.
 	 * @param shallow      Does this represent a shallow (scalar or entity-id) select?
 	 * @throws QueryException   There was a problem parsing the query string.
 	 * @throws MappingException There was a problem querying defined mappings.
 	 */
 	void compile(Map replacements, boolean shallow) throws QueryException, MappingException;
 
 	/**
 	 * Perform a list operation given the underlying query definition.
 	 *
 	 * @param session         The session owning this query.
 	 * @param queryParameters The query bind parameters.
 	 * @return The query list results.
 	 * @throws HibernateException
 	 */
 	List list(SessionImplementor session, QueryParameters queryParameters)
 			throws HibernateException;
 
 	/**
 	 * Perform an iterate operation given the underlying query definition.
 	 *
 	 * @param queryParameters The query bind parameters.
 	 * @param session         The session owning this query.
 	 * @return An iterator over the query results.
 	 * @throws HibernateException
 	 */
 	Iterator iterate(QueryParameters queryParameters, EventSource session)
 			throws HibernateException;
 
 	/**
 	 * Perform a scroll operation given the underlying query definition.
 	 *
 	 * @param queryParameters The query bind parameters.
 	 * @param session         The session owning this query.
 	 * @return The ScrollableResults wrapper around the query results.
 	 * @throws HibernateException
 	 */
 	ScrollableResults scroll(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException;
 
 	/**
 	 * Perform a bulk update/delete operation given the underlying query definition.
 	 *
 	 * @param queryParameters The query bind parameters.
 	 * @param session         The session owning this query.
 	 * @return The number of entities updated or deleted.
 	 * @throws HibernateException
 	 */
 	int executeUpdate(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException;
 
 	/**
 	 * Returns the set of query spaces (table names) that the query refers to.
 	 *
 	 * @return A set of query spaces (table names).
 	 */
 	Set getQuerySpaces();
 
 	/**
 	 * Retrieve the query identifier for this translator.  The query identifier is
 	 * used in states collection.
 	 *
 	 * @return the identifier
 	 */
 	String getQueryIdentifier();
 
 	/**
 	 * Returns the SQL string generated by the translator.
 	 *
 	 * @return the SQL string generated by the translator.
 	 */
 	String getSQLString();
 
 	List collectSqlStrings();
 
 	/**
 	 * Returns the HQL string processed by the translator.
 	 *
 	 * @return the HQL string processed by the translator.
 	 */
 	String getQueryString();
 
 	/**
 	 * Returns the filters enabled for this query translator.
 	 *
 	 * @return Filters enabled for this query execution.
 	 */
 	Map getEnabledFilters();
 
 	/**
 	 * Returns an array of Types represented in the query result.
 	 *
 	 * @return Query return types.
 	 */
 	Type[] getReturnTypes();
 	
 	/**
 	 * Returns an array of HQL aliases
 	 */
 	String[] getReturnAliases();
 
 	/**
 	 * Returns the column names in the generated SQL.
 	 *
 	 * @return the column names in the generated SQL.
 	 */
 	String[][] getColumnNames();
 
 	/**
 	 * Return information about any parameters encountered during
 	 * translation.
 	 *
 	 * @return The parameter information.
 	 */
 	ParameterTranslations getParameterTranslations();
 
 	/**
 	 * Validate the scrollability of the translated query.
 	 *
 	 * @throws HibernateException
 	 */
 	void validateScrollability() throws HibernateException;
 
 	/**
 	 * Does the translated query contain collection fetches?
 	 *
 	 * @return true if the query does contain collection fetched;
 	 * false otherwise.
 	 */
 	boolean containsCollectionFetches();
 
 	boolean isManipulationStatement();
 
 	public Class getDynamicInstantiationResultType();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/QueryTranslatorFactory.java b/hibernate-core/src/main/java/org/hibernate/hql/spi/QueryTranslatorFactory.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/hql/QueryTranslatorFactory.java
rename to hibernate-core/src/main/java/org/hibernate/hql/spi/QueryTranslatorFactory.java
index acc9928aef..a0adc7f7ac 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/QueryTranslatorFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/spi/QueryTranslatorFactory.java
@@ -1,58 +1,58 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
-package org.hibernate.hql;
+package org.hibernate.hql.spi;
 import java.util.Map;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 
 /**
  * Facade for generation of {@link QueryTranslator} and {@link FilterTranslator} instances.
  *
  * @author Gavin King
  */
 public interface QueryTranslatorFactory {
 	/**
 	 * Construct a {@link QueryTranslator} instance capable of translating
 	 * an HQL query string.
 	 *
 	 * @param queryIdentifier The query-identifier (used in
 	 * {@link org.hibernate.stat.QueryStatistics} collection). This is
 	 * typically the same as the queryString parameter except for the case of
 	 * split polymorphic queries which result in multiple physical sql
 	 * queries.
 	 * @param queryString The query string to be translated
 	 * @param filters Currently enabled filters
 	 * @param factory The session factory.
 	 * @return an appropriate translator.
 	 */
 	public QueryTranslator createQueryTranslator(String queryIdentifier, String queryString, Map filters, SessionFactoryImplementor factory);
 
 	/**
 	 * Construct a {@link FilterTranslator} instance capable of translating
 	 * an HQL filter string.
 	 *
 	 * @see #createQueryTranslator
 	 */
 	public FilterTranslator createFilterTranslator(String queryIdentifier, String queryString, Map filters, SessionFactoryImplementor factory);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/AbstractQueryImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/AbstractQueryImpl.java
index 1b84b73ffa..9383abe322 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/AbstractQueryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/AbstractQueryImpl.java
@@ -1,958 +1,958 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import java.io.Serializable;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.CacheMode;
 import org.hibernate.FlushMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.NonUniqueResultException;
 import org.hibernate.PropertyNotFoundException;
 import org.hibernate.Query;
 import org.hibernate.QueryException;
 import org.hibernate.Session;
 import org.hibernate.engine.query.spi.ParameterMetadata;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.TypedValue;
-import org.hibernate.hql.classic.ParserHelper;
+import org.hibernate.hql.internal.classic.ParserHelper;
 import org.hibernate.internal.util.MarkerObject;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.property.Getter;
 import org.hibernate.proxy.HibernateProxyHelper;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.SerializableType;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.Type;
 
 /**
  * Abstract implementation of the Query interface.
  *
  * @author Gavin King
  * @author Max Andersen
  */
 public abstract class AbstractQueryImpl implements Query {
 
 	private static final Object UNSET_PARAMETER = new MarkerObject("<unset parameter>");
 	private static final Object UNSET_TYPE = new MarkerObject("<unset type>");
 
 	private final String queryString;
 	protected final SessionImplementor session;
 	protected final ParameterMetadata parameterMetadata;
 
 	// parameter bind values...
 	private List values = new ArrayList(4);
 	private List types = new ArrayList(4);
 	private Map namedParameters = new HashMap(4);
 	private Map namedParameterLists = new HashMap(4);
 
 	private Object optionalObject;
 	private Serializable optionalId;
 	private String optionalEntityName;
 
 	private RowSelection selection;
 	private boolean cacheable;
 	private String cacheRegion;
 	private String comment;
 	private FlushMode flushMode;
 	private CacheMode cacheMode;
 	private FlushMode sessionFlushMode;
 	private CacheMode sessionCacheMode;
 	private Serializable collectionKey;
 	private Boolean readOnly;
 	private ResultTransformer resultTransformer;
 
 	public AbstractQueryImpl(
 			String queryString,
 	        FlushMode flushMode,
 	        SessionImplementor session,
 	        ParameterMetadata parameterMetadata) {
 		this.session = session;
 		this.queryString = queryString;
 		this.selection = new RowSelection();
 		this.flushMode = flushMode;
 		this.cacheMode = null;
 		this.parameterMetadata = parameterMetadata;
 	}
 
 	public ParameterMetadata getParameterMetadata() {
 		return parameterMetadata;
 	}
 
 	public String toString() {
 		return StringHelper.unqualify( getClass().getName() ) + '(' + queryString + ')';
 	}
 
 	public final String getQueryString() {
 		return queryString;
 	}
 
 	//TODO: maybe call it getRowSelection() ?
 	public RowSelection getSelection() {
 		return selection;
 	}
 	
 	public Query setFlushMode(FlushMode flushMode) {
 		this.flushMode = flushMode;
 		return this;
 	}
 	
 	public Query setCacheMode(CacheMode cacheMode) {
 		this.cacheMode = cacheMode;
 		return this;
 	}
 
 	public CacheMode getCacheMode() {
 		return cacheMode;
 	}
 
 	public Query setCacheable(boolean cacheable) {
 		this.cacheable = cacheable;
 		return this;
 	}
 
 	public Query setCacheRegion(String cacheRegion) {
 		if (cacheRegion != null)
 			this.cacheRegion = cacheRegion.trim();
 		return this;
 	}
 
 	public Query setComment(String comment) {
 		this.comment = comment;
 		return this;
 	}
 
 	public Query setFirstResult(int firstResult) {
 		selection.setFirstRow( new Integer(firstResult) );
 		return this;
 	}
 
 	public Query setMaxResults(int maxResults) {
 		if ( maxResults < 0 ) {
 			// treat negatives specically as meaning no limit...
 			selection.setMaxRows( null );
 		}
 		else {
 			selection.setMaxRows( new Integer(maxResults) );
 		}
 		return this;
 	}
 
 	public Query setTimeout(int timeout) {
 		selection.setTimeout( new Integer(timeout) );
 		return this;
 	}
 	public Query setFetchSize(int fetchSize) {
 		selection.setFetchSize( new Integer(fetchSize) );
 		return this;
 	}
 
 	public Type[] getReturnTypes() throws HibernateException {
 		return session.getFactory().getReturnTypes( queryString );
 	}
 
 	public String[] getReturnAliases() throws HibernateException {
 		return session.getFactory().getReturnAliases( queryString );
 	}
 
 	public Query setCollectionKey(Serializable collectionKey) {
 		this.collectionKey = collectionKey;
 		return this;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public boolean isReadOnly() {
 		return ( readOnly == null ?
 				getSession().getPersistenceContext().isDefaultReadOnly() :
 				readOnly.booleanValue() 
 		);
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Query setReadOnly(boolean readOnly) {
 		this.readOnly = Boolean.valueOf( readOnly );
 		return this;
 	}
 
 	public Query setResultTransformer(ResultTransformer transformer) {
 		this.resultTransformer = transformer;
 		return this;
 	}
 	
 	public void setOptionalEntityName(String optionalEntityName) {
 		this.optionalEntityName = optionalEntityName;
 	}
 
 	public void setOptionalId(Serializable optionalId) {
 		this.optionalId = optionalId;
 	}
 
 	public void setOptionalObject(Object optionalObject) {
 		this.optionalObject = optionalObject;
 	}
 
 	SessionImplementor getSession() {
 		return session;
 	}
 
 	public abstract LockOptions getLockOptions();
 
 
 	// Parameter handling code ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Returns a shallow copy of the named parameter value map.
 	 *
 	 * @return Shallow copy of the named parameter value map
 	 */
 	protected Map getNamedParams() {
 		return new HashMap( namedParameters );
 	}
 
 	/**
 	 * Returns an array representing all named parameter names encountered
 	 * during (intial) parsing of the query.
 	 * <p/>
 	 * Note <i>initial</i> here means different things depending on whether
 	 * this is a native-sql query or an HQL/filter query.  For native-sql, a
 	 * precursory inspection of the query string is performed specifically to
 	 * locate defined parameters.  For HQL/filter queries, this is the
 	 * information returned from the query-translator.  This distinction
 	 * holds true for all parameter metadata exposed here.
 	 *
 	 * @return Array of named parameter names.
 	 * @throws HibernateException
 	 */
 	public String[] getNamedParameters() throws HibernateException {
 		return ArrayHelper.toStringArray( parameterMetadata.getNamedParameterNames() );
 	}
 
 	/**
 	 * Does this query contain named parameters?
 	 *
 	 * @return True if the query was found to contain named parameters; false
 	 * otherwise;
 	 */
 	public boolean hasNamedParameters() {
 		return parameterMetadata.getNamedParameterNames().size() > 0;
 	}
 
 	/**
 	 * Retreive the value map for any named parameter lists (i.e., for
 	 * auto-expansion) bound to this query.
 	 *
 	 * @return The parameter list value map.
 	 */
 	protected Map getNamedParameterLists() {
 		return namedParameterLists;
 	}
 
 	/**
 	 * Retreives the list of parameter values bound to this query for
 	 * ordinal parameters.
 	 *
 	 * @return The ordinal parameter values.
 	 */
 	protected List getValues() {
 		return values;
 	}
 
 	/**
 	 * Retreives the list of parameter {@link Type type}s bound to this query for
 	 * ordinal parameters.
 	 *
 	 * @return The ordinal parameter types.
 	 */
 	protected List getTypes() {
 		return types;
 	}
 
 	/**
 	 * Perform parameter validation.  Used prior to executing the encapsulated
 	 * query.
 	 *
 	 * @throws QueryException
 	 */
 	protected void verifyParameters() throws QueryException {
 		verifyParameters(false);
 	}
 
 	/**
 	 * Perform parameter validation.  Used prior to executing the encapsulated
 	 * query.
 	 *
 	 * @param reserveFirstParameter if true, the first ? will not be verified since
 	 * its needed for e.g. callable statements returning a out parameter
 	 * @throws HibernateException
 	 */
 	protected void verifyParameters(boolean reserveFirstParameter) throws HibernateException {
 		if ( parameterMetadata.getNamedParameterNames().size() != namedParameters.size() + namedParameterLists.size() ) {
 			Set missingParams = new HashSet( parameterMetadata.getNamedParameterNames() );
 			missingParams.removeAll( namedParameterLists.keySet() );
 			missingParams.removeAll( namedParameters.keySet() );
 			throw new QueryException( "Not all named parameters have been set: " + missingParams, getQueryString() );
 		}
 
 		int positionalValueSpan = 0;
 		for ( int i = 0; i < values.size(); i++ ) {
 			Object object = types.get( i );
 			if( values.get( i ) == UNSET_PARAMETER || object == UNSET_TYPE ) {
 				if ( reserveFirstParameter && i==0 ) {
 					continue;
 				}
 				else {
 					throw new QueryException( "Unset positional parameter at position: " + i, getQueryString() );
 				}
 			}
 			positionalValueSpan += ( (Type) object ).getColumnSpan( session.getFactory() );
 		}
 
 		if ( parameterMetadata.getOrdinalParameterCount() != positionalValueSpan ) {
 			if ( reserveFirstParameter && parameterMetadata.getOrdinalParameterCount() - 1 != positionalValueSpan ) {
 				throw new QueryException(
 				 		"Expected positional parameter count: " +
 				 		(parameterMetadata.getOrdinalParameterCount()-1) +
 				 		", actual parameters: " +
 				 		values,
 				 		getQueryString()
 				 	);
 			}
 			else if ( !reserveFirstParameter ) {
 				throw new QueryException(
 				 		"Expected positional parameter count: " +
 				 		parameterMetadata.getOrdinalParameterCount() +
 				 		", actual parameters: " +
 				 		values,
 				 		getQueryString()
 				 	);
 			}
 		}
 	}
 
 	public Query setParameter(int position, Object val, Type type) {
 		if ( parameterMetadata.getOrdinalParameterCount() == 0 ) {
 			throw new IllegalArgumentException("No positional parameters in query: " + getQueryString() );
 		}
 		if ( position < 0 || position > parameterMetadata.getOrdinalParameterCount() - 1 ) {
 			throw new IllegalArgumentException("Positional parameter does not exist: " + position + " in query: " + getQueryString() );
 		}
 		int size = values.size();
 		if ( position < size ) {
 			values.set( position, val );
 			types.set( position, type );
 		}
 		else {
 			// prepend value and type list with null for any positions before the wanted position.
 			for ( int i = 0; i < position - size; i++ ) {
 				values.add( UNSET_PARAMETER );
 				types.add( UNSET_TYPE );
 			}
 			values.add( val );
 			types.add( type );
 		}
 		return this;
 	}
 
 	public Query setParameter(String name, Object val, Type type) {
 		if ( !parameterMetadata.getNamedParameterNames().contains( name ) ) {
 			throw new IllegalArgumentException("Parameter " + name + " does not exist as a named parameter in [" + getQueryString() + "]");
 		}
 		else {
 			 namedParameters.put( name, new TypedValue( type, val, session.getEntityMode() ) );
 			 return this;
 		}
 	}
 
 	public Query setParameter(int position, Object val) throws HibernateException {
 		if (val == null) {
 			setParameter( position, val, StandardBasicTypes.SERIALIZABLE );
 		}
 		else {
 			setParameter( position, val, determineType( position, val ) );
 		}
 		return this;
 	}
 
 	public Query setParameter(String name, Object val) throws HibernateException {
 		if (val == null) {
 			Type type = parameterMetadata.getNamedParameterExpectedType( name );
 			if ( type == null ) {
 				type = StandardBasicTypes.SERIALIZABLE;
 			}
 			setParameter( name, val, type );
 		}
 		else {
 			setParameter( name, val, determineType( name, val ) );
 		}
 		return this;
 	}
 
 	protected Type determineType(int paramPosition, Object paramValue, Type defaultType) {
 		Type type = parameterMetadata.getOrdinalParameterExpectedType( paramPosition + 1 );
 		if ( type == null ) {
 			type = defaultType;
 		}
 		return type;
 	}
 
 	protected Type determineType(int paramPosition, Object paramValue) throws HibernateException {
 		Type type = parameterMetadata.getOrdinalParameterExpectedType( paramPosition + 1 );
 		if ( type == null ) {
 			type = guessType( paramValue );
 		}
 		return type;
 	}
 
 	protected Type determineType(String paramName, Object paramValue, Type defaultType) {
 		Type type = parameterMetadata.getNamedParameterExpectedType( paramName );
 		if ( type == null ) {
 			type = defaultType;
 		}
 		return type;
 	}
 
 	protected Type determineType(String paramName, Object paramValue) throws HibernateException {
 		Type type = parameterMetadata.getNamedParameterExpectedType( paramName );
 		if ( type == null ) {
 			type = guessType( paramValue );
 		}
 		return type;
 	}
 
 	protected Type determineType(String paramName, Class clazz) throws HibernateException {
 		Type type = parameterMetadata.getNamedParameterExpectedType( paramName );
 		if ( type == null ) {
 			type = guessType( clazz );
 		}
 		return type;
 	}
 
 	private Type guessType(Object param) throws HibernateException {
 		Class clazz = HibernateProxyHelper.getClassWithoutInitializingProxy( param );
 		return guessType( clazz );
 	}
 
 	private Type guessType(Class clazz) throws HibernateException {
 		String typename = clazz.getName();
 		Type type = session.getFactory().getTypeResolver().heuristicType(typename);
 		boolean serializable = type!=null && type instanceof SerializableType;
 		if (type==null || serializable) {
 			try {
 				session.getFactory().getEntityPersister( clazz.getName() );
 			}
 			catch (MappingException me) {
 				if (serializable) {
 					return type;
 				}
 				else {
 					throw new HibernateException("Could not determine a type for class: " + typename);
 				}
 			}
 			return ( (Session) session ).getTypeHelper().entity( clazz );
 		}
 		else {
 			return type;
 		}
 	}
 
 	public Query setString(int position, String val) {
 		setParameter(position, val, StandardBasicTypes.STRING);
 		return this;
 	}
 
 	public Query setCharacter(int position, char val) {
 		setParameter(position, new Character(val), StandardBasicTypes.CHARACTER);
 		return this;
 	}
 
 	public Query setBoolean(int position, boolean val) {
 		Boolean valueToUse = val ? Boolean.TRUE : Boolean.FALSE;
 		Type typeToUse = determineType( position, valueToUse, StandardBasicTypes.BOOLEAN );
 		setParameter( position, valueToUse, typeToUse );
 		return this;
 	}
 
 	public Query setByte(int position, byte val) {
 		setParameter(position, new Byte(val), StandardBasicTypes.BYTE);
 		return this;
 	}
 
 	public Query setShort(int position, short val) {
 		setParameter(position, new Short(val), StandardBasicTypes.SHORT);
 		return this;
 	}
 
 	public Query setInteger(int position, int val) {
 		setParameter(position, new Integer(val), StandardBasicTypes.INTEGER);
 		return this;
 	}
 
 	public Query setLong(int position, long val) {
 		setParameter(position, new Long(val), StandardBasicTypes.LONG);
 		return this;
 	}
 
 	public Query setFloat(int position, float val) {
 		setParameter(position, new Float(val), StandardBasicTypes.FLOAT);
 		return this;
 	}
 
 	public Query setDouble(int position, double val) {
 		setParameter(position, new Double(val), StandardBasicTypes.DOUBLE);
 		return this;
 	}
 
 	public Query setBinary(int position, byte[] val) {
 		setParameter(position, val, StandardBasicTypes.BINARY);
 		return this;
 	}
 
 	public Query setText(int position, String val) {
 		setParameter(position, val, StandardBasicTypes.TEXT);
 		return this;
 	}
 
 	public Query setSerializable(int position, Serializable val) {
 		setParameter(position, val, StandardBasicTypes.SERIALIZABLE);
 		return this;
 	}
 
 	public Query setDate(int position, Date date) {
 		setParameter(position, date, StandardBasicTypes.DATE);
 		return this;
 	}
 
 	public Query setTime(int position, Date date) {
 		setParameter(position, date, StandardBasicTypes.TIME);
 		return this;
 	}
 
 	public Query setTimestamp(int position, Date date) {
 		setParameter(position, date, StandardBasicTypes.TIMESTAMP);
 		return this;
 	}
 
 	public Query setEntity(int position, Object val) {
 		setParameter( position, val, ( (Session) session ).getTypeHelper().entity( resolveEntityName( val ) ) );
 		return this;
 	}
 
 	private String resolveEntityName(Object val) {
 		if ( val == null ) {
 			throw new IllegalArgumentException( "entity for parameter binding cannot be null" );
 		}
 		return session.bestGuessEntityName( val );
 	}
 
 	public Query setLocale(int position, Locale locale) {
 		setParameter(position, locale, StandardBasicTypes.LOCALE);
 		return this;
 	}
 
 	public Query setCalendar(int position, Calendar calendar) {
 		setParameter(position, calendar, StandardBasicTypes.CALENDAR);
 		return this;
 	}
 
 	public Query setCalendarDate(int position, Calendar calendar) {
 		setParameter(position, calendar, StandardBasicTypes.CALENDAR_DATE);
 		return this;
 	}
 
 	public Query setBinary(String name, byte[] val) {
 		setParameter(name, val, StandardBasicTypes.BINARY);
 		return this;
 	}
 
 	public Query setText(String name, String val) {
 		setParameter(name, val, StandardBasicTypes.TEXT);
 		return this;
 	}
 
 	public Query setBoolean(String name, boolean val) {
 		Boolean valueToUse = val ? Boolean.TRUE : Boolean.FALSE;
 		Type typeToUse = determineType( name, valueToUse, StandardBasicTypes.BOOLEAN );
 		setParameter( name, valueToUse, typeToUse );
 		return this;
 	}
 
 	public Query setByte(String name, byte val) {
 		setParameter(name, new Byte(val), StandardBasicTypes.BYTE);
 		return this;
 	}
 
 	public Query setCharacter(String name, char val) {
 		setParameter(name, new Character(val), StandardBasicTypes.CHARACTER);
 		return this;
 	}
 
 	public Query setDate(String name, Date date) {
 		setParameter(name, date, StandardBasicTypes.DATE);
 		return this;
 	}
 
 	public Query setDouble(String name, double val) {
 		setParameter(name, new Double(val), StandardBasicTypes.DOUBLE);
 		return this;
 	}
 
 	public Query setEntity(String name, Object val) {
 		setParameter( name, val, ( (Session) session ).getTypeHelper().entity( resolveEntityName( val ) ) );
 		return this;
 	}
 
 	public Query setFloat(String name, float val) {
 		setParameter(name, new Float(val), StandardBasicTypes.FLOAT);
 		return this;
 	}
 
 	public Query setInteger(String name, int val) {
 		setParameter(name, new Integer(val), StandardBasicTypes.INTEGER);
 		return this;
 	}
 
 	public Query setLocale(String name, Locale locale) {
 		setParameter(name, locale, StandardBasicTypes.LOCALE);
 		return this;
 	}
 
 	public Query setCalendar(String name, Calendar calendar) {
 		setParameter(name, calendar, StandardBasicTypes.CALENDAR);
 		return this;
 	}
 
 	public Query setCalendarDate(String name, Calendar calendar) {
 		setParameter(name, calendar, StandardBasicTypes.CALENDAR_DATE);
 		return this;
 	}
 
 	public Query setLong(String name, long val) {
 		setParameter(name, new Long(val), StandardBasicTypes.LONG);
 		return this;
 	}
 
 	public Query setSerializable(String name, Serializable val) {
 		setParameter(name, val, StandardBasicTypes.SERIALIZABLE);
 		return this;
 	}
 
 	public Query setShort(String name, short val) {
 		setParameter(name, new Short(val), StandardBasicTypes.SHORT);
 		return this;
 	}
 
 	public Query setString(String name, String val) {
 		setParameter(name, val, StandardBasicTypes.STRING);
 		return this;
 	}
 
 	public Query setTime(String name, Date date) {
 		setParameter(name, date, StandardBasicTypes.TIME);
 		return this;
 	}
 
 	public Query setTimestamp(String name, Date date) {
 		setParameter(name, date, StandardBasicTypes.TIMESTAMP);
 		return this;
 	}
 
 	public Query setBigDecimal(int position, BigDecimal number) {
 		setParameter(position, number, StandardBasicTypes.BIG_DECIMAL);
 		return this;
 	}
 
 	public Query setBigDecimal(String name, BigDecimal number) {
 		setParameter(name, number, StandardBasicTypes.BIG_DECIMAL);
 		return this;
 	}
 
 	public Query setBigInteger(int position, BigInteger number) {
 		setParameter(position, number, StandardBasicTypes.BIG_INTEGER);
 		return this;
 	}
 
 	public Query setBigInteger(String name, BigInteger number) {
 		setParameter(name, number, StandardBasicTypes.BIG_INTEGER);
 		return this;
 	}
 
 	public Query setParameterList(String name, Collection vals, Type type) throws HibernateException {
 		if ( !parameterMetadata.getNamedParameterNames().contains( name ) ) {
 			throw new IllegalArgumentException("Parameter " + name + " does not exist as a named parameter in [" + getQueryString() + "]");
 		}
 		namedParameterLists.put( name, new TypedValue( type, vals, session.getEntityMode() ) );
 		return this;
 	}
 	
 	/**
 	 * Warning: adds new parameters to the argument by side-effect, as well as
 	 * mutating the query string!
 	 */
 	protected String expandParameterLists(Map namedParamsCopy) {
 		String query = this.queryString;
 		Iterator iter = namedParameterLists.entrySet().iterator();
 		while ( iter.hasNext() ) {
 			Map.Entry me = (Map.Entry) iter.next();
 			query = expandParameterList( query, (String) me.getKey(), (TypedValue) me.getValue(), namedParamsCopy );
 		}
 		return query;
 	}
 
 	/**
 	 * Warning: adds new parameters to the argument by side-effect, as well as
 	 * mutating the query string!
 	 */
 	private String expandParameterList(String query, String name, TypedValue typedList, Map namedParamsCopy) {
 		Collection vals = (Collection) typedList.getValue();
 		Type type = typedList.getType();
 
 		boolean isJpaPositionalParam = parameterMetadata.getNamedParameterDescriptor( name ).isJpaStyle();
 		String paramPrefix = isJpaPositionalParam ? "?" : ParserHelper.HQL_VARIABLE_PREFIX;
 		String placeholder =
 				new StringBuffer( paramPrefix.length() + name.length() )
 						.append( paramPrefix ).append(  name )
 						.toString();
 
 		if ( query == null ) {
 			return query;
 		}
 		int loc = query.indexOf( placeholder );
 
 		if ( loc < 0 ) {
 			return query;
 		}
 
 		String beforePlaceholder = query.substring( 0, loc );
 		String afterPlaceholder =  query.substring( loc + placeholder.length() );
 
 		// check if placeholder is already immediately enclosed in parentheses
 		// (ignoring whitespace)
 		boolean isEnclosedInParens =
 				StringHelper.getLastNonWhitespaceCharacter( beforePlaceholder ) == '(' &&
 				StringHelper.getFirstNonWhitespaceCharacter( afterPlaceholder ) == ')';
 
 		if ( vals.size() == 1  && isEnclosedInParens ) {
 			// short-circuit for performance when only 1 value and the
 			// placeholder is already enclosed in parentheses...
 			namedParamsCopy.put( name, new TypedValue( type, vals.iterator().next(), session.getEntityMode() ) );
 			return query;
 		}
 
 		StringBuffer list = new StringBuffer( 16 );
 		Iterator iter = vals.iterator();
 		int i = 0;
 		while ( iter.hasNext() ) {
 			String alias = ( isJpaPositionalParam ? 'x' + name : name ) + i++ + '_';
 			namedParamsCopy.put( alias, new TypedValue( type, iter.next(), session.getEntityMode() ) );
 			list.append( ParserHelper.HQL_VARIABLE_PREFIX ).append( alias );
 			if ( iter.hasNext() ) {
 				list.append( ", " );
 			}
 		}
 		return StringHelper.replace(
 				beforePlaceholder,
 				afterPlaceholder,
 				placeholder.toString(),
 				list.toString(),
 				true,
 				true
 		);
 	}
 
 	public Query setParameterList(String name, Collection vals) throws HibernateException {
 		if ( vals == null ) {
 			throw new QueryException( "Collection must be not null!" );
 		}
 
 		if( vals.size() == 0 ) {
 			setParameterList( name, vals, null );
 		}
 		else {
 			setParameterList(name, vals, determineType( name, vals.iterator().next() ) );
 		}
 
 		return this;
 	}
 
 	public Query setParameterList(String name, Object[] vals, Type type) throws HibernateException {
 		return setParameterList( name, Arrays.asList(vals), type );
 	}
 
 	public Query setParameterList(String name, Object[] vals) throws HibernateException {
 		return setParameterList( name, Arrays.asList(vals) );
 	}
 
 	public Query setProperties(Map map) throws HibernateException {
 		String[] params = getNamedParameters();
 		for (int i = 0; i < params.length; i++) {
 			String namedParam = params[i];
 				final Object object = map.get(namedParam);
 				if(object==null) {
 					continue;
 				}
 				Class retType = object.getClass();
 				if ( Collection.class.isAssignableFrom( retType ) ) {
 					setParameterList( namedParam, ( Collection ) object );
 				}
 				else if ( retType.isArray() ) {
 					setParameterList( namedParam, ( Object[] ) object );
 				}
 				else {
 					setParameter( namedParam, object, determineType( namedParam, retType ) );
 				}
 
 			
 		}
 		return this;				
 	}
 	
 	public Query setProperties(Object bean) throws HibernateException {
 		Class clazz = bean.getClass();
 		String[] params = getNamedParameters();
 		for (int i = 0; i < params.length; i++) {
 			String namedParam = params[i];
 			try {
 				Getter getter = ReflectHelper.getGetter( clazz, namedParam );
 				Class retType = getter.getReturnType();
 				final Object object = getter.get( bean );
 				if ( Collection.class.isAssignableFrom( retType ) ) {
 					setParameterList( namedParam, ( Collection ) object );
 				}
 				else if ( retType.isArray() ) {
 				 	setParameterList( namedParam, ( Object[] ) object );
 				}
 				else {
 					setParameter( namedParam, object, determineType( namedParam, retType ) );
 				}
 			}
 			catch (PropertyNotFoundException pnfe) {
 				// ignore
 			}
 		}
 		return this;
 	}
 
 	public Query setParameters(Object[] values, Type[] types) {
 		this.values = Arrays.asList(values);
 		this.types = Arrays.asList(types);
 		return this;
 	}
 
 
 	// Execution methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public Object uniqueResult() throws HibernateException {
 		return uniqueElement( list() );
 	}
 
 	static Object uniqueElement(List list) throws NonUniqueResultException {
 		int size = list.size();
 		if (size==0) return null;
 		Object first = list.get(0);
 		for ( int i=1; i<size; i++ ) {
 			if ( list.get(i)!=first ) {
 				throw new NonUniqueResultException( list.size() );
 			}
 		}
 		return first;
 	}
 
 	protected RowSelection getRowSelection() {
 		return selection;
 	}
 
 	public Type[] typeArray() {
 		return ArrayHelper.toTypeArray( getTypes() );
 	}
 	
 	public Object[] valueArray() {
 		return getValues().toArray();
 	}
 
 	public QueryParameters getQueryParameters(Map namedParams) {
 		return new QueryParameters(
 				typeArray(),
 				valueArray(),
 				namedParams,
 				getLockOptions(),
 				getSelection(),
 				true,
 				isReadOnly(),
 				cacheable,
 				cacheRegion,
 				comment,
 				collectionKey == null ? null : new Serializable[] { collectionKey },
 				optionalObject,
 				optionalEntityName,
 				optionalId,
 				resultTransformer
 		);
 	}
 	
 	protected void before() {
 		if ( flushMode!=null ) {
 			sessionFlushMode = getSession().getFlushMode();
 			getSession().setFlushMode(flushMode);
 		}
 		if ( cacheMode!=null ) {
 			sessionCacheMode = getSession().getCacheMode();
 			getSession().setCacheMode(cacheMode);
 		}
 	}
 	
 	protected void after() {
 		if (sessionFlushMode!=null) {
 			getSession().setFlushMode(sessionFlushMode);
 			sessionFlushMode = null;
 		}
 		if (sessionCacheMode!=null) {
 			getSession().setCacheMode(sessionCacheMode);
 			sessionCacheMode = null;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/AbstractScrollableResults.java b/hibernate-core/src/main/java/org/hibernate/internal/AbstractScrollableResults.java
index c9b012b591..cff7db8d43 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/AbstractScrollableResults.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/AbstractScrollableResults.java
@@ -1,289 +1,289 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.sql.Blob;
 import java.sql.Clob;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Locale;
 import java.util.TimeZone;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.hql.HolderInstantiator;
+import org.hibernate.hql.internal.HolderInstantiator;
 import org.hibernate.loader.Loader;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.Type;
 
 /**
  * Implementation of the <tt>ScrollableResults</tt> interface
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractScrollableResults implements ScrollableResults {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        AbstractScrollableResults.class.getName());
 
 	private final ResultSet resultSet;
 	private final PreparedStatement ps;
 	private final SessionImplementor session;
 	private final Loader loader;
 	private final QueryParameters queryParameters;
 	private final Type[] types;
 	private HolderInstantiator holderInstantiator;
 
 	public AbstractScrollableResults(
 	        ResultSet rs,
 	        PreparedStatement ps,
 	        SessionImplementor sess,
 			Loader loader,
 			QueryParameters queryParameters,
 	        Type[] types,
 	        HolderInstantiator holderInstantiator) throws MappingException {
 		this.resultSet=rs;
 		this.ps=ps;
 		this.session = sess;
 		this.loader = loader;
 		this.queryParameters = queryParameters;
 		this.types = types;
 		this.holderInstantiator = holderInstantiator!=null && holderInstantiator.isRequired()
 		        ? holderInstantiator
 		        : null;
 	}
 
 	protected abstract Object[] getCurrentRow();
 
 	protected ResultSet getResultSet() {
 		return resultSet;
 	}
 
 	protected PreparedStatement getPs() {
 		return ps;
 	}
 
 	protected SessionImplementor getSession() {
 		return session;
 	}
 
 	protected Loader getLoader() {
 		return loader;
 	}
 
 	protected QueryParameters getQueryParameters() {
 		return queryParameters;
 	}
 
 	protected Type[] getTypes() {
 		return types;
 	}
 
 	protected HolderInstantiator getHolderInstantiator() {
 		return holderInstantiator;
 	}
 
 	public final void close() throws HibernateException {
 		try {
 			// not absolutely necessary, but does help with aggressive release
 			//session.getJDBCContext().getConnectionManager().closeQueryStatement( ps, resultSet );
 			ps.close();
 		}
 		catch (SQLException sqle) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not close results"
 				);
 		}
 		finally {
 			try {
 				session.getPersistenceContext().getLoadContexts().cleanup( resultSet );
 			}
 			catch( Throwable ignore ) {
 				// ignore this error for now
                 LOG.trace("Exception trying to cleanup load context : " + ignore.getMessage());
 			}
 		}
 	}
 
 	public final Object[] get() throws HibernateException {
 		return getCurrentRow();
 	}
 
 	public final Object get(int col) throws HibernateException {
 		return getCurrentRow()[col];
 	}
 
 	/**
 	 * Check that the requested type is compatible with the result type, and
 	 * return the column value.  This version makes sure the the classes
 	 * are identical.
 	 *
 	 * @param col the column
 	 * @param returnType a "final" type
 	 */
 	protected final Object getFinal(int col, Type returnType) throws HibernateException {
 		if ( holderInstantiator!=null ) {
 			throw new HibernateException("query specifies a holder class");
 		}
 
 		if ( returnType.getReturnedClass()==types[col].getReturnedClass() ) {
 			return get(col);
 		}
 		else {
 			return throwInvalidColumnTypeException(col, types[col], returnType);
 		}
 	}
 
 	/**
 	 * Check that the requested type is compatible with the result type, and
 	 * return the column value.  This version makes sure the the classes
 	 * are "assignable".
 	 *
 	 * @param col the column
 	 * @param returnType any type
 	 */
 	protected final Object getNonFinal(int col, Type returnType) throws HibernateException {
 		if ( holderInstantiator!=null ) {
 			throw new HibernateException("query specifies a holder class");
 		}
 
 		if ( returnType.getReturnedClass().isAssignableFrom( types[col].getReturnedClass() ) ) {
 			return get(col);
 		}
 		else {
 			return throwInvalidColumnTypeException(col, types[col], returnType);
 		}
 	}
 
 	public final BigDecimal getBigDecimal(int col) throws HibernateException {
 		return (BigDecimal) getFinal(col, StandardBasicTypes.BIG_DECIMAL);
 	}
 
 	public final BigInteger getBigInteger(int col) throws HibernateException {
 		return (BigInteger) getFinal(col, StandardBasicTypes.BIG_INTEGER);
 	}
 
 	public final byte[] getBinary(int col) throws HibernateException {
 		return (byte[]) getFinal(col, StandardBasicTypes.BINARY);
 	}
 
 	public final String getText(int col) throws HibernateException {
 		return (String) getFinal(col, StandardBasicTypes.TEXT);
 	}
 
 	public final Blob getBlob(int col) throws HibernateException {
 		return (Blob) getNonFinal(col, StandardBasicTypes.BLOB);
 	}
 
 	public final Clob getClob(int col) throws HibernateException {
 		return (Clob) getNonFinal(col, StandardBasicTypes.CLOB);
 	}
 
 	public final Boolean getBoolean(int col) throws HibernateException {
 		return (Boolean) getFinal(col, StandardBasicTypes.BOOLEAN);
 	}
 
 	public final Byte getByte(int col) throws HibernateException {
 		return (Byte) getFinal(col, StandardBasicTypes.BYTE);
 	}
 
 	public final Character getCharacter(int col) throws HibernateException {
 		return (Character) getFinal(col, StandardBasicTypes.CHARACTER);
 	}
 
 	public final Date getDate(int col) throws HibernateException {
 		return (Date) getNonFinal(col, StandardBasicTypes.TIMESTAMP);
 	}
 
 	public final Calendar getCalendar(int col) throws HibernateException {
 		return (Calendar) getNonFinal(col, StandardBasicTypes.CALENDAR);
 	}
 
 	public final Double getDouble(int col) throws HibernateException {
 		return (Double) getFinal(col, StandardBasicTypes.DOUBLE);
 	}
 
 	public final Float getFloat(int col) throws HibernateException {
 		return (Float) getFinal(col, StandardBasicTypes.FLOAT);
 	}
 
 	public final Integer getInteger(int col) throws HibernateException {
 		return (Integer) getFinal(col, StandardBasicTypes.INTEGER);
 	}
 
 	public final Long getLong(int col) throws HibernateException {
 		return (Long) getFinal(col, StandardBasicTypes.LONG);
 	}
 
 	public final Short getShort(int col) throws HibernateException {
 		return (Short) getFinal(col, StandardBasicTypes.SHORT);
 	}
 
 	public final String getString(int col) throws HibernateException {
 		return (String) getFinal(col, StandardBasicTypes.STRING);
 	}
 
 	public final Locale getLocale(int col) throws HibernateException {
 		return (Locale) getFinal(col, StandardBasicTypes.LOCALE);
 	}
 
 	/*public final Currency getCurrency(int col) throws HibernateException {
 		return (Currency) get(col);
 	}*/
 
 	public final TimeZone getTimeZone(int col) throws HibernateException {
 		return (TimeZone) getNonFinal(col, StandardBasicTypes.TIMEZONE);
 	}
 
 	public final Type getType(int i) {
 		return types[i];
 	}
 
 	private Object throwInvalidColumnTypeException(
 	        int i,
 	        Type type,
 	        Type returnType) throws HibernateException {
 		throw new HibernateException(
 				"incompatible column types: " +
 				type.getName() +
 				", " +
 				returnType.getName()
 		);
 	}
 
 	protected void afterScrollOperation() {
 		session.afterScrollOperation();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/FetchingScrollableResultsImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/FetchingScrollableResultsImpl.java
index c5112aaccb..d8df991965 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/FetchingScrollableResultsImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/FetchingScrollableResultsImpl.java
@@ -1,332 +1,332 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.hql.HolderInstantiator;
+import org.hibernate.hql.internal.HolderInstantiator;
 import org.hibernate.loader.Loader;
 import org.hibernate.type.Type;
 
 /**
  * Implementation of ScrollableResults which can handle collection fetches.
  *
  * @author Steve Ebersole
  */
 public class FetchingScrollableResultsImpl extends AbstractScrollableResults {
 
 	public FetchingScrollableResultsImpl(
 	        ResultSet rs,
 	        PreparedStatement ps,
 	        SessionImplementor sess,
 	        Loader loader,
 	        QueryParameters queryParameters,
 	        Type[] types,
 	        HolderInstantiator holderInstantiator) throws MappingException {
 		super( rs, ps, sess, loader, queryParameters, types, holderInstantiator );
 	}
 
 	private Object[] currentRow = null;
 	private int currentPosition = 0;
 	private Integer maxPosition = null;
 
 	@Override
     protected Object[] getCurrentRow() {
 		return currentRow;
 	}
 
 	/**
 	 * Advance to the next result
 	 *
 	 * @return <tt>true</tt> if there is another result
 	 */
 	public boolean next() throws HibernateException {
 		if ( maxPosition != null && maxPosition.intValue() <= currentPosition ) {
 			currentRow = null;
 			currentPosition = maxPosition.intValue() + 1;
 			return false;
 		}
 
 		if ( isResultSetEmpty() ) {
 			currentRow = null;
 			currentPosition = 0;
 			return false;
 		}
 
 		Object row = getLoader().loadSequentialRowsForward(
 				getResultSet(),
 				getSession(),
 				getQueryParameters(),
 				false
 		);
 
 
 		boolean afterLast;
 		try {
 			afterLast = getResultSet().isAfterLast();
 		}
 		catch( SQLException e ) {
 			throw getSession().getFactory().getSQLExceptionHelper().convert(
 			        e,
 			        "exception calling isAfterLast()"
 				);
 		}
 
 		currentPosition++;
 		currentRow = new Object[] { row };
 
 		if ( afterLast ) {
 			if ( maxPosition == null ) {
 				// we just hit the last position
 				maxPosition = new Integer( currentPosition );
 			}
 		}
 
 		afterScrollOperation();
 
 		return true;
 	}
 
 	/**
 	 * Retreat to the previous result
 	 *
 	 * @return <tt>true</tt> if there is a previous result
 	 */
 	public boolean previous() throws HibernateException {
 		if ( currentPosition <= 1 ) {
 			currentPosition = 0;
 			currentRow = null;
 			return false;
 		}
 
 		Object loadResult = getLoader().loadSequentialRowsReverse(
 				getResultSet(),
 				getSession(),
 				getQueryParameters(),
 				false,
 		        ( maxPosition != null && currentPosition > maxPosition.intValue() )
 		);
 
 		currentRow = new Object[] { loadResult };
 		currentPosition--;
 
 		afterScrollOperation();
 
 		return true;
 
 	}
 
 	/**
 	 * Scroll an arbitrary number of locations
 	 *
 	 * @param positions a positive (forward) or negative (backward) number of rows
 	 *
 	 * @return <tt>true</tt> if there is a result at the new location
 	 */
 	public boolean scroll(int positions) throws HibernateException {
 		boolean more = false;
 		if ( positions > 0 ) {
 			// scroll ahead
 			for ( int i = 0; i < positions; i++ ) {
 				more = next();
 				if ( !more ) {
 					break;
 				}
 			}
 		}
 		else if ( positions < 0 ) {
 			// scroll backward
 			for ( int i = 0; i < ( 0 - positions ); i++ ) {
 				more = previous();
 				if ( !more ) {
 					break;
 				}
 			}
 		}
 		else {
 			throw new HibernateException( "scroll(0) not valid" );
 		}
 
 		afterScrollOperation();
 
 		return more;
 	}
 
 	/**
 	 * Go to the last result
 	 *
 	 * @return <tt>true</tt> if there are any results
 	 */
 	public boolean last() throws HibernateException {
 		boolean more = false;
 		if ( maxPosition != null ) {
 			if ( currentPosition > maxPosition.intValue() ) {
 				more = previous();
 			}
 			for ( int i = currentPosition; i < maxPosition.intValue(); i++ ) {
 				more = next();
 			}
 		}
 		else {
 			try {
 				if ( isResultSetEmpty() || getResultSet().isAfterLast() ) {
 					// should not be able to reach last without maxPosition being set
 					// unless there are no results
 					return false;
 				}
 
 				while ( !getResultSet().isAfterLast() ) {
 					more = next();
 				}
 			}
 			catch( SQLException e ) {
 				throw getSession().getFactory().getSQLExceptionHelper().convert(
 						e,
 						"exception calling isAfterLast()"
 					);
 			}
 		}
 
 		afterScrollOperation();
 
 		return more;
 	}
 
 	/**
 	 * Go to the first result
 	 *
 	 * @return <tt>true</tt> if there are any results
 	 */
 	public boolean first() throws HibernateException {
 		beforeFirst();
 		boolean more = next();
 
 		afterScrollOperation();
 
 		return more;
 	}
 
 	/**
 	 * Go to a location just before first result (this is the initial location)
 	 */
 	public void beforeFirst() throws HibernateException {
 		try {
 			getResultSet().beforeFirst();
 		}
 		catch( SQLException e ) {
 			throw getSession().getFactory().getSQLExceptionHelper().convert(
 			        e,
 			        "exception calling beforeFirst()"
 				);
 		}
 		currentRow = null;
 		currentPosition = 0;
 	}
 
 	/**
 	 * Go to a location just after the last result
 	 */
 	public void afterLast() throws HibernateException {
 		// TODO : not sure the best way to handle this.
 		// The non-performant way :
 		last();
 		next();
 		afterScrollOperation();
 	}
 
 	/**
 	 * Is this the first result?
 	 *
 	 * @return <tt>true</tt> if this is the first row of results
 	 *
 	 * @throws org.hibernate.HibernateException
 	 */
 	public boolean isFirst() throws HibernateException {
 		return currentPosition == 1;
 	}
 
 	/**
 	 * Is this the last result?
 	 *
 	 * @return <tt>true</tt> if this is the last row of results
 	 *
 	 * @throws org.hibernate.HibernateException
 	 */
 	public boolean isLast() throws HibernateException {
 		if ( maxPosition == null ) {
 			// we have not yet hit the last result...
 			return false;
 		}
 		else {
 			return currentPosition == maxPosition.intValue();
 		}
 	}
 
 	/**
 	 * Get the current location in the result set. The first row is number <tt>0</tt>, contrary to JDBC.
 	 *
 	 * @return the row number, numbered from <tt>0</tt>, or <tt>-1</tt> if there is no current row
 	 */
 	public int getRowNumber() throws HibernateException {
 		return currentPosition;
 	}
 
 	/**
 	 * Set the current location in the result set, numbered from either the first row (row number <tt>0</tt>), or the last
 	 * row (row number <tt>-1</tt>).
 	 *
 	 * @param rowNumber the row number, numbered from the last row, in the case of a negative row number
 	 *
 	 * @return true if there is a row at that row number
 	 */
 	public boolean setRowNumber(int rowNumber) throws HibernateException {
 		if ( rowNumber == 1 ) {
 			return first();
 		}
 		else if ( rowNumber == -1 ) {
 			return last();
 		}
 		else if ( maxPosition != null && rowNumber == maxPosition.intValue() ) {
 			return last();
 		}
 		return scroll( rowNumber - currentPosition );
 	}
 
 	private boolean isResultSetEmpty() {
 		try {
 			return currentPosition == 0 && ! getResultSet().isBeforeFirst() && ! getResultSet().isAfterLast();
 		}
 		catch( SQLException e ) {
 			throw getSession().getFactory().getSQLExceptionHelper().convert(
 			        e,
 			        "Could not determine if resultset is empty due to exception calling isBeforeFirst or isAfterLast()"
 			);
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/IteratorImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/IteratorImpl.java
index c4e9935c2c..f10a7a6a4b 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/IteratorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/IteratorImpl.java
@@ -1,181 +1,181 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.internal;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.NoSuchElementException;
 import org.hibernate.HibernateException;
 import org.hibernate.JDBCException;
 import org.hibernate.engine.HibernateIterator;
 import org.hibernate.event.spi.EventSource;
-import org.hibernate.hql.HolderInstantiator;
+import org.hibernate.hql.internal.HolderInstantiator;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 
 /**
  * An implementation of <tt>java.util.Iterator</tt> that is
  * returned by <tt>iterate()</tt> query execution methods.
  * @author Gavin King
  */
 public final class IteratorImpl implements HibernateIterator {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, IteratorImpl.class.getName());
 
 	private ResultSet rs;
 	private final EventSource session;
 	private boolean readOnly;
 	private final Type[] types;
 	private final boolean single;
 	private Object currentResult;
 	private boolean hasNext;
 	private final String[][] names;
 	private PreparedStatement ps;
 	private HolderInstantiator holderInstantiator;
 
 	public IteratorImpl(
 	        ResultSet rs,
 	        PreparedStatement ps,
 	        EventSource sess,
 	        boolean readOnly,
 	        Type[] types,
 	        String[][] columnNames,
 	        HolderInstantiator holderInstantiator)
 	throws HibernateException, SQLException {
 
 		this.rs=rs;
 		this.ps=ps;
 		this.session = sess;
 		this.readOnly = readOnly;
 		this.types = types;
 		this.names = columnNames;
 		this.holderInstantiator = holderInstantiator;
 
 		single = types.length==1;
 
 		postNext();
 	}
 
 	public void close() throws JDBCException {
 		if (ps!=null) {
 			try {
                 LOG.debugf("Closing iterator");
 				ps.close();
 				ps = null;
 				rs = null;
 				hasNext = false;
 			}
 			catch (SQLException e) {
                 LOG.unableToCloseIterator(e);
 				throw session.getFactory().getSQLExceptionHelper().convert(
 				        e,
 				        "Unable to close iterator"
 					);
 			}
 			finally {
 				try {
 					session.getPersistenceContext().getLoadContexts().cleanup( rs );
 				}
 				catch( Throwable ignore ) {
 					// ignore this error for now
                     LOG.debugf("Exception trying to cleanup load context : %s", ignore.getMessage());
 				}
 			}
 		}
 	}
 
 	private void postNext() throws SQLException {
         LOG.debugf("Attempting to retrieve next results");
 		this.hasNext = rs.next();
 		if (!hasNext) {
             LOG.debugf("Exhausted results");
 			close();
         } else LOG.debugf("Retrieved next results");
 	}
 
 	public boolean hasNext() {
 		return hasNext;
 	}
 
 	public Object next() throws HibernateException {
 		if ( !hasNext ) throw new NoSuchElementException("No more results");
 		boolean sessionDefaultReadOnlyOrig = session.isDefaultReadOnly();
 		session.setDefaultReadOnly( readOnly );
 		try {
 			boolean isHolder = holderInstantiator.isRequired();
 
             LOG.debugf("Assembling results");
 			if ( single && !isHolder ) {
 				currentResult = types[0].nullSafeGet( rs, names[0], session, null );
 			}
 			else {
 				Object[] currentResults = new Object[types.length];
 				for (int i=0; i<types.length; i++) {
 					currentResults[i] = types[i].nullSafeGet( rs, names[i], session, null );
 				}
 
 				if (isHolder) {
 					currentResult = holderInstantiator.instantiate(currentResults);
 				}
 				else {
 					currentResult = currentResults;
 				}
 			}
 
 			postNext();
             LOG.debugf("Returning current results");
 			return currentResult;
 		}
 		catch (SQLException sqle) {
 			throw session.getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not get next iterator result"
 				);
 		}
 		finally {
 			session.setDefaultReadOnly( sessionDefaultReadOnlyOrig );
 		}
 	}
 
 	public void remove() {
 		if (!single) {
 			throw new UnsupportedOperationException("Not a single column hibernate query result set");
 		}
 		if (currentResult==null) {
 			throw new IllegalStateException("Called Iterator.remove() before next()");
 		}
 		if ( !( types[0] instanceof EntityType ) ) {
 			throw new UnsupportedOperationException("Not an entity");
 		}
 
 		session.delete(
 				( (EntityType) types[0] ).getAssociatedEntityName(),
 				currentResult,
 				false,
 		        null
 			);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/ScrollableResultsImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/ScrollableResultsImpl.java
index 48fddf6623..a4db2bec06 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/ScrollableResultsImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/ScrollableResultsImpl.java
@@ -1,259 +1,259 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.hql.HolderInstantiator;
+import org.hibernate.hql.internal.HolderInstantiator;
 import org.hibernate.loader.Loader;
 import org.hibernate.type.Type;
 
 /**
  * Implementation of the <tt>ScrollableResults</tt> interface
  * @author Gavin King
  */
 public class ScrollableResultsImpl extends AbstractScrollableResults implements ScrollableResults {
 
 	private Object[] currentRow;
 
 	public ScrollableResultsImpl(
 	        ResultSet rs,
 	        PreparedStatement ps,
 	        SessionImplementor sess,
 	        Loader loader,
 	        QueryParameters queryParameters,
 	        Type[] types, HolderInstantiator holderInstantiator) throws MappingException {
 		super( rs, ps, sess, loader, queryParameters, types, holderInstantiator );
 	}
 
 	protected Object[] getCurrentRow() {
 		return currentRow;
 	}
 
 	/**
 	 * @see org.hibernate.ScrollableResults#scroll(int)
 	 */
 	public boolean scroll(int i) throws HibernateException {
 		try {
 			boolean result = getResultSet().relative(i);
 			prepareCurrentRow(result);
 			return result;
 		}
 		catch (SQLException sqle) {
 			throw getSession().getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not advance using scroll()"
 				);
 		}
 	}
 
 	/**
 	 * @see org.hibernate.ScrollableResults#first()
 	 */
 	public boolean first() throws HibernateException {
 		try {
 			boolean result = getResultSet().first();
 			prepareCurrentRow(result);
 			return result;
 		}
 		catch (SQLException sqle) {
 			throw getSession().getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not advance using first()"
 				);
 		}
 	}
 
 	/**
 	 * @see org.hibernate.ScrollableResults#last()
 	 */
 	public boolean last() throws HibernateException {
 		try {
 			boolean result = getResultSet().last();
 			prepareCurrentRow(result);
 			return result;
 		}
 		catch (SQLException sqle) {
 			throw getSession().getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not advance using last()"
 				);
 		}
 	}
 
 	/**
 	 * @see org.hibernate.ScrollableResults#next()
 	 */
 	public boolean next() throws HibernateException {
 		try {
 			boolean result = getResultSet().next();
 			prepareCurrentRow(result);
 			return result;
 		}
 		catch (SQLException sqle) {
 			throw getSession().getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not advance using next()"
 				);
 		}
 	}
 
 	/**
 	 * @see org.hibernate.ScrollableResults#previous()
 	 */
 	public boolean previous() throws HibernateException {
 		try {
 			boolean result = getResultSet().previous();
 			prepareCurrentRow(result);
 			return result;
 		}
 		catch (SQLException sqle) {
 			throw getSession().getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not advance using previous()"
 				);
 		}
 	}
 
 	/**
 	 * @see org.hibernate.ScrollableResults#afterLast()
 	 */
 	public void afterLast() throws HibernateException {
 		try {
 			getResultSet().afterLast();
 		}
 		catch (SQLException sqle) {
 			throw getSession().getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"exception calling afterLast()"
 				);
 		}
 	}
 
 	/**
 	 * @see org.hibernate.ScrollableResults#beforeFirst()
 	 */
 	public void beforeFirst() throws HibernateException {
 		try {
 			getResultSet().beforeFirst();
 		}
 		catch (SQLException sqle) {
 			throw getSession().getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"exception calling beforeFirst()"
 				);
 		}
 	}
 
 	/**
 	 * @see org.hibernate.ScrollableResults#isFirst()
 	 */
 	public boolean isFirst() throws HibernateException {
 		try {
 			return getResultSet().isFirst();
 		}
 		catch (SQLException sqle) {
 			throw getSession().getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"exception calling isFirst()"
 				);
 		}
 	}
 
 	/**
 	 * @see org.hibernate.ScrollableResults#isLast()
 	 */
 	public boolean isLast() throws HibernateException {
 		try {
 			return getResultSet().isLast();
 		}
 		catch (SQLException sqle) {
 			throw getSession().getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"exception calling isLast()"
 				);
 		}
 	}
 
 	public int getRowNumber() throws HibernateException {
 		try {
 			return getResultSet().getRow()-1;
 		}
 		catch (SQLException sqle) {
 			throw getSession().getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"exception calling getRow()"
 				);
 		}
 	}
 
 	public boolean setRowNumber(int rowNumber) throws HibernateException {
 		if (rowNumber>=0) rowNumber++;
 		try {
 			boolean result = getResultSet().absolute(rowNumber);
 			prepareCurrentRow(result);
 			return result;
 		}
 		catch (SQLException sqle) {
 			throw getSession().getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not advance using absolute()"
 				);
 		}
 	}
 
 	private void prepareCurrentRow(boolean underlyingScrollSuccessful) 
 	throws HibernateException {
 		
 		if (!underlyingScrollSuccessful) {
 			currentRow = null;
 			return;
 		}
 
 		Object result = getLoader().loadSingleRow(
 				getResultSet(),
 				getSession(),
 				getQueryParameters(),
 				false
 		);
 		if ( result != null && result.getClass().isArray() ) {
 			currentRow = (Object[]) result;
 		}
 		else {
 			currentRow = new Object[] { result };
 		}
 
 		if ( getHolderInstantiator() != null ) {
 			currentRow = new Object[] { getHolderInstantiator().instantiate(currentRow) };
 		}
 
 		afterScrollOperation();
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java
index 1baa86829b..bb78df3c5c 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java
@@ -1,1159 +1,1159 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import javax.naming.NamingException;
 import javax.naming.Reference;
 import javax.naming.StringRefAddr;
 import java.io.IOException;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.ObjectStreamException;
 import java.io.Serializable;
 import java.sql.Connection;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.Cache;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.EntityMode;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.MappingException;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.QueryException;
 import org.hibernate.Session;
 import org.hibernate.SessionBuilder;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.StatelessSession;
 import org.hibernate.StatelessSessionBuilder;
 import org.hibernate.TypeHelper;
 import org.hibernate.cache.internal.CacheDataDescriptionImpl;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.cache.spi.CollectionRegion;
 import org.hibernate.cache.spi.EntityRegion;
 import org.hibernate.cache.spi.QueryCache;
 import org.hibernate.cache.spi.Region;
 import org.hibernate.cache.spi.UpdateTimestampsCache;
 import org.hibernate.cache.spi.access.AccessType;
 import org.hibernate.cache.spi.access.CollectionRegionAccessStrategy;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.Settings;
 import org.hibernate.context.internal.ThreadLocalSessionContext;
 import org.hibernate.context.spi.CurrentSessionContext;
 import org.hibernate.context.internal.JTASessionContext;
 import org.hibernate.context.internal.ManagedSessionContext;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.function.SQLFunctionRegistry;
 import org.hibernate.engine.query.spi.QueryPlanCache;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.profile.Association;
 import org.hibernate.engine.profile.Fetch;
 import org.hibernate.engine.profile.FetchProfile;
 import org.hibernate.engine.query.spi.sql.NativeSQLQuerySpecification;
 import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
 import org.hibernate.engine.transaction.spi.TransactionEnvironment;
 import org.hibernate.exception.spi.SQLExceptionConverter;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.UUIDGenerator;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.internal.util.collections.EmptyIterator;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.metadata.CollectionMetadata;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.persister.spi.PersisterFactory;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.integrator.spi.IntegratorService;
 import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.jndi.spi.JndiService;
 import org.hibernate.service.jta.platform.spi.JtaPlatform;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.service.spi.SessionFactoryServiceRegistryFactory;
 import org.hibernate.stat.Statistics;
 import org.hibernate.stat.spi.StatisticsImplementor;
 import org.hibernate.tool.hbm2ddl.SchemaExport;
 import org.hibernate.tool.hbm2ddl.SchemaUpdate;
 import org.hibernate.tool.hbm2ddl.SchemaValidator;
 import org.hibernate.tuple.entity.EntityTuplizer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeResolver;
 
 
 /**
  * Concrete implementation of the <tt>SessionFactory</tt> interface. Has the following
  * responsibilities
  * <ul>
  * <li>caches configuration settings (immutably)
  * <li>caches "compiled" mappings ie. <tt>EntityPersister</tt>s and
  *     <tt>CollectionPersister</tt>s (immutable)
  * <li>caches "compiled" queries (memory sensitive cache)
  * <li>manages <tt>PreparedStatement</tt>s
  * <li> delegates JDBC <tt>Connection</tt> management to the <tt>ConnectionProvider</tt>
  * <li>factory for instances of <tt>SessionImpl</tt>
  * </ul>
  * This class must appear immutable to clients, even if it does all kinds of caching
  * and pooling under the covers. It is crucial that the class is not only thread
  * safe, but also highly concurrent. Synchronization must be used extremely sparingly.
  *
  * @see org.hibernate.service.jdbc.connections.spi.ConnectionProvider
  * @see org.hibernate.Session
- * @see org.hibernate.hql.QueryTranslator
+ * @see org.hibernate.hql.spi.QueryTranslator
  * @see org.hibernate.persister.entity.EntityPersister
  * @see org.hibernate.persister.collection.CollectionPersister
  * @author Gavin King
  */
 public final class SessionFactoryImpl
 		implements SessionFactory, SessionFactoryImplementor {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, SessionFactoryImpl.class.getName());
 	private static final IdentifierGenerator UUID_GENERATOR = UUIDGenerator.buildSessionFactoryUniqueIdentifierGenerator();
 
 	private final String name;
 	private final String uuid;
 
 	private final transient Map entityPersisters;
 	private final transient Map<String,ClassMetadata> classMetadata;
 	private final transient Map collectionPersisters;
 	private final transient Map collectionMetadata;
 	private final transient Map<String,Set<String>> collectionRolesByEntityParticipant;
 	private final transient Map identifierGenerators;
 	private final transient Map namedQueries;
 	private final transient Map namedSqlQueries;
 	private final transient Map sqlResultSetMappings;
 	private final transient Map filters;
 	private final transient Map fetchProfiles;
 	private final transient Map imports;
 	private final transient Interceptor interceptor;
 	private final transient SessionFactoryServiceRegistry serviceRegistry;
 	private final transient Settings settings;
 	private final transient Properties properties;
 	private transient SchemaExport schemaExport;
 	private final transient QueryCache queryCache;
 	private final transient UpdateTimestampsCache updateTimestampsCache;
 	private final transient Map<String,QueryCache> queryCaches;
 	private final transient ConcurrentMap<String,Region> allCacheRegions = new ConcurrentHashMap<String, Region>();
 	private final transient CurrentSessionContext currentSessionContext;
 	private final transient EntityNotFoundDelegate entityNotFoundDelegate;
 	private final transient SQLFunctionRegistry sqlFunctionRegistry;
 	private final transient SessionFactoryObserverChain observer = new SessionFactoryObserverChain();
 	private final transient HashMap entityNameResolvers = new HashMap();
 	private final transient QueryPlanCache queryPlanCache;
 	private final transient Cache cacheAccess = new CacheImpl();
 	private transient boolean isClosed = false;
 	private final transient TypeResolver typeResolver;
 	private final transient TypeHelper typeHelper;
 	private final transient TransactionEnvironment transactionEnvironment;
 
 	public SessionFactoryImpl(
 			Configuration cfg,
 	        Mapping mapping,
 			ServiceRegistry serviceRegistry,
 	        Settings settings,
 			SessionFactoryObserver observer) throws HibernateException {
         LOG.debug( "Building session factory" );
 
 		this.settings = settings;
 		this.interceptor = cfg.getInterceptor();
 
 		this.properties = new Properties();
 		this.properties.putAll( cfg.getProperties() );
 
 		this.serviceRegistry = serviceRegistry.getService( SessionFactoryServiceRegistryFactory.class ).buildServiceRegistry(
 				this,
 				cfg
 		);
 		this.sqlFunctionRegistry = new SQLFunctionRegistry( getDialect(), cfg.getSqlFunctions() );
 		if ( observer != null ) {
 			this.observer.addObserver( observer );
 		}
 
 		this.typeResolver = cfg.getTypeResolver().scope( this );
 		this.typeHelper = new TypeLocatorImpl( typeResolver );
 
 		this.filters = new HashMap();
 		this.filters.putAll( cfg.getFilterDefinitions() );
 
         LOG.debugf("Session factory constructed with filter configurations : %s", filters);
         LOG.debugf("Instantiating session factory with properties: %s", properties);
 
 		// Caches
 		settings.getRegionFactory().start( settings, properties );
 		this.queryPlanCache = new QueryPlanCache( this );
 
 		// todo : everything above here consider implementing as standard SF service.  specifically: stats, caches, types, function-reg
 
 		class IntegratorObserver implements SessionFactoryObserver {
 			private ArrayList<Integrator> integrators = new ArrayList<Integrator>();
 
 			@Override
 			public void sessionFactoryCreated(SessionFactory factory) {
 			}
 
 			@Override
 			public void sessionFactoryClosed(SessionFactory factory) {
 				for ( Integrator integrator : integrators ) {
 					integrator.disintegrate( SessionFactoryImpl.this, SessionFactoryImpl.this.serviceRegistry );
 				}
 			}
 		}
 
 		final IntegratorObserver integratorObserver = new IntegratorObserver();
 		this.observer.addObserver( integratorObserver );
 		for ( Integrator integrator : serviceRegistry.getService( IntegratorService.class ).getIntegrators() ) {
 			integrator.integrate( cfg, this, this.serviceRegistry );
 			integratorObserver.integrators.add( integrator );
 		}
 
 		//Generators:
 
 		identifierGenerators = new HashMap();
 		Iterator classes = cfg.getClassMappings();
 		while ( classes.hasNext() ) {
 			PersistentClass model = (PersistentClass) classes.next();
 			if ( !model.isInherited() ) {
 				IdentifierGenerator generator = model.getIdentifier().createIdentifierGenerator(
 						cfg.getIdentifierGeneratorFactory(),
 						getDialect(),
 				        settings.getDefaultCatalogName(),
 				        settings.getDefaultSchemaName(),
 				        (RootClass) model
 				);
 				identifierGenerators.put( model.getEntityName(), generator );
 			}
 		}
 
 
 		///////////////////////////////////////////////////////////////////////
 		// Prepare persisters and link them up with their cache
 		// region/access-strategy
 
 		final String cacheRegionPrefix = settings.getCacheRegionPrefix() == null ? "" : settings.getCacheRegionPrefix() + ".";
 
 		entityPersisters = new HashMap();
 		Map entityAccessStrategies = new HashMap();
 		Map<String,ClassMetadata> classMeta = new HashMap<String,ClassMetadata>();
 		classes = cfg.getClassMappings();
 		while ( classes.hasNext() ) {
 			final PersistentClass model = (PersistentClass) classes.next();
 			model.prepareTemporaryTables( mapping, getDialect() );
 			final String cacheRegionName = cacheRegionPrefix + model.getRootClass().getCacheRegionName();
 			// cache region is defined by the root-class in the hierarchy...
 			EntityRegionAccessStrategy accessStrategy = ( EntityRegionAccessStrategy ) entityAccessStrategies.get( cacheRegionName );
 			if ( accessStrategy == null && settings.isSecondLevelCacheEnabled() ) {
 				final AccessType accessType = AccessType.fromExternalName( model.getCacheConcurrencyStrategy() );
 				if ( accessType != null ) {
                     LOG.trace("Building cache for entity data [" + model.getEntityName() + "]");
 					EntityRegion entityRegion = settings.getRegionFactory().buildEntityRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
 					accessStrategy = entityRegion.buildAccessStrategy( accessType );
 					entityAccessStrategies.put( cacheRegionName, accessStrategy );
 					allCacheRegions.put( cacheRegionName, entityRegion );
 				}
 			}
 			EntityPersister cp = serviceRegistry.getService( PersisterFactory.class ).createEntityPersister(
 					model,
 					accessStrategy,
 					this,
 					mapping
 			);
 			entityPersisters.put( model.getEntityName(), cp );
 			classMeta.put( model.getEntityName(), cp.getClassMetadata() );
 		}
 		this.classMetadata = Collections.unmodifiableMap(classMeta);
 
 		Map<String,Set<String>> tmpEntityToCollectionRoleMap = new HashMap<String,Set<String>>();
 		collectionPersisters = new HashMap();
 		Iterator collections = cfg.getCollectionMappings();
 		while ( collections.hasNext() ) {
 			Collection model = (Collection) collections.next();
 			final String cacheRegionName = cacheRegionPrefix + model.getCacheRegionName();
 			final AccessType accessType = AccessType.fromExternalName( model.getCacheConcurrencyStrategy() );
 			CollectionRegionAccessStrategy accessStrategy = null;
 			if ( accessType != null && settings.isSecondLevelCacheEnabled() ) {
                 LOG.trace("Building cache for collection data [" + model.getRole() + "]");
 				CollectionRegion collectionRegion = settings.getRegionFactory().buildCollectionRegion( cacheRegionName, properties, CacheDataDescriptionImpl
 						.decode( model ) );
 				accessStrategy = collectionRegion.buildAccessStrategy( accessType );
 				entityAccessStrategies.put( cacheRegionName, accessStrategy );
 				allCacheRegions.put( cacheRegionName, collectionRegion );
 			}
 			CollectionPersister persister = serviceRegistry.getService( PersisterFactory.class ).createCollectionPersister(
 					cfg,
 					model,
 					accessStrategy,
 					this
 			) ;
 			collectionPersisters.put( model.getRole(), persister.getCollectionMetadata() );
 			Type indexType = persister.getIndexType();
 			if ( indexType != null && indexType.isAssociationType() && !indexType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) indexType ).getAssociatedEntityName( this );
 				Set roles = tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 			Type elementType = persister.getElementType();
 			if ( elementType.isAssociationType() && !elementType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) elementType ).getAssociatedEntityName( this );
 				Set roles = tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 		}
 		collectionMetadata = Collections.unmodifiableMap(collectionPersisters);
 		Iterator itr = tmpEntityToCollectionRoleMap.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			entry.setValue( Collections.unmodifiableSet( ( Set ) entry.getValue() ) );
 		}
 		collectionRolesByEntityParticipant = Collections.unmodifiableMap( tmpEntityToCollectionRoleMap );
 
 		//Named Queries:
 		namedQueries = new HashMap( cfg.getNamedQueries() );
 		namedSqlQueries = new HashMap( cfg.getNamedSQLQueries() );
 		sqlResultSetMappings = new HashMap( cfg.getSqlResultSetMappings() );
 		imports = new HashMap( cfg.getImports() );
 
 		// after *all* persisters and named queries are registered
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			final EntityPersister persister = ( ( EntityPersister ) iter.next() );
 			persister.postInstantiate();
 			registerEntityNameResolvers( persister );
 
 		}
 		iter = collectionPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			final CollectionPersister persister = ( ( CollectionPersister ) iter.next() );
 			persister.postInstantiate();
 		}
 
 		//JNDI + Serialization:
 
 		name = settings.getSessionFactoryName();
 		try {
 			uuid = (String) UUID_GENERATOR.generate(null, null);
 		}
 		catch (Exception e) {
 			throw new AssertionFailure("Could not generate UUID");
 		}
 		SessionFactoryRegistry.INSTANCE.addSessionFactory( uuid, name, this, serviceRegistry.getService( JndiService.class ) );
 
         LOG.debugf("Instantiated session factory");
 
 		if ( settings.isAutoCreateSchema() ) {
 			new SchemaExport( serviceRegistry, cfg ).create( false, true );
 		}
 		if ( settings.isAutoUpdateSchema() ) {
 			new SchemaUpdate( serviceRegistry, cfg ).execute( false, true );
 		}
 		if ( settings.isAutoValidateSchema() ) {
 			new SchemaValidator( serviceRegistry, cfg ).validate();
 		}
 		if ( settings.isAutoDropSchema() ) {
 			schemaExport = new SchemaExport( serviceRegistry, cfg );
 		}
 
 		currentSessionContext = buildCurrentSessionContext();
 
 		if ( settings.isQueryCacheEnabled() ) {
 			updateTimestampsCache = new UpdateTimestampsCache(settings, properties);
 			queryCache = settings.getQueryCacheFactory()
 			        .getQueryCache(null, updateTimestampsCache, settings, properties);
 			queryCaches = new HashMap<String,QueryCache>();
 			allCacheRegions.put( updateTimestampsCache.getRegion().getName(), updateTimestampsCache.getRegion() );
 			allCacheRegions.put( queryCache.getRegion().getName(), queryCache.getRegion() );
 		}
 		else {
 			updateTimestampsCache = null;
 			queryCache = null;
 			queryCaches = null;
 		}
 
 		//checking for named queries
 		if ( settings.isNamedQueryStartupCheckingEnabled() ) {
 			Map errors = checkNamedQueries();
 			if ( !errors.isEmpty() ) {
 				Set keys = errors.keySet();
 				StringBuffer failingQueries = new StringBuffer( "Errors in named queries: " );
 				for ( Iterator iterator = keys.iterator() ; iterator.hasNext() ; ) {
 					String queryName = ( String ) iterator.next();
 					HibernateException e = ( HibernateException ) errors.get( queryName );
 					failingQueries.append( queryName );
                     if (iterator.hasNext()) failingQueries.append(", ");
                     LOG.namedQueryError(queryName, e);
 				}
 				throw new HibernateException( failingQueries.toString() );
 			}
 		}
 
 		// EntityNotFoundDelegate
 		EntityNotFoundDelegate entityNotFoundDelegate = cfg.getEntityNotFoundDelegate();
 		if ( entityNotFoundDelegate == null ) {
 			entityNotFoundDelegate = new EntityNotFoundDelegate() {
 				public void handleEntityNotFound(String entityName, Serializable id) {
 					throw new ObjectNotFoundException( id, entityName );
 				}
 			};
 		}
 		this.entityNotFoundDelegate = entityNotFoundDelegate;
 
 		// this needs to happen after persisters are all ready to go...
 		this.fetchProfiles = new HashMap();
 		itr = cfg.iterateFetchProfiles();
 		while ( itr.hasNext() ) {
 			final org.hibernate.mapping.FetchProfile mappingProfile =
 					( org.hibernate.mapping.FetchProfile ) itr.next();
 			final FetchProfile fetchProfile = new FetchProfile( mappingProfile.getName() );
 			Iterator fetches = mappingProfile.getFetches().iterator();
 			while ( fetches.hasNext() ) {
 				final org.hibernate.mapping.FetchProfile.Fetch mappingFetch =
 						( org.hibernate.mapping.FetchProfile.Fetch ) fetches.next();
 				// resolve the persister owning the fetch
 				final String entityName = getImportedClassName( mappingFetch.getEntity() );
 				final EntityPersister owner = ( EntityPersister ) ( entityName == null ? null : entityPersisters.get( entityName ) );
 				if ( owner == null ) {
 					throw new HibernateException(
 							"Unable to resolve entity reference [" + mappingFetch.getEntity()
 									+ "] in fetch profile [" + fetchProfile.getName() + "]"
 					);
 				}
 
 				// validate the specified association fetch
 				Type associationType = owner.getPropertyType( mappingFetch.getAssociation() );
 				if ( associationType == null || !associationType.isAssociationType() ) {
 					throw new HibernateException( "Fetch profile [" + fetchProfile.getName() + "] specified an invalid association" );
 				}
 
 				// resolve the style
 				final Fetch.Style fetchStyle = Fetch.Style.parse( mappingFetch.getStyle() );
 
 				// then construct the fetch instance...
 				fetchProfile.addFetch( new Association( owner, mappingFetch.getAssociation() ), fetchStyle );
 				( ( Loadable ) owner ).registerAffectingFetchProfile( fetchProfile.getName() );
 			}
 			fetchProfiles.put( fetchProfile.getName(), fetchProfile );
 		}
 
 		this.transactionEnvironment = new TransactionEnvironmentImpl( this );
 		this.observer.sessionFactoryCreated( this );
 	}
 
 	public Session openSession() throws HibernateException {
 		return withOptions().openSession();
 	}
 
 	public Session openTemporarySession() throws HibernateException {
 		return withOptions()
 				.autoClose( false )
 				.flushBeforeCompletion( false )
 				.connectionReleaseMode( ConnectionReleaseMode.AFTER_STATEMENT )
 				.openSession();
 	}
 
 	public Session getCurrentSession() throws HibernateException {
 		if ( currentSessionContext == null ) {
 			throw new HibernateException( "No CurrentSessionContext configured!" );
 		}
 		return currentSessionContext.currentSession();
 	}
 
 	@Override
 	public SessionBuilder withOptions() {
 		return new SessionBuilderImpl( this );
 	}
 
 	@Override
 	public StatelessSessionBuilder withStatelessOptions() {
 		return new StatelessSessionBuilderImpl( this );
 	}
 
 	public StatelessSession openStatelessSession() {
 		return withStatelessOptions().openStatelessSession();
 	}
 
 	public StatelessSession openStatelessSession(Connection connection) {
 		return withStatelessOptions().connection( connection ).openStatelessSession();
 	}
 
 	@Override
 	public void addObserver(SessionFactoryObserver observer) {
 		this.observer.addObserver( observer );
 	}
 
 	public TransactionEnvironment getTransactionEnvironment() {
 		return transactionEnvironment;
 	}
 
 	public Properties getProperties() {
 		return properties;
 	}
 
 	public IdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 		return null;
 	}
 
 	public TypeResolver getTypeResolver() {
 		return typeResolver;
 	}
 
 	private void registerEntityNameResolvers(EntityPersister persister) {
 		if ( persister.getEntityMetamodel() == null || persister.getEntityMetamodel().getTuplizerMapping() == null ) {
 			return;
 		}
 		Iterator itr = persister.getEntityMetamodel().getTuplizerMapping().iterateTuplizers();
 		while ( itr.hasNext() ) {
 			final EntityTuplizer tuplizer = ( EntityTuplizer ) itr.next();
 			registerEntityNameResolvers( tuplizer );
 		}
 	}
 
 	private void registerEntityNameResolvers(EntityTuplizer tuplizer) {
 		EntityNameResolver[] resolvers = tuplizer.getEntityNameResolvers();
 		if ( resolvers == null ) {
 			return;
 		}
 
 		for ( int i = 0; i < resolvers.length; i++ ) {
 			registerEntityNameResolver( resolvers[i], tuplizer.getEntityMode() );
 		}
 	}
 
 	public void registerEntityNameResolver(EntityNameResolver resolver, EntityMode entityMode) {
 		LinkedHashSet resolversForMode = ( LinkedHashSet ) entityNameResolvers.get( entityMode );
 		if ( resolversForMode == null ) {
 			resolversForMode = new LinkedHashSet();
 			entityNameResolvers.put( entityMode, resolversForMode );
 		}
 		resolversForMode.add( resolver );
 	}
 
 	public Iterator iterateEntityNameResolvers(EntityMode entityMode) {
 		Set actualEntityNameResolvers = ( Set ) entityNameResolvers.get( entityMode );
 		return actualEntityNameResolvers == null
 				? EmptyIterator.INSTANCE
 				: actualEntityNameResolvers.iterator();
 	}
 
 	public QueryPlanCache getQueryPlanCache() {
 		return queryPlanCache;
 	}
 
 	private Map checkNamedQueries() throws HibernateException {
 		Map errors = new HashMap();
 
 		// Check named HQL queries
         LOG.debugf("Checking %s named HQL queries", namedQueries.size());
 		Iterator itr = namedQueries.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			final String queryName = ( String ) entry.getKey();
 			final NamedQueryDefinition qd = ( NamedQueryDefinition ) entry.getValue();
 			// this will throw an error if there's something wrong.
 			try {
                 LOG.debugf("Checking named query: %s", queryName);
 				//TODO: BUG! this currently fails for named queries for non-POJO entities
 				queryPlanCache.getHQLQueryPlan( qd.getQueryString(), false, CollectionHelper.EMPTY_MAP );
 			}
 			catch ( QueryException e ) {
 				errors.put( queryName, e );
 			}
 			catch ( MappingException e ) {
 				errors.put( queryName, e );
 			}
 		}
 
         LOG.debugf("Checking %s named SQL queries", namedSqlQueries.size());
 		itr = namedSqlQueries.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			final String queryName = ( String ) entry.getKey();
 			final NamedSQLQueryDefinition qd = ( NamedSQLQueryDefinition ) entry.getValue();
 			// this will throw an error if there's something wrong.
 			try {
                 LOG.debugf("Checking named SQL query: %s", queryName);
 				// TODO : would be really nice to cache the spec on the query-def so as to not have to re-calc the hash;
 				// currently not doable though because of the resultset-ref stuff...
 				NativeSQLQuerySpecification spec;
 				if ( qd.getResultSetRef() != null ) {
 					ResultSetMappingDefinition definition = ( ResultSetMappingDefinition ) sqlResultSetMappings.get( qd.getResultSetRef() );
 					if ( definition == null ) {
 						throw new MappingException( "Unable to find resultset-ref definition: " + qd.getResultSetRef() );
 					}
 					spec = new NativeSQLQuerySpecification(
 							qd.getQueryString(),
 					        definition.getQueryReturns(),
 					        qd.getQuerySpaces()
 					);
 				}
 				else {
 					spec =  new NativeSQLQuerySpecification(
 							qd.getQueryString(),
 					        qd.getQueryReturns(),
 					        qd.getQuerySpaces()
 					);
 				}
 				queryPlanCache.getNativeSQLQueryPlan( spec );
 			}
 			catch ( QueryException e ) {
 				errors.put( queryName, e );
 			}
 			catch ( MappingException e ) {
 				errors.put( queryName, e );
 			}
 		}
 
 		return errors;
 	}
 
 	public EntityPersister getEntityPersister(String entityName) throws MappingException {
 		EntityPersister result = (EntityPersister) entityPersisters.get(entityName);
 		if (result==null) {
 			throw new MappingException( "Unknown entity: " + entityName );
 		}
 		return result;
 	}
 
 	public CollectionPersister getCollectionPersister(String role) throws MappingException {
 		CollectionPersister result = (CollectionPersister) collectionPersisters.get(role);
 		if (result==null) {
 			throw new MappingException( "Unknown collection role: " + role );
 		}
 		return result;
 	}
 
 	public Settings getSettings() {
 		return settings;
 	}
 
 	public JdbcServices getJdbcServices() {
 		return serviceRegistry.getService( JdbcServices.class );
 	}
 
 	public Dialect getDialect() {
 		if ( serviceRegistry == null ) {
 			throw new IllegalStateException( "Cannot determine dialect because serviceRegistry is null." );
 		}
 		return getJdbcServices().getDialect();
 	}
 
 	public Interceptor getInterceptor()
 	{
 		return interceptor;
 	}
 
 	public SQLExceptionConverter getSQLExceptionConverter() {
 		return getSQLExceptionHelper().getSqlExceptionConverter();
 	}
 
 	public SqlExceptionHelper getSQLExceptionHelper() {
 		return getJdbcServices().getSqlExceptionHelper();
 	}
 
 	public Set<String> getCollectionRolesByEntityParticipant(String entityName) {
 		return collectionRolesByEntityParticipant.get( entityName );
 	}
 
 	@Override
 	public Reference getReference() throws NamingException {
 		// from javax.naming.Referenceable
         LOG.debug( "Returning a Reference to the SessionFactory" );
 		return new Reference(
 				SessionFactoryImpl.class.getName(),
 				new StringRefAddr("uuid", uuid),
 				SessionFactoryRegistry.ObjectFactoryImpl.class.getName(),
 				null
 		);
 	}
 
 	private Object readResolve() throws ObjectStreamException {
         LOG.trace("Resolving serialized SessionFactory");
 		// look for the instance by uuid
 		Object result = SessionFactoryRegistry.INSTANCE.getSessionFactory( uuid );
 		if ( result == null ) {
 			// in case we were deserialized in a different JVM, look for an instance with the same name
 			// (alternatively we could do an actual JNDI lookup here....)
 			result = SessionFactoryRegistry.INSTANCE.getNamedSessionFactory( name );
             if ( result == null ) {
 				throw new InvalidObjectException( "Could not find a SessionFactory [uuid=" + uuid + ",name=" + name + "]" );
 			}
             LOG.debugf("Resolved SessionFactory by name");
         }
 		else {
 			LOG.debugf("Resolved SessionFactory by UUID");
 		}
 		return result;
 	}
 
 	public NamedQueryDefinition getNamedQuery(String queryName) {
 		return (NamedQueryDefinition) namedQueries.get(queryName);
 	}
 
 	public NamedSQLQueryDefinition getNamedSQLQuery(String queryName) {
 		return (NamedSQLQueryDefinition) namedSqlQueries.get(queryName);
 	}
 
 	public ResultSetMappingDefinition getResultSetMapping(String resultSetName) {
 		return (ResultSetMappingDefinition) sqlResultSetMappings.get(resultSetName);
 	}
 
 	public Type getIdentifierType(String className) throws MappingException {
 		return getEntityPersister(className).getIdentifierType();
 	}
 	public String getIdentifierPropertyName(String className) throws MappingException {
 		return getEntityPersister(className).getIdentifierPropertyName();
 	}
 
 	private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
         LOG.trace( "Deserializing" );
 		in.defaultReadObject();
         LOG.debugf( "Deserialized: %s", uuid );
 	}
 
 	private void writeObject(ObjectOutputStream out) throws IOException {
         LOG.debugf("Serializing: %s", uuid);
 		out.defaultWriteObject();
         LOG.trace("Serialized");
 	}
 
 	public Type[] getReturnTypes(String queryString) throws HibernateException {
 		return queryPlanCache.getHQLQueryPlan( queryString, false, CollectionHelper.EMPTY_MAP ).getReturnMetadata().getReturnTypes();
 	}
 
 	public String[] getReturnAliases(String queryString) throws HibernateException {
 		return queryPlanCache.getHQLQueryPlan( queryString, false, CollectionHelper.EMPTY_MAP ).getReturnMetadata().getReturnAliases();
 	}
 
 	public ClassMetadata getClassMetadata(Class persistentClass) throws HibernateException {
 		return getClassMetadata( persistentClass.getName() );
 	}
 
 	public CollectionMetadata getCollectionMetadata(String roleName) throws HibernateException {
 		return (CollectionMetadata) collectionMetadata.get(roleName);
 	}
 
 	public ClassMetadata getClassMetadata(String entityName) throws HibernateException {
 		return classMetadata.get(entityName);
 	}
 
 	/**
 	 * Return the names of all persistent (mapped) classes that extend or implement the
 	 * given class or interface, accounting for implicit/explicit polymorphism settings
 	 * and excluding mapped subclasses/joined-subclasses of other classes in the result.
 	 */
 	public String[] getImplementors(String className) throws MappingException {
 
 		final Class clazz;
 		try {
 			clazz = ReflectHelper.classForName(className);
 		}
 		catch (ClassNotFoundException cnfe) {
 			return new String[] { className }; //for a dynamic-class
 		}
 
 		ArrayList results = new ArrayList();
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			//test this entity to see if we must query it
 			EntityPersister testPersister = (EntityPersister) iter.next();
 			if ( testPersister instanceof Queryable ) {
 				Queryable testQueryable = (Queryable) testPersister;
 				String testClassName = testQueryable.getEntityName();
 				boolean isMappedClass = className.equals(testClassName);
 				if ( testQueryable.isExplicitPolymorphism() ) {
 					if ( isMappedClass ) {
 						return new String[] {className}; //NOTE EARLY EXIT
 					}
 				}
 				else {
 					if (isMappedClass) {
 						results.add(testClassName);
 					}
 					else {
 						final Class mappedClass = testQueryable.getMappedClass( EntityMode.POJO );
 						if ( mappedClass!=null && clazz.isAssignableFrom( mappedClass ) ) {
 							final boolean assignableSuperclass;
 							if ( testQueryable.isInherited() ) {
 								Class mappedSuperclass = getEntityPersister( testQueryable.getMappedSuperclass() ).getMappedClass( EntityMode.POJO);
 								assignableSuperclass = clazz.isAssignableFrom(mappedSuperclass);
 							}
 							else {
 								assignableSuperclass = false;
 							}
 							if ( !assignableSuperclass ) {
 								results.add( testClassName );
 							}
 						}
 					}
 				}
 			}
 		}
 		return (String[]) results.toArray( new String[ results.size() ] );
 	}
 
 	public String getImportedClassName(String className) {
 		String result = (String) imports.get(className);
 		if (result==null) {
 			try {
 				ReflectHelper.classForName( className );
 				return className;
 			}
 			catch (ClassNotFoundException cnfe) {
 				return null;
 			}
 		}
 		else {
 			return result;
 		}
 	}
 
 	public Map<String,ClassMetadata> getAllClassMetadata() throws HibernateException {
 		return classMetadata;
 	}
 
 	public Map getAllCollectionMetadata() throws HibernateException {
 		return collectionMetadata;
 	}
 
 	public Type getReferencedPropertyType(String className, String propertyName)
 		throws MappingException {
 		return getEntityPersister( className ).getPropertyType( propertyName );
 	}
 
 	public ConnectionProvider getConnectionProvider() {
 		return serviceRegistry.getService( JdbcServices.class ).getConnectionProvider();
 	}
 
 	/**
 	 * Closes the session factory, releasing all held resources.
 	 *
 	 * <ol>
 	 * <li>cleans up used cache regions and "stops" the cache provider.
 	 * <li>close the JDBC connection
 	 * <li>remove the JNDI binding
 	 * </ol>
 	 *
 	 * Note: Be aware that the sessionFactory instance still can
 	 * be a "heavy" object memory wise after close() has been called.  Thus
 	 * it is important to not keep referencing the instance to let the garbage
 	 * collector release the memory.
 	 */
 	public void close() throws HibernateException {
 
 		if ( isClosed ) {
             LOG.trace("Already closed");
 			return;
 		}
 
         LOG.closing();
 
 		isClosed = true;
 
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			EntityPersister p = (EntityPersister) iter.next();
 			if ( p.hasCache() ) {
 				p.getCacheAccessStrategy().getRegion().destroy();
 			}
 		}
 
 		iter = collectionPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			CollectionPersister p = (CollectionPersister) iter.next();
 			if ( p.hasCache() ) {
 				p.getCacheAccessStrategy().getRegion().destroy();
 			}
 		}
 
 		if ( settings.isQueryCacheEnabled() )  {
 			queryCache.destroy();
 
 			iter = queryCaches.values().iterator();
 			while ( iter.hasNext() ) {
 				QueryCache cache = (QueryCache) iter.next();
 				cache.destroy();
 			}
 			updateTimestampsCache.destroy();
 		}
 
 		settings.getRegionFactory().stop();
 
 		if ( settings.isAutoDropSchema() ) {
 			schemaExport.drop( false, true );
 		}
 
 		SessionFactoryRegistry.INSTANCE.removeSessionFactory(
 				uuid, name, serviceRegistry.getService( JndiService.class )
 		);
 
 		observer.sessionFactoryClosed( this );
 		serviceRegistry.destroy();
 	}
 
 	private class CacheImpl implements Cache {
 		public boolean containsEntity(Class entityClass, Serializable identifier) {
 			return containsEntity( entityClass.getName(), identifier );
 		}
 
 		public boolean containsEntity(String entityName, Serializable identifier) {
 			EntityPersister p = getEntityPersister( entityName );
 			return p.hasCache() &&
 					p.getCacheAccessStrategy().getRegion().contains( buildCacheKey( identifier, p ) );
 		}
 
 		public void evictEntity(Class entityClass, Serializable identifier) {
 			evictEntity( entityClass.getName(), identifier );
 		}
 
 		public void evictEntity(String entityName, Serializable identifier) {
 			EntityPersister p = getEntityPersister( entityName );
 			if ( p.hasCache() ) {
                 if (LOG.isDebugEnabled()) LOG.debugf("Evicting second-level cache: %s",
                                                      MessageHelper.infoString(p, identifier, SessionFactoryImpl.this));
 				p.getCacheAccessStrategy().evict( buildCacheKey( identifier, p ) );
 			}
 		}
 
 		private CacheKey buildCacheKey(Serializable identifier, EntityPersister p) {
 			return new CacheKey(
 					identifier,
 					p.getIdentifierType(),
 					p.getRootEntityName(),
 					EntityMode.POJO,			// we have to assume POJO
 					null, 						// and also assume non tenancy
 					SessionFactoryImpl.this
 			);
 		}
 
 		public void evictEntityRegion(Class entityClass) {
 			evictEntityRegion( entityClass.getName() );
 		}
 
 		public void evictEntityRegion(String entityName) {
 			EntityPersister p = getEntityPersister( entityName );
 			if ( p.hasCache() ) {
                 LOG.debugf("Evicting second-level cache: %s", p.getEntityName());
 				p.getCacheAccessStrategy().evictAll();
 			}
 		}
 
 		public void evictEntityRegions() {
 			Iterator entityNames = entityPersisters.keySet().iterator();
 			while ( entityNames.hasNext() ) {
 				evictEntityRegion( ( String ) entityNames.next() );
 			}
 		}
 
 		public boolean containsCollection(String role, Serializable ownerIdentifier) {
 			CollectionPersister p = getCollectionPersister( role );
 			return p.hasCache() &&
 					p.getCacheAccessStrategy().getRegion().contains( buildCacheKey( ownerIdentifier, p ) );
 		}
 
 		public void evictCollection(String role, Serializable ownerIdentifier) {
 			CollectionPersister p = getCollectionPersister( role );
 			if ( p.hasCache() ) {
                 if (LOG.isDebugEnabled()) LOG.debugf("Evicting second-level cache: %s",
                                                      MessageHelper.collectionInfoString(p, ownerIdentifier, SessionFactoryImpl.this));
 				CacheKey cacheKey = buildCacheKey( ownerIdentifier, p );
 				p.getCacheAccessStrategy().evict( cacheKey );
 			}
 		}
 
 		private CacheKey buildCacheKey(Serializable ownerIdentifier, CollectionPersister p) {
 			return new CacheKey(
 					ownerIdentifier,
 					p.getKeyType(),
 					p.getRole(),
 					EntityMode.POJO,			// we have to assume POJO
 					null,						// and also assume non tenancy
 					SessionFactoryImpl.this
 			);
 		}
 
 		public void evictCollectionRegion(String role) {
 			CollectionPersister p = getCollectionPersister( role );
 			if ( p.hasCache() ) {
                 LOG.debugf("Evicting second-level cache: %s", p.getRole());
 				p.getCacheAccessStrategy().evictAll();
 			}
 		}
 
 		public void evictCollectionRegions() {
 			Iterator collectionRoles = collectionPersisters.keySet().iterator();
 			while ( collectionRoles.hasNext() ) {
 				evictCollectionRegion( ( String ) collectionRoles.next() );
 			}
 		}
 
 		public boolean containsQuery(String regionName) {
 			return queryCaches.get( regionName ) != null;
 		}
 
 		public void evictDefaultQueryRegion() {
 			if ( settings.isQueryCacheEnabled() ) {
 				queryCache.clear();
 			}
 		}
 
 		public void evictQueryRegion(String regionName) {
             if (regionName == null) throw new NullPointerException(
                                                                    "Region-name cannot be null (use Cache#evictDefaultQueryRegion to evict the default query cache)");
             if (settings.isQueryCacheEnabled()) {
                 QueryCache namedQueryCache = queryCaches.get(regionName);
                 // TODO : cleanup entries in queryCaches + allCacheRegions ?
                 if (namedQueryCache != null) namedQueryCache.clear();
 			}
 		}
 
 		public void evictQueryRegions() {
 			if ( queryCaches != null ) {
 				for ( QueryCache queryCache : queryCaches.values() ) {
 					queryCache.clear();
 					// TODO : cleanup entries in queryCaches + allCacheRegions ?
 				}
 			}
 		}
 	}
 
 	public Cache getCache() {
 		return cacheAccess;
 	}
 
 	public void evictEntity(String entityName, Serializable id) throws HibernateException {
 		getCache().evictEntity( entityName, id );
 	}
 
 	public void evictEntity(String entityName) throws HibernateException {
 		getCache().evictEntityRegion( entityName );
 	}
 
 	public void evict(Class persistentClass, Serializable id) throws HibernateException {
 		getCache().evictEntity( persistentClass, id );
 	}
 
 	public void evict(Class persistentClass) throws HibernateException {
 		getCache().evictEntityRegion( persistentClass );
 	}
 
 	public void evictCollection(String roleName, Serializable id) throws HibernateException {
 		getCache().evictCollection( roleName, id );
 	}
 
 	public void evictCollection(String roleName) throws HibernateException {
 		getCache().evictCollectionRegion( roleName );
 	}
 
 	public void evictQueries() throws HibernateException {
 		if ( settings.isQueryCacheEnabled() ) {
 			queryCache.clear();
 		}
 	}
 
 	public void evictQueries(String regionName) throws HibernateException {
 		getCache().evictQueryRegion( regionName );
 	}
 
 	public UpdateTimestampsCache getUpdateTimestampsCache() {
 		return updateTimestampsCache;
 	}
 
 	public QueryCache getQueryCache() {
 		return queryCache;
 	}
 
 	public QueryCache getQueryCache(String regionName) throws HibernateException {
 		if ( regionName == null ) {
 			return getQueryCache();
 		}
 
 		if ( !settings.isQueryCacheEnabled() ) {
 			return null;
 		}
 
 		QueryCache currentQueryCache = queryCaches.get( regionName );
 		if ( currentQueryCache == null ) {
 			currentQueryCache = settings.getQueryCacheFactory().getQueryCache( regionName, updateTimestampsCache, settings, properties );
 			queryCaches.put( regionName, currentQueryCache );
 			allCacheRegions.put( currentQueryCache.getRegion().getName(), currentQueryCache.getRegion() );
 		}
 
 		return currentQueryCache;
 	}
 
 	public Region getSecondLevelCacheRegion(String regionName) {
 		return allCacheRegions.get( regionName );
 	}
 
 	public Map getAllSecondLevelCacheRegions() {
 		return new HashMap( allCacheRegions );
 	}
 
 	public boolean isClosed() {
 		return isClosed;
 	}
 
 	public Statistics getStatistics() {
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/Loader.java b/hibernate-core/src/main/java/org/hibernate/loader/Loader.java
index 0ee02a3e9c..7f3cd4c1ef 100644
--- a/hibernate-core/src/main/java/org/hibernate/loader/Loader.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/Loader.java
@@ -1,1071 +1,1071 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009 by Red Hat Inc and/or its affiliates or by
  * third-party contributors as indicated by either @author tags or express
  * copyright attribution statements applied by the authors.  All
  * third-party contributions are distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.loader;
 
 import java.io.Serializable;
 import java.sql.CallableStatement;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.cache.spi.QueryCache;
 import org.hibernate.cache.spi.QueryKey;
 import org.hibernate.engine.internal.TwoPhaseLoad;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.SubselectFetch;
 import org.hibernate.event.spi.EventSource;
 import org.hibernate.event.spi.PreLoadEvent;
+import org.hibernate.hql.internal.HolderInstantiator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollMode;
 import org.hibernate.ScrollableResults;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.WrongClassException;
 import org.hibernate.cache.spi.FilterKey;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.EntityUniqueKey;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.TypedValue;
 import org.hibernate.engine.jdbc.ColumnNameCache;
 import org.hibernate.event.spi.PostLoadEvent;
-import org.hibernate.hql.HolderInstantiator;
 import org.hibernate.internal.FetchingScrollableResultsImpl;
 import org.hibernate.internal.ScrollableResultsImpl;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.UniqueKeyLoadable;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.transform.CacheableResultTransformer;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.hibernate.type.VersionType;
 
 /**
  * Abstract superclass of object loading (and querying) strategies. This class implements
  * useful common functionality that concrete loaders delegate to. It is not intended that this
  * functionality would be directly accessed by client code. (Hence, all methods of this class
  * are declared <tt>protected</tt> or <tt>private</tt>.) This class relies heavily upon the
  * <tt>Loadable</tt> interface, which is the contract between this class and
  * <tt>EntityPersister</tt>s that may be loaded by it.<br>
  * <br>
  * The present implementation is able to load any number of columns of entities and at most
  * one collection role per query.
  *
  * @author Gavin King
  * @see org.hibernate.persister.entity.Loadable
  */
 public abstract class Loader {
 
     protected static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, Loader.class.getName());
 
 	private final SessionFactoryImplementor factory;
 	private ColumnNameCache columnNameCache;
 
 	public Loader(SessionFactoryImplementor factory) {
 		this.factory = factory;
 	}
 
 	/**
 	 * The SQL query string to be called; implemented by all subclasses
 	 *
 	 * @return The sql command this loader should use to get its {@link ResultSet}.
 	 */
 	protected abstract String getSQLString();
 
 	/**
 	 * An array of persisters of entity classes contained in each row of results;
 	 * implemented by all subclasses
 	 *
 	 * @return The entity persisters.
 	 */
 	protected abstract Loadable[] getEntityPersisters();
 
 	/**
 	 * An array indicating whether the entities have eager property fetching
 	 * enabled.
 	 *
 	 * @return Eager property fetching indicators.
 	 */
 	protected boolean[] getEntityEagerPropertyFetches() {
 		return null;
 	}
 
 	/**
 	 * An array of indexes of the entity that owns a one-to-one association
 	 * to the entity at the given index (-1 if there is no "owner").  The
 	 * indexes contained here are relative to the result of
 	 * {@link #getEntityPersisters}.
 	 *
 	 * @return The owner indicators (see discussion above).
 	 */
 	protected int[] getOwners() {
 		return null;
 	}
 
 	/**
 	 * An array of the owner types corresponding to the {@link #getOwners()}
 	 * returns.  Indices indicating no owner would be null here.
 	 *
 	 * @return The types for the owners.
 	 */
 	protected EntityType[] getOwnerAssociationTypes() {
 		return null;
 	}
 
 	/**
 	 * An (optional) persister for a collection to be initialized; only
 	 * collection loaders return a non-null value
 	 */
 	protected CollectionPersister[] getCollectionPersisters() {
 		return null;
 	}
 
 	/**
 	 * Get the index of the entity that owns the collection, or -1
 	 * if there is no owner in the query results (ie. in the case of a
 	 * collection initializer) or no collection.
 	 */
 	protected int[] getCollectionOwners() {
 		return null;
 	}
 
 	protected int[][] getCompositeKeyManyToOneTargetIndices() {
 		return null;
 	}
 
 	/**
 	 * What lock options does this load entities with?
 	 *
 	 * @param lockOptions a collection of lock options specified dynamically via the Query interface
 	 */
 	//protected abstract LockOptions[] getLockOptions(Map lockOptions);
 	protected abstract LockMode[] getLockModes(LockOptions lockOptions);
 
 	/**
 	 * Append <tt>FOR UPDATE OF</tt> clause, if necessary. This
 	 * empty superclass implementation merely returns its first
 	 * argument.
 	 */
 	protected String applyLocks(String sql, LockOptions lockOptions, Dialect dialect) throws HibernateException {
 		return sql;
 	}
 
 	/**
 	 * Does this query return objects that might be already cached
 	 * by the session, whose lock mode may need upgrading
 	 */
 	protected boolean upgradeLocks() {
 		return false;
 	}
 
 	/**
 	 * Return false is this loader is a batch entity loader
 	 */
 	protected boolean isSingleRowLoader() {
 		return false;
 	}
 
 	/**
 	 * Get the SQL table aliases of entities whose
 	 * associations are subselect-loadable, returning
 	 * null if this loader does not support subselect
 	 * loading
 	 */
 	protected String[] getAliases() {
 		return null;
 	}
 
 	/**
 	 * Modify the SQL, adding lock hints and comments, if necessary
 	 */
 	protected String preprocessSQL(String sql, QueryParameters parameters, Dialect dialect)
 			throws HibernateException {
 
 		sql = applyLocks( sql, parameters.getLockOptions(), dialect );
 
 		return getFactory().getSettings().isCommentsEnabled() ?
 				prependComment( sql, parameters ) : sql;
 	}
 
 	private String prependComment(String sql, QueryParameters parameters) {
 		String comment = parameters.getComment();
 		if ( comment == null ) {
 			return sql;
 		}
 		else {
 			return new StringBuffer( comment.length() + sql.length() + 5 )
 					.append( "/* " )
 					.append( comment )
 					.append( " */ " )
 					.append( sql )
 					.toString();
 		}
 	}
 
 	/**
 	 * Execute an SQL query and attempt to instantiate instances of the class mapped by the given
 	 * persister from each row of the <tt>ResultSet</tt>. If an object is supplied, will attempt to
 	 * initialize that object. If a collection is supplied, attempt to initialize that collection.
 	 */
 	private List doQueryAndInitializeNonLazyCollections(
 			final SessionImplementor session,
 			final QueryParameters queryParameters,
 			final boolean returnProxies) throws HibernateException, SQLException {
 		return doQueryAndInitializeNonLazyCollections(
 				session,
 				queryParameters,
 				returnProxies,
 				null
 		);
 	}
 
 	private List doQueryAndInitializeNonLazyCollections(
 			final SessionImplementor session,
 			final QueryParameters queryParameters,
 			final boolean returnProxies,
 			final ResultTransformer forcedResultTransformer)
 			throws HibernateException, SQLException {
 		final PersistenceContext persistenceContext = session.getPersistenceContext();
 		boolean defaultReadOnlyOrig = persistenceContext.isDefaultReadOnly();
 		if ( queryParameters.isReadOnlyInitialized() ) {
 			// The read-only/modifiable mode for the query was explicitly set.
 			// Temporarily set the default read-only/modifiable setting to the query's setting.
 			persistenceContext.setDefaultReadOnly( queryParameters.isReadOnly() );
 		}
 		else {
 			// The read-only/modifiable setting for the query was not initialized.
 			// Use the default read-only/modifiable from the persistence context instead.
 			queryParameters.setReadOnly( persistenceContext.isDefaultReadOnly() );
 		}
 		persistenceContext.beforeLoad();
 		List result;
 		try {
 			try {
 				result = doQuery( session, queryParameters, returnProxies, forcedResultTransformer );
 			}
 			finally {
 				persistenceContext.afterLoad();
 			}
 			persistenceContext.initializeNonLazyCollections();
 		}
 		finally {
 			// Restore the original default
 			persistenceContext.setDefaultReadOnly( defaultReadOnlyOrig );
 		}
 		return result;
 	}
 
 	/**
 	 * Loads a single row from the result set.  This is the processing used from the
 	 * ScrollableResults where no collection fetches were encountered.
 	 *
 	 * @param resultSet The result set from which to do the load.
 	 * @param session The session from which the request originated.
 	 * @param queryParameters The query parameters specified by the user.
 	 * @param returnProxies Should proxies be generated
 	 * @return The loaded "row".
 	 * @throws HibernateException
 	 */
 	public Object loadSingleRow(
 	        final ResultSet resultSet,
 	        final SessionImplementor session,
 	        final QueryParameters queryParameters,
 	        final boolean returnProxies) throws HibernateException {
 
 		final int entitySpan = getEntityPersisters().length;
 		final List hydratedObjects = entitySpan == 0 ?
 				null : new ArrayList( entitySpan );
 
 		final Object result;
 		try {
 			result = getRowFromResultSet(
 			        resultSet,
 					session,
 					queryParameters,
 					getLockModes( queryParameters.getLockOptions() ),
 					null,
 					hydratedObjects,
 					new EntityKey[entitySpan],
 					returnProxies
 				);
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not read next row of results",
 			        getSQLString()
 				);
 		}
 
 		initializeEntitiesAndCollections(
 				hydratedObjects,
 				resultSet,
 				session,
 				queryParameters.isReadOnly( session )
 			);
 		session.getPersistenceContext().initializeNonLazyCollections();
 		return result;
 	}
 
 	private Object sequentialLoad(
 	        final ResultSet resultSet,
 	        final SessionImplementor session,
 	        final QueryParameters queryParameters,
 	        final boolean returnProxies,
 	        final EntityKey keyToRead) throws HibernateException {
 
 		final int entitySpan = getEntityPersisters().length;
 		final List hydratedObjects = entitySpan == 0 ?
 				null : new ArrayList( entitySpan );
 
 		Object result = null;
 		final EntityKey[] loadedKeys = new EntityKey[entitySpan];
 
 		try {
 			do {
 				Object loaded = getRowFromResultSet(
 						resultSet,
 						session,
 						queryParameters,
 						getLockModes( queryParameters.getLockOptions() ),
 						null,
 						hydratedObjects,
 						loadedKeys,
 						returnProxies
 					);
 				if ( result == null ) {
 					result = loaded;
 				}
 			}
 			while ( keyToRead.equals( loadedKeys[0] ) && resultSet.next() );
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not doAfterTransactionCompletion sequential read of results (forward)",
 			        getSQLString()
 				);
 		}
 
 		initializeEntitiesAndCollections(
 				hydratedObjects,
 				resultSet,
 				session,
 				queryParameters.isReadOnly( session )
 			);
 		session.getPersistenceContext().initializeNonLazyCollections();
 		return result;
 	}
 
 	/**
 	 * Loads a single logical row from the result set moving forward.  This is the
 	 * processing used from the ScrollableResults where there were collection fetches
 	 * encountered; thus a single logical row may have multiple rows in the underlying
 	 * result set.
 	 *
 	 * @param resultSet The result set from which to do the load.
 	 * @param session The session from which the request originated.
 	 * @param queryParameters The query parameters specified by the user.
 	 * @param returnProxies Should proxies be generated
 	 * @return The loaded "row".
 	 * @throws HibernateException
 	 */
 	public Object loadSequentialRowsForward(
 	        final ResultSet resultSet,
 	        final SessionImplementor session,
 	        final QueryParameters queryParameters,
 	        final boolean returnProxies) throws HibernateException {
 
 		// note that for sequential scrolling, we make the assumption that
 		// the first persister element is the "root entity"
 
 		try {
 			if ( resultSet.isAfterLast() ) {
 				// don't even bother trying to read further
 				return null;
 			}
 
 			if ( resultSet.isBeforeFirst() ) {
 				resultSet.next();
 			}
 
 			// We call getKeyFromResultSet() here so that we can know the
 			// key value upon which to doAfterTransactionCompletion the breaking logic.  However,
 			// it is also then called from getRowFromResultSet() which is certainly
 			// not the most efficient.  But the call here is needed, and there
 			// currently is no other way without refactoring of the doQuery()/getRowFromResultSet()
 			// methods
 			final EntityKey currentKey = getKeyFromResultSet(
 					0,
 					getEntityPersisters()[0],
 					null,
 					resultSet,
 					session
 				);
 
 			return sequentialLoad( resultSet, session, queryParameters, returnProxies, currentKey );
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not doAfterTransactionCompletion sequential read of results (forward)",
 			        getSQLString()
 				);
 		}
 	}
 
 	/**
 	 * Loads a single logical row from the result set moving forward.  This is the
 	 * processing used from the ScrollableResults where there were collection fetches
 	 * encountered; thus a single logical row may have multiple rows in the underlying
 	 * result set.
 	 *
 	 * @param resultSet The result set from which to do the load.
 	 * @param session The session from which the request originated.
 	 * @param queryParameters The query parameters specified by the user.
 	 * @param returnProxies Should proxies be generated
 	 * @return The loaded "row".
 	 * @throws HibernateException
 	 */
 	public Object loadSequentialRowsReverse(
 	        final ResultSet resultSet,
 	        final SessionImplementor session,
 	        final QueryParameters queryParameters,
 	        final boolean returnProxies,
 	        final boolean isLogicallyAfterLast) throws HibernateException {
 
 		// note that for sequential scrolling, we make the assumption that
 		// the first persister element is the "root entity"
 
 		try {
 			if ( resultSet.isFirst() ) {
 				// don't even bother trying to read any further
 				return null;
 			}
 
 			EntityKey keyToRead = null;
 			// This check is needed since processing leaves the cursor
 			// after the last physical row for the current logical row;
 			// thus if we are after the last physical row, this might be
 			// caused by either:
 			//      1) scrolling to the last logical row
 			//      2) scrolling past the last logical row
 			// In the latter scenario, the previous logical row
 			// really is the last logical row.
 			//
 			// In all other cases, we should process back two
 			// logical records (the current logic row, plus the
 			// previous logical row).
 			if ( resultSet.isAfterLast() && isLogicallyAfterLast ) {
 				// position cursor to the last row
 				resultSet.last();
 				keyToRead = getKeyFromResultSet(
 						0,
 						getEntityPersisters()[0],
 						null,
 						resultSet,
 						session
 					);
 			}
 			else {
 				// Since the result set cursor is always left at the first
 				// physical row after the "last processed", we need to jump
 				// back one position to get the key value we are interested
 				// in skipping
 				resultSet.previous();
 
 				// sequentially read the result set in reverse until we recognize
 				// a change in the key value.  At that point, we are pointed at
 				// the last physical sequential row for the logical row in which
 				// we are interested in processing
 				boolean firstPass = true;
 				final EntityKey lastKey = getKeyFromResultSet(
 						0,
 						getEntityPersisters()[0],
 						null,
 						resultSet,
 						session
 					);
 				while ( resultSet.previous() ) {
 					EntityKey checkKey = getKeyFromResultSet(
 							0,
 							getEntityPersisters()[0],
 							null,
 							resultSet,
 							session
 						);
 
 					if ( firstPass ) {
 						firstPass = false;
 						keyToRead = checkKey;
 					}
 
 					if ( !lastKey.equals( checkKey ) ) {
 						break;
 					}
 				}
 
 			}
 
 			// Read backwards until we read past the first physical sequential
 			// row with the key we are interested in loading
 			while ( resultSet.previous() ) {
 				EntityKey checkKey = getKeyFromResultSet(
 						0,
 						getEntityPersisters()[0],
 						null,
 						resultSet,
 						session
 					);
 
 				if ( !keyToRead.equals( checkKey ) ) {
 					break;
 				}
 			}
 
 			// Finally, read ahead one row to position result set cursor
 			// at the first physical row we are interested in loading
 			resultSet.next();
 
 			// and doAfterTransactionCompletion the load
 			return sequentialLoad( resultSet, session, queryParameters, returnProxies, keyToRead );
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not doAfterTransactionCompletion sequential read of results (forward)",
 			        getSQLString()
 				);
 		}
 	}
 
 	private static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SessionImplementor session) {
 		final Object optionalObject = queryParameters.getOptionalObject();
 		final Serializable optionalId = queryParameters.getOptionalId();
 		final String optionalEntityName = queryParameters.getOptionalEntityName();
 
 		if ( optionalObject != null && optionalEntityName != null ) {
 			return session.generateEntityKey( optionalId, session.getEntityPersister( optionalEntityName, optionalObject ) );
 		}
 		else {
 			return null;
 		}
 
 	}
 
 	private Object getRowFromResultSet(
 	        final ResultSet resultSet,
 	        final SessionImplementor session,
 	        final QueryParameters queryParameters,
 	        final LockMode[] lockModesArray,
 	        final EntityKey optionalObjectKey,
 	        final List hydratedObjects,
 	        final EntityKey[] keys,
 	        boolean returnProxies) throws SQLException, HibernateException {
 		return getRowFromResultSet(
 				resultSet,
 				session,
 				queryParameters,
 				lockModesArray,
 				optionalObjectKey,
 				hydratedObjects,
 				keys,
 				returnProxies,
 				null
 		);
 	}
 
 	private Object getRowFromResultSet(
 	        final ResultSet resultSet,
 	        final SessionImplementor session,
 	        final QueryParameters queryParameters,
 	        final LockMode[] lockModesArray,
 	        final EntityKey optionalObjectKey,
 	        final List hydratedObjects,
 	        final EntityKey[] keys,
 	        boolean returnProxies,
 	        ResultTransformer forcedResultTransformer) throws SQLException, HibernateException {
 		final Loadable[] persisters = getEntityPersisters();
 		final int entitySpan = persisters.length;
 		extractKeysFromResultSet( persisters, queryParameters, resultSet, session, keys, lockModesArray, hydratedObjects );
 
 		registerNonExists( keys, persisters, session );
 
 		// this call is side-effecty
 		Object[] row = getRow(
 		        resultSet,
 				persisters,
 				keys,
 				queryParameters.getOptionalObject(),
 				optionalObjectKey,
 				lockModesArray,
 				hydratedObjects,
 				session
 		);
 
 		readCollectionElements( row, resultSet, session );
 
 		if ( returnProxies ) {
 			// now get an existing proxy for each row element (if there is one)
 			for ( int i = 0; i < entitySpan; i++ ) {
 				Object entity = row[i];
 				Object proxy = session.getPersistenceContext().proxyFor( persisters[i], keys[i], entity );
 				if ( entity != proxy ) {
 					// force the proxy to resolve itself
 					( (HibernateProxy) proxy ).getHibernateLazyInitializer().setImplementation(entity);
 					row[i] = proxy;
 				}
 			}
 		}
 
 		applyPostLoadLocks( row, lockModesArray, session );
 
 		return forcedResultTransformer == null ?
 				getResultColumnOrRow( row, queryParameters.getResultTransformer(), resultSet, session ) :
 				forcedResultTransformer.transformTuple(
 						getResultRow( row, resultSet, session ),
 						getResultRowAliases()
 				)
 		;
 	}
 
 	protected void extractKeysFromResultSet(
 			Loadable[] persisters,
 			QueryParameters queryParameters,
 			ResultSet resultSet,
 			SessionImplementor session,
 			EntityKey[] keys,
 			LockMode[] lockModes,
 			List hydratedObjects) throws SQLException {
 		final int entitySpan = persisters.length;
 
 		final int numberOfPersistersToProcess;
 		final Serializable optionalId = queryParameters.getOptionalId();
 		if ( isSingleRowLoader() && optionalId != null ) {
 			keys[ entitySpan - 1 ] = session.generateEntityKey( optionalId, persisters[ entitySpan - 1 ] );
 			// skip the last persister below...
 			numberOfPersistersToProcess = entitySpan - 1;
 		}
 		else {
 			numberOfPersistersToProcess = entitySpan;
 		}
 
 		final Object[] hydratedKeyState = new Object[numberOfPersistersToProcess];
 
 		for ( int i = 0; i < numberOfPersistersToProcess; i++ ) {
 			final Type idType = persisters[i].getIdentifierType();
 			hydratedKeyState[i] = idType.hydrate( resultSet, getEntityAliases()[i].getSuffixedKeyAliases(), session, null );
 		}
 
 		for ( int i = 0; i < numberOfPersistersToProcess; i++ ) {
 			final Type idType = persisters[i].getIdentifierType();
 			if ( idType.isComponentType() && getCompositeKeyManyToOneTargetIndices() != null ) {
 				// we may need to force resolve any key-many-to-one(s)
 				int[] keyManyToOneTargetIndices = getCompositeKeyManyToOneTargetIndices()[i];
 				// todo : better solution is to order the index processing based on target indices
 				//		that would account for multiple levels whereas this scheme does not
 				if ( keyManyToOneTargetIndices != null ) {
 					for ( int targetIndex : keyManyToOneTargetIndices ) {
 						if ( targetIndex < numberOfPersistersToProcess ) {
 							final Type targetIdType = persisters[targetIndex].getIdentifierType();
 							final Serializable targetId = (Serializable) targetIdType.resolve(
 									hydratedKeyState[targetIndex],
 									session,
 									null
 							);
 							// todo : need a way to signal that this key is resolved and its data resolved
 							keys[targetIndex] = session.generateEntityKey( targetId, persisters[targetIndex] );
 						}
 
 						// this part copied from #getRow, this section could be refactored out
 						Object object = session.getEntityUsingInterceptor( keys[targetIndex] );
 						if ( object != null ) {
 							//its already loaded so don't need to hydrate it
 							instanceAlreadyLoaded(
 									resultSet,
 									targetIndex,
 									persisters[targetIndex],
 									keys[targetIndex],
 									object,
 									lockModes[targetIndex],
 									session
 							);
 						}
 						else {
 							instanceNotYetLoaded(
 									resultSet,
 									targetIndex,
 									persisters[targetIndex],
 									getEntityAliases()[targetIndex].getRowIdAlias(),
 									keys[targetIndex],
 									lockModes[targetIndex],
 									getOptionalObjectKey( queryParameters, session ),
 									queryParameters.getOptionalObject(),
 									hydratedObjects,
 									session
 							);
 						}
 					}
 				}
 			}
 			final Serializable resolvedId = (Serializable) idType.resolve( hydratedKeyState[i], session, null );
 			keys[i] = resolvedId == null ? null : session.generateEntityKey( resolvedId, persisters[i] );
 		}
 	}
 
 	private Serializable determineResultId(SessionImplementor session, Serializable optionalId, Type idType, Serializable resolvedId) {
 		final boolean idIsResultId = optionalId != null
 				&& resolvedId != null
 				&& idType.isEqual( optionalId, resolvedId, session.getEntityMode(), factory );
 		final Serializable resultId = idIsResultId ? optionalId : resolvedId;
 		return resultId;
 	}
 
 	protected void applyPostLoadLocks(Object[] row, LockMode[] lockModesArray, SessionImplementor session) {
 	}
 
 	/**
 	 * Read any collection elements contained in a single row of the result set
 	 */
 	private void readCollectionElements(Object[] row, ResultSet resultSet, SessionImplementor session)
 			throws SQLException, HibernateException {
 
 		//TODO: make this handle multiple collection roles!
 
 		final CollectionPersister[] collectionPersisters = getCollectionPersisters();
 		if ( collectionPersisters != null ) {
 
 			final CollectionAliases[] descriptors = getCollectionAliases();
 			final int[] collectionOwners = getCollectionOwners();
 
 			for ( int i=0; i<collectionPersisters.length; i++ ) {
 
 				final boolean hasCollectionOwners = collectionOwners !=null &&
 						collectionOwners[i] > -1;
 				//true if this is a query and we are loading multiple instances of the same collection role
 				//otherwise this is a CollectionInitializer and we are loading up a single collection or batch
 
 				final Object owner = hasCollectionOwners ?
 						row[ collectionOwners[i] ] :
 						null; //if null, owner will be retrieved from session
 
 				final CollectionPersister collectionPersister = collectionPersisters[i];
 				final Serializable key;
 				if ( owner == null ) {
 					key = null;
 				}
 				else {
 					key = collectionPersister.getCollectionType().getKeyOfOwner( owner, session );
 					//TODO: old version did not require hashmap lookup:
 					//keys[collectionOwner].getIdentifier()
 				}
 
 				readCollectionElement(
 						owner,
 						key,
 						collectionPersister,
 						descriptors[i],
 						resultSet,
 						session
 					);
 
 			}
 
 		}
 	}
 
 	private List doQuery(
 			final SessionImplementor session,
 			final QueryParameters queryParameters,
 			final boolean returnProxies,
 			final ResultTransformer forcedResultTransformer) throws SQLException, HibernateException {
 
 		final RowSelection selection = queryParameters.getRowSelection();
 		final int maxRows = hasMaxRows( selection ) ?
 				selection.getMaxRows().intValue() :
 				Integer.MAX_VALUE;
 
 		final int entitySpan = getEntityPersisters().length;
 
 		final ArrayList hydratedObjects = entitySpan == 0 ? null : new ArrayList( entitySpan * 10 );
 		final PreparedStatement st = prepareQueryStatement( queryParameters, false, session );
 		final ResultSet rs = getResultSet( st, queryParameters.hasAutoDiscoverScalarTypes(), queryParameters.isCallable(), selection, session );
 
 // would be great to move all this below here into another method that could also be used
 // from the new scrolling stuff.
 //
 // Would need to change the way the max-row stuff is handled (i.e. behind an interface) so
 // that I could do the control breaking at the means to know when to stop
 
 		final EntityKey optionalObjectKey = getOptionalObjectKey( queryParameters, session );
 		final LockMode[] lockModesArray = getLockModes( queryParameters.getLockOptions() );
 		final boolean createSubselects = isSubselectLoadingEnabled();
 		final List subselectResultKeys = createSubselects ? new ArrayList() : null;
 		final List results = new ArrayList();
 
 		try {
 
 			handleEmptyCollections( queryParameters.getCollectionKeys(), rs, session );
 
 			EntityKey[] keys = new EntityKey[entitySpan]; //we can reuse it for each row
 
             LOG.trace("Processing result set");
 
 			int count;
 			for ( count = 0; count < maxRows && rs.next(); count++ ) {
 
                 LOG.debugf("Result set row: %s", count);
 
 				Object result = getRowFromResultSet(
 						rs,
 						session,
 						queryParameters,
 						lockModesArray,
 						optionalObjectKey,
 						hydratedObjects,
 						keys,
 						returnProxies,
 						forcedResultTransformer
 				);
 				results.add( result );
 
 				if ( createSubselects ) {
 					subselectResultKeys.add(keys);
 					keys = new EntityKey[entitySpan]; //can't reuse in this case
 				}
 
 			}
 
             LOG.trace("Done processing result set (" + count + " rows)");
 
 		}
 		finally {
 			st.close();
 		}
 
 		initializeEntitiesAndCollections( hydratedObjects, rs, session, queryParameters.isReadOnly( session ) );
 
 		if ( createSubselects ) createSubselects( subselectResultKeys, queryParameters, session );
 
 		return results; //getResultList(results);
 
 	}
 
 	protected boolean isSubselectLoadingEnabled() {
 		return false;
 	}
 
 	protected boolean hasSubselectLoadableCollections() {
 		final Loadable[] loadables = getEntityPersisters();
 		for (int i=0; i<loadables.length; i++ ) {
 			if ( loadables[i].hasSubselectLoadableCollections() ) return true;
 		}
 		return false;
 	}
 
 	private static Set[] transpose( List keys ) {
 		Set[] result = new Set[ ( ( EntityKey[] ) keys.get(0) ).length ];
 		for ( int j=0; j<result.length; j++ ) {
 			result[j] = new HashSet( keys.size() );
 			for ( int i=0; i<keys.size(); i++ ) {
 				result[j].add( ( ( EntityKey[] ) keys.get(i) ) [j] );
 			}
 		}
 		return result;
 	}
 
 	private void createSubselects(List keys, QueryParameters queryParameters, SessionImplementor session) {
 		if ( keys.size() > 1 ) { //if we only returned one entity, query by key is more efficient
 
 			Set[] keySets = transpose(keys);
 
 			Map namedParameterLocMap = buildNamedParameterLocMap( queryParameters );
 
 			final Loadable[] loadables = getEntityPersisters();
 			final String[] aliases = getAliases();
 			final Iterator iter = keys.iterator();
 			while ( iter.hasNext() ) {
 
 				final EntityKey[] rowKeys = (EntityKey[]) iter.next();
 				for ( int i=0; i<rowKeys.length; i++ ) {
 
 					if ( rowKeys[i]!=null && loadables[i].hasSubselectLoadableCollections() ) {
 
 						SubselectFetch subselectFetch = new SubselectFetch(
 								//getSQLString(),
 								aliases[i],
 								loadables[i],
 								queryParameters,
 								keySets[i],
 								namedParameterLocMap
 							);
 
 						session.getPersistenceContext()
 								.getBatchFetchQueue()
 								.addSubselect( rowKeys[i], subselectFetch );
 					}
 
 				}
 
 			}
 		}
 	}
 
 	private Map buildNamedParameterLocMap(QueryParameters queryParameters) {
 		if ( queryParameters.getNamedParameters()!=null ) {
 			final Map namedParameterLocMap = new HashMap();
 			Iterator piter = queryParameters.getNamedParameters().keySet().iterator();
 			while ( piter.hasNext() ) {
 				String name = (String) piter.next();
 				namedParameterLocMap.put(
 						name,
 						getNamedParameterLocs(name)
 					);
 			}
 			return namedParameterLocMap;
 		}
 		else {
 			return null;
 		}
 	}
 
 	private void initializeEntitiesAndCollections(
 			final List hydratedObjects,
 			final Object resultSetId,
 			final SessionImplementor session,
 			final boolean readOnly)
 	throws HibernateException {
 
 		final CollectionPersister[] collectionPersisters = getCollectionPersisters();
 		if ( collectionPersisters != null ) {
 			for ( int i=0; i<collectionPersisters.length; i++ ) {
 				if ( collectionPersisters[i].isArray() ) {
 					//for arrays, we should end the collection load before resolving
 					//the entities, since the actual array instances are not instantiated
 					//during loading
 					//TODO: or we could do this polymorphically, and have two
 					//      different operations implemented differently for arrays
 					endCollectionLoad( resultSetId, session, collectionPersisters[i] );
 				}
 			}
 		}
 
 		//important: reuse the same event instances for performance!
 		final PreLoadEvent pre;
 		final PostLoadEvent post;
 		if ( session.isEventSource() ) {
 			pre = new PreLoadEvent( (EventSource) session );
 			post = new PostLoadEvent( (EventSource) session );
 		}
 		else {
 			pre = null;
 			post = null;
 		}
 
 		if ( hydratedObjects!=null ) {
 			int hydratedObjectsSize = hydratedObjects.size();
             LOG.trace("Total objects hydrated: " + hydratedObjectsSize);
 			for ( int i = 0; i < hydratedObjectsSize; i++ ) {
 				TwoPhaseLoad.initializeEntity( hydratedObjects.get(i), readOnly, session, pre, post );
 			}
 		}
 
 		if ( collectionPersisters != null ) {
 			for ( int i=0; i<collectionPersisters.length; i++ ) {
 				if ( !collectionPersisters[i].isArray() ) {
 					//for sets, we should end the collection load after resolving
 					//the entities, since we might call hashCode() on the elements
 					//TODO: or we could do this polymorphically, and have two
 					//      different operations implemented differently for arrays
 					endCollectionLoad( resultSetId, session, collectionPersisters[i] );
 				}
 			}
 		}
 
 	}
 
 	private void endCollectionLoad(
 			final Object resultSetId,
 			final SessionImplementor session,
 			final CollectionPersister collectionPersister) {
 		//this is a query and we are loading multiple instances of the same collection role
 		session.getPersistenceContext()
 				.getLoadContexts()
 				.getCollectionLoadContext( ( ResultSet ) resultSetId )
 				.endLoadingCollections( collectionPersister );
 	}
 
 	/**
 	 * Determine the actual ResultTransformer that will be used to
 	 * transform query results.
 	 *
 	 * @param resultTransformer the specified result transformer
 	 * @return the actual result transformer
 	 */
 	protected ResultTransformer resolveResultTransformer(ResultTransformer resultTransformer) {
 		return resultTransformer;
 	}
 
 	protected List getResultList(List results, ResultTransformer resultTransformer) throws QueryException {
 		return results;
 	}
 
 	/**
 	 * Are rows transformed immediately after being read from the ResultSet?
 	 * @return true, if getResultColumnOrRow() transforms the results; false, otherwise
 	 */
 	protected boolean areResultSetRowsTransformedImmediately() {
 		return false;
 	}
 
 	/**
 	 * Returns the aliases that corresponding to a result row.
 	 * @return Returns the aliases that corresponding to a result row.
 	 */
 	protected String[] getResultRowAliases() {
 		 return null;
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/criteria/CriteriaQueryTranslator.java b/hibernate-core/src/main/java/org/hibernate/loader/criteria/CriteriaQueryTranslator.java
index 92296d1899..b4bf2a0f5b 100755
--- a/hibernate-core/src/main/java/org/hibernate/loader/criteria/CriteriaQueryTranslator.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/criteria/CriteriaQueryTranslator.java
@@ -1,685 +1,685 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.loader.criteria;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.StringTokenizer;
 import org.hibernate.Criteria;
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.criterion.CriteriaQuery;
 import org.hibernate.criterion.Criterion;
 import org.hibernate.criterion.EnhancedProjection;
 import org.hibernate.criterion.Projection;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.TypedValue;
-import org.hibernate.hql.ast.util.SessionFactoryHelper;
+import org.hibernate.hql.internal.ast.util.SessionFactoryHelper;
 import org.hibernate.internal.CriteriaImpl;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.PropertyMapping;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.StringRepresentableType;
 import org.hibernate.type.Type;
 import org.hibernate.internal.util.StringHelper;
 
 /**
  * @author Gavin King
  */
 public class CriteriaQueryTranslator implements CriteriaQuery {
 
 	public static final String ROOT_SQL_ALIAS = Criteria.ROOT_ALIAS + '_';
 
 	private CriteriaQuery outerQueryTranslator;
 
 	private final CriteriaImpl rootCriteria;
 	private final String rootEntityName;
 	private final String rootSQLAlias;
 	private int aliasCount = 0;
 
 	private final Map /* <Criteria, CriteriaInfoProvider> */ criteriaInfoMap = new LinkedHashMap();
 	private final Map /* <String, CriteriaInfoProvider> */ nameCriteriaInfoMap = new LinkedHashMap();
 	private final Map criteriaSQLAliasMap = new HashMap();
 	private final Map aliasCriteriaMap = new HashMap();
 	private final Map associationPathCriteriaMap = new LinkedHashMap();
 	private final Map associationPathJoinTypesMap = new LinkedHashMap();
 	private final Map withClauseMap = new HashMap();
 	
 	private final SessionFactoryImplementor sessionFactory;
 	private final SessionFactoryHelper helper;
 
 	public CriteriaQueryTranslator(
 			final SessionFactoryImplementor factory,
 	        final CriteriaImpl criteria,
 	        final String rootEntityName,
 	        final String rootSQLAlias,
 	        CriteriaQuery outerQuery) throws HibernateException {
 		this( factory, criteria, rootEntityName, rootSQLAlias );
 		outerQueryTranslator = outerQuery;
 	}
 
 	public CriteriaQueryTranslator(
 			final SessionFactoryImplementor factory,
 	        final CriteriaImpl criteria,
 	        final String rootEntityName,
 	        final String rootSQLAlias) throws HibernateException {
 		this.rootCriteria = criteria;
 		this.rootEntityName = rootEntityName;
 		this.sessionFactory = factory;
 		this.rootSQLAlias = rootSQLAlias;
 		this.helper = new SessionFactoryHelper(factory);
 		createAliasCriteriaMap();
 		createAssociationPathCriteriaMap();
 		createCriteriaEntityNameMap();
 		createCriteriaSQLAliasMap();
 	}
 
 	public String generateSQLAlias() {
 		return StringHelper.generateAlias( Criteria.ROOT_ALIAS, aliasCount ) + '_';
 	}
 
 	public String getRootSQLALias() {
 		return rootSQLAlias;
 	}
 
 	private Criteria getAliasedCriteria(String alias) {
 		return ( Criteria ) aliasCriteriaMap.get( alias );
 	}
 
 	public boolean isJoin(String path) {
 		return associationPathCriteriaMap.containsKey( path );
 	}
 
 	public int getJoinType(String path) {
 		Integer result = ( Integer ) associationPathJoinTypesMap.get( path );
 		return ( result == null ? Criteria.INNER_JOIN : result.intValue() );
 	}
 
 	public Criteria getCriteria(String path) {
 		return ( Criteria ) associationPathCriteriaMap.get( path );
 	}
 
 	public Set getQuerySpaces() {
 		Set result = new HashSet();
 		Iterator iter = criteriaInfoMap.values().iterator();
 		while ( iter.hasNext() ) {
 			CriteriaInfoProvider info = ( CriteriaInfoProvider )iter.next();
 			result.addAll( Arrays.asList( info.getSpaces() ) );
 		}
 		return result;
 	}
 
 	private void createAliasCriteriaMap() {
 		aliasCriteriaMap.put( rootCriteria.getAlias(), rootCriteria );
 		Iterator iter = rootCriteria.iterateSubcriteria();
 		while ( iter.hasNext() ) {
 			Criteria subcriteria = ( Criteria ) iter.next();
 			if ( subcriteria.getAlias() != null ) {
 				Object old = aliasCriteriaMap.put( subcriteria.getAlias(), subcriteria );
 				if ( old != null ) {
 					throw new QueryException( "duplicate alias: " + subcriteria.getAlias() );
 				}
 			}
 		}
 	}
 
 	private void createAssociationPathCriteriaMap() {
 		Iterator iter = rootCriteria.iterateSubcriteria();
 		while ( iter.hasNext() ) {
 			CriteriaImpl.Subcriteria crit = ( CriteriaImpl.Subcriteria ) iter.next();
 			String wholeAssociationPath = getWholeAssociationPath( crit );
 			Object old = associationPathCriteriaMap.put( wholeAssociationPath, crit );
 			if ( old != null ) {
 				throw new QueryException( "duplicate association path: " + wholeAssociationPath );
 			}
 			int joinType = crit.getJoinType();
 			old = associationPathJoinTypesMap.put( wholeAssociationPath, new Integer( joinType ) );
 			if ( old != null ) {
 				// TODO : not so sure this is needed...
 				throw new QueryException( "duplicate association path: " + wholeAssociationPath );
 			}
 			if ( crit.getWithClause() != null )
 			{
 				this.withClauseMap.put(wholeAssociationPath, crit.getWithClause());
 			}
 		}
 	}
 
 	private String getWholeAssociationPath(CriteriaImpl.Subcriteria subcriteria) {
 		String path = subcriteria.getPath();
 
 		// some messy, complex stuff here, since createCriteria() can take an
 		// aliased path, or a path rooted at the creating criteria instance
 		Criteria parent = null;
 		if ( path.indexOf( '.' ) > 0 ) {
 			// if it is a compound path
 			String testAlias = StringHelper.root( path );
 			if ( !testAlias.equals( subcriteria.getAlias() ) ) {
 				// and the qualifier is not the alias of this criteria
 				//      -> check to see if we belong to some criteria other
 				//          than the one that created us
 				parent = ( Criteria ) aliasCriteriaMap.get( testAlias );
 			}
 		}
 		if ( parent == null ) {
 			// otherwise assume the parent is the the criteria that created us
 			parent = subcriteria.getParent();
 		}
 		else {
 			path = StringHelper.unroot( path );
 		}
 
 		if ( parent.equals( rootCriteria ) ) {
 			// if its the root criteria, we are done
 			return path;
 		}
 		else {
 			// otherwise, recurse
 			return getWholeAssociationPath( ( CriteriaImpl.Subcriteria ) parent ) + '.' + path;
 		}
 	}
 
 	private void createCriteriaEntityNameMap() {
 		// initialize the rootProvider first
 		CriteriaInfoProvider rootProvider = new EntityCriteriaInfoProvider(( Queryable ) sessionFactory.getEntityPersister( rootEntityName ) );
 		criteriaInfoMap.put( rootCriteria, rootProvider);
 		nameCriteriaInfoMap.put ( rootProvider.getName(), rootProvider );
 
 		Iterator iter = associationPathCriteriaMap.entrySet().iterator();
 		while ( iter.hasNext() ) {
 			Map.Entry me = ( Map.Entry ) iter.next();
 			CriteriaInfoProvider info = getPathInfo((String)me.getKey());
 
 			criteriaInfoMap.put(
 					me.getValue(), //the criteria instance
 					info
 			);
 
 			nameCriteriaInfoMap.put( info.getName(), info );
 		}
 	}
 
 
 	private CriteriaInfoProvider getPathInfo(String path) {
 		StringTokenizer tokens = new StringTokenizer( path, "." );
 		String componentPath = "";
 
 		// start with the 'rootProvider'
 		CriteriaInfoProvider provider = ( CriteriaInfoProvider )nameCriteriaInfoMap.get( rootEntityName );
 
 		while ( tokens.hasMoreTokens() ) {
 			componentPath += tokens.nextToken();
 			Type type = provider.getType( componentPath );
 			if ( type.isAssociationType() ) {
 				// CollectionTypes are always also AssociationTypes - but there's not always an associated entity...
 				AssociationType atype = ( AssociationType ) type;
 				CollectionType ctype = type.isCollectionType() ? (CollectionType)type : null;
 				Type elementType = (ctype != null) ? ctype.getElementType( sessionFactory ) : null;
 				// is the association a collection of components or value-types? (i.e a colloction of valued types?)
 				if ( ctype != null  && elementType.isComponentType() ) {
 					provider = new ComponentCollectionCriteriaInfoProvider( helper.getCollectionPersister(ctype.getRole()) );
 				}
 				else if ( ctype != null && !elementType.isEntityType() ) {
 					provider = new ScalarCollectionCriteriaInfoProvider( helper, ctype.getRole() );
 				}
 				else {
 					provider = new EntityCriteriaInfoProvider(( Queryable ) sessionFactory.getEntityPersister(
 											  atype.getAssociatedEntityName( sessionFactory )
 											  ));
 				}
 				
 				componentPath = "";
 			}
 			else if ( type.isComponentType() ) {
 				if (!tokens.hasMoreTokens()) {
 					throw new QueryException("Criteria objects cannot be created directly on components.  Create a criteria on owning entity and use a dotted property to access component property: "+path);
 				} else {
 					componentPath += '.';
 				}
 			}
 			else {
 				throw new QueryException( "not an association: " + componentPath );
 			}
 		}
 		
 		return provider;
 	}
 
 	public int getSQLAliasCount() {
 		return criteriaSQLAliasMap.size();
 	}
 
 	private void createCriteriaSQLAliasMap() {
 		int i = 0;
 		Iterator criteriaIterator = criteriaInfoMap.entrySet().iterator();
 		while ( criteriaIterator.hasNext() ) {
 			Map.Entry me = ( Map.Entry ) criteriaIterator.next();
 			Criteria crit = ( Criteria ) me.getKey();
 			String alias = crit.getAlias();
 			if ( alias == null ) {
 				alias = (( CriteriaInfoProvider ) me.getValue()).getName(); // the entity name
 			}
 			criteriaSQLAliasMap.put( crit, StringHelper.generateAlias( alias, i++ ) );
 		}
 		criteriaSQLAliasMap.put( rootCriteria, rootSQLAlias );
 	}
 
 	public CriteriaImpl getRootCriteria() {
 		return rootCriteria;
 	}
 
 	public QueryParameters getQueryParameters() {
 		LockOptions lockOptions = new LockOptions();
 		RowSelection selection = new RowSelection();
 		selection.setFirstRow( rootCriteria.getFirstResult() );
 		selection.setMaxRows( rootCriteria.getMaxResults() );
 		selection.setTimeout( rootCriteria.getTimeout() );
 		selection.setFetchSize( rootCriteria.getFetchSize() );
 
 		Iterator iter = rootCriteria.getLockModes().entrySet().iterator();
 		while ( iter.hasNext() ) {
 			Map.Entry me = ( Map.Entry ) iter.next();
 			final Criteria subcriteria = getAliasedCriteria( ( String ) me.getKey() );
 			lockOptions.setAliasSpecificLockMode( getSQLAlias( subcriteria ), (LockMode)me.getValue() );
 		}
 		List values = new ArrayList();
 		List types = new ArrayList();
 		iter = rootCriteria.iterateSubcriteria();
 		while ( iter.hasNext() ) {
 			CriteriaImpl.Subcriteria subcriteria = ( CriteriaImpl.Subcriteria ) iter.next();
 			LockMode lm = subcriteria.getLockMode();
 			if ( lm != null ) {
 				lockOptions.setAliasSpecificLockMode( getSQLAlias( subcriteria ), lm );
 			}
 			if ( subcriteria.getWithClause() != null )
 			{
 				TypedValue[] tv = subcriteria.getWithClause().getTypedValues( subcriteria, this );
 				for ( int i = 0; i < tv.length; i++ ) {
 					values.add( tv[i].getValue() );
 					types.add( tv[i].getType() );
 				}
 			}
 		}
 
 		// Type and value gathering for the WHERE clause needs to come AFTER lock mode gathering,
 		// because the lock mode gathering loop now contains join clauses which can contain
 		// parameter bindings (as in the HQL WITH clause).
 		iter = rootCriteria.iterateExpressionEntries();
 		while ( iter.hasNext() ) {
 			CriteriaImpl.CriterionEntry ce = ( CriteriaImpl.CriterionEntry ) iter.next();
 			TypedValue[] tv = ce.getCriterion().getTypedValues( ce.getCriteria(), this );
 			for ( int i = 0; i < tv.length; i++ ) {
 				values.add( tv[i].getValue() );
 				types.add( tv[i].getType() );
 			}
 		}
 
 		Object[] valueArray = values.toArray();
 		Type[] typeArray = ArrayHelper.toTypeArray( types );
 		return new QueryParameters(
 				typeArray,
 		        valueArray,
 		        lockOptions,
 		        selection,
 		        rootCriteria.isReadOnlyInitialized(),
 		        ( rootCriteria.isReadOnlyInitialized() ? rootCriteria.isReadOnly() : false ),
 		        rootCriteria.getCacheable(),
 		        rootCriteria.getCacheRegion(),
 		        rootCriteria.getComment(),
 		        rootCriteria.isLookupByNaturalKey(),
 		        rootCriteria.getResultTransformer()
 		);
 	}
 
 	public boolean hasProjection() {
 		return rootCriteria.getProjection() != null;
 	}
 
 	public String getGroupBy() {
 		if ( rootCriteria.getProjection().isGrouped() ) {
 			return rootCriteria.getProjection()
 					.toGroupSqlString( rootCriteria.getProjectionCriteria(), this );
 		}
 		else {
 			return "";
 		}
 	}
 
 	public String getSelect() {
 		return rootCriteria.getProjection().toSqlString(
 				rootCriteria.getProjectionCriteria(),
 		        0,
 		        this
 		);
 	}
 
 	/* package-protected */
 	Type getResultType(Criteria criteria) {
 		return getFactory().getTypeResolver().getTypeFactory().manyToOne( getEntityName( criteria ) );
 	}
 
 	public Type[] getProjectedTypes() {
 		return rootCriteria.getProjection().getTypes( rootCriteria, this );
 	}
 
 	public String[] getProjectedColumnAliases() {
 		return rootCriteria.getProjection() instanceof EnhancedProjection ?
 				( ( EnhancedProjection ) rootCriteria.getProjection() ).getColumnAliases( 0, rootCriteria, this ) :
 				rootCriteria.getProjection().getColumnAliases( 0 );
 	}
 
 	public String[] getProjectedAliases() {
 		return rootCriteria.getProjection().getAliases();
 	}
 
 	public String getWhereCondition() {
 		StringBuffer condition = new StringBuffer( 30 );
 		Iterator criterionIterator = rootCriteria.iterateExpressionEntries();
 		while ( criterionIterator.hasNext() ) {
 			CriteriaImpl.CriterionEntry entry = ( CriteriaImpl.CriterionEntry ) criterionIterator.next();
 			String sqlString = entry.getCriterion().toSqlString( entry.getCriteria(), this );
 			condition.append( sqlString );
 			if ( criterionIterator.hasNext() ) {
 				condition.append( " and " );
 			}
 		}
 		return condition.toString();
 	}
 
 	public String getOrderBy() {
 		StringBuffer orderBy = new StringBuffer( 30 );
 		Iterator criterionIterator = rootCriteria.iterateOrderings();
 		while ( criterionIterator.hasNext() ) {
 			CriteriaImpl.OrderEntry oe = ( CriteriaImpl.OrderEntry ) criterionIterator.next();
 			orderBy.append( oe.getOrder().toSqlString( oe.getCriteria(), this ) );
 			if ( criterionIterator.hasNext() ) {
 				orderBy.append( ", " );
 			}
 		}
 		return orderBy.toString();
 	}
 
 	public SessionFactoryImplementor getFactory() {
 		return sessionFactory;
 	}
 
 	public String getSQLAlias(Criteria criteria) {
 		return ( String ) criteriaSQLAliasMap.get( criteria );
 	}
 
 	public String getEntityName(Criteria criteria) {
 		return (( CriteriaInfoProvider ) criteriaInfoMap.get( criteria )).getName();
 	}
 
 	public String getColumn(Criteria criteria, String propertyName) {
 		String[] cols = getColumns( propertyName, criteria );
 		if ( cols.length != 1 ) {
 			throw new QueryException( "property does not map to a single column: " + propertyName );
 		}
 		return cols[0];
 	}
 
 	/**
 	 * Get the names of the columns constrained
 	 * by this criterion.
 	 */
 	public String[] getColumnsUsingProjection(
 			Criteria subcriteria,
 	        String propertyName) throws HibernateException {
 
 		//first look for a reference to a projection alias
 		final Projection projection = rootCriteria.getProjection();
 		String[] projectionColumns = null;
 		if ( projection != null ) {
 			projectionColumns = ( projection instanceof EnhancedProjection ?
 					( ( EnhancedProjection ) projection ).getColumnAliases( propertyName, 0, rootCriteria, this ) :
 					projection.getColumnAliases( propertyName, 0 )
 			);
 		}
 		if ( projectionColumns == null ) {
 			//it does not refer to an alias of a projection,
 			//look for a property
 			try {
 				return getColumns( propertyName, subcriteria );
 			}
 			catch ( HibernateException he ) {
 				//not found in inner query , try the outer query
 				if ( outerQueryTranslator != null ) {
 					return outerQueryTranslator.getColumnsUsingProjection( subcriteria, propertyName );
 				}
 				else {
 					throw he;
 				}
 			}
 		}
 		else {
 			//it refers to an alias of a projection
 			return projectionColumns;
 		}
 	}
 
 	public String[] getIdentifierColumns(Criteria subcriteria) {
 		String[] idcols =
 				( ( Loadable ) getPropertyMapping( getEntityName( subcriteria ) ) ).getIdentifierColumnNames();
 		return StringHelper.qualify( getSQLAlias( subcriteria ), idcols );
 	}
 
 	public Type getIdentifierType(Criteria subcriteria) {
 		return ( ( Loadable ) getPropertyMapping( getEntityName( subcriteria ) ) ).getIdentifierType();
 	}
 
 	public TypedValue getTypedIdentifierValue(Criteria subcriteria, Object value) {
 		final Loadable loadable = ( Loadable ) getPropertyMapping( getEntityName( subcriteria ) );
 		return new TypedValue(
 				loadable.getIdentifierType(),
 		        value,
 		        EntityMode.POJO
 		);
 	}
 
 	public String[] getColumns(
 			String propertyName,
 	        Criteria subcriteria) throws HibernateException {
 		return getPropertyMapping( getEntityName( subcriteria, propertyName ) )
 				.toColumns(
 						getSQLAlias( subcriteria, propertyName ),
 				        getPropertyName( propertyName )
 				);
 	}
 
 	/**
 	 * Get the names of the columns mapped by a property path; if the
 	 * property path is not found in subcriteria, try the "outer" query.
 	 * Projection aliases are ignored.
 	 */
 	public String[] findColumns(String propertyName, Criteria subcriteria )
 	throws HibernateException {
 		try {
 			return getColumns( propertyName, subcriteria );
 		}
 		catch ( HibernateException he ) {
 			//not found in inner query, try the outer query
 			if ( outerQueryTranslator != null ) {
 				return outerQueryTranslator.findColumns( propertyName, subcriteria );
 			}
 			else {
 				throw he;
 			}
 		}
 	}
 
 	public Type getTypeUsingProjection(Criteria subcriteria, String propertyName)
 			throws HibernateException {
 
 		//first look for a reference to a projection alias
 		final Projection projection = rootCriteria.getProjection();
 		Type[] projectionTypes = projection == null ?
 		                         null :
 		                         projection.getTypes( propertyName, subcriteria, this );
 
 		if ( projectionTypes == null ) {
 			try {
 				//it does not refer to an alias of a projection,
 				//look for a property
 				return getType( subcriteria, propertyName );
 			}
 			catch ( HibernateException he ) {
 				//not found in inner query , try the outer query
 				if ( outerQueryTranslator != null ) {
 					return outerQueryTranslator.getType( subcriteria, propertyName );
 				}
 				else {
 					throw he;
 				}
 			}
 		}
 		else {
 			if ( projectionTypes.length != 1 ) {
 				//should never happen, i think
 				throw new QueryException( "not a single-length projection: " + propertyName );
 			}
 			return projectionTypes[0];
 		}
 	}
 
 	public Type getType(Criteria subcriteria, String propertyName)
 			throws HibernateException {
 		return getPropertyMapping( getEntityName( subcriteria, propertyName ) )
 				.toType( getPropertyName( propertyName ) );
 	}
 
 	/**
 	 * Get the a typed value for the given property value.
 	 */
 	public TypedValue getTypedValue(Criteria subcriteria, String propertyName, Object value)
 			throws HibernateException {
 		// Detect discriminator values...
 		if ( value instanceof Class ) {
 			Class entityClass = ( Class ) value;
 			Queryable q = SessionFactoryHelper.findQueryableUsingImports( sessionFactory, entityClass.getName() );
 			if ( q != null ) {
 				Type type = q.getDiscriminatorType();
 				String stringValue = q.getDiscriminatorSQLValue();
 				if (stringValue != null && stringValue.length() > 2
 						&& stringValue.startsWith("'")
 						&& stringValue.endsWith("'")) { // remove the single
 														// quotes
 					stringValue = stringValue.substring(1,
 							stringValue.length() - 1);
 				}
 				
 				// Convert the string value into the proper type.
 				if ( type instanceof StringRepresentableType ) {
 					StringRepresentableType nullableType = (StringRepresentableType) type;
 					value = nullableType.fromStringValue( stringValue );
 				}
 				else {
 					throw new QueryException( "Unsupported discriminator type " + type );
 				}
 				return new TypedValue(
 						type,
 				        value,
 				        EntityMode.POJO
 				);
 			}
 		}
 		// Otherwise, this is an ordinary value.
 		return new TypedValue(
 				getTypeUsingProjection( subcriteria, propertyName ),
 		        value,
 		        EntityMode.POJO
 		);
 	}
 
 	private PropertyMapping getPropertyMapping(String entityName)
 			throws MappingException {
 		CriteriaInfoProvider info = ( CriteriaInfoProvider )nameCriteriaInfoMap.get(entityName);
 		return info.getPropertyMapping();
 	}
 
 	//TODO: use these in methods above
 
 	public String getEntityName(Criteria subcriteria, String propertyName) {
 		if ( propertyName.indexOf( '.' ) > 0 ) {
 			String root = StringHelper.root( propertyName );
 			Criteria crit = getAliasedCriteria( root );
 			if ( crit != null ) {
 				return getEntityName( crit );
 			}
 		}
 		return getEntityName( subcriteria );
 	}
 
 	public String getSQLAlias(Criteria criteria, String propertyName) {
 		if ( propertyName.indexOf( '.' ) > 0 ) {
 			String root = StringHelper.root( propertyName );
 			Criteria subcriteria = getAliasedCriteria( root );
 			if ( subcriteria != null ) {
 				return getSQLAlias( subcriteria );
 			}
 		}
 		return getSQLAlias( criteria );
 	}
 
 	public String getPropertyName(String propertyName) {
 		if ( propertyName.indexOf( '.' ) > 0 ) {
 			String root = StringHelper.root( propertyName );
 			Criteria crit = getAliasedCriteria( root );
 			if ( crit != null ) {
 				return propertyName.substring( root.length() + 1 );
 			}
 		}
 		return propertyName;
 	}
 
 	public String getWithClause(String path)
 	{
 		final Criterion crit = (Criterion)this.withClauseMap.get(path);
 		return crit == null ? null : crit.toSqlString(getCriteria(path), this);
 	}
 
 	public boolean hasRestriction(String path)
 	{
 		final CriteriaImpl.Subcriteria crit = ( CriteriaImpl.Subcriteria ) getCriteria( path );
 		return crit == null ? false : crit.hasRestriction();
 	}
 
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/criteria/ScalarCollectionCriteriaInfoProvider.java b/hibernate-core/src/main/java/org/hibernate/loader/criteria/ScalarCollectionCriteriaInfoProvider.java
index ca1c88a327..b132312b17 100644
--- a/hibernate-core/src/main/java/org/hibernate/loader/criteria/ScalarCollectionCriteriaInfoProvider.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/criteria/ScalarCollectionCriteriaInfoProvider.java
@@ -1,68 +1,67 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.loader.criteria;
 
 import java.io.Serializable;
 
-import org.hibernate.hql.ast.util.SessionFactoryHelper;
+import org.hibernate.hql.internal.ast.util.SessionFactoryHelper;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.PropertyMapping;
-import org.hibernate.type.ComponentType;
 import org.hibernate.type.Type;
 
 /**
  * @author David Mansfield
  */
 
 class ScalarCollectionCriteriaInfoProvider implements CriteriaInfoProvider {
     String role;
     QueryableCollection persister;
     SessionFactoryHelper helper;
 
     ScalarCollectionCriteriaInfoProvider(SessionFactoryHelper helper, String role) {
 	this.role = role;
 	this.helper = helper;
 	this.persister = helper.requireQueryableCollection(role);
     }
 
     public String getName() {
 	return role;
     }
 
     public Serializable[] getSpaces() {
 	return persister.getCollectionSpaces();
     }
 
     public PropertyMapping getPropertyMapping() {
 	return helper.getCollectionPropertyMapping(role);
     }
 
     public Type getType(String relativePath) {
 	//not sure what things are going to be passed here, how about 'id', maybe 'index' or 'key' or 'elements' ???
 	// todo: wtf!
 	return getPropertyMapping().toType(relativePath);
     }
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/custom/CustomLoader.java b/hibernate-core/src/main/java/org/hibernate/loader/custom/CustomLoader.java
index 9ea03bd8a5..6331c1a154 100755
--- a/hibernate-core/src/main/java/org/hibernate/loader/custom/CustomLoader.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/custom/CustomLoader.java
@@ -1,645 +1,645 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.loader.custom;
 
 import java.sql.ResultSet;
 import java.sql.ResultSetMetaData;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.hql.HolderInstantiator;
+import org.hibernate.hql.internal.HolderInstantiator;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.loader.CollectionAliases;
 import org.hibernate.loader.EntityAliases;
 import org.hibernate.loader.Loader;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 
 /**
  * Extension point for loaders which use a SQL result set with "unexpected" column aliases.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class CustomLoader extends Loader {
 
 	// Currently *not* cachable if autodiscover types is in effect (e.g. "select * ...")
 
 	private final String sql;
 	private final Set querySpaces = new HashSet();
 	private final Map namedParameterBindPoints;
 
 	private final Queryable[] entityPersisters;
 	private final int[] entiytOwners;
 	private final EntityAliases[] entityAliases;
 
 	private final QueryableCollection[] collectionPersisters;
 	private final int[] collectionOwners;
 	private final CollectionAliases[] collectionAliases;
 
 	private final LockMode[] lockModes;
 
 	private boolean[] includeInResultRow;
 
 //	private final String[] sqlAliases;
 //	private final String[] sqlAliasSuffixes;
 	private final ResultRowProcessor rowProcessor;
 
 	// this is only needed (afaict) for processing results from the query cache;
 	// however, this cannot possibly work in the case of discovered types...
 	private Type[] resultTypes;
 
 	// this is only needed (afaict) for ResultTransformer processing...
 	private String[] transformerAliases;
 
 	public CustomLoader(CustomQuery customQuery, SessionFactoryImplementor factory) {
 		super( factory );
 
 		this.sql = customQuery.getSQL();
 		this.querySpaces.addAll( customQuery.getQuerySpaces() );
 		this.namedParameterBindPoints = customQuery.getNamedParameterBindPoints();
 
 		List entityPersisters = new ArrayList();
 		List entityOwners = new ArrayList();
 		List entityAliases = new ArrayList();
 
 		List collectionPersisters = new ArrayList();
 		List collectionOwners = new ArrayList();
 		List collectionAliases = new ArrayList();
 
 		List lockModes = new ArrayList();
 		List resultColumnProcessors = new ArrayList();
 		List nonScalarReturnList = new ArrayList();
 		List resultTypes = new ArrayList();
 		List specifiedAliases = new ArrayList();
 		int returnableCounter = 0;
 		boolean hasScalars = false;
 
 		List includeInResultRowList = new ArrayList();
 
 		Iterator itr = customQuery.getCustomQueryReturns().iterator();
 		while ( itr.hasNext() ) {
 			final Return rtn = ( Return ) itr.next();
 			if ( rtn instanceof ScalarReturn ) {
 				ScalarReturn scalarRtn = ( ScalarReturn ) rtn;
 				resultTypes.add( scalarRtn.getType() );
 				specifiedAliases.add( scalarRtn.getColumnAlias() );
 				resultColumnProcessors.add(
 						new ScalarResultColumnProcessor(
 								StringHelper.unquote( scalarRtn.getColumnAlias(), factory.getDialect() ),
 								scalarRtn.getType()
 						)
 				);
 				includeInResultRowList.add( true );
 				hasScalars = true;
 			}
 			else if ( rtn instanceof RootReturn ) {
 				RootReturn rootRtn = ( RootReturn ) rtn;
 				Queryable persister = ( Queryable ) factory.getEntityPersister( rootRtn.getEntityName() );
 				entityPersisters.add( persister );
 				lockModes.add( (rootRtn.getLockMode()) );
 				resultColumnProcessors.add( new NonScalarResultColumnProcessor( returnableCounter++ ) );
 				nonScalarReturnList.add( rtn );
 				entityOwners.add( new Integer( -1 ) );
 				resultTypes.add( persister.getType() );
 				specifiedAliases.add( rootRtn.getAlias() );
 				entityAliases.add( rootRtn.getEntityAliases() );
 				ArrayHelper.addAll( querySpaces, persister.getQuerySpaces() );
 				includeInResultRowList.add( true );
 			}
 			else if ( rtn instanceof CollectionReturn ) {
 				CollectionReturn collRtn = ( CollectionReturn ) rtn;
 				String role = collRtn.getOwnerEntityName() + "." + collRtn.getOwnerProperty();
 				QueryableCollection persister = ( QueryableCollection ) factory.getCollectionPersister( role );
 				collectionPersisters.add( persister );
 				lockModes.add( collRtn.getLockMode() );
 				resultColumnProcessors.add( new NonScalarResultColumnProcessor( returnableCounter++ ) );
 				nonScalarReturnList.add( rtn );
 				collectionOwners.add( new Integer( -1 ) );
 				resultTypes.add( persister.getType() );
 				specifiedAliases.add( collRtn.getAlias() );
 				collectionAliases.add( collRtn.getCollectionAliases() );
 				// determine if the collection elements are entities...
 				Type elementType = persister.getElementType();
 				if ( elementType.isEntityType() ) {
 					Queryable elementPersister = ( Queryable ) ( ( EntityType ) elementType ).getAssociatedJoinable( factory );
 					entityPersisters.add( elementPersister );
 					entityOwners.add( new Integer( -1 ) );
 					entityAliases.add( collRtn.getElementEntityAliases() );
 					ArrayHelper.addAll( querySpaces, elementPersister.getQuerySpaces() );
 				}
 				includeInResultRowList.add( true );
 			}
 			else if ( rtn instanceof EntityFetchReturn ) {
 				EntityFetchReturn fetchRtn = ( EntityFetchReturn ) rtn;
 				NonScalarReturn ownerDescriptor = fetchRtn.getOwner();
 				int ownerIndex = nonScalarReturnList.indexOf( ownerDescriptor );
 				entityOwners.add( new Integer( ownerIndex ) );
 				lockModes.add( fetchRtn.getLockMode() );
 				Queryable ownerPersister = determineAppropriateOwnerPersister( ownerDescriptor );
 				EntityType fetchedType = ( EntityType ) ownerPersister.getPropertyType( fetchRtn.getOwnerProperty() );
 				String entityName = fetchedType.getAssociatedEntityName( getFactory() );
 				Queryable persister = ( Queryable ) factory.getEntityPersister( entityName );
 				entityPersisters.add( persister );
 				nonScalarReturnList.add( rtn );
 				specifiedAliases.add( fetchRtn.getAlias() );
 				entityAliases.add( fetchRtn.getEntityAliases() );
 				ArrayHelper.addAll( querySpaces, persister.getQuerySpaces() );
 				includeInResultRowList.add( false );
 			}
 			else if ( rtn instanceof CollectionFetchReturn ) {
 				CollectionFetchReturn fetchRtn = ( CollectionFetchReturn ) rtn;
 				NonScalarReturn ownerDescriptor = fetchRtn.getOwner();
 				int ownerIndex = nonScalarReturnList.indexOf( ownerDescriptor );
 				collectionOwners.add( new Integer( ownerIndex ) );
 				lockModes.add( fetchRtn.getLockMode() );
 				Queryable ownerPersister = determineAppropriateOwnerPersister( ownerDescriptor );
 				String role = ownerPersister.getEntityName() + '.' + fetchRtn.getOwnerProperty();
 				QueryableCollection persister = ( QueryableCollection ) factory.getCollectionPersister( role );
 				collectionPersisters.add( persister );
 				nonScalarReturnList.add( rtn );
 				specifiedAliases.add( fetchRtn.getAlias() );
 				collectionAliases.add( fetchRtn.getCollectionAliases() );
 				// determine if the collection elements are entities...
 				Type elementType = persister.getElementType();
 				if ( elementType.isEntityType() ) {
 					Queryable elementPersister = ( Queryable ) ( ( EntityType ) elementType ).getAssociatedJoinable( factory );
 					entityPersisters.add( elementPersister );
 					entityOwners.add( new Integer( ownerIndex ) );
 					entityAliases.add( fetchRtn.getElementEntityAliases() );
 					ArrayHelper.addAll( querySpaces, elementPersister.getQuerySpaces() );
 				}
 				includeInResultRowList.add( false );
 			}
 			else {
 				throw new HibernateException( "unexpected custom query return type : " + rtn.getClass().getName() );
 			}
 		}
 
 		this.entityPersisters = new Queryable[ entityPersisters.size() ];
 		for ( int i = 0; i < entityPersisters.size(); i++ ) {
 			this.entityPersisters[i] = ( Queryable ) entityPersisters.get( i );
 		}
 		this.entiytOwners = ArrayHelper.toIntArray( entityOwners );
 		this.entityAliases = new EntityAliases[ entityAliases.size() ];
 		for ( int i = 0; i < entityAliases.size(); i++ ) {
 			this.entityAliases[i] = ( EntityAliases ) entityAliases.get( i );
 		}
 
 		this.collectionPersisters = new QueryableCollection[ collectionPersisters.size() ];
 		for ( int i = 0; i < collectionPersisters.size(); i++ ) {
 			this.collectionPersisters[i] = ( QueryableCollection ) collectionPersisters.get( i );
 		}
 		this.collectionOwners = ArrayHelper.toIntArray( collectionOwners );
 		this.collectionAliases = new CollectionAliases[ collectionAliases.size() ];
 		for ( int i = 0; i < collectionAliases.size(); i++ ) {
 			this.collectionAliases[i] = ( CollectionAliases ) collectionAliases.get( i );
 		}
 
 		this.lockModes = new LockMode[ lockModes.size() ];
 		for ( int i = 0; i < lockModes.size(); i++ ) {
 			this.lockModes[i] = ( LockMode ) lockModes.get( i );
 		}
 
 		this.resultTypes = ArrayHelper.toTypeArray( resultTypes );
 		this.transformerAliases = ArrayHelper.toStringArray( specifiedAliases );
 
 		this.rowProcessor = new ResultRowProcessor(
 				hasScalars,
 		        ( ResultColumnProcessor[] ) resultColumnProcessors.toArray( new ResultColumnProcessor[ resultColumnProcessors.size() ] )
 		);
 
 		this.includeInResultRow = ArrayHelper.toBooleanArray( includeInResultRowList );
 	}
 
 	private Queryable determineAppropriateOwnerPersister(NonScalarReturn ownerDescriptor) {
 		String entityName = null;
 		if ( ownerDescriptor instanceof RootReturn ) {
 			entityName = ( ( RootReturn ) ownerDescriptor ).getEntityName();
 		}
 		else if ( ownerDescriptor instanceof CollectionReturn ) {
 			CollectionReturn collRtn = ( CollectionReturn ) ownerDescriptor;
 			String role = collRtn.getOwnerEntityName() + "." + collRtn.getOwnerProperty();
 			CollectionPersister persister = getFactory().getCollectionPersister( role );
 			EntityType ownerType = ( EntityType ) persister.getElementType();
 			entityName = ownerType.getAssociatedEntityName( getFactory() );
 		}
 		else if ( ownerDescriptor instanceof FetchReturn ) {
 			FetchReturn fetchRtn = ( FetchReturn ) ownerDescriptor;
 			Queryable persister = determineAppropriateOwnerPersister( fetchRtn.getOwner() );
 			Type ownerType = persister.getPropertyType( fetchRtn.getOwnerProperty() );
 			if ( ownerType.isEntityType() ) {
 				entityName = ( ( EntityType ) ownerType ).getAssociatedEntityName( getFactory() );
 			}
 			else if ( ownerType.isCollectionType() ) {
 				Type ownerCollectionElementType = ( ( CollectionType ) ownerType ).getElementType( getFactory() );
 				if ( ownerCollectionElementType.isEntityType() ) {
 					entityName = ( ( EntityType ) ownerCollectionElementType ).getAssociatedEntityName( getFactory() );
 				}
 			}
 		}
 
 		if ( entityName == null ) {
 			throw new HibernateException( "Could not determine fetch owner : " + ownerDescriptor );
 		}
 
 		return ( Queryable ) getFactory().getEntityPersister( entityName );
 	}
 
 	@Override
     protected String getQueryIdentifier() {
 		return sql;
 	}
 
 	@Override
     protected String getSQLString() {
 		return sql;
 	}
 
 	public Set getQuerySpaces() {
 		return querySpaces;
 	}
 
 	@Override
     protected LockMode[] getLockModes(LockOptions lockOptions) {
 		return lockModes;
 	}
 
 	@Override
     protected Loadable[] getEntityPersisters() {
 		return entityPersisters;
 	}
 
 	@Override
     protected CollectionPersister[] getCollectionPersisters() {
 		return collectionPersisters;
 	}
 
 	@Override
     protected int[] getCollectionOwners() {
 		return collectionOwners;
 	}
 
 	@Override
     protected int[] getOwners() {
 		return entiytOwners;
 	}
 
 	public List list(SessionImplementor session, QueryParameters queryParameters) throws HibernateException {
 		return list( session, queryParameters, querySpaces, resultTypes );
 	}
 
 	public ScrollableResults scroll(
 			final QueryParameters queryParameters,
 			final SessionImplementor session) throws HibernateException {
 		return scroll(
 				queryParameters,
 				resultTypes,
 				getHolderInstantiator( queryParameters.getResultTransformer(), getReturnAliasesForTransformer() ),
 				session
 		);
 	}
 
 	static private HolderInstantiator getHolderInstantiator(ResultTransformer resultTransformer, String[] queryReturnAliases) {
 		if ( resultTransformer == null ) {
 			return HolderInstantiator.NOOP_INSTANTIATOR;
 		}
 		else {
 			return new HolderInstantiator(resultTransformer, queryReturnAliases);
 		}
 	}
 
 	@Override
     protected String[] getResultRowAliases() {
 		return transformerAliases;
 	}
 
 	@Override
     protected ResultTransformer resolveResultTransformer(ResultTransformer resultTransformer) {
 		return HolderInstantiator.resolveResultTransformer( null, resultTransformer );
 	}
 
 	@Override
     protected boolean[] includeInResultRow() {
 		return includeInResultRow;
 	}
 
 	@Override
     protected Object getResultColumnOrRow(
 			Object[] row,
 	        ResultTransformer transformer,
 	        ResultSet rs,
 	        SessionImplementor session) throws SQLException, HibernateException {
 		return rowProcessor.buildResultRow( row, rs, transformer != null, session );
 	}
 
 	@Override
     protected Object[] getResultRow(Object[] row, ResultSet rs, SessionImplementor session)
 			throws SQLException, HibernateException {
 		return rowProcessor.buildResultRow( row, rs, session );
 	}
 
 	@Override
     protected List getResultList(List results, ResultTransformer resultTransformer) throws QueryException {
 		// meant to handle dynamic instantiation queries...(Copy from QueryLoader)
 		HolderInstantiator holderInstantiator = HolderInstantiator.getHolderInstantiator(
 				null,
 				resultTransformer,
 				getReturnAliasesForTransformer()
 		);
 		if ( holderInstantiator.isRequired() ) {
 			for ( int i = 0; i < results.size(); i++ ) {
 				Object[] row = ( Object[] ) results.get( i );
 				Object result = holderInstantiator.instantiate(row);
 				results.set( i, result );
 			}
 
 			return resultTransformer.transformList(results);
 		}
 		else {
 			return results;
 		}
 	}
 
 	private String[] getReturnAliasesForTransformer() {
 		return transformerAliases;
 	}
 
 	@Override
     protected EntityAliases[] getEntityAliases() {
 		return entityAliases;
 	}
 
 	@Override
     protected CollectionAliases[] getCollectionAliases() {
 		return collectionAliases;
 	}
 
 	@Override
     public int[] getNamedParameterLocs(String name) throws QueryException {
 		Object loc = namedParameterBindPoints.get( name );
 		if ( loc == null ) {
 			throw new QueryException(
 					"Named parameter does not appear in Query: " + name,
 					sql
 			);
 		}
 		if ( loc instanceof Integer ) {
 			return new int[] { ( ( Integer ) loc ).intValue() };
 		}
 		else {
 			return ArrayHelper.toIntArray( ( List ) loc );
 		}
 	}
 
 
 	public class ResultRowProcessor {
 		private final boolean hasScalars;
 		private ResultColumnProcessor[] columnProcessors;
 
 		public ResultRowProcessor(boolean hasScalars, ResultColumnProcessor[] columnProcessors) {
 			this.hasScalars = hasScalars || ( columnProcessors == null || columnProcessors.length == 0 );
 			this.columnProcessors = columnProcessors;
 		}
 
 		public void prepareForAutoDiscovery(Metadata metadata) throws SQLException {
 			if ( columnProcessors == null || columnProcessors.length == 0 ) {
 				int columns = metadata.getColumnCount();
 				columnProcessors = new ResultColumnProcessor[ columns ];
 				for ( int i = 1; i <= columns; i++ ) {
 					columnProcessors[ i - 1 ] = new ScalarResultColumnProcessor( i );
 				}
 
 			}
 		}
 
 		/**
 		 * Build a logical result row.
 		 * <p/>
 		 * At this point, Loader has already processed all non-scalar result data.  We
 		 * just need to account for scalar result data here...
 		 *
 		 * @param data Entity data defined as "root returns" and already handled by the
 		 * normal Loader mechanism.
 		 * @param resultSet The JDBC result set (positioned at the row currently being processed).
 		 * @param hasTransformer Does this query have an associated {@link ResultTransformer}
 		 * @param session The session from which the query request originated.
 		 * @return The logical result row
 		 * @throws SQLException
 		 * @throws HibernateException
 		 */
 		public Object buildResultRow(
 				Object[] data,
 				ResultSet resultSet,
 				boolean hasTransformer,
 				SessionImplementor session) throws SQLException, HibernateException {
 			Object[] resultRow = buildResultRow( data, resultSet, session );
 			return ( hasTransformer )
 			       ? resultRow
 			       : ( resultRow.length == 1 )
 			         ? resultRow[0]
 			         : resultRow;
 		}
 		public Object[] buildResultRow(
 				Object[] data,
 				ResultSet resultSet,
 				SessionImplementor session) throws SQLException, HibernateException {
 			Object[] resultRow;
 			if ( !hasScalars ) {
 				resultRow = data;
 			}
 			else {
 				// build an array with indices equal to the total number
 				// of actual returns in the result Hibernate will return
 				// for this query (scalars + non-scalars)
 				resultRow = new Object[ columnProcessors.length ];
 				for ( int i = 0; i < columnProcessors.length; i++ ) {
 					resultRow[i] = columnProcessors[i].extract( data, resultSet, session );
 				}
 			}
 
 			return resultRow;
 		}
 	}
 
 	private static interface ResultColumnProcessor {
 		public Object extract(Object[] data, ResultSet resultSet, SessionImplementor session) throws SQLException, HibernateException;
 		public void performDiscovery(Metadata metadata, List types, List aliases) throws SQLException, HibernateException;
 	}
 
 	public class NonScalarResultColumnProcessor implements ResultColumnProcessor {
 		private final int position;
 
 		public NonScalarResultColumnProcessor(int position) {
 			this.position = position;
 		}
 
 		public Object extract(
 				Object[] data,
 				ResultSet resultSet,
 				SessionImplementor session) throws SQLException, HibernateException {
 			return data[ position ];
 		}
 
 		public void performDiscovery(Metadata metadata, List types, List aliases) {
 		}
 
 	}
 
 	public class ScalarResultColumnProcessor implements ResultColumnProcessor {
 		private int position = -1;
 		private String alias;
 		private Type type;
 
 		public ScalarResultColumnProcessor(int position) {
 			this.position = position;
 		}
 
 		public ScalarResultColumnProcessor(String alias, Type type) {
 			this.alias = alias;
 			this.type = type;
 		}
 
 		public Object extract(
 				Object[] data,
 				ResultSet resultSet,
 				SessionImplementor session) throws SQLException, HibernateException {
 			return type.nullSafeGet( resultSet, alias, session, null );
 		}
 
 		public void performDiscovery(Metadata metadata, List types, List aliases) throws SQLException {
 			if ( alias == null ) {
 				alias = metadata.getColumnName( position );
 			}
 			else if ( position < 0 ) {
 				position = metadata.resolveColumnPosition( alias );
 			}
 			if ( type == null ) {
 				type = metadata.getHibernateType( position );
 			}
 			types.add( type );
 			aliases.add( alias );
 		}
 	}
 
 	@Override
     protected void autoDiscoverTypes(ResultSet rs) {
 		try {
 			Metadata metadata = new Metadata( getFactory(), rs );
 			List aliases = new ArrayList();
 			List types = new ArrayList();
 
 			rowProcessor.prepareForAutoDiscovery( metadata );
 
 			for ( int i = 0; i < rowProcessor.columnProcessors.length; i++ ) {
 				rowProcessor.columnProcessors[i].performDiscovery( metadata, types, aliases );
 			}
 
 			resultTypes = ArrayHelper.toTypeArray( types );
 			transformerAliases = ArrayHelper.toStringArray( aliases );
 		}
 		catch ( SQLException e ) {
 			throw new HibernateException( "Exception while trying to autodiscover types.", e );
 		}
 	}
 
 	private static class Metadata {
 		private final SessionFactoryImplementor factory;
 		private final ResultSet resultSet;
 		private final ResultSetMetaData resultSetMetaData;
 
 		public Metadata(SessionFactoryImplementor factory, ResultSet resultSet) throws HibernateException {
 			try {
 				this.factory = factory;
 				this.resultSet = resultSet;
 				this.resultSetMetaData = resultSet.getMetaData();
 			}
 			catch( SQLException e ) {
 				throw new HibernateException( "Could not extract result set metadata", e );
 			}
 		}
 
 		public int getColumnCount() throws HibernateException {
 			try {
 				return resultSetMetaData.getColumnCount();
 			}
 			catch( SQLException e ) {
 				throw new HibernateException( "Could not determine result set column count", e );
 			}
 		}
 
 		public int resolveColumnPosition(String columnName) throws HibernateException {
 			try {
 				return resultSet.findColumn( columnName );
 			}
 			catch( SQLException e ) {
 				throw new HibernateException( "Could not resolve column name in result set [" + columnName + "]", e );
 			}
 		}
 
 		public String getColumnName(int position) throws HibernateException {
 			try {
 				return factory.getDialect().getColumnAliasExtractor().extractColumnAlias( resultSetMetaData, position );
 			}
 			catch( SQLException e ) {
 				throw new HibernateException( "Could not resolve column name [" + position + "]", e );
 			}
 		}
 
 		public Type getHibernateType(int columnPos) throws SQLException {
 			int columnType = resultSetMetaData.getColumnType( columnPos );
 			int scale = resultSetMetaData.getScale( columnPos );
 			int precision = resultSetMetaData.getPrecision( columnPos );
 			return factory.getTypeResolver().heuristicType(
 					factory.getDialect().getHibernateTypeName(
 							columnType,
 							precision,
 							precision,
 							scale
 					)
 			);
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/hql/QueryLoader.java b/hibernate-core/src/main/java/org/hibernate/loader/hql/QueryLoader.java
index be234e260d..e699c26ff0 100644
--- a/hibernate-core/src/main/java/org/hibernate/loader/hql/QueryLoader.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/hql/QueryLoader.java
@@ -1,617 +1,617 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.loader.hql;
 
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.event.spi.EventSource;
-import org.hibernate.hql.HolderInstantiator;
-import org.hibernate.hql.ast.QueryTranslatorImpl;
-import org.hibernate.hql.ast.tree.AggregatedSelectExpression;
-import org.hibernate.hql.ast.tree.FromElement;
-import org.hibernate.hql.ast.tree.QueryNode;
-import org.hibernate.hql.ast.tree.SelectClause;
+import org.hibernate.hql.internal.HolderInstantiator;
+import org.hibernate.hql.internal.ast.QueryTranslatorImpl;
+import org.hibernate.hql.internal.ast.tree.AggregatedSelectExpression;
+import org.hibernate.hql.internal.ast.tree.FromElement;
+import org.hibernate.hql.internal.ast.tree.QueryNode;
+import org.hibernate.hql.internal.ast.tree.SelectClause;
 import org.hibernate.internal.IteratorImpl;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.loader.BasicLoader;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.Lockable;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 /**
  * A delegate that implements the Loader part of QueryTranslator.
  *
  * @author josh
  */
 public class QueryLoader extends BasicLoader {
 
 	/**
 	 * The query translator that is delegating to this object.
 	 */
 	private QueryTranslatorImpl queryTranslator;
 
 	private Queryable[] entityPersisters;
 	private String[] entityAliases;
 	private String[] sqlAliases;
 	private String[] sqlAliasSuffixes;
 	private boolean[] includeInSelect;
 
 	private String[] collectionSuffixes;
 
 	private boolean hasScalars;
 	private String[][] scalarColumnNames;
 	//private Type[] sqlResultTypes;
 	private Type[] queryReturnTypes;
 
 	private final Map sqlAliasByEntityAlias = new HashMap(8);
 
 	private EntityType[] ownerAssociationTypes;
 	private int[] owners;
 	private boolean[] entityEagerPropertyFetches;
 
 	private int[] collectionOwners;
 	private QueryableCollection[] collectionPersisters;
 
 	private int selectLength;
 
 	private AggregatedSelectExpression aggregatedSelectExpression;
 	private String[] queryReturnAliases;
 
 	private LockMode[] defaultLockModes;
 
 
 	/**
 	 * Creates a new Loader implementation.
 	 *
 	 * @param queryTranslator The query translator that is the delegator.
 	 * @param factory The factory from which this loader is being created.
 	 * @param selectClause The AST representing the select clause for loading.
 	 */
 	public QueryLoader(
 			final QueryTranslatorImpl queryTranslator,
 	        final SessionFactoryImplementor factory,
 	        final SelectClause selectClause) {
 		super( factory );
 		this.queryTranslator = queryTranslator;
 		initialize( selectClause );
 		postInstantiate();
 	}
 
 	private void initialize(SelectClause selectClause) {
 
 		List fromElementList = selectClause.getFromElementsForLoad();
 
 		hasScalars = selectClause.isScalarSelect();
 		scalarColumnNames = selectClause.getColumnNames();
 		//sqlResultTypes = selectClause.getSqlResultTypes();
 		queryReturnTypes = selectClause.getQueryReturnTypes();
 
 		aggregatedSelectExpression = selectClause.getAggregatedSelectExpression();
 		queryReturnAliases = selectClause.getQueryReturnAliases();
 
 		List collectionFromElements = selectClause.getCollectionFromElements();
 		if ( collectionFromElements != null && collectionFromElements.size()!=0 ) {
 			int length = collectionFromElements.size();
 			collectionPersisters = new QueryableCollection[length];
 			collectionOwners = new int[length];
 			collectionSuffixes = new String[length];
 			for ( int i=0; i<length; i++ ) {
 				FromElement collectionFromElement = (FromElement) collectionFromElements.get(i);
 				collectionPersisters[i] = collectionFromElement.getQueryableCollection();
 				collectionOwners[i] = fromElementList.indexOf( collectionFromElement.getOrigin() );
 //				collectionSuffixes[i] = collectionFromElement.getColumnAliasSuffix();
 //				collectionSuffixes[i] = Integer.toString( i ) + "_";
 				collectionSuffixes[i] = collectionFromElement.getCollectionSuffix();
 			}
 		}
 
 		int size = fromElementList.size();
 		entityPersisters = new Queryable[size];
 		entityEagerPropertyFetches = new boolean[size];
 		entityAliases = new String[size];
 		sqlAliases = new String[size];
 		sqlAliasSuffixes = new String[size];
 		includeInSelect = new boolean[size];
 		owners = new int[size];
 		ownerAssociationTypes = new EntityType[size];
 
 		for ( int i = 0; i < size; i++ ) {
 			final FromElement element = ( FromElement ) fromElementList.get( i );
 			entityPersisters[i] = ( Queryable ) element.getEntityPersister();
 
 			if ( entityPersisters[i] == null ) {
 				throw new IllegalStateException( "No entity persister for " + element.toString() );
 			}
 
 			entityEagerPropertyFetches[i] = element.isAllPropertyFetch();
 			sqlAliases[i] = element.getTableAlias();
 			entityAliases[i] = element.getClassAlias();
 			sqlAliasByEntityAlias.put( entityAliases[i], sqlAliases[i] );
 			// TODO should we just collect these like with the collections above?
 			sqlAliasSuffixes[i] = ( size == 1 ) ? "" : Integer.toString( i ) + "_";
 //			sqlAliasSuffixes[i] = element.getColumnAliasSuffix();
 			includeInSelect[i] = !element.isFetch();
 			if ( includeInSelect[i] ) {
 				selectLength++;
 			}
 
 			owners[i] = -1; //by default
 			if ( element.isFetch() ) {
 				if ( element.isCollectionJoin() || element.getQueryableCollection() != null ) {
 					// This is now handled earlier in this method.
 				}
 				else if ( element.getDataType().isEntityType() ) {
 					EntityType entityType = ( EntityType ) element.getDataType();
 					if ( entityType.isOneToOne() ) {
 						owners[i] = fromElementList.indexOf( element.getOrigin() );
 					}
 					ownerAssociationTypes[i] = entityType;
 				}
 			}
 		}
 
 		//NONE, because its the requested lock mode, not the actual! 
 		defaultLockModes = ArrayHelper.fillArray( LockMode.NONE, size );
 	}
 
 	public AggregatedSelectExpression getAggregatedSelectExpression() {
 		return aggregatedSelectExpression;
 	}
 
 
 	// -- Loader implementation --
 
 	public final void validateScrollability() throws HibernateException {
 		queryTranslator.validateScrollability();
 	}
 
 	protected boolean needsFetchingScroll() {
 		return queryTranslator.containsCollectionFetches();
 	}
 
 	public Loadable[] getEntityPersisters() {
 		return entityPersisters;
 	}
 
 	public String[] getAliases() {
 		return sqlAliases;
 	}
 
 	public String[] getSqlAliasSuffixes() {
 		return sqlAliasSuffixes;
 	}
 
 	public String[] getSuffixes() {
 		return getSqlAliasSuffixes();
 	}
 
 	public String[] getCollectionSuffixes() {
 		return collectionSuffixes;
 	}
 
 	protected String getQueryIdentifier() {
 		return queryTranslator.getQueryIdentifier();
 	}
 
 	/**
 	 * The SQL query string to be called.
 	 */
 	protected String getSQLString() {
 		return queryTranslator.getSQLString();
 	}
 
 	/**
 	 * An (optional) persister for a collection to be initialized; only collection loaders
 	 * return a non-null value
 	 */
 	protected CollectionPersister[] getCollectionPersisters() {
 		return collectionPersisters;
 	}
 
 	protected int[] getCollectionOwners() {
 		return collectionOwners;
 	}
 
 	protected boolean[] getEntityEagerPropertyFetches() {
 		return entityEagerPropertyFetches;
 	}
 
 	/**
 	 * An array of indexes of the entity that owns a one-to-one association
 	 * to the entity at the given index (-1 if there is no "owner")
 	 */
 	protected int[] getOwners() {
 		return owners;
 	}
 
 	protected EntityType[] getOwnerAssociationTypes() {
 		return ownerAssociationTypes;
 	}
 
 	// -- Loader overrides --
 
 	protected boolean isSubselectLoadingEnabled() {
 		return hasSubselectLoadableCollections();
 	}
 
 	/**
 	 * @param lockOptions a collection of lock modes specified dynamically via the Query interface
 	 */
 	protected LockMode[] getLockModes(LockOptions lockOptions) {
 		if ( lockOptions == null ) {
 			return defaultLockModes;
 		}
 
 		if ( lockOptions.getAliasLockCount() == 0
 				&& ( lockOptions.getLockMode() == null || LockMode.NONE.equals( lockOptions.getLockMode() ) ) ) {
 			return defaultLockModes;
 		}
 
 		// unfortunately this stuff can't be cached because
 		// it is per-invocation, not constant for the
 		// QueryTranslator instance
 
 		LockMode[] lockModesArray = new LockMode[entityAliases.length];
 		for ( int i = 0; i < entityAliases.length; i++ ) {
 			LockMode lockMode = lockOptions.getEffectiveLockMode( entityAliases[i] );
 			if ( lockMode == null ) {
 				//NONE, because its the requested lock mode, not the actual!
 				lockMode = LockMode.NONE;
 			}
 			lockModesArray[i] = lockMode;
 		}
 
 		return lockModesArray;
 	}
 
 	protected String applyLocks(String sql, LockOptions lockOptions, Dialect dialect) throws QueryException {
 		// can't cache this stuff either (per-invocation)
 		// we are given a map of user-alias -> lock mode
 		// create a new map of sql-alias -> lock mode
 
 		if ( lockOptions == null ||
 			( lockOptions.getLockMode() == LockMode.NONE && lockOptions.getAliasLockCount() == 0 ) ) {
 			return sql;
 		}
 
 		// we need both the set of locks and the columns to reference in locks
 		// as the ultimate output of this section...
 		final LockOptions locks = new LockOptions( lockOptions.getLockMode() );
 		final Map keyColumnNames = dialect.forUpdateOfColumns() ? new HashMap() : null;
 
 		locks.setScope( lockOptions.getScope() );
 		locks.setTimeOut( lockOptions.getTimeOut() );
 
 		final Iterator itr = sqlAliasByEntityAlias.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = (Map.Entry) itr.next();
 			final String userAlias = (String) entry.getKey();
 			final String drivingSqlAlias = (String) entry.getValue();
 			if ( drivingSqlAlias == null ) {
 				throw new IllegalArgumentException( "could not locate alias to apply lock mode : " + userAlias );
 			}
 			// at this point we have (drivingSqlAlias) the SQL alias of the driving table
 			// corresponding to the given user alias.  However, the driving table is not
 			// (necessarily) the table against which we want to apply locks.  Mainly,
 			// the exception case here is joined-subclass hierarchies where we instead
 			// want to apply the lock against the root table (for all other strategies,
 			// it just happens that driving and root are the same).
 			final QueryNode select = ( QueryNode ) queryTranslator.getSqlAST();
 			final Lockable drivingPersister = ( Lockable ) select.getFromClause()
 					.findFromElementByUserOrSqlAlias( userAlias, drivingSqlAlias )
 					.getQueryable();
 			final String sqlAlias = drivingPersister.getRootTableAlias( drivingSqlAlias );
 
 			final LockMode effectiveLockMode = lockOptions.getEffectiveLockMode( userAlias );
 			locks.setAliasSpecificLockMode( sqlAlias, effectiveLockMode );
 
 			if ( keyColumnNames != null ) {
 				keyColumnNames.put( sqlAlias, drivingPersister.getRootTableIdentifierColumnNames() );
 			}
 		}
 
 		// apply the collected locks and columns
 		return dialect.applyLocksToSql( sql, locks, keyColumnNames );
 	}
 
 	protected void applyPostLoadLocks(Object[] row, LockMode[] lockModesArray, SessionImplementor session) {
 		// todo : scalars???
 //		if ( row.length != lockModesArray.length ) {
 //			return;
 //		}
 //
 //		for ( int i = 0; i < lockModesArray.length; i++ ) {
 //			if ( LockMode.OPTIMISTIC_FORCE_INCREMENT.equals( lockModesArray[i] ) ) {
 //				final EntityEntry pcEntry =
 //			}
 //			else if ( LockMode.PESSIMISTIC_FORCE_INCREMENT.equals( lockModesArray[i] ) ) {
 //
 //			}
 //		}
 	}
 
 	protected boolean upgradeLocks() {
 		return true;
 	}
 
 	private boolean hasSelectNew() {
 		return aggregatedSelectExpression != null &&  aggregatedSelectExpression.getResultTransformer() != null;
 	}
 
 	protected String[] getResultRowAliases() {
 		return queryReturnAliases;
 	}
 	
 	protected ResultTransformer resolveResultTransformer(ResultTransformer resultTransformer) {
 		final ResultTransformer implicitResultTransformer = aggregatedSelectExpression == null
 				? null
 				: aggregatedSelectExpression.getResultTransformer();
 		return HolderInstantiator.resolveResultTransformer( implicitResultTransformer, resultTransformer );
 	}
 
 	protected boolean[] includeInResultRow() {
 		boolean[] includeInResultTuple = includeInSelect;
 		if ( hasScalars ) {
 			includeInResultTuple = new boolean[ queryReturnTypes.length ];
 			Arrays.fill( includeInResultTuple, true );
 		}
 		return includeInResultTuple;
 	}
 
 	protected Object getResultColumnOrRow(Object[] row, ResultTransformer transformer, ResultSet rs, SessionImplementor session)
 			throws SQLException, HibernateException {
 
 		Object[] resultRow = getResultRow( row, rs, session );
 		boolean hasTransform = hasSelectNew() || transformer!=null;
 		return ( ! hasTransform && resultRow.length == 1 ?
 				resultRow[ 0 ] :
 				resultRow
 		);
 	}
 
 	protected Object[] getResultRow(Object[] row, ResultSet rs, SessionImplementor session)
 			throws SQLException, HibernateException {
 		Object[] resultRow;
 		if ( hasScalars ) {
 			String[][] scalarColumns = scalarColumnNames;
 			int queryCols = queryReturnTypes.length;
 			resultRow = new Object[queryCols];
 			for ( int i = 0; i < queryCols; i++ ) {
 				resultRow[i] = queryReturnTypes[i].nullSafeGet( rs, scalarColumns[i], session, null );
 			}
 		}
 		else {
 			resultRow = toResultRow( row );
 		}
 		return resultRow;
 	}
 
 	protected List getResultList(List results, ResultTransformer resultTransformer) throws QueryException {
 		// meant to handle dynamic instantiation queries...
 		HolderInstantiator holderInstantiator = buildHolderInstantiator( resultTransformer );
 		if ( holderInstantiator.isRequired() ) {
 			for ( int i = 0; i < results.size(); i++ ) {
 				Object[] row = ( Object[] ) results.get( i );
 				Object result = holderInstantiator.instantiate(row);
 				results.set( i, result );
 			}
 
 			if ( !hasSelectNew() && resultTransformer != null ) {
 				return resultTransformer.transformList(results);
 			}
 			else {
 				return results;
 			}
 		}
 		else {
 			return results;
 		}
 	}
 
 	private HolderInstantiator buildHolderInstantiator(ResultTransformer queryLocalResultTransformer) {
 		final ResultTransformer implicitResultTransformer = aggregatedSelectExpression == null
 				? null
 				: aggregatedSelectExpression.getResultTransformer();
 		return HolderInstantiator.getHolderInstantiator(
 				implicitResultTransformer,
 				queryLocalResultTransformer,
 				queryReturnAliases
 		);
 	}
 	// --- Query translator methods ---
 
 	public List list(
 			SessionImplementor session,
 			QueryParameters queryParameters) throws HibernateException {
 		checkQuery( queryParameters );
 		return list( session, queryParameters, queryTranslator.getQuerySpaces(), queryReturnTypes );
 	}
 
 	private void checkQuery(QueryParameters queryParameters) {
 		if ( hasSelectNew() && queryParameters.getResultTransformer() != null ) {
 			throw new QueryException( "ResultTransformer is not allowed for 'select new' queries." );
 		}
 	}
 
 	public Iterator iterate(
 			QueryParameters queryParameters,
 			EventSource session) throws HibernateException {
 		checkQuery( queryParameters );
 		final boolean stats = session.getFactory().getStatistics().isStatisticsEnabled();
 		long startTime = 0;
 		if ( stats ) {
 			startTime = System.currentTimeMillis();
 		}
 
 		try {
 			final PreparedStatement st = prepareQueryStatement( queryParameters, false, session );
 			if ( queryParameters.isCallable() ) {
 				throw new QueryException("iterate() not supported for callable statements");
 			}
 			final ResultSet rs = getResultSet(st, queryParameters.hasAutoDiscoverScalarTypes(), false, queryParameters.getRowSelection(), session);
 			final Iterator result = new IteratorImpl(
 					rs,
 			        st,
 			        session,
 			        queryParameters.isReadOnly( session ),
 			        queryReturnTypes,
 			        queryTranslator.getColumnNames(),
 			        buildHolderInstantiator( queryParameters.getResultTransformer() )
 			);
 
 			if ( stats ) {
 				session.getFactory().getStatisticsImplementor().queryExecuted(
 //						"HQL: " + queryTranslator.getQueryString(),
 						getQueryIdentifier(),
 						0,
 						System.currentTimeMillis() - startTime
 				);
 			}
 
 			return result;
 
 		}
 		catch ( SQLException sqle ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not execute query using iterate",
 			        getSQLString()
 				);
 		}
 
 	}
 
 	public ScrollableResults scroll(
 			final QueryParameters queryParameters,
 	        final SessionImplementor session) throws HibernateException {
 		checkQuery( queryParameters );
 		return scroll( 
 				queryParameters,
 				queryReturnTypes,
 				buildHolderInstantiator( queryParameters.getResultTransformer() ),
 				session
 		);
 	}
 
 	// -- Implementation private methods --
 
 	private Object[] toResultRow(Object[] row) {
 		if ( selectLength == row.length ) {
 			return row;
 		}
 		else {
 			Object[] result = new Object[selectLength];
 			int j = 0;
 			for ( int i = 0; i < row.length; i++ ) {
 				if ( includeInSelect[i] ) {
 					result[j++] = row[i];
 				}
 			}
 			return result;
 		}
 	}
 
 	/**
 	 * Returns the locations of all occurrences of the named parameter.
 	 */
 	public int[] getNamedParameterLocs(String name) throws QueryException {
 		return queryTranslator.getParameterTranslations().getNamedParameterSqlLocations( name );
 	}
 
 	/**
 	 * We specifically override this method here, because in general we know much more
 	 * about the parameters and their appropriate bind positions here then we do in
 	 * our super because we track them explciitly here through the ParameterSpecification
 	 * interface.
 	 *
 	 * @param queryParameters The encapsulation of the parameter values to be bound.
 	 * @param startIndex The position from which to start binding parameter values.
 	 * @param session The originating session.
 	 * @return The number of JDBC bind positions actually bound during this method execution.
 	 * @throws SQLException Indicates problems performing the binding.
 	 */
 	protected int bindParameterValues(
 			final PreparedStatement statement,
 			final QueryParameters queryParameters,
 			final int startIndex,
 			final SessionImplementor session) throws SQLException {
 //		int position = bindFilterParameterValues( statement, queryParameters, startIndex, session );
 		int position = startIndex;
 //		List parameterSpecs = queryTranslator.getSqlAST().getWalker().getParameters();
 		List parameterSpecs = queryTranslator.getCollectedParameterSpecifications();
 		Iterator itr = parameterSpecs.iterator();
 		while ( itr.hasNext() ) {
 			ParameterSpecification spec = ( ParameterSpecification ) itr.next();
 			position += spec.bind( statement, queryParameters, session, position );
 		}
 		return position - startIndex;
 	}
 
 	private int bindFilterParameterValues(
 			PreparedStatement st,
 			QueryParameters queryParameters,
 			int position,
 			SessionImplementor session) throws SQLException {
 		// todo : better to handle dynamic filters through implicit DynamicFilterParameterSpecification
 		// see the discussion there in DynamicFilterParameterSpecification's javadocs as to why
 		// it is currently not done that way.
 		int filteredParamCount = queryParameters.getFilteredPositionalParameterTypes() == null
 				? 0
 				: queryParameters.getFilteredPositionalParameterTypes().length;
 		int nonfilteredParamCount = queryParameters.getPositionalParameterTypes() == null
 				? 0
 				: queryParameters.getPositionalParameterTypes().length;
 		int filterParamCount = filteredParamCount - nonfilteredParamCount;
 		for ( int i = 0; i < filterParamCount; i++ ) {
 			Type type = queryParameters.getFilteredPositionalParameterTypes()[i];
 			Object value = queryParameters.getFilteredPositionalParameterValues()[i];
 			type.nullSafeSet( st, value, position, session );
 			position += type.getColumnSpan( getFactory() );
 		}
 
 		return position;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/sql/ordering/antlr/OrderByFragmentRenderer.java b/hibernate-core/src/main/java/org/hibernate/sql/ordering/antlr/OrderByFragmentRenderer.java
index 6c0cb2c530..ab5497468b 100644
--- a/hibernate-core/src/main/java/org/hibernate/sql/ordering/antlr/OrderByFragmentRenderer.java
+++ b/hibernate-core/src/main/java/org/hibernate/sql/ordering/antlr/OrderByFragmentRenderer.java
@@ -1,78 +1,78 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.sql.ordering.antlr;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.hql.ast.util.ASTPrinter;
+import org.hibernate.hql.internal.ast.util.ASTPrinter;
 import org.hibernate.internal.util.StringHelper;
 
 import org.jboss.logging.Logger;
 import antlr.collections.AST;
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class OrderByFragmentRenderer extends GeneratedOrderByFragmentRenderer {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        OrderByFragmentRenderer.class.getName());
 	private static final ASTPrinter printer = new ASTPrinter( GeneratedOrderByFragmentRendererTokenTypes.class );
 
 	@Override
     protected void out(AST ast) {
 		out( ( ( Node ) ast ).getRenderableText() );
 	}
 
 
 	// handle trace logging ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
     private int traceDepth = 0;
 
 	@Override
     public void traceIn(String ruleName, AST tree) {
 		if ( inputState.guessing > 0 ) {
 			return;
 		}
 		String prefix = StringHelper.repeat( '-', (traceDepth++ * 2) ) + "-> ";
 		String traceText = ruleName + " (" + buildTraceNodeName(tree) + ")";
         LOG.trace(prefix + traceText);
 	}
 
 	private String buildTraceNodeName(AST tree) {
 		return tree == null
 				? "???"
 				: tree.getText() + " [" + printer.getTokenTypeName( tree.getType() ) + "]";
 	}
 
 	@Override
     public void traceOut(String ruleName, AST tree) {
 		if ( inputState.guessing > 0 ) {
 			return;
 		}
 		String prefix = "<-" + StringHelper.repeat( '-', (--traceDepth * 2) ) + " ";
         LOG.trace(prefix + ruleName);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/sql/ordering/antlr/OrderByFragmentTranslator.java b/hibernate-core/src/main/java/org/hibernate/sql/ordering/antlr/OrderByFragmentTranslator.java
index a4b1a35223..cd267b4258 100644
--- a/hibernate-core/src/main/java/org/hibernate/sql/ordering/antlr/OrderByFragmentTranslator.java
+++ b/hibernate-core/src/main/java/org/hibernate/sql/ordering/antlr/OrderByFragmentTranslator.java
@@ -1,87 +1,87 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.sql.ordering.antlr;
 import java.io.StringReader;
 import org.hibernate.HibernateException;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.hql.ast.util.ASTPrinter;
+import org.hibernate.hql.internal.ast.util.ASTPrinter;
 
 import org.jboss.logging.Logger;
 
 /**
  * A translator which coordinates translation of an <tt>order-by</tt> mapping.
  *
  * @author Steve Ebersole
  */
 public class OrderByFragmentTranslator {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        OrderByFragmentTranslator.class.getName());
 
 	public final TranslationContext context;
 
 	public OrderByFragmentTranslator(TranslationContext context) {
 		this.context = context;
 	}
 
 	/**
 	 * The main contract, performing the transaction.
 	 *
 	 * @param fragment The <tt>order-by</tt> mapping fragment to be translated.
 	 *
 	 * @return The translated fragment.
 	 */
 	public String render(String fragment) {
 		GeneratedOrderByLexer lexer = new GeneratedOrderByLexer( new StringReader( fragment ) );
 		OrderByFragmentParser parser = new OrderByFragmentParser( lexer, context );
 		try {
 			parser.orderByFragment();
 		}
 		catch ( HibernateException e ) {
 			throw e;
 		}
 		catch ( Throwable t ) {
 			throw new HibernateException( "Unable to parse order-by fragment", t );
 		}
 
         if (LOG.isTraceEnabled()) {
 			ASTPrinter printer = new ASTPrinter( OrderByTemplateTokenTypes.class );
             LOG.trace(printer.showAsString(parser.getAST(), "--- {order-by fragment} ---"));
 		}
 
 		OrderByFragmentRenderer renderer = new OrderByFragmentRenderer();
 		try {
 			renderer.orderByFragment( parser.getAST() );
 		}
 		catch ( HibernateException e ) {
 			throw e;
 		}
 		catch ( Throwable t ) {
 			throw new HibernateException( "Unable to render parsed order-by fragment", t );
 		}
 
 		return renderer.getRenderedFragment();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/ast/ASTIteratorTest.java b/hibernate-core/src/test/java/org/hibernate/test/ast/ASTIteratorTest.java
index 9fd05e0177..328a4f9fa3 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/ast/ASTIteratorTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/ast/ASTIteratorTest.java
@@ -1,128 +1,128 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.ast;
 
 import java.io.PrintWriter;
 
 import antlr.ASTFactory;
 import antlr.collections.AST;
 
-import org.hibernate.hql.antlr.HqlTokenTypes;
-import org.hibernate.hql.ast.HqlParser;
-import org.hibernate.hql.ast.util.ASTIterator;
-import org.hibernate.hql.ast.util.ASTParentsFirstIterator;
-import org.hibernate.hql.ast.util.ASTPrinter;
-import org.hibernate.hql.ast.util.ASTUtil;
+import org.hibernate.hql.internal.antlr.HqlTokenTypes;
+import org.hibernate.hql.internal.ast.HqlParser;
+import org.hibernate.hql.internal.ast.util.ASTIterator;
+import org.hibernate.hql.internal.ast.util.ASTParentsFirstIterator;
+import org.hibernate.hql.internal.ast.util.ASTPrinter;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Test ASTIterator.
  */
 public class ASTIteratorTest extends BaseUnitTestCase {
 	private ASTFactory factory = new ASTFactory();
 
 	@Test
 	public void testSimpleTree() throws Exception {
 		String input = "select foo from foo in class org.hibernate.test.Foo, fee in class org.hibernate.test.Fee where foo.dependent = fee order by foo.string desc, foo.component.count asc, fee.id";
 		HqlParser parser = HqlParser.getInstance( input );
 		parser.statement();
 		AST ast = parser.getAST();
 		ASTPrinter printer = new ASTPrinter( HqlTokenTypes.class );
 		printer.showAst( ast, new PrintWriter( System.out ) );
 		ASTIterator iterator = new ASTIterator( ast );
 		int count = 0;
 		while ( iterator.hasNext() ) {
 			assertTrue( iterator.next() instanceof AST );
 			count++;
 		}
 		assertEquals( 43, count );
 
 		UnsupportedOperationException uoe = null;
 		try {
 			iterator.remove();
 		}
 		catch ( UnsupportedOperationException e ) {
 			uoe = e;
 		}
 		assertNotNull( uoe );
 	}
 
 	@Test
 	public void testParentsFirstIterator() throws Exception {
 		AST[] tree = new AST[4];
 		AST grandparent = tree[0] = ASTUtil.create( factory, 1, "grandparent" );
 		AST parent = tree[1] = ASTUtil.create( factory, 2, "parent" );
 		AST child = tree[2] = ASTUtil.create( factory, 3, "child" );
 		AST baby = tree[3] = ASTUtil.create( factory, 4, "baby" );
 		AST t = ASTUtil.createTree( factory, tree );
 		AST brother = ASTUtil.create( factory, 10, "brother" );
 		child.setNextSibling( brother );
 		AST sister = ASTUtil.create( factory, 11, "sister" );
 		brother.setNextSibling( sister );
 		AST uncle = factory.make( new AST[]{
 			factory.create( 20, "uncle" ),
 			factory.create( 21, "cousin1" ),
 			factory.create( 22, "cousin2" ),
 			factory.create( 23, "cousin3" )} );
 		parent.setNextSibling( uncle );
 		System.out.println( t.toStringTree() );
 
 		System.out.println( "--- ASTParentsFirstIterator ---" );
 		ASTParentsFirstIterator iter = new ASTParentsFirstIterator( t );
 		int count = 0;
 		while ( iter.hasNext() ) {
 			AST n = iter.nextNode();
 			count++;
 			System.out.println( n );
 		}
 		assertEquals( 10, count );
 
 		System.out.println( "--- ASTIterator ---" );
 		ASTIterator iter2 = new ASTIterator( t );
 		int count2 = 0;
 		while ( iter2.hasNext() ) {
 			AST n = iter2.nextNode();
 			count2++;
 			System.out.println( n );
 		}
 		assertEquals( 10, count2 );
 
 		System.out.println( "--- ASTParentsFirstIterator (parent) ---" );
 		ASTParentsFirstIterator iter3 = new ASTParentsFirstIterator( parent );
 		int count3 = 0;
 		while ( iter3.hasNext() ) {
 			AST n = iter3.nextNode();
 			count3++;
 			System.out.println( n );
 		}
 		assertEquals( 5, count3 );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/ast/ASTUtilTest.java b/hibernate-core/src/test/java/org/hibernate/test/ast/ASTUtilTest.java
index 52efcf2549..3feb970f25 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/ast/ASTUtilTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/ast/ASTUtilTest.java
@@ -1,87 +1,87 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.ast;
 
 import antlr.ASTFactory;
 import antlr.collections.AST;
 
-import org.hibernate.hql.ast.util.ASTUtil;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 
 /**
  * Unit test for ASTUtil.
  */
 public class ASTUtilTest extends BaseUnitTestCase {
 	private ASTFactory factory = new ASTFactory();
 
 	@Test
 	public void testCreate() throws Exception {
 		AST n = ASTUtil.create( factory, 1, "one");
 		assertNull( n.getFirstChild() );
 		assertEquals( "one", n.getText() );
 		assertEquals( 1, n.getType() );
 	}
 
 	@Test
 	public void testCreateTree() throws Exception {
 		AST[] tree = new AST[4];
 		AST grandparent = tree[0] = ASTUtil.create(factory, 1, "grandparent");
 		AST parent = tree[1] = ASTUtil.create(factory,2,"parent");
 		AST child = tree[2] = ASTUtil.create(factory,3,"child");
 		AST baby = tree[3] = ASTUtil.create(factory,4,"baby");
 		AST t = ASTUtil.createTree( factory, tree);
 		assertSame(t,grandparent);
 		assertSame(parent,t.getFirstChild());
 		assertSame(child,t.getFirstChild().getFirstChild());
 		assertSame( baby, t.getFirstChild().getFirstChild().getFirstChild() );
 	}
 
 	@Test
 	public void testFindPreviousSibling() throws Exception {
 		AST child1 = ASTUtil.create(factory,2, "child1");
 		AST child2 = ASTUtil.create(factory,3, "child2");
 		AST n = factory.make( new AST[] {
 			ASTUtil.create(factory, 1, "parent"),
 			child1,
 			child2,
 		});
 		assertSame(child1,ASTUtil.findPreviousSibling( n,child2));
 		Exception e = null;
 		try {
 			ASTUtil.findPreviousSibling(child1,null);
 		}
 		catch (Exception x) {
 			e = x;
 		}
 		assertNotNull(e);
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingOrderByTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingOrderByTest.java
index 3d0ae5a8de..c69f96add0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingOrderByTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingOrderByTest.java
@@ -1,695 +1,693 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.Hibernate;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
-import org.hibernate.hql.ast.ASTQueryTranslatorFactory;
+import org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory;
 
-import org.junit.After;
-import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.testing.FailureExpected;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Tests AST parser processing of ORDER BY clauses.
  *
  * @author Gail Badner
  */
 public class ASTParserLoadingOrderByTest extends BaseCoreFunctionalTestCase {
 	StateProvince stateProvince;
 	private Zoo zoo1;
 	private Zoo zoo2;
 	private Zoo zoo3;
 	private Zoo zoo4;
 	Set<Zoo> zoosWithSameName;
 	Set<Zoo> zoosWithSameAddress;
 	Mammal zoo1Mammal1;
 	Mammal zoo1Mammal2;
 	Human zoo2Director1;
 	Human zoo2Director2;
 
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 				"hql/Animal.hbm.xml",
 		};
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.USE_QUERY_CACHE, "false" );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 		cfg.setProperty( Environment.QUERY_TRANSLATOR, ASTQueryTranslatorFactory.class.getName() );
 	}
 
 	private void createData() {
 		stateProvince = new StateProvince();
 		stateProvince.setName( "IL" );
 
 	    zoo1 = new Zoo();
 		zoo1.setName( "Zoo" );
 		Address address1 = new Address();
 		address1.setStreet( "1313 Mockingbird Lane" );
 		address1.setCity( "Anywhere" );
 		address1.setStateProvince( stateProvince );
 		address1.setCountry( "USA" );
 		zoo1.setAddress( address1 );
 		zoo1Mammal1 = new Mammal();
 		zoo1Mammal1.setDescription( "zoo1Mammal1" );
 		zoo1Mammal1.setZoo( zoo1 );
 		zoo1.getMammals().put( "type1", zoo1Mammal1);
 		zoo1Mammal2 = new Mammal();
 		zoo1Mammal2.setDescription( "zoo1Mammal2" );
 		zoo1Mammal2.setZoo( zoo1 );
 		zoo1.getMammals().put( "type1", zoo1Mammal2);
 
 		zoo2 = new Zoo();
 		zoo2.setName( "A Zoo" );
 		Address address2 = new Address();
 		address2.setStreet( "1313 Mockingbird Lane" );
 		address2.setCity( "Anywhere" );
 		address2.setStateProvince( stateProvince );
 		address2.setCountry( "USA" );
 		zoo2.setAddress( address2 );
 		zoo2Director1 = new Human();
 		zoo2Director1.setName( new Name( "Duh", 'A', "Man" ) );
 		zoo2Director2 = new Human();
 		zoo2Director2.setName( new Name( "Fat", 'A', "Cat" ) );
 		zoo2.getDirectors().put( "Head Honcho", zoo2Director1 );
 		zoo2.getDirectors().put( "Asst. Head Honcho", zoo2Director2 );		
 
 		zoo3 = new Zoo();
 		zoo3.setName( "Zoo" );
 		Address address3 = new Address();
 		address3.setStreet( "1312 Mockingbird Lane" );
 		address3.setCity( "Anywhere" );
 		address3.setStateProvince( stateProvince );
 		address3.setCountry( "USA" );
 		zoo3.setAddress( address3 );
 
 		zoo4 = new Zoo();
 		zoo4.setName( "Duh Zoo" );
 		Address address4 = new Address();
 		address4.setStreet( "1312 Mockingbird Lane" );
 		address4.setCity( "Nowhere" );
 		address4.setStateProvince( stateProvince );
 		address4.setCountry( "USA" );
 		zoo4.setAddress( address4 );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.save( stateProvince );
 		s.save( zoo1Mammal1 );
 		s.save( zoo1Mammal2 );
 		s.save( zoo1 );
 		s.save( zoo2Director1 );
 		s.save( zoo2Director2 );
 		s.save( zoo2 );
 		s.save( zoo3 );
 		s.save( zoo4 );
 		t.commit();
 		s.close();
 
 		zoosWithSameName = new HashSet<Zoo>( 2 );
 		zoosWithSameName.add( zoo1 );
 		zoosWithSameName.add( zoo3 );
 		zoosWithSameAddress = new HashSet<Zoo>( 2 );
 		zoosWithSameAddress.add( zoo1 );
 		zoosWithSameAddress.add( zoo2 );
 	}
 
 	private void cleanupData() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		if ( zoo1 != null ) {
 			s.delete( zoo1 );
 			zoo1 = null;
 		}
 		if ( zoo2 != null ) {
 			s.delete( zoo2 );
 			zoo2 = null;
 		}
 		if ( zoo3 != null ) {
 			s.delete( zoo3 );
 			zoo3 = null;
 		}
 		if ( zoo4 != null ) {
 			s.delete( zoo4 );
 			zoo4 = null;
 		}
 		if ( zoo1Mammal1 != null ) {
 			s.delete( zoo1Mammal1 );
 			zoo1Mammal1 = null;
 		}
 		if ( zoo1Mammal2 != null ) {
 			s.delete( zoo1Mammal2 );
 			zoo1Mammal2 = null;
 		}
 		if ( zoo2Director1 != null ) {
 			s.delete( zoo2Director1 );
 			zoo2Director1 = null;
 		}
 		if ( zoo2Director2 != null ) {
 			s.delete( zoo2Director2 );
 			zoo2Director2 = null;			
 		}
 		if ( stateProvince != null ) {
 			s.delete( stateProvince );
 		}
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testOrderByNoSelectAliasRef() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by name, address:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select name, address from Zoo order by name, address"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address from Zoo z order by z.name, z.address"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z2.name, z2.address from Zoo z2 where z2.name in ( select name from Zoo ) order by z2.name, z2.address"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		// using ASC
 		checkTestOrderByResults(
 				s.createQuery(
 						"select name, address from Zoo order by name ASC, address ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address from Zoo z order by z.name ASC, z.address ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z2.name, z2.address from Zoo z2 where z2.name in ( select name from Zoo ) order by z2.name ASC, z2.address ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 
 		// ordered by address, name:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address from Zoo z order by z.address, z.name"
 				).list(),
 				zoo3, zoo4, zoo2, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select name, address from Zoo order by address, name"
 				).list(),
 				zoo3, zoo4, zoo2, zoo1, null
 		);
 
 		// ordered by address:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		// unordered:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address from Zoo z order by z.address"
 				).list(),
 				zoo3, zoo4, null, null, zoosWithSameAddress
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select name, address from Zoo order by address"
 				).list(),
 				zoo3, zoo4, null, null, zoosWithSameAddress
 		);
 
 		// ordered by name:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		// unordered:
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address from Zoo z order by z.name"
 				).list(),
 				zoo2, zoo4, null, null, zoosWithSameName
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select name, address from Zoo order by name"
 				).list(),
 				zoo2, zoo4, null, null, zoosWithSameName
 		);
 		t.commit();
 		s.close();
 
 		cleanupData();
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "unknown" )
 	public void testOrderByComponentDescNoSelectAliasRef() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by address DESC, name DESC:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address from Zoo z order by z.address DESC, z.name DESC"
 				).list(),
 				zoo1, zoo2, zoo4, zoo3, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select name, address from Zoo order by address DESC, name DESC"
 				).list(),
 				zoo1, zoo2, zoo4, zoo3, null
 		);
 		t.commit();
 		s.close();
 		cleanupData();
 	}
 
 	@Test
 	public void testOrderBySelectAliasRef() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by name, address:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z2.name as zname, z2.address as zooAddress from Zoo z2 where z2.name in ( select name from Zoo ) order by zname, zooAddress"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as name, z.address as address from Zoo z order by name, address"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as zooName, z.address as zooAddress from Zoo z order by zooName, zooAddress"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address as name from Zoo z order by z.name, name"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address as name from Zoo z order by z.name, name"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		// using ASC
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z2.name as zname, z2.address as zooAddress from Zoo z2 where z2.name in ( select name from Zoo ) order by zname ASC, zooAddress ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as name, z.address as address from Zoo z order by name ASC, address ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as zooName, z.address as zooAddress from Zoo z order by zooName ASC, zooAddress ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address as name from Zoo z order by z.name ASC, name ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address as name from Zoo z order by z.name ASC, name ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 
 		// ordered by address, name:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as address, z.address as name from Zoo z order by name, address"
 				).list(),
 				zoo3, zoo4, zoo2, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address as name from Zoo z order by name, z.name"
 				).list(),
 				zoo3, zoo4, zoo2, zoo1, null
 		);
 		// using ASC
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as address, z.address as name from Zoo z order by name ASC, address ASC"
 				).list(),
 				zoo3, zoo4, zoo2, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address as name from Zoo z order by name ASC, z.name ASC"
 				).list(),
 				zoo3, zoo4, zoo2, zoo1, null
 		);
 
 		// ordered by address:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		// unordered:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as zooName, z.address as zooAddress from Zoo z order by zooAddress"
 				).list(),
 				zoo3, zoo4, null, null, zoosWithSameAddress
 		);
 
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as zooName, z.address as name from Zoo z order by name"
 				).list(),
 				zoo3, zoo4, null, null, zoosWithSameAddress
 		);
 
 		// ordered by name:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		// unordered:
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as zooName, z.address as zooAddress from Zoo z order by zooName"
 				).list(),
 				zoo2, zoo4, null, null, zoosWithSameName
 		);
 
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as address, z.address as name from Zoo z order by address"
 				).list(),
 				zoo2, zoo4, null, null, zoosWithSameName
 		);
 		t.commit();
 		s.close();
 
 		cleanupData();
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "unknown")
 	public void testOrderByComponentDescSelectAliasRefFailureExpected() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by address desc, name desc:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		// using DESC
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as zooName, z.address as zooAddress from Zoo z order by zooAddress DESC, zooName DESC"
 				).list(),
 				zoo1, zoo2, zoo4, zoo3, null
 		);
 
 		t.commit();
 		s.close();
 
 		cleanupData();
 	}
 
 	@Test
 	public void testOrderByEntityWithFetchJoinedCollection() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by address desc, name desc:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		// using DESC
 		List list = s.createQuery( "from Zoo z join fetch z.mammals" ).list();
 
 		t.commit();
 		s.close();
 
 		cleanupData();
 	}
 
 	@Test
 	public void testOrderBySelectNewArgAliasRef() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by name, address:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		List list =
 				s.createQuery(
 						"select new Zoo( z.name as zname, z.address as zaddress) from Zoo z order by zname, zaddress"
 				).list();
 		assertEquals( 4, list.size() );
 		assertEquals( zoo2, list.get( 0 ) );
 		assertEquals( zoo4, list.get( 1 ) );
 		assertEquals( zoo3, list.get( 2 ) );
 		assertEquals( zoo1, list.get( 3 ) );
 
 		// ordered by address, name:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		list =
 				s.createQuery(
 						"select new Zoo( z.name as zname, z.address as zaddress) from Zoo z order by zaddress, zname"
 				).list();
 		assertEquals( 4, list.size() );
 		assertEquals( zoo3, list.get( 0 ) );
 		assertEquals( zoo4, list.get( 1 ) );
 		assertEquals( zoo2, list.get( 2 ) );
 		assertEquals( zoo1, list.get( 3 ) );
 
 
 		t.commit();
 		s.close();
 
 		cleanupData();
 	}
 
 	@Test
 	public void testOrderBySelectNewMapArgAliasRef() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by name, address:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		List list =
 				s.createQuery(
 						"select new map( z.name as zname, z.address as zaddress ) from Zoo z left join z.mammals m order by zname, zaddress"
 				).list();
 		assertEquals( 4, list.size() );
 		assertEquals( zoo2.getName(), ( ( Map ) list.get( 0 ) ).get( "zname" ) );
 		assertEquals( zoo2.getAddress(), ( ( Map ) list.get( 0 ) ).get( "zaddress" ) );
 		assertEquals( zoo4.getName(), ( ( Map ) list.get( 1 ) ).get( "zname" ) );
 		assertEquals( zoo4.getAddress(), ( ( Map ) list.get( 1 ) ).get( "zaddress" ) );
 		assertEquals( zoo3.getName(), ( ( Map ) list.get( 2 ) ).get( "zname" ) );
 		assertEquals( zoo3.getAddress(), ( ( Map ) list.get( 2 ) ).get( "zaddress" ) );
 		assertEquals( zoo1.getName(), ( ( Map ) list.get( 3 ) ).get( "zname" ) );
 		assertEquals( zoo1.getAddress(), ( ( Map ) list.get( 3 ) ).get( "zaddress" ) );
 
 		// ordered by address, name:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		list =
 				s.createQuery(
 						"select new map( z.name as zname, z.address as zaddress ) from Zoo z left join z.mammals m order by zaddress, zname"
 				).list();
 		assertEquals( 4, list.size() );
 		assertEquals( zoo3.getName(), ( ( Map ) list.get( 0 ) ).get( "zname" ) );
 		assertEquals( zoo3.getAddress(), ( ( Map ) list.get( 0 ) ).get( "zaddress" ) );
 		assertEquals( zoo4.getName(), ( ( Map ) list.get( 1 ) ).get( "zname" ) );
 		assertEquals( zoo4.getAddress(), ( ( Map ) list.get( 1 ) ).get( "zaddress" ) );
 		assertEquals( zoo2.getName(), ( ( Map ) list.get( 2 ) ).get( "zname" ) );
 		assertEquals( zoo2.getAddress(), ( ( Map ) list.get( 2 ) ).get( "zaddress" ) );
 		assertEquals( zoo1.getName(), ( ( Map ) list.get( 3 ) ).get( "zname" ) );
 		assertEquals( zoo1.getAddress(), ( ( Map ) list.get( 3 ) ).get( "zaddress" ) );
 		t.commit();
 		s.close();
 
 		cleanupData();
 	}
 
 	@Test
 	public void testOrderByAggregatedArgAliasRef() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by name, address:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		List list =
 				s.createQuery(
 						"select z.name as zname, count(*) as cnt from Zoo z group by z.name order by cnt desc, zname"
 				).list();
 		assertEquals( 3, list.size() );
 		assertEquals( zoo3.getName(), ( ( Object[] ) list.get( 0 ) )[ 0 ] );
 		assertEquals( Long.valueOf( 2 ), ( ( Object[] ) list.get( 0 ) )[ 1 ] );
 		assertEquals( zoo2.getName(), ( ( Object[] ) list.get( 1 ) )[ 0 ] );
 		assertEquals( Long.valueOf( 1 ), ( ( Object[] ) list.get( 1 ) )[ 1 ] );
 		assertEquals( zoo4.getName(), ( ( Object[] ) list.get( 2 ) )[ 0 ] );
 		assertEquals( Long.valueOf( 1 ), ( ( Object[] ) list.get( 2 ) )[ 1 ] );
 		t.commit();
 		s.close();
 		cleanupData();
 	}
 
 	private void checkTestOrderByResults(
 			List results,
 			Zoo zoo1,
 			Zoo zoo2,
 			Zoo zoo3,
 			Zoo zoo4,
 			Set<Zoo> zoosUnordered) {
 		assertEquals( 4, results.size() );
 		Set<Zoo> zoosUnorderedCopy = ( zoosUnordered == null ? null : new HashSet<Zoo>( zoosUnordered ) );
 		checkTestOrderByResult( results.get( 0 ), zoo1, zoosUnorderedCopy );
 		checkTestOrderByResult( results.get( 1 ), zoo2, zoosUnorderedCopy );
 		checkTestOrderByResult( results.get( 2 ), zoo3, zoosUnorderedCopy );
 		checkTestOrderByResult( results.get( 3 ), zoo4, zoosUnorderedCopy );
 		if ( zoosUnorderedCopy != null ) {
 			assertTrue( zoosUnorderedCopy.isEmpty() );
 		}
 	}
 
 	private void checkTestOrderByResult(Object result,
 										Zoo zooExpected,
 										Set<Zoo> zoosUnordered) {
 		assertTrue( result instanceof Object[] );
 		Object[] resultArray = ( Object[] ) result;
 		assertEquals( 2,  resultArray.length );
 		Hibernate.initialize( ( ( Address ) resultArray[ 1 ] ).getStateProvince() );
 		if ( zooExpected == null ) {
 			Zoo zooResult = new Zoo();
 			zooResult.setName( ( String ) resultArray[ 0 ] );
 			zooResult.setAddress( ( Address ) resultArray[ 1 ] );
 			assertTrue( zoosUnordered.remove( zooResult ) );
 		}
 		else {
 			assertEquals( zooExpected.getName(), ( ( Object[] ) result )[ 0 ] );
 			assertEquals( zooExpected.getAddress(), ( ( Object[] ) result )[ 1 ] );
 		}
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingTest.java
index 2432bd9931..a10813e79b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingTest.java
@@ -1,1061 +1,1061 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.sql.Date;
 import java.sql.Time;
 import java.sql.Timestamp;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.Hibernate;
 import org.hibernate.HibernateException;
 import org.hibernate.Query;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.TypeMismatchException;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.DB2Dialect;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.IngresDialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.Oracle8iDialect;
 import org.hibernate.dialect.PostgreSQLDialect;
 import org.hibernate.dialect.SQLServerDialect;
 import org.hibernate.dialect.Sybase11Dialect;
 import org.hibernate.dialect.SybaseASE15Dialect;
 import org.hibernate.dialect.SybaseAnywhereDialect;
 import org.hibernate.dialect.SybaseDialect;
-import org.hibernate.hql.ast.ASTQueryTranslatorFactory;
+import org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.persister.entity.DiscriminatorType;
 import org.hibernate.stat.QueryStatistics;
 import org.hibernate.transform.DistinctRootEntityResultTransformer;
 import org.hibernate.transform.Transformers;
 import org.hibernate.type.ComponentType;
 import org.hibernate.type.ManyToOneType;
 import org.hibernate.type.Type;
 
 import org.junit.Test;
 
 import org.hibernate.testing.DialectChecks;
 import org.hibernate.testing.FailureExpected;
 import org.hibernate.testing.RequiresDialectFeature;
 import org.hibernate.testing.SkipForDialect;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.hibernate.test.any.IntegerPropertyValue;
 import org.hibernate.test.any.PropertySet;
 import org.hibernate.test.any.PropertyValue;
 import org.hibernate.test.any.StringPropertyValue;
 import org.hibernate.test.cid.Customer;
 import org.hibernate.test.cid.LineItem;
 import org.hibernate.test.cid.LineItem.Id;
 import org.hibernate.test.cid.Order;
 import org.hibernate.test.cid.Product;
 
 import static org.hibernate.testing.junit4.ExtraAssertions.assertClassAssignability;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * Tests the integration of the new AST parser into the loading of query results using
  * the Hibernate persisters and loaders.
  * <p/>
  * Also used to test the syntax of the resulting sql against the underlying
  * database, specifically for functionality not supported by the classic
  * parser.
  *
  * @author Steve
  */
 public class ASTParserLoadingTest extends BaseCoreFunctionalTestCase {
 	private static final Logger log = Logger.getLogger( ASTParserLoadingTest.class );
 
 	private List<Long> createdAnimalIds = new ArrayList<Long>();
 
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 				"hql/Animal.hbm.xml",
 				"hql/FooBarCopy.hbm.xml",
 				"hql/SimpleEntityWithAssociation.hbm.xml",
 				"hql/CrazyIdFieldNames.hbm.xml",
 				"hql/Image.hbm.xml",
 				"hql/ComponentContainer.hbm.xml",
 				"hql/VariousKeywordPropertyEntity.hbm.xml",
 				"batchfetch/ProductLine.hbm.xml",
 				"cid/Customer.hbm.xml",
 				"cid/Order.hbm.xml",
 				"cid/LineItem.hbm.xml",
 				"cid/Product.hbm.xml",
 				"any/Properties.hbm.xml",
 				"legacy/Commento.hbm.xml",
 				"legacy/Marelo.hbm.xml"
 		};
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.USE_QUERY_CACHE, "true" );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 		cfg.setProperty( Environment.QUERY_TRANSLATOR, ASTQueryTranslatorFactory.class.getName() );
 	}
 
 	@Test
 	public void testSubSelectAsArithmeticOperand() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		// first a control
 		s.createQuery( "from Zoo z where ( select count(*) from Zoo ) = 0" ).list();
 
 		// now as operands singly:
 		s.createQuery( "from Zoo z where ( select count(*) from Zoo ) + 0 = 0" ).list();
 		s.createQuery( "from Zoo z where 0 + ( select count(*) from Zoo ) = 0" ).list();
 
 		// and doubly:
 		s.createQuery( "from Zoo z where ( select count(*) from Zoo ) + ( select count(*) from Zoo ) = 0" ).list();
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testJpaTypeOperator() {
 		// just checking syntax here...
 		Session s = openSession();
 		s.beginTransaction();
 
 		///////////////////////////////////////////////////////////////
 		// where clause
 		// control
 		s.createQuery( "from Animal a where a.class = Dog" ).list();
         // test
 		s.createQuery( "from Animal a where type(a) = Dog" ).list();
 
 		///////////////////////////////////////////////////////////////
 		// select clause (at some point we should unify these)
 		// control
 		Query query = s.createQuery( "select a.class from Animal a where a.class = Dog" );
 		query.list(); // checks syntax
 		assertEquals( 1, query.getReturnTypes().length );
 		assertEquals( Integer.class, query.getReturnTypes()[0].getReturnedClass() ); // always integer for joined
         // test
 		query = s.createQuery( "select type(a) from Animal a where type(a) = Dog" );
 		query.list(); // checks syntax
 		assertEquals( 1, query.getReturnTypes().length );
 		assertEquals( DiscriminatorType.class, query.getReturnTypes()[0].getClass() );
 		assertEquals( Class.class, query.getReturnTypes()[0].getReturnedClass() );
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testComponentJoins() {
 		Session s = openSession();
 		s.beginTransaction();
 		ComponentContainer root = new ComponentContainer(
 				new ComponentContainer.Address(
 						"123 Main",
 						"Anywhere",
 						"USA",
 						new ComponentContainer.Address.Zip( 12345, 6789 )
 				)
 		);
 		s.save( root );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List result = s.createQuery( "select a from ComponentContainer c join c.address a" ).list();
 		assertEquals( 1, result.size() );
 		assertTrue( ComponentContainer.Address.class.isInstance( result.get( 0 ) ) );
 
 		result = s.createQuery( "select a.zip from ComponentContainer c join c.address a" ).list();
 		assertEquals( 1, result.size() );
 		assertTrue( ComponentContainer.Address.Zip.class.isInstance( result.get( 0 ) ) );
 
 		result = s.createQuery( "select z from ComponentContainer c join c.address a join a.zip z" ).list();
 		assertEquals( 1, result.size() );
 		assertTrue( ComponentContainer.Address.Zip.class.isInstance( result.get( 0 ) ) );
 
 		result = s.createQuery( "select z.code from ComponentContainer c join c.address a join a.zip z" ).list();
 		assertEquals( 1, result.size() );
 		assertTrue( Integer.class.isInstance( result.get( 0 ) ) );
 		s.delete( root );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testJPAQLQualifiedIdentificationVariablesControl() {
 		// just checking syntax here...
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from VariousKeywordPropertyEntity where type = 'something'" ).list();
 		s.createQuery( "from VariousKeywordPropertyEntity where value = 'something'" ).list();
 		s.createQuery( "from VariousKeywordPropertyEntity where key = 'something'" ).list();
 		s.createQuery( "from VariousKeywordPropertyEntity where entry = 'something'" ).list();
 
 		s.createQuery( "from VariousKeywordPropertyEntity e where e.type = 'something'" ).list();
 		s.createQuery( "from VariousKeywordPropertyEntity e where e.value = 'something'" ).list();
 		s.createQuery( "from VariousKeywordPropertyEntity e where e.key = 'something'" ).list();
 		s.createQuery( "from VariousKeywordPropertyEntity e where e.entry = 'something'" ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testJPAQLQualifiedIdentificationVariables() {
 		Session s = openSession();
 		s.beginTransaction();
 		Human me = new Human();
 		me.setName( new Name( "Steve", null, "Ebersole" ) );
 		Human joe = new Human();
 		me.setName( new Name( "Joe", null, "Ebersole" ) );
 		me.setFamily( new HashMap() );
 		me.getFamily().put( "son", joe );
 		s.save( me );
 		s.save( joe );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List results = s.createQuery( "select entry(h.family) from Human h" ).list();
 		assertEquals( 1, results.size() );
 		Object result = results.get(0);
 		assertTrue( Map.Entry.class.isAssignableFrom( result.getClass() ) );
 		Map.Entry entry = (Map.Entry) result;
 		assertTrue( String.class.isAssignableFrom( entry.getKey().getClass() ) );
 		assertTrue( Human.class.isAssignableFrom( entry.getValue().getClass() ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		results = s.createQuery( "select distinct key(h.family) from Human h" ).list();
 		assertEquals( 1, results.size() );
 		Object key = results.get(0);
 		assertTrue( String.class.isAssignableFrom( key.getClass() ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( me );
 		s.delete( joe );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@SkipForDialect(
 			value = IngresDialect.class,
 			jiraKey = "HHH-4961",
 			comment = "Ingres does not support this scoping in 9.3"
 	)
 	public void testPaginationWithPolymorphicQuery() {
 		Session s = openSession();
 		s.beginTransaction();
 		Human h = new Human();
 		h.setName( new Name( "Steve", null, "Ebersole" ) );
 		s.save( h );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List results = s.createQuery( "from java.lang.Object" ).setMaxResults( 2 ).list();
 		assertEquals( 1, results.size() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( h );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testComponentNullnessChecks() {
 		Session s = openSession();
 		s.beginTransaction();
 		Human h = new Human();
 		h.setName( new Name( "Johnny", 'B', "Goode" ) );
 		s.save( h );
 		h = new Human();
 		h.setName( new Name( "Steve", null, "Ebersole" ) );
 		s.save( h );
 		h = new Human();
 		h.setName( new Name( "Bono", null, null ) );
 		s.save( h );
 		h = new Human();
 		h.setName( new Name( null, null, null ) );
 		s.save( h );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List results = s.createQuery( "from Human where name is null" ).list();
 		assertEquals( 1, results.size() );
 		results = s.createQuery( "from Human where name is not null" ).list();
 		assertEquals( 3, results.size() );
 		String query =
 				( getDialect() instanceof DB2Dialect || getDialect() instanceof HSQLDialect ) ?
 						"from Human where cast(? as string) is null" :
 						"from Human where ? is null"
 				;
 		s.createQuery( query ).setParameter( 0, null ).list();
 
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete Human" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testInvalidCollectionDereferencesFail() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		// control group...
 		s.createQuery( "from Animal a join a.offspring o where o.description = 'xyz'" ).list();
 		s.createQuery( "from Animal a join a.offspring o where o.father.description = 'xyz'" ).list();
 		s.createQuery( "from Animal a join a.offspring o order by o.description" ).list();
 		s.createQuery( "from Animal a join a.offspring o order by o.father.description" ).list();
 
 		try {
 			s.createQuery( "from Animal a where a.offspring.description = 'xyz'" ).list();
 			fail( "illegal collection dereference semantic did not cause failure" );
 		}
 		catch( QueryException qe ) {
             log.trace("expected failure...", qe);
 		}
 
 		try {
 			s.createQuery( "from Animal a where a.offspring.father.description = 'xyz'" ).list();
 			fail( "illegal collection dereference semantic did not cause failure" );
 		}
 		catch( QueryException qe ) {
             log.trace("expected failure...", qe);
 		}
 
 		try {
 			s.createQuery( "from Animal a order by a.offspring.description" ).list();
 			fail( "illegal collection dereference semantic did not cause failure" );
 		}
 		catch( QueryException qe ) {
             log.trace("expected failure...", qe);
 		}
 
 		try {
 			s.createQuery( "from Animal a order by a.offspring.father.description" ).list();
 			fail( "illegal collection dereference semantic did not cause failure" );
 		}
 		catch( QueryException qe ) {
             log.trace("expected failure...", qe);
 		}
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testConcatenation() {
 		// simple syntax checking...
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Human h where h.nickName = '1' || 'ov' || 'tha' || 'few'" ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testExpressionWithParamInFunction() {
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Animal a where abs(a.bodyWeight-:param) < 2.0" ).setLong( "param", 1 ).list();
 		s.createQuery( "from Animal a where abs(:param - a.bodyWeight) < 2.0" ).setLong( "param", 1 ).list();
 		if ( ( getDialect() instanceof HSQLDialect ) || ( getDialect() instanceof DB2Dialect ) ) {
 			// HSQLDB and DB2 don't like the abs(? - ?) syntax. bit work if at least one parameter is typed...
 			s.createQuery( "from Animal where abs(cast(:x as long) - :y) < 2.0" ).setLong( "x", 1 ).setLong( "y", 1 ).list();
 			s.createQuery( "from Animal where abs(:x - cast(:y as long)) < 2.0" ).setLong( "x", 1 ).setLong( "y", 1 ).list();
 			s.createQuery( "from Animal where abs(cast(:x as long) - cast(:y as long)) < 2.0" ).setLong( "x", 1 ).setLong( "y", 1 ).list();
 		}
 		else {
 			s.createQuery( "from Animal where abs(:x - :y) < 2.0" ).setLong( "x", 1 ).setLong( "y", 1 ).list();
 		}
 
 		if ( getDialect() instanceof DB2Dialect ) {
 			s.createQuery( "from Animal where lower(upper(cast(:foo as string))) like 'f%'" ).setString( "foo", "foo" ).list();
 		}
 		else {
 			s.createQuery( "from Animal where lower(upper(:foo)) like 'f%'" ).setString( "foo", "foo" ).list();
 		}
 		s.createQuery( "from Animal a where abs(abs(a.bodyWeight - 1.0 + :param) * abs(length('ffobar')-3)) = 3.0" ).setLong(
 				"param", 1
 		).list();
 		if ( getDialect() instanceof DB2Dialect ) {
 			s.createQuery( "from Animal where lower(upper('foo') || upper(cast(:bar as string))) like 'f%'" ).setString( "bar", "xyz" ).list();
 		}
 		else {
 			s.createQuery( "from Animal where lower(upper('foo') || upper(:bar)) like 'f%'" ).setString( "bar", "xyz" ).list();
 		}
 		if ( ! ( getDialect() instanceof PostgreSQLDialect || getDialect() instanceof MySQLDialect ) ) {
 			s.createQuery( "from Animal where abs(cast(1 as float) - cast(:param as float)) = 1.0" ).setLong( "param", 1 ).list();
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCrazyIdFieldNames() {
 		MoreCrazyIdFieldNameStuffEntity top = new MoreCrazyIdFieldNameStuffEntity( "top" );
 		HeresAnotherCrazyIdFieldName next = new HeresAnotherCrazyIdFieldName( "next" );
 		top.setHeresAnotherCrazyIdFieldName( next );
 		MoreCrazyIdFieldNameStuffEntity other = new MoreCrazyIdFieldNameStuffEntity( "other" );
 		Session s = openSession();
 		s.beginTransaction();
 		s.save( next );
 		s.save( top );
 		s.save( other );
 		s.flush();
 
 		List results = s.createQuery( "select e.heresAnotherCrazyIdFieldName from MoreCrazyIdFieldNameStuffEntity e where e.heresAnotherCrazyIdFieldName is not null" ).list();
 		assertEquals( 1, results.size() );
 		Object result = results.get( 0 );
 		assertClassAssignability( HeresAnotherCrazyIdFieldName.class, result.getClass() );
 		assertSame( next, result );
 
 		results = s.createQuery( "select e.heresAnotherCrazyIdFieldName.heresAnotherCrazyIdFieldName from MoreCrazyIdFieldNameStuffEntity e where e.heresAnotherCrazyIdFieldName is not null" ).list();
 		assertEquals( 1, results.size() );
 		result = results.get( 0 );
 		assertClassAssignability( Long.class, result.getClass() );
 		assertEquals( next.getHeresAnotherCrazyIdFieldName(), result );
 
 		results = s.createQuery( "select e.heresAnotherCrazyIdFieldName from MoreCrazyIdFieldNameStuffEntity e" ).list();
 		assertEquals( 1, results.size() );
 		Iterator itr = s.createQuery( "select e.heresAnotherCrazyIdFieldName from MoreCrazyIdFieldNameStuffEntity e" ).iterate();
 		assertTrue( itr.hasNext() ); itr.next(); assertFalse( itr.hasNext() );
 
 		s.delete( top );
 		s.delete( next );
 		s.delete( other );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-2257" )
 	public void testImplicitJoinsInDifferentClauses() {
 		// both the classic and ast translators output the same syntactically valid sql
 		// for all of these cases; the issue is that shallow (iterate) and
 		// non-shallow (list/scroll) queries return different results because the
 		// shallow skips the inner join which "weeds out" results from the non-shallow queries.
 		// The results were initially different depending upon the clause(s) in which the
 		// implicit join occurred
 		Session s = openSession();
 		s.beginTransaction();
 		SimpleEntityWithAssociation owner = new SimpleEntityWithAssociation( "owner" );
 		SimpleAssociatedEntity e1 = new SimpleAssociatedEntity( "thing one", owner );
 		SimpleAssociatedEntity e2 = new SimpleAssociatedEntity( "thing two" );
 		s.save( e1 );
 		s.save( e2 );
 		s.save( owner );
 		s.getTransaction().commit();
 		s.close();
 
 		checkCounts( "select e.owner from SimpleAssociatedEntity e", 1, "implicit-join in select clause" );
 		checkCounts( "select e.id, e.owner from SimpleAssociatedEntity e", 1, "implicit-join in select clause" );
 
 		// resolved to a "id short cut" when part of the order by clause -> no inner join = no weeding out...
 		checkCounts( "from SimpleAssociatedEntity e order by e.owner", 2, "implicit-join in order-by clause" );
 		// resolved to a "id short cut" when part of the group by clause -> no inner join = no weeding out...
 		checkCounts( "select e.owner.id, count(*) from SimpleAssociatedEntity e group by e.owner", 2, "implicit-join in select and group-by clauses" );
 
 	 	s = openSession();
 		s.beginTransaction();
 		s.delete( e1 );
 		s.delete( e2 );
 		s.delete( owner );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testRowValueConstructorSyntaxInInList() {
 		Session s = openSession();
 		s.beginTransaction();
 		Product product = new Product();
 		product.setDescription( "My Product" );
 		product.setNumberAvailable( 10 );
 		product.setPrice( new BigDecimal( 123 ) );
 		product.setProductId( "4321" );
 		s.save( product );
 
 
 		Customer customer = new Customer();
 		customer.setCustomerId( "123456789" );
 		customer.setName( "My customer" );
 		customer.setAddress( "somewhere" );
 		s.save( customer );
 
 		Order order = customer.generateNewOrder( new BigDecimal( 1234 ) );
 		s.save( order );
 
 		LineItem li = order.generateLineItem( product, 5 );
 		s.save( li );
 		product = new Product();
 		product.setDescription( "My Product" );
 		product.setNumberAvailable( 10 );
 		product.setPrice( new BigDecimal( 123 ) );
 		product.setProductId( "1234" );
 		s.save( product );
 		li = order.generateLineItem( product, 10 );
 		s.save( li );
 
 		s.flush();
 		Query query = s.createQuery( "from LineItem l where l.id in (:idList)" );
 		List<Id> list = new ArrayList<Id>();
 		list.add( new Id( "123456789", order.getId().getOrderNumber(), "4321" ) );
 		list.add( new Id( "123456789", order.getId().getOrderNumber(), "1234" ) );
 		query.setParameterList( "idList", list );
 		assertEquals( 2, query.list().size() );
 
 		query = s.createQuery( "from LineItem l where l.id in :idList" );
 		query.setParameterList( "idList", list );
 		assertEquals( 2, query.list().size() );
 
 		s.getTransaction().rollback();
 		s.close();
 
 	}
 
 	private void checkCounts(String hql, int expected, String testCondition) {
 		Session s = openSession();
 		s.beginTransaction();
 		int count = determineCount( s.createQuery( hql ).list().iterator() );
 		assertEquals( "list() [" + testCondition + "]", expected, count );
 		count = determineCount( s.createQuery( hql ).iterate() );
 		assertEquals( "iterate() [" + testCondition + "]", expected, count );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-2257" )
 	public void testImplicitSelectEntityAssociationInShallowQuery() {
 		// both the classic and ast translators output the same syntactically valid sql.
 		// the issue is that shallow and non-shallow queries return different
 		// results because the shallow skips the inner join which "weeds out" results
 		// from the non-shallow queries...
 		Session s = openSession();
 		s.beginTransaction();
 		SimpleEntityWithAssociation owner = new SimpleEntityWithAssociation( "owner" );
 		SimpleAssociatedEntity e1 = new SimpleAssociatedEntity( "thing one", owner );
 		SimpleAssociatedEntity e2 = new SimpleAssociatedEntity( "thing two" );
 		s.save( e1 );
 		s.save( e2 );
 		s.save( owner );
 		s.getTransaction().commit();
 		s.close();
 
 	 	s = openSession();
 		s.beginTransaction();
 		int count = determineCount( s.createQuery( "select e.id, e.owner from SimpleAssociatedEntity e" ).list().iterator() );
 		assertEquals( 1, count ); // thing two would be removed from the result due to the inner join
 		count = determineCount( s.createQuery( "select e.id, e.owner from SimpleAssociatedEntity e" ).iterate() );
 		assertEquals( 1, count );
 		s.getTransaction().commit();
 		s.close();
 
 	 	s = openSession();
 		s.beginTransaction();
 		s.delete( e1 );
 		s.delete( e2 );
 		s.delete( owner );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	private int determineCount(Iterator iterator) {
 		int count = 0;
 		while( iterator.hasNext() ) {
 			count++;
 			iterator.next();
 		}
 		return count;
 	}
 
 	@Test
 	public void testEntityAndOneToOneReturnedByQuery() {
 		Session s = openSession();
 		s.beginTransaction();
 		Human h = new Human();
 		h.setName( new Name( "Gail", null, "Badner" ) );
 		s.save( h );
 		User u = new User();
 		u.setUserName( "gbadner" );
 		u.setHuman( h );
 		s.save( u );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Object [] result = ( Object [] ) s.createQuery( "from User u, Human h where u.human = h" ).uniqueResult();
 		assertNotNull( result );
 		assertEquals( u.getUserName(), ( ( User ) result[ 0 ] ).getUserName() );
 		assertEquals( h.getName().getFirst(), ((Human) result[1]).getName().getFirst() );
 		assertSame( ((User) result[0]).getHuman(), result[1] );
 		s.createQuery( "delete User" ).executeUpdate();
 		s.createQuery( "delete Human" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNestedComponentIsNull() {
 		// (1) From MapTest originally...
 		// (2) Was then moved into HQLTest...
 		// (3) However, a bug fix to EntityType#getIdentifierOrUniqueKeyType (HHH-2138)
 		// 		caused the classic parser to suddenly start throwing exceptions on
 		//		this query, apparently relying on the buggy behavior somehow; thus
 		//		moved here to at least get some syntax checking...
 		//
 		// fyi... found and fixed the problem in the classic parser; still
 		// leaving here for syntax checking
 		new SyntaxChecker( "from Commento c where c.marelo.commento.mcompr is null" ).checkAll();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-939" )
 	public void testSpecialClassPropertyReference() {
 		// this is a long standing bug in Hibernate when applied to joined-subclasses;
 		//  see HHH-939 for details and history
 		new SyntaxChecker( "from Zoo zoo where zoo.class = PettingZoo" ).checkAll();
 		new SyntaxChecker( "select a.description from Animal a where a.class = Mammal" ).checkAll();
 		new SyntaxChecker( "select a.class from Animal a" ).checkAll();
 		new SyntaxChecker( "from DomesticAnimal an where an.class = Dog" ).checkAll();
 		new SyntaxChecker( "from Animal an where an.class = Dog" ).checkAll();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-2376" )
 	public void testSpecialClassPropertyReferenceFQN() {
 		new SyntaxChecker( "from Zoo zoo where zoo.class = org.hibernate.test.hql.PettingZoo" ).checkAll();
 		new SyntaxChecker( "select a.description from Animal a where a.class = org.hibernate.test.hql.Mammal" ).checkAll();
 		new SyntaxChecker( "from DomesticAnimal an where an.class = org.hibernate.test.hql.Dog" ).checkAll();
 		new SyntaxChecker( "from Animal an where an.class = org.hibernate.test.hql.Dog" ).checkAll();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-1631" )
 	public void testSubclassOrSuperclassPropertyReferenceInJoinedSubclass() {
 		// this is a long standing bug in Hibernate; see HHH-1631 for details and history
 		//
 		// (1) pregnant is defined as a property of the class (Mammal) itself
 		// (2) description is defined as a property of the superclass (Animal)
 		// (3) name is defined as a property of a particular subclass (Human)
 
 		new SyntaxChecker( "from Zoo z join z.mammals as m where m.name.first = 'John'" ).checkIterate();
 
 		new SyntaxChecker( "from Zoo z join z.mammals as m where m.pregnant = false" ).checkAll();
 		new SyntaxChecker( "select m.pregnant from Zoo z join z.mammals as m where m.pregnant = false" ).checkAll();
 
 		new SyntaxChecker( "from Zoo z join z.mammals as m where m.description = 'tabby'" ).checkAll();
 		new SyntaxChecker( "select m.description from Zoo z join z.mammals as m where m.description = 'tabby'" ).checkAll();
 
 		new SyntaxChecker( "from Zoo z join z.mammals as m where m.name.first = 'John'" ).checkAll();
 		new SyntaxChecker( "select m.name from Zoo z join z.mammals as m where m.name.first = 'John'" ).checkAll();
 
 		new SyntaxChecker( "select m.pregnant from Zoo z join z.mammals as m" ).checkAll();
 		new SyntaxChecker( "select m.description from Zoo z join z.mammals as m" ).checkAll();
 		new SyntaxChecker( "select m.name from Zoo z join z.mammals as m" ).checkAll();
 
 		new SyntaxChecker( "from DomesticAnimal da join da.owner as o where o.nickName = 'Gavin'" ).checkAll();
 		new SyntaxChecker( "select da.father from DomesticAnimal da join da.owner as o where o.nickName = 'Gavin'" ).checkAll();
 	}
 
 	@Test
 	@RequiresDialectFeature(
 			value = DialectChecks.SupportLimitAndOffsetCheck.class,
 			comment = "dialect does not support offset and limit combo"
 	)
 	public void testSimpleSelectWithLimitAndOffset() throws Exception {
 		// just checking correctness of param binding code...
 		Session session = openSession();
 		session.createQuery( "from Animal" )
 				.setFirstResult( 2 )
 				.setMaxResults( 1 )
 				.list();
 		session.close();
 	}
 
 	@Test
 	public void testJPAPositionalParameterList() {
 		Session s = openSession();
 		s.beginTransaction();
 		ArrayList<String> params = new ArrayList<String>();
 		params.add( "Doe" );
 		params.add( "Public" );
 		s.createQuery( "from Human where name.last in (?1)" )
 				.setParameterList( "1", params )
 				.list();
 
 		s.createQuery( "from Human where name.last in ?1" )
 				.setParameterList( "1", params )
 				.list();
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testComponentQueries() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		Type[] types = s.createQuery( "select h.name from Human h" ).getReturnTypes();
 		assertEquals( 1, types.length );
 		assertTrue( types[0] instanceof ComponentType );
 
 		// Test the ability to perform comparisons between component values
 		s.createQuery( "from Human h where h.name = h.name" ).list();
 		s.createQuery( "from Human h where h.name = :name" ).setParameter( "name", new Name() ).list();
 		s.createQuery( "from Human where name = :name" ).setParameter( "name", new Name() ).list();
 		s.createQuery( "from Human h where :name = h.name" ).setParameter( "name", new Name() ).list();
 		s.createQuery( "from Human h where :name <> h.name" ).setParameter( "name", new Name() ).list();
 
 		// Test the ability to perform comparisons between a component and an explicit row-value
 		s.createQuery( "from Human h where h.name = ('John', 'X', 'Doe')" ).list();
 		s.createQuery( "from Human h where ('John', 'X', 'Doe') = h.name" ).list();
 		s.createQuery( "from Human h where ('John', 'X', 'Doe') <> h.name" ).list();
 		s.createQuery( "from Human h where ('John', 'X', 'Doe') >= h.name" ).list();
 
 		s.createQuery( "from Human h order by h.name" ).list();
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-1774" )
 	@SkipForDialect(
 			value = IngresDialect.class,
 			comment = "Subselects are not supported within select target lists in Ingres",
 			jiraKey = "HHH-4970"
 	)
 	public void testComponentParameterBinding() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		Order.Id oId = new Order.Id( "1234", 1 );
 
 		// control
 		s.createQuery("from Order o where o.customer.name =:name and o.id = :id")
 				.setParameter( "name", "oracle" )
 				.setParameter( "id", oId )
 				.list();
 
 		// this is the form that caused problems in the original case...
 		s.createQuery("from Order o where o.id = :id and o.customer.name =:name ")
 				.setParameter( "id", oId )
 				.setParameter( "name", "oracle" )
 				.list();
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testAnyMappingReference() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		PropertyValue redValue = new StringPropertyValue( "red" );
 		PropertyValue loneliestNumberValue = new IntegerPropertyValue( 1 );
 
 		Long id;
 		PropertySet ps = new PropertySet( "my properties" );
 		ps.setSomeSpecificProperty( redValue );
 		ps.getGeneralProperties().put( "the loneliest number", loneliestNumberValue );
 		ps.getGeneralProperties().put( "i like", new StringPropertyValue( "pina coladas" ) );
 		ps.getGeneralProperties().put( "i also like", new StringPropertyValue( "getting caught in the rain" ) );
 		s.save( ps );
 
 		s.getTransaction().commit();
 		id = ps.getId();
 		s.clear();
 		s.beginTransaction();
 
 		// TODO : setEntity() currently will not work here, but that would be *very* nice
 		// does not work because the corresponding EntityType is then used as the "bind type" rather
 		// than the "discovered" AnyType...
 		s.createQuery( "from PropertySet p where p.someSpecificProperty = :ssp" ).setParameter( "ssp", redValue ).list();
 
 		s.createQuery( "from PropertySet p where p.someSpecificProperty.id is not null" ).list();
 
 		s.createQuery( "from PropertySet p join p.generalProperties gp where gp.id is not null" ).list();
 
 		s.delete( s.load( PropertySet.class, id ) );
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testJdkEnumStyleEnumConstant() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 
 		s.createQuery( "from Zoo z where z.classification = org.hibernate.test.hql.Classification.LAME" ).list();
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnnecessaryBoxing"})
 	@FailureExpected( jiraKey = "unknown" )
 	public void testParameterTypeMismatch() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		Query query = s.createQuery( "from Animal a where a.description = :nonstring" )
 				.setParameter( "nonstring", Integer.valueOf( 1 ) );
 		try {
 			query.list();
 			fail( "query execution should have failed" );
 		}
 		catch( TypeMismatchException tme ) {
 			// expected behavior
 		}
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testMultipleBagFetchesFail() {
 		Session s = openSession();
 		s.beginTransaction();
 		try {
 			s.createQuery( "from Human h join fetch h.friends f join fetch f.friends fof" ).list();
 			fail( "failure expected" );
 		}
 		catch( HibernateException e ) {
 			assertTrue( "unexpected failure reason : " + e, e.getMessage().indexOf( "multiple bags" ) > 0 );
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-1248" )
 	public void testCollectionJoinsInSubselect() {
 		// HHH-1248 : initially FromElementFactory treated any explicit join
 		// as an implied join so that theta-style joins would always be used.
 		// This was because correlated subqueries cannot use ANSI-style joins
 		// for the correlation.  However, this special treatment was not limited
 		// to only correlated subqueries; it was applied to any subqueries ->
 		// which in-and-of-itself is not necessarily bad.  But somewhere later
 		// the choices made there caused joins to be dropped.
 		Session s = openSession();
 		String qryString =
 				"select a.id, a.description" +
 				" from Animal a" +
 				"       left join a.offspring" +
 				" where a in (" +
 				"       select a1 from Animal a1" +
 				"           left join a1.offspring o" +
 				"       where a1.id=1" +
 		        ")";
 		s.createQuery( qryString ).list();
 		qryString =
 				"select h.id, h.description" +
 		        " from Human h" +
 				"      left join h.friends" +
 				" where h in (" +
 				"      select h1" +
 				"      from Human h1" +
 				"          left join h1.friends f" +
 				"      where h1.id=1" +
 				")";
 		s.createQuery( qryString ).list();
 		qryString =
 				"select h.id, h.description" +
 		        " from Human h" +
 				"      left join h.friends f" +
 				" where f in (" +
 				"      select h1" +
 				"      from Human h1" +
 				"          left join h1.friends f1" +
 				"      where h = f1" +
 				")";
 		s.createQuery( qryString ).list();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionFetchWithDistinctionAndLimit() {
 		// create some test data...
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		int parentCount = 30;
 		for ( int i = 0; i < parentCount; i++ ) {
 			Animal child1 = new Animal();
 			child1.setDescription( "collection fetch distinction (child1 - parent" + i + ")" );
 			s.persist( child1 );
 			Animal child2 = new Animal();
 			child2.setDescription( "collection fetch distinction (child2 - parent " + i + ")" );
 			s.persist( child2 );
 			Animal parent = new Animal();
 			parent.setDescription( "collection fetch distinction (parent" + i + ")" );
 			parent.setSerialNumber( "123-" + i );
 			parent.addOffspring( child1 );
 			parent.addOffspring( child2 );
 			s.persist( parent );
 		}
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		// Test simple distinction
 		List results;
 		results = s.createQuery( "select distinct p from Animal p inner join fetch p.offspring" ).list();
 		assertEquals( "duplicate list() returns", 30, results.size() );
 		// Test first/max
 		results = s.createQuery( "select p from Animal p inner join fetch p.offspring order by p.id" )
 				.setFirstResult( 5 )
 				.setMaxResults( 20 )
 				.list();
 		assertEquals( "duplicate returns", 20, results.size() );
 		Animal firstReturn = ( Animal ) results.get( 0 );
 		assertEquals( "firstResult not applied correctly", "123-5", firstReturn.getSerialNumber() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete Animal where mother is not null" ).executeUpdate();
 		s.createQuery( "delete Animal" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testFetchInSubqueryFails() {
 		Session s = openSession();
 		try {
 			s.createQuery( "from Animal a where a.mother in (select m from Animal a1 inner join a1.mother as m join fetch m.mother)" ).list();
 			fail( "fetch join allowed in subquery" );
 		}
 		catch( QueryException expected ) {
 			// expected behavior
 		}
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-1464" )
 	public void testQueryMetadataRetrievalWithFetching() {
 		// HHH-1464 : there was a problem due to the fact they we polled
 		// the shallow version of the query plan to get the metadata.
 		Session s = openSession();
 		Query query = s.createQuery( "from Animal a inner join fetch a.mother" );
 		assertEquals( 1, query.getReturnTypes().length );
 		assertNull( query.getReturnAliases() );
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-429" )
 	@SuppressWarnings( {"unchecked"})
 	public void testSuperclassPropertyReferenceAfterCollectionIndexedAccess() {
 		// note: simply performing syntax checking in the db
 		Session s = openSession();
 		s.beginTransaction();
 		Mammal tiger = new Mammal();
 		tiger.setDescription( "Tiger" );
 		s.persist( tiger );
 		Mammal mother = new Mammal();
 		mother.setDescription( "Tiger's mother" );
 		mother.setBodyWeight( 4.0f );
 		mother.addOffspring( tiger );
 		s.persist( mother );
 		Zoo zoo = new Zoo();
 		zoo.setName( "Austin Zoo" );
 		zoo.setMammals( new HashMap() );
 		zoo.getMammals().put( "tiger", tiger );
 		s.persist( zoo );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List results = s.createQuery( "from Zoo zoo where zoo.mammals['tiger'].mother.bodyWeight > 3.0f" ).list();
 		assertEquals( 1, results.size() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( tiger );
 		s.delete( mother );
 		s.delete( zoo );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java
index 8475783715..40ff05216c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java
@@ -1,1035 +1,1035 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
 
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
 
 import org.hibernate.QueryException;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.dialect.MySQLDialect;
-import org.hibernate.hql.ast.HqlSqlWalker;
+import org.hibernate.hql.internal.ast.HqlSqlWalker;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.persister.entity.EntityPersister;
 
 import org.junit.Test;
 import junit.framework.AssertionFailedError;
 
 import org.hibernate.testing.DialectChecks;
 import org.hibernate.testing.RequiresDialectFeature;
 import org.hibernate.testing.SkipLog;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * Tests execution of bulk UPDATE/DELETE statements through the new AST parser.
  *
  * @author Steve Ebersole
  */
 public class BulkManipulationTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] {
 				"hql/Animal.hbm.xml",
 		        "hql/Vehicle.hbm.xml",
 		        "hql/KeyManyToOneEntity.hbm.xml",
 		        "hql/Versions.hbm.xml",
 				"hql/FooBarCopy.hbm.xml",
 				"legacy/Multi.hbm.xml",
 				"hql/EntityWithCrazyCompositeKey.hbm.xml",
 				"hql/SimpleEntityWithAssociation.hbm.xml",
 				"hql/BooleanLiteralEntity.hbm.xml"
 		};
 	}
 
 	@Test
 	public void testDeleteNonExistentEntity() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		try {
 			s.createQuery( "delete NonExistentEntity" ).executeUpdate();
 			fail( "no exception thrown" );
 		}
 		catch( QueryException ignore ) {
 		}
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testUpdateNonExistentEntity() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		try {
 			s.createQuery( "update NonExistentEntity e set e.someProp = ?" ).executeUpdate();
 			fail( "no exception thrown" );
 		}
 		catch( QueryException e ) {
 		}
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testTempTableGenerationIsolation() throws Throwable{
 		Session s = openSession();
 		s.beginTransaction();
 
 		Truck truck = new Truck();
 		truck.setVin( "123t" );
 		truck.setOwner( "Steve" );
 		s.save( truck );
 
 		// manually flush the session to ensure the insert happens
 		s.flush();
 
 		// now issue a bulk delete against Car which should force the temp table to be
 		// created.  we need to test to ensure that this does not cause the transaction
 		// to be committed...
 		s.createQuery( "delete from Vehicle" ).executeUpdate();
 
 		s.getTransaction().rollback();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List list = s.createQuery( "from Car" ).list();
 		assertEquals( "temp table gen caused premature commit", 0, list.size() );
 		s.createQuery( "delete from Car" ).executeUpdate();
 		s.getTransaction().rollback();
 		s.close();
 	}
 
 	@Test
 	public void testBooleanHandling() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// currently, we need the three different binds because they are different underlying types...
 		int count = s.createQuery( "update BooleanLiteralEntity set yesNoBoolean = :b1, trueFalseBoolean = :b2, zeroOneBoolean = :b3" )
 				.setBoolean( "b1", true )
 				.setBoolean( "b2", true )
 				.setBoolean( "b3", true )
 				.executeUpdate();
 		assertEquals( 1, count );
 		BooleanLiteralEntity entity = ( BooleanLiteralEntity ) s.createQuery( "from BooleanLiteralEntity" ).uniqueResult();
 		assertTrue( entity.isYesNoBoolean() );
 		assertTrue( entity.isTrueFalseBoolean() );
 		assertTrue( entity.isZeroOneBoolean() );
 		s.clear();
 
 		count = s.createQuery( "update BooleanLiteralEntity set yesNoBoolean = true, trueFalseBoolean = true, zeroOneBoolean = true" )
 				.executeUpdate();
 		assertEquals( 1, count );
 		entity = ( BooleanLiteralEntity ) s.createQuery( "from BooleanLiteralEntity" ).uniqueResult();
 		assertTrue( entity.isYesNoBoolean() );
 		assertTrue( entity.isTrueFalseBoolean() );
 		assertTrue( entity.isZeroOneBoolean() );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testSimpleInsert() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		s.createQuery( "insert into Pickup (id, vin, owner) select id, vin, owner from Car" ).executeUpdate();
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createQuery( "delete Vehicle" ).executeUpdate();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testSimpleNativeSQLInsert() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		List l = s.createQuery("from Vehicle").list();
 		assertEquals(l.size(),4);
 
 		s.createSQLQuery( "insert into Pickup (id, vin, owner) select id, vin, owner from Car" ).executeUpdate();
 
 		l = s.createQuery("from Vehicle").list();
 		assertEquals( l.size(), 5 );
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createSQLQuery( "delete from Truck" ).executeUpdate();
 
 		l = s.createQuery("from Vehicle").list();
 		assertEquals(l.size(),4);
 
 		Car c = (Car) s.createQuery( "from Car where owner = 'Kirsten'" ).uniqueResult();
 		c.setOwner( "NotKirsten" );
 		assertEquals( 0, s.getNamedQuery( "native-delete-car" ).setString( 0, "Kirsten" ).executeUpdate() );
 		assertEquals( 1, s.getNamedQuery( "native-delete-car" ).setString( 0, "NotKirsten" ).executeUpdate() );
 
 
 		assertEquals(
 				0, s.createSQLQuery( "delete from SUV where owner = :owner" )
 				.setString( "owner", "NotThere" )
 				.executeUpdate()
 		);
 		assertEquals(
 				1, s.createSQLQuery( "delete from SUV where owner = :owner" )
 				.setString( "owner", "Joe" )
 				.executeUpdate()
 		);
 		s.createSQLQuery( "delete from Pickup" ).executeUpdate();
 
 		l = s.createQuery("from Vehicle").list();
 		assertEquals(l.size(),0);
 
 
 		t.commit();
 		s.close();
 
 
 		data.cleanup();
 	}
 	
 	@Test
 	public void testInsertWithManyToOne() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		s.createQuery( "insert into Animal (description, bodyWeight, mother) select description, bodyWeight, mother from Human" ).executeUpdate();
 
 		t.commit();
 		t = s.beginTransaction();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testInsertWithMismatchedTypes() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		try {
 			s.createQuery( "insert into Pickup (owner, vin, id) select id, vin, owner from Car" ).executeUpdate();
 			fail( "mismatched types did not error" );
 		}
 		catch( QueryException e ) {
 			// expected result
 		}
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createQuery( "delete Vehicle" ).executeUpdate();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testInsertIntoSuperclassPropertiesFails() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		try {
 			s.createQuery( "insert into Human (id, bodyWeight) select id, bodyWeight from Lizard" ).executeUpdate();
 			fail( "superclass prop insertion did not error" );
 		}
 		catch( QueryException e ) {
 			// expected result
 		}
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createQuery( "delete Animal where mother is not null" ).executeUpdate();
 		s.createQuery( "delete Animal where father is not null" ).executeUpdate();
 		s.createQuery( "delete Animal" ).executeUpdate();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testInsertAcrossMappedJoinFails() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		try {
 			s.createQuery( "insert into Joiner (name, joinedName) select vin, owner from Car" ).executeUpdate();
 			fail( "mapped-join insertion did not error" );
 		}
 		catch( QueryException e ) {
 			// expected result
 		}
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createQuery( "delete Joiner" ).executeUpdate();
 		s.createQuery( "delete Vehicle" ).executeUpdate();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	protected boolean supportsBulkInsertIdGeneration(Class entityClass) {
 		EntityPersister persister = sessionFactory().getEntityPersister( entityClass.getName() );
 		IdentifierGenerator generator = persister.getIdentifierGenerator();
 		return HqlSqlWalker.supportsIdGenWithBulkInsertion( generator );
 	}
 
 	@Test
 	public void testInsertWithGeneratedId() {
 		// Make sure the env supports bulk inserts with generated ids...
 		if ( !supportsBulkInsertIdGeneration( PettingZoo.class ) ) {
 			SkipLog.reportSkip(
 					"bulk id generation not supported",
 					"test bulk inserts with generated id and generated timestamp"
 			);
 			return;
 		}
 
 		// create a Zoo
 		Zoo zoo = new Zoo();
 		zoo.setName( "zoo" );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.save( zoo );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "insert into PettingZoo (name) select name from Zoo" ).executeUpdate();
 		t.commit();
 		s.close();
 
 		assertEquals( "unexpected insertion count", 1, count );
 
 		s = openSession();
 		t = s.beginTransaction();
 		PettingZoo pz = ( PettingZoo ) s.createQuery( "from PettingZoo" ).uniqueResult();
 		t.commit();
 		s.close();
 
 		assertEquals( zoo.getName(), pz.getName() );
 		assertTrue( !zoo.getId().equals( pz.getId() ) );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete Zoo" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	@Test
 	public void testInsertWithGeneratedVersionAndId() {
 		// Make sure the env supports bulk inserts with generated ids...
 		if ( !supportsBulkInsertIdGeneration( IntegerVersioned.class ) ) {
 			SkipLog.reportSkip(
 					"bulk id generation not supported",
 					"test bulk inserts with generated id and generated timestamp"
 			);
 			return;
 		}
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		IntegerVersioned entity = new IntegerVersioned( "int-vers" );
 		s.save( entity );
 		s.createQuery( "select id, name, version from IntegerVersioned" ).list();
 		t.commit();
 		s.close();
 
 		Long initialId = entity.getId();
 		int initialVersion = entity.getVersion();
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "insert into IntegerVersioned ( name ) select name from IntegerVersioned" ).executeUpdate();
 		t.commit();
 		s.close();
 
 		assertEquals( "unexpected insertion count", 1, count );
 
 		s = openSession();
 		t = s.beginTransaction();
 		IntegerVersioned created = ( IntegerVersioned ) s.createQuery( "from IntegerVersioned where id <> :initialId" )
 				.setLong( "initialId", initialId.longValue() )
 				.uniqueResult();
 		t.commit();
 		s.close();
 
 		assertEquals( "version was not seeded", initialVersion, created.getVersion() );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete IntegerVersioned" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	@RequiresDialectFeature(
 			value = DialectChecks.SupportsParametersInInsertSelectCheck.class,
 			comment = "dialect does not support parameter in INSERT ... SELECT"
 	)
 	public void testInsertWithGeneratedTimestampVersion() {
 		// Make sure the env supports bulk inserts with generated ids...
 		if ( !supportsBulkInsertIdGeneration( TimestampVersioned.class ) ) {
 			SkipLog.reportSkip(
 					"bulk id generation not supported",
 					"test bulk inserts with generated id and generated timestamp"
 			);
 			return;
 		}
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		TimestampVersioned entity = new TimestampVersioned( "int-vers" );
 		s.save( entity );
 		s.createQuery( "select id, name, version from TimestampVersioned" ).list();
 		t.commit();
 		s.close();
 
 		Long initialId = entity.getId();
 		//Date initialVersion = entity.getVersion();
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "insert into TimestampVersioned ( name ) select name from TimestampVersioned" ).executeUpdate();
 		t.commit();
 		s.close();
 
 		assertEquals( "unexpected insertion count", 1, count );
 
 		s = openSession();
 		t = s.beginTransaction();
 		TimestampVersioned created = ( TimestampVersioned ) s.createQuery( "from TimestampVersioned where id <> :initialId" )
 				.setLong( "initialId", initialId.longValue() )
 				.uniqueResult();
 		t.commit();
 		s.close();
 
 		assertNotNull( created.getVersion() );
 		//assertEquals( "version was not seeded", initialVersion, created.getVersion() );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete TimestampVersioned" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testInsertWithSelectListUsingJoins() {
 		// this is just checking parsing and syntax...
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "insert into Animal (description, bodyWeight) select h.description, h.bodyWeight from Human h where h.mother.mother is not null" ).executeUpdate();
 		s.createQuery( "insert into Animal (description, bodyWeight) select h.description, h.bodyWeight from Human h join h.mother m where m.mother is not null" ).executeUpdate();
 		s.createQuery( "delete from Animal" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testIncorrectSyntax() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		try {
 			s.createQuery( "update Human set Human.description = 'xyz' where Human.id = 1 and Human.description is null" );
 			fail( "expected failure" );
 		}
 		catch( QueryException expected ) {
 			// ignore : expected behavior
 		}
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testUpdateWithWhereExistsSubquery() {
 		// multi-table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Human joe = new Human();
 		joe.setName( new Name( "Joe", 'Q', "Public" ) );
 		s.save( joe );
 		Human doll = new Human();
 		doll.setName( new Name( "Kyu", 'P', "Doll" ) );
 		doll.setFriends( new ArrayList() );
 		doll.getFriends().add( joe );
 		s.save( doll );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		String updateQryString = "update Human h " +
 		                         "set h.description = 'updated' " +
 		                         "where exists (" +
 		                         "      select f.id " +
 		                         "      from h.friends f " +
 		                         "      where f.name.last = 'Public' " +
 		                         ")";
 		int count = s.createQuery( updateQryString ).executeUpdate();
 		assertEquals( 1, count );
 		s.delete( doll );
 		s.delete( joe );
 		t.commit();
 		s.close();
 
 		// single-table (one-to-many & many-to-many) ~~~~~~~~~~~~~~~~~~~~~~~~~~
 		s = openSession();
 		t = s.beginTransaction();
 		SimpleEntityWithAssociation entity = new SimpleEntityWithAssociation();
 		SimpleEntityWithAssociation other = new SimpleEntityWithAssociation();
 		entity.setName( "main" );
 		other.setName( "many-to-many-association" );
 		entity.getManyToManyAssociatedEntities().add( other );
 		entity.addAssociation( "one-to-many-association" );
 		s.save( entity );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		// one-to-many test
 		updateQryString = "update SimpleEntityWithAssociation e " +
 		                         "set e.name = 'updated' " +
 		                         "where exists (" +
 		                         "      select a.id " +
 		                         "      from e.associatedEntities a " +
 		                         "      where a.name = 'one-to-many-association' " +
 		                         ")";
 		count = s.createQuery( updateQryString ).executeUpdate();
 		assertEquals( 1, count );
 		// many-to-many test
 		if ( getDialect().supportsSubqueryOnMutatingTable() ) {
 			updateQryString = "update SimpleEntityWithAssociation e " +
 									 "set e.name = 'updated' " +
 									 "where exists (" +
 									 "      select a.id " +
 									 "      from e.manyToManyAssociatedEntities a " +
 									 "      where a.name = 'many-to-many-association' " +
 									 ")";
 			count = s.createQuery( updateQryString ).executeUpdate();
 			assertEquals( 1, count );
 		}
 		s.delete( entity.getManyToManyAssociatedEntities().iterator().next() );
 		s.delete( entity );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testIncrementCounterVersion() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		IntegerVersioned entity = new IntegerVersioned( "int-vers" );
 		s.save( entity );
 		t.commit();
 		s.close();
 
 		int initialVersion = entity.getVersion();
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "update versioned IntegerVersioned set name = name" ).executeUpdate();
 		assertEquals( "incorrect exec count", 1, count );
 		t.commit();
 
 		t = s.beginTransaction();
 		entity = ( IntegerVersioned ) s.load( IntegerVersioned.class, entity.getId() );
 		assertEquals( "version not incremented", initialVersion + 1, entity.getVersion() );
 
 		s.delete( entity );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testIncrementTimestampVersion() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		TimestampVersioned entity = new TimestampVersioned( "ts-vers" );
 		s.save( entity );
 		t.commit();
 		s.close();
 
 		Date initialVersion = entity.getVersion();
 
 		synchronized (this) {
 			try {
 				wait(1500);
 			}
 			catch (InterruptedException ie) {}
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "update versioned TimestampVersioned set name = name" ).executeUpdate();
 		assertEquals( "incorrect exec count", 1, count );
 		t.commit();
 
 		t = s.beginTransaction();
 		entity = ( TimestampVersioned ) s.load( TimestampVersioned.class, entity.getId() );
 		assertTrue( "version not incremented", entity.getVersion().after( initialVersion ) );
 
 		s.delete( entity );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	public void testUpdateOnComponent() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Human human = new Human();
 		human.setName( new Name( "Stevee", 'X', "Ebersole" ) );
 
 		s.save( human );
 		s.flush();
 
 		t.commit();
 
 		String correctName = "Steve";
 
 		t = s.beginTransaction();
 
 		int count = s.createQuery( "update Human set name.first = :correction where id = :id" )
 				.setString( "correction", correctName )
 				.setLong( "id", human.getId().longValue() )
 				.executeUpdate();
 
 		assertEquals( "Incorrect update count", 1, count );
 
 		t.commit();
 
 		t = s.beginTransaction();
 
 		s.refresh( human );
 
 		assertEquals( "Update did not execute properly", correctName, human.getName().getFirst() );
 
 		s.createQuery( "delete Human" ).executeUpdate();
 		t.commit();
 
 		s.close();
 	}
 
 	@Test
 	public void testUpdateOnManyToOne() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		s.createQuery( "update Animal a set a.mother = null where a.id = 2" ).executeUpdate();
 		if ( ! ( getDialect() instanceof MySQLDialect ) ) {
 			// MySQL does not support (even un-correlated) subqueries against the update-mutating table
 			s.createQuery( "update Animal a set a.mother = (from Animal where id = 1) where a.id = 2" ).executeUpdate();
 		}
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testUpdateOnImplicitJoinFails() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Human human = new Human();
 		human.setName( new Name( "Steve", 'E', null ) );
 
 		Human mother = new Human();
 		mother.setName( new Name( "Jane", 'E', null ) );
 		human.setMother( mother );
 
 		s.save( human );
 		s.save( mother );
 		s.flush();
 
 		t.commit();
 
 		t = s.beginTransaction();
 		try {
 			s.createQuery( "update Human set mother.name.initial = :initial" ).setString( "initial", "F" ).executeUpdate();
 			fail( "update allowed across implicit join" );
 		}
 		catch( QueryException e ) {
 		}
 
 		s.createQuery( "delete Human where mother is not null" ).executeUpdate();
 		s.createQuery( "delete Human" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	public void testUpdateOnDiscriminatorSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update PettingZoo set name = name" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass update count", 1, count );
 
 		t.rollback();
 		t = s.beginTransaction();
 
 		count = s.createQuery( "update PettingZoo pz set pz.name = pz.name where pz.id = :id" )
 				.setLong( "id", data.pettingZoo.getId().longValue() )
 				.executeUpdate();
 		assertEquals( "Incorrect discrim subclass update count", 1, count );
 
 		t.rollback();
 		t = s.beginTransaction();
 
 		count = s.createQuery( "update Zoo as z set z.name = z.name" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass update count", 2, count );
 
 		t.rollback();
 		t = s.beginTransaction();
 
 		// TODO : not so sure this should be allowed.  Seems to me that if they specify an alias,
 		// property-refs should be required to be qualified.
 		count = s.createQuery( "update Zoo as z set name = name where id = :id" )
 				.setLong( "id", data.zoo.getId().longValue() )
 				.executeUpdate();
 		assertEquals( "Incorrect discrim subclass update count", 1, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateOnAnimal() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		int count = s.createQuery( "update Animal set description = description where description = :desc" )
 				.setString( "desc", data.frog.getDescription() )
 				.executeUpdate();
 		assertEquals( "Incorrect entity-updated count", 1, count );
 
 		count = s.createQuery( "update Animal set description = :newDesc where description = :desc" )
 				.setString( "desc", data.polliwog.getDescription() )
 				.setString( "newDesc", "Tadpole" )
 				.executeUpdate();
 		assertEquals( "Incorrect entity-updated count", 1, count );
 
 		Animal tadpole = ( Animal ) s.load( Animal.class, data.polliwog.getId() );
 		assertEquals( "Update did not take effect", "Tadpole", tadpole.getDescription() );
 
 		count = s.createQuery( "update Animal set bodyWeight = bodyWeight + :w1 + :w2" )
 				.setDouble( "w1", 1 )
 				.setDouble( "w2", 2 )
 				.executeUpdate();
 		assertEquals( "incorrect count on 'complex' update assignment", count, 6 );
 
 		if ( ! ( getDialect() instanceof MySQLDialect ) ) {
 			// MySQL does not support (even un-correlated) subqueries against the update-mutating table
 			s.createQuery( "update Animal set bodyWeight = ( select max(bodyWeight) from Animal )" )
 					.executeUpdate();
 		}
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateOnMammal() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update Mammal set description = description" ).executeUpdate();
 		assertEquals( "incorrect update count against 'middle' of joined-subclass hierarchy", 2, count );
 
 		count = s.createQuery( "update Mammal set bodyWeight = 25" ).executeUpdate();
 		assertEquals( "incorrect update count against 'middle' of joined-subclass hierarchy", 2, count );
 
 		if ( ! ( getDialect() instanceof MySQLDialect ) ) {
 			// MySQL does not support (even un-correlated) subqueries against the update-mutating table
 			count = s.createQuery( "update Mammal set bodyWeight = ( select max(bodyWeight) from Animal )" ).executeUpdate();
 			assertEquals( "incorrect update count against 'middle' of joined-subclass hierarchy", 2, count );
 		}
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateSetNullUnionSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		// These should reach out into *all* subclass tables...
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update Vehicle set owner = 'Steve'" ).executeUpdate();
 		assertEquals( "incorrect restricted update count", 4, count );
 		count = s.createQuery( "update Vehicle set owner = null where owner = 'Steve'" ).executeUpdate();
 		assertEquals( "incorrect restricted update count", 4, count );
 
 		try {
 			count = s.createQuery( "delete Vehicle where owner is null" ).executeUpdate();
 			assertEquals( "incorrect restricted delete count", 4, count );
 		}
 		catch ( AssertionFailedError afe ) {
 			if ( H2Dialect.class.isInstance( getDialect() ) ) {
 				// http://groups.google.com/group/h2-database/t/5548ff9fd3abdb7
 				// this is fixed in H2 1.2.140
 				count = s.createQuery( "delete Vehicle" ).executeUpdate();
 				assertEquals( "incorrect count", 4, count );
 			}
 			else {
 				throw afe;
 			}
 		}
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateSetNullOnDiscriminatorSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update PettingZoo set address.city = null" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 		count = s.createQuery( "delete Zoo where address.city is null" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 
 		count = s.createQuery( "update Zoo set address.city = null" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 		count = s.createQuery( "delete Zoo where address.city is null" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateSetNullOnJoinedSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update Mammal set bodyWeight = null" ).executeUpdate();
 		assertEquals( "Incorrect deletion count on joined subclass", 2, count );
 
 		count = s.createQuery( "delete Animal where bodyWeight = null" ).executeUpdate();
 		assertEquals( "Incorrect deletion count on joined subclass", 2, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testDeleteWithSubquery() {
 		// setup the test data...
 		Session s = openSession();
 		s.beginTransaction();
 		SimpleEntityWithAssociation owner = new SimpleEntityWithAssociation( "myEntity-1" );
 		owner.addAssociation( "assoc-1" );
 		owner.addAssociation( "assoc-2" );
 		owner.addAssociation( "assoc-3" );
 		s.save( owner );
 		SimpleEntityWithAssociation owner2 = new SimpleEntityWithAssociation( "myEntity-2" );
 		owner2.addAssociation( "assoc-1" );
 		owner2.addAssociation( "assoc-2" );
 		owner2.addAssociation( "assoc-3" );
 		owner2.addAssociation( "assoc-4" );
 		s.save( owner2 );
 		SimpleEntityWithAssociation owner3 = new SimpleEntityWithAssociation( "myEntity-3" );
 		s.save( owner3 );
 		s.getTransaction().commit();
 		s.close();
 
 		// now try the bulk delete
 		s = openSession();
 		s.beginTransaction();
 		int count = s.createQuery( "delete SimpleEntityWithAssociation e where size( e.associatedEntities ) = 0 and e.name like '%'" ).executeUpdate();
 		assertEquals( "incorrect delete count", 1, count );
 		s.getTransaction().commit();
 		s.close();
 
 		// finally, clean up
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete SimpleAssociatedEntity" ).executeUpdate();
 		s.createQuery( "delete SimpleEntityWithAssociation" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	@RequiresDialectFeature(
 			value = DialectChecks.HasSelfReferentialForeignKeyBugCheck.class,
 			comment = "self referential FK bug"
 	)
 	public void testSimpleDeleteOnAnimal() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "delete from Animal as a where a.id = :id" )
 				.setLong( "id", data.polliwog.getId().longValue() )
 				.executeUpdate();
 		assertEquals( "Incorrect delete count", 1, count );
 
 		count = s.createQuery( "delete Animal where id = :id" )
 				.setLong( "id", data.catepillar.getId().longValue() )
 				.executeUpdate();
 		assertEquals( "incorrect delete count", 1, count );
 
 		if ( getDialect().supportsSubqueryOnMutatingTable() ) {
 			count = s.createQuery( "delete from User u where u not in (select u from User u)" ).executeUpdate();
 			assertEquals( 0, count );
 		}
 
 		count = s.createQuery( "delete Animal a" ).executeUpdate();
 		assertEquals( "Incorrect delete count", 4, count );
 
 		List list = s.createQuery( "select a from Animal as a" ).list();
 		assertTrue( "table not empty", list.isEmpty() );
 
 		t.commit();
 		s.close();
 		data.cleanup();
 	}
 
 	@Test
 	public void testDeleteOnDiscriminatorSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "delete PettingZoo" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 
 		count = s.createQuery( "delete Zoo" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testDeleteOnJoinedSubclass() {
 		TestData data = new TestData();
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/ClassicTranslatorTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/ClassicTranslatorTest.java
index 1f588d82f9..8106a7e28d 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/ClassicTranslatorTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/ClassicTranslatorTest.java
@@ -1,80 +1,80 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
 
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
-import org.hibernate.hql.classic.ClassicQueryTranslatorFactory;
+import org.hibernate.hql.internal.classic.ClassicQueryTranslatorFactory;
 
 import org.junit.Test;
 
 /**
  * Some simple test queries using the classic translator explicitly
  * to ensure that code is not broken in changes for the new translator.
  * <p/>
  * Only really checking translation and syntax, not results.
  *
  * @author Steve Ebersole
  */
 public class ClassicTranslatorTest extends QueryTranslatorTestCase {
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.QUERY_TRANSLATOR, ClassicQueryTranslatorFactory.class.getName() );
 	}
 
 	@Override
 	public boolean createSchema() {
 		return true;
 	}
 
 	@Override
 	public boolean rebuildSessionFactoryOnError() {
 		return true;
 	}
 
 	@Test
 	public void testQueries() {
 		Session session = openSession();
 		session.beginTransaction();
 
 		session.createQuery( "from Animal" ).list();
 
 		session.createQuery( "select a from Animal as a" ).list();
 		session.createQuery( "select a.mother from Animal as a" ).list();
 		session.createQuery( "select m from Animal as a inner join a.mother as m" ).list();
 		session.createQuery( "select a from Animal as a inner join fetch a.mother" ).list();
 
 		session.createQuery( "from Animal as a where a.description = ?" ).setString( 0, "jj" ).list();
 		session.createQuery( "from Animal as a where a.description = :desc" ).setString( "desc", "jr" ).list();
 		session.createQuery( "from Animal as a where a.description = ? or a.description = :desc" )
 				.setString( 0, "jj" )
 				.setString( "desc", "jr" )
 				.list();
 
 		session.getTransaction().commit();
 		session.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/CriteriaClassicAggregationReturnTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/CriteriaClassicAggregationReturnTest.java
index 045d8cb005..3c95ad1862 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/CriteriaClassicAggregationReturnTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/CriteriaClassicAggregationReturnTest.java
@@ -1,125 +1,125 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
 import java.util.Collections;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.dialect.function.ClassicAvgFunction;
 import org.hibernate.dialect.function.ClassicCountFunction;
 import org.hibernate.dialect.function.ClassicSumFunction;
-import org.hibernate.hql.QueryTranslator;
-import org.hibernate.hql.QueryTranslatorFactory;
-import org.hibernate.hql.ast.QueryTranslatorImpl;
-import org.hibernate.hql.classic.ClassicQueryTranslatorFactory;
+import org.hibernate.hql.spi.QueryTranslator;
+import org.hibernate.hql.spi.QueryTranslatorFactory;
+import org.hibernate.hql.internal.ast.QueryTranslatorImpl;
+import org.hibernate.hql.internal.classic.ClassicQueryTranslatorFactory;
 import org.hibernate.type.BigDecimalType;
 import org.hibernate.type.BigIntegerType;
 import org.hibernate.type.DoubleType;
 import org.hibernate.type.FloatType;
 import org.hibernate.type.IntegerType;
 import org.hibernate.type.LongType;
 
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Steve Ebersole
  */
 public class CriteriaClassicAggregationReturnTest extends QueryTranslatorTestCase {
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.addSqlFunction( "count", new ClassicCountFunction() );
 		cfg.addSqlFunction( "avg", new ClassicAvgFunction() );
 		cfg.addSqlFunction( "sum", new ClassicSumFunction() );
 	}
 
 	@Test
 	public void testClassicHQLAggregationReturnTypes() {
 		// EJB3: COUNT returns Long
 		QueryTranslatorImpl translator = createNewQueryTranslator( "select count(*) from Human h", sessionFactory() );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", IntegerType.INSTANCE, translator.getReturnTypes()[0] );
 
 		translator = createNewQueryTranslator( "select count(h.heightInches) from Human h", sessionFactory() );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", IntegerType.INSTANCE, translator.getReturnTypes()[0] );
 
 		// MAX, MIN return the type of the state-field to which they are applied.
 		translator = createNewQueryTranslator( "select max(h.heightInches) from Human h", sessionFactory() );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 
 		translator = createNewQueryTranslator( "select max(h.id) from Human h", sessionFactory() );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", LongType.INSTANCE, translator.getReturnTypes()[0] );
 
 		// AVG returns Float integrals, and otherwise the field type.
 		translator = createNewQueryTranslator( "select avg(h.heightInches) from Human h", sessionFactory() );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 
 		translator = createNewQueryTranslator( "select avg(h.id) from Human h", sessionFactory() );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", FloatType.INSTANCE, translator.getReturnTypes()[0] );
 
 		translator = createNewQueryTranslator( "select avg(h.bigIntegerValue) from Human h", sessionFactory() );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", BigIntegerType.INSTANCE, translator.getReturnTypes()[0] );
 
         // SUM returns underlying type sum
  	    translator = createNewQueryTranslator( "select sum(h.id) from Human h", sessionFactory() );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", LongType.INSTANCE, translator.getReturnTypes()[0] );
 
 		translator = createNewQueryTranslator( "select sum(h.intValue) from Human h", sessionFactory() );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", IntegerType.INSTANCE, translator.getReturnTypes()[0] );
 
 		translator = createNewQueryTranslator( "select sum(h.heightInches) from Human h", sessionFactory() );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 
 		translator = createNewQueryTranslator( "select sum(h.floatValue) from Human h", sessionFactory() );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", FloatType.INSTANCE, translator.getReturnTypes()[0] );
 
 		translator = createNewQueryTranslator( "select sum(h.bigIntegerValue) from Human h", sessionFactory() );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", BigIntegerType.INSTANCE, translator.getReturnTypes()[0] );
 
 		translator = createNewQueryTranslator( "select sum(h.bigDecimalValue) from Human h", sessionFactory() );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", BigDecimalType.INSTANCE, translator.getReturnTypes()[0] );
 
 		// special case to test classicquery special case handling of count(*)
 		String hql = "select count(*) from Human h";
 		QueryTranslatorFactory classic = new ClassicQueryTranslatorFactory();
 		QueryTranslator oldQueryTranslator = classic.createQueryTranslator( hql, hql, Collections.EMPTY_MAP, sessionFactory() );
 		oldQueryTranslator.compile( Collections.EMPTY_MAP, true);
 		assertEquals( "incorrect return type count", 1, oldQueryTranslator.getReturnTypes().length );
 		assertEquals( "incorrect return type", IntegerType.INSTANCE, oldQueryTranslator.getReturnTypes()[0] );
 
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/CriteriaHQLAlignmentTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/CriteriaHQLAlignmentTest.java
index 3f72640ab7..452a834fac 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/CriteriaHQLAlignmentTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/CriteriaHQLAlignmentTest.java
@@ -1,386 +1,386 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Collections;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.criterion.Projections;
 import org.hibernate.exception.SQLGrammarException;
-import org.hibernate.hql.QueryTranslator;
-import org.hibernate.hql.QueryTranslatorFactory;
-import org.hibernate.hql.ast.QueryTranslatorImpl;
-import org.hibernate.hql.ast.tree.SelectClause;
-import org.hibernate.hql.classic.ClassicQueryTranslatorFactory;
+import org.hibernate.hql.spi.QueryTranslator;
+import org.hibernate.hql.spi.QueryTranslatorFactory;
+import org.hibernate.hql.internal.ast.QueryTranslatorImpl;
+import org.hibernate.hql.internal.ast.tree.SelectClause;
+import org.hibernate.hql.internal.classic.ClassicQueryTranslatorFactory;
 import org.hibernate.type.BigDecimalType;
 import org.hibernate.type.BigIntegerType;
 import org.hibernate.type.DoubleType;
 import org.hibernate.type.LongType;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.testing.TestForIssue;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 
 /**
  * Tests cases for ensuring alignment between HQL and Criteria behavior. 
  *
  * @author Max Rydahl Andersen
  */
 public class CriteriaHQLAlignmentTest extends QueryTranslatorTestCase {
 	private boolean initialVersion2SqlFlagValue;
 
 	@Before
 	public void setVersion2SqlFlag() {
 		initialVersion2SqlFlagValue = SelectClause.VERSION2_SQL;
 		SelectClause.VERSION2_SQL = true;
 	}
 
 	@After
 	public void resetVersion2SqlFlag() {
 		SelectClause.VERSION2_SQL = initialVersion2SqlFlagValue;
 	}
 
 	@Override
 	public String[] getMappings() {
 			return new String[] {
 					"hql/Animal.hbm.xml",
 			};
 	}
 
 	@Override
 	public boolean createSchema() {
 		return true; // needed for the Criteria return type test
 	}
 
 	@Override
 	public boolean rebuildSessionFactoryOnError() {
 		return true;
 	}
 
 	@Test
 	public void testHQLAggregationReturnType() {
 		// EJB3: COUNT returns Long
 		QueryTranslatorImpl translator = createNewQueryTranslator( "select count(*) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", LongType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		translator = createNewQueryTranslator( "select count(h.heightInches) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", LongType.INSTANCE, translator.getReturnTypes()[0] );
 				
 		// MAX, MIN return the type of the state-field to which they are applied. 
 		translator = createNewQueryTranslator( "select max(h.heightInches) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		translator = createNewQueryTranslator( "select max(h.id) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", LongType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		// AVG returns Double.
 		translator = createNewQueryTranslator( "select avg(h.heightInches) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		translator = createNewQueryTranslator( "select avg(h.id) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		translator = createNewQueryTranslator( "select avg(h.bigIntegerValue) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 		
         // SUM returns Long when applied to state-fields of integral types (other than BigInteger);
  	    translator = createNewQueryTranslator( "select sum(h.id) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", LongType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		translator = createNewQueryTranslator( "select sum(h.intValue) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", LongType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		// SUM returns Double when applied to state-fields of floating point types; 
 		translator = createNewQueryTranslator( "select sum(h.heightInches) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 
 		translator = createNewQueryTranslator( "select sum(h.floatValue) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 		
 	    // SUM returns BigInteger when applied to state-fields of type BigInteger 
 		translator = createNewQueryTranslator( "select sum(h.bigIntegerValue) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", BigIntegerType.INSTANCE, translator.getReturnTypes()[0] );
 		
 		// SUM and BigDecimal when applied to state-fields of type BigDecimal.
 		translator = createNewQueryTranslator( "select sum(h.bigDecimalValue) from Human h" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", BigDecimalType.INSTANCE, translator.getReturnTypes()[0] );
 
 		// special case to test classicquery special case handling of count(*)
 		String hql = "select count(*) from Human h";
 		QueryTranslatorFactory classic = new ClassicQueryTranslatorFactory();
 		QueryTranslator oldQueryTranslator = classic.createQueryTranslator( hql, hql, Collections.EMPTY_MAP, sessionFactory() );
 		oldQueryTranslator.compile( Collections.EMPTY_MAP, true);
 		assertEquals( "incorrect return type count", 1, oldQueryTranslator.getReturnTypes().length );
 		assertEquals( "incorrect return type", LongType.INSTANCE, oldQueryTranslator.getReturnTypes()[0] );
 
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-1724" )
 	public void testCriteriaAggregationReturnType() {
 		Session s = openSession();
 		s.beginTransaction();
 		Human human = new Human();
 		human.setBigIntegerValue( new BigInteger("42") );
 		human.setBigDecimalValue( new BigDecimal(45) );
 		s.save(human);
 		s.flush();
 		s.clear();
 		// EJB3: COUNT returns Long
 		Long longValue = (Long) s.createCriteria( Human.class ).setProjection( Projections.rowCount()).uniqueResult();
 		assertEquals(longValue, new Long(1));
 		longValue = (Long) s.createCriteria( Human.class ).setProjection( Projections.count("heightInches")).uniqueResult();
 		assertEquals(longValue, new Long(1));
 		
 		 // MAX, MIN return the type of the state-field to which they are applied. 		
 		Double dblValue = (Double) s.createCriteria( Human.class ).setProjection( Projections.max( "heightInches" )).uniqueResult();
 		assertNotNull(dblValue);
 		
 		longValue = (Long) s.createCriteria( Human.class ).setProjection( Projections.max( "id" )).uniqueResult();
 		assertNotNull(longValue);
 		
 		// AVG returns Double.
 		dblValue = (Double) s.createCriteria( Human.class ).setProjection( Projections.avg( "heightInches" )).uniqueResult();
 		assertNotNull(dblValue);
 		
 		dblValue = (Double) s.createCriteria( Human.class ).setProjection( Projections.avg( "id" )).uniqueResult();
 		assertNotNull(dblValue);
 		
 		dblValue = (Double) s.createCriteria( Human.class ).setProjection( Projections.avg( "bigIntegerValue" )).uniqueResult();
 		assertNotNull(dblValue);
 		
         // SUM returns Long when applied to state-fields of integral types (other than BigInteger);
 		longValue = (Long) s.createCriteria( Human.class ).setProjection( Projections.sum( "id" )).uniqueResult();
 		assertNotNull(longValue);
 		
 		longValue = (Long) s.createCriteria( Human.class ).setProjection( Projections.sum( "intValue" )).uniqueResult();
 		assertNotNull(longValue);
 		
 		// SUM returns Double when applied to state-fields of floating point types; 
 		dblValue = (Double) s.createCriteria( Human.class ).setProjection( Projections.sum( "heightInches" )).uniqueResult();
 		assertNotNull(dblValue);
 		
 		dblValue = (Double) s.createCriteria( Human.class ).setProjection( Projections.sum( "floatValue" )).uniqueResult();
 		assertNotNull(dblValue);
 		
 	    // SUM returns BigInteger when applied to state-fields of type BigInteger 
 		BigInteger bigIValue = (BigInteger) s.createCriteria( Human.class ).setProjection( Projections.sum( "bigIntegerValue" )).uniqueResult();
 		assertNotNull(bigIValue);
 		
 		// SUM and BigDecimal when applied to state-fields of type BigDecimal.
 		BigDecimal bigDValue = (BigDecimal) s.createCriteria( Human.class ).setProjection( Projections.sum( "bigDecimalValue" )).uniqueResult();
 		assertNotNull(bigDValue);
 		
 		s.delete( human );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCountReturnValues() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Human human1 = new Human();
 		human1.setName( new Name( "John", 'Q', "Public" ) );
 		human1.setNickName( "Johnny" );
 		s.save(human1);
 		Human human2 = new Human();
 		human2.setName( new Name( "John", 'A', "Doe" ) );
 		human2.setNickName( "Johnny" );
 		s.save( human2 );
 		Human human3 = new Human();
 		human3.setName( new Name( "John", 'A', "Doe" ) );
 		human3.setNickName( "Jack" );
 		s.save( human3 );
 		Human human4 = new Human();
 		human4.setName( new Name( "John", 'A', "Doe" ) );
 		s.save( human4 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 
 		Long count = ( Long ) s.createQuery( "select count( * ) from Human" ).uniqueResult();
 		assertEquals( 4, count.longValue() );
 		s.clear();
 		count = ( Long ) s.createCriteria( Human.class )
 				.setProjection( Projections.rowCount() )
 				.uniqueResult();
 		assertEquals( 4, count.longValue() );
 		s.clear();
 
 		count = ( Long ) s.createQuery( "select count( nickName ) from Human" ).uniqueResult();
 		assertEquals( 3, count.longValue() );
 		s.clear();
 		count = ( Long ) s.createCriteria( Human.class )
 				.setProjection( Projections.count( "nickName" ) )
 				.uniqueResult();
 		assertEquals( 3, count.longValue() );
 		s.clear();
 
 		count = ( Long ) s.createQuery( "select count( distinct nickName ) from Human" ).uniqueResult();
 		assertEquals( 2, count.longValue() );
 		s.clear();
 		count = ( Long ) s.createCriteria( Human.class )
 				.setProjection( Projections.count( "nickName" ).setDistinct() )
 				.uniqueResult();
 		assertEquals( 2, count.longValue() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		try {
 			count = ( Long ) s.createQuery( "select count( distinct name ) from Human" ).uniqueResult();
 			if ( ! getDialect().supportsTupleDistinctCounts() ) {
 				fail( "expected SQLGrammarException" );
 			}
 			assertEquals( 2, count.longValue() );
 		}
 		catch ( SQLGrammarException ex ) {
 			if ( ! getDialect().supportsTupleDistinctCounts() ) {
 				// expected
 			}
 			else {
 				throw ex;
 			}
 		}
 		finally {
 			t.rollback();
 			s.close();
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		try {
 			count = ( Long ) s.createCriteria( Human.class )
 					.setProjection( Projections.count( "name" ).setDistinct() )
 					.uniqueResult();
 			if ( ! getDialect().supportsTupleDistinctCounts() ) {
 				fail( "expected SQLGrammarException" );
 			}
 			assertEquals( 2, count.longValue() );
 		}
 		catch ( SQLGrammarException ex ) {
 			if ( ! getDialect().supportsTupleDistinctCounts() ) {
 				// expected
 			}
 			else {
 				throw ex;
 			}
 		}
 		finally {
 			t.rollback();
 			s.close();
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		count = ( Long ) s.createQuery( "select count( distinct name.first ) from Human" ).uniqueResult();
 		assertEquals( 1, count.longValue() );
 		s.clear();
 		count = ( Long ) s.createCriteria( Human.class )
 				.setProjection( Projections.count( "name.first" ).setDistinct() )
 				.uniqueResult();
 		assertEquals( 1, count.longValue() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		try {
 			count = ( Long ) s.createQuery( "select count( name ) from Human" ).uniqueResult();
 			if ( ! getDialect().supportsTupleCounts() ) {
 				fail( "expected SQLGrammarException" );
 			}
 			assertEquals( 1, count.longValue() );
 		}
 		catch ( SQLGrammarException ex ) {
 			if ( ! getDialect().supportsTupleCounts() ) {
 				// expected
 			}
 			else {
 				throw ex;
 			}
 		}
 		finally {
 			t.rollback();
 			s.close();
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		try {
 			count = ( Long ) s.createCriteria( Human.class )
 					.setProjection( Projections.count( "name" ) )
 					.uniqueResult();
 			if ( ! getDialect().supportsTupleCounts() ) {
 				fail( "expected SQLGrammarException" );
 			}
 			assertEquals( 1, count.longValue() );
 		}
 		catch ( SQLGrammarException ex ) {
 			if ( ! getDialect().supportsTupleCounts() ) {
 				// expected
 			}
 			else {
 				throw ex;
 			}
 		}
 		finally {
 			t.rollback();
 			s.close();
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete from Human" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/EJBQLTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/EJBQLTest.java
index 4002123ec7..08e35446ac 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/EJBQLTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/EJBQLTest.java
@@ -1,312 +1,312 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
 import java.io.ByteArrayOutputStream;
 import java.io.PrintStream;
 import java.util.Collections;
 import java.util.List;
 
 import antlr.RecognitionException;
 import antlr.TokenStreamException;
 import antlr.collections.AST;
 
-import org.hibernate.hql.QueryTranslator;
-import org.hibernate.hql.QueryTranslatorFactory;
-import org.hibernate.hql.antlr.HqlSqlTokenTypes;
-import org.hibernate.hql.ast.ASTQueryTranslatorFactory;
-import org.hibernate.hql.ast.HqlParser;
-import org.hibernate.hql.ast.QueryTranslatorImpl;
-import org.hibernate.hql.ast.util.ASTUtil;
+import org.hibernate.hql.spi.QueryTranslator;
+import org.hibernate.hql.spi.QueryTranslatorFactory;
+import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
+import org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory;
+import org.hibernate.hql.internal.ast.HqlParser;
+import org.hibernate.hql.internal.ast.QueryTranslatorImpl;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertTrue;
 
 /**
  * @author <a href="mailto:alex@jboss.org">Alexey Loubyansky</a>
  */
 public class EJBQLTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[]{
 			"hql/Animal.hbm.xml",
 			"batchfetch/ProductLine.hbm.xml",
 			"cid/Customer.hbm.xml",
 			"cid/Order.hbm.xml",
 			"cid/LineItem.hbm.xml",
 			"cid/Product.hbm.xml",
 			"legacy/Glarch.hbm.xml",
 			"legacy/Fee.hbm.xml",
 			"legacy/Qux.hbm.xml",
 			"legacy/Fum.hbm.xml",
 			"legacy/Holder.hbm.xml",
 			"legacy/One.hbm.xml",
 			"legacy/FooBar.hbm.xml",
 			"legacy/Many.hbm.xml",
 			"legacy/Baz.hbm.xml",
 			"legacy/Simple.hbm.xml",
 			"legacy/Middle.hbm.xml",
 			"legacy/Category.hbm.xml",
 			"legacy/Multi.hbm.xml",
 			"legacy/Commento.hbm.xml",
 			"legacy/Marelo.hbm.xml",
 			"compositeelement/Parent.hbm.xml",
 			"legacy/Container.hbm.xml",
 		};
 	}
 
 	@Override
 	public boolean createSchema() {
 		return false;
 	}
 
 	@Test
 	public void testEjb3PositionalParameters() throws Exception {
 		QueryTranslatorImpl qt = compile( "from Animal a where a.bodyWeight = ?1" );
 		AST ast = ( AST ) qt.getSqlAST();
 
 		// make certain that the ejb3-positional param got recognized as a named param
 		List namedParams = ASTUtil.collectChildren(
 		        ast,
 		        new ASTUtil.FilterPredicate() {
 			        public boolean exclude(AST n) {
 				        return n.getType() != HqlSqlTokenTypes.NAMED_PARAM;
 			        }
 		        }
 		);
 		assertTrue( "ejb3 positional param not recognized as a named param", namedParams.size() > 0 );
 	}
 
 	@Test
 	public void testSelectObjectClause() throws Exception {
 		//parse("select object(m) from Model m");
 		assertEjbqlEqualsHql( "select object(m) from Model m", "from Model m" );
 	}
 
 	@Test
 	public void testCollectionMemberDeclaration() throws Exception {
 		String hql = "select o from Animal a inner join a.offspring o";
 		String ejbql = "select object(o) from Animal a, in(a.offspring) o";
 		//parse(hql);
 		//parse(ejbql);
 		assertEjbqlEqualsHql( ejbql, hql );
 	}
 
 	@Test
 	public void testIsEmpty() throws Exception {
 		//String hql = "from Animal a where not exists (from a.offspring)";
 		String hql = "from Animal a where not exists elements(a.offspring)";
 		String ejbql = "select object(a) from Animal a where a.offspring is empty";
 		//parse(hql);
 		//parse(ejbql);
 		assertEjbqlEqualsHql(ejbql, hql);
 
 		hql = "from Animal a where exists (from a.mother.father.offspring)";
 		ejbql = "select object(a) from Animal a where a.mother.father.offspring is not empty";
 		assertEjbqlEqualsHql( ejbql, hql );
 	}
 
 	@Test
 	public void testMemberOf() throws Exception {
 		String hql = "from Animal a where a.mother in (from a.offspring)";
 		//String hql = "from Animal a where a.mother in elements(a.offspring)";
 		String ejbql = "select object(a) from Animal a where a.mother member of a.offspring";
 		//parse(hql);
 		//parse(ejbql);
 		assertEjbqlEqualsHql( ejbql, hql );
 
 		hql = "from Animal a where a.mother not in (from a.offspring)";
 		//hql = "from Animal a where a.mother not in elements(a.offspring)";
 		ejbql = "select object(a) from Animal a where a.mother not member of a.offspring";
 		//parse(hql);
 		//parse(ejbql);
 		assertEjbqlEqualsHql( ejbql, hql );
 	}
 
 	@Test
 	public void testEJBQLFunctions() throws Exception {
 		String hql = "select object(a) from Animal a where a.description = concat('1', concat('2','3'), '4'||'5')||0";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "from Animal a where substring(a.description, 1, 3) = :p1";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select substring(a.description, 1, 3) from Animal a";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "from Animal a where lower(a.description) = :p1";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select lower(a.description) from Animal a";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "from Animal a where upper(a.description) = :p1";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select upper(a.description) from Animal a";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "from Animal a where length(a.description) = :p1";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select length(a.description) from Animal a";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "from Animal a where locate(a.description, 'abc', 2) = :p1";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select locate(a.description, :p1, 2) from Animal a";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select object(a) from Animal a where trim(trailing '_' from a.description) = :p1";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select trim(trailing '_' from a.description) from Animal a";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select object(a) from Animal a where trim(leading '_' from a.description) = :p1";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select object(a) from Animal a where trim(both a.description) = :p1";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select object(a) from Animal a where trim(a.description) = :p1";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select object(a) from Animal a where abs(a.bodyWeight) = sqrt(a.bodyWeight)";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select object(a) from Animal a where mod(a.bodyWeight, a.mother.bodyWeight) = :p1";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select object(a) from Animal a where BIT_LENGTH(a.bodyWeight) = :p1";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select BIT_LENGTH(a.bodyWeight) from Animal a";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select object(a) from Animal a where CURRENT_DATE = :p1 or CURRENT_TIME = :p2 or CURRENT_TIMESTAMP = :p3";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		// todo the following is not supported
 		//hql = "select CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP from Animal a";
 		//parse(hql, true);
 		//System.out.println("sql: " + toSql(hql));
 
 		hql = "select object(a) from Animal a where a.bodyWeight like '%a%'";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select object(a) from Animal a where a.bodyWeight not like '%a%'";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 
 		hql = "select object(a) from Animal a where a.bodyWeight like '%a%' escape '%'";
 		parse( hql, false );
 		System.out.println( "sql: " + toSql( hql ) );
 	}
 
 	@Test
 	public void testTrueFalse() throws Exception {
 		assertEjbqlEqualsHql( "from Human h where h.pregnant is true", "from Human h where h.pregnant = true" );
 		assertEjbqlEqualsHql( "from Human h where h.pregnant is false", "from Human h where h.pregnant = false" );
 		assertEjbqlEqualsHql( "from Human h where not(h.pregnant is true)", "from Human h where not( h.pregnant=true )" );
 	}
 
 
 	private void assertEjbqlEqualsHql(String ejbql, String hql) {
 		QueryTranslatorFactory ast = new ASTQueryTranslatorFactory();
 
 		QueryTranslator queryTranslator = ast.createQueryTranslator( hql, hql, Collections.EMPTY_MAP, sessionFactory() );
 		queryTranslator.compile( Collections.EMPTY_MAP, true );
 		String hqlSql = queryTranslator.getSQLString();
 
 		queryTranslator = ast.createQueryTranslator( ejbql, ejbql, Collections.EMPTY_MAP, sessionFactory() );
 		queryTranslator.compile( Collections.EMPTY_MAP, true );
 		String ejbqlSql = queryTranslator.getSQLString();
 
 		assertEquals( hqlSql, ejbqlSql );
 	}
 
 	private QueryTranslatorImpl compile(String input) {
 		QueryTranslatorFactory ast = new ASTQueryTranslatorFactory();
 		QueryTranslator queryTranslator = ast.createQueryTranslator( input, input, Collections.EMPTY_MAP, sessionFactory() );
 		queryTranslator.compile( Collections.EMPTY_MAP, true );
 
 		return ( QueryTranslatorImpl ) queryTranslator;
 	}
 
 	private AST parse(String input, boolean logging) throws RecognitionException, TokenStreamException {
 		if ( logging ) {
 			System.out.println( "input: ->" + input + "<-" );
 		}
 
 		HqlParser parser = HqlParser.getInstance( input );
 		parser.setFilter( false );
 		parser.statement();
 		AST ast = parser.getAST();
 
 		if ( logging ) {
 			System.out.println( "AST  :  " + ast.toStringTree() + "" );
 			ByteArrayOutputStream baos = new ByteArrayOutputStream();
 			parser.showAst( ast, new PrintStream( baos ) );
 			System.out.println( baos.toString() );
 		}
 
 		assertEquals( "At least one error occurred during parsing!", 0, parser.getParseErrorHandler().getErrorCount() );
 
 		return ast;
 	}
 
 	private String toSql(String hql) {
 		QueryTranslatorFactory ast = new ASTQueryTranslatorFactory();
 		QueryTranslator queryTranslator = ast.createQueryTranslator( hql, hql, Collections.EMPTY_MAP, sessionFactory() );
 		queryTranslator.compile( Collections.EMPTY_MAP, true );
 		return queryTranslator.getSQLString();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/HQLTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/HQLTest.java
index e4186b7702..6bd285ca3a 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/HQLTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/HQLTest.java
@@ -1,1067 +1,1067 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import antlr.RecognitionException;
 import antlr.collections.AST;
 
 import org.hibernate.QueryException;
 import org.hibernate.dialect.DB2Dialect;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.IngresDialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.Oracle8iDialect;
 import org.hibernate.dialect.PostgreSQLDialect;
 import org.hibernate.dialect.SQLServerDialect;
 import org.hibernate.dialect.Sybase11Dialect;
 import org.hibernate.dialect.SybaseASE15Dialect;
 import org.hibernate.dialect.SybaseAnywhereDialect;
 import org.hibernate.dialect.SybaseDialect;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.engine.query.spi.HQLQueryPlan;
 import org.hibernate.engine.query.spi.ReturnMetadata;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.hql.QueryTranslator;
-import org.hibernate.hql.QueryTranslatorFactory;
-import org.hibernate.hql.antlr.HqlTokenTypes;
-import org.hibernate.hql.ast.ASTQueryTranslatorFactory;
-import org.hibernate.hql.ast.DetailedSemanticException;
-import org.hibernate.hql.ast.QuerySyntaxException;
-import org.hibernate.hql.ast.QueryTranslatorImpl;
-import org.hibernate.hql.ast.SqlGenerator;
-import org.hibernate.hql.ast.tree.ConstructorNode;
-import org.hibernate.hql.ast.tree.DotNode;
-import org.hibernate.hql.ast.tree.FromReferenceNode;
-import org.hibernate.hql.ast.tree.IndexNode;
-import org.hibernate.hql.ast.tree.QueryNode;
-import org.hibernate.hql.ast.tree.SelectClause;
-import org.hibernate.hql.ast.util.ASTUtil;
+import org.hibernate.hql.spi.QueryTranslator;
+import org.hibernate.hql.spi.QueryTranslatorFactory;
+import org.hibernate.hql.internal.antlr.HqlTokenTypes;
+import org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory;
+import org.hibernate.hql.internal.ast.DetailedSemanticException;
+import org.hibernate.hql.internal.ast.QuerySyntaxException;
+import org.hibernate.hql.internal.ast.QueryTranslatorImpl;
+import org.hibernate.hql.internal.ast.SqlGenerator;
+import org.hibernate.hql.internal.ast.tree.ConstructorNode;
+import org.hibernate.hql.internal.ast.tree.DotNode;
+import org.hibernate.hql.internal.ast.tree.FromReferenceNode;
+import org.hibernate.hql.internal.ast.tree.IndexNode;
+import org.hibernate.hql.internal.ast.tree.QueryNode;
+import org.hibernate.hql.internal.ast.tree.SelectClause;
+import org.hibernate.hql.internal.ast.util.ASTUtil;
 import org.hibernate.type.CalendarDateType;
 import org.hibernate.type.DoubleType;
 import org.hibernate.type.StringType;
 
 import org.hibernate.testing.DialectChecks;
 import org.hibernate.testing.FailureExpected;
 import org.hibernate.testing.RequiresDialectFeature;
 import org.hibernate.testing.SkipForDialect;
 import org.hibernate.testing.TestForIssue;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 import org.junit.Test;
 
 /**
  * Tests cases where the AST based query translator and the 'classic' query translator generate identical SQL.
  *
  * @author Gavin King
  */
 public class HQLTest extends QueryTranslatorTestCase {
 	@Override
 	public boolean createSchema() {
 		return false;
 	}
 
 	@Override
 	public boolean rebuildSessionFactoryOnError() {
 		return false;
 	}
 
 	@Override
 	protected void prepareTest() throws Exception {
 		super.prepareTest();
 		SelectClause.VERSION2_SQL = true;
 		DotNode.REGRESSION_STYLE_JOIN_SUPPRESSION = true;
 		DotNode.ILLEGAL_COLL_DEREF_EXCP_BUILDER = new DotNode.IllegalCollectionDereferenceExceptionBuilder() {
 			public QueryException buildIllegalCollectionDereferenceException(String propertyName, FromReferenceNode lhs) {
 				throw new QueryException( "illegal syntax near collection: " + propertyName );
 			}
 		};
 		SqlGenerator.REGRESSION_STYLE_CROSS_JOINS = true;
 	}
 
 	@Override
 	protected void cleanupTest() throws Exception {
 		SelectClause.VERSION2_SQL = false;
 		DotNode.REGRESSION_STYLE_JOIN_SUPPRESSION = false;
 		DotNode.ILLEGAL_COLL_DEREF_EXCP_BUILDER = DotNode.DEF_ILLEGAL_COLL_DEREF_EXCP_BUILDER;
 		SqlGenerator.REGRESSION_STYLE_CROSS_JOINS = false;
 		super.cleanupTest();
 	}
 
 	@Test
 	public void testModulo() {
 		assertTranslation( "from Animal a where a.bodyWeight % 2 = 0" );
 	}
 
 	@Test
 	public void testInvalidCollectionDereferencesFail() {
 		// should fail with the same exceptions (because of the DotNode.ILLEGAL_COLL_DEREF_EXCP_BUILDER injection)
 		assertTranslation( "from Animal a where a.offspring.description = 'xyz'" );
 		assertTranslation( "from Animal a where a.offspring.father.description = 'xyz'" );
 	}
 	
 	@Test
 	@FailureExpected( jiraKey = "N/A", message = "Lacking ClassicQueryTranslatorFactory support" )
     public void testRowValueConstructorSyntaxInInList2() {
         assertTranslation( "from LineItem l where l.id in (:idList)" );
 		assertTranslation( "from LineItem l where l.id in :idList" );
     }
 
 	@Test
 	@RequiresDialectFeature( DialectChecks.SupportsRowValueConstructorSyntaxInInListCheck .class )
     public void testRowValueConstructorSyntaxInInList() {
 		QueryTranslatorImpl translator = createNewQueryTranslator("from LineItem l where l.id in (?)");
 		assertInExist("'in' should be translated to 'and'", false, translator);
 		translator = createNewQueryTranslator("from LineItem l where l.id in ?");
 		assertInExist("'in' should be translated to 'and'", false, translator);
 		translator = createNewQueryTranslator("from LineItem l where l.id in (('a1',1,'b1'),('a2',2,'b2'))");
 		assertInExist("'in' should be translated to 'and'", false, translator);
 		translator = createNewQueryTranslator("from Animal a where a.id in (?)");
 		assertInExist("only translate tuple with 'in' syntax", true, translator);
 		translator = createNewQueryTranslator("from Animal a where a.id in ?");
 		assertInExist("only translate tuple with 'in' syntax", true, translator);
 		translator = createNewQueryTranslator("from LineItem l where l.id in (select a1 from Animal a1 left join a1.offspring o where a1.id = 1)");
 		assertInExist("do not translate subqueries", true, translator);
 
     }
 
 	private void assertInExist( String message, boolean expected, QueryTranslatorImpl translator ) {
 		AST ast = translator.getSqlAST().getWalker().getAST();
 		QueryNode queryNode = (QueryNode) ast;
 		AST inNode = ASTUtil.findTypeInChildren( queryNode, HqlTokenTypes.IN );
 		assertEquals( message, expected, inNode != null );
 	}
     
 	@Test
 	public void testSubComponentReferences() {
 		assertTranslation( "select c.address.zip.code from ComponentContainer c" );
 		assertTranslation( "select c.address.zip from ComponentContainer c" );
 		assertTranslation( "select c.address from ComponentContainer c" );
 	}
 
 	@Test
 	public void testManyToAnyReferences() {
 		assertTranslation( "from PropertySet p where p.someSpecificProperty.id is not null" );
 		assertTranslation( "from PropertySet p join p.generalProperties gp where gp.id is not null" );
 	}
 
 	@Test
 	public void testJoinFetchCollectionOfValues() {
 		assertTranslation( "select h from Human as h join fetch h.nickNames" );
 	}
 	
 	@Test
 	public void testCollectionMemberDeclarations2() {
 		assertTranslation( "from Customer c, in(c.orders) o" );
 		assertTranslation( "from Customer c, in(c.orders) as o" );
 		assertTranslation( "select c.name from Customer c, in(c.orders) as o where c.id = o.id.customerId" );
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "N/A", message = "Lacking ClassicQueryTranslatorFactory support" )
 	public void testCollectionMemberDeclarations(){
 		// both these two query translators throw exeptions for this HQL since
 		// IN asks an alias, but the difference is that the error message from AST
 		// contains the error token location (by lines and columns), which is hardly 
 		// to get from Classic query translator --stliu
 		assertTranslation( "from Customer c, in(c.orders)" ); 
 	}
 
 	@Test
 	public void testCollectionJoinsInSubselect() {
 		// caused by some goofiness in FromElementFactory that tries to
 		// handle correlated subqueries (but fails miserably) even though this
 		// is not a correlated subquery.  HHH-1248
 		assertTranslation(
 				"select a.id, a.description" +
 				" from Animal a" +
 				"       left join a.offspring" +
 				" where a in (" +
 				"       select a1 from Animal a1" +
 				"           left join a1.offspring o" +
 				"       where a1.id=1" +
 		        ")"
 		);
 		assertTranslation(
 				"select h.id, h.description" +
 		        " from Human h" +
 				"      left join h.friends" +
 				" where h in (" +
 				"      select h1" +
 				"      from Human h1" +
 				"          left join h1.friends f" +
 				"      where h1.id=1" +
 				")"
 		);
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "N/A" )
 	public void testEmptyInList() {
 		assertTranslation( "select a from Animal a where a.description in ()" );
 	}
 
 	@Test
 	public void testDateTimeArithmeticReturnTypesAndParameterGuessing() {
 		QueryTranslatorImpl translator = createNewQueryTranslator( "select o.orderDate - o.orderDate from Order o" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", DoubleType.INSTANCE, translator.getReturnTypes()[0] );
 		translator = createNewQueryTranslator( "select o.orderDate + 2 from Order o" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", CalendarDateType.INSTANCE, translator.getReturnTypes()[0] );
 		translator = createNewQueryTranslator( "select o.orderDate -2 from Order o" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", CalendarDateType.INSTANCE, translator.getReturnTypes()[0] );
 
 		translator = createNewQueryTranslator( "from Order o where o.orderDate > ?" );
 		assertEquals( "incorrect expected param type", CalendarDateType.INSTANCE, translator.getParameterTranslations().getOrdinalParameterExpectedType( 1 ) );
 
 		translator = createNewQueryTranslator( "select o.orderDate + ? from Order o" );
 		assertEquals( "incorrect return type count", 1, translator.getReturnTypes().length );
 		assertEquals( "incorrect return type", CalendarDateType.INSTANCE, translator.getReturnTypes()[0] );
 		assertEquals( "incorrect expected param type", DoubleType.INSTANCE, translator.getParameterTranslations().getOrdinalParameterExpectedType( 1 ) );
 
 	}
 
 	@Test
 	public void testReturnMetadata() {
 		HQLQueryPlan plan = createQueryPlan( "from Animal a" );
 		check( plan.getReturnMetadata(), false, true );
 
 		plan = createQueryPlan( "select a as animal from Animal a" );
 		check( plan.getReturnMetadata(), false, false );
 
 		plan = createQueryPlan( "from java.lang.Object" );
 		check( plan.getReturnMetadata(), true, true );
 
 		plan = createQueryPlan( "select o as entity from java.lang.Object o" );
 		check( plan.getReturnMetadata(), true, false );
 	}
 
 	private void check(
 			ReturnMetadata returnMetadata,
 	        boolean expectingEmptyTypes,
 	        boolean expectingEmptyAliases) {
 		assertNotNull( "null return metadata", returnMetadata );
 		assertNotNull( "null return metadata - types", returnMetadata );
 		assertEquals( "unexpected return size", 1, returnMetadata.getReturnTypes().length );
 		if ( expectingEmptyTypes ) {
 			assertNull( "non-empty types", returnMetadata.getReturnTypes()[0] );
 		}
 		else {
 			assertNotNull( "empty types", returnMetadata.getReturnTypes()[0] );
 		}
 		if ( expectingEmptyAliases ) {
 			assertNull( "non-empty aliases", returnMetadata.getReturnAliases() );
 		}
 		else {
 			assertNotNull( "empty aliases", returnMetadata.getReturnAliases() );
 			assertNotNull( "empty aliases", returnMetadata.getReturnAliases()[0] );
 		}
 	}
 
 	@Test
 	public void testImplicitJoinsAlongWithCartesianProduct() {
 		DotNode.useThetaStyleImplicitJoins = true;
 		assertTranslation( "select foo.foo from Foo foo, Foo foo2" );
 		assertTranslation( "select foo.foo.foo from Foo foo, Foo foo2" );
 		DotNode.useThetaStyleImplicitJoins = false;
 	}
 
 	@Test
 	public void testSubselectBetween() {
 		assertTranslation("from Animal x where (select max(a.bodyWeight) from Animal a) between :min and :max");
 		assertTranslation("from Animal x where (select max(a.description) from Animal a) like 'big%'");
 		assertTranslation("from Animal x where (select max(a.bodyWeight) from Animal a) is not null");
 		assertTranslation("from Animal x where exists (select max(a.bodyWeight) from Animal a)");
 		assertTranslation("from Animal x where (select max(a.bodyWeight) from Animal a) in (1,2,3)");
 	}
 
 	@Test
 	public void testFetchOrderBy() {
 		assertTranslation("from Animal a left outer join fetch a.offspring where a.mother.id = :mid order by a.description");
 	}
 
 	@Test
 	public void testCollectionOrderBy() {
 		assertTranslation("from Animal a join a.offspring o order by a.description");
 		assertTranslation("from Animal a join fetch a.offspring order by a.description");
 		assertTranslation("from Animal a join fetch a.offspring o order by o.description");
 		assertTranslation("from Animal a join a.offspring o order by a.description, o.description");
 	}
 
 	@Test
 	public void testExpressionWithParamInFunction() {
 		assertTranslation("from Animal a where abs(a.bodyWeight-:param) < 2.0");
 		assertTranslation("from Animal a where abs(:param - a.bodyWeight) < 2.0");
 		assertTranslation("from Animal where abs(:x - :y) < 2.0");
 		assertTranslation("from Animal where lower(upper(:foo)) like 'f%'");
 		if ( ! ( getDialect() instanceof SybaseDialect ) &&  ! ( getDialect() instanceof Sybase11Dialect ) &&  ! ( getDialect() instanceof SybaseASE15Dialect ) && ! ( getDialect() instanceof SQLServerDialect ) ) {
 			// Transact-SQL dialects (except SybaseAnywhereDialect) map the length function -> len; 
 			// classic translator does not consider that *when nested*;
 			// SybaseAnywhereDialect supports the length function
 
 			assertTranslation("from Animal a where abs(abs(a.bodyWeight - 1.0 + :param) * abs(length('ffobar')-3)) = 3.0");
 		}
 		if ( !( getDialect() instanceof MySQLDialect ) && ! ( getDialect() instanceof SybaseDialect ) && ! ( getDialect() instanceof Sybase11Dialect ) && !( getDialect() instanceof SybaseASE15Dialect ) && ! ( getDialect() instanceof SybaseAnywhereDialect ) && ! ( getDialect() instanceof SQLServerDialect ) ) {
 			assertTranslation("from Animal where lower(upper('foo') || upper(:bar)) like 'f%'");
 		}
 		if ( getDialect() instanceof PostgreSQLDialect ) {
 			return;
 		}
 		assertTranslation("from Animal where abs(cast(1 as float) - cast(:param as float)) = 1.0");
 	}
 
 	@Test
 	public void testCompositeKeysWithPropertyNamedId() {
 		assertTranslation( "select e.id.id from EntityWithCrazyCompositeKey e" );
 		assertTranslation( "select max(e.id.id) from EntityWithCrazyCompositeKey e" );
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "N/A", message = "Lacking ClassicQueryTranslatorFactory support" )
 	public void testMaxindexHqlFunctionInElementAccessor() {
 		//TODO: broken SQL
 		//      steve (2005.10.06) - this is perfect SQL, but fairly different from the old parser
 		//              tested : HSQLDB (1.8), Oracle8i
 		assertTranslation( "select c from ContainerX c where c.manyToMany[ maxindex(c.manyToMany) ].count = 2" );
 		assertTranslation( "select c from Container c where c.manyToMany[ maxIndex(c.manyToMany) ].count = 2" );
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "N/A", message = "Lacking ClassicQueryTranslatorFactory support" )
 	public void testMultipleElementAccessorOperators() throws Exception {
 		//TODO: broken SQL
 		//      steve (2005.10.06) - Yes, this is all hosed ;)
 		assertTranslation( "select c from ContainerX c where c.oneToMany[ c.manyToMany[0].count ].name = 's'" );
 		assertTranslation( "select c from ContainerX c where c.manyToMany[ c.oneToMany[0].count ].name = 's'" );
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "N/A", message = "Parser output mismatch" )
 	public void testKeyManyToOneJoin() {
 		//TODO: new parser generates unnecessary joins (though the query results are correct)
 		assertTranslation( "from Order o left join fetch o.lineItems li left join fetch li.product p" );
 		assertTranslation( "from Outer o where o.id.master.id.sup.dudu is not null" );
 		assertTranslation( "from Outer o where o.id.master.id.sup.dudu is not null" );
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "N/A", message = "Parser output mismatch" )
 	public void testDuplicateExplicitJoin() throws Exception {
 		//very minor issue with select clause:
 		assertTranslation( "from Animal a join a.mother m1 join a.mother m2" );
 		assertTranslation( "from Zoo zoo join zoo.animals an join zoo.mammals m" );
 		assertTranslation( "from Zoo zoo join zoo.mammals an join zoo.mammals m" );
 	}
 
 	@Test
 	public void testIndexWithExplicitJoin() throws Exception {
 		//TODO: broken on dialects with theta-style outerjoins:
 		//      steve (2005.10.06) - this works perfectly for me on Oracle8i
 		assertTranslation( "from Zoo zoo join zoo.animals an where zoo.mammals[ index(an) ] = an" );
 		assertTranslation( "from Zoo zoo join zoo.mammals dog where zoo.mammals[ index(dog) ] = dog" );
 		assertTranslation( "from Zoo zoo join zoo.mammals dog where dog = zoo.mammals[ index(dog) ]" );
 	}
 
 	@Test
 	public void testOneToManyMapIndex() throws Exception {
 		//TODO: this breaks on dialects with theta-style outerjoins:
 		//      steve (2005.10.06) - this works perfectly for me on Oracle8i
 		assertTranslation( "from Zoo zoo where zoo.mammals['dog'].description like '%black%'" );
 		assertTranslation( "from Zoo zoo where zoo.mammals['dog'].father.description like '%black%'" );
 		assertTranslation( "from Zoo zoo where zoo.mammals['dog'].father.id = 1234" );
 		assertTranslation( "from Zoo zoo where zoo.animals['1234'].description like '%black%'" );
 	}
 
 	@Test
 	public void testExplicitJoinMapIndex() throws Exception {
 		//TODO: this breaks on dialects with theta-style outerjoins:
 		//      steve (2005.10.06) - this works perfectly for me on Oracle8i
 		assertTranslation( "from Zoo zoo, Dog dog where zoo.mammals['dog'] = dog" );
 		assertTranslation( "from Zoo zoo join zoo.mammals dog where zoo.mammals['dog'] = dog" );
 	}
 
 	@Test
 	public void testIndexFunction() throws Exception {
 		// Instead of doing the pre-processor trick like the existing QueryTranslator, this
 		// is handled by MethodNode.
 		//      steve (2005.10.06) - this works perfectly for me on Oracle8i
 		//TODO: broken on dialects with theta-style outerjoins:
 		assertTranslation( "from Zoo zoo join zoo.mammals dog where index(dog) = 'dog'" );
 		assertTranslation( "from Zoo zoo join zoo.animals an where index(an) = '1234'" );
 	}
 
 	@Test
 	public void testSelectCollectionOfValues() throws Exception {
 		//TODO: broken on dialects with theta-style joins
 		///old parser had a bug where the collection element was not included in return types!
 		//      steve (2005.10.06) - this works perfectly for me on Oracle8i
 		assertTranslation( "select baz, date from Baz baz join baz.stringDateMap date where index(date) = 'foo'" );
 	}
 
 	@Test
 	public void testCollectionOfValues() throws Exception {
 		//old parser had a bug where the collection element was not returned!
 		//TODO: broken on dialects with theta-style joins
 		//      steve (2005.10.06) - this works perfectly for me on Oracle8i
 		assertTranslation( "from Baz baz join baz.stringDateMap date where index(date) = 'foo'" );
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-719" )
     public void testHHH719() throws Exception {
         assertTranslation("from Baz b order by org.bazco.SpecialFunction(b.id)");
         assertTranslation("from Baz b order by anypackage.anyFunction(b.id)");
     }
 
 	@Test
 	public void testParameterListExpansion() {
 		assertTranslation( "from Animal as animal where animal.id in (:idList_1, :idList_2)" );
 	}
 
 	@Test
 	public void testComponentManyToOneDereferenceShortcut() {
 		assertTranslation( "from Zoo z where z.address.stateProvince.id is null" );
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-770" )
 	public void testNestedCollectionImplicitJoins() {
 		assertTranslation( "select h.friends.offspring from Human h" );
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-557" )
 	public void testExplicitJoinsInSubquery() {
 		assertTranslation(
 		        "from org.hibernate.test.hql.Animal as animal " +
 		        "where animal.id in (" +
 		        "        select a.id " +
 		        "        from org.hibernate.test.hql.Animal as a " +
 		        "               left join a.mother as mo" +
 		        ")"
 		);
 	}
 
 	@Test
 	public void testImplicitJoinsInGroupBy() {
 		assertTranslation(
 		        "select o.mother.bodyWeight, count(distinct o) " +
 		        "from Animal an " +
 		        "   join an.offspring as o " +
 		        "group by o.mother.bodyWeight"
 		);
 	}
 
 	@Test
 	public void testCrazyIdFieldNames() {
 		DotNode.useThetaStyleImplicitJoins = true;
 		// only regress against non-scalar forms as there appears to be a bug in the classic translator
 		// in regards to this issue also.  Specifically, it interprets the wrong return type, though it gets
 		// the sql "correct" :/
 
 		String hql = "select e.heresAnotherCrazyIdFieldName from MoreCrazyIdFieldNameStuffEntity e where e.heresAnotherCrazyIdFieldName is not null";
 		assertTranslation( hql, new HashMap(), false, null );
 
 	    hql = "select e.heresAnotherCrazyIdFieldName.heresAnotherCrazyIdFieldName from MoreCrazyIdFieldNameStuffEntity e where e.heresAnotherCrazyIdFieldName is not null";
 		assertTranslation( hql, new HashMap(), false, null );
 
 		DotNode.useThetaStyleImplicitJoins = false;
 	}
 
 	@Test
 	public void testSizeFunctionAndProperty() {
 		assertTranslation("from Animal a where a.offspring.size > 0");
 		assertTranslation("from Animal a join a.offspring where a.offspring.size > 1");
 		assertTranslation("from Animal a where size(a.offspring) > 0");
 		assertTranslation("from Animal a join a.offspring o where size(a.offspring) > 1");
 		assertTranslation("from Animal a where size(a.offspring) > 1 and size(a.offspring) < 100");
 
 		assertTranslation("from Human a where a.family.size > 0");
 		assertTranslation("from Human a join a.family where a.family.size > 1");
 		assertTranslation("from Human a where size(a.family) > 0");
 		assertTranslation("from Human a join a.family o where size(a.family) > 1");
 		assertTranslation("from Human a where a.family.size > 0 and a.family.size < 100");
 	}
 
 	@Test
 	public void testFromOnly() throws Exception {
 		// 2004-06-21 [jsd] This test now works with the new AST based QueryTranslatorImpl.
 		assertTranslation( "from Animal" );
 		assertTranslation( "from Model" );
 	}
 
 	@Test
 	public void testJoinPathEndingInValueCollection() {
 		assertTranslation( "select h from Human as h join h.nickNames as nn where h.nickName=:nn1 and (nn=:nn2 or nn=:nn3)" );
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-242" )
 	public void testSerialJoinPathEndingInValueCollection() {
 		assertTranslation( "select h from Human as h join h.friends as f join f.nickNames as nn where h.nickName=:nn1 and (nn=:nn2 or nn=:nn3)" );
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-281" )
 	public void testImplicitJoinContainedByCollectionFunction() {
 		assertTranslation( "from Human as h where 'shipping' in indices(h.father.addresses)" );
 		assertTranslation( "from Human as h where 'shipping' in indices(h.father.father.addresses)" );
 		assertTranslation( "from Human as h where 'sparky' in elements(h.father.nickNames)" );
 		assertTranslation( "from Human as h where 'sparky' in elements(h.father.father.nickNames)" );
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-276" )
 	public void testImpliedJoinInSubselectFrom() {
 		assertTranslation( "from Animal a where exists( from a.mother.offspring )" );
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-276" )
 	public void testSubselectImplicitJoins() {
 		assertTranslation( "from Simple s where s = some( select sim from Simple sim where sim.other.count=s.other.count )" );
 	}
 
 	@Test
 	public void testCollectionOfValuesSize() throws Exception {
 		//SQL *was* missing a comma
 		assertTranslation( "select size(baz.stringDateMap) from org.hibernate.test.legacy.Baz baz" );
 	}
 
 	@Test
 	public void testCollectionFunctions() throws Exception {
 		//these are both broken, a join that belongs in the subselect finds its way into the main query
 		assertTranslation( "from Zoo zoo where size(zoo.animals) > 100" );
 		assertTranslation( "from Zoo zoo where maxindex(zoo.mammals) = 'dog'" );
 	}
 
 	@Test
 	public void testImplicitJoinInExplicitJoin() throws Exception {
 		assertTranslation( "from Animal an inner join an.mother.mother gm" );
 		assertTranslation( "from Animal an inner join an.mother.mother.mother ggm" );
 		assertTranslation( "from Animal an inner join an.mother.mother.mother.mother gggm" );
 	}
 
 	@Test
 	public void testImpliedManyToManyProperty() throws Exception {
 		//missing a table join (SQL correct for a one-to-many, not for a many-to-many)
 		assertTranslation( "select c from ContainerX c where c.manyToMany[0].name = 's'" );
 	}
 
 	@Test
 	public void testCollectionSize() throws Exception {
 		assertTranslation( "select size(zoo.animals) from Zoo zoo" );
 	}
 
 	@Test
 	public void testFetchCollectionOfValues() throws Exception {
 		assertTranslation( "from Baz baz left join fetch baz.stringSet" );
 	}
 
 	@Test
 	public void testFetchList() throws Exception {
 		assertTranslation( "from User u join fetch u.permissions" );
 	}
 
 	@Test
 	public void testCollectionFetchWithExplicitThetaJoin() {
 		assertTranslation( "select m from Master m1, Master m left join fetch m.details where m.name=m1.name" );
 	}
 
 	@Test
 	public void testListElementFunctionInWhere() throws Exception {
 		assertTranslation( "from User u where 'read' in elements(u.permissions)" );
 		assertTranslation( "from User u where 'write' <> all elements(u.permissions)" );
 	}
 
 	@Test
 	public void testManyToManyMaxElementFunctionInWhere() throws Exception {
 		assertTranslation( "from Human human where 5 = maxelement(human.friends)" );
 	}
 
 	@Test
 	public void testCollectionIndexFunctionsInWhere() throws Exception {
 		assertTranslation( "from Zoo zoo where 4 = maxindex(zoo.animals)" );
 		assertTranslation( "from Zoo zoo where 2 = minindex(zoo.animals)" );
 	}
 
 	@Test
 	public void testCollectionIndicesInWhere() throws Exception {
 		assertTranslation( "from Zoo zoo where 4 > some indices(zoo.animals)" );
 		assertTranslation( "from Zoo zoo where 4 > all indices(zoo.animals)" );
 	}
 
 	@Test
 	public void testIndicesInWhere() throws Exception {
 		assertTranslation( "from Zoo zoo where 4 in indices(zoo.animals)" );
 		assertTranslation( "from Zoo zoo where exists indices(zoo.animals)" );
 	}
 
 	@Test
 	public void testCollectionElementInWhere() throws Exception {
 		assertTranslation( "from Zoo zoo where 4 > some elements(zoo.animals)" );
 		assertTranslation( "from Zoo zoo where 4 > all elements(zoo.animals)" );
 	}
 
 	@Test
 	public void testElementsInWhere() throws Exception {
 		assertTranslation( "from Zoo zoo where 4 in elements(zoo.animals)" );
 		assertTranslation( "from Zoo zoo where exists elements(zoo.animals)" );
 	}
 
 	@Test
 	public void testNull() throws Exception {
 		assertTranslation( "from Human h where h.nickName is null" );
 		assertTranslation( "from Human h where h.nickName is not null" );
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testSubstitutions() throws Exception {
 		Map replacements = buildTrueFalseReplacementMapForDialect();
 		replacements.put("yes", "'Y'");
 		assertTranslation( "from Human h where h.pregnant = true", replacements );
 		assertTranslation( "from Human h where h.pregnant = yes", replacements );
 		assertTranslation( "from Human h where h.pregnant = foo", replacements );
 	}
 
 	@Test
 	public void testWhere() throws Exception {
 		assertTranslation( "from Animal an where an.bodyWeight > 10" );
 		// 2004-06-26 [jsd] This one requires NOT GT => LE transform.
 		assertTranslation( "from Animal an where not an.bodyWeight > 10" );
 		assertTranslation( "from Animal an where an.bodyWeight between 0 and 10" );
 		assertTranslation( "from Animal an where an.bodyWeight not between 0 and 10" );
 		assertTranslation( "from Animal an where sqrt(an.bodyWeight)/2 > 10" );
 		// 2004-06-27 [jsd] Recognize 'is null' properly.  Generate 'and' and 'or' as well.
 		assertTranslation( "from Animal an where (an.bodyWeight > 10 and an.bodyWeight < 100) or an.bodyWeight is null" );
 	}
 
 	@Test
 	public void testEscapedQuote() throws Exception {
 		assertTranslation( "from Human h where h.nickName='1 ov''tha''few'");
 	}
 
 	@Test
 	public void testCaseWhenElse() {
 		assertTranslation(
 				"from Human h where case when h.nickName='1ovthafew' then 'Gavin' when h.nickName='turin' then 'Christian' else h.nickName end = h.name.first"
 		);
 	}
 
 	@Test
 	public void testCaseExprWhenElse() {
 		assertTranslation( "from Human h where case h.nickName when '1ovthafew' then 'Gavin' when 'turin' then 'Christian' else h.nickName end = h.name.first" );
 	}
 
 	@Test
 	@SuppressWarnings( {"ThrowableResultOfMethodCallIgnored"})
 	public void testInvalidHql() throws Exception {
 		Exception newException = compileBadHql( "from Animal foo where an.bodyWeight > 10", false );
 		assertTrue( "Wrong exception type!", newException instanceof QuerySyntaxException );
 		newException = compileBadHql( "select an.name from Animal foo", false );
 		assertTrue( "Wrong exception type!", newException instanceof QuerySyntaxException );
 		newException = compileBadHql( "from Animal foo where an.verybogus > 10", false );
 		assertTrue( "Wrong exception type!", newException instanceof QuerySyntaxException );
 		newException = compileBadHql( "select an.boguspropertyname from Animal foo", false );
 		assertTrue( "Wrong exception type!", newException instanceof QuerySyntaxException );
 		newException = compileBadHql( "select an.name", false );
 		assertTrue( "Wrong exception type!", newException instanceof QuerySyntaxException );
 		newException = compileBadHql( "from Animal an where (((an.bodyWeight > 10 and an.bodyWeight < 100)) or an.bodyWeight is null", false );
 		assertTrue( "Wrong exception type!", newException instanceof QuerySyntaxException );
 		newException = compileBadHql( "from Animal an where an.bodyWeight is null where an.bodyWeight is null", false );
 		assertTrue( "Wrong exception type!", newException instanceof QuerySyntaxException );
 		newException = compileBadHql( "from where name='foo'", false );
 		assertTrue( "Wrong exception type!", newException instanceof QuerySyntaxException );
 		newException = compileBadHql( "from NonexistentClass where name='foo'", false );
 		assertTrue( "Wrong exception type!", newException instanceof QuerySyntaxException );
 		newException = compileBadHql( "select new FOO_BOGUS_Animal(an.description, an.bodyWeight) from Animal an", false );
 		assertTrue( "Wrong exception type!", newException instanceof QuerySyntaxException );
 		newException = compileBadHql( "select new Animal(an.description, an.bodyWeight, 666) from Animal an", false );
 		assertTrue( "Wrong exception type!", newException instanceof QuerySyntaxException );
 
 	}
 
 	@Test
 	public void testWhereBetween() throws Exception {
 		assertTranslation( "from Animal an where an.bodyWeight between 1 and 10" );
 	}
 
 	@Test
 	public void testConcatenation() {
 		if ( getDialect() instanceof MySQLDialect || getDialect() instanceof SybaseDialect
 				|| getDialect() instanceof Sybase11Dialect
 				|| getDialect() instanceof SybaseASE15Dialect
 				|| getDialect() instanceof SybaseAnywhereDialect
 				|| getDialect() instanceof SQLServerDialect 
 				|| getDialect() instanceof IngresDialect) {
 			// SybaseASE15Dialect and SybaseAnywhereDialect support '||'
 			// MySQL uses concat(x, y, z)
 			// SQL Server replaces '||' with '+'
 			//
 			// this is syntax checked in {@link ASTParserLoadingTest#testConcatenation} 
 			// Ingres supports both "||" and '+' but IngresDialect originally
 			// uses '+' operator; updated Ingres9Dialect to use "||".
 			return;
 		}
 		assertTranslation("from Human h where h.nickName = '1' || 'ov' || 'tha' || 'few'");
 	}
 
 	@Test
 	public void testWhereLike() throws Exception {
 		assertTranslation( "from Animal a where a.description like '%black%'" );
 		assertTranslation( "from Animal an where an.description like '%fat%'" );
 		assertTranslation( "from Animal an where lower(an.description) like '%fat%'" );
 	}
 
 	@Test
 	public void testWhereIn() throws Exception {
 		assertTranslation( "from Animal an where an.description in ('fat', 'skinny')" );
 	}
 
 	@Test
 	public void testLiteralInFunction() throws Exception {
 		assertTranslation( "from Animal an where an.bodyWeight > abs(5)" );
 		assertTranslation( "from Animal an where an.bodyWeight > abs(-5)" );
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testExpressionInFunction() throws Exception {
 		assertTranslation( "from Animal an where an.bodyWeight > abs(3-5)" );
 		assertTranslation( "from Animal an where an.bodyWeight > abs(3/5)" );
 		assertTranslation( "from Animal an where an.bodyWeight > abs(3+5)" );
 		assertTranslation( "from Animal an where an.bodyWeight > abs(3*5)" );
 		SQLFunction concat = sessionFactory().getSqlFunctionRegistry().findSQLFunction( "concat");
 		List list = new ArrayList();
 		list.add("'fat'");
 		list.add("'skinny'");
 		assertTranslation(
 				"from Animal an where an.description = " +
 						concat.render( StringType.INSTANCE, list, sessionFactory() )
 		);
 	}
 
 	@Test
 	public void testNotOrWhereClause() {
 		assertTranslation( "from Simple s where 'foo'='bar' or not 'foo'='foo'" );
 		assertTranslation( "from Simple s where 'foo'='bar' or not ('foo'='foo')" );
 		assertTranslation( "from Simple s where not ( 'foo'='bar' or 'foo'='foo' )" );
 		assertTranslation( "from Simple s where not ( 'foo'='bar' and 'foo'='foo' )" );
 		assertTranslation( "from Simple s where not ( 'foo'='bar' and 'foo'='foo' ) or not ('x'='y')" );
 		assertTranslation( "from Simple s where not ( 'foo'='bar' or 'foo'='foo' ) and not ('x'='y')" );
 		assertTranslation( "from Simple s where not ( 'foo'='bar' or 'foo'='foo' ) and 'x'='y'" );
 		assertTranslation( "from Simple s where not ( 'foo'='bar' and 'foo'='foo' ) or 'x'='y'" );
 		assertTranslation( "from Simple s where 'foo'='bar' and 'foo'='foo' or not 'x'='y'" );
 		assertTranslation( "from Simple s where 'foo'='bar' or 'foo'='foo' and not 'x'='y'" );
 		assertTranslation( "from Simple s where ('foo'='bar' and 'foo'='foo') or 'x'='y'" );
 		assertTranslation( "from Simple s where ('foo'='bar' or 'foo'='foo') and 'x'='y'" );
 		assertTranslation( "from Simple s where not( upper( s.name ) ='yada' or 1=2 or 'foo'='bar' or not('foo'='foo') or 'foo' like 'bar' )" );
 	}
 
 	@Test
 	public void testComplexExpressionInFunction() throws Exception {
 		assertTranslation( "from Animal an where an.bodyWeight > abs((3-5)/4)" );
 	}
 
 	@Test
 	public void testStandardFunctions() throws Exception {
 		assertTranslation( "from Animal where current_date = current_time" );
 		assertTranslation( "from Animal a where upper(a.description) = 'FAT'" );
 		assertTranslation( "select lower(a.description) from Animal a" );
 	}
 
 	@Test
 	public void testOrderBy() throws Exception {
 		assertTranslation( "from Animal an order by an.bodyWeight" );
 		assertTranslation( "from Animal an order by an.bodyWeight asc" );
 		assertTranslation( "from Animal an order by an.bodyWeight desc" );
 		assertTranslation( "from Animal an order by sqrt(an.bodyWeight*4)/2" );
 		assertTranslation( "from Animal an order by an.mother.bodyWeight" );
 		assertTranslation( "from Animal an order by an.bodyWeight, an.description" );
 		assertTranslation( "from Animal an order by an.bodyWeight asc, an.description desc" );
 		if ( getDialect() instanceof HSQLDialect || getDialect() instanceof DB2Dialect ) {
 			assertTranslation( "from Human h order by sqrt(h.bodyWeight), year(h.birthdate)" );
 		}
 	}
 
 	@Test
 	public void testGroupByFunction() {
 		if ( getDialect() instanceof Oracle8iDialect ) return; // the new hiearchy...
 		if ( getDialect() instanceof PostgreSQLDialect ) return;
 		if ( ! H2Dialect.class.isInstance( getDialect() ) ) {
 			// H2 has no year function
 			assertTranslation( "select count(*) from Human h group by year(h.birthdate)" );
 			assertTranslation( "select count(*) from Human h group by year(sysdate)" );
 		}
 		assertTranslation( "select count(*) from Human h group by trunc( sqrt(h.bodyWeight*4)/2 )" );
 	}
 
 	@Test
 	public void testPolymorphism() throws Exception {
 		Map replacements = buildTrueFalseReplacementMapForDialect();
 		assertTranslation( "from Mammal" );
 		assertTranslation( "from Dog" );
 		assertTranslation( "from Mammal m where m.pregnant = false and m.bodyWeight > 10", replacements );
 		assertTranslation( "from Dog d where d.pregnant = false and d.bodyWeight > 10", replacements );
 	}
 
 	private Map buildTrueFalseReplacementMapForDialect() {
 		HashMap replacements = new HashMap();
 		try {
 			String dialectTrueRepresentation = getDialect().toBooleanValueString( true );
 			// if this call succeeds, then the dialect is saying to represent true/false as int values...
 			Integer.parseInt( dialectTrueRepresentation );
 			replacements.put( "true", "1" );
 			replacements.put( "false", "0" );
 		}
 		catch( NumberFormatException nfe ) {
 			// the Integer#parseInt call failed...
 		}
 		return replacements;
 	}
 
 	@Test
 	public void testTokenReplacement() throws Exception {
 		Map replacements = buildTrueFalseReplacementMapForDialect();
 		assertTranslation( "from Mammal m where m.pregnant = false and m.bodyWeight > 10", replacements );
 	}
 
 	@Test
 	public void testProduct() throws Exception {
 		Map replacements = buildTrueFalseReplacementMapForDialect();
 		assertTranslation( "from Animal, Animal" );
 		assertTranslation( "from Animal x, Animal y where x.bodyWeight = y.bodyWeight" );
 		assertTranslation( "from Animal x, Mammal y where x.bodyWeight = y.bodyWeight and not y.pregnant = true", replacements );
 		assertTranslation( "from Mammal, Mammal" );
 	}
 
 	@Test
 	public void testJoinedSubclassProduct() throws Exception {
 		assertTranslation( "from PettingZoo, PettingZoo" ); //product of two subclasses
 	}
 
 	@Test
 	public void testProjectProduct() throws Exception {
 		assertTranslation( "select x from Human x, Human y where x.nickName = y.nickName" );
 		assertTranslation( "select x, y from Human x, Human y where x.nickName = y.nickName" );
 	}
 
 	@Test
 	public void testExplicitEntityJoins() throws Exception {
 		assertTranslation( "from Animal an inner join an.mother mo" );
 		assertTranslation( "from Animal an left outer join an.mother mo" );
 		assertTranslation( "from Animal an left outer join fetch an.mother" );
 	}
 
 	@Test
 	public void testMultipleExplicitEntityJoins() throws Exception {
 		assertTranslation( "from Animal an inner join an.mother mo inner join mo.mother gm" );
 		assertTranslation( "from Animal an left outer join an.mother mo left outer join mo.mother gm" );
 		assertTranslation( "from Animal an inner join an.mother m inner join an.father f" );
 		assertTranslation( "from Animal an left join fetch an.mother m left join fetch an.father f" );
 	}
 
 	@Test
 	public void testMultipleExplicitJoins() throws Exception {
 		assertTranslation( "from Animal an inner join an.mother mo inner join an.offspring os" );
 		assertTranslation( "from Animal an left outer join an.mother mo left outer join an.offspring os" );
 	}
 
 	@Test
 	public void testExplicitEntityJoinsWithRestriction() throws Exception {
 		assertTranslation( "from Animal an inner join an.mother mo where an.bodyWeight < mo.bodyWeight" );
 	}
 
 	@Test
 	public void testIdProperty() throws Exception {
 		assertTranslation( "from Animal a where a.mother.id = 12" );
 	}
 
 	@Test
 	public void testSubclassAssociation() throws Exception {
 		assertTranslation( "from DomesticAnimal da join da.owner o where o.nickName = 'Gavin'" );
 		assertTranslation( "from DomesticAnimal da left join fetch da.owner" );
 		assertTranslation( "from Human h join h.pets p where p.pregnant = 1" );
 		assertTranslation( "from Human h join h.pets p where p.bodyWeight > 100" );
 		assertTranslation( "from Human h left join fetch h.pets" );
 	}
 
 	@Test
 	public void testExplicitCollectionJoins() throws Exception {
 		assertTranslation( "from Animal an inner join an.offspring os" );
 		assertTranslation( "from Animal an left outer join an.offspring os" );
 	}
 
 	@Test
 	public void testExplicitOuterJoinFetch() throws Exception {
 		assertTranslation( "from Animal an left outer join fetch an.offspring" );
 	}
 
 	@Test
 	public void testExplicitOuterJoinFetchWithSelect() throws Exception {
 		assertTranslation( "select an from Animal an left outer join fetch an.offspring" );
 	}
 
 	@Test
 	public void testExplicitJoins() throws Exception {
 		Map replacements = buildTrueFalseReplacementMapForDialect();
 		assertTranslation( "from Zoo zoo join zoo.mammals mam where mam.pregnant = true and mam.description like '%white%'", replacements );
 		assertTranslation( "from Zoo zoo join zoo.animals an where an.description like '%white%'" );
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-559" )
     public void testMultibyteCharacterConstant() throws Exception {
         assertTranslation( "from Zoo zoo join zoo.animals an where an.description like '%\u4e2d%'" );
     }
 
 	@Test
 	public void testImplicitJoins() throws Exception {
 		// Two dots...
 		assertTranslation( "from Animal an where an.mother.bodyWeight > ?" );
 		assertTranslation( "from Animal an where an.mother.bodyWeight > 10" );
 		assertTranslation( "from Dog dog where dog.mother.bodyWeight > 10" );
 		// Three dots...
 		assertTranslation( "from Animal an where an.mother.mother.bodyWeight > 10" );
 		// The new QT doesn't throw an exception here, so this belongs in ASTQueryTranslator test. [jsd]
 //		assertTranslation( "from Animal an where an.offspring.mother.bodyWeight > 10" );
 		// Is not null (unary postfix operator)
 		assertTranslation( "from Animal an where an.mother is not null" );
 		// ID property shortut (no implicit join)
 		assertTranslation( "from Animal an where an.mother.id = 123" );
 	}
 
 	@Test
 	public void testImplicitJoinInSelect() {
 		assertTranslation( "select foo, foo.long from Foo foo" );
 		DotNode.useThetaStyleImplicitJoins = true;
 		assertTranslation( "select foo.foo from Foo foo" );
 		assertTranslation( "select foo, foo.foo from Foo foo" );
 		assertTranslation( "select foo.foo from Foo foo where foo.foo is not null" );
 		DotNode.useThetaStyleImplicitJoins = false;
 	}
 
 	@Test
 	public void testSelectExpressions() {
 		DotNode.useThetaStyleImplicitJoins = true;
 		assertTranslation( "select an.mother.mother from Animal an" );
 		assertTranslation( "select an.mother.mother.mother from Animal an" );
 		assertTranslation( "select an.mother.mother.bodyWeight from Animal an" );
 		assertTranslation( "select an.mother.zoo.id from Animal an" );
 		assertTranslation( "select user.human.zoo.id from User user" );
 		assertTranslation( "select u.userName, u.human.name.first from User u" );
 		assertTranslation( "select u.human.name.last, u.human.name.first from User u" );
 		assertTranslation( "select bar.baz.name from Bar bar" );
 		assertTranslation( "select bar.baz.name, bar.baz.count from Bar bar" );
 		DotNode.useThetaStyleImplicitJoins = false;
 	}
 
 	@Test
 	public void testSelectStandardFunctionsNoParens() throws Exception {
 		assertTranslation( "select current_date, current_time, current_timestamp from Animal" );
 	}
 
 	@Test
 	public void testMapIndex() throws Exception {
 		assertTranslation( "from User u where u.permissions['hibernate']='read'" );
 	}
 
 	@Test
 	public void testNamedParameters() throws Exception {
 		assertTranslation( "from Animal an where an.mother.bodyWeight > :weight" );
 	}
 
 	@Test
 	@SkipForDialect( Oracle8iDialect.class )
 	public void testClassProperty() throws Exception {
 		assertTranslation( "from Animal a where a.mother.class = Reptile" );
 	}
 
 	@Test
 	public void testComponent() throws Exception {
 		assertTranslation( "from Human h where h.name.first = 'Gavin'" );
 	}
 
 	@Test
 	public void testSelectEntity() throws Exception {
 		assertTranslation( "select an from Animal an inner join an.mother mo where an.bodyWeight < mo.bodyWeight" );
 		assertTranslation( "select mo, an from Animal an inner join an.mother mo where an.bodyWeight < mo.bodyWeight" );
 	}
 
 	@Test
 	public void testValueAggregate() {
 		assertTranslation( "select max(p), min(p) from User u join u.permissions p" );
 	}
 
 	@Test
 	public void testAggregation() throws Exception {
 		assertTranslation( "select count(an) from Animal an" );
 		assertTranslation( "select count(*) from Animal an" );
 		assertTranslation( "select count(distinct an) from Animal an" );
 		assertTranslation( "select count(distinct an.id) from Animal an" );
 		assertTranslation( "select count(all an.id) from Animal an" );
 	}
 
 	@Test
 	public void testSelectProperty() throws Exception {
 		assertTranslation( "select an.bodyWeight, mo.bodyWeight from Animal an inner join an.mother mo where an.bodyWeight < mo.bodyWeight" );
 	}
 
 	@Test
 	public void testSelectEntityProperty() throws Exception {
 		DotNode.useThetaStyleImplicitJoins = true;
 		assertTranslation( "select an.mother from Animal an" );
 		assertTranslation( "select an, an.mother from Animal an" );
 		DotNode.useThetaStyleImplicitJoins = false;
 	}
 
 	@Test
 	public void testSelectDistinctAll() throws Exception {
 		assertTranslation( "select distinct an.description, an.bodyWeight from Animal an" );
 		assertTranslation( "select all an from Animal an" );
 	}
 
 	@Test
 	public void testSelectAssociatedEntityId() throws Exception {
 		assertTranslation( "select an.mother.id from Animal an" );
 	}
 
 	@Test
 	public void testGroupBy() throws Exception {
 		assertTranslation( "select an.mother.id, max(an.bodyWeight) from Animal an group by an.mother.id" );
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/HqlParserTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/HqlParserTest.java
index 0a1b5137d3..ff18f0ce16 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/HqlParserTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/HqlParserTest.java
@@ -1,1011 +1,1011 @@
 // $Id: HqlParserTest.java 10977 2006-12-12 23:28:04Z steve.ebersole@jboss.com $
 package org.hibernate.test.hql;
 import java.io.ByteArrayOutputStream;
 import java.io.PrintStream;
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
-import org.hibernate.hql.ast.HqlParser;
-import org.hibernate.hql.ast.tree.Node;
-import org.hibernate.hql.ast.util.ASTIterator;
-import org.hibernate.hql.ast.util.ASTPrinter;
+import org.hibernate.hql.internal.ast.HqlParser;
+import org.hibernate.hql.internal.ast.tree.Node;
+import org.hibernate.hql.internal.ast.util.ASTIterator;
+import org.hibernate.hql.internal.ast.util.ASTPrinter;
 import antlr.RecognitionException;
 import antlr.TokenStreamException;
 import antlr.collections.AST;
 
 /**
  * Tests the HQL parser on various inputs, just makes sure that the first phase of the parser
  * works properly (i.e. no unexpected syntax errors).
  */
 public class HqlParserTest extends TestCase {
 
 	/**
 	 * Standard JUnit test case constructor.
 	 *
 	 * @param name The name of the test case.
 	 */
 	public HqlParserTest(String name) {
 		super( name );
 	}
 	
 	public void testUnion() throws Exception {
 		parse("from Animal a where a in (from Cat union from Dog) ");
 	}
 
 	/**
 	 * Section 9.2 - from *
 	 */
 	public void testDocoExamples92() throws Exception {
 		parse( "from eg.Cat" );
 		parse( "from eg.Cat as cat" );
 		parse( "from eg.Cat cat" );
 		parse( "from Formula, Parameter" );
 		parse( "from Formula as form, Parameter as param" );
 	}
 
 	/**
 	 * Section 9.3 - Associations and joins *
 	 */
 	public void testDocoExamples93() throws Exception {
 		parse( "from eg.Cat as cat inner join cat.mate as mate left outer join cat.kittens as kitten" );
 		parse( "from eg.Cat as cat left join cat.mate.kittens as kittens" );
 		parse( "from Formula form full join form.parameter param" );
 		parse( "from eg.Cat as cat join cat.mate as mate left join cat.kittens as kitten" );
 		parse( "from eg.Cat as cat\ninner join fetch cat.mate\nleft join fetch cat.kittens" );
 	}
 
 	/**
 	 * Section 9.4 - Select *
 	 */
 	public void testDocoExamples94() throws Exception {
 		parse( "select mate from eg.Cat as cat inner join cat.mate as mate" );
 		parse( "select cat.mate from eg.Cat cat" );
 		parse( "select elements(cat.kittens) from eg.Cat cat" );
 		parse( "select cat.name from eg.DomesticCat cat where cat.name like 'fri%'" );
 		parse( "select cust.name.firstName from Customer as cust" );
 		parse( "select mother, offspr, mate.name from eg.DomesticCat\n"
 				+ " as mother inner join mother.mate as mate left outer join\n"
 				+ "mother.kittens as offspr" );
 		parse( "select new Family(mother, mate, offspr)\n"
 				+ "from eg.DomesticCat as mother\n"
 				+ "join mother.mate as mate\n"
 				+ "left join mother.kittens as offspr\n" );
 	}
 
 	/**
 	 * Section 9.5 - Aggregate functions *
 	 */
 	public void testDocoExamples95() throws Exception {
 		parse( "select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)\n"
 				+ "from eg.Cat cat" );
 		parse( "select cat, count( elements(cat.kittens) )\n"
 				+ " from eg.Cat cat group by cat" );
 		parse( "select distinct cat.name from eg.Cat cat" );
 		parse( "select count(distinct cat.name), count(cat) from eg.Cat cat" );
 	}
 
 	/**
 	 * Section 9.6 - Polymorphism *
 	 */
 	public void testDocoExamples96() throws Exception {
 		parse( "from eg.Cat as cat" );
 		parse( "from java.lang.Object o" );
 		parse( "from eg.Named n, eg.Named m where n.name = m.name" );
 	}
 
 	/**
 	 * Section 9.7 - Where *
 	 */
 	public void testDocoExamples97() throws Exception {
 		parse( "from eg.Cat as cat where cat.name='Fritz'" );
 		parse( "select foo\n"
 				+ "from eg.Foo foo, eg.Bar bar\n"
 				+ "where foo.startDate = bar.date\n" );
 		parse( "from eg.Cat cat where cat.mate.name is not null" );
 		parse( "from eg.Cat cat, eg.Cat rival where cat.mate = rival.mate" );
 		parse( "select cat, mate\n"
 				+ "from eg.Cat cat, eg.Cat mate\n"
 				+ "where cat.mate = mate" );
 		parse( "from eg.Cat as cat where cat.id = 123" );
 		parse( "from eg.Cat as cat where cat.mate.id = 69" );
 		parse( "from bank.Person person\n"
 				+ "where person.id.country = 'AU'\n"
 				+ "and person.id.medicareNumber = 123456" );
 		parse( "from bank.Account account\n"
 				+ "where account.owner.id.country = 'AU'\n"
 				+ "and account.owner.id.medicareNumber = 123456" );
 		parse( "from eg.Cat cat where cat.class = eg.DomesticCat" );
 		parse( "from eg.AuditLog log, eg.Payment payment\n"
 				+ "where log.item.class = 'eg.Payment' and log.item.id = payment.id" );
 	}
 
 	/**
 	 * Section 9.8 - Expressions *
 	 */
 	public void testDocoExamples98() throws Exception {
 		parse( "from eg.DomesticCat cat where cat.name between 'A' and 'B'" );
 		parse( "from eg.DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )" );
 		parse( "from eg.DomesticCat cat where cat.name not between 'A' and 'B'" );
 		parse( "from eg.DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )" );
 		parse( "from eg.Cat cat where cat.kittens.size > 0" );
 		parse( "from eg.Cat cat where size(cat.kittens) > 0" );
 // This is a little odd.  I'm not sure whether 'current' is a keyword.
 //        parse("from Calendar cal where cal.holidays.maxElement > current date");
 // Using the token 'order' as both a keyword and an identifier works now, but
 // the second instance causes some problems because order is valid in the second instance.
 //        parse("from Order order where maxindex(order.items) > 100");
 //        parse("from Order order where minelement(order.items) > 10000");
 		parse( "from Order ord where maxindex(ord.items) > 100" );
 		parse( "from Order ord where minelement(ord.items) > 10000" );
 
 		parse( "select mother from eg.Cat as mother, eg.Cat as kit\n"
 				+ "where kit in elements(foo.kittens)" );
 		parse( "select p from eg.NameList list, eg.Person p\n"
 				+ "where p.name = some elements(list.names)" );
 		parse( "from eg.Cat cat where exists elements(cat.kittens)" );
 		parse( "from eg.Player p where 3 > all elements(p.scores)" );
 		parse( "from eg.Show show where 'fizard' in indices(show.acts)" );
 
 		// Yet another example of the pathological 'order' token.
 //        parse("from Order order where order.items[0].id = 1234");
 //        parse("select person from Person person, Calendar calendar\n"
 //        + "where calendar.holidays['national day'] = person.birthDay\n"
 //        + "and person.nationality.calendar = calendar");
 //        parse("select item from Item item, Order order\n"
 //        + "where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11");
 //        parse("select item from Item item, Order order\n"
 //        + "where order.items[ maxindex(order.items) ] = item and order.id = 11");
 
 		parse( "from Order ord where ord.items[0].id = 1234" );
 		parse( "select person from Person person, Calendar calendar\n"
 				+ "where calendar.holidays['national day'] = person.birthDay\n"
 				+ "and person.nationality.calendar = calendar" );
 		parse( "select item from Item item, Order ord\n"
 				+ "where ord.items[ ord.deliveredItemIndices[0] ] = item and ord.id = 11" );
 		parse( "select item from Item item, Order ord\n"
 				+ "where ord.items[ maxindex(ord.items) ] = item and ord.id = 11" );
 
 		parse( "select item from Item item, Order ord\n"
 				+ "where ord.items[ size(ord.items) - 1 ] = item" );
 
 		parse( "from eg.DomesticCat cat where upper(cat.name) like 'FRI%'" );
 
 		parse( "select cust from Product prod, Store store\n"
 				+ "inner join store.customers cust\n"
 				+ "where prod.name = 'widget'\n"
 				+ "and store.location.name in ( 'Melbourne', 'Sydney' )\n"
 				+ "and prod = all elements(cust.currentOrder.lineItems)" );
 
 	}
 
 	public void testDocoExamples99() throws Exception {
 		parse( "from eg.DomesticCat cat\n"
 				+ "order by cat.name asc, cat.weight desc, cat.birthdate" );
 	}
 
 	public void testDocoExamples910() throws Exception {
 		parse( "select cat.color, sum(cat.weight), count(cat)\n"
 				+ "from eg.Cat cat group by cat.color" );
 		parse( "select foo.id, avg( elements(foo.names) ), max( indices(foo.names) )\n"
 				+ "from eg.Foo foo group by foo.id" );
 		parse( "select cat.color, sum(cat.weight), count(cat)\n"
 				+ "from eg.Cat cat group by cat.color\n"
 				+ "having cat.color in (eg.Color.TABBY, eg.Color.BLACK)" );
 		parse( "select cat from eg.Cat cat join cat.kittens kitten\n"
 				+ "group by cat having avg(kitten.weight) > 100\n"
 				+ "order by count(kitten) asc, sum(kitten.weight) desc" );
 	}
 
 	public void testDocoExamples911() throws Exception {
 		parse( "from eg.Cat as fatcat where fatcat.weight > (\n"
 				+ "select avg(cat.weight) from eg.DomesticCat cat)" );
 		parse( "from eg.DomesticCat as cat where cat.name = some (\n"
 				+ "select name.nickName from eg.Name as name)\n" );
 		parse( "from eg.Cat as cat where not exists (\n"
 				+ "from eg.Cat as mate where mate.mate = cat)" );
 		parse( "from eg.DomesticCat as cat where cat.name not in (\n"
 				+ "select name.nickName from eg.Name as name)" );
 	}
 
 	public void testDocoExamples912() throws Exception {
 		parse( "select ord.id, sum(price.amount), count(item)\n"
 				+ "from Order as ord join ord.lineItems as item\n"
 				+ "join item.product as product, Catalog as catalog\n"
 				+ "join catalog.prices as price\n"
 				+ "where ord.paid = false\n"
 				+ "and ord.customer = :customer\n"
 				+ "and price.product = product\n"
 				+ "and catalog.effectiveDate < sysdate\n"
 				+ "and catalog.effectiveDate >= all (\n"
 				+ "select cat.effectiveDate from Catalog as cat where cat.effectiveDate < sysdate)\n"
 				+ "group by ord\n"
 				+ "having sum(price.amount) > :minAmount\n"
 				+ "order by sum(price.amount) desc" );
 
 		parse( "select ord.id, sum(price.amount), count(item)\n"
 				+ "from Order as ord join ord.lineItems as item join item.product as product,\n"
 				+ "Catalog as catalog join catalog.prices as price\n"
 				+ "where ord.paid = false and ord.customer = :customer\n"
 				+ "and price.product = product and catalog = :currentCatalog\n"
 				+ "group by ord having sum(price.amount) > :minAmount\n"
 				+ "order by sum(price.amount) desc" );
 
 		parse( "select count(payment), status.name \n"
 				+ "from Payment as payment \n"
 				+ "    join payment.currentStatus as status\n"
 				+ "    join payment.statusChanges as statusChange\n"
 				+ "where payment.status.name <> PaymentStatus.AWAITING_APPROVAL\n"
 				+ "    or (\n"
 				+ "        statusChange.timeStamp = ( \n"
 				+ "            select max(change.timeStamp) \n"
 				+ "            from PaymentStatusChange change \n"
 				+ "            where change.payment = payment\n"
 				+ "        )\n"
 				+ "        and statusChange.user <> :currentUser\n"
 				+ "    )\n"
 				+ "group by status.name, status.sortOrder\n"
 				+ "order by status.sortOrder" );
 		parse( "select count(payment), status.name \n"
 				+ "from Payment as payment\n"
 				+ "    join payment.currentStatus as status\n"
 				+ "where payment.status.name <> PaymentStatus.AWAITING_APPROVAL\n"
 				+ "    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user <> :currentUser\n"
 				+ "group by status.name, status.sortOrder\n"
 				+ "order by status.sortOrder" );
 		parse( "select account, payment\n"
 				+ "from Account as account\n"
 				+ "    left outer join account.payments as payment\n"
 				+ "where :currentUser in elements(account.holder.users)\n"
 				+ "    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)\n"
 				+ "order by account.type.sortOrder, account.accountNumber, payment.dueDate" );
 		parse( "select account, payment\n"
 				+ "from Account as account\n"
 				+ "    join account.holder.users as user\n"
 				+ "    left outer join account.payments as payment\n"
 				+ "where :currentUser = user\n"
 				+ "    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)\n"
 				+ "order by account.type.sortOrder, account.accountNumber, payment.dueDate" );
 	}
 
 	public void testExamples1() throws Exception {
 		parse( "select new org.hibernate.test.S(s.count, s.address)\n"
 				+ "from s in class Simple" );
 		parse( "select s.name, sysdate, trunc(s.pay), round(s.pay) from s in class Simple" );
 		parse( "select round(s.pay, 2) from s" );
 		parse( "select abs(round(s.pay)) from s in class Simple" );
 		parse( "select trunc(round(sysdate)) from s in class Simple" );
 	}
 
 	public void testArrayExpr() throws Exception {
 		parse( "from Order ord where ord.items[0].id = 1234" );
 	}
 
 	public void testMultipleActualParameters() throws Exception {
 		parse( "select round(s.pay, 2) from s" );
 	}
 
 	public void testMultipleFromClasses() throws Exception {
 		parse( "FROM eg.mypackage.Cat qat, com.toadstool.Foo f" );
 		parse( "FROM eg.mypackage.Cat qat, org.jabberwocky.Dipstick" );
 	}
 
 	public void testFromWithJoin() throws Exception {
 		parse( "FROM eg.mypackage.Cat qat, com.toadstool.Foo f join net.sf.blurb.Blurb" );
 		parse( "FROM eg.mypackage.Cat qat  left join com.multijoin.JoinORama , com.toadstool.Foo f join net.sf.blurb.Blurb" );
 	}
 
 	public void testSelect() throws Exception {
 		parse( "SELECT f FROM eg.mypackage.Cat qat, com.toadstool.Foo f join net.sf.blurb.Blurb" );
 		parse( "SELECT DISTINCT bar FROM eg.mypackage.Cat qat  left join com.multijoin.JoinORama as bar, com.toadstool.Foo f join net.sf.blurb.Blurb" );
 		parse( "SELECT count(*) FROM eg.mypackage.Cat qat" );
 		parse( "SELECT avg(qat.weight) FROM eg.mypackage.Cat qat" );
 	}
 
 	public void testWhere() throws Exception {
 		parse( "FROM eg.mypackage.Cat qat where qat.name like '%fluffy%' or qat.toes > 5" );
 		parse( "FROM eg.mypackage.Cat qat where not qat.name like '%fluffy%' or qat.toes > 5" );
 		parse( "FROM eg.mypackage.Cat qat where not qat.name not like '%fluffy%'" );
 		parse( "FROM eg.mypackage.Cat qat where qat.name in ('crater','bean','fluffy')" );
 		parse( "FROM eg.mypackage.Cat qat where qat.name not in ('crater','bean','fluffy')" );
 		parse( "from Animal an where sqrt(an.bodyWeight)/2 > 10" );
 		parse( "from Animal an where (an.bodyWeight > 10 and an.bodyWeight < 100) or an.bodyWeight is null" );
 	}
 
 	public void testGroupBy() throws Exception {
 		parse( "FROM eg.mypackage.Cat qat group by qat.breed" );
 		parse( "FROM eg.mypackage.Cat qat group by qat.breed, qat.eyecolor" );
 	}
 
 	public void testOrderBy() throws Exception {
 		parse( "FROM eg.mypackage.Cat qat order by avg(qat.toes)" );
 		parse( "from Animal an order by sqrt(an.bodyWeight)/2" );
 	}
 
 	public void testDoubleLiteral() throws Exception {
 		parse( "from eg.Cat as tinycat where fatcat.weight < 3.1415" );
 		parse( "from eg.Cat as enormouscat where fatcat.weight > 3.1415e3" );
 	}
 
 	public void testComplexConstructor() throws Exception {
 		parse( "select new Foo(count(bar)) from bar" );
 		parse( "select new Foo(count(bar),(select count(*) from doofus d where d.gob = 'fat' )) from bar" );
 	}
 
 
 	public void testInNotIn() throws Exception {
 		parse( "from foo where foo.bar in ('a' , 'b', 'c')" );
 		parse( "from foo where foo.bar not in ('a' , 'b', 'c')" );
 	}
 
 	public void testOperatorPrecedence() throws Exception {
 		parse( "from foo where foo.bar = 123 + foo.baz * foo.not" );
 		parse( "from foo where foo.bar like 'testzzz' || foo.baz or foo.bar in ('duh', 'gob')" );
 	}
 
 	/**
 	 * Tests HQL generated by the other unit tests.
 	 *
 	 * @throws Exception if the HQL could not be parsed.
 	 */
 	public void testUnitTestHql() throws Exception {
 		parse( "select foo from foo in class org.hibernate.test.Foo, fee in class org.hibernate.test.Fee where foo.dependent = fee order by foo.string desc, foo.component.count asc, fee.id" );
 		parse( "select foo.foo, foo.dependent from foo in class org.hibernate.test.Foo order by foo.foo.string desc, foo.component.count asc, foo.dependent.id" );
 		parse( "select foo from foo in class org.hibernate.test.Foo order by foo.dependent.id, foo.dependent.fi" );
 		parse( "SELECT one FROM one IN CLASS org.hibernate.test.One ORDER BY one.value ASC" );
 		parse( "SELECT many.one FROM many IN CLASS org.hibernate.test.Many ORDER BY many.one.value ASC, many.one.id" );
 		parse( "select foo.id from org.hibernate.test.Foo foo where foo.joinedProp = 'foo'" );
 		parse( "from org.hibernate.test.Foo foo inner join fetch foo.foo" );
 		parse( "from org.hibernate.test.Baz baz left outer join fetch baz.fooToGlarch" );
 		parse( "select foo.foo.foo.string from foo in class org.hibernate.test.Foo where foo.foo = 'bar'" );
 		parse( "select foo.foo.foo.foo.string from foo in class org.hibernate.test.Foo where foo.foo.foo = 'bar'" );
 		parse( "select foo.foo.foo.string from foo in class org.hibernate.test.Foo where foo.foo.foo.foo.string = 'bar'" );
 		parse( "select foo.string from foo in class org.hibernate.test.Foo where foo.foo.foo = 'bar' and foo.foo.foo.foo = 'baz'" );
 		parse( "select foo.string from foo in class org.hibernate.test.Foo where foo.foo.foo.foo.string = 'a' and foo.foo.string = 'b'" );
 		parse( "from org.hibernate.test.Foo as foo where foo.component.glarch.name is not null" );
 		parse( "from org.hibernate.test.Foo as foo left outer join foo.component.glarch as glarch where glarch.name = 'foo'" );
 		parse( "from org.hibernate.test.Foo" );
 		parse( "from org.hibernate.test.Foo foo left outer join foo.foo" );
 		parse( "from org.hibernate.test.Foo, org.hibernate.test.Bar" );
 		parse( "from org.hibernate.test.Baz baz left join baz.fooToGlarch, org.hibernate.test.Bar bar join bar.foo" );
 		parse( "from org.hibernate.test.Baz baz left join baz.fooToGlarch join baz.fooSet" );
 		parse( "from org.hibernate.test.Baz baz left join baz.fooToGlarch join fetch baz.fooSet foo left join fetch foo.foo" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.string='osama bin laden' and foo.boolean = true order by foo.string asc, foo.component.count desc" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.string='osama bin laden' order by foo.string asc, foo.component.count desc" );
 		parse( "select foo.foo from foo in class org.hibernate.test.Foo" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.component.count is null order by foo.component.count" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.component.name='foo'" );
 		parse( "select distinct foo.component.name, foo.component.name from foo in class org.hibernate.test.Foo where foo.component.name='foo'" );
 		parse( "select distinct foo.component.name, foo.id from foo in class org.hibernate.test.Foo where foo.component.name='foo'" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.id=?" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.key=?" );
 		parse( "select foo.foo from foo in class org.hibernate.test.Foo where foo.string='fizard'" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.component.subcomponent.name='bar'" );
 		parse( "select foo.foo from foo in class org.hibernate.test.Foo where foo.foo.id=?" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.foo = ?" );
 		parse( "from bar in class org.hibernate.test.Bar where bar.string='a string' or bar.string='a string'" );
 		parse( "select foo.component.name, elements(foo.component.importantDates) from foo in class org.hibernate.test.Foo where foo.foo.id=?" );
 		parse( "select max(elements(foo.component.importantDates)) from foo in class org.hibernate.test.Foo group by foo.id" );
 		parse( "select foo.foo.foo.foo from foo in class org.hibernate.test.Foo, foo2 in class org.hibernate.test.Foo where foo = foo2.foo and not not ( not foo.string='fizard' ) and foo2.string between 'a' and (foo.foo.string) and ( foo2.string in ( 'fiz', 'blah') or 1=1 )" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.string='from BoogieDown  -tinsel town  =!@#$^&*())'" );
 		parse( "from foo in class org.hibernate.test.Foo where not foo.string='foo''bar'" ); // Added quote quote is an escape
 		parse( "from foo in class org.hibernate.test.Foo where foo.component.glarch.next is null" );
 		parse( " from bar in class org.hibernate.test.Bar where bar.baz.count=667 and bar.baz.count!=123 and not bar.baz.name='1-E-1'" );
 		parse( " from i in class org.hibernate.test.Bar where i.baz.name='Bazza'" );
 		parse( "select count(distinct foo.foo) from foo in class org.hibernate.test.Foo" );
 		parse( "select count(foo.foo.boolean) from foo in class org.hibernate.test.Foo" );
 		parse( "select count(*), foo.int from foo in class org.hibernate.test.Foo group by foo.int" );
 		parse( "select sum(foo.foo.int) from foo in class org.hibernate.test.Foo" );
 		parse( "select count(foo) from foo in class org.hibernate.test.Foo where foo.id=?" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.boolean = ?" );
 		parse( "select new Foo(fo.x) from org.hibernate.test.Fo fo" );
 		parse( "select new Foo(fo.integer) from org.hibernate.test.Foo fo" );
 		parse( "select new Foo(fo.x) from org.hibernate.test.Foo fo" );
 		parse( "select foo.long, foo.component.name, foo, foo.foo from foo in class org.hibernate.test.Foo" );
 		parse( "select avg(foo.float), max(foo.component.name), count(distinct foo.id) from foo in class org.hibernate.test.Foo" );
 		parse( "select foo.long, foo.component, foo, foo.foo from foo in class org.hibernate.test.Foo" );
 		parse( "from o in class org.hibernate.test.MoreStuff" );
 		parse( "from o in class org.hibernate.test.Many" );
 		parse( "from o in class org.hibernate.test.Fee" );
 		parse( "from o in class org.hibernate.test.Qux" );
 		parse( "from o in class org.hibernate.test.Y" );
 		parse( "from o in class org.hibernate.test.Fumm" );
 		parse( "from o in class org.hibernate.test.X" );
 		parse( "from o in class org.hibernate.test.Simple" );
 		parse( "from o in class org.hibernate.test.Location" );
 		parse( "from o in class org.hibernate.test.Holder" );
 		parse( "from o in class org.hibernate.test.Part" );
 		parse( "from o in class org.hibernate.test.Baz" );
 		parse( "from o in class org.hibernate.test.Vetoer" );
 		parse( "from o in class org.hibernate.test.Sortable" );
 		parse( "from o in class org.hibernate.test.Contained" );
 		parse( "from o in class org.hibernate.test.Stuff" );
 		parse( "from o in class org.hibernate.test.Immutable" );
 		parse( "from o in class org.hibernate.test.Container" );
 		parse( "from o in class org.hibernate.test.X$XX" );
 		parse( "from o in class org.hibernate.test.One" );
 		parse( "from o in class org.hibernate.test.Foo" );
 		parse( "from o in class org.hibernate.test.Fo" );
 		parse( "from o in class org.hibernate.test.Glarch" );
 		parse( "from o in class org.hibernate.test.Fum" );
 		parse( "from n in class org.hibernate.test.Holder" );
 		parse( "from n in class org.hibernate.test.Baz" );
 		parse( "from n in class org.hibernate.test.Bar" );
 		parse( "from n in class org.hibernate.test.Glarch" );
 		parse( "from n in class org.hibernate.test.Holder where n.name is not null" );
 		parse( "from n in class org.hibernate.test.Baz where n.name is not null" );
 		parse( "from n in class org.hibernate.test.Bar where n.name is not null" );
 		parse( "from n in class org.hibernate.test.Glarch where n.name is not null" );
 		parse( "from n in class org.hibernate.test.Holder" );
 		parse( "from n in class org.hibernate.test.Baz" );
 		parse( "from n in class org.hibernate.test.Bar" );
 		parse( "from n in class org.hibernate.test.Glarch" );
 		parse( "from n0 in class org.hibernate.test.Holder, n1 in class org.hibernate.test.Holder where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Baz, n1 in class org.hibernate.test.Holder where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Bar, n1 in class org.hibernate.test.Holder where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Glarch, n1 in class org.hibernate.test.Holder where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Holder, n1 in class org.hibernate.test.Baz where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Baz, n1 in class org.hibernate.test.Baz where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Bar, n1 in class org.hibernate.test.Baz where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Glarch, n1 in class org.hibernate.test.Baz where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Holder, n1 in class org.hibernate.test.Bar where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Baz, n1 in class org.hibernate.test.Bar where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Bar, n1 in class org.hibernate.test.Bar where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Glarch, n1 in class org.hibernate.test.Bar where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Holder, n1 in class org.hibernate.test.Glarch where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Baz, n1 in class org.hibernate.test.Glarch where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Bar, n1 in class org.hibernate.test.Glarch where n0.name = n1.name" );
 		parse( "from n0 in class org.hibernate.test.Glarch, n1 in class org.hibernate.test.Glarch where n0.name = n1.name" );
 		parse( "from n in class org.hibernate.test.Holder where n.name = :name" );
 		parse( "from o in class org.hibernate.test.MoreStuff" );
 		parse( "from o in class org.hibernate.test.Many" );
 		parse( "from o in class org.hibernate.test.Fee" );
 		parse( "from o in class org.hibernate.test.Qux" );
 		parse( "from o in class org.hibernate.test.Y" );
 		parse( "from o in class org.hibernate.test.Fumm" );
 		parse( "from o in class org.hibernate.test.X" );
 		parse( "from o in class org.hibernate.test.Simple" );
 		parse( "from o in class org.hibernate.test.Location" );
 		parse( "from o in class org.hibernate.test.Holder" );
 		parse( "from o in class org.hibernate.test.Part" );
 		parse( "from o in class org.hibernate.test.Baz" );
 		parse( "from o in class org.hibernate.test.Vetoer" );
 		parse( "from o in class org.hibernate.test.Sortable" );
 		parse( "from o in class org.hibernate.test.Contained" );
 		parse( "from o in class org.hibernate.test.Stuff" );
 		parse( "from o in class org.hibernate.test.Immutable" );
 		parse( "from o in class org.hibernate.test.Container" );
 		parse( "from o in class org.hibernate.test.X$XX" );
 		parse( "from o in class org.hibernate.test.One" );
 		parse( "from o in class org.hibernate.test.Foo" );
 		parse( "from o in class org.hibernate.test.Fo" );
 		parse( "from o in class org.hibernate.test.Glarch" );
 		parse( "from o in class org.hibernate.test.Fum" );
 		parse( "select baz.code, min(baz.count) from baz in class org.hibernate.test.Baz group by baz.code" );
 		parse( "selecT baz from baz in class org.hibernate.test.Baz where baz.stringDateMap['foo'] is not null or baz.stringDateMap['bar'] = ?" );
 		parse( "select baz from baz in class org.hibernate.test.Baz where baz.stringDateMap['now'] is not null" );
 		parse( "select baz from baz in class org.hibernate.test.Baz where baz.stringDateMap['now'] is not null and baz.stringDateMap['big bang'] < baz.stringDateMap['now']" );
 		parse( "select index(date) from org.hibernate.test.Baz baz join baz.stringDateMap date" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.integer not between 1 and 5 and foo.string not in ('cde', 'abc') and foo.string is not null and foo.integer<=3" );
 		parse( "from org.hibernate.test.Baz baz inner join baz.collectionComponent.nested.foos foo where foo.string is null" );
 		parse( "from org.hibernate.test.Baz baz inner join baz.fooSet where '1' in (from baz.fooSet foo where foo.string is not null)" );
 		parse( "from org.hibernate.test.Baz baz where 'a' in elements(baz.collectionComponent.nested.foos) and 1.0 in elements(baz.collectionComponent.nested.floats)" );
 		parse( "from org.hibernate.test.Foo foo join foo.foo where foo.foo in ('1','2','3')" );
 		parse( "select foo.foo from org.hibernate.test.Foo foo where foo.foo in ('1','2','3')" );
 		parse( "select foo.foo.string from org.hibernate.test.Foo foo where foo.foo in ('1','2','3')" );
 		parse( "select foo.foo.string from org.hibernate.test.Foo foo where foo.foo.string in ('1','2','3')" );
 		parse( "select foo.foo.long from org.hibernate.test.Foo foo where foo.foo.string in ('1','2','3')" );
 		parse( "select count(*) from org.hibernate.test.Foo foo where foo.foo.string in ('1','2','3') or foo.foo.long in (1,2,3)" );
 		parse( "select count(*) from org.hibernate.test.Foo foo where foo.foo.string in ('1','2','3') group by foo.foo.long" );
 		parse( "from org.hibernate.test.Foo foo1 left join foo1.foo foo2 left join foo2.foo where foo1.string is not null" );
 		parse( "from org.hibernate.test.Foo foo1 left join foo1.foo.foo where foo1.string is not null" );
 		parse( "from org.hibernate.test.Foo foo1 left join foo1.foo foo2 left join foo1.foo.foo foo3 where foo1.string is not null" );
 		parse( "select foo.formula from org.hibernate.test.Foo foo where foo.formula > 0" );
 		parse( "from org.hibernate.test.Foo as foo join foo.foo as foo2 where foo2.id >'a' or foo2.id <'a'" );
 		parse( "from org.hibernate.test.Holder" );
 		parse( "from org.hibernate.test.Baz baz left outer join fetch baz.manyToAny" );
 		parse( "from org.hibernate.test.Baz baz join baz.manyToAny" );
 		parse( "select baz from org.hibernate.test.Baz baz join baz.manyToAny a where index(a) = 0" );
 		parse( "select bar from org.hibernate.test.Bar bar where bar.baz.stringDateMap['now'] is not null" );
 		parse( "select bar from org.hibernate.test.Bar bar join bar.baz b where b.stringDateMap['big bang'] < b.stringDateMap['now'] and b.stringDateMap['now'] is not null" );
 		parse( "select bar from org.hibernate.test.Bar bar where bar.baz.stringDateMap['big bang'] < bar.baz.stringDateMap['now'] and bar.baz.stringDateMap['now'] is not null" );
 		parse( "select foo.string, foo.component, foo.id from org.hibernate.test.Bar foo" );
 		parse( "select elements(baz.components) from org.hibernate.test.Baz baz" );
 		parse( "select bc.name from org.hibernate.test.Baz baz join baz.components bc" );
 		parse( "from org.hibernate.test.Foo foo where foo.integer < 10 order by foo.string" );
 		parse( "from org.hibernate.test.Fee" );
 		parse( "from org.hibernate.test.Holder h join h.otherHolder oh where h.otherHolder.name = 'bar'" );
 		parse( "from org.hibernate.test.Baz baz join baz.fooSet foo join foo.foo.foo foo2 where foo2.string = 'foo'" );
 		parse( "from org.hibernate.test.Baz baz join baz.fooArray foo join foo.foo.foo foo2 where foo2.string = 'foo'" );
 		parse( "from org.hibernate.test.Baz baz join baz.stringDateMap date where index(date) = 'foo'" );
 		parse( "from org.hibernate.test.Baz baz join baz.topGlarchez g where index(g) = 'A'" );
 		parse( "select index(g) from org.hibernate.test.Baz baz join baz.topGlarchez g" );
 		parse( "from org.hibernate.test.Baz baz left join baz.stringSet" );
 		parse( "from org.hibernate.test.Baz baz join baz.stringSet str where str='foo'" );
 		parse( "from org.hibernate.test.Baz baz left join fetch baz.stringSet" );
 		parse( "from org.hibernate.test.Baz baz join baz.stringSet string where string='foo'" );
 		parse( "from org.hibernate.test.Baz baz inner join baz.components comp where comp.name='foo'" );
 		parse( "from org.hibernate.test.Glarch g inner join g.fooComponents comp where comp.fee is not null" );
 		parse( "from org.hibernate.test.Glarch g inner join g.fooComponents comp join comp.fee fee where fee.count > 0" );
 		parse( "from org.hibernate.test.Glarch g inner join g.fooComponents comp where comp.fee.count is not null" );
 		parse( "from org.hibernate.test.Baz baz left join fetch baz.fooBag" );
 		parse( "from org.hibernate.test.Glarch" );
 		parse( "from org.hibernate.test.Fee" );
 		parse( "from org.hibernate.test.Baz baz left join fetch baz.sortablez order by baz.name asc" );
 		parse( "from org.hibernate.test.Baz baz order by baz.name asc" );
 		parse( "from org.hibernate.test.Foo foo, org.hibernate.test.Baz baz left join fetch baz.fees" );
 		parse( "from org.hibernate.test.Foo foo, org.hibernate.test.Bar bar" );
 		parse( "from org.hibernate.test.Foo foo" );
 		parse( "from org.hibernate.test.Foo foo, org.hibernate.test.Bar bar, org.hibernate.test.Bar bar2" );
 		parse( "from org.hibernate.test.X x" );
 		parse( "from org.hibernate.test.Foo foo" );
 		parse( "select distinct foo from org.hibernate.test.Foo foo" );
 		parse( "from org.hibernate.test.Glarch g where g.multiple.glarch=g and g.multiple.count=12" );
 		parse( "from org.hibernate.test.Bar bar left join bar.baz baz left join baz.cascadingBars b where bar.name like 'Bar %'" );
 		parse( "select bar, b from org.hibernate.test.Bar bar left join bar.baz baz left join baz.cascadingBars b where bar.name like 'Bar%'" );
 		parse( "select bar, b from org.hibernate.test.Bar bar left join bar.baz baz left join baz.cascadingBars b where ( bar.name in (:nameList0_, :nameList1_, :nameList2_) or bar.name in (:nameList0_, :nameList1_, :nameList2_) ) and bar.string = :stringVal" );
 		parse( "select bar, b from org.hibernate.test.Bar bar inner join bar.baz baz inner join baz.cascadingBars b where bar.name like 'Bar%'" );
 		parse( "select bar, b from org.hibernate.test.Bar bar left join bar.baz baz left join baz.cascadingBars b where bar.name like :name and b.name like :name" );
 		parse( "select bar from org.hibernate.test.Bar as bar where bar.x > ? or bar.short = 1 or bar.string = 'ff ? bb'" );
 		parse( "select bar from org.hibernate.test.Bar as bar where bar.string = ' ? ' or bar.string = '?'" );
 		parse( "from org.hibernate.test.Baz baz, baz.fooArray foo" );
 		parse( "from s in class org.hibernate.test.Stuff where s.foo.id = ? and s.id.id = ? and s.moreStuff.id.intId = ? and s.moreStuff.id.stringId = ?" );
 		parse( "from s in class org.hibernate.test.Stuff where s.foo.id = ? and s.id.id = ? and s.moreStuff.name = ?" );
 		parse( "from s in class org.hibernate.test.Stuff where s.foo.string is not null" );
 		parse( "from s in class org.hibernate.test.Stuff where s.foo > '0' order by s.foo" );
 		parse( "from ms in class org.hibernate.test.MoreStuff" );
 		parse( "from foo in class org.hibernate.test.Foo" );
 		parse( "from fee in class org.hibernate.test.Fee" );
 		parse( "select new Result(foo.string, foo.long, foo.integer) from foo in class org.hibernate.test.Foo" );
 		parse( "select new Result( baz.name, foo.long, count(elements(baz.fooArray)) ) from org.hibernate.test.Baz baz join baz.fooArray foo group by baz.name, foo.long" );
 		parse( "select new Result( baz.name, max(foo.long), count(foo) ) from org.hibernate.test.Baz baz join baz.fooArray foo group by baz.name" );
 		parse( "select max( elements(bar.baz.fooArray) ) from org.hibernate.test.Bar as bar" );
 		parse( "from org.hibernate.test.Baz baz left join baz.fooToGlarch join fetch baz.fooArray foo left join fetch foo.foo" );
 		parse( "select baz.name from org.hibernate.test.Bar bar inner join bar.baz baz inner join baz.fooSet foo where baz.name = bar.string" );
 		parse( "SELECT baz.name FROM org.hibernate.test.Bar AS bar INNER JOIN bar.baz AS baz INNER JOIN baz.fooSet AS foo WHERE baz.name = bar.string" );
 		parse( "select baz.name from org.hibernate.test.Bar bar join bar.baz baz left outer join baz.fooSet foo where baz.name = bar.string" );
 		parse( "select baz.name from org.hibernate.test.Bar bar, bar.baz baz, baz.fooSet foo where baz.name = bar.string" );
 		parse( "SELECT baz.name FROM org.hibernate.test.Bar AS bar, bar.baz AS baz, baz.fooSet AS foo WHERE baz.name = bar.string" );
 		parse( "select baz.name from org.hibernate.test.Bar bar left join bar.baz baz left join baz.fooSet foo where baz.name = bar.string" );
 		parse( "select foo.string from org.hibernate.test.Bar bar left join bar.baz.fooSet foo where bar.string = foo.string" );
 		parse( "select baz.name from org.hibernate.test.Bar bar left join bar.baz baz left join baz.fooArray foo where baz.name = bar.string" );
 		parse( "select foo.string from org.hibernate.test.Bar bar left join bar.baz.fooArray foo where bar.string = foo.string" );
 		parse( "select foo from bar in class org.hibernate.test.Bar inner join bar.baz as baz inner join baz.fooSet as foo" );
 		parse( "select foo from bar in class org.hibernate.test.Bar inner join bar.baz.fooSet as foo" );
 		parse( "select foo from bar in class org.hibernate.test.Bar, bar.baz as baz, baz.fooSet as foo" );
 		parse( "select foo from bar in class org.hibernate.test.Bar, bar.baz.fooSet as foo" );
 		parse( "from org.hibernate.test.Bar bar join bar.baz.fooArray foo" );
 		parse( "from bar in class org.hibernate.test.Bar, foo in elements( bar.baz.fooArray )" );
 		parse( "select one.id, elements(one.manies) from one in class org.hibernate.test.One" );
 		parse( "select max( elements(one.manies) ) from one in class org.hibernate.test.One" );
 		parse( "select one, elements(one.manies) from one in class org.hibernate.test.One" );
 		parse( "select one, max(elements(one.manies)) from one in class org.hibernate.test.One group by one" );
 		parse( "select elements(baz.fooArray) from baz in class org.hibernate.test.Baz where baz.id=?" );
 		parse( "select elements(baz.fooArray) from baz in class org.hibernate.test.Baz where baz.id=?" );
 		parse( "select indices(baz.fooArray) from baz in class org.hibernate.test.Baz where baz.id=?" );
 		parse( "select baz, max(elements(baz.timeArray)) from baz in class org.hibernate.test.Baz group by baz" );
 		parse( "select baz, baz.stringSet.size, count(distinct elements(baz.stringSet)), max(elements(baz.stringSet)) from baz in class org.hibernate.test.Baz group by baz" );
 		parse( "select max( elements(baz.timeArray) ) from baz in class org.hibernate.test.Baz where baz.id=?" );
 		parse( "select max(elements(baz.stringSet)) from baz in class org.hibernate.test.Baz where baz.id=?" );
 		parse( "select size(baz.stringSet) from baz in class org.hibernate.test.Baz where baz.id=?" );
 		parse( "from org.hibernate.test.Foo foo where foo.component.glarch.id is not null" );
 		parse( "from baz in class org.hibernate.test.Baz" );
 		parse( "select elements(baz.stringArray) from baz in class org.hibernate.test.Baz" );
 		parse( "from foo in class org.hibernate.test.Foo" );
 		parse( "select elements(baz.stringList) from baz in class org.hibernate.test.Baz" );
 		parse( "select count(*) from org.hibernate.test.Bar" );
 		parse( "select count(*) from b in class org.hibernate.test.Bar" );
 		parse( "from g in class org.hibernate.test.Glarch" );
 		parse( "select baz, baz from baz in class org.hibernate.test.Baz" );
 		parse( "select baz from baz in class org.hibernate.test.Baz order by baz" );
 		parse( "from bar in class org.hibernate.test.Bar" );
 		parse( "from g in class org.hibernate.test.Glarch" );
 		parse( "from f in class org.hibernate.test.Foo" );
 		parse( "from o in class org.hibernate.test.One" );
 		parse( "from q in class org.hibernate.test.Qux" );
 		parse( "select foo from foo in class org.hibernate.test.Foo where foo.string='foo bar'" );
 		parse( "from foo in class org.hibernate.test.Foo order by foo.string, foo.date" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.class='B'" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.class=Bar" );
 		parse( "select bar from bar in class org.hibernate.test.Bar, foo in class org.hibernate.test.Foo where bar.string = foo.string and not bar=foo" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.string='foo bar'" );
 		parse( "select foo from foo in class org.hibernate.test.Foo" );
 		parse( "from bar in class org.hibernate.test.Bar where bar.barString='bar bar'" );
 		parse( "from t in class org.hibernate.test.Trivial" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.date = ?" );
 		parse( "from o in class org.hibernate.test.MoreStuff" );
 		parse( "from o in class org.hibernate.test.Many" );
 		parse( "from o in class org.hibernate.test.Fee" );
 		parse( "from o in class org.hibernate.test.Qux" );
 		parse( "from o in class org.hibernate.test.Y" );
 		parse( "from o in class org.hibernate.test.Fumm" );
 		parse( "from o in class org.hibernate.test.X" );
 		parse( "from o in class org.hibernate.test.Simple" );
 		parse( "from o in class org.hibernate.test.Location" );
 		parse( "from o in class org.hibernate.test.Holder" );
 		parse( "from o in class org.hibernate.test.Part" );
 		parse( "from o in class org.hibernate.test.Baz" );
 		parse( "from o in class org.hibernate.test.Vetoer" );
 		parse( "from o in class org.hibernate.test.Sortable" );
 		parse( "from o in class org.hibernate.test.Contained" );
 		parse( "from o in class org.hibernate.test.Stuff" );
 		parse( "from o in class org.hibernate.test.Immutable" );
 		parse( "from o in class org.hibernate.test.Container" );
 		parse( "from o in class org.hibernate.test.X$XX" );
 		parse( "from o in class org.hibernate.test.One" );
 		parse( "from o in class org.hibernate.test.Foo" );
 		parse( "from o in class org.hibernate.test.Fo" );
 		parse( "from o in class org.hibernate.test.Glarch" );
 		parse( "from o in class org.hibernate.test.Fum" );
 		parse( "from q in class org.hibernate.test.Qux where q.stuff is null" );
 		parse( "from q in class org.hibernate.test.Qux where q.stuff=?" );
 		parse( "from q in class org.hibernate.test.Qux" );
 		parse( "from g in class org.hibernate.test.Glarch where g.version=2" );
 		parse( "from g in class org.hibernate.test.Glarch where g.next is not null" );
 		parse( "from g in class org.hibernate.test.Glarch order by g.order asc" );
 		parse( "from foo in class org.hibernate.test.Foo order by foo.string asc" );
 		parse( "select parent, child from parent in class org.hibernate.test.Foo, child in class org.hibernate.test.Foo where parent.foo = child" );
 		parse( "select count(distinct child.id), count(distinct parent.id) from parent in class org.hibernate.test.Foo, child in class org.hibernate.test.Foo where parent.foo = child" );
 		parse( "select child.id, parent.id, child.long from parent in class org.hibernate.test.Foo, child in class org.hibernate.test.Foo where parent.foo = child" );
 		parse( "select child.id, parent.id, child.long, child, parent.foo from parent in class org.hibernate.test.Foo, child in class org.hibernate.test.Foo where parent.foo = child" );
 		parse( "select parent, child from parent in class org.hibernate.test.Foo, child in class org.hibernate.test.Foo where parent.foo = child and parent.string='a string'" );
 		parse( "from fee in class org.hibernate.test.Fee" );
 		parse( "from org.hibernate.test.Foo foo where foo.custom.s1 = 'one'" );
 		parse( "from im in class org.hibernate.test.Immutable where im = ?" );
 		parse( "from foo in class org.hibernate.test.Foo" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.char='X'" );
 		parse( "select elements(baz.stringArray) from baz in class org.hibernate.test.Baz" );
 		parse( "select distinct elements(baz.stringArray) from baz in class org.hibernate.test.Baz" );
 		parse( "select elements(baz.fooArray) from baz in class org.hibernate.test.Baz" );
 		parse( "from foo in class org.hibernate.test.Fo" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.dependent.qux.foo.string = 'foo2'" );
 		parse( "from org.hibernate.test.Bar bar where bar.object.id = ? and bar.object.class = ?" );
 		parse( "select one from org.hibernate.test.One one, org.hibernate.test.Bar bar where bar.object.id = one.id and bar.object.class = 'O'" );
 		parse( "from l in class org.hibernate.test.Location where l.countryCode = 'AU' and l.description='foo bar'" );
 		parse( "from org.hibernate.test.Bar bar" );
 		parse( "From org.hibernate.test.Bar bar" );
 		parse( "From org.hibernate.test.Foo foo" );
 		parse( "from o in class org.hibernate.test.Baz" );
 		parse( "from o in class org.hibernate.test.Foo" );
 		parse( "from f in class org.hibernate.test.Foo" );
 		parse( "select fum.id from fum in class org.hibernate.test.Fum where not fum.fum='FRIEND'" );
 		parse( "select fum.id from fum in class org.hibernate.test.Fum where not fum.fum='FRIEND'" );
 		parse( "from fum in class org.hibernate.test.Fum where not fum.fum='FRIEND'" );
 		parse( "from fo in class org.hibernate.test.Fo where fo.id.string like 'an instance of fo'" );
 		parse( "from org.hibernate.test.Inner" );
 		parse( "from org.hibernate.test.Outer o where o.id.detailId = ?" );
 		parse( "from org.hibernate.test.Outer o where o.id.master.id.sup.dudu is not null" );
 		parse( "from org.hibernate.test.Outer o where o.id.master.id.sup.id.akey is not null" );
 		parse( "select o.id.master.id.sup.dudu from org.hibernate.test.Outer o where o.id.master.id.sup.dudu is not null" );
 		parse( "select o.id.master.id.sup.id.akey from org.hibernate.test.Outer o where o.id.master.id.sup.id.akey is not null" );
 		parse( "from org.hibernate.test.Outer o where o.id.master.bla = ''" );
 		parse( "from org.hibernate.test.Outer o where o.id.master.id.one = ''" );
 		parse( "from org.hibernate.test.Inner inn where inn.id.bkey is not null and inn.backOut.id.master.id.sup.id.akey > 'a'" );
 		parse( "from org.hibernate.test.Outer as o left join o.id.master m left join m.id.sup where o.bubu is not null" );
 		parse( "from org.hibernate.test.Outer as o left join o.id.master.id.sup s where o.bubu is not null" );
 		parse( "from org.hibernate.test.Outer as o left join o.id.master m left join o.id.master.id.sup s where o.bubu is not null" );
 		parse( "select fum1.fo from fum1 in class org.hibernate.test.Fum where fum1.fo.fum is not null" );
 		parse( "from fum1 in class org.hibernate.test.Fum where fum1.fo.fum is not null order by fum1.fo.fum" );
 		parse( "select elements(fum1.friends) from fum1 in class org.hibernate.test.Fum" );
 		parse( "from fum1 in class org.hibernate.test.Fum, fr in elements( fum1.friends )" );
 		parse( "select new Jay(eye) from org.hibernate.test.Eye eye" );
 		parse( "from org.hibernate.test.Category cat where cat.name='new foo'" );
 		parse( "from org.hibernate.test.Category cat where cat.name='new sub'" );
 		parse( "from org.hibernate.test.Up up order by up.id2 asc" );
 		parse( "from org.hibernate.test.Down down" );
 		parse( "from org.hibernate.test.Up up" );
 		parse( "from m in class org.hibernate.test.Master" );
 		parse( "from s in class org.hibernate.test.Several" );
 		parse( "from s in class org.hibernate.test.Single" );
 		parse( "\n" +
 				"		from d in class \n" +
 				"			org.hibernate.test.Detail\n" +
 				"	" );
 		parse( "from c in class org.hibernate.test.Category where c.name = org.hibernate.test.Category.ROOT_CATEGORY" );
 		parse( "select c from c in class org.hibernate.test.Container, s in class org.hibernate.test.Simple where c.oneToMany[2] = s" );
 		parse( "select c from c in class org.hibernate.test.Container, s in class org.hibernate.test.Simple where c.manyToMany[2] = s" );
 		parse( "select c from c in class org.hibernate.test.Container, s in class org.hibernate.test.Simple where s = c.oneToMany[2]" );
 		parse( "select c from c in class org.hibernate.test.Container, s in class org.hibernate.test.Simple where s = c.manyToMany[2]" );
 		parse( "select c from c in class org.hibernate.test.Container where c.oneToMany[0].name = 's'" );
 		parse( "select c from c in class org.hibernate.test.Container where c.manyToMany[0].name = 's'" );
 		parse( "select c from c in class org.hibernate.test.Container where 's' = c.oneToMany[2 - 2].name" );
 		parse( "select c from c in class org.hibernate.test.Container where 's' = c.manyToMany[(3+1)/4-1].name" );
 		parse( "select c from c in class org.hibernate.test.Container where c.manyToMany[ maxindex(c.manyToMany) ].count = 2" );
 		parse( "select c from c in class org.hibernate.test.Container where c.oneToMany[ c.manyToMany[0].count ].name = 's'" );
 		parse( "select c from org.hibernate.test.Container c where c.manyToMany[ c.oneToMany[0].count ].name = 's'" );
 		parse( "select count(comp.name) from org.hibernate.test.Container c join c.components comp" );
 		parse( "from org.hibernate.test.Parent p left join fetch p.child" );
 		parse( "from org.hibernate.test.Parent p join p.child c where c.x > 0" );
 		parse( "from org.hibernate.test.Child c join c.parent p where p.x > 0" );
 		parse( "from org.hibernate.test.Child" );
 		parse( "from org.hibernate.test.MoreStuff" );
 		parse( "from org.hibernate.test.Many" );
 		parse( "from org.hibernate.test.Fee" );
 		parse( "from org.hibernate.test.Qux" );
 		parse( "from org.hibernate.test.Fumm" );
 		parse( "from org.hibernate.test.Parent" );
 		parse( "from org.hibernate.test.Simple" );
 		parse( "from org.hibernate.test.Holder" );
 		parse( "from org.hibernate.test.Part" );
 		parse( "from org.hibernate.test.Baz" );
 		parse( "from org.hibernate.test.Vetoer" );
 		parse( "from org.hibernate.test.Sortable" );
 		parse( "from org.hibernate.test.Contained" );
 		parse( "from org.hibernate.test.Circular" );
 		parse( "from org.hibernate.test.Stuff" );
 		parse( "from org.hibernate.test.Immutable" );
 		parse( "from org.hibernate.test.Container" );
 		parse( "from org.hibernate.test.One" );
 		parse( "from org.hibernate.test.Foo" );
 		parse( "from org.hibernate.test.Fo" );
 		parse( "from org.hibernate.test.Glarch" );
 		parse( "from org.hibernate.test.Fum" );
 		parse( "from org.hibernate.test.Glarch g" );
 		parse( "from org.hibernate.test.Part" );
 		parse( "from org.hibernate.test.Baz baz join baz.parts" );
 		parse( "from c in class org.hibernate.test.Child where c.parent.count=66" );
 		parse( "from org.hibernate.test.Parent p join p.child c where p.count=66" );
 		parse( "select c, c.parent from c in class org.hibernate.test.Child order by c.parent.count" );
 		parse( "select c, c.parent from c in class org.hibernate.test.Child where c.parent.count=66 order by c.parent.count" );
 		parse( "select c, c.parent, c.parent.count from c in class org.hibernate.test.Child order by c.parent.count" );
 		parse( "FROM p IN CLASS org.hibernate.test.Parent WHERE p.count = ?" );
 		parse( "select count(*) from org.hibernate.test.Container as c join c.components as ce join ce.simple as s where ce.name='foo'" );
 		parse( "select c, s from org.hibernate.test.Container as c join c.components as ce join ce.simple as s where ce.name='foo'" );
 		parse( "from s in class org.hibernate.test.Simple" );
 		parse( "from m in class org.hibernate.test.Many" );
 		parse( "from o in class org.hibernate.test.One" );
 		parse( "from c in class org.hibernate.test.Container" );
 		parse( "from o in class org.hibernate.test.Child" );
 		parse( "from o in class org.hibernate.test.MoreStuff" );
 		parse( "from o in class org.hibernate.test.Many" );
 		parse( "from o in class org.hibernate.test.Fee" );
 		parse( "from o in class org.hibernate.test.Qux" );
 		parse( "from o in class org.hibernate.test.Fumm" );
 		parse( "from o in class org.hibernate.test.Parent" );
 		parse( "from o in class org.hibernate.test.Simple" );
 		parse( "from o in class org.hibernate.test.Holder" );
 		parse( "from o in class org.hibernate.test.Part" );
 		parse( "from o in class org.hibernate.test.Baz" );
 		parse( "from o in class org.hibernate.test.Vetoer" );
 		parse( "from o in class org.hibernate.test.Sortable" );
 		parse( "from o in class org.hibernate.test.Contained" );
 		parse( "from o in class org.hibernate.test.Circular" );
 		parse( "from o in class org.hibernate.test.Stuff" );
 		parse( "from o in class org.hibernate.test.Immutable" );
 		parse( "from o in class org.hibernate.test.Container" );
 		parse( "from o in class org.hibernate.test.One" );
 		parse( "from o in class org.hibernate.test.Foo" );
 		parse( "from o in class org.hibernate.test.Fo" );
 		parse( "from o in class org.hibernate.test.Glarch" );
 		parse( "from o in class org.hibernate.test.Fum" );
 		parse( "from c in class org.hibernate.test.C2 where 1=1 or 1=1" );
 		parse( "from b in class org.hibernate.test.B" );
 		parse( "from a in class org.hibernate.test.A" );
 		parse( "from b in class org.hibernate.test.B" );
 		parse( "from org.hibernate.test.E e join e.reverse as b where b.count=1" );
 		parse( "from org.hibernate.test.E e join e.as as b where b.count=1" );
 		parse( "from org.hibernate.test.B" );
 		parse( "from org.hibernate.test.C1" );
 		parse( "from org.hibernate.test.C2" );
 		parse( "from org.hibernate.test.E e, org.hibernate.test.A a where e.reverse = a.forward and a = ?" );
 		parse( "from org.hibernate.test.E e join fetch e.reverse" );
 		parse( "from org.hibernate.test.E e" );
 		parse( "select max(s.count) from s in class org.hibernate.test.Simple" );
 		parse( "select new org.hibernate.test.S(s.count, s.address) from s in class org.hibernate.test.Simple" );
 		parse( "select max(s.count) from s in class org.hibernate.test.Simple" );
 		parse( "select count(*) from s in class org.hibernate.test.Simple" );
 		parse( "from s in class org.hibernate.test.Simple where s.name=:name and s.count=:count" );
 		parse( "from s in class org.hibernate.test.Simple where s.name in (:several0_, :several1_)" );
 		parse( "from s in class org.hibernate.test.Simple where s.name in (:stuff0_, :stuff1_)" );
 		parse( "from org.hibernate.test.Simple s where s.name=?" );
 		parse( "from org.hibernate.test.Simple s where s.name=:name" );
 		parse( "from s in class org.hibernate.test.Simple where upper( s.name ) ='SIMPLE 1'" );
 		parse( "from s in class org.hibernate.test.Simple where not( upper( s.name ) ='yada' or 1=2 or 'foo'='bar' or not('foo'='foo') or 'foo' like 'bar' )" );
 		parse( "from s in class org.hibernate.test.Simple where lower( s.name || ' foo' ) ='simple 1 foo'" );
 		parse( "from s in class org.hibernate.test.Simple where upper( s.other.name ) ='SIMPLE 2'" );
 		parse( "from s in class org.hibernate.test.Simple where not ( upper( s.other.name ) ='SIMPLE 2' )" );
 		parse( "select distinct s from s in class org.hibernate.test.Simple where ( ( s.other.count + 3 ) = (15*2)/2 and s.count = 69) or ( ( s.other.count + 2 ) / 7 ) = 2" );
 		parse( "select s from s in class org.hibernate.test.Simple where ( ( s.other.count + 3 ) = (15*2)/2 and s.count = 69) or ( ( s.other.count + 2 ) / 7 ) = 2 order by s.other.count" );
 		parse( "select sum(s.count) from s in class org.hibernate.test.Simple group by s.count having sum(s.count) > 10" );
 		parse( "select s.count from s in class org.hibernate.test.Simple group by s.count having s.count = 12" );
 		parse( "select s.id, s.count, count(t), max(t.date) from s in class org.hibernate.test.Simple, t in class org.hibernate.test.Simple where s.count = t.count group by s.id, s.count order by s.count" );
 		parse( "from s in class org.hibernate.test.Simple" );
 		parse( "from s in class org.hibernate.test.Simple where s.name = ?" );
 		parse( "from s in class org.hibernate.test.Simple where s.name = ? and upper(s.name) = ?" );
 		parse( "from s in class org.hibernate.test.Simple where s.name = :foo and upper(s.name) = :bar or s.count=:count or s.count=:count + 1" );
 		parse( "select s.id from s in class org.hibernate.test.Simple" );
 		parse( "select all s, s.other from s in class org.hibernate.test.Simple where s = :s" );
 		parse( "from s in class org.hibernate.test.Simple where s.name in (:name_list0_, :name_list1_) and s.count > :count" );
 		parse( "from org.hibernate.test.Simple s" );
 		parse( "from org.hibernate.test.Simple s" );
 		parse( "from org.hibernate.test.Assignable" );
 		parse( "from org.hibernate.test.Category" );
 		parse( "from org.hibernate.test.Simple" );
 		parse( "from org.hibernate.test.A" );
 		parse( "from foo in class org.hibernate.test.Foo where foo.string=?" );
 		parse( "from foo in class org.hibernate.test.Foo" );
 		parse( "from org.hibernate.test.Po po, org.hibernate.test.Lower low where low.mypo = po" );
 		parse( "from org.hibernate.test.Po po join po.set as sm where sm.amount > 0" );
 		parse( "from org.hibernate.test.Po po join po.top as low where low.foo = 'po'" );
 		parse( "from org.hibernate.test.SubMulti sm join sm.children smc where smc.name > 'a'" );
 		parse( "select s, ya from org.hibernate.test.Lower s join s.yetanother ya" );
 		parse( "from org.hibernate.test.Lower s1 join s1.bag s2" );
 		parse( "from org.hibernate.test.Lower s1 left join s1.bag s2" );
 		parse( "select s, a from org.hibernate.test.Lower s join s.another a" );
 		parse( "select s, a from org.hibernate.test.Lower s left join s.another a" );
 		parse( "from org.hibernate.test.Top s, org.hibernate.test.Lower ls" );
 		parse( "from org.hibernate.test.Lower ls join ls.set s where s.name > 'a'" );
 		parse( "from org.hibernate.test.Po po join po.list sm where sm.name > 'a'" );
 		parse( "from org.hibernate.test.Lower ls inner join ls.another s where s.name is not null" );
 		parse( "from org.hibernate.test.Lower ls where ls.other.another.name is not null" );
 		parse( "from org.hibernate.test.Multi m where m.derived like 'F%'" );
 		parse( "from org.hibernate.test.SubMulti m where m.derived like 'F%'" );
 		parse( "select s from org.hibernate.test.SubMulti as sm join sm.children as s where s.amount>-1 and s.name is null" );
 		parse( "select elements(sm.children) from org.hibernate.test.SubMulti as sm" );
 		parse( "select distinct sm from org.hibernate.test.SubMulti as sm join sm.children as s where s.amount>-1 and s.name is null" );
 		parse( "select distinct s from s in class org.hibernate.test.SubMulti where s.moreChildren[1].amount < 1.0" );
 		parse( "from s in class org.hibernate.test.TrivialClass where s.id = 2" );
 		parse( "select s.count from s in class org.hibernate.test.Top" );
 		parse( "from s in class org.hibernate.test.Lower where s.another.name='name'" );
 		parse( "from s in class org.hibernate.test.Lower where s.yetanother.name='name'" );
 		parse( "from s in class org.hibernate.test.Lower where s.yetanother.name='name' and s.yetanother.foo is null" );
 		parse( "from s in class org.hibernate.test.Top where s.count=1" );
 		parse( "select s.count from s in class org.hibernate.test.Top, ls in class org.hibernate.test.Lower where ls.another=s" );
 		parse( "select elements(ls.bag), elements(ls.set) from ls in class org.hibernate.test.Lower" );
 		parse( "from s in class org.hibernate.test.Lower" );
 		parse( "from s in class org.hibernate.test.Top" );
 		parse( "from sm in class org.hibernate.test.SubMulti" );
 		parse( "select\n" +
 				"\n" +
 				"s from s in class org.hibernate.test.Top where s.count>0" );
 		parse( "from m in class org.hibernate.test.Multi where m.count>0 and m.extraProp is not null" );
 		parse( "from m in class org.hibernate.test.Top where m.count>0 and m.name is not null" );
 		parse( "from m in class org.hibernate.test.Lower where m.other is not null" );
 		parse( "from m in class org.hibernate.test.Multi where m.other.id = 1" );
 		parse( "from m in class org.hibernate.test.SubMulti where m.amount > 0.0" );
 		parse( "from m in class org.hibernate.test.Multi" );
 		parse( "from m in class org.hibernate.test.Multi where m.class = SubMulti" );
 		parse( "from m in class org.hibernate.test.Top where m.class = Multi" );
 		parse( "from s in class org.hibernate.test.Top" );
 		parse( "from ls in class org.hibernate.test.Lower" );
 		parse( "from ls in class org.hibernate.test.Lower, s in elements(ls.bag) where s.id is not null" );
 		parse( "from ls in class org.hibernate.test.Lower, s in elements(ls.set) where s.id is not null" );
 		parse( "from o in class org.hibernate.test.Top" );
 		parse( "from o in class org.hibernate.test.Po" );
 		parse( "from ChildMap cm where cm.parent is not null" );
 		parse( "from ParentMap cm where cm.child is not null" );
 		parse( "from org.hibernate.test.Componentizable" );
 	}
 
 	public void testUnnamedParameter() throws Exception {
 		parse( "select foo, bar from org.hibernate.test.Foo foo left outer join foo.foo bar where foo = ?" ); // Added '?' as a valid expression.
 	}
 
 	public void testInElements() throws Exception {
 		parse( "from bar in class org.hibernate.test.Bar, foo in elements(bar.baz.fooArray)" );   // Added collectionExpr as a valid 'in' clause.
 	}
 
 	public void testDotElements() throws Exception {
 		parse( "select distinct foo from baz in class org.hibernate.test.Baz, foo in elements(baz.fooArray)" );
 		parse( "select foo from baz in class org.hibernate.test.Baz, foo in elements(baz.fooSet)" );
 		parse( "select foo from baz in class org.hibernate.test.Baz, foo in elements(baz.fooArray)" );
 		parse( "from org.hibernate.test.Baz baz where 'b' in elements(baz.collectionComponent.nested.foos) and 1.0 in elements(baz.collectionComponent.nested.floats)" );
 	}
 
 	public void testSelectAll() throws Exception {
 		parse( "select all s, s.other from s in class org.hibernate.test.Simple where s = :s" );
 	}
 
 	public void testNot() throws Exception {
 		// Cover NOT optimization in HqlParser
 		parse( "from eg.Cat cat where not ( cat.kittens.size < 1 )" );
 		parse( "from eg.Cat cat where not ( cat.kittens.size > 1 )" );
 		parse( "from eg.Cat cat where not ( cat.kittens.size >= 1 )" );
 		parse( "from eg.Cat cat where not ( cat.kittens.size <= 1 )" );
 		parse( "from eg.DomesticCat cat where not ( cat.name between 'A' and 'B' ) " );
 		parse( "from eg.DomesticCat cat where not ( cat.name not between 'A' and 'B' ) " );
 		parse( "from eg.Cat cat where not ( not cat.kittens.size <= 1 )" );
 		parse( "from eg.Cat cat where not  not ( not cat.kittens.size <= 1 )" );
 	}
 
 	public void testOtherSyntax() throws Exception {
 		parse( "select bar from org.hibernate.test.Bar bar order by ((bar.x - :valueX)*(bar.x - :valueX))" );
 		parse( "from bar in class org.hibernate.test.Bar, foo in elements(bar.baz.fooSet)" );
 		parse( "from one in class org.hibernate.test.One, many in elements(one.manies) where one.id = 1 and many.id = 1" );
 		parse( "from org.hibernate.test.Inner _inner join _inner.middles middle" );
 		parse( "FROM m IN CLASS org.hibernate.test.Master WHERE NOT EXISTS ( FROM d IN elements(m.details) WHERE NOT d.i=5 )" );
 		parse( "FROM m IN CLASS org.hibernate.test.Master WHERE NOT 5 IN ( SELECT d.i FROM d IN elements(m.details) )" );
 		parse( "SELECT m FROM m IN CLASS org.hibernate.test.Master, d IN elements(m.details) WHERE d.i=5" );
 		parse( "SELECT m FROM m IN CLASS org.hibernate.test.Master, d IN elements(m.details) WHERE d.i=5" );
 		parse( "SELECT m.id FROM m IN CLASS org.hibernate.test.Master, d IN elements(m.details) WHERE d.i=5" );
 		// I'm not sure about these... [jsd]
 //        parse("select bar.string, foo.string from bar in class org.hibernate.test.Bar inner join bar.baz as baz inner join elements(baz.fooSet) as foo where baz.name = 'name'");
 //        parse("select bar.string, foo.string from bar in class org.hibernate.test.Bar, bar.baz as baz, elements(baz.fooSet) as foo where baz.name = 'name'");
 //        parse("select count(*) where this.amount>-1 and this.name is null");
 //        parse("from sm in class org.hibernate.test.SubMulti where exists sm.children.elements");
 	}
 
 	public void testEjbqlExtensions() throws Exception {
 		parse( "select object(a) from Animal a where a.mother member of a.offspring" );
 		parse( "select object(a) from Animal a where a.mother member a.offspring" ); //no member of
 		parse( "select object(a) from Animal a where a.offspring is empty" );
 	}
 
 	public void testEmptyFilter() throws Exception {
 		parseFilter( "" );  //  Blank is a legitimate filter.
 	}
 
 	public void testOrderByFilter() throws Exception {
 		parseFilter( "order by this.id" );
 	}
 
 	public void testRestrictionFilter() throws Exception {
 		parseFilter( "where this.name = ?" );
 	}
 
 	public void testNoFrom() throws Exception {
 		System.out.println( "***** This test ensures that an error is detected ERROR MESSAGES ARE OKAY!  *****" );
 		HqlParser parser = HqlParser.getInstance( "" );
 		parser.setFilter( false );
 		parser.statement();
 		assertEquals( "Parser allowed no FROM clause!", 1, parser.getParseErrorHandler().getErrorCount() );
 		System.out.println( "***** END OF ERROR TEST  *****" );
 	}
 
 	public void testHB1042() throws Exception {
 		parse( "select x from fmc_web.pool.Pool x left join x.containers c0 where (upper(x.name) = upper(':') and c0.id = 1)" );
 	}
 
 	public void testKeywordInPath() throws Exception {
 		// The keyword 'order' used as a property name.
 		parse( "from Customer c where c.order.status = 'argh'" );
 		// The keyword 'order' and 'count' used as a property name.
 		parse( "from Customer c where c.order.count > 3" );
 		// The keywords 'where', 'order' and 'count' used as a property name.
 		parse( "select c.where from Customer c where c.order.count > 3" );
 		parse( "from Interval i where i.end <:end" );
 		parse( "from Letter l where l.case = :case" );
 	}
 
 	public void testPathologicalKeywordAsIdentifier() throws Exception {
 		// Super evil badness... a legitimate keyword!
 		parse( "from Order order" );
 		//parse( "from Order order join order.group" );
 		parse( "from X x order by x.group.by.from" );
 		parse( "from Order x order by x.order.group.by.from" );
 		parse( "select order.id from Order order" );
 		parse( "select order from Order order" );
 		parse( "from Order order where order.group.by.from is not null" );
 		parse( "from Order order order by order.group.by.from" );
 		// Okay, now this is getting silly.
 		parse( "from Group as group group by group.by.from" );
 	}
 
     public void testHHH354() throws Exception {
         parse( "from Foo f where f.full = 'yep'");
     }
 
     public void testWhereAsIdentifier() throws Exception {
         // 'where' as a package name
         parse( "from where.Order" );
     }
 
 	public void testEjbqlKeywordsAsIdentifier() throws Exception {
 		parse( "from org.hibernate.test.Bar bar where bar.object.id = ? and bar.object.class = ?" );
 	}
 
 	public void testConstructorIn() throws Exception {
 		parse( "from org.hibernate.test.Bar bar where (b.x, b.y, b.z) in (select foo, bar, baz from org.hibernate.test.Foo)" );
 	}
 
     public void testMultiByteCharacters() throws Exception {
         parse ("from User user where user.name like '%nn\u4e2dnn%'");
         // Test for HHH-558
         parse ("from User user where user.\u432d like '%\u4e2d%'");
         parse ("from \u432d \u432d where \u432d.name like '%fred%'");        
     }
 
     public void testHHH719() throws Exception {
         // Some SQLs have function names with package qualifiers.
         parse("from Foo f order by com.fooco.SpecialFunction(f.id)");
     }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/QueryTranslatorTestCase.java b/hibernate-core/src/test/java/org/hibernate/test/hql/QueryTranslatorTestCase.java
index 1143fba08a..c982844abe 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/QueryTranslatorTestCase.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/QueryTranslatorTestCase.java
@@ -1,307 +1,307 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
 
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.TreeMap;
 
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.engine.query.spi.HQLQueryPlan;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.hql.QueryTranslator;
-import org.hibernate.hql.QueryTranslatorFactory;
-import org.hibernate.hql.ast.ASTQueryTranslatorFactory;
-import org.hibernate.hql.ast.QueryTranslatorImpl;
-import org.hibernate.hql.ast.util.ASTPrinter;
-import org.hibernate.hql.classic.ClassicQueryTranslatorFactory;
+import org.hibernate.hql.spi.QueryTranslator;
+import org.hibernate.hql.spi.QueryTranslatorFactory;
+import org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory;
+import org.hibernate.hql.internal.ast.QueryTranslatorImpl;
+import org.hibernate.hql.internal.ast.util.ASTPrinter;
+import org.hibernate.hql.internal.classic.ClassicQueryTranslatorFactory;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.type.Type;
 
 import junit.framework.ComparisonFailure;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 public abstract class QueryTranslatorTestCase extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] {
 				"hql/Animal.hbm.xml",
 				"hql/EntityWithCrazyCompositeKey.hbm.xml",
 				"hql/CrazyIdFieldNames.hbm.xml",
 				"hql/SimpleEntityWithAssociation.hbm.xml",
 				"hql/ComponentContainer.hbm.xml",
 				"batchfetch/ProductLine.hbm.xml",
 				"cid/Customer.hbm.xml",
 				"cid/Order.hbm.xml",
 				"cid/LineItem.hbm.xml",
 				"cid/Product.hbm.xml",
 				"legacy/Baz.hbm.xml",
 				"legacy/Category.hbm.xml",
 				"legacy/Commento.hbm.xml",
 				"legacy/Container.hbm.xml",
 				"legacy/Custom.hbm.xml",
 				"legacy/Eye.hbm.xml",
 				"legacy/Fee.hbm.xml",
 				"legacy/FooBar.hbm.xml",
 				"legacy/Fum.hbm.xml",
 				"legacy/Glarch.hbm.xml",
 				"legacy/Holder.hbm.xml",
 				"legacy/Many.hbm.xml",
 				"legacy/Marelo.hbm.xml",
 				"legacy/MasterDetail.hbm.xml",
 				"legacy/Middle.hbm.xml",
 				"legacy/Multi.hbm.xml",
 				"legacy/Nameable.hbm.xml",
 				"legacy/One.hbm.xml",
 				"legacy/Qux.hbm.xml",
 				"legacy/Simple.hbm.xml",
 				"legacy/SingleSeveral.hbm.xml",
 				"legacy/WZ.hbm.xml",
 				"legacy/UpDown.hbm.xml",
 				"compositeelement/Parent.hbm.xml",
 				"onetoone/joined/Person.hbm.xml",
 				"any/Properties.hbm.xml"
 		};
 	}
 
 	@Override
 	public boolean createSchema() {
 		return false;
 	}
 
 	@Override
 	public boolean rebuildSessionFactoryOnError() {
 		return false;
 	}
 
 	public void assertTranslation(String hql) throws QueryException, MappingException {
 		assertTranslation( hql, null );
 	}
 
 	protected void assertTranslation(String hql, Map replacements) {
 		ComparisonFailure cf = null;
 		try {
 			assertTranslation( hql, replacements, false, null );
 		}
 		catch ( ComparisonFailure e ) {
 			e.printStackTrace();
 			cf = e;
 		}
 		if ("false".equals(System.getProperty("org.hibernate.test.hql.SkipScalarQuery","false"))) {
 			// Run the scalar translation anyway, even if there was a comparison failure.
 			assertTranslation( hql, replacements, true, null );
 		}
 		if (cf != null)
 			throw cf;
 	}
 
 	protected void assertTranslation(String hql, Map replacements, boolean scalar, String sql) {
 		SessionFactoryImplementor factory = sessionFactory();
 
 		// Create an empty replacements map if we don't have one.
 		if ( replacements == null ) {
 			replacements = new HashMap();
 		}
 
 		// steve -> note that the empty maps here represent the currently enabled filters...
 		QueryTranslator oldQueryTranslator = null;
 		Exception oldException = null;
 		try {
 			System.out.println("Compiling with classic QueryTranslator...");
 			QueryTranslatorFactory classic = new ClassicQueryTranslatorFactory();
 			oldQueryTranslator = classic.createQueryTranslator( hql, hql, Collections.EMPTY_MAP, factory );
 			oldQueryTranslator.compile( replacements, scalar );
 		}
 		catch ( QueryException e ) {
 			oldException = e;
 		}
 		catch ( MappingException e ) {
 			oldException = e;
 		}
 
 		QueryTranslator newQueryTranslator = null;
 		Exception newException = null;
 		try {
 			System.out.println("Compiling with AST QueryTranslator...");
 			newQueryTranslator = createNewQueryTranslator( hql, replacements, scalar );
 		}
 		catch ( QueryException e ) {
 			newException = e;
 		}
 		catch ( MappingException e ) {
 			newException = e;
 		}
 
 		// If the old QT threw an exception, the new one should too.
 		if ( oldException != null ) {
 			assertNotNull( "New query translator did *NOT* throw an exception, the old one did : " + oldException, newException );
 			assertEquals( oldException.getMessage(), newException.getMessage() );
 			return;	// Don't bother with the rest of the assertions.
 		}
 		else if ( newException != null ) {
 			newException.printStackTrace();
 			assertNull( "Old query translator did not throw an exception, the new one did", newException );
 		}
 
 		// -- check all of the outputs --
 		checkSql( oldQueryTranslator, newQueryTranslator, hql, scalar, sql );
 		checkQuerySpaces( oldQueryTranslator, newQueryTranslator );
 		checkReturnedTypes( oldQueryTranslator, newQueryTranslator );
 
 	}
 
 	protected QueryTranslatorImpl createNewQueryTranslator(String hql, Map replacements, boolean scalar) {
 		SessionFactoryImplementor factory = sessionFactory();
 		return createNewQueryTranslator( hql, replacements, scalar, factory );
 	}
 
 	private QueryTranslatorImpl createNewQueryTranslator(String hql, Map replacements, boolean scalar, SessionFactoryImplementor factory) {
 		QueryTranslatorFactory ast = new ASTQueryTranslatorFactory();
 		QueryTranslatorImpl newQueryTranslator = ( QueryTranslatorImpl ) ast.createQueryTranslator( hql, hql, Collections.EMPTY_MAP, factory );
 		newQueryTranslator.compile( replacements, scalar );
 		return newQueryTranslator;
 	}
 
 	protected QueryTranslatorImpl createNewQueryTranslator(String hql) {
 		return createNewQueryTranslator( hql, new HashMap(), false );
 	}
 
 	protected QueryTranslatorImpl createNewQueryTranslator(String hql, SessionFactoryImplementor sfimpl) {
 		return createNewQueryTranslator( hql, new HashMap(), false, sfimpl );
 	}
 
 	protected HQLQueryPlan createQueryPlan(String hql, boolean scalar) {
 		return new HQLQueryPlan( hql, scalar, Collections.EMPTY_MAP, sessionFactory() );
 	}
 
 	protected HQLQueryPlan createQueryPlan(String hql) {
 		return createQueryPlan( hql, false );
 	}
 
 	@Deprecated
 	protected SessionFactoryImplementor getSessionFactoryImplementor() {
 		return sessionFactory();
 	}
 
 	private void checkReturnedTypes(QueryTranslator oldQueryTranslator, QueryTranslator newQueryTranslator) {
 		// Check the returned types for a regression.
 		Type[] oldReturnTypes = oldQueryTranslator.getReturnTypes();
 		Type[] returnTypes = newQueryTranslator.getReturnTypes();
 		assertEquals( "Return types array is not the right length!", oldReturnTypes.length, returnTypes.length );
 		for ( int i = 0; i < returnTypes.length; i++ ) {
 			assertNotNull( returnTypes[i] );
 			assertNotNull( oldReturnTypes[i] );
 			assertEquals( "Returned types did not match!", oldReturnTypes[i].getReturnedClass(), returnTypes[i].getReturnedClass() );
 			System.out.println("returnedType[" + i + "] = " + returnTypes[i] + " oldReturnTypes[" + i + "] = " + oldReturnTypes[i]);
 		}
 	}
 
 	private void checkQuerySpaces(QueryTranslator oldQueryTranslator, QueryTranslator newQueryTranslator) {
 		// Check the query spaces for a regression.
 		Set oldQuerySpaces = oldQueryTranslator.getQuerySpaces();
 		Set querySpaces = newQueryTranslator.getQuerySpaces();
 		assertEquals( "Query spaces is not the right size!", oldQuerySpaces.size(), querySpaces.size() );
 		for ( Object o : oldQuerySpaces ) {
 			assertTrue( "New query space does not contain " + o + "!", querySpaces.contains( o ) );
 		}
 	}
 
 	protected Exception compileBadHql(String hql, boolean scalar) {
 		QueryTranslator newQueryTranslator;
 		Map replacements = null;
 		Exception newException = null;
 		SessionFactoryImplementor factory = sessionFactory();
 		try {
 			QueryTranslatorFactory ast = new ASTQueryTranslatorFactory();
 			newQueryTranslator = ast.createQueryTranslator( hql, hql, Collections.EMPTY_MAP, factory );
 			newQueryTranslator.compile( replacements, scalar );
 		}
 		catch ( QueryException e ) {
 			newException = e;
 		}
 		catch ( MappingException e ) {
 			newException = e;
 		}
 		assertNotNull( "Expected exception from compilation of '" + hql + "'!", newException );
 		return newException;
 	}
 
 	private void checkSql(QueryTranslator oldQueryTranslator, QueryTranslator newQueryTranslator, String hql, boolean scalar, String sql) {
 
 		String oldsql = oldQueryTranslator.getSQLString();
 		String newsql = newQueryTranslator.getSQLString();
 		System.out.println( "HQL    : " + ASTPrinter.escapeMultibyteChars(hql) );
 		System.out.println( "OLD SQL: " + ASTPrinter.escapeMultibyteChars(oldsql) );
 		System.out.println( "NEW SQL: " + ASTPrinter.escapeMultibyteChars(newsql) );
 		if ( sql == null ) {
 			// Check the generated SQL.                                          ASTPrinter.escapeMultibyteChars(
 			assertSQLEquals( "SQL is not the same as the old SQL (scalar=" + scalar + ")", oldsql, newsql );
 		}
 		else {
 			assertSQLEquals( "SQL is not the same as the expected SQL (scalar=" + scalar + ")", sql, newsql );
 		}
 	}
 
 	private void assertSQLEquals(String message, String oldsql, String newsql) {
 		Map oldMap = getTokens(oldsql);
 		Map newMap = getTokens(newsql);
 		if ( !oldMap.equals(newMap) ) {
 			assertEquals(message, oldsql, newsql);
 		}
 	}
 
 	
 	@SuppressWarnings( {"UnnecessaryBoxing", "UnnecessaryUnboxing"})
 	private Map getTokens(String sql) {
 		Map<String,Integer> result = new TreeMap<String,Integer>();
 		if ( sql == null ) {
 			return result;
 		}
 		result.put( "=", Integer.valueOf( StringHelper.countUnquoted( sql, '=' ) ) );
 		StringTokenizer tokenizer = new StringTokenizer( sql, "(),= " );
 		while ( tokenizer.hasMoreTokens() ) {
 			String fragment = tokenizer.nextToken();
 			/*if ( "on".equals(fragment) ) fragment = "and";
 			if ( "join".equals(fragment) || "inner".equals(fragment) ) continue;*/
 			Integer count = result.get(fragment);
 			if ( count == null ) {
 				count = Integer.valueOf(1);
 			}
 			else {
 				count = Integer.valueOf( count.intValue() + 1 );
 			}
 			result.put(fragment, count);
 		}
 		return result;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/WithClauseTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/WithClauseTest.java
index f080467b69..74f97973f0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/WithClauseTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/WithClauseTest.java
@@ -1,213 +1,213 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
-import org.hibernate.hql.ast.InvalidWithClauseException;
+import org.hibernate.hql.internal.ast.InvalidWithClauseException;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * Implementation of WithClauseTest.
  *
  * @author Steve Ebersole
  */
 public class WithClauseTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] { "hql/Animal.hbm.xml" };
 	}
 
 	@Test
 	public void testWithClauseFailsWithFetch() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 
 		try {
 			s.createQuery( "from Animal a inner join fetch a.offspring as o with o.bodyWeight = :someLimit" )
 			        .setDouble( "someLimit", 1 )
 			        .list();
 			fail( "ad-hoc on clause allowed with fetched association" );
 		}
 		catch ( HibernateException e ) {
 			// the expected response...
 		}
 
 		txn.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testInvalidWithSemantics() {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 
 		try {
 			// PROBLEM : f.bodyWeight is a reference to a column on the Animal table; however, the 'f'
 			// alias relates to the Human.friends collection which the aonther Human entity.  The issue
 			// here is the way JoinSequence and Joinable (the persister) interact to generate the
 			// joins relating to the sublcass/superclass tables
 			s.createQuery( "from Human h inner join h.friends as f with f.bodyWeight < :someLimit" )
 					.setDouble( "someLimit", 1 )
 					.list();
 			fail( "failure expected" );
 		}
 		catch( InvalidWithClauseException expected ) {
 		}
 
 		try {
 			s.createQuery( "from Animal a inner join a.offspring o inner join o.mother as m inner join m.father as f with o.bodyWeight > 1" )
 					.list();
 			fail( "failure expected" );
 		}
 		catch( InvalidWithClauseException expected ) {
 		}
 
 		try {
 			s.createQuery( "from Human h inner join h.offspring o with o.mother.father = :cousin" )
 					.setEntity( "cousin", s.load( Human.class, new Long(123) ) )
 					.list();
 			fail( "failure expected" );
 		}
 		catch( InvalidWithClauseException expected ) {
 		}
 
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testWithClause() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 
 		// one-to-many
 		List list = s.createQuery( "from Human h inner join h.offspring as o with o.bodyWeight < :someLimit" )
 				.setDouble( "someLimit", 1 )
 				.list();
 		assertTrue( "ad-hoc on did not take effect", list.isEmpty() );
 
 		// many-to-one
 		list = s.createQuery( "from Animal a inner join a.mother as m with m.bodyWeight < :someLimit" )
 				.setDouble( "someLimit", 1 )
 				.list();
 		assertTrue( "ad-hoc on did not take effect", list.isEmpty() );
 
 		// many-to-many
 		list = s.createQuery( "from Human h inner join h.friends as f with f.nickName like 'bubba'" )
 				.list();
 		assertTrue( "ad-hoc on did not take effect", list.isEmpty() );
 
 		// http://opensource.atlassian.com/projects/hibernate/browse/HHH-1930
 		list = s.createQuery( "from Human h inner join h.nickNames as nicknames with nicknames = 'abc'" )
 				.list();
 		assertTrue( "ad-hoc on did not take effect", list.isEmpty() );
 
 		txn.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	private class TestData {
 		public void prepare() {
 			Session session = openSession();
 			Transaction txn = session.beginTransaction();
 
 			Human mother = new Human();
 			mother.setBodyWeight( 10 );
 			mother.setDescription( "mother" );
 
 			Human father = new Human();
 			father.setBodyWeight( 15 );
 			father.setDescription( "father" );
 
 			Human child1 = new Human();
 			child1.setBodyWeight( 5 );
 			child1.setDescription( "child1" );
 
 			Human child2 = new Human();
 			child2.setBodyWeight( 6 );
 			child2.setDescription( "child2" );
 
 			Human friend = new Human();
 			friend.setBodyWeight( 20 );
 			friend.setDescription( "friend" );
 
 			child1.setMother( mother );
 			child1.setFather( father );
 			mother.addOffspring( child1 );
 			father.addOffspring( child1 );
 
 			child2.setMother( mother );
 			child2.setFather( father );
 			mother.addOffspring( child2 );
 			father.addOffspring( child2 );
 
 			father.setFriends( new ArrayList() );
 			father.getFriends().add( friend );
 
 			session.save( mother );
 			session.save( father );
 			session.save( child1 );
 			session.save( child2 );
 			session.save( friend );
 
 			txn.commit();
 			session.close();
 		}
 
 		public void cleanup() {
 			Session session = openSession();
 			Transaction txn = session.beginTransaction();
 			Human father = (Human) session.createQuery( "from Human where description = 'father'" ).uniqueResult();
 			father.getFriends().clear();
 			session.flush();
 			session.delete( session.createQuery( "from Human where description = 'friend'" ).uniqueResult() );
 			session.delete( session.createQuery( "from Human where description = 'child1'" ).uniqueResult() );
 			session.delete( session.createQuery( "from Human where description = 'child2'" ).uniqueResult() );
 			session.delete( session.createQuery( "from Human where description = 'mother'" ).uniqueResult() );
 			session.delete( father );
 			session.createQuery( "delete Animal" ).executeUpdate();
 			txn.commit();
 			session.close();
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/LegacyTestCase.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/LegacyTestCase.java
index 77123cc672..fd7b34b2e3 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/LegacyTestCase.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/LegacyTestCase.java
@@ -1,109 +1,109 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
 
 import org.hibernate.Query;
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.DefaultNamingStrategy;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.Dialect;
-import org.hibernate.hql.classic.ClassicQueryTranslatorFactory;
+import org.hibernate.hql.internal.classic.ClassicQueryTranslatorFactory;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.type.Type;
 
 import org.junit.Before;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 /**
  * @author Steve Ebersole
  */
 public abstract class LegacyTestCase extends BaseCoreFunctionalTestCase {
 	public static final String USE_ANTLR_PARSER_PROP = "legacy.use_antlr_hql_parser";
 
 	private boolean useAntlrParser;
 
 	@Before
 	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	public void checkAntlrParserSetting() {
 		useAntlrParser = Boolean.valueOf( extractFromSystem( USE_ANTLR_PARSER_PROP ) ).booleanValue();
 	}
 
 	protected static String extractFromSystem(String systemPropertyName) {
 		try {
 			return System.getProperty( systemPropertyName );
 		}
 		catch( Throwable t ) {
 			return null;
 		}
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		if ( !useAntlrParser ) {
 			cfg.setProperty( Environment.QUERY_TRANSLATOR, ClassicQueryTranslatorFactory.class.getName() );
 			try {
 				String dialectTrueRepresentation = Dialect.getDialect().toBooleanValueString( true );
 				// if this call succeeds, then the dialect is saying to represent true/false as int values...
 				Integer.parseInt( dialectTrueRepresentation );
 				String subs = cfg.getProperties().getProperty( Environment.QUERY_SUBSTITUTIONS );
 				if ( subs == null ) {
 					subs = "";
 				}
 				if ( StringHelper.isEmpty( subs ) ) {
 					subs = "true=1, false=0";
 				}
 				else {
 					subs += ", true=1, false=0";
 				}
 				cfg.getProperties().setProperty( Environment.QUERY_SUBSTITUTIONS, subs );
 				cfg.setNamingStrategy( DefaultNamingStrategy.INSTANCE );
 			}
 			catch( NumberFormatException nfe ) {
 				// the Integer#parseInt call failed...
 			}
 		}
 	}
 
 	protected int doDelete(Session session, String queryString) {
 		return doDelete( session, session.createQuery( queryString ) );
 	}
 
 	protected int doDelete(Session session, String queryString, Object param, Type paramType) {
 		Query query = session.createQuery( queryString )
 				.setParameter( 0, param, paramType );
 		return doDelete( session, query );
 	}
 
 	protected int doDelete(Session session, Query selectQuery) {
 		int count = 0;
 		for ( Object o : selectQuery.list() ) {
 			session.delete( o );
 			count++;
 		}
 		return count;
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/AbstractQueryImpl.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/AbstractQueryImpl.java
index d14bd4488b..88df1b9b3e 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/AbstractQueryImpl.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/AbstractQueryImpl.java
@@ -1,412 +1,412 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
  * third-party contributors as indicated by either @author tags or express
  * copyright attribution statements applied by the authors.  All
  * third-party contributions are distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb;
 import static org.hibernate.ejb.QueryHints.HINT_CACHEABLE;
 import static org.hibernate.ejb.QueryHints.HINT_CACHE_MODE;
 import static org.hibernate.ejb.QueryHints.HINT_CACHE_REGION;
 import static org.hibernate.ejb.QueryHints.HINT_COMMENT;
 import static org.hibernate.ejb.QueryHints.HINT_FETCH_SIZE;
 import static org.hibernate.ejb.QueryHints.HINT_FLUSH_MODE;
 import static org.hibernate.ejb.QueryHints.HINT_READONLY;
 import static org.hibernate.ejb.QueryHints.HINT_TIMEOUT;
 import static org.hibernate.ejb.QueryHints.SPEC_HINT_TIMEOUT;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 import javax.persistence.CacheRetrieveMode;
 import javax.persistence.CacheStoreMode;
 import javax.persistence.FlushModeType;
 import javax.persistence.Parameter;
 import javax.persistence.TransactionRequiredException;
 import javax.persistence.TypedQuery;
 import org.hibernate.CacheMode;
 import org.hibernate.FlushMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.TypeMismatchException;
 import org.hibernate.ejb.internal.EntityManagerMessageLogger;
 import org.hibernate.ejb.util.CacheModeHelper;
 import org.hibernate.ejb.util.ConfigurationHelper;
 import org.hibernate.ejb.util.LockModeTypeHelper;
-import org.hibernate.hql.QueryExecutionRequestException;
+import org.hibernate.hql.internal.QueryExecutionRequestException;
 import org.jboss.logging.Logger;
 
 /**
  * Intended as a base class providing convenience in implementing both {@link javax.persistence.Query} and
  * {@link javax.persistence.TypedQuery}.
  * <p/>
  * IMPL NOTE : This issue, and the reason for this distinction, is that criteria and hl.sql queries share no
  * commonality currently in Hibernate internals.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractQueryImpl<X> implements TypedQuery<X> {
 
     private static final EntityManagerMessageLogger LOG = Logger.getMessageLogger(EntityManagerMessageLogger.class,
                                                                            AbstractQueryImpl.class.getName());
 
 	private final HibernateEntityManagerImplementor entityManager;
 
 	public AbstractQueryImpl(HibernateEntityManagerImplementor entityManager) {
 		this.entityManager = entityManager;
 	}
 
 	protected HibernateEntityManagerImplementor getEntityManager() {
 		return entityManager;
 	}
 
 	/**
 	 * Actually execute the update; all pre-requisites have been checked.
 	 *
 	 * @return The number of "affected rows".
 	 */
 	protected abstract int internalExecuteUpdate();
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@SuppressWarnings({ "ThrowableInstanceNeverThrown" })
 	public int executeUpdate() {
 		try {
 			if ( ! entityManager.isTransactionInProgress() ) {
 				entityManager.throwPersistenceException( new TransactionRequiredException( "Executing an update/delete query" ) );
 				return 0;
 			}
 			return internalExecuteUpdate();
 		}
 		catch ( QueryExecutionRequestException he) {
 			throw new IllegalStateException(he);
 		}
 		catch( TypeMismatchException e ) {
 			throw new IllegalArgumentException(e);
 		}
 		catch ( HibernateException he) {
 			entityManager.throwPersistenceException( he );
 			return 0;
 		}
 	}
 
 	private int maxResults = -1;
 
 	/**
 	 * Apply the given max results value.
 	 *
 	 * @param maxResults The specified max results
 	 */
 	protected abstract void applyMaxResults(int maxResults);
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public TypedQuery<X> setMaxResults(int maxResult) {
 		if ( maxResult < 0 ) {
 			throw new IllegalArgumentException(
 					"Negative value (" + maxResult + ") passed to setMaxResults"
 			);
 		}
 		this.maxResults = maxResult;
 		applyMaxResults( maxResult );
 		return this;
 	}
 
 	public int getSpecifiedMaxResults() {
 		return maxResults;
 	}
 
 	public int getMaxResults() {
 		return maxResults == -1
 				? Integer.MAX_VALUE // stupid spec... MAX_VALUE??
 				: maxResults;
 	}
 
 	private int firstResult;
 
 	/**
 	 * Apply the given first-result value.
 	 *
 	 * @param firstResult The specified first-result value.
 	 */
 	protected abstract void applyFirstResult(int firstResult);
 
 	public TypedQuery<X> setFirstResult(int firstResult) {
 		if ( firstResult < 0 ) {
 			throw new IllegalArgumentException(
 					"Negative value (" + firstResult + ") passed to setFirstResult"
 			);
 		}
 		this.firstResult = firstResult;
 		applyFirstResult( firstResult );
 		return this;
 	}
 
 	public int getFirstResult() {
 		return firstResult;
 	}
 
 	private Map<String, Object> hints;
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Map<String, Object> getHints() {
 		return hints;
 	}
 
 	protected abstract void applyTimeout(int timeout);
 
 	protected abstract void applyComment(String comment);
 
 	protected abstract void applyFetchSize(int fetchSize);
 
 	protected abstract void applyCacheable(boolean isCacheable);
 
 	protected abstract void applyCacheRegion(String regionName);
 
 	protected abstract void applyReadOnly(boolean isReadOnly);
 
 	protected abstract void applyCacheMode(CacheMode cacheMode);
 
 	protected abstract void applyFlushMode(FlushMode flushMode);
 
 	protected abstract boolean canApplyLockModes();
 
 	protected abstract void applyAliasSpecificLockMode(String alias, LockMode lockMode);
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public TypedQuery<X> setHint(String hintName, Object value) {
 		boolean skipped = false;
 		try {
 			if ( HINT_TIMEOUT.equals( hintName ) ) {
 				applyTimeout( ConfigurationHelper.getInteger( value ) );
 			}
 			else if ( SPEC_HINT_TIMEOUT.equals( hintName ) ) {
 				// convert milliseconds to seconds
 				int timeout = (int)Math.round(ConfigurationHelper.getInteger( value ).doubleValue() / 1000.0 );
 				applyTimeout( new Integer(timeout) );
 			}
 			else if ( HINT_COMMENT.equals( hintName ) ) {
 				applyComment( (String) value );
 			}
 			else if ( HINT_FETCH_SIZE.equals( hintName ) ) {
 				applyFetchSize( ConfigurationHelper.getInteger( value ) );
 			}
 			else if ( HINT_CACHEABLE.equals( hintName ) ) {
 				applyCacheable( ConfigurationHelper.getBoolean( value ) );
 			}
 			else if ( HINT_CACHE_REGION.equals( hintName ) ) {
 				applyCacheRegion( (String) value );
 			}
 			else if ( HINT_READONLY.equals( hintName ) ) {
 				applyReadOnly( ConfigurationHelper.getBoolean( value ) );
 			}
 			else if ( HINT_CACHE_MODE.equals( hintName ) ) {
 				applyCacheMode( ConfigurationHelper.getCacheMode( value ) );
 			}
 			else if ( HINT_FLUSH_MODE.equals( hintName ) ) {
 				applyFlushMode( ConfigurationHelper.getFlushMode( value ) );
 			}
 			else if ( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE.equals( hintName ) ) {
 				final CacheRetrieveMode retrieveMode = (CacheRetrieveMode) value;
 
 				CacheStoreMode storeMode = hints != null
 						? (CacheStoreMode) hints.get( AvailableSettings.SHARED_CACHE_STORE_MODE )
 						: null;
 				if ( storeMode == null ) {
 					storeMode = (CacheStoreMode) entityManager.getProperties()
 							.get( AvailableSettings.SHARED_CACHE_STORE_MODE );
 				}
 				applyCacheMode(
 						CacheModeHelper.interpretCacheMode( storeMode, retrieveMode )
 				);
 			}
 			else if ( AvailableSettings.SHARED_CACHE_STORE_MODE.equals( hintName ) ) {
 				final CacheStoreMode storeMode = (CacheStoreMode) value;
 
 				CacheRetrieveMode retrieveMode = hints != null
 						? (CacheRetrieveMode) hints.get( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE )
 						: null;
 				if ( retrieveMode == null ) {
 					retrieveMode = (CacheRetrieveMode) entityManager.getProperties()
 							.get( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE );
 				}
 				applyCacheMode(
 						CacheModeHelper.interpretCacheMode( storeMode, retrieveMode )
 				);
 			}
 			else if ( hintName.startsWith( AvailableSettings.ALIAS_SPECIFIC_LOCK_MODE ) ) {
 				if ( ! canApplyLockModes() ) {
 					skipped = true;
 				}
 				else {
 					// extract the alias
 					final String alias = hintName.substring( AvailableSettings.ALIAS_SPECIFIC_LOCK_MODE.length() + 1 );
 					// determine the LockMode
 					try {
 						final LockMode lockMode = LockModeTypeHelper.interpretLockMode( value );
 						applyAliasSpecificLockMode( alias, lockMode );
 					}
 					catch ( Exception e ) {
                         LOG.unableToDetermineLockModeValue(hintName, value);
 						skipped = true;
 					}
 				}
 			}
 			else {
 				skipped = true;
                 LOG.ignoringUnrecognizedQueryHint(hintName);
 			}
 		}
 		catch ( ClassCastException e ) {
 			throw new IllegalArgumentException( "Value for hint" );
 		}
 
 		if ( !skipped ) {
 			if ( hints == null ) {
 				hints = new HashMap<String,Object>();
 			}
 			hints.put( hintName, value );
 		}
 
 		return this;
 	}
 
 	public Set<String> getSupportedHints() {
 		return QueryHints.getDefinedHints();
 	}
 
 	public abstract TypedQuery<X> setLockMode(javax.persistence.LockModeType lockModeType);
 
 	public abstract javax.persistence.LockModeType getLockMode();
 
 	private FlushModeType jpaFlushMode;
 
 	public TypedQuery<X> setFlushMode(FlushModeType jpaFlushMode) {
 		this.jpaFlushMode = jpaFlushMode;
 		// TODO : treat as hint?
 		if ( jpaFlushMode == FlushModeType.AUTO ) {
 			applyFlushMode( FlushMode.AUTO );
 		}
 		else if ( jpaFlushMode == FlushModeType.COMMIT ) {
 			applyFlushMode( FlushMode.COMMIT );
 		}
 		return this;
 	}
 
 	protected FlushModeType getSpecifiedFlushMode() {
 		return jpaFlushMode;
 	}
 
 	public FlushModeType getFlushMode() {
 		return jpaFlushMode != null
 				? jpaFlushMode
 				: entityManager.getFlushMode();
 	}
 
 	private Map parameterBindings;
 
 	protected void registerParameterBinding(Parameter parameter, Object value) {
 		if ( value != null && parameter.getParameterType() != null ) {
 			if ( Collection.class.isInstance( value ) ) {
 				final Collection collection = (Collection) value;
 				// validate the elements...
 				for ( Object element : collection ) {
 					if ( ! parameter.getParameterType().isInstance( element ) ) {
 						throw new IllegalArgumentException(
 								"Parameter value [" + element + "] was not matching type [" +
 										parameter.getParameterType().getName() + "]"
 						);
 					}
 				}
 			}
 			else if ( value.getClass().isArray() && value.getClass().equals( Object[].class ) ) {
 				final Object[] array = (Object[]) value;
 				for ( Object element : array ) {
 					if ( ! parameter.getParameterType().isInstance( element ) ) {
 						throw new IllegalArgumentException(
 								"Parameter value [" + element + "] was not matching type [" +
 										parameter.getParameterType().getName() + "]"
 						);
 					}
 				}
 			}
 			else {
 				if ( ! parameter.getParameterType().isInstance( value ) ) {
 					throw new IllegalArgumentException(
 							"Parameter value [" + value + "] was not matching type [" +
 									parameter.getParameterType().getName() + "]"
 					);
 				}
 			}
 		}
 
 		if ( parameterBindings == null ) {
 			parameterBindings = new HashMap();
 		}
 		parameterBindings.put( parameter, value );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
     public boolean isBound(Parameter<?> param) {
 		return parameterBindings != null && parameterBindings.containsKey( param );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public <T> T getParameterValue(Parameter<T> param) {
 		if ( parameterBindings == null ) {
 			throw new IllegalStateException( "No parameters have been bound" );
 		}
 		try {
 			T value = (T) parameterBindings.get( param );
 			if ( value == null ) {
 				throw new IllegalStateException( "Parameter has not been bound" );
 			}
 			return value;
 		}
 		catch ( ClassCastException cce ) {
 			throw new IllegalStateException( "Encountered a parameter value type exception" );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Object getParameterValue(String name) {
 		return getParameterValue( getParameter( name ) );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Object getParameterValue(int position) {
 		return getParameterValue( getParameter( position ) );
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/QueryImpl.java b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/QueryImpl.java
index e1427304f9..074aff71d2 100755
--- a/hibernate-entitymanager/src/main/java/org/hibernate/ejb/QueryImpl.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/ejb/QueryImpl.java
@@ -1,638 +1,638 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009 by Red Hat Inc and/or its affiliates or by
  * third-party contributors as indicated by either @author tags or express
  * copyright attribution statements applied by the authors.  All
  * third-party contributions are distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.ejb;
 import static javax.persistence.TemporalType.DATE;
 import static javax.persistence.TemporalType.TIME;
 import static javax.persistence.TemporalType.TIMESTAMP;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.persistence.NoResultException;
 import javax.persistence.NonUniqueResultException;
 import javax.persistence.Parameter;
 import javax.persistence.PersistenceException;
 import javax.persistence.Query;
 import javax.persistence.TemporalType;
 import javax.persistence.TransactionRequiredException;
 import javax.persistence.TypedQuery;
 import org.hibernate.CacheMode;
 import org.hibernate.FlushMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.QueryParameterException;
 import org.hibernate.SQLQuery;
 import org.hibernate.TypeMismatchException;
 import org.hibernate.ejb.internal.EntityManagerMessageLogger;
 import org.hibernate.ejb.util.LockModeTypeHelper;
 import org.hibernate.engine.query.spi.NamedParameterDescriptor;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.query.spi.OrdinalParameterDescriptor;
-import org.hibernate.hql.QueryExecutionRequestException;
+import org.hibernate.hql.internal.QueryExecutionRequestException;
 import org.hibernate.internal.AbstractQueryImpl;
 import org.jboss.logging.Logger;
 
 /**
  * Hibernate implementation of both the {@link Query} and {@link TypedQuery} contracts.
  *
  * @author <a href="mailto:gavin@hibernate.org">Gavin King</a>
  * @author Emmanuel Bernard
  * @author Steve Ebersole
  */
 public class QueryImpl<X> extends org.hibernate.ejb.AbstractQueryImpl<X> implements TypedQuery<X>, HibernateQuery {
 
     public static final EntityManagerMessageLogger LOG = Logger.getMessageLogger(EntityManagerMessageLogger.class, QueryImpl.class.getName());
 
 	private org.hibernate.Query query;
 	private Set<Integer> jpaPositionalIndices;
 	private Set<Parameter<?>> parameters;
 
 	public QueryImpl(org.hibernate.Query query, AbstractEntityManagerImpl em) {
 		this( query, em, Collections.<String, Class>emptyMap() );
 	}
 
 	public QueryImpl(
 			org.hibernate.Query query,
 			AbstractEntityManagerImpl em,
 			Map<String,Class> namedParameterTypeRedefinitions) {
 		super( em );
 		this.query = query;
 		extractParameterInfo( namedParameterTypeRedefinitions );
 	}
 
 	@SuppressWarnings({ "unchecked", "RedundantCast" })
 	private void extractParameterInfo(Map<String,Class> namedParameterTypeRedefinition) {
 		if ( ! AbstractQueryImpl.class.isInstance( query ) ) {
 			throw new IllegalStateException( "Unknown query type for parameter extraction" );
 		}
 
 		HashSet<Parameter<?>> parameters = new HashSet<Parameter<?>>();
 		AbstractQueryImpl queryImpl = AbstractQueryImpl.class.cast( query );
 
 		// extract named params
 		for ( String name : (Set<String>) queryImpl.getParameterMetadata().getNamedParameterNames() ) {
 			final NamedParameterDescriptor descriptor =
 					queryImpl.getParameterMetadata().getNamedParameterDescriptor( name );
 			Class javaType = namedParameterTypeRedefinition.get( name );
 			if ( javaType != null && mightNeedRedefinition( javaType ) ) {
 				descriptor.resetExpectedType(
 						sfi().getTypeResolver().heuristicType( javaType.getName() )
 				);
 			}
 			else if ( descriptor.getExpectedType() != null ) {
 				javaType = descriptor.getExpectedType().getReturnedClass();
 			}
 			final ParameterImpl parameter = new ParameterImpl( name, javaType );
 			parameters.add( parameter );
 			if ( descriptor.isJpaStyle() ) {
 				if ( jpaPositionalIndices == null ) {
 					jpaPositionalIndices = new HashSet<Integer>();
 				}
 				jpaPositionalIndices.add( Integer.valueOf( name ) );
 			}
 		}
 
 		// extract positional parameters
 		for ( int i = 0, max = queryImpl.getParameterMetadata().getOrdinalParameterCount(); i < max; i++ ) {
 			final OrdinalParameterDescriptor descriptor =
 					queryImpl.getParameterMetadata().getOrdinalParameterDescriptor( i+1 );
 			ParameterImpl parameter = new ParameterImpl(
 					i + 1,
 					descriptor.getExpectedType() == null
 							? null
 							: descriptor.getExpectedType().getReturnedClass()
 			);
 			parameters.add( parameter );
 			Integer position = descriptor.getOrdinalPosition();
             if (jpaPositionalIndices != null && jpaPositionalIndices.contains(position)) LOG.parameterPositionOccurredAsBothJpaAndHibernatePositionalParameter(position);
 		}
 
 		this.parameters = java.util.Collections.unmodifiableSet( parameters );
 	}
 
 	private SessionFactoryImplementor sfi() {
 		return (SessionFactoryImplementor) getEntityManager().getFactory().getSessionFactory();
 	}
 
 	private boolean mightNeedRedefinition(Class javaType) {
 		// for now, only really no for dates/times/timestamps
 		return java.util.Date.class.isAssignableFrom( javaType );
 	}
 
 	private static class ParameterImpl implements Parameter {
 		private final String name;
 		private final Integer position;
 		private final Class javaType;
 
 		private ParameterImpl(String name, Class javaType) {
 			this.name = name;
 			this.javaType = javaType;
 			this.position = null;
 		}
 
 		private ParameterImpl(Integer position, Class javaType) {
 			this.position = position;
 			this.javaType = javaType;
 			this.name = null;
 		}
 
 		public String getName() {
 			return name;
 		}
 
 		public Integer getPosition() {
 			return position;
 		}
 
 		public Class getParameterType() {
 			return javaType;
 		}
 	}
 
 	public org.hibernate.Query getHibernateQuery() {
 		return query;
 	}
 
 	@Override
     protected int internalExecuteUpdate() {
 		return query.executeUpdate();
 	}
 
 	@Override
     protected void applyMaxResults(int maxResults) {
 		query.setMaxResults( maxResults );
 	}
 
 	@Override
     protected void applyFirstResult(int firstResult) {
 		query.setFirstResult( firstResult );
 	}
 
 	@Override
     protected void applyTimeout(int timeout) {
 		query.setTimeout( timeout );
 	}
 
 	@Override
     protected void applyComment(String comment) {
 		query.setComment( comment );
 	}
 
 	@Override
     protected void applyFetchSize(int fetchSize) {
 		query.setFetchSize( fetchSize );
 	}
 
 	@Override
     protected void applyCacheable(boolean isCacheable) {
 		query.setCacheable( isCacheable );
 	}
 
 	@Override
     protected void applyCacheRegion(String regionName) {
 		query.setCacheRegion( regionName );
 	}
 
 	@Override
     protected void applyReadOnly(boolean isReadOnly) {
 		query.setReadOnly( isReadOnly );
 	}
 
 	@Override
     protected void applyCacheMode(CacheMode cacheMode) {
 		query.setCacheMode( cacheMode );
 	}
 
 	@Override
     protected void applyFlushMode(FlushMode flushMode) {
 		query.setFlushMode( flushMode );
 	}
 
 	@Override
     protected boolean canApplyLockModes() {
 		return org.hibernate.internal.QueryImpl.class.isInstance( query );
 	}
 
 	@Override
 	protected void applyAliasSpecificLockMode(String alias, LockMode lockMode) {
 		( (org.hibernate.internal.QueryImpl) query ).getLockOptions().setAliasSpecificLockMode( alias, lockMode );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@SuppressWarnings({ "unchecked", "RedundantCast" })
 	public List<X> getResultList() {
 		try {
 			return query.list();
 		}
 		catch (QueryExecutionRequestException he) {
 			throw new IllegalStateException(he);
 		}
 		catch( TypeMismatchException e ) {
 			throw new IllegalArgumentException(e);
 		}
 		catch (HibernateException he) {
 			throw getEntityManager().convert( he );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@SuppressWarnings({ "unchecked", "RedundantCast" })
 	public X getSingleResult() {
 		try {
 			boolean mucked = false;
 			// IMPL NOTE : the mucking with max results here is attempting to help the user from shooting themselves
 			//		in the foot in the case where they have a large query by limiting the query results to 2 max
 			//    SQLQuery cannot be safely paginated, leaving the user's choice here.
 			if ( getSpecifiedMaxResults() != 1 &&
 					! ( SQLQuery.class.isAssignableFrom( query.getClass() ) ) ) {
 				mucked = true;
 				query.setMaxResults( 2 ); //avoid OOME if the list is huge
 			}
 			List<X> result = query.list();
 			if ( mucked ) {
 				query.setMaxResults( getSpecifiedMaxResults() );
 			}
 
 			if ( result.size() == 0 ) {
 				NoResultException nre = new NoResultException( "No entity found for query" );
 				getEntityManager().handlePersistenceException( nre );
 				throw nre;
 			}
 			else if ( result.size() > 1 ) {
 				Set<X> uniqueResult = new HashSet<X>(result);
 				if ( uniqueResult.size() > 1 ) {
 					NonUniqueResultException nure = new NonUniqueResultException( "result returns more than one elements" );
 					getEntityManager().handlePersistenceException( nure );
 					throw nure;
 				}
 				else {
 					return uniqueResult.iterator().next();
 				}
 
 			}
 			else {
 				return result.get( 0 );
 			}
 		}
 		catch (QueryExecutionRequestException he) {
 			throw new IllegalStateException(he);
 		}
 		catch( TypeMismatchException e ) {
 			throw new IllegalArgumentException(e);
 		}
 		catch (HibernateException he) {
 			throw getEntityManager().convert( he );
 		}
 	}
 
 	public <T> TypedQuery<X> setParameter(Parameter<T> param, T value) {
 		if ( ! parameters.contains( param ) ) {
 			throw new IllegalArgumentException( "Specified parameter was not found in query" );
 		}
 		if ( param.getName() != null ) {
 			// a named param, for not delegate out.  Eventually delegate *into* this method...
 			setParameter( param.getName(), value );
 		}
 		else {
 			setParameter( param.getPosition(), value );
 		}
 		return this;
 	}
 
 	public TypedQuery<X> setParameter(Parameter<Date> param, Date value, TemporalType temporalType) {
 		if ( ! parameters.contains( param ) ) {
 			throw new IllegalArgumentException( "Specified parameter was not found in query" );
 		}
 		if ( param.getName() != null ) {
 			// a named param, for not delegate out.  Eventually delegate *into* this method...
 			setParameter( param.getName(), value, temporalType );
 		}
 		else {
 			setParameter( param.getPosition(), value, temporalType );
 		}
 		return this;
 	}
 
 	public TypedQuery<X> setParameter(Parameter<Calendar> param, Calendar value, TemporalType temporalType) {
 		if ( ! parameters.contains( param ) ) {
 			throw new IllegalArgumentException( "Specified parameter was not found in query" );
 		}
 		if ( param.getName() != null ) {
 			// a named param, for not delegate out.  Eventually delegate *into* this method...
 			setParameter( param.getName(), value, temporalType );
 		}
 		else {
 			setParameter( param.getPosition(), value, temporalType );
 		}
 		return this;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public TypedQuery<X> setParameter(String name, Object value) {
 		try {
 			if ( value instanceof Collection ) {
 				query.setParameterList( name, (Collection) value );
 			}
 			else {
 				query.setParameter( name, value );
 			}
 			registerParameterBinding( getParameter( name ), value );
 			return this;
 		}
 		catch (QueryParameterException e) {
 			throw new IllegalArgumentException( e );
 		}
 		catch (HibernateException he) {
 			throw getEntityManager().convert( he );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public TypedQuery<X> setParameter(String name, Date value, TemporalType temporalType) {
 		try {
 			if ( temporalType == DATE ) {
 				query.setDate( name, value );
 			}
 			else if ( temporalType == TIME ) {
 				query.setTime( name, value );
 			}
 			else if ( temporalType == TIMESTAMP ) {
 				query.setTimestamp( name, value );
 			}
 			registerParameterBinding( getParameter( name ), value );
 			return this;
 		}
 		catch (QueryParameterException e) {
 			throw new IllegalArgumentException( e );
 		}
 		catch (HibernateException he) {
 			throw getEntityManager().convert( he );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public TypedQuery<X> setParameter(String name, Calendar value, TemporalType temporalType) {
 		try {
 			if ( temporalType == DATE ) {
 				query.setCalendarDate( name, value );
 			}
 			else if ( temporalType == TIME ) {
 				throw new IllegalArgumentException( "not yet implemented" );
 			}
 			else if ( temporalType == TIMESTAMP ) {
 				query.setCalendar( name, value );
 			}
 			registerParameterBinding( getParameter(name), value );
 			return this;
 		}
 		catch (QueryParameterException e) {
 			throw new IllegalArgumentException( e );
 		}
 		catch (HibernateException he) {
 			throw getEntityManager().convert( he );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public TypedQuery<X> setParameter(int position, Object value) {
 		try {
 			if ( isJpaPositionalParameter( position ) ) {
 				this.setParameter( Integer.toString( position ), value );
 			}
 			else {
 				query.setParameter( position - 1, value );
 				registerParameterBinding( getParameter( position ), value );
 			}
 			return this;
 		}
 		catch (QueryParameterException e) {
 			throw new IllegalArgumentException( e );
 		}
 		catch (HibernateException he) {
 			throw getEntityManager().convert( he );
 		}
 	}
 
 	private boolean isJpaPositionalParameter(int position) {
 		return jpaPositionalIndices != null && jpaPositionalIndices.contains( position );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public TypedQuery<X> setParameter(int position, Date value, TemporalType temporalType) {
 		try {
 			if ( isJpaPositionalParameter( position ) ) {
 				String name = Integer.toString( position );
 				this.setParameter( name, value, temporalType );
 			}
 			else {
 				if ( temporalType == DATE ) {
 					query.setDate( position - 1, value );
 				}
 				else if ( temporalType == TIME ) {
 					query.setTime( position - 1, value );
 				}
 				else if ( temporalType == TIMESTAMP ) {
 					query.setTimestamp( position - 1, value );
 				}
 				registerParameterBinding( getParameter( position ), value );
 			}
 			return this;
 		}
 		catch (QueryParameterException e) {
 			throw new IllegalArgumentException( e );
 		}
 		catch (HibernateException he) {
 			throw getEntityManager().convert( he );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public TypedQuery<X> setParameter(int position, Calendar value, TemporalType temporalType) {
 		try {
 			if ( isJpaPositionalParameter( position ) ) {
 				String name = Integer.toString( position );
 				this.setParameter( name, value, temporalType );
 			}
 			else {
 				if ( temporalType == DATE ) {
 					query.setCalendarDate( position - 1, value );
 				}
 				else if ( temporalType == TIME ) {
 					throw new IllegalArgumentException( "not yet implemented" );
 				}
 				else if ( temporalType == TIMESTAMP ) {
 					query.setCalendar( position - 1, value );
 				}
 				registerParameterBinding( getParameter( position ), value );
 			}
 			return this;
 		}
 		catch (QueryParameterException e) {
 			throw new IllegalArgumentException( e );
 		}
 		catch (HibernateException he) {
 			throw getEntityManager().convert( he );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Set<Parameter<?>> getParameters() {
 		return parameters;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Parameter<?> getParameter(String name) {
 		if ( name == null ) {
 			throw new IllegalArgumentException( "Name of parameter to locate cannot be null" );
 		}
 		for ( Parameter parameter : parameters ) {
 			if ( name.equals( parameter.getName() ) ) {
 				return parameter;
 			}
 		}
 		throw new IllegalArgumentException( "Unable to locate parameter named [" + name + "]" );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Parameter<?> getParameter(int position) {
 		if ( isJpaPositionalParameter( position ) ) {
 			return getParameter( Integer.toString( position ) );
 		}
 		else {
 			for ( Parameter parameter : parameters ) {
 				if ( parameter.getPosition() != null && position == parameter.getPosition() ) {
 					return parameter;
 				}
 			}
 			throw new IllegalArgumentException( "Unable to locate parameter with position [" + position + "]" );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public <T> Parameter<T> getParameter(String name, Class<T> type) {
 		Parameter param = getParameter( name );
 		if ( param.getParameterType() != null ) {
 			// we were able to determine the expected type during analysis, so validate it here
 			throw new IllegalArgumentException(
 					"Parameter type [" + param.getParameterType().getName() +
 							"] is not assignment compatible with requested type [" +
 							type.getName() + "]"
 			);
 		}
 		return param;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public <T> Parameter<T> getParameter(int position, Class<T> type) {
 		Parameter param = getParameter( position );
 		if ( param.getParameterType() != null ) {
 			// we were able to determine the expected type during analysis, so validate it here
 			throw new IllegalArgumentException(
 					"Parameter type [" + param.getParameterType().getName() +
 							"] is not assignment compatible with requested type [" +
 							type.getName() + "]"
 			);
 		}
 		return param;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public <T> T unwrap(Class<T> tClass) {
 		if ( org.hibernate.Query.class.isAssignableFrom( tClass ) ) {
 			return (T) query;
 		}
 		else {
 			try {
 				return (T) this;
 			}
 			catch ( ClassCastException cce ) {
 				PersistenceException pe = new PersistenceException(
 						"Unsupported unwrap target type [" + tClass.getName() + "]"
 				);
 				//It's probably against the spec to not mark the tx for rollback but it will be easier for people
 				//getEntityManager().handlePersistenceException( pe );
 				throw pe;
 			}
 		}
 	}
 
 	private javax.persistence.LockModeType jpaLockMode = javax.persistence.LockModeType.NONE;
 
 	@Override
     @SuppressWarnings({ "unchecked" })
 	public TypedQuery<X> setLockMode(javax.persistence.LockModeType lockModeType) {
 		if (! getEntityManager().isTransactionInProgress()) {
 			throw new TransactionRequiredException( "no transaction is in progress" );
 		}
 		if ( ! canApplyLockModes() ) {
 			throw new IllegalStateException( "Not a JPAQL/Criteria query" );
 		}
 		this.jpaLockMode = lockModeType;
 		( (org.hibernate.internal.QueryImpl) query ).getLockOptions().setLockMode(
 				LockModeTypeHelper.getLockMode( lockModeType )
 		);
 		return this;
 	}
 
 	@Override
     public javax.persistence.LockModeType getLockMode() {
 		return jpaLockMode;
 	}
 
 }
